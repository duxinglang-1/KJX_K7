/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*****************************************************************************
 *
 * Filename:
 * ---------
 *   w32_audio.c
 *
 * Project:
 * --------
 *   Maui
 *
 * Description:
 * ------------
 *   L1Audio dummy functions for WIN32 environment
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/
#include <windows.h>
#include <math.h>
#include "time.h"

#include "kal_release.h"

#include "stack_common.h"
#include "stack_msgs.h"
#include "app_ltlcom.h"

#include "stacklib.h"
#include "stack_timer.h"

#include "syscomp_config.h"
#include "task_config.h"

#include "device.h"
//#include "w32_timers.h"
#include "rtc_sw.h"
#include "l4a.h"
#include "uart_sw.h"
#include "drvsignals.h"

#include "l1audio.h"
#include "fmr_common_api.h"
#include "fmr_rds_api.h"

static MHdl mhdl;
static Media_iMelody_Param iMelody_Param;
static Media_Wav_Param Wav_Param;
static Media_ToneSeq_Param ToneSeq_Param;
static Media_AMR_Param AMR_Param;
static Media_SMF_Param SMF_Param;

L1SP_TurnOnFIR(){};
L1SP_TurnOffFIR(){};
L1SP_IsFIROn(){};

void l1audio_console_handler(kal_char *string) {}
void l1audio_consoleDVT(kal_char *string) {}

void        Spc_Speech_On( kal_uint8 RAT_Mode ){}
void        Spc_Speech_Off( void ){}
void        Spc_SetMicrophoneVolume( kal_uint8 mic_volume ){}
void        Spc_SetSidetoneVolume( kal_uint8 sidetone ){}
void        Spc_Default_Tone_Play(kal_uint8 toneIdx){}
void        Spc_Default_Tone_Stop( void ){}
void        Spc_SetOutputVolume( kal_uint8 volume1, kal_int8 digital_gain_index ){} 
void        Spc_SetInputSource( kal_uint8 src ){}
void        Spc_SetOutputDevice( kal_uint8 device ){}
void        Spc_SetSpeechMode_Adaptation( kal_uint8 mode ){}
void        Spc_ReceiveEMParameter(kal_uint8* buffer, kal_uint16 len){}
void        Spc_ATCommand(kal_uint32 uLen, kal_uint8 *pCmd){}

void        L1SP_SetCordLessPath( kal_uint8 uPath ){}
void        L1SP_SetNvramInfoByIndex(L1SP_NVRAM_INFO_INDEX index,kal_uint8* buffer, kal_uint16 len){}
void        L1SP_MutePCMOuputPort( kal_bool fMute ){}
void        L1SP_SetOutputDevice( kal_uint8 device ) {}
void        L1SP_LoadCommonSpeechPara( kal_uint16* c_para) {}
void        L1SP_SetSpeechMode( kal_uint8 mode, kal_uint16* m_para) {}
void        L1SP_SetWbSpeechPara( kal_uint16* m_para ) {}
void        L1SP_SetOutputVolume( kal_uint8 volume1, kal_int8 digital_gain_index ){}
void        L1SP_SetSpeechVolumeLevel( kal_uint8 level, kal_uint16* v_para ) {}
void        L1SP_Speech_On( void ){}
void        L1SP_Speech_Off( void ){}
void        L1SP_Afe_On( kal_uint32 afe_mode ){}
void        L1SP_Afe_Off( void ){}
void        L1SP_SetInputSource( kal_uint8 src ){}
kal_uint8   L1SP_GetInputSource( void ){return 0;}
void        L1SP_SetMicrophoneVolume( kal_uint8 mic_volume ){}
kal_uint8   L1SP_GetMicrophoneVolume( void ){return 0;}
void        L1SP_SetSidetoneVolume( kal_uint8 sidetone ){}
kal_uint8   L1SP_GetSidetoneVolume( void ){return 0;}
void        L1SP_MuteMicrophone( kal_bool mute ){}
void        L1SP_MuteSpeaker( kal_bool mute ){}
kal_bool    L1SP_IsMicrophoneMuted( void ){return 0;}
kal_bool    L1SP_IsSpeechOn( void ){return 0;}
void        L1SP_SetFIR( kal_bool enable ){}
void        L1SP_SetEchoSuppression( kal_bool ec ){}
void        L1SP_SetEchoSuppressionParameter( kal_uint16 timeConst, kal_uint16 volConst ){}
void        L1SP_Set_DAI_Mode( kal_uint8 mode ){}
void        L1SP_Write_Audio_Coefficients( const kal_int16 in_coeff[30], const kal_int16 out_coeff[30] ){}
void        L1SP_Write_WB_Audio_Coefficients( const kal_int16 in_coeff[90], const kal_int16 out_coeff[90] ){}
void        L1SP_SetAfeLoopback( kal_bool enable ){}
void        L1SP_SetAfeLoopback2( kal_bool enable ){}
kal_bool    L1SP_GetAfeLoopbackStatus( void ){}
void        L1SP_SetDualMicNR( kal_bool enable ){}
#define     FIRST_MIC (0) 
kal_uint32  L1SP_GetFrameIntensity(kal_uint32 channel){}
void        L1SP_GetIntensityExtremeValues(kal_uint32 *p_intensity_max_value, kal_uint32 *p_intensity_min_value){}

void L1SP_Write_Audio_Coefficients_ByFirIndex( const kal_uint8 inOrOut2FirIndex, const kal_uint8 outFirIndex){}
void L1SP_SetSpeechVolumeLevelByIndex(kal_uint8 level, kal_uint8 v_paraIndex){}
void L1SP_SetSpeechEnhanceAndFir(kal_uint32 scene, kal_uint32 updatedCoeff){}
void L1SP_GetNvramInfoByIndex(L1SP_NVRAM_INFO_INDEX index, void *buffer, kal_uint16 len){}
kal_int16 L1SP_GetNumOfAllEnhancementMode(void){ return 8; }
kal_int16 L1SP_GetNumOfAllFir(kal_uint8 isWideBand, kal_uint8 isOutputFir){ return 6; }
kal_int16 L1SP_GetAllEnhancementModeCategory(kal_int16 inputBufLength, kal_int16 *categoryResult){ return 1;}
kal_int16 L1SP_GetAllEnhancementModeName(kal_int16 inputBufLength, kal_char *nameResult){return 8;}
kal_int16 L1SP_GetAllEnhancementCategoryName(kal_int16 inputBufLength, kal_char *categoryName){return 1; }
kal_int16 L1SP_GetNumOfAllEnhancementCategory(void){return 1;}
kal_int16 L1SP_GetNumOfAllEnhancementCategoryParam(kal_int16 inputBufLength, kal_int16 *paramNumOfCatg){return 16;}


void        AcousticLoopbackOn (void){}
void        AcousticLoopbackOff (void){}
void        AcousticLoopbackSpeechMode (kal_uint8 u1Mode){}
kal_bool    AcousticLoopbackStatus(void){}
void        AcousticLoopbackBypassMode (kal_uint8 u1Mode){}
void        AcousticLoopbackLength (kal_uint32 u4Length){}

#define     L1SP_DEFAULT_ACOUSTIC_LOOPBACK_LENGTH (1024) 
void        L1SP_AcousticLoopbackOn (void){}
void        L1SP_AcousticLoopbackOff (void){}
void        L1SP_AcousticLoopbackSpeechMode (kal_uint8 u1Mode){}
kal_bool    L1SP_AcousticLoopbackStatus(void){}
void        L1SP_AcousticLoopbackBypassMode (kal_uint8 u1Mode){}
void        L1SP_AcousticLoopbackLength (kal_uint32 u4Length){}

void        ABF_SetAcousticLoopback( kal_bool loopback ){}
kal_bool    ABF_GetAcousticLoopbackStatus( void ){}

void        L1SP_SetDMNRPara( kal_int16 DMNR_para[44] ){}
void        L1SP_SetWbDMNRPara( kal_int16 WB_DMNR_para[76] ){}

void        LINEIN_SetOutputDevice( kal_uint8 device ){}
void        LINEIN_SetOutputVolume( kal_uint8 volume1, kal_int8 digital_gain_index ){}
void        LINEIN_Open( void ){}
void        LINEIN_Close( void ){}
void        LINEIN_MuteSpeaker( kal_bool mute ){}
#if defined(__GAIN_TABLE_SUPPORT__)
void LINEIN_SetOutputGainControl (kal_uint32 gain){}
void LINEIN_SetOutputGainControlDualPath( kal_uint32 ext_amp_gain ){}
#endif


/* ------------------------------------------------------------------------------ */
/*  Key Tone Interface                                                            */
/* ------------------------------------------------------------------------------ */
void  KT_SetOutputDevice( kal_uint8 device ){}
void  KT_SetOutputVolume( kal_uint8 volume1, kal_int8 digital_gain_index ){}

void  KT_Stop( void ){}
void  KT_StopAndWait( void ){}
void  KT_SetAmplitude( kal_int16 amp ){}
void  KT_SetFIR( kal_bool enable ){}
kal_bool KT_IsPlayable(void){return 0;}



void  TONE_SetOutputDevice( kal_uint8 device ) {}
void  TONE_SetOutputVolume( kal_uint8 volume1, kal_int8 digital_gain_index ){}

void  TONE_Stop( void ){}
void  TONE_StopAndWait( void ){}
void  TONE_SetAmplitude( kal_int16 amp ){}
void  TONE_SetFIR( kal_bool enable ){}
void  TONE_PlayQTMF( const L1SP_QTMF *tonelist ){} /* QTMF Play Interface */

void Media_PowerOff(void){}
void AFE_FastCloseSpk(void){}
void AFE_AudAccDetInit(void){} 
void AFE_DC_Calibration(kal_uint16* pwdc_offset, void(*DC_Calibration_CallBack)(kal_uint16 *pwdc_offset)){} 
void AFE_DC_Calibration_Register_Callback( void(*DC_Calibration_CallBack2)(kal_uint32 msg_name, void *data)){}
void AFE_Retrieve_DC_Cali_Data(kal_int32 data){}
kal_bool AFE_SPKAMP_OCDetect(void){return 0;}

void Media_SetVibrInitParam(void *pBuf, kal_uint32 uLen){}
void Media_VIB_Calibration_Write(void(*VIB_Calibration_CallBack)(void *cali_data)){}
void Media_Vibrate_CF_Check(void){}
kal_bool Media_Is_Vibrator_Calibration(void){return KAL_TRUE;}
Media_CaliType Media_GetCalibrationType(void){return 0;}
void AFE_Retrieve_VIB_CF_Data(kal_int32 data){}

Media_Status  Media_SpkVibration_Enable( kal_bool fEnable ){return MEDIA_SUCCESS;}
void  Media_EnableVolumeProtection(kal_bool enable){}
void  Media_SetOutputDevice( kal_uint8 device ){}
void  Media_SetOutputVolume( kal_uint8 volume1, kal_int8 digital_gain_index ){}
void  Media_SetBuffer( kal_uint16 *buffer, kal_uint32 buf_len ){}
void  Media_MuteSpeaker( kal_bool mute ){}
void  Media_SetRecordedStopTime( kal_uint32 uStopTime ){}
Media_Status  Media_Play( Media_Format format, void (*media_handler)( Media_Event event ), void *param ){return MEDIA_SUCCESS;}
Media_Status  Media_Record( Media_Format format, void (*media_handler)( Media_Event event ), void *param ){return MEDIA_SUCCESS;}
Media_Status  Media_RecordAppendable( Media_Format format, FS_HANDLE fs, Media_Record_File_Info *info ){return MEDIA_SUCCESS;}
Media_Status  Media_Control( Media_Ctrl ctrl_no, kal_int32 ctrl_val ){return MEDIA_SUCCESS;}
void  Media_Stop( void ){}
void  Media_GetWriteBuffer( kal_uint16 **buffer, kal_uint32 *buf_len ){}
void  Media_WriteDataDone( kal_uint32 len ){}
void  Media_DataFinished( void ){}
void  Media_GetReadBuffer( kal_uint16 **buffer, kal_uint32 *buf_len ){}
void  Media_ReadDataDone( kal_uint32 len ){}
void Media_GetMaxMinRate(Media_Format eFormat, kal_int32* max, kal_int32* min)
{
   switch(eFormat){
      case MEDIA_FORMAT_SMF:
      case MEDIA_FORMAT_JTS:
         *max = 400*1000;
         *min =  25*1000;
         break;
      default:
         *max = 160*1000;
         *min =  50*1000;
         break;
   }
}
void Media_GetMMACapability(Media_Format eFormat, kal_uint8* concurrent)
{
   switch(eFormat){
      case MEDIA_FORMAT_SMF:
         *concurrent = 4;
         break;
      case MEDIA_FORMAT_IMELODY:
         *concurrent = 1;
         break;
      case MEDIA_FORMAT_JTS:
         *concurrent = 3;
         break;
      case MEDIA_FORMAT_WAV:
         *concurrent = 4;
         break;    
      default:
         *concurrent = 1;
         break;
   }
}
Media_Status Media_FastPassMode(void* hdl, Media_Format eFormat){return MEDIA_SUCCESS;}
kal_uint32 Media_GetSpeechFeatureCapability(void)
{
	return MEDIA_SPEECH_FEATURE_NONE;
}

Media_Status Media_SetLevel( kal_uint8 level ){return MEDIA_SUCCESS;}
kal_uint32   Media_GetRecordedTime( void ) {return 5000;}
kal_int32 Media_GetDataCount( void ) {return 0;}
kal_bool      Media_IsPlaybackOn( void ) {return KAL_TRUE;}
void          Media_SetUserData(Media_Handle *hdl, void* pAppData){}
void          Media_GetUserData(Media_Handle *hdl, void** pAppData){}

typedef void (*play_finish_ind_func)(void);
static play_finish_ind_func play_finish_ind_handler=NULL;
void  TONE_SetHandler( void (*handler)(void) )
{
	play_finish_ind_handler = (handler);
}

#define SAMPLE_PER_SECOND	11025			  // sample per seconds
#define MAX_TONE_SECONDS	10				
#define PI            3.14159265358979

static HWAVEOUT     hWaveOut;          // Handle to sound card output
static WAVEHDR      WaveHeader;        // WAVE header for our sound data
static WAVEFORMATEX WaveFormat;        // The sound format

static char			tone_buffer[SAMPLE_PER_SECOND*MAX_TONE_SECONDS];
static const L1SP_Tones *current_tone;
static const L1SP_Tones	*tone_root;
static kal_bool is_busy;
static void CALLBACK w32_tone_play_finish(HWAVEOUT hwo,UINT uMsg,DWORD dwInstance,DWORD dwParam1,DWORD dwParam2)
{
	switch(uMsg)
	{
	case WOM_OPEN:
		return;
	case WOM_CLOSE:
		return;
	case WOM_DONE:
		break;
	}
	if(!current_tone)
	{
		if(play_finish_ind_handler)
			play_finish_ind_handler();

		if (waveOutUnprepareHeader(hWaveOut,&WaveHeader,sizeof(WaveHeader)) != MMSYSERR_NOERROR)
			return ;
		is_busy = KAL_FALSE;
		return;
	}


	// ** Make the sound buffer **
	{
		int i;
		double x;
		
		int total_bytes = current_tone->on_duration *SAMPLE_PER_SECOND/1000;
		if(total_bytes > SAMPLE_PER_SECOND*MAX_TONE_SECONDS)
			total_bytes = SAMPLE_PER_SECOND*MAX_TONE_SECONDS;
		
		for(i=0;i<total_bytes;i++)
		{
			x = sin(i*2.0*PI*current_tone->freq1/(double)SAMPLE_PER_SECOND);
	        // ** scale x to a range of 0-255 (signed char) for 8 bit sound reproduction **
			tone_buffer[i] = (char)(127*x+128);
		}
		// ** Create the wave header for our sound buffer **
		WaveHeader.lpData=tone_buffer;
		WaveHeader.dwBufferLength=total_bytes;
		WaveHeader.dwFlags=WHDR_DONE;
		WaveHeader.dwLoops=0;
	}
    
    // ** Prepare the header for playback on sound card **
    if (waveOutPrepareHeader(hWaveOut,&WaveHeader,sizeof(WaveHeader)) != MMSYSERR_NOERROR)
        return;
    
	is_busy = KAL_TRUE;
	// ** Play the sound! **
    if (waveOutWrite(hWaveOut,&WaveHeader,sizeof(WaveHeader)) != MMSYSERR_NOERROR)
        return;

	// move to next tone
	if(current_tone->next_tone==0)
		current_tone = NULL;
	else
		current_tone = &(tone_root[current_tone->next_tone]);

}

void w32_audio_init(void)
{
    // ** Initialize the sound format we will request from sound card **    
    WaveFormat.wFormatTag = WAVE_FORMAT_PCM;		// Uncompressed sound format
    WaveFormat.nChannels = 1;						// 1=Mono 2=Stereo
    WaveFormat.wBitsPerSample = 8;					// Bits per sample per channel
    WaveFormat.nSamplesPerSec = SAMPLE_PER_SECOND;           // Sample Per Second
    WaveFormat.nBlockAlign = WaveFormat.nChannels * WaveFormat.wBitsPerSample / 8;
    WaveFormat.nAvgBytesPerSec = WaveFormat.nSamplesPerSec * WaveFormat.nBlockAlign;    
    WaveFormat.cbSize = 0;

	current_tone = NULL;
	is_busy = KAL_FALSE;

    // ** Open the audio device **
    if (waveOutOpen(&hWaveOut,0,&WaveFormat,(DWORD) w32_tone_play_finish,0,CALLBACK_FUNCTION) != MMSYSERR_NOERROR) 
    {        
        return;
    }

}



void  TONE_Play( const L1SP_Tones *tonelist )
{
	if(is_busy) return;
	
	current_tone = tone_root = tonelist;
	w32_tone_play_finish(0,WOM_DONE,0,0,0);
}

//static L1SP_Tones kt_tone[128];
//static int kt_tone_index=0;
void  KT_Play( kal_uint16 freq1, kal_uint16 freq2, kal_uint16 duration )
{
	/*
	if(is_busy) return;
	kt_tone_index ++;
	kt_tone_index %=128;
	kt_tone[kt_tone_index].freq1 = freq1;
	kt_tone[kt_tone_index].freq2 = freq2;
	kt_tone[kt_tone_index].on_duration = duration;
	kt_tone[kt_tone_index].next_tone = 0;
	TONE_Play(&(kt_tone[kt_tone_index]));
	*/
}

void L1SP_NormalMode_SetAECParameter(void){}
void L1SP_NormalMode_SetAEC(void){}
void wavSetAdpcmState(void){}
void mediaIsDataConsumed( void ){}
void mediaGetDataCount( void ){}
void amrGetDataCount(void){}
void AEQ_SetAudioEqualizer( kal_int8 magnitude[8] ){}
void AEQ_Activate( kal_int16 asp_fs, kal_bool rampup ){}
/* l1audio internal use */
kal_uint32 AMR_DediEnc_BufferSize( void ){return 0;}
kal_uint16 AMR_DediEnc_SetBuffer( void *buf, kal_uint32 buf_size ){return 0;}
Media_Status PoC_AMR_EncodeStart( PoC_AMR_Type vocoder, void (*media_handler)(void), kal_int32 frame_threshold ) {	return MEDIA_SUCCESS;}
void PoC_AMR_SetBuffer(kal_uint16 *buf, kal_uint32 len){}
PoC_AMR_Type PoC_AMR_GetVocoderCapability(void){return 0;}
Media_Status PoC_AMR_EncodeStop( void ){return MEDIA_SUCCESS;}
Media_Status PoC_AMR_DecodeStart( void ){return MEDIA_SUCCESS;}
Media_Status PoC_AMR_DecodeStop( void ){return MEDIA_SUCCESS;}
kal_int32 PoC_AMR_GetFrameCount( void ){return 0;}
kal_int32 PoC_AMR_GetPayload( kal_uint8 *buf, kal_int32 len, kal_int32 frames ){return 0;}
Media_Status PoC_AMR_PutPayload( const kal_uint8 *buf, kal_int32 len ){return MEDIA_SUCCESS;}


kal_bool NANDsanitycheck_Factory(void) {return KAL_TRUE;}
void EINT_Set_HW_Debounce(kal_uint8 eintno, kal_uint32 ms) {}

/* Dummy Audio Post Process Interface */
kal_bool AudioPP_TS_IsSupport(Media_Format eFormat, STFSAL *pstFSAL) { return KAL_TRUE; }
Media_Status AudioPP_TS_SetSpeed(kal_uint16 speed_mode) { return 0; }
void AudioPP_TS_Close(void) {}
void AudioPP_Reverb_SetMode(kal_uint32 mode) {}
Media_Status AudioPP_Reverb_TurnOn( void ) {return 0;}
void AudioPP_Reverb_TurnOff(void) {}

	
void  Media_SetMelodyFilter( kal_uint16 len, const kal_int16 *filter ){}


/* FM Radio Interface */
void  FMR_PowerOn(void){}
void  FMR_PowerOff(void){}
kal_uint8 FMR_ValidStop(kal_int16 freq, kal_int8 signalvl, kal_bool is_step_up){return 0;}
void  FMR_SetFreq(kal_int16 curf){}
void FMR_AutoSearch(kal_uint8 dir, void(*fm_handler)(kal_int16 *data)){}
kal_int16 FMR_ManualSearch(kal_uint8 dir){return 0;}
kal_int16 FMR_GetFreq(void){return 0;}
void  FMR_Mute(kal_uint8 mute){}
void  FMR_Mono(kal_uint8 MS){}
void  FMR_Standby(kal_uint8 standby){}
void FMR_SetOutputDevice( kal_uint8 device ){}
void  FMR_SetOutputVolume( kal_uint8 volume1, kal_int8 digital_gain_index ){}
kal_uint8 FMR_GetSignalLevel(kal_int16 curf){return 0;}
void FMR_RDS_EnableAF(kal_bool b_AFON){}
void FMR_RDS_EnableTP(kal_bool b_TPON){}
void FMR_EvaluateRSSIThreshold(void){}
void FMR_Radio_EngineerMode(kal_uint16 group_idx, kal_uint16 item_idx, kal_uint32 item_value){}
kal_bool FMR_HWSearch( void (*callback)( kal_int16 wFreq, kal_uint8 wSignal_Lv, kal_bool is_valid ), kal_int16 wStartFreq, kal_bool is_up, kal_int16 wSpace, kal_bool is_preset ){}
void FMR_HWSearchForceStop(void){}
kal_bool FMR_IsActive(void){}
void FMR_SetAntennaType(kal_uint8 ata_type){}
kal_uint32 FMR_GetCapArray(void){return 0;}
void FMR_Set_AntennaType(fmr_antenna_type_enum type){}
fmr_antenna_type_enum FMR_Get_AntennaType(void){return 1;}
kal_uint32 FMR_Get_RSSI_Threshold(fmr_antenna_type_enum type){return 0;}
void FMR_Set_RSSI_Threshold(fmr_antenna_type_enum type, kal_uint32 value){return 0;}
kal_int32 FMR_RSSI_Hex2Db(kal_uint32 Hex){return 0;}
kal_uint32 FMR_RSSI_Db2Hex(kal_int32 Db){return 0;}
fmr_sound_track_type_enum FMR_Get_Sound_Track(void){return 0;}
void FMR_Force_Mono(void){}
void FMR_Force_Stereo(void){}
kal_uint32 FMR_RDS_GetBLER(void){return 0;}
void FMR_RDS_Enable(void){}
void FMR_RDS_Disable(void){}
kal_uint32 FMR_Get_Param(kal_uint8* param)
{
	return 0;
}
void FMR_Set_Param(kal_uint8* param, kal_uint32 len)
{
	return;
}


void Media_SetOutputVolume_ST( kal_uint8 volume ) {}
void  Media_GetFileHeader( kal_uint8 **header, kal_uint32 *len ) {}
void  Media_SetRBThreshold( kal_uint16 threshold ) {}
void Media_SetRBOffset( kal_uint32 uOffset ) {}
kal_bool Media_IsCSDMode(void){return 0;}

Media_Status  Media_Pause( void ){return MEDIA_SUCCESS;}
Media_Status  Media_Resume( void ){return MEDIA_SUCCESS;}

void Media_EnableHardwareMuteSleep(kal_bool enable) {}

Media_Handle   *JTone_Open( void (*handler)( Media_Handle *handle, Media_Event event ), Media_ToneSeq_Param **param )
{
	*param = &ToneSeq_Param;
	return (Media_Handle*)&mhdl;
}
Media_Status   JTone_Close( Media_Handle *handle ){return MEDIA_SUCCESS;}
Media_Status   JTone_Play( Media_Handle *handle ){return MEDIA_SUCCESS;}
Media_Status   JTone_Stop( Media_Handle *handle ){return MEDIA_SUCCESS;}
Media_Status   JTone_Pause( Media_Handle *handle ){return MEDIA_SUCCESS;}
Media_Status   JTone_Resume( Media_Handle *handle ){return MEDIA_SUCCESS;}
Media_Status   JTone_SetStartTime( Media_Handle *handle, kal_int32 msStartTime ){return MEDIA_SUCCESS;}
Media_Status   JTone_SetStopTime( Media_Handle *handle, kal_int32 msStopTime ){return MEDIA_SUCCESS;}
kal_int32      JTone_GetCurrentTime( Media_Handle *handle ){return 0;}
kal_int32      JTone_GetDuration( Media_Handle *handle ){return 0;}
Media_Status   JTone_SetLevel( Media_Handle *handle, kal_uint8 level ){return MEDIA_SUCCESS;}
kal_uint8      JTone_GetLevel( Media_Handle *handle ){return 0;}
Media_Status   JTone_SetPitchShift(Media_Handle *handle, kal_int8 pitch_shift){return MEDIA_SUCCESS;}
kal_int8       JTone_GetPitchShift(Media_Handle *handle){return 0;}
Media_Status   JTone_SetSpeed(Media_Handle *handle, kal_uint32 speed_factor){return MEDIA_SUCCESS;}
Media_Status   JTone_SetProgram(Media_Handle *handle, kal_uint8 program){return MEDIA_SUCCESS;}
Media_Status   JTone_SetPlayStyle(Media_Handle *handle, kal_uint8 play_style){return MEDIA_SUCCESS;}
Media_Status   JTone_SetRate( Media_Handle *handle, kal_int32 milliRate ) {return MEDIA_SUCCESS;}
kal_int32      JTone_GetRate( Media_Handle *handle ){return 0;}

Media_Handle   *JImy_Open( void (*handler)( Media_Handle *handle, Media_Event event ), Media_iMelody_Param **param )
{
	*param = &iMelody_Param;
	return (Media_Handle*)&mhdl;
}
Media_Status   JImy_Close( Media_Handle *handle ){return MEDIA_SUCCESS;}
Media_Status   JImy_Play( Media_Handle *handle ){return MEDIA_SUCCESS;}
Media_Status   JImy_Stop( Media_Handle *handle ){return MEDIA_SUCCESS;}
Media_Status   JImy_Pause( Media_Handle *handle ){return MEDIA_SUCCESS;}
Media_Status   JImy_Resume( Media_Handle *handle ){return MEDIA_SUCCESS;}
Media_Status   JImy_SetStartTime( Media_Handle *handle, kal_int32 msStartTime ){return MEDIA_SUCCESS;}
Media_Status   JImy_SetStopTime( Media_Handle *handle, kal_int32 msStopTime ){return MEDIA_SUCCESS;}
kal_int32      JImy_GetCurrentTime( Media_Handle *handle ){return 0;}
kal_int32      JImy_GetDuration( Media_Handle *handle ){return 0;}
Media_Status   JImy_SetLevel( Media_Handle *handle, kal_uint8 level ){return MEDIA_SUCCESS;}
kal_uint8      JImy_GetLevel( Media_Handle *handle ){return 0;}

Media_Handle   *JWav_Open( void (*handler)( Media_Handle *handle, Media_Event event ), Media_Wav_Param **param )
{
	*param = &Wav_Param;
	return (Media_Handle*)&mhdl;
}
Media_Status   JWav_Close( Media_Handle *handle ){return MEDIA_SUCCESS;}
Media_Status   JWav_Load(Media_Handle *handle, kal_uint32 *requiredBufSize)
{	
	*requiredBufSize = 100;
	return MEDIA_SUCCESS;
}
void           JWav_SetBuffer(Media_Handle *handle, kal_int16 *buffer, kal_uint32 buf_len){}
Media_Status   JWav_Play( Media_Handle *handle ){return MEDIA_SUCCESS;}
Media_Status   JWav_Stop( Media_Handle *handle ){return MEDIA_SUCCESS;}
Media_Status   JWav_Pause( Media_Handle *handle ){return MEDIA_SUCCESS;}
Media_Status   JWav_Resume( Media_Handle *handle ){return MEDIA_SUCCESS;}
Media_Status   JWav_SetStartTime( Media_Handle *handle, kal_int32 msStartTime ){return MEDIA_SUCCESS;}
Media_Status   JWav_SetStopTime( Media_Handle *handle, kal_int32 msStopTime ){return MEDIA_SUCCESS;}
kal_int32      JWav_GetCurrentTime( Media_Handle *handle ){return 0;}
kal_int32      JWav_GetDuration( Media_Handle *handle ){return 0;}
Media_Status   JWav_SetLevel( Media_Handle *handle, kal_uint8 level ){return MEDIA_SUCCESS;}
kal_uint8      JWav_GetLevel( Media_Handle *handle ){return 0;}

Media_Handle   *JXWav_Open( void (*handler)( Media_Handle *handle, Media_Event event )){return (Media_Handle*)&mhdl;}
Media_Status   JXWav_Close( Media_Handle *handle ){return MEDIA_SUCCESS;}
Media_Status   JXWav_Load(Media_Handle *handle, kal_uint32 *requiredBufSize){return MEDIA_SUCCESS;}
void           JXWav_SetBuffer(Media_Handle *handle, kal_int16 *buffer, kal_uint32 buf_len){}
Media_Status   JXWav_Play( Media_Handle *handle ){return MEDIA_SUCCESS;}
Media_Status   JXWav_Stop( Media_Handle *handle ){return MEDIA_SUCCESS;}
Media_Status   JXWav_Pause( Media_Handle *handle ){return MEDIA_SUCCESS;}
Media_Status   JXWav_Resume( Media_Handle *handle ){return MEDIA_SUCCESS;}
kal_int32      JXWav_GetCurrentTime( Media_Handle *handle ){return 0;}
Media_Status   JXWav_SetLevel( Media_Handle *handle, kal_uint8 level ){return MEDIA_SUCCESS;}
kal_uint8      JXWav_GetLevel( Media_Handle *handle ){return 0;}

kal_uint32 Media_A2V_GetInterruptCount(void){return 0;}
void Media_A2V_EnableInterrupt(kal_bool bFlag, kal_uint32 start_count){}
void Media_A2V_HookInterrupt(void (*a2v_lisr)(void)){}
void Media_A2V_SetTimeStamp(kal_uint16 wTimeStamp){}

kal_uint16 Media_A2V_GetAudioFrameCount(void){return 0;}
kal_uint16 Media_A2V_GetVideoFrameCount(void){return 0;}
kal_uint32 Media_A2V_GetAudioInterruptTimeScale(Media_Format eFormat, kal_uint8 bSamplingFreqIndex){return 0;}
kal_uint32 Media_A2V_GetAudioInterruptTimeScaleFxdPnt(Media_Format eFormat, kal_uint8 bSamplingFreqIndex){return 0;}
kal_uint32 Media_A2V_GetAudioPlaybackDelay(Media_Format eFormat){return 0;}
kal_uint32 Media_A2V_GetAudioRecordDelay(Media_Format eFormat){return 0;}
void Media_A2V_DisableDspSleep(kal_bool disable){}

kal_uint32 Media_A2V_GetPlaybackInterruptTimeScale(Media_Format eFormat, kal_uint8 bSamplingFreqIndex){return 0;}
kal_uint32 Media_A2V_GetPlaybackInterruptTimeScaleFxdPnt(Media_Format eFormat, kal_uint8 bSamplingFreqIndex){return 0;}
kal_uint32 Media_A2V_GetRecInterruptTimeScale(Media_Format eFormat, kal_uint8 bSamplingFreqIndex){return 0;}
kal_uint32 Media_A2V_GetRecInterruptTimeScaleFxdPnt(Media_Format eFormat, kal_uint8 bSamplingFreqIndex){return 0;}

Media_Status Media_A2V_Audio_GetPlayTime(kal_uint64 *puMiliSecond, kal_uint64 uAudioSeekPointTime, kal_uint32 speed_scale, kal_uint8 bAudioSamplingFreqIndex, Media_Format eFormat){return MEDIA_SUCCESS;}
Media_Status Media_A2V_Video_GetPlayTime(kal_uint64 *puMiliSecond, kal_uint32 speed_scale, kal_uint8 bAudioSamplingFreqIndex, Media_Format eFormat){return MEDIA_SUCCESS;}
void Media_A2V_SetPlaybackTimerBase(kal_uint32 uPlaybackTimeBase, kal_bool bResetPreviousInterruptCount){}

void Media_A2V_SetMediaFormat(Media_Format format){}
void Media_A2V_SetFreq(kal_uint32 uSamplingFreq){}
void Media_A2V_SetSpeedScale(kal_uint32 speed_scale){}
void Media_A2V_SetInterruptTime(kal_uint16 msTime){}
Media_Status Media_A2V_Audio_GetPlayTime_S( kal_uint64 *puMiliSecond, kal_uint64 uAudioSeekPointTime ){return MEDIA_SUCCESS;}
Media_Status Media_A2V_Video_GetPlayTime_S(kal_uint64 *puMiliSecond){return MEDIA_SUCCESS;}
Media_Format MP4_Audio_Type_To_Media_Format(MP4_Audio_Type eAudioType)
{
   Media_Format eAudioFormat = 0;
   switch(eAudioType) {
      case MP4_AUDIO_AAC:
         eAudioFormat = MEDIA_FORMAT_MP4_AAC;
         break;
      case MP4_AUDIO_AMR:
         eAudioFormat = MEDIA_FORMAT_MP4_AMR;
         break;
      case MP4_AUDIO_AMR_WB:
         eAudioFormat = MEDIA_FORMAT_MP4_AMR_WB;
         break;
      case MP4_AUDIO_BSAC:
         eAudioFormat = MEDIA_FORMAT_MP4_BSAC;
         break;
      case MP4_AUDIO_NONE:
         eAudioFormat = MEDIA_FORMAT_MP4_AMR;
         break;
   }
   return eAudioFormat;
}

const kal_uint16 lenSpeechBitsAMR[9]={
    95, 103, 118, 134, 148, 159, 204, 244, 39
};
const kal_uint16 lenSpeechBitsAMR_WB[10]={
   132, 177, 253, 285, 317, 365, 397, 461, 477, 40
};

void GPTI_StartItem(void){}
void GPTI_StopItem(void){}

void Media_A2V_SetInterruptCount(kal_uint32 uInterruptCount){}
VR_Result VR_GetParameters(kal_int16 *SimThrld, kal_int16 *DiffThrld, kal_int16 *RejThrld){return 0;}
VR_Result VR_SetParemeters (kal_int16 SimThrld, kal_int16 DiffThrld, kal_int16 RejThrld){return 0;}
kal_uint32 VR_GetBufferSize(void){return 0;}
void VR_SetBuffer(kal_uint8 *RTmemory){}
VR_Result  VR_SetDatabaseDir(kal_uint8 *Dir){return 0;}
VR_Result VR_TRA_Start(kal_uint16 wID, kal_uint16 *mdIDList, kal_uint16 *mdIDListLen, void (*vr_handler)(void *parameter )){return 0;}
VR_Result VR_TRA2Start(void){return 0;}
VR_Result VR_RCG_Start(kal_uint16 *mdIDList,kal_uint16 *mdIDListLen,void(*vr_handler)(void *parameter)){return 0;}
VR_Result VR_Process(kal_uint16 *RcgID){return 0;}
void VR_Stop(void){}
kal_int32 VR_GetEngineVer(void){return 0;}


Media_Handle   *JAmr_Open( void (*handler)( Media_Handle *handle, Media_Event event ), Media_AMR_Param **param )
{
	*param = &AMR_Param;
	return (Media_Handle*)&mhdl;
}
Media_Status   JAmr_Close( Media_Handle *handle ){return MEDIA_SUCCESS;}
Media_Status   JAmr_Play( Media_Handle *handle ){return MEDIA_SUCCESS;}
Media_Status   JAmr_Stop( Media_Handle *handle ){return MEDIA_SUCCESS;}
Media_Status   JAmr_Pause( Media_Handle *handle ){return MEDIA_SUCCESS;}
Media_Status   JAmr_Resume( Media_Handle *handle ){return MEDIA_SUCCESS;}
Media_Status   JAmr_SetStartTime( Media_Handle *handle, kal_int32 msStartTime ){return MEDIA_SUCCESS;}
Media_Status   JAmr_SetStopTime( Media_Handle *handle, kal_int32 msStopTime ){return MEDIA_SUCCESS;}
kal_int32      JAmr_GetCurrentTime( Media_Handle *handle ){return 0;}
Media_Status   JAmr_SetLevel( Media_Handle *handle, kal_uint8 level ){return MEDIA_SUCCESS;}
kal_uint8      JAmr_GetLevel( Media_Handle *handle ){return 0;}
Media_Status   JAmr_GetDuration( const kal_uint8 *amrfile, kal_int32 amrsize, kal_int32 *duration ){return MEDIA_SUCCESS;}

#ifdef BGSND_ENABLE
void sndProcess( Media_Handle *hdl ){}
Media_Status SND_GetFormat(STFSAL *pstFSAL, Media_Format *pFormat){return MEDIA_SUCCESS;}
Media_Handle *SND_Open(void(*handler)(Media_Handle *, Media_Event ), Snd_Param **param)
{
	return (Media_Handle*)&mhdl;
}
Media_Status SND_Close(Media_Handle *hdl){return MEDIA_SUCCESS;}
Media_Status SND_Play( Media_Handle *hdl ){return MEDIA_SUCCESS;}
void SND_Stop( Media_Handle *hdl ){}
void SND_ConfigULMixer( Media_Handle *hdl, kal_bool bULSPHFlag, kal_int8 ULSNDGain ){}
void SND_ConfigDLMixer( Media_Handle *hdl, kal_bool bDLSPHFlag, kal_int8 DLSNDGain ){}
void SND_SetOutputDevice( kal_uint8 device ){}
#endif


void free_NFI_bus(void) {}
void get_NFI_bus(void) {}

void Audio_MedFuncReg(Media_Func_Reg_Type *func){}
void Audio_BTFuncReg (BT_Func_Reg_Type    *func){}

kal_bool       JMidi_isBankQuerySupported( void ){return 0;}
void           JMidi_GetBankList( kal_bool custom, const kal_int16 **buf, kal_int16 *len){}
void           JMidi_GetProgramList( kal_int16 bank, const kal_int8 **buf, kal_int16 *len){}
const kal_uint8*JMidi_GetProgramName( kal_int16 bank, kal_int8 prog ){return 0;}
const kal_uint8*JMidi_GetKeyName( kal_int16 bank, kal_int8 prog, kal_int8 key ){return 0;}

Media_Handle   *JMidi_OpenDevice( kal_uint32 *requiredBufSize )
{
   *requiredBufSize = 100;
   return (Media_Handle*)&mhdl;
}

void           JMidi_SetBuffer( Media_Handle *handle, kal_int8 *buffer, kal_uint32 buf_len ){ return; }
Media_Status   JMidi_CloseDevice( Media_Handle *handle ){return MEDIA_SUCCESS;}
Media_Status   JMidi_SendLongMsg( Media_Handle *handle, const kal_uint8 *buf, kal_uint16 len ){return MEDIA_SUCCESS;}
Media_Status   JMidi_SendShortMsg( Media_Handle *handle, kal_uint8 type, kal_uint8 data1, kal_uint8 data2 ){return MEDIA_SUCCESS;}
Media_Status   JMidi_SetLevel( Media_Handle *handle, kal_uint8 level ){return MEDIA_SUCCESS;}
kal_uint8      JMidi_GetLevel( Media_Handle *handle ){return 0;}
Media_Status   JMidi_SetTempo( Media_Handle *handle, kal_int32 milliTempo ){return MEDIA_SUCCESS;}
kal_int32      JMidi_GetTempo( Media_Handle *handle ){return 0;}
Media_Status   JMidi_SetRate( Media_Handle *handle, kal_int32 milliRate ){return MEDIA_SUCCESS;}
kal_int32      JMidi_GetRate( Media_Handle *handle ){return 0;}
Media_Status   JMidi_SetPitchTranspose( Media_Handle *handle, kal_int32 milliSt ){return MEDIA_SUCCESS;}
kal_int32      JMidi_GetPitchTranspose( Media_Handle *handle ){return 0;}
Media_Status   JMidi_SetChannelVolume( Media_Handle *handle, kal_int8 channel, kal_uint8 level ){return MEDIA_SUCCESS;}
kal_int8       JMidi_GetChannelVolume( Media_Handle *handle, kal_int8 channel ){return 0;}
Media_Status   JMidi_SetProgram( Media_Handle *handle, kal_int8 channel, kal_int16 bank, kal_int8 program ){return MEDIA_SUCCESS;}
void           JMidi_GetProgram( Media_Handle *handle, kal_int8 channel, kal_int16 *bank, kal_int8 *program ){}

void wavGetAdpcmState      (void){}
void wavCopyAdpcmState     (void){}

void       *processing_lisr;

Media_Handle   *JSmf_Open( void (*handler)( Media_Handle *handle, Media_Event event ), kal_uint32 *requiredBufSize )
{
	*requiredBufSize = 100;
	return (Media_Handle*)&mhdl;
}

void           JSmf_SetBuffer( Media_Handle *handle, kal_int8 *buffer, kal_uint32 buf_len, Media_SMF_Param **param )
{
   *param = &SMF_Param;
   return;
}

Media_Status   JSmf_Close( Media_Handle *handle ){return MEDIA_SUCCESS;}
Media_Status   JSmf_Play( Media_Handle *handle ){return MEDIA_SUCCESS;}
Media_Status   JSmf_Stop( Media_Handle *handle ){return MEDIA_SUCCESS;}
Media_Status   JSmf_Pause( Media_Handle *handle ){return MEDIA_SUCCESS;}
Media_Status   JSmf_Resume( Media_Handle *handle ){return MEDIA_SUCCESS;}
Media_Status   JSmf_SetStartTime( Media_Handle *handle, kal_int32 msStartTime ){return MEDIA_SUCCESS;}
Media_Status   JSmf_SetStopTime( Media_Handle *handle, kal_int32 msStopTime ){return MEDIA_SUCCESS;}
kal_int32      JSmf_GetCurrentTime( Media_Handle *handle ){return 0;}
kal_int32      JSmf_GetDuration( Media_Handle *handle ){return 0;}
kal_int32      JSmf_GetMidiDuration( const kal_uint8 *mid ){return 100;}
Media_Event    JSmf_QueryExtEvent( Media_Handle *handle, kal_int32 *note ){return 0;}
kal_bool       JSmf_isSpMidi( Media_Handle *handle ){return KAL_FALSE;}

void SPT_Open( void ){}
void SPT_Close( void ){}
void SPT_GetSpectrum( kal_uint8 top[16], kal_uint8 val[16] ){}
void SPT_PutPcmData( const kal_int16 *pcm, kal_int32 len, kal_bool mono ){}    /* L1audio internal use */

#if defined(MT6205B) 
kal_uint8 AFE_TurnOnMicBias( void ) { return 0;}
void AFE_TurnOffMicBias( void ) {}
#else 
void AFE_TurnOnMicBias(void){}
void AFE_TurnOffMicBias( void ){}
#endif

//audio compensation filter for META interface
void ACF_SetFilterCoeff(kal_int16 *coeff, MEDIA_ACF_OUTPUT_MODE mode) {}
MEDIA_ACF_Filter_Type ACF_GetFilterType( void ){ return MEDIA_ACF_HW_FIR; }

MHdl *AMR_Open(void(*handler)( MHdl *handle, Media_Event event ), STFSAL *pstFSAL, void *param) {return &mhdl;}
MHdl *VM_Open(void(*handler)( MHdl *handle, Media_Event event ), STFSAL *pstFSAL, void *param) {return &mhdl;}
MHdl *DAF_Open(void(*handler)( MHdl *handle, Media_Event event ), STFSAL *pstFSAL, void *param) {return &mhdl;}
MHdl *AAC_Open(void(*handler)( MHdl *handle, Media_Event event ), STFSAL *pstFSAL, void *param) {return &mhdl;}
MHdl *BSAC_Open(void(*handler)( MHdl *handle, Media_Event event ), STFSAL *pstFSAL, void *param) {return &mhdl;}
MHdl *WAV_Open(void(*handler)( MHdl *handle, Media_Event event ), STFSAL *pstFSAL, void *param) {return &mhdl;}
MHdl *AIFF_Open(void(*handler)( MHdl *handle, Media_Event event ), STFSAL *pstFSAL, void *param) {return &mhdl;}
MHdl *AU_Open(void(*handler)( MHdl *handle, Media_Event event ), STFSAL *pstFSAL, void *param) {return &mhdl;}
MHdl *M4A_Open(void(*handler)( MHdl *handle, Media_Event event ), STFSAL *pstFSAL, void *param) {return &mhdl;}
MHdl *PCM_Open(void(*handler)( MHdl *handle, Media_Event event ), STFSAL *pstFSAL, void *param) {return &mhdl;}
MHdl *WMA_Open(void(*handler)( MHdl *handle, Media_Event event ), STFSAL *pstFSAL, void *param) {return &mhdl;}
MHdl *PCM_Strm_Open(void(*handler)( MHdl *handle, Media_Event event ), void *param) {return &mhdl;}
MHdl *PCM_Strm_Rec_Open(void(*handler)( MHdl *handle, Media_Event event ), void *param) {return &mhdl;}
MHdl *COOK_Open(void(*handler)( MHdl *handle, Media_Event event ), STFSAL *pstFSAL, void *param) {return &mhdl;}
MHdl *APE_Open(void(*handler)( MHdl *handle, Media_Event event ), STFSAL *pstFSAL, void *param) {return &mhdl;}
MHdl *DRA_Open(void(*handler)( MHdl *handle, Media_Event event ), STFSAL *pstFSAL, void *param) {return &mhdl;}
MHdl *VORBIS_Open(void(*handler)( MHdl *handle, Media_Event event ), STFSAL *pstFSAL, void *param) {return &mhdl;}
MHdl *VORBIS_Strm_Open(void(*handler)( MHdl *handle, Media_Event event ), STFSAL *pstFSAL, void *param) {return &mhdl;}
MHdl *FLAC_Open(void(*handler)( MHdl *handle, Media_Event event ), STFSAL *pstFSAL, void *param) {return &mhdl;}


/*I2S interface*/
Media_Status I2S_Open( void ){ return MEDIA_SUCCESS; }
Media_Status I2S_Close( void ){ return MEDIA_SUCCESS; }
kal_bool I2S_is_I2S_open( void ){ return 0; }
kal_bool I2S_is_FM( void ){ return 0; }
Media_Status FM_I2S_Open(void){ return MEDIA_SUCCESS; }
Media_Status FM_I2S_Close(void){ return MEDIA_SUCCESS; }


void I2SIN_TurnOnSpeaker(void){}
void I2SIN_TurnOffSpeaker(void){}
void I2SIN_MuteSpeaker( kal_bool mute ){}
void I2SIN_SetOutputVolume( kal_uint8 volume1, kal_int8 digital_gain_index ){}
void I2SIN_SetOutputDevice( kal_uint8 device ){}
kal_bool I2SIN_CheckDataValid(){return KAL_TRUE;}
void I2SIN_MuteDSP( kal_bool fMute ){}

Media_Status VM_GetContentDescInfo( STFSAL *pstFSAL, audInfoStruct *contentInfo, void *param )	 { return MEDIA_SUCCESS; }
Media_Status AIFF_GetContentDescInfo( STFSAL *pstFSAL, audInfoStruct *contentInfo, void *param  ) 	{ return MEDIA_SUCCESS; }
Media_Status PCM_GetContentDescInfo( STFSAL *pstFSAL, audInfoStruct *contentInfo, void *param  ) 	{ return MEDIA_SUCCESS; }
Media_Status DAF_GetContentDescInfo( STFSAL *pstFSAL, audInfoStruct *contentInfo, void *param  ) 	{ return MEDIA_SUCCESS; }
Media_Status M4A_GetContentDescInfo( STFSAL *pstFSAL, audInfoStruct *contentInfo, void *param  ) 	{ return MEDIA_SUCCESS; }
Media_Status MP4_GetContentDescInfo( STFSAL *pstFSAL, audInfoStruct *contentInfo, void *param  )  { return MEDIA_SUCCESS; }
Media_Status AMR_GetContentDescInfo( STFSAL *pstFSAL, audInfoStruct *contentInfo, void *param  ) 	{ return MEDIA_SUCCESS; }
Media_Status WAV_GetContentDescInfo( STFSAL *pstFSAL, audInfoStruct *contentInfo, void *param  ) 	{ return MEDIA_SUCCESS; }
Media_Status AU_GetContentDescInfo( STFSAL *pstFSAL, audInfoStruct *contentInfo, void *param  ) 	{ return MEDIA_SUCCESS; }
Media_Status WMA_GetContentDescInfo( STFSAL *pstFSAL, audInfoStruct *contentInfo, void *param  ) {return MEDIA_SUCCESS;}
Media_Status AAC_GetContentDescInfo( STFSAL *pstFSAL, audInfoStruct *contentInfo, void *param  ){return MEDIA_SUCCESS;}
Media_Status APE_GetContentDescInfo( STFSAL *pstFSAL, audInfoStruct *contentInfo, void *param  ){return MEDIA_SUCCESS;}
Media_Status VORBIS_GetContentDescInfo( STFSAL *pstFSAL, audInfoStruct *contentInfo, void *param  ){return MEDIA_SUCCESS;}
Media_Status JSmf_GetContentDescInfo( STFSAL *pstFSAL, audInfoStruct *contentInfo, void *param  ){return MEDIA_SUCCESS;}
Media_Status JImy_GetContentDescInfo( STFSAL *pstFSAL, audInfoStruct *contentInfo, void *param  ){return MEDIA_SUCCESS;}
Media_Status FLAC_GetContentDescInfo( STFSAL *pstFSAL, audInfoStruct *contentInfo, void *param  ){return MEDIA_SUCCESS;}

kal_bool APE_IsSeekable( STFSAL *pstFSAL) {return 0;}
kal_bool AAC_IsPPSupport( STFSAL *pstFSAL) {return 0;}
kal_bool M4A_IsPPSupport( STFSAL *pstFSAL) {return 0;}
void mhdlStoreFileOffset(void){}
void mhdlSetFileOffset(kal_uint32 uCurOffset){}
kal_uint32 mhdlGetFileOffset(void){return 0;}
Media_Status AAC_GetMetaData( kal_wchar *filename, kal_uint8 *pbBuf, kal_uint32 uSize, audInfoStruct *contentInfo, void *param ){ return MEDIA_SUCCESS; }
Media_Status AMR_GetMetaData( kal_wchar *filename, kal_uint8 *pbBuf, kal_uint32 uSize, audInfoStruct *contentInfo, void *param ){ return MEDIA_SUCCESS; }
Media_Status DAF_GetMetaData( kal_wchar *filename, kal_uint8 *pbBuf, kal_uint32 uSize, audInfoStruct *contentInfo, void *param ){ return MEDIA_SUCCESS; }
Media_Status JSmf_GetMetaData( kal_wchar *filename, kal_uint8 *pbBuf, kal_uint32 uSize, audInfoStruct *contentInfo, void *param ){ return MEDIA_SUCCESS; }
Media_Status JImy_GetMetaData( kal_wchar *filename, kal_uint8 *pbBuf, kal_uint32 uSize, audInfoStruct *contentInfo, void *param ){ return MEDIA_SUCCESS; }
Media_Status WMA_GetMetaData( kal_wchar *filename, kal_uint8 *pbBuf, kal_uint32 uSize, audInfoStruct *contentInfo, void *param ){ return MEDIA_SUCCESS; }
Media_Status WAV_GetMetaData( kal_wchar *filename, kal_uint8 *pbBuf, kal_uint32 uSize, audInfoStruct *contentInfo, void *param ){ return MEDIA_SUCCESS; }
Media_Status AIFF_GetMetaData( kal_wchar *filename, kal_uint8 *pbBuf, kal_uint32 uSize, audInfoStruct *contentInfo, void *param ){ return MEDIA_SUCCESS; }
Media_Status AU_GetMetaData( kal_wchar *filename, kal_uint8 *pbBuf, kal_uint32 uSize, audInfoStruct *contentInfo, void *param ){ return MEDIA_SUCCESS; }
Media_Status M4A_GetMetaData( kal_wchar *filename, kal_uint8 *pbBuf, kal_uint32 uSize, audInfoStruct *contentInfo, void *param ){ return MEDIA_SUCCESS; }
Media_Status APE_GetMetaData( kal_wchar *filename, kal_uint8 *pbBuf, kal_uint32 uSize, audInfoStruct *contentInfo, void *param ){ return MEDIA_SUCCESS; }
Media_Status VORBIS_GetMetaData( kal_wchar *filename, kal_uint8 *pbBuf, kal_uint32 uSize, audInfoStruct *contentInfo, void *param ){ return MEDIA_SUCCESS; }


/* SBC interface */
bt_a2dp_sbc_codec_cap_struct sbc_cap[1];
void SBC_InitiateBitPool( kal_uint8 channel_mode, kal_uint8 sample_rate, kal_uint8 *min, kal_uint8 *max ) {}
kal_uint32 SBC_GetMemReq(void) { return 0; }
A2DP_codec_struct *SBC_Open(
   Media_Format aud_fmt, 
   A2DP_Callback pHandler, 
   bt_a2dp_sbc_codec_cap_struct *sbc_config_data, 
   kal_uint8 *buf, 
   kal_uint32 buf_len ) { return 0; }
void SBC_Close(void) {}
void SBC_AdjustBitpool( kal_uint8 max_bitpool, kal_uint8 min_bitpool ) {}
kal_uint32 SBC_SetQualityLevel(kal_uint32 level) {return level;}
void sbc_initiate_internal(const kal_uint8 code[16]){}
void SBC_SetLevelVolume( kal_uint8 uCurStep, kal_uint8 uTotalStep ){}
void SBC_MuteSpeaker( kal_bool mute ){}
void SBC_QueryInfo(bt_a2dp_sbc_codec_info_struct *info) {}

void BT_SetLevelVolume( kal_uint8 uCurStep, kal_uint8 uTotalStep ){}
void BT_MuteSpeaker( kal_bool mute ){}

bt_a2dp_mp3_codec_cap_struct mp3_cap[1];
kal_uint32 A2DP_DAF_GetMemReq(void){return 0;}
A2DP_codec_struct *A2DP_DAF_Open( MHdl *mhdl_handle, A2DP_Callback pHandler, bt_a2dp_mp3_codec_cap_struct *daf_config_data, kal_uint8 *buf, kal_uint32 buf_len){return NULL;}
void A2DP_DAF_Close( MHdl *mhdl_handle ){return;}


/*
VORTP_UL_HANDLE *PoCAMR_OpenULChannel( void ){ return NULL; }
VORTP_DL_HANDLE *PoCAMR_OpenDLChannel( void ){ return NULL; }

VORTP_UL_HANDLE *VoRTP_OpenULChannel( void ){ return NULL; }
VORTP_DL_HANDLE *VoRTP_OpenDLChannel( void ){ return NULL; }
VORTP_STATUS VoRTP_StartInbandTone( 
   kal_uint32 freq1, kal_uint32 freq2, 
   kal_int32 amp_dbm0, kal_uint32 duration_msec, 
   VORTP_TONE_CALLBACK callback, void *host_data  ){ return VORTP_STATUS_FAIL; }
VORTP_STATUS VoRTP_StopInbandTone( void ){ return VORTP_STATUS_FAIL; }
 VoRTP interface */
void L1Ctm_Open(L1Ctm_Interface a, L1Ctm_Callback handler, kal_uint8 *buf, kal_uint32 buf_len, CTM_Param *ctm_param){ return; }
void L1Ctm_StartNegotiation(void){ return; }
void L1Ctm_Close(void){ return; }
kal_uint32 L1Ctm_GetMemReq(void){ return 0; }
kal_uint32 L1Ctm_RxGetText(kal_uint8 *text, kal_uint32 len, kal_uint32 *left_count){ return 0; }
kal_uint32 L1Ctm_TxPutText(const kal_uint8 *text, kal_uint32 len, kal_uint32 *left_space){ return 0; }

eCall_Modem_Status eCall_IVS_Open(eCall_Callback handler){ return eCALL_OPERATION_SUCCESS; }
eCall_Modem_Status eCall_IVS_Close(void){ return eCALL_OPERATION_SUCCESS; }
eCall_Modem_Status eCall_IVS_PutMSD(const kal_uint8 *pMSD, const kal_uint32 uLen){ return eCALL_OPERATION_SUCCESS; }
eCall_Modem_Status eCall_IVS_SendStart(void){ return eCALL_OPERATION_SUCCESS; }
eCall_Modem_Status eCall_PSAP_Open(eCall_Callback handler) {return eCALL_OPERATION_FAIL;}
eCall_Modem_Status eCall_PSAP_Close(void) {return eCALL_OPERATION_FAIL;}
eCall_Modem_Status eCall_PSAP_SendStart(void) {return eCALL_OPERATION_FAIL;}

void AFE_GetMappedGain(kal_uint8 MaxAnalogGain, kal_uint8 step, kal_uint8 level,
                   kal_uint8 *AnalogGain, kal_int8 *DigitalGain){}
void AFE_SetLevelVolume(kal_uint8 aud_func, kal_uint8 MaxAnalogGain, kal_uint8 step, kal_uint8 level)
{  
}  
void  Media_SetLevelVolume( kal_uint8 MaxAnalogGain, kal_uint8 step, kal_uint8 level )
{   
}                   
void AudioPP_Surround_Enable(void)
{
}
void AudioPP_Surround_Disable(void)
{
}
void AudioPP_Surround_ModeSelect(kal_int32 mode)
{
}

void AM_SetLoopBackTest( kal_bool enable )
{
}

kal_bool AM_IsVoIPOn( void ){return 0;}

TTS_Handle *TTS_Open(void(*callback)(TTS_Handle *hdl, TTS_Event event, void *data), TTS_LANG lang, TTS_TYPE type, TTS_GENDER gender){ return NULL; }
void SP3G_Request(void){ return; }
void SP3G_UL_SetFrameType(kal_uint8 amr_frame_type){ return; }
void SP3G_UL_GetSpeechFrame(kal_uint16*frame_index, kal_uint8 *frame_type, kal_uint8 *rab_byte_array, kal_uint8 *len){ return; }
void SP3G_DL_PutSpeechFrame(kal_uint32 CFN, kal_uint8 sub_flow_id, kal_uint8 frame_type, kal_bool crc_status, kal_uint8 *subflow){ return; }
void SP3G_Closed_Confirm( void ){ return; }
kal_uint8 SP3GVT_DL_PutSpeechFrame(kal_uint8 *dl_data, kal_uint32 size, kal_bool error_flag, kal_uint8 *dl_frame_number){return 0;}
kal_uint8 SP3GVT_DL_DropSpeechFrame(kal_uint32 number, kal_uint8 *dl_frame_number){return 0;}
void SP3GVT_UL_GetSpeechFrame(kal_uint8 *ul_data, kal_uint32 ul_space, kal_uint32 *size){ return; }
void SP3GVT_SetDelayValue(kal_uint32 delay){ return; }
void SP3G_Rab_Deest( void ){ return; }
void SP3G_Rab_Est( kal_uint32 rab_id, kal_uint8 default_speech_codec ){ return; }
void SP3G_SetDTX(kal_bool on){ return; }

// For Audio Equalizer
void AudioPP_Equalizer_SetMag( kal_int8 magnitude[8] ) {}
void AudioPP_Equalizer_TurnOn( void ) {}
void AudioPP_Equalizer_TurnOff( void ) {}
kal_bool AudioPP_Equalizer_IsEnable( void ) {return KAL_FALSE;}

//For flexible audio equalizer
void AudioPP_Equalizer_SetMag_Flexible(kal_int8 *band_mag) { return; }
void Media_SetBesEQInitParam(kal_uint8 *pBuf, kal_uint32 u4Len) { return; }
void AudioPP_Equalizer_TransformMag_ToBarNum (kal_int8 *band_mag, kal_int8 *bar_mag, kal_uint32 bar_num) { return; }
void AudioPP_Equalizer_TransformMag_ToBandNum (kal_int8 *bar_mag, kal_int8 *band_mag, kal_uint32 bar_num) { return; }
kal_int16 Media_QueryBesEQMaxBandNum(void) { return 0; }

// For BesLoudness
void Media_SetBesLoudnessCustomCoeff(kal_uint32 *hsf_coeffs, kal_uint32 *bpf_coeffs){}
void Media_SetBesLoudnessCustomCoeff_v3(void *pBuf, kal_uint32 uLen){}
kal_uint32 Media_QueryBesLoudnessVersion(void){return 0;}

// For Audio Compensation Filter
void Media_SelectAudioCompensation(Media_Aud_Comp_Mode mode){}
void Media_SetAudioCompensation(Media_Aud_Comp_Mode mode, const kal_int16 *coeff) {}
void Audio_Compensation_Activate( kal_bool rampup ) {}

// For Audio SWFIR
void Media_SetAudioCompensation_SWFIR(void *pBuf, kal_uint32 uLen){}

// For Hardware FIR
void Audio_HW_FIR_Reset( void ) {}

// For BassEnhance
void AudioPP_BassEnhance_Enable( void ){}
void AudioPP_BassEnhance_Disable( void ){}

// For Loudness
void AudioPP_Loudness_Enable( void ){}
void AudioPP_Loudness_Disable( void ){}

// Turn on/off Bessound effect
void AudioPP_DisableBesSound( void ){}
void AudioPP_EnableBesSound( void ){}
void AudioPP_DisableBesSoundinVideo( void ){}
void AudioPP_EnableBesSoundinVideo( void ){}

// Gain table support API
void L1SP_SetOutputGainControl(kal_uint32 vol){}
void Media_SetOutputGainControl(kal_uint32 vol, kal_uint32 ext_amp_gain){}
void TONE_SetOutputGainControl(kal_uint32 vol){}
void KT_SetOutputGainControl(kal_uint32 vol){}
void FMR_SetOutputGainControl(kal_uint32 vol){}
void FMR_SetDualPathGainControl(kal_uint32 ext_amp_gain ){}
void L1SP_SetMicGainControl(kal_uint32 vol){}

#if defined(AMR_CODEC)
static const kal_uint8 AMR_FileHeader[6] = { 0x23, 0x21, 0x41, 0x4D, 0x52, 0x0A};
#endif

#if defined(AMRWB_DECODE)
static const kal_uint8 AWB_FileHeader[9] = {
   0x23, 0x21, 0x41, 0x4D, 0x52, 0x2D, 0x57, 0x42, 0x0A
};
#endif

#if defined(AAC_DECODE)
/* Get the silence pattern */
static const kal_uint8 AAC_Header[7] = { 0xFF, 0xF9, 0x40, 0x20, 0x00, 0x1F, 0xFC };
static const kal_uint8 AAC_Mono_SilData[9] = { 0x01, 0x40, 0x20, 0x07, 0xF6, 0x00, 0x00, 0x00, 0x00 };
static const kal_uint8 AAC_Stereo_SilData[9] = { 0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80 };
static const kal_uint8 AAC_Plus_Mono_SilData[22] = {
   0x00, 0xD0, 0x30, 0x83, 0xE2, 0x5B, 0x66, 0x25, 
   0x77, 0xC4, 0x5A, 0xB7, 0x14, 0x05, 0xD0, 0x40, 
   0x00, 0x00, 0x00, 0x03, 0x80, 0x38
};
static const kal_uint8 AAC_Plus_Stereo_SilData[32] = {
   0x21, 0x19, 0x53, 0x40, 0x7C, 0xCB, 0x6C, 0xA4, 
   0xA1, 0x08, 0x9A, 0x03, 0xE6, 0x5B, 0x65, 0x25, 
   0x08, 0x45, 0xB3, 0x75, 0x60, 0x5D, 0x42, 0x00, 
   0x00, 0x00, 0x01, 0xC6, 0x00, 0x0C, 0x03, 0x80
};
static const kal_uint8 AAC_PS_Mono_SilData[26] = {
   0x00, 0xD0, 0x33, 0x03, 0xE7, 0x5B, 0x88, 0x39, 0x7C, 0xFF, 
   0xFC, 0x5B, 0x77, 0x78, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 
   0x01, 0xC2, 0x54, 0x10, 0x00, 0x38
};

#if defined(BSAC_DECODE)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
#endif

Media_Status Media_GetFileHeaderLength(
   Media_Format format,
   kal_uint32 channelNum,
   kal_uint32 freq,
   kal_uint32 subframeNum,
   kal_uint32 *len
)
{
   switch (format) {
#if defined(AMR_CODEC)
      case MEDIA_FORMAT_AMR:
      case MEDIA_FORMAT_MP4_AMR:
         *len = 6;
         break;
#endif
#if defined(AMRWB_DECODE)
      case MEDIA_FORMAT_AMR_WB:
      case MEDIA_FORMAT_MP4_AMR_WB:
         *len = 9;
         break;
#endif
#if defined(AAC_DECODE)
      case MEDIA_FORMAT_AAC:
      case MEDIA_FORMAT_MP4_AAC:
      case MEDIA_FORMAT_AAC_PLUS:
      case MEDIA_FORMAT_AAC_PLUS_V2:
      case MEDIA_FORMAT_BSAC:
      case MEDIA_FORMAT_MP4_BSAC:
         *len = 0;
         break;
#endif
      default:
         return MEDIA_UNSUPPORTED_TYPE;
   }
   
   return MEDIA_SUCCESS;
}

Media_Status  Media_GetFileHeaderPattern(
   Media_Format format,
   kal_uint32 channelNum,
   kal_uint32 freq,
   kal_uint32 subframeNum,
   kal_uint8 *pattern
)
{
   switch (format) {
#if defined(AMR_CODEC)
      case MEDIA_FORMAT_AMR:
      case MEDIA_FORMAT_MP4_AMR:
         memcpy(pattern, AMR_FileHeader, 6);
         break;
#endif
#if defined(AMRWB_DECODE)
      case MEDIA_FORMAT_AMR_WB:
      case MEDIA_FORMAT_MP4_AMR_WB:
         memcpy(pattern, AWB_FileHeader, 9);
         break;
#endif
#if defined(AAC_DECODE)
      case MEDIA_FORMAT_AAC:
      case MEDIA_FORMAT_MP4_AAC:
      case MEDIA_FORMAT_AAC_PLUS:
      case MEDIA_FORMAT_AAC_PLUS_V2:
      case MEDIA_FORMAT_BSAC:
      case MEDIA_FORMAT_MP4_BSAC:
         memcpy(pattern, AAC_Header, 7);
         break;
#endif
      default:
         return MEDIA_UNSUPPORTED_TYPE;
   }
   
   return MEDIA_SUCCESS;
}

Media_Status Media_GetSilenceLength(
   Media_Format format,
   kal_uint32 channelNum,
   kal_uint32 freq,
   kal_uint32 subframeNum,
   kal_uint32 *len
)
{
   if ((channelNum == 0) || (channelNum > 2)) {
      return MEDIA_UNSUPPORTED_CHANNEL;
   }

   switch (format) {
#if defined(AMR_CODEC)
      case MEDIA_FORMAT_AMR:
      case MEDIA_FORMAT_MP4_AMR:
         *len = 1;
         break;
#endif
#if defined(AMRWB_DECODE)
      case MEDIA_FORMAT_AMR_WB:
      case MEDIA_FORMAT_MP4_AMR_WB:
         *len = 1;
         break;
#endif
#if defined(AAC_DECODE)
      case MEDIA_FORMAT_AAC:
      case MEDIA_FORMAT_MP4_AAC:
         *len = 16;
         break;
      case MEDIA_FORMAT_AAC_PLUS:
         if (channelNum == 1) {
            *len = 29;
         } else {
            *len = 39;
         }
         break;
      case MEDIA_FORMAT_AAC_PLUS_V2:
         *len = 33;
         break;
      case MEDIA_FORMAT_BSAC:
      case MEDIA_FORMAT_MP4_BSAC:
         if (channelNum == 1) {
            *len = 7 + 9*subframeNum;
         } else {
            *len = 7 + 13*subframeNum;
         }
         break;
#endif
      default:
         return MEDIA_UNSUPPORTED_TYPE;
   }

   return MEDIA_SUCCESS;
}


Media_Status  Media_GetSilencePattern(
   Media_Format format,
   kal_uint32 channelNum,
   kal_uint32 freq,
   kal_uint32 subframeNum,
   kal_uint8 *pattern
)
{
   kal_uint32 freqIndex = 0;
   kal_uint32 silLen = 0;

   if ((channelNum == 0) || (channelNum > 2)) {
      return MEDIA_UNSUPPORTED_CHANNEL;
   }

#if defined(AMR_CODEC)
   if ( (format == MEDIA_FORMAT_AMR) || (format == MEDIA_FORMAT_MP4_AMR) )
   {
      if (channelNum != 1) {
         return MEDIA_UNSUPPORTED_CHANNEL;
      }
      
      if (freq != 8000) {
         return MEDIA_UNSUPPORTED_FREQ;
      }
      
      pattern[0] = 0x7C;
      
      return MEDIA_SUCCESS;
   }
#endif

#if defined(AMRWB_DECODE)
   if ((format == MEDIA_FORMAT_AMR_WB) || (format == MEDIA_FORMAT_MP4_AMR_WB) )
   {
      if (channelNum != 1) {
         return MEDIA_UNSUPPORTED_CHANNEL;
      }
      
      if (freq != 16000) {
         return MEDIA_UNSUPPORTED_FREQ;
      }
      
      pattern[0] = 0x7C;
      
      return MEDIA_SUCCESS;
   }
#endif

#if defined(AAC_DECODE)
   switch (freq) {
      case 8000:
         freqIndex = 11;
         break;
      case 11025:
         freqIndex = 10;
         break;
      case 12000:
         freqIndex = 9;
         break;
      case 16000:
         freqIndex = 8;
         break;
      case 22050:
         freqIndex = 7;
         break;
      case 24000:
         freqIndex = 6;
         break;
      case 32000:
         freqIndex = 5;
         break;
      case 44100:
         freqIndex = 4;
         break;
      case 48000:
         freqIndex = 3;
         break;
      default:
         return MEDIA_UNSUPPORTED_FREQ;
   }

   memcpy(pattern, AAC_Header, 7);

   switch (format) {
      case MEDIA_FORMAT_AAC:
      case MEDIA_FORMAT_MP4_AAC:
         if (channelNum == 1) {
            memcpy(pattern+7, AAC_Mono_SilData, 9);
            silLen = 16;
         } else {
            memcpy(pattern+7, AAC_Stereo_SilData, 9);
            silLen = 16;
         }
         break;
      case MEDIA_FORMAT_AAC_PLUS:
         if (freqIndex <= 5)
            return MEDIA_UNSUPPORTED_FREQ;
         if (channelNum == 1) {
            memcpy(pattern+7, AAC_Plus_Mono_SilData, 22);
            silLen = 29;
         } else {
            memcpy(pattern+7, AAC_Plus_Stereo_SilData, 32);
            silLen = 39;
         }
         break;
      case MEDIA_FORMAT_AAC_PLUS_V2:
         if (freqIndex <= 5)
            return MEDIA_UNSUPPORTED_FREQ;
         if (channelNum != 1)
            return MEDIA_UNSUPPORTED_CHANNEL;
         memcpy(pattern+7, AAC_PS_Mono_SilData, 26);
         silLen = 33;
         break;
#if defined(BSAC_DECODE)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
      default:
         return MEDIA_UNSUPPORTED_TYPE;
   }
   
   // Update AAC ADTS header
   pattern[2] |= (freqIndex<<2);
   pattern[3] |= (channelNum<<6) | (silLen>>11);
   pattern[4] = (silLen>>3)&0xFF;
   pattern[5] |= (silLen & 0x07) << 5;
#endif

   return MEDIA_SUCCESS;
}

kal_uint32 Media_GetPlaybackPrebufferFrameNum(Media_Format uFormat)
{
   return 60;
}

kal_bool Media_IsSeekable(STFSAL *pstFSAL, Media_Format uFormat)
{
   return KAL_TRUE;
}

kal_bool Media_IsPauseable(STFSAL *pstFSAL, Media_Format uFormat)
{
   return KAL_TRUE;
}

kal_bool Media_IsFormatSupported(Media_Format uFormat, kal_uint32 channelNum, kal_uint32 freq)
{
   return KAL_TRUE;
}

Media_Status Media_GetSilenceFormat( Media_Format uFormat, kal_uint32 *uChannelNum, kal_uint32 *uSampleRate, kal_uint8 *pBuf, kal_uint32 uBufLen)
{
   return MEDIA_FAIL;
}

kal_uint32 Media_GetAudioPlaybackRingBufferMinSize(Media_Format uFormat)
{
   return 4096; 
}

// LGE dummy function
// LGE BT System (AVM)
void AudioPP_AVM_Enable( void ) {}
void AudioPP_AVM_Disable( void ) {}

// LGE OAEP (Audio Effect Package for Opera)
void AudioPP_OAEP_Enable( void ) {}
void AudioPP_OAEP_Disable( void ) {}
void AudioPP_OAEP_SetEffectMode( kal_uint32 mode, void *param ) {}
void AudioPP_OAEP_SetOutputType( kal_uint32 eType ) {}

Media_Status  Media_GetRecordFormat( Audio_Record_Mode uMode, Audio_Record_Quality uQuality, Audio_Record_Format *pFormatStruct )
{
   pFormatStruct->uFormat = MEDIA_FORMAT_AMR;
   kal_wstrcpy(pFormatStruct->pFileExtension, L".amr");
   pFormatStruct->uByteRate = 1660;	
   return MEDIA_SUCCESS;
}

kal_uint32 Media_GetRecordFormatByteRate( Media_Format uFormat, Audio_Record_Mode uMode, void *param )
{
   return 16000;  
}

void Media_SetBLISRC(kal_bool enable){}

//[VCP]
void      Media_SetChargePump(kal_bool enable, Media_VCP_DS_Module module){}
kal_bool  Media_IsChargePump(void){return KAL_FALSE;}
