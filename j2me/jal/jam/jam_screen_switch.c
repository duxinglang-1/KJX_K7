/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/
/*****************************************************************************
 *
 * Filename:
 * ---------
 *
 *
 * Project:
 * --------
 *  MAUI
 *
 * Description:
 * ------------
 *
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/

#ifdef __J2ME__

/*************************************************************************
 * Include header files
 *************************************************************************/
#include "stdC.h"
#include "MMI_features.h"
#include "mmi_frm_gprot.h"
#include "GlobalDefs.h" /* GLOBAL_SCR_DUMMY */
#include "wgui_categories.h"
#include "wgui_categories_multimedia.h"

#include "j2me_custom_option.h" /* many compile option here */
#include "jal.h"
#include "jal_internal.h"
#include "jui_interface.h"      //JUI MVM
#include "JavaAgencyDef.h"
#include "JavaAgencyGprot.h"
#include "JavaAgencyProt.h"
#include "JavaAgencyUICommon.h"
#include "JavaAgencyUITextBox.h"

#include "gdi_include.h"
#include "gdi_datatype.h"

#define MMIAPI_USING_UI
#define MMIAPI_USING_BLOCKING
#include "mmiapi_struct.h"
#include "mmiapi.h"
#include "mmiapi_res.h"
#include "Mmiapi_func.h"

#include "mdi_audio.h"
#include "device.h"
#include "PowerOnChargerProt.h"
#include "CharBatSrvGprot.h"
#include "IdleAppDef.h" /* popup_screen */

#include "app_str.h"
#include "jbt_interface.h"

#ifdef SUPPORT_JSR_179
#include "jlbs_internal.h"
#endif

#if defined(__OP01__ ) && (defined(__IJET_VM__) || defined(__NEMO_VM__)) && defined(J2ME_SUPPORT_BACKGROUND)            
#include "AlarmResDef.h"           
#endif /* __OP01__  and (__IJET_VM__ or __NEMO_VM__) and J2ME_SUPPORT_BACKGROUND */  
#ifdef __MMI_BACKGROUND_CALL__
#include "UCMResDef.h"
#endif 
#include "commonscreensresdef.h"
#include "jam_internal.h"
#ifdef __DM_LAWMO_SUPPORT__
#include "dmuigprot.h"
#endif

#ifdef __COSMOS_MMI_PACKAGE__
#include "vapp_java_srv.h"
#include "ImeGprot.h"
#endif
#ifdef __MMI_NCENTER_SUPPORT__
#include "JavaAgencyNCenter.h"
#include "vapp_ncenter_gprot.h"
#endif
#include "timerevents.h"
#include "IdleGprot.h"

#ifdef __MMI_TOUCH_FEEDBACK_SUPPORT__
/* under construction !*/
#endif
#include "AppMgrSrvGprot.h" //add by zhao

/*************************************************************************
 * Internal static function
 *************************************************************************/
typedef void (*func_ptr) (void*  vm_data);
static void jam_entry_sublcd_screen(void);
static void jam_exit_sublcd_screen(void);
static void jam_execute_rpc(func_ptr func, void *data,kal_bool is_blocking);
static void jam_send_vm_abort_req(kal_int32 vm_id);
extern kal_int32 g_mmi_java_current_selected_vm_id;

/*************************************************************************
 * Global Definition and Declaration
 *************************************************************************/
kal_bool g_jam_allowed_sending_abort_from_idle = KAL_TRUE;

static kal_int32 g_jam_incoming_call_serial = 0;

static kal_bool g_jam_has_vm_entered_idle_screen = KAL_FALSE;
static kal_bool g_jam_is_force_pauseapp = KAL_FALSE;

#define GOTO_IDLE_SCREEN_AS_EXIT_SCREEN 0

static kal_bool g_jam_refresh_screen_after_resume = KAL_TRUE;
static volatile kal_int32 g_jam_lock_mmi_count = 0;
static kal_bool g_jam_exit_by_asm = KAL_FALSE;
kal_bool g_jam_stop_resume = KAL_FALSE;

extern kal_int32 jm3g_register_graphics3d(void);
extern kal_int32 jm3g_unregister_graphics3d(void);
extern int j2me_deactivate_socket(kal_int32 vm_id);
extern kal_bool is_graphics3d_activated(void);
extern void mmi_java_mids_install_abort(void);    
extern MMI_BOOL mmi_scr_locker_is_locked(void);
kal_bool g_jam_remove_install_file = KAL_FALSE;
kal_bool g_jam_stopFS = KAL_FALSE;
extern kal_bool  jui_is_set_jtwi_symbol;
extern kal_bool g_is_asm_allow_to_launch;

extern kal_bool g_jvm_is_show_ncenter;
kal_bool g_jam_is_allow_show_ncenter = KAL_TRUE;
extern long* g_jam_mvm_little_mem_space_oom;
extern long* g_jam_mvm_whole_heap_space;
extern kal_bool g_jam_user_update_setting_exclusive;
extern kal_int32 g_mmi_java_select_permission_vm_id;
extern kal_bool g_mmi_java_allow_show_icon; 
#ifdef __MMI_NCENTER_SUPPORT__
kal_bool g_jam_ncenter_add_ongoing_cell = KAL_TRUE;
#endif
#if defined( __NEMO_VM__)
extern kal_bool vm_is_force_terminated;
#endif
/* MAUI_03121973 wenmin 20120523 begin */
#if 0
#if defined (__MMI_BACKGROUND_CALL__) && defined (SUPPORT_JSR_135_VIDEO)
/* under construction !*/
/* under construction !*/
#endif
#endif
/* MAUI_03121973 wenmin 20120523 end */
/*****************************************************************************
 * FUNCTION
 *  jam_send_vm_abort_req
 * DESCRIPTION
 *  
 * PARAMETERS
 * RETURNS
 *  void
 *****************************************************************************/
static kal_bool is_need_lock_gdiframebuffer = KAL_FALSE;
static void jui_set_is_need_lock_gdiframebuffer(kal_bool is_need)
{
	is_need_lock_gdiframebuffer = is_need;
}
#ifdef __COSMOS_MMI_PACKAGE__   
static kal_bool jui_get_is_need_lock_gdiframebuffer()
{
	return is_need_lock_gdiframebuffer;
}
#endif
static void jam_send_vm_abort_req(kal_int32 vm_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
   // ilm_struct *ilm_ptr;
    mmi_java_abort_req_struct *msg;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    msg = (mmi_java_abort_req_struct*) construct_local_para(sizeof(mmi_java_abort_req_struct), TD_CTRL);
    msg->vm_id = vm_id;
    java_send_msg_from_active_mod(MOD_JAM,MMI_J2ME_SAP,MSG_ID_MMI_JAVA_ABORT_REQ,msg);
}


/*****************************************************************************
 * FUNCTION
 *  jam_send_vm_asm_abort_req
 * DESCRIPTION
 *  Send abort msg to terminate vm in ASM scinerio
 * PARAMETERS
 * RETURNS
 *  void
 *****************************************************************************/
void jam_send_vm_asm_abort_req(void)
{   
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    //ilm_struct *ilm_ptr;
    mmi_java_abort_req_struct *msg;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    msg = (mmi_java_abort_req_struct*) construct_local_para(sizeof(mmi_java_abort_req_struct), TD_CTRL);
    java_send_msg_from_active_mod(MOD_JAM,MMI_J2ME_SAP,MSG_ID_MMI_JAVA_ASM_ABORT_REQ,msg);
}


/*****************************************************************************
 *****************************************************************************/
#define JAM_RES_LOCK      jam_resmgr_mutex_lock()
#define JAM_RES_UNLOCK    jam_resmgr_mutex_unlock()

static volatile int g_jam_resmgr_mutex_cnt = 0;
static volatile module_type g_jam_resmgr_mutex_tid = MOD_NIL;


/*****************************************************************************
 * FUNCTION
 *  jam_resmgr_mutex_lock
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void jam_resmgr_mutex_lock(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (kal_get_active_module_id() != g_jam_resmgr_mutex_tid)
    {
        while(g_jam_resmgr_mutex_cnt>0)
            kal_sleep_task(1);
        kal_take_mutex(g_jam_resmgr_mutex);
        g_jam_resmgr_mutex_tid = kal_get_active_module_id();
    }
    ++g_jam_resmgr_mutex_cnt;
}


/*****************************************************************************
 * FUNCTION
 *  jam_resmgr_mutex_unlock
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void jam_resmgr_mutex_unlock(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    --g_jam_resmgr_mutex_cnt;

    if (g_jam_resmgr_mutex_cnt == 0)
    {
        g_jam_resmgr_mutex_tid = MOD_NIL;
        kal_give_mutex(g_jam_resmgr_mutex);
    }
}


/*****************************************************************************
 * FUNCTION
 *  jam_resmgr_fbbr_controller
 * DESCRIPTION
 *  manage fbbr depending upon the source state and destination state of VM
 * PARAMETERS
 *  src     [IN]        
 *  dst     [IN]        
 * RETURNS
 *****************************************************************************/
kal_int32 jam_resmgr_fbbr_controller(kal_int32 vm_id,jvm_state_enum src, jvm_state_enum dst)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if DATACACHE_FBBR_ON
    if (dst == JVM_FG_RUNNING_STATE)
    {
        FBBR_heap_init();
    }
    else if (src == JVM_FG_RUNNING_STATE)
    {
        FBBR_heap_finalize();
    }
#endif /* DATACACHE_FBBR_ON */ 
    return 0;
}

#if defined(J2ME_SLIM_MEMORY_SUPPORT) && defined(__JUI_SLIM_SAVE_LAYER__)
extern   void jui_widget_layer_delete_backup(void);
extern   kal_bool jui_widget_is_saved_layer;
#endif

/*****************************************************************************
 * FUNCTION
 *  jam_resmgr_lcd_controller
 * DESCRIPTION
 *  manage LCD depending upon the source state and destination state of VM
 * PARAMETERS
 *  src     [IN]        
 *  dst     [IN]        
 * RETURNS
 *****************************************************************************/
kal_int32 jam_resmgr_lcd_controller(kal_int32 vm_id,jvm_state_enum src, jvm_state_enum dst)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    kal_bool is_resume = src != JVM_TERMINATE_STATE ? KAL_TRUE : KAL_FALSE;
    MMI_ID group_id;
    MMI_ID screen_id;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (dst == JVM_FG_RUNNING_STATE)
    {
        entry_full_screen();
		
        if (!is_resume)
        {
            jui_lcd_mutex_lock();
            jui_widget_mvm_set_screen_mode(JUI_SCREEN_MODE_NORMAL,vm_id);
            jui_lcd_mutex_unlock();
        }
		
        if (is_resume)
        {

            jui_lcd_mutex_lock();
            jui_widget_mvm_register_lcd(KAL_FALSE,vm_id);   //JUI MVM
			
            gdi_layer_lock_frame_buffer();
            jui_widget_mvm_resume_screen(vm_id);            //JUI MVM
            gdi_layer_unlock_frame_buffer();

            jui_lcd_mutex_unlock();
            
            if(g_jam_refresh_screen_after_resume && jui_widget_mvm_get_current_screen(vm_id) != JUI_SCREEN_TYPE_TEXTBOX)
            {
               extern kal_bool   g_jui_resume_first_screen;
               g_jui_resume_first_screen = KAL_TRUE;
               jui_widget_mvm_refresh_lcd(0,0,jui_widget_get_display_width(),/*jui_widget_get_display_height()*/ UI_device_height,vm_id);    //JUI MVM
            }
			else if(jui_widget_mvm_get_current_screen(vm_id) == JUI_SCREEN_TYPE_TEXTBOX)
			{
				jui_set_is_need_lock_gdiframebuffer(KAL_TRUE);
			}
        }
		
        if (src == JVM_FG_MMI_RUNNING_STATE && g_jui_screen_data[vm_id].screen_mode_changed_in_fg_mmi)
        {
            g_jui_screen_data[vm_id].screen_mode_changed_in_fg_mmi = KAL_FALSE;
            jui_widget_mvm_fire_event_listener_void_void(vm_id, JUI_EVENT_SCREEN_MODE_CHANGED);
        }
		
#ifdef __MMI_SUBLCD__   /* SUBLCD */
        ForceSubLCDScreen(jam_entry_sublcd_screen);
#endif 
		
    }
    else if (src == JVM_FG_RUNNING_STATE)
    {
        jui_widget_mvm_unregister_lcd(vm_id);    //JUI MVM

        mmi_frm_get_active_scrn_id(&group_id,&screen_id);
        if( screen_id == GRP_ID_JAVA_TASK_SWITCH)
        {
            jui_widget_mvm_clear_base_layer(vm_id);
        }
		
#ifdef __MMI_SUBLCD__   /* SUBLCD, Should after release audio/vedio */
        GoBackSubLCDHistory();
#endif 
    }
    else if (dst == JVM_BG_RUNNING_STATE)
    {
        jui_widget_mvm_clear_mmi_screen_context(vm_id);
    }
#ifdef __MVM__
#ifdef J2ME_SUPPORT_BACKGROUND
		if(jam_mvm_is_vm_support_bg(vm_id))
		{
            if(dst == JVM_TERMINATE_STATE ||
               dst == JVM_TERMINATING_STATE||
               dst == JVM_FG_RUNNING_STATE||
               dst == JVM_FG_MMI_RUNNING_STATE           
               )
            {
                jui_lcd_mutex_lock();
                gdi_layer_lock_frame_buffer();  //why add lock??, if not, all screen will be blt
                jui_widget_update_vm_bg_status_icon(KAL_FALSE, vm_id);
                gdi_layer_unlock_frame_buffer();
                jui_lcd_mutex_unlock();
            }
            else if(dst != JVM_LONG_EVENT_STATE&&
                        dst != JVM_SHORT_EVENT_STATE||
                        dst == JVM_LONG_EVENT_STATE&&GetActiveScreenId() == SCR_ID_JAVA_UI_TEXTFIELD_EDITOR )
            {
                jui_lcd_mutex_lock();
                gdi_layer_lock_frame_buffer();
                jui_widget_update_vm_bg_status_icon(KAL_TRUE, vm_id);
                gdi_layer_unlock_frame_buffer();
                jui_lcd_mutex_unlock();
            }
		}
#endif /* J2ME_SUPPORT_BACKGROUND */ 

#ifdef __SUPPORT_JAVA_VIRTUAL_KEYPAD__
    if (dst == JVM_TERMINATE_STATE)
    {
        jui_vk_clear(vm_id);
    }
#endif

#if defined(J2ME_SLIM_MEMORY_SUPPORT) && defined(__JUI_SLIM_SAVE_LAYER__)
    if (dst == JVM_TERMINATE_STATE)
    {
        jui_widget_layer_delete_backup();
        jui_widget_is_saved_layer = KAL_FALSE;
    }
#endif

#else
#ifdef J2ME_SUPPORT_BACKGROUND
	if(jam_mvm_is_vm_support_bg(vm_id))
	{
        if (dst == JVM_BG_RUNNING_STATE)
        {
            jui_lcd_mutex_lock();
            gdi_layer_lock_frame_buffer();
            jui_widget_update_vm_bg_status_icon(KAL_TRUE, vm_id);
            gdi_layer_unlock_frame_buffer();
            jui_lcd_mutex_unlock();
        }
        else if (src == JVM_BG_RUNNING_STATE)
        {
            jui_lcd_mutex_lock();
            gdi_layer_lock_frame_buffer();
          jui_widget_update_vm_bg_status_icon(KAL_FALSE, vm_id);
            gdi_layer_unlock_frame_buffer();
            jui_lcd_mutex_unlock();
        }
	}
#endif /* J2ME_SUPPORT_BACKGROUND */ 
#endif /* __MVM__ */	
    return 0;
}


/*****************************************************************************
 * FUNCTION
 *  jam_resmgr_device_controller
 * DESCRIPTION
 *  manage device depending upon the source state and destination state of VM
 * PARAMETERS
 *  src     [IN]        
 *  dst     [IN]        
 * RETURNS
 *****************************************************************************/
kal_int32 jam_resmgr_device_controller(kal_int32 vm_id, jvm_state_enum src, jvm_state_enum dst)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    kal_bool is_resume = KAL_FALSE;
    kal_bool is_pause = KAL_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    jvm_trace_debug("[device_controller]vm_id=%d,src=%d,dst=%d\n",vm_id,src,dst);
    //why add FG_MMI_RUNNING_STATE???
    //reason: support vibrate and blacklight in java mmi screen
    if( (src == JVM_FG_RUNNING_STATE && dst == JVM_FG_MMI_RUNNING_STATE)
        ||
        (src == JVM_FG_MMI_RUNNING_STATE && dst == JVM_FG_RUNNING_STATE))
        return;
    
    if (dst == JVM_FG_RUNNING_STATE || dst == JVM_FG_MMI_RUNNING_STATE)    /* resume and enter  5 */
    {
        if (src != JVM_TERMINATE_STATE)
        {
            is_resume = KAL_TRUE;
        }

        /*****************************************
         * VIBRATE and BACKLIGHT and AUDIO VIDEO *
         * Must Before Audio Switch              *
         *****************************************/
        jvm_GetDeviceControl(is_resume);
        jam_backlight_init();
    }
    else if (src == JVM_FG_RUNNING_STATE || src == JVM_FG_MMI_RUNNING_STATE || dst == JVM_FG_MMI_RUNNING_STATE)   /* event and terminate  3 */
    {
        /*****************************************
         * VIBRATE and BACKLIGHT and AUDIO VIDEO *
         * Must before unregister lcd            *
         *****************************************/

        if (dst != JVM_TERMINATE_STATE)
        {
            is_pause = KAL_TRUE;
        }
        jam_backlight_deinit();
        jvm_ReleaseDeviceControl(is_pause);
    }

    return 0;
}


/*****************************************************************************
 * FUNCTION
 *  jam_resmgr_audio_controller
 * DESCRIPTION
 *  manage audio depending upon the source state and destination state of VM
 *  Active state of audio player:
 *  (1) JVM_FG_RUNNING_STATE
 *  (2) JVM_BG_RUNNING_STATE
 *  (3) JVM_SHORT_EVENT_STATE
 * PARAMETERS
 *  src     [IN]        
 *  dst     [IN]        
 * RETURNS
 *****************************************************************************/
kal_int32 jam_resmgr_audio_controller(kal_int32 vm_id, jvm_state_enum src, jvm_state_enum dst)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Init parameter. The line should be put at the beginning of the function */
    if (src == JVM_TERMINATE_STATE && dst == JVM_FG_RUNNING_STATE)
    {
        /* Init the context when the first VM launched */
        if (JVM_RUNNING_NUM_1 == jam_mvm_get_running_count())
        {
            jma_media_player_clear_parameter(KAL_TRUE);
            /* avoid conflict with touch feedback sound */
        #ifdef __MMI_TOUCH_FEEDBACK_SUPPORT__
/* under construction !*/
        #endif
            /* Register bt callback when midlet is launched */
        #ifdef __BT_SPK_VOL_CONTROL__
        #ifdef __COSMOS_MMI_PACKAGE__
            mdi_audio_bt_register_volume_sync_callback(
                APP_JAVA, 
                MDI_AUD_VOL_LEVEL_EXTEND_MUTE, 
                jam_bt_volume_sync_hdlr);
        #else /* #ifdef __COSMOS_MMI_PACKAGE__ */
            mdi_audio_bt_register_volume_sync_callback(
                APP_JAVA, 
                MDI_AUD_VOL_LEVEL_NORMAL_MUTE, 
                jam_bt_volume_sync_hdlr);
        #endif /* #ifdef __COSMOS_MMI_PACKAGE__ */
        #endif /* #ifdef __BT_SPK_VOL_CONTROL__ */
        }
    }

    /********************************************************************
     * Everytime when Java is FG running, Re-register background callback
     * as highest priority. Deregister background callback until java wants
     * to resume MMI background audio.
     ********************************************************************/
    if (dst == JVM_FG_RUNNING_STATE || dst == JVM_FG_MMI_RUNNING_STATE)
    {
        mdi_audio_set_headset_mode_output_path(MDI_DEVICE_SPEAKER2);
		
        /* Stop MMI audio if java does not play audio && not record audio */
        if (!jma_audio_player_is_really_active() &&
            !jma_audio_recorder_is_really_active(vm_id))
        {
        #ifdef __COSMOS_MMI_PACKAGE__
			if(jui_get_is_need_lock_gdiframebuffer())
			{
			    gdi_layer_lock_frame_buffer();
                mdi_audio_terminate_background_play();
			    gdi_layer_unlock_frame_buffer();
				jui_set_is_need_lock_gdiframebuffer(KAL_FALSE);
			}
			else
			{
                mdi_audio_terminate_background_play();
			}

        #else
            mdi_audio_stop_all();
        #endif
        }
        mdi_audio_set_background_handler(MDI_BACKGROUND_APP_JAVA, jma_audio_player_background_callback, NULL);
    }
    else if (src == JVM_FG_RUNNING_STATE && dst == JVM_BG_RUNNING_STATE ||
		     src == JVM_FG_MMI_RUNNING_STATE && dst == JVM_BG_RUNNING_STATE ||
		     src == JVM_LONG_EVENT_STATE && dst == JVM_BG_RUNNING_STATE)
    {
        if (jma_audio_player_is_active() && jma_audio_player_is_mdi_audio_usable())
        {
            kal_int32 _vm_id = 0;
            kal_int32 num = -1;
            num = mdi_audio_get_background_callback_register_app_num();
            if (num > 0)
            {
                /* Java must be highest priority. */
                mdi_audio_clear_other_background_handler(MDI_BACKGROUND_APP_JAVA);
            }
            for (_vm_id = 0; _vm_id < JVM_NUM; _vm_id++)
            {
                if (jma_audio_is_vm_players_active(_vm_id))
                {
                #ifdef J2ME_SUPPORT_BACKGROUND
                    /* Update Java icon */
				    if(jam_mvm_is_vm_support_bg(vm_id))
				    {
                        jui_widget_update_vm_bg_status_audio_icon(KAL_TRUE, _vm_id);
				    }
                #endif
                }
            }
        }
        else if (!jma_audio_player_is_active())
        {
            mdi_audio_clear_background_handler(MDI_BACKGROUND_APP_JAVA);
        }
    }
    else if (src == JVM_LONG_EVENT_STATE && dst == JVM_PAUSED_STATE)
    {
        mdi_audio_clear_background_handler(MDI_BACKGROUND_APP_JAVA);
    }
    else if (src == JVM_LONG_EVENT_STATE && dst == JVM_TERMINATE_STATE)
    {
        /* The line is put at the following */
        /* mdi_audio_clear_background_handler(MDI_BACKGROUND_APP_JAVA); */
    }

    /********************************************************************
     * When VM state changes, MMAPI should call corresponding handler.  *
     ********************************************************************/
    if (src == JVM_TERMINATE_STATE && dst == JVM_FG_RUNNING_STATE)
    {
        kal_bool in_bg_call = KAL_FALSE;
        
   // #ifdef __MMI_BACKGROUND_CALL__    
        if (jma_media_player_is_in_background_call()) 
        {
            in_bg_call = KAL_TRUE;
        }
   // #endif /* __MMI_BACKGROUND_CALL__ */  

        /* If Java audio is interrupted by MMI (except call),
           resume JAVA audio before Java is foreground running */
        if (is_med_suspend_audio && !in_bg_call)
        {
            jma_audio_player_background_callback(MDI_AUDIO_RESUME, NULL);
        }
    }
    else if (src == JVM_FG_RUNNING_STATE && dst == JVM_LONG_EVENT_STATE ||
             src == JVM_FG_MMI_RUNNING_STATE && dst == JVM_LONG_EVENT_STATE ||
             src == JVM_SHORT_EVENT_STATE && dst == JVM_LONG_EVENT_STATE)
    {
        jma_audio_player_vm_notify_suspend();
    }
    else if (src == JVM_LONG_EVENT_STATE && dst == JVM_BG_RUNNING_STATE)
    {
        kal_bool in_bg_call = KAL_FALSE;

   // #ifdef __MMI_BACKGROUND_CALL__    
        if (jma_media_player_is_in_background_call())
        {
            in_bg_call = KAL_TRUE;
        }
   // #endif /* __MMI_BACKGROUND_CALL__ */
    
        if (!in_bg_call && jma_audio_player_is_mdi_audio_usable())
        {
            jma_audio_player_vm_notify_resume();
        }
    }
    else if (src == JVM_LONG_EVENT_STATE && dst == JVM_FG_RUNNING_STATE ||
             src == JVM_LONG_EVENT_STATE && dst == JVM_FG_MMI_RUNNING_STATE ||
		     src == JVM_PAUSED_STATE && dst == JVM_FG_RUNNING_STATE)
    {
        kal_bool in_bg_call = KAL_FALSE;

  //  #ifdef __MMI_BACKGROUND_CALL__    
        if (jma_media_player_is_in_background_call())
        {
            in_bg_call = KAL_TRUE;
        }
  //  #endif /* __MMI_BACKGROUND_CALL__ */
    
        if (!in_bg_call)
        {
            jma_audio_player_vm_notify_resume();
        }
    }
    else if (src == JVM_BG_RUNNING_STATE && dst == JVM_FG_RUNNING_STATE)
    {        
        kal_bool in_bg_call = KAL_FALSE;
        
   // #ifdef __MMI_BACKGROUND_CALL__    
        if (jma_media_player_is_in_background_call()) 
        {
            in_bg_call = KAL_TRUE;
        }
  //  #endif /* __MMI_BACKGROUND_CALL__ */  

        /* If Java audio is interrupted by MMI (except call),
           resume JAVA audio before Java is foreground running */
        if (is_med_suspend_audio && !in_bg_call)
        {
            jma_audio_player_background_callback(MDI_AUDIO_RESUME, NULL);
        }

        if (is_vm_suspend_audio && !in_bg_call)
        {
            jma_audio_player_vm_notify_resume();
        }
#ifdef __JMA_PREEMPT_PLAYER__        
        if (!in_bg_call)
        {
            jma_audio_player_vm_resume_preempted_players(vm_id);
        }
#endif
    }
    else if ((dst == JVM_TERMINATING_STATE) || 
             (dst == JVM_TERMINATE_STATE && src != JVM_TERMINATING_STATE))
    {
        kal_bool in_bg_call = KAL_FALSE;
  //  #ifdef __MMI_BACKGROUND_CALL__    
        if (jma_media_player_is_in_background_call()) 
        {
            in_bg_call = KAL_TRUE;
        }
  //  #endif /* __MMI_BACKGROUND_CALL__ */  
        
        jma_audio_player_do_terminate_job(src, vm_id);

        if (!in_bg_call)
        {
            if ((src == JVM_LONG_EVENT_STATE || src == JVM_PAUSED_STATE)&&jma_audio_player_is_mdi_audio_usable())
            {
                jma_audio_player_vm_notify_resume();
            }
        }
    }

    /* Reset parameter. The line should be put at the end of the function */
    if (dst == JVM_TERMINATE_STATE)
    {
        if (!jma_audio_player_is_active())
        {
            mdi_audio_clear_background_handler(MDI_BACKGROUND_APP_JAVA);
        }
        /* Rest the context when the last JVM exit */
        if (JVM_RUNNING_NUM_1 == jam_mvm_get_running_count())
        {
        #ifdef __MMI_TOUCH_FEEDBACK_SUPPORT__
/* under construction !*/
        #endif
            //mdi_audio_clear_background_handler(MDI_BACKGROUND_APP_JAVA);
            jma_media_player_clear_parameter(KAL_FALSE);

        /* De-register bt callback when midlet is terminated */
        #ifdef __BT_SPK_VOL_CONTROL__
            mdi_audio_bt_clear_volume_sync_callback(APP_JAVA);
        #endif
        }
    }
    return 0;
}

//#ifdef SUPPORT_JSR_135_VIDEO
/*****************************************************************************
 * FUNCTION
 *  jam_resmgr_video_controller
 * DESCRIPTION
 *  manage video depending upon the source state and destination state of VM
 * PARAMETERS
 *  src     [IN]        
 *  dst     [IN]        
 * RETURNS
 *****************************************************************************/
kal_int32 jam_resmgr_video_controller(kal_int32 vm_id, jvm_state_enum src, jvm_state_enum dst)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (src == JVM_FG_RUNNING_STATE && dst == JVM_SHORT_EVENT_STATE ||
        src == JVM_FG_RUNNING_STATE && dst == JVM_LONG_EVENT_STATE ||
        src == JVM_FG_RUNNING_STATE && dst == JVM_BG_RUNNING_STATE ||
        src == JVM_FG_MMI_RUNNING_STATE && dst == JVM_SHORT_EVENT_STATE ||
        src == JVM_FG_MMI_RUNNING_STATE && dst == JVM_LONG_EVENT_STATE ||
        src == JVM_FG_MMI_RUNNING_STATE && dst == JVM_BG_RUNNING_STATE)
    {
        jma_media_player_vm_notfy_suspend(vm_id);
        #ifdef __JMA_PREEMPT_PLAYER__
        /* Resume audio players when video entry BG state */
        if (JVM_BG_RUNNING_STATE == dst &&
            (jma_video_player_is_active(vm_id) || jma_audio_recorder_is_active(vm_id)))
        {
            jma_video_notify_resume_audio_player(vm_id);
        }
        #endif
    }
    else if (src == JVM_SHORT_EVENT_STATE && dst == JVM_FG_RUNNING_STATE ||
             src == JVM_SHORT_EVENT_STATE && dst == JVM_FG_MMI_RUNNING_STATE ||
		     src == JVM_LONG_EVENT_STATE && dst == JVM_FG_RUNNING_STATE ||
		     src == JVM_LONG_EVENT_STATE && dst == JVM_FG_MMI_RUNNING_STATE ||
		     src == JVM_PAUSED_STATE && dst == JVM_FG_RUNNING_STATE ||
		     src == JVM_BG_RUNNING_STATE && dst == JVM_FG_RUNNING_STATE)
    {
        kal_bool in_bg_call = KAL_FALSE;
        
   // #ifdef __MMI_BACKGROUND_CALL__    
        if (jma_media_player_is_in_background_call()) 
        {
            in_bg_call = KAL_TRUE;
        }
   // #endif /* __MMI_BACKGROUND_CALL__ */

#ifdef __JMA_PREEMPT_PLAYER__
        /* Suspend audio players when video entry FG from BG state */
        if (!in_bg_call && 
            JVM_BG_RUNNING_STATE == src && JVM_FG_RUNNING_STATE == dst &&
            (jma_video_player_is_active(vm_id) || jma_audio_recorder_is_active(vm_id)) &&
            jma_audio_player_is_active())
        {
            jma_video_notify_suspend_audio_player(vm_id);
        }
#endif
        /* Resume video player */
        /* When end the background call, enable the video */
        if (!in_bg_call)
        {
            jma_media_player_vm_notfy_resume(vm_id);
        }
    }
    #ifdef __JMA_PREEMPT_PLAYER__
    else if (src == JVM_LONG_EVENT_STATE && dst == JVM_BG_RUNNING_STATE)
    {
        /* Resume audio players when video entry BG state */
        if (jma_video_player_is_active(vm_id) || jma_audio_recorder_is_active(vm_id))
        {
            jma_video_notify_resume_audio_player(vm_id);
        }
    }
    #endif
    /* Invoke at java exit screen function: jam_pause_screen */
    else if (src == JVM_FG_RUNNING_STATE && dst == JVM_FG_MMI_RUNNING_STATE)
    {
        #ifdef SUPPORT_JSR_135_VIDEO
        jma_media_player_exit_screen_hdlr(vm_id);
		#endif
    }
    /* Invoke at java entry screen function: jam_resume_screen */
    else if (src == JVM_FG_MMI_RUNNING_STATE && dst == JVM_FG_RUNNING_STATE)
    {
        #ifdef SUPPORT_JSR_135_VIDEO
		jma_media_player_entry_screen_hdlr(vm_id);
		#endif
    }
    else if ((dst == JVM_TERMINATING_STATE) || 
             (dst == JVM_TERMINATE_STATE && src != JVM_TERMINATING_STATE))
    {
        kal_bool is_video_active = (kal_bool)(jma_video_player_is_active(vm_id) || jma_audio_recorder_is_active(vm_id));
        jma_media_player_vm_notfy_terminate(vm_id);
        #ifdef __JMA_PREEMPT_PLAYER__
        /* Resume audio players when video entry Terminate state */
        if (is_video_active)
        {
            jma_video_notify_resume_audio_player(vm_id);
        }
        #endif
    }
    return 0;
}
//#endif /* SUPPORT_JSR_135_VIDEO */

/*****************************************************************************
 * FUNCTION
 *  jam_resmgr_graphics3d_controller
 * DESCRIPTION
 *  manage M3G depending upon the source state and destination state of VM
 * PARAMETERS
 *  src     [IN]        
 *  dst     [IN]        
 * RETURNS
 *****************************************************************************/
kal_int32 jam_resmgr_graphics3d_controller(kal_int32 vm_id, jvm_state_enum src, jvm_state_enum dst)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef SUPPORT_JSR_184
    if (dst == JVM_FG_RUNNING_STATE && (src == JVM_TERMINATE_STATE ||
      src == JVM_PAUSED_STATE || src == JVM_BG_RUNNING_STATE || src == JVM_FG_MMI_RUNNING_STATE ))
    {
        jm3g_register_graphics3d();
    }
    else if (dst == JVM_TERMINATE_STATE || dst == JVM_PAUSED_STATE || dst == JVM_BG_RUNNING_STATE 
      || dst == JVM_FG_MMI_RUNNING_STATE)
    {
        jm3g_unregister_graphics3d();
    }
#endif /* SUPPORT_JSR_184 */ 
    return 0;
}


/*****************************************************************************
 * FUNCTION
 *  jam_resmgr_event_controller
 * DESCRIPTION
 *  manage enent handling depending upon the source state and destination state of VM
 * PARAMETERS
 *  src     [IN]        
 *  dst     [IN]        
 * RETURNS
 *****************************************************************************/
kal_int32 jam_resmgr_event_controller(kal_int32 vm_id, jvm_state_enum src, jvm_state_enum dst)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    kal_bool is_resume = KAL_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (dst == JVM_FG_RUNNING_STATE)
    {
        if (src != JVM_TERMINATE_STATE)
        {
            is_resume = KAL_TRUE;
        }
        jvm_register_keypad(is_resume); /* KEYPAD */
        jvm_register_pen_events();      /* PEN EVENT */
    }
    else if (src == JVM_FG_RUNNING_STATE)
    {
        jvm_unregister_keypad();        /* KEYPAD */
        jvm_unregister_pen_events();    /* PEN EVENT */
    }
    return 0;
}


/*****************************************************************************
 * FUNCTION
 *  jam_resmgr_file_controller
 * DESCRIPTION
 *  manage file  depending upon the source state and destination state of VM
 * PARAMETERS
 *  src     [IN]        
 *  dst     [IN]        
 * RETURNS
 *****************************************************************************/
kal_int32 jam_resmgr_file_controller(kal_int32 vm_id, jvm_state_enum src, jvm_state_enum dst)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Justin TODO: JSR75-File  */

    if (dst == JVM_FG_RUNNING_STATE)
    {
        disk_changed = KAL_TRUE;
        jvm_file_disk_changed_callback_handler();
    }
    else if (src == JVM_FG_RUNNING_STATE)
    {
    }

    return 0;
}

/*****************************************************************************
 * FUNCTION
 *  jam_resmgr_wma_controller
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src     [IN]        
 *  dst     [IN]        
 * RETURNS
 *****************************************************************************/
kal_int32 jam_resmgr_wma_controller(kal_int32 vm_id, jvm_state_enum src, jvm_state_enum dst)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if ((src == JVM_BG_RUNNING_STATE || src == JVM_PAUSED_STATE) && 
        (dst == JVM_FG_RUNNING_STATE || dst == JVM_FG_MMI_RUNNING_STATE || dst == JVM_SHORT_EVENT_STATE || dst == JVM_LONG_EVENT_STATE))
    {
#ifdef SUPPORT_JSR_120     
        J2ME_sms_process_pending_task_by_controller();
#endif
#ifdef SUPPORT_JSR_205
        J2ME_mms_process_pending_task_by_controller();
#endif
    }
	
    return 0;
}


/*****************************************************************************
 * FUNCTION
 *  jam_resmgr_lbs_controller
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src     [IN]        
 *  dst     [IN]        
 * RETURNS
 *****************************************************************************/
kal_int32 jam_resmgr_lbs_controller(kal_int32 vm_id, jvm_state_enum src, jvm_state_enum dst)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef SUPPORT_JSR_179
    if ((src == JVM_BG_RUNNING_STATE || src == JVM_PAUSED_STATE || src == JVM_TERMINATING_STATE || src == JVM_TERMINATE_STATE) && 
        (dst == JVM_FG_RUNNING_STATE || dst == JVM_FG_MMI_RUNNING_STATE))
    {
        jlbs_gps_get_settings();
    }
#endif
    return 0;
}


/*****************************************************************************
 * FUNCTION
 *  jam_resmgr_network_controller
 * DESCRIPTION
 *  manage network depending upon the source state and destination state of VM
 * PARAMETERS
 *  src     [IN]        
 *  dst     [IN]        
 * RETURNS
 *****************************************************************************/
kal_int32 jam_resmgr_network_controller(kal_int32 vm_id, jvm_state_enum src, jvm_state_enum dst)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return 0;
}


/*****************************************************************************
 * FUNCTION
 *  jam_resmgr_vm_controller
 * DESCRIPTION
 *  manage VM depending upon the source state and destination state of VM
 * PARAMETERS
 *  src     [IN]        
 *  dst     [IN]        
 * RETURNS
 *****************************************************************************/
kal_int32 jam_resmgr_vm_controller(kal_int32 vm_id, jvm_state_enum src, jvm_state_enum dst)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    kal_trace(TRACE_STATE,FUNC_JVM_RESMGR_VM_CONTROLLER, vm_id, src, dst);

    jui_widget_mvm_fire_event_listener_void_void(vm_id,JUI_EVENT_VM_ACTIVE_NOTIFY);
    if (dst == JVM_TERMINATING_STATE)
        {
            jam_stopVMExternal(vm_id);
        }
    else if (dst == JVM_FG_RUNNING_STATE)
    {
        if (src == JVM_TERMINATE_STATE)
        {
            jam_initVMExternal(vm_id);
        }
        else if( src == JVM_BG_RUNNING_STATE )
        {
            jam_activeVMExternal(vm_id, src, dst);
        }
        else if( src != JVM_FG_MMI_RUNNING_STATE )
        {
            jam_resumeVMExternal(vm_id, src, dst);
        }
    }
    else if(dst == JVM_FG_MMI_RUNNING_STATE)
    {
      if(src != JVM_FG_RUNNING_STATE)
      {
         jam_resumeVMExternal(vm_id, src, dst);
      }
    }
    else if(dst == JVM_BG_RUNNING_STATE)
    {
        //Trans state from FG to BG directly, such as press home key, or notifyPaused
        if(src == JVM_FG_RUNNING_STATE || src == JVM_FG_MMI_RUNNING_STATE)
        {
            jam_minimizeVMExternal(vm_id, src, dst);
        }
        else if(src == JVM_LONG_EVENT_STATE)
        {
            jam_resumeVMExternal(vm_id, src, dst);
        }
        // Do any other state trans to BG ?
    }
    else if(dst == JVM_TERMINATE_STATE)
    {
        ;//no need do anythings for MVM;
    }
    else
    {
        jam_pauseVMExternal(vm_id,src, dst);
    }
	
    if (dst == JVM_BG_RUNNING_STATE)
    {
        stack_change_priority_by_module_ID(MOD_J2ME, TASK_PRIORITY_JVM_BG);
    }
    else if (src == JVM_BG_RUNNING_STATE)
    {
        stack_change_priority_by_module_ID(MOD_J2ME, TASK_PRIORITY_JVM);
    }
	
    return 0;
}

/*****************************************************************************
 *****************************************************************************/
typedef struct
{
    kal_int32(*controller) (kal_int32 vm_id,jvm_state_enum, jvm_state_enum);
} jvm_resmgr_ctrl_entry;

jvm_resmgr_ctrl_entry ctrl_tbl[] = 
{
    jam_resmgr_fbbr_controller,
    jam_resmgr_lcd_controller,
    jam_resmgr_device_controller,
    jam_resmgr_audio_controller,
//#ifdef SUPPORT_JSR_135_VIDEO
    jam_resmgr_video_controller,
//#endif /* SUPPORT_JSR_135_VIDEO */
    jam_resmgr_graphics3d_controller,
    jam_resmgr_event_controller,
    jam_resmgr_file_controller,
    jam_resmgr_wma_controller,
    jam_resmgr_lbs_controller,
    jam_resmgr_network_controller,
    jam_resmgr_vm_controller
};

#define CTRL_TBL_SIZE (sizeof(ctrl_tbl) / sizeof(jvm_resmgr_ctrl_entry))

/*****************************************************************************
 * FUNCTION
 *  jam_resmgr_state_transition
 * DESCRIPTION
 *  This function will be invoked when state will be changed.
 *  It call all resource manager callback function to do correspounding action
 * PARAMETERS
 *  dst     [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void jam_resmgr_state_transition(kal_int32 vm_id,jvm_state_enum dst)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    kal_int32 result, i;
    jvm_state_enum src = (jvm_state_enum)jam_mvm_get_vm_state(vm_id);
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    kal_trace(TRACE_STATE, FUNC_JVM_RESMGR_STATE_TRANSITION,vm_id, src, dst);

    if (src == dst)
    {
        return;
    }

    /* invalid state transition */
    if ((src == JVM_FG_RUNNING_STATE && dst == JVM_PAUSED_STATE) ||
        (src == JVM_BG_RUNNING_STATE && dst == JVM_SHORT_EVENT_STATE) ||
        (src == JVM_BG_RUNNING_STATE && dst == JVM_LONG_EVENT_STATE) ||
        (src == JVM_BG_RUNNING_STATE && dst == JVM_PAUSED_STATE) ||
        (src == JVM_SHORT_EVENT_STATE && dst == JVM_BG_RUNNING_STATE) ||
        (src == JVM_SHORT_EVENT_STATE && dst == JVM_PAUSED_STATE) ||
        (src == JVM_LONG_EVENT_STATE && dst == JVM_SHORT_EVENT_STATE) ||
        (src == JVM_PAUSED_STATE && dst == JVM_BG_RUNNING_STATE) ||
        (src == JVM_PAUSED_STATE && dst == JVM_SHORT_EVENT_STATE) ||
        (src == JVM_PAUSED_STATE && dst == JVM_LONG_EVENT_STATE) ||
        (src == JVM_TERMINATING_STATE && dst != JVM_TERMINATE_STATE) ||
        (src == JVM_TERMINATE_STATE && dst != JVM_BG_RUNNING_STATE && dst != JVM_FG_RUNNING_STATE)
        )
    {
        EXT_ASSERT(0,0,0,0);
    }

    StopTimer(J2ME_VM_EVENT_TIMER);

    JAM_RES_LOCK;

    jam_mvm_set_vm_state(vm_id,dst);
    /* Recording current FG running midlet, only support 1 midlet can run at FG,*/
    if(dst == JVM_FG_MMI_RUNNING_STATE||
       dst == JVM_FG_RUNNING_STATE)
    {
        jam_mvm_set_current_vm_id(vm_id);
        /*#ifdef __COSMOS_MMI_PACKAGE__
        if (src == JVM_BG_RUNNING_STATE)
        {
            vapp_java_request_ncenter_leave(vm_id); //MAUI_02745615
        }
        #endif*/
    }
    if (src > dst)  /* release */
    {
        for (i = CTRL_TBL_SIZE - 1; i >= 0; i--)
        {
            result = ctrl_tbl[i].controller(vm_id,src, dst);
        }
    }
    else    /* get */
    {
        for (i = 0; i < CTRL_TBL_SIZE; i++)
        {
            result = ctrl_tbl[i].controller(vm_id,src, dst);
        }
    }
    if (result < 0)
    {
        EXT_ASSERT(0,0,0,0);
    }
    /*Reset current running midlet vm id to invalide*/
    if( jam_mvm_get_current_vm_id()== vm_id &&
        src != JVM_TERMINATING_STATE &&
        (dst == JVM_TERMINATING_STATE || 
         dst == JVM_TERMINATE_STATE  ||
         dst == JVM_BG_RUNNING_STATE))
    {
	    jam_mvm_set_current_vm_id(INVALIDE_VM_ID);
    }
#ifdef __MMI_NCENTER_SUPPORT__
    if(dst == JVM_TERMINATING_STATE||
        dst == JVM_TERMINATE_STATE||
        dst == JVM_FG_RUNNING_STATE|
        dst == JVM_FG_MMI_RUNNING_STATE)
        mmi_java_ncenter_on_going_cell_remove(vm_id);
    if(dst == JVM_BG_RUNNING_STATE||
       dst == JVM_LONG_EVENT_STATE  && g_jam_ncenter_add_ongoing_cell )
    {
        if(jam_mvm_get_vm_state(vm_id)!= JVM_TERMINATE_STATE &&
            jam_mvm_get_vm_state(vm_id)!= JVM_TERMINATING_STATE)
        {
            mmi_java_ncenter_on_going_cell_add(vm_id);
        }
    }
    else if(g_jam_ncenter_add_ongoing_cell == KAL_FALSE)
    {
        g_jam_ncenter_add_ongoing_cell = KAL_TRUE;
    }
    if (src == JVM_LONG_EVENT_STATE && dst == JVM_FG_RUNNING_STATE)
    {
    	  /* kal_sleep_task(40);	*/	
    }
    #endif
    JAM_RES_UNLOCK;
}


/*****************************************************************************
 * FUNCTION
 *  jam_is_in_terminate_menu
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
kal_bool jam_is_in_terminate_menu(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    kal_uint16 screen_id = GetActiveScreenId();
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (screen_id == SCR_JAVA_TERMINATE_DIALOG)
    {
        return KAL_TRUE;
    }
    else
    {
        return KAL_FALSE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  jam_mvm_is_minimize_mode
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
kal_bool jam_mvm_is_minimize_mode(kal_int32 vm_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef J2ME_SUPPORT_BACKGROUND
	if(jam_mvm_is_vm_support_bg(vm_id))
	{
        return (kal_bool)(jam_mvm_get_vm_state(vm_id)== JVM_BG_RUNNING_STATE);
	}
	else
	{
	    return KAL_FALSE;
	}
#else 
    return KAL_FALSE;
#endif 
}

/*****************************************************************************
 * FUNCTION
 *  jam_usb_mode_check
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
kal_bool jam_usb_mode_check(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
   // kal_int32 vm_id=0;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
//#ifdef J2ME_SUPPORT_BACKGROUND
    return (kal_bool)(mmi_java_is_installing()||
    (jam_mvm_get_running_count() > 0));
//#else 
//    return mmi_java_is_installing();
//#endif 
}


/*****************************************************************************
 * FUNCTION
 *  jam_enter_usb_mode
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void jam_enter_usb_mode(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    kal_trace(JAM_JAVAAGENCY_GROUP, JAM_ENTER_USB_MODE);
    if(g_java.screen_after_terminate == TER_ENTRY_TASK_MANAGER)
        g_java.screen_after_terminate = TER_ENTRY_NONE;    
    mmi_java_mids_install_abort();
//#ifdef J2ME_SUPPORT_BACKGROUND
    jam_mvm_shutdown_all_req();
#ifdef J2ME_SLIM_MEMORY_SUPPORT
    if (jam_mvm_is_shutdowning())
    {
       mmi_java_entry_terminating(MMI_FALSE);
    }
#endif
//#endif 
    g_jam_remove_install_file = KAL_TRUE;
#ifdef __COSMOS_MMI_PACKAGE__
    vapp_java_close_MIDelt_screen();
#endif
}


/*****************************************************************************
 * FUNCTION
 *  jam_enter_usb_ms_callback
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
mmi_ret jam_enter_usb_ms_callback(mmi_event_struct *evt)
{

    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    kal_trace(JAM_JAVAAGENCY_GROUP ,JAM_ENTER_USB_MS_CALLBACK);
    if(jam_usb_mode_check())
    {
        jam_enter_usb_mode();
    }
#ifdef __COSMOS_MMI_PACKAGE__
    vapp_java_close_venus_screen();
#endif
    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  jam_card_plug_in_out_callback
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
mmi_ret jam_card_plug_in_out_callback(mmi_event_struct *evt)
{
	
#if defined(J2ME_SLIM_MEMORY_SUPPORT)

    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	mmi_java_plug_in_out_tcard_struct *msg;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

	 msg = (mmi_java_plug_in_out_tcard_struct*) OslConstructDataPtr(sizeof(mmi_java_plug_in_out_tcard_struct));
     msg->evt_id=evt->evt_id;
	 mmi_java_send_message_from_active_mod( MOD_JAM, MMI_J2ME_SAP,
			MSG_ID_MMI_JAVA_PLUG_IN_OUT_TCARD_IND, msg);



#endif

    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  jam_mvm_is_vm_running
 * DESCRIPTION
 *  check whether given vm_id is running a midlet?
 * PARAMETERS
 *  kal_int32 vm_id
 * RETURNS
 *  kal_bool
 *****************************************************************************/
kal_bool jam_mvm_is_vm_running(kal_int32 vm_id)
{
    return (kal_bool)(jam_mvm_get_vm_state(vm_id)!=JVM_TERMINATE_STATE && jam_mvm_get_vm_state(vm_id)!=JVM_TERMINATING_STATE);
}
/*****************************************************************************
 * FUNCTION
 *  jam_mvm_is_vm_terminating
 * DESCRIPTION
 *  check whether given vm_id is terminating a midlet?
 * PARAMETERS
 *  kal_int32 vm_id
 * RETURNS
 *  kal_bool
 *****************************************************************************/
kal_bool jam_mvm_is_vm_terminating(kal_int32 vm_id)
{
    return (kal_bool)(jam_mvm_get_vm_state(vm_id)==JVM_TERMINATING_STATE);
}

/*****************************************************************************
 * FUNCTION
 *  jam_is_pause_mode
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
kal_bool jam_mvm_is_pause_mode(kal_int32 vm_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef J2ME_SUPPORT_PAUSE
    return (kal_bool)(jam_mvm_get_vm_state(vm_id) == JVM_PAUSED_STATE || jam_mvm_get_vm_state(vm_id) == JVM_SHORT_EVENT_STATE ||
         jam_mvm_get_vm_state(vm_id) == JVM_LONG_EVENT_STATE);

#else /* J2ME_SUPPORT_PAUSE */ 
    return (kal_bool)(jam_mvm_get_vm_state(vm_id) == JVM_SHORT_EVENT_STATE || jam_mvm_get_vm_state(vm_id) == JVM_LONG_EVENT_STATE);

#endif /* J2ME_SUPPORT_PAUSE */ 
}


/*****************************************************************************
 * FUNCTION
 *  jam_mvm_is_teminate_mode
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
kal_bool jam_mvm_is_teminate_mode(kal_int32 vm_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return (kal_bool)(jam_mvm_get_vm_state(vm_id) == JVM_TERMINATE_STATE);
}



/*****************************************************************************
 * FUNCTION
 *  jam_is_in_background_long_time
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
kal_bool jam_is_in_background_long_time(kal_int32 vm_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return (kal_bool)(jam_mvm_get_vm_state(vm_id) == JVM_PAUSED_STATE);
}

/*****************************************************************************
 * FUNCTION
 *  jam_is_own_java_screen
 * DESCRIPTION
 *  To check if java task get the control now
 *  (PS. resource may not be ready)
 * PARAMETERS
 *  void
 * RETURNS
 *  KAL_TRUE    java task get the control,the screen is drawed by java
 *****************************************************************************/
kal_bool jam_is_own_java_screen(kal_int32 vm_id)
{
	/*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

   return jam_is_in_fg_screen(vm_id);
}

/*****************************************************************************
* FUNCTION
*  jam_is_own_mmi_screen
* DESCRIPTION
*  To check if java task get the control now
*  (PS. resource may not be ready)
* PARAMETERS
*  void
* RETURNS
*  KAL_TRUE    java is using mmi screen
*****************************************************************************/
kal_bool jam_is_own_mmi_screen(kal_int32 vm_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

   return jam_is_in_fg_mmi_screen(vm_id);
}

/*****************************************************************************
* FUNCTION
*  jam_is_own_screen
* DESCRIPTION
*  To check if java task get the control now
*  (PS. resource may not be ready)
* PARAMETERS
*  void
* RETURNS
*  KAL_TRUE    java task get the control
*****************************************************************************/
kal_bool jam_is_own_screen(void)
{
	/*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    kal_bool result;
    kal_int32 vm_id = jam_mvm_get_current_vm_id();
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (jam_mvm_get_vm_state(vm_id)== JVM_FG_RUNNING_STATE || jam_mvm_get_vm_state(vm_id) == JVM_FG_MMI_RUNNING_STATE )
    {
        result = KAL_TRUE;
    }
    else
    {
        result = KAL_FALSE;
    }

    return result;
}

/*****************************************************************************
 * FUNCTION
*  jam_is_in_fg_screen
 * DESCRIPTION
 *  To check if java task get the control now
 *  (PS. resource may not be ready)
 * PARAMETERS
 *  void
 * RETURNS
*  KAL_TRUE    java task get the control
 *****************************************************************************/

kal_bool jam_is_in_fg_screen(kal_int32 vm_id)
{
   /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    kal_bool result;
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (jam_mvm_get_vm_state(vm_id) == JVM_FG_RUNNING_STATE)
    {
        result = KAL_TRUE;
    }
    else
    {
        result = KAL_FALSE;
    }
   
    return result;
		}
		
/*****************************************************************************
 * FUNCTION
*  jam_is_in_fg_mmi_screen
 * DESCRIPTION
 *  To check if java task get the control now
 *  (PS. resource may not be ready)
 * PARAMETERS
 *  void
 * RETURNS
 *  KAL_TRUE    java task get the control
 *****************************************************************************/

kal_bool jam_is_in_fg_mmi_screen(kal_int32 vm_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    kal_bool result;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (jam_mvm_get_vm_state(vm_id) == JVM_FG_MMI_RUNNING_STATE)
    {
        result = KAL_TRUE;
    }
    else
    {
        result = KAL_FALSE;
    }

    return result;
}


/*****************************************************************************
 * FUNCTION
 *  jam_is_lock_mmi
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
kal_bool jam_is_lock_mmi(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    kal_bool result;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    JAM_RES_LOCK;
    result = g_jam_lock_mmi_count > 0 ? KAL_TRUE : KAL_FALSE;
    JAM_RES_UNLOCK;
    return result;
}


/*****************************************************************************
 * FUNCTION
 *  jam_is_allow_format
 * DESCRIPTION
 *  
 * PARAMETERS
 *  drive       [IN]        
 * RETURNS
 *  
 *****************************************************************************/
kal_bool jam_is_allow_format(CHAR drive)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_java_is_installing())
    {
        return MMI_FALSE;
    }

    if (jam_mvm_has_running_vm_on_driver((kal_int8)drive))
    {
        return KAL_FALSE;
    }
    else
    {
        return KAL_TRUE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  jam_exit_screen_callback_for_asm
 * DESCRIPTION
 *  This function will be invoked when asm requests Java to free memory.
 *  This function will only be invoked in MMI context.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void jam_exit_screen_callback_for_asm(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_jam_exit_by_asm = KAL_TRUE;
    if(!jam_mvm_is_shutdowning())
    {
        jam_terminate_by_asm(); // need ke modify
    }
}


/*****************************************************************************
 * FUNCTION
 *  jam_applib_mem_ap_notify_stop_finished_call_back
 * DESCRIPTION
 *  This function will be invoked right after Java free ASM memory.
 *  This function will be invoked in Java context.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void jam_applib_mem_ap_notify_stop_finished_call_back(void *data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    kal_bool * keep = NULL;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    kal_trace(JAM_JAVAAGENCY_GROUP, JAM_APPLIB_MEM_AP_NOTIFY_STOP_FINISHED_CB);
    keep = (kal_bool*)data;
    if(*keep == KAL_FALSE)
    {
        applib_mem_ap_notify_stop_finished(APPLIB_MEM_AP_ID_JAVA, KAL_TRUE);
        g_jam_mvm_little_mem_space_oom = NULL;
    }
    g_jam_mvm_whole_heap_space = NULL;
}


/*****************************************************************************
 * FUNCTION
 *  jam_asm_free_mem_notification
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void jam_asm_free_mem_notification(kal_bool* keep)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    kal_trace(JAM_JAVAAGENCY_GROUP, JAM_ASM_FREE_MEM_NOTIFICATION);
    g_jam_exit_by_asm = KAL_FALSE;
    jam_execute_rpc((func_ptr) jam_applib_mem_ap_notify_stop_finished_call_back, keep,KAL_FALSE);
}


/*****************************************************************************
 * FUNCTION
 *  jam_draw_sublcd_icon
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void jam_draw_sublcd_icon(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    kal_int32 image_width;
    kal_int32 image_height;
    kal_int32 lcd_width;
    kal_int32 lcd_height;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_lcd_set_active(GDI_LCD_SUB_LCD_HANDLE);
    gdi_lcd_get_dimension(&lcd_width, &lcd_height);

    gdi_layer_reset_clip();

    gdi_layer_clear_background(GDI_COLOR_WHITE);
    gdi_image_get_dimension_id(IMG_JAVA_POWERED, &image_width, &image_height);
    gdi_image_draw_id((lcd_width - image_width) >> 1, (lcd_height - image_height) >> 1, IMG_JAVA_POWERED);
    gdi_layer_blt_base_layer(0, 0, lcd_width - 1, lcd_height - 1);

    gdi_lcd_set_active(GDI_LCD_MAIN_LCD_HANDLE);

}


/*****************************************************************************
 * FUNCTION
 *  jam_entry_sublcd_screen
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void jam_entry_sublcd_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ExecSubLCDCurrExitHandler();
    ShowCategory331Screen();
    SetSubLCDExitHandler(jam_exit_sublcd_screen);

    /* draw a icon on sub */
    jam_draw_sublcd_icon();

}


/*****************************************************************************
 * FUNCTION
 *  jam_exit_sublcd_screen
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void jam_exit_sublcd_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    SubLCDHistoryNode SubLCDHistory;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    SubLCDHistory.entryFuncPtr = jam_entry_sublcd_screen;
    AddSubLCDHistory(&SubLCDHistory);
}


/*****************************************************************************
 * FUNCTION
 *  jam_send_terminate_change_state_ind
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void      
 * RETURNS
 *  void
 *****************************************************************************/
void jam_send_terminate_notify_ind(void* data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_java_terminate_notify_struct * old_terminate_ptr = (mmi_java_terminate_notify_struct *) data;
    mmi_java_terminate_notify_struct * new_terminate_ptr = NULL;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    new_terminate_ptr = (mmi_java_terminate_notify_struct*) construct_local_para(sizeof(mmi_java_terminate_notify_struct), TD_CTRL);
    new_terminate_ptr->vm_id = old_terminate_ptr->vm_id;
    new_terminate_ptr->return_code = old_terminate_ptr->return_code;
    new_terminate_ptr->is_timealarm_push_start = old_terminate_ptr->is_timealarm_push_start;
    new_terminate_ptr->is_tck = old_terminate_ptr->is_tck;
    java_send_msg_from_active_mod(MOD_JAM,MMI_J2ME_SAP,MSG_ID_MMI_JAVA_TERMINATE_NOTIFY_IND,new_terminate_ptr);
}


/*****************************************************************************
 * FUNCTION
 *  jam_execute_rpc
 * DESCRIPTION
 *  
 * PARAMETERS
 *  func            [IN]        
 *  is_blocking     [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
static void jam_execute_rpc(func_ptr func, void *data,kal_bool is_blocking)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmiapi_remote_proc_call_struct *rpc;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    rpc = (mmiapi_remote_proc_call_struct*) construct_local_para(sizeof(mmiapi_remote_proc_call_struct), TD_CTRL);

    rpc->type = MMIAPI_RPC_POINTER;
    rpc->func_ptr = (void*)func;
    rpc->_u.p = data;
    rpc->finish_callback = NULL;
    rpc->validate_callback = NULL;

    if (is_blocking)
    {
        rpc->blocking_data = mmiapi_get_blocking_data(MOD_JAM);
    }
    else
    {
        rpc->blocking_data = NULL;
    }
    java_send_msg_from_active_mod(MOD_MMI,J2ME_MMI_SAP,MSG_ID_MMIAPI_REMOTE_PROC_CALL_REQ,rpc);
}


/*****************************************************************************
 * FUNCTION
 *  jam_goto_idle_screen_callback
 * DESCRIPTION
 *  jvm exit screen handler
 * (1) This funtion only allow to be executed in MMI
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void jam_goto_idle_screen_callback(void *data)    /* this function is call by MMI */
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_java_terminate_notify_struct * terminate_ptr = (mmi_java_terminate_notify_struct*)data;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    kal_trace(TRACE_STATE, FUNC_JVM_GOTO_IDLE_SCREEN_CALLBACK,terminate_ptr->vm_id);
    jam_resmgr_state_transition(terminate_ptr->vm_id,JVM_TERMINATE_STATE);
    jam_send_terminate_notify_ind(data);
    free_ctrl_buffer(data);
    //ClearDelScrnIDCallbackHandler(SCR_JAVA_APP, NULL);
     //delete mmi releated screends
    jam_delete_fg_mmi_screen();
    if (mmi_frm_group_is_present(GRP_ID_JAVA_APP))  /* java is in history */
    {
        mmi_frm_group_close(GRP_ID_JAVA_APP);    /* /TODO: maybe we should clear all the historys below the SCR_JAVA_APP */
    }
    else
    {
        mmi_idle_display();
    }
}


/*****************************************************************************
 * FUNCTION
 *  jam_goto_idle_screen
 * DESCRIPTION
 *  Vm is terminated by End key => pause or Terminate
 *  (1) This funtion only allow to be executed in JAM task
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void jam_goto_idle_screen(void *vm_ptr) /* this function is call by JAVA */
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    kal_trace(TRACE_STATE, FUNC_JVM_GOTO_IDLE_SCREEN,((mmi_java_terminate_notify_struct*)vm_ptr)->vm_id);

#if GOTO_IDLE_SCREEN_AS_EXIT_SCREEN
    jam_execute_rpc((func_ptr) jam_exit_screen_callback,vm_ptr, KAL_TRUE);   /* this goback history should run in MMI task. */
#else 
    jam_execute_rpc((func_ptr) jam_goto_idle_screen_callback,vm_ptr, KAL_TRUE);      /* this goback history should run in MMI task. */
#endif 
}


#ifdef __COSMOS_MMI_PACKAGE__
kal_bool jam_is_allow_close_venus_screen(kal_int32 vm_id)
{
    if(g_mmi_java_current_selected_vm_id == -1 &&
        !mmi_java_is_installing()&&
        !g_jam_user_update_setting_exclusive &&
        !g_vjava_is_select_screen_active &&
        !vapp_java_is_in_task_manager()/* Avoid main menu get list */)
    {
        return KAL_TRUE;
    }
    if(g_vjava_screen_switch != GRP_ID_INVALID && g_mmi_java_current_selected_vm_id == vm_id)
    {
        return KAL_TRUE;
    }
    if(g_mmi_java_select_permission_vm_id == vm_id)
    {
        return KAL_TRUE;
    }
    return KAL_FALSE;
}
#endif


/*****************************************************************************
 * FUNCTION
 *  jam_exit_screen_callback
 * DESCRIPTION
 *  (1) Vm is terminated normally (not press end key)
 *  (2) Launch Midlet fail, 
 *  (3) This funtion only allow to be executed in MMI
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void jam_exit_screen_callback(void *data) /* this function is call by MMI */
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_java_terminate_notify_struct * terminate_ptr = (mmi_java_terminate_notify_struct*)data;
    kal_int32 vm_id = terminate_ptr->vm_id;
    kal_bool is_bg_running = (kal_bool)(jam_mvm_get_vm_state(vm_id) == JVM_BG_RUNNING_STATE);
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    kal_trace(TRACE_STATE, FUNC_JVM_EXIT_SCREEN_CALLBACK,terminate_ptr->vm_id, jam_mvm_get_vm_state(terminate_ptr->vm_id));

    jam_resmgr_state_transition(terminate_ptr->vm_id,JVM_TERMINATE_STATE);
    jui_widget_mvm_finalize_screen(terminate_ptr->vm_id);
    jam_send_terminate_notify_ind(data);
    if(jam_mvm_get_current_vm_id() == INVALIDE_VM_ID)
    {
        /*only need close*/
        if(g_mmi_java_current_selected_vm_id != INVALID_VM_ID && 
           g_mmi_java_current_selected_vm_id == terminate_ptr->vm_id)
        {
            mmi_frm_group_close(GRP_ID_JAVA_TASK_SWITCH);
        } 

#ifndef J2ME_SLIM_MEMORY_SUPPORT
        if (!is_bg_running)
        {
            mmi_frm_group_close(GRP_ID_JAVA_APP);
            mmi_frm_group_close(GRP_ID_JAVA_TEXTFIELD);
            mmi_frm_group_close(GRP_ID_JAVA_CONFIRM);
            jam_delete_fg_mmi_screen();
            mmi_frm_group_close(GRP_ID_JAVA_TERMINATE_CB);
        }
#endif	
#ifdef __COSMOS_MMI_PACKAGE__
        if(jam_get_g_jam_exit_by_asm()||jam_is_allow_close_venus_screen(terminate_ptr->vm_id))
        {
            vapp_java_close_venus_screen();
        }
        vcp_global_popup_cancel(g_vjava_force_resume_global_popup);
        g_vjava_force_resume_global_popup = GRP_ID_INVALID;
        vcp_global_popup_cancel(g_vjava_terminate_confirm_global_popup);
        g_vjava_terminate_confirm_global_popup = GRP_ID_INVALID;
        vcp_global_popup_cancel(g_vjava_global_popup);
        g_vjava_global_popup = GRP_ID_INVALID;
#endif


        mmi_java_ui_common_reset_mmi_status_icon(terminate_ptr->vm_id);
    }
    free_ctrl_buffer(data);
    g_jam_is_allow_show_ncenter = KAL_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  jam_exit_screen
 * DESCRIPTION
 *  (1) This funtion only allow to be executed in JAM task
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void jam_exit_screen(void *vm_ptr)  /* this function is call by JAVA */
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    kal_trace(TRACE_STATE, FUNC_JVM_EXIT_SCREEN,((mmi_java_terminate_notify_struct*)vm_ptr)->vm_id);
    jam_execute_rpc((func_ptr) jam_exit_screen_callback, vm_ptr,KAL_TRUE);   /* this goback history should run in MMI task. */
}


/*****************************************************************************
 * FUNCTION
 *  jam_exit_dummy_screen
 * DESCRIPTION
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void jam_exit_dummy_screen(void)
{
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
}


/*****************************************************************************
 * FUNCTION
 *  jam_pause_dummy_screen
 * DESCRIPTION
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void jam_pause_dummy_screen(void)
{
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
}


/*****************************************************************************
 * FUNCTION
 *  jam_resume_dummy_screen
 * DESCRIPTION
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void jam_resume_dummy_screen(void)
{
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
}

void jam_resume_screen_ext(void);
kal_bool jam_is_allow_enter_java_screen(void);
/*****************************************************************************
 * FUNCTION
 *  jam_resume_screen
 * DESCRIPTION
 *  jvm resume screen handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void jam_resume_screen(void)    /* this function is call by MMI */
{
    S32 is_redraw = mmi_is_redrawing_bk_screens();
    if(!jam_is_allow_enter_java_screen() && !is_redraw)
    {
        kal_trace(JAM_JAVAAGENCY_GROUP,JAM_RESUME_SCREEN_NOT_ALLOW);
        return;
    }

    if(mmi_frm_scrn_is_present(GRP_ID_JAVA_APP,SCR_JAVA_APP,MMI_FRM_NODE_EXCLUDE_ACTIVE_SCRN_FLAG))
    {
        mmi_java_set_screen_delete_callback_flag(MMI_FALSE);
        mmi_frm_group_close(GRP_ID_JAVA_APP);
        mmi_frm_group_close(GRP_ID_JAVA_TEXTFIELD);
        mmi_frm_group_close(GRP_ID_JAVA_TASK_SWITCH);
        jam_delete_fg_mmi_screen();
    }
    mmi_frm_group_create(GRP_ID_ROOT,GRP_ID_JAVA_APP,jam_sg_proc,NULL);
    mmi_frm_group_enter(GRP_ID_JAVA_APP, MMI_FRM_NODE_SMART_CLOSE_FLAG);
    jam_resume_screen_ext();
}


void jam_resume_screen_ext(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    kal_int32 vm_id=0;
    S32 is_redraw = 0;
 #ifdef __MMI_CABC__
    U8 attrib = g_java.mids_info[g_java.mids_index - g_java.mids_info_start].mids_attributes;    
 #endif
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    kal_trace(TRACE_STATE, FUNC_JVM_RESUME_SCREEN, vm_id, jam_mvm_get_vm_state(vm_id));
    is_redraw = mmi_is_redrawing_bk_screens();
    vm_id = jam_mvm_get_current_vm_id();
    if(vm_id == INVALIDE_VM_ID)
    {
        if(g_mmi_java_current_selected_vm_id == -1)
        {
            kal_trace(TRACE_STATE, FUNC_JVM_RESUME_SCREEN_RETURN, vm_id, jam_mvm_get_vm_state(vm_id));
            return;
        }
        else
        {
            vm_id = g_mmi_java_current_selected_vm_id;      
        }
    }
#ifdef J2ME_SLIM_MEMORY_SUPPORT
    if(jam_mvm_get_vm_state(vm_id) == JVM_TERMINATING_STATE ||
       jam_mvm_get_vm_state(vm_id) == JVM_TERMINATE_STATE)
    {
        return;
    }
#endif
#ifdef __MMI_NCENTER_SUPPORT__
    if(jam_mvm_get_vm_state(vm_id)!=JVM_TERMINATE_STATE &&
        jam_mvm_get_vm_state(vm_id)!=JVM_TERMINATING_STATE &&
        !is_redraw)
    {
        mmi_java_ncenter_on_going_cell_add(vm_id);
    }
#endif
#ifdef __COSMOS_MMI_PACKAGE__
    if(g_jam_user_update_setting_exclusive) /* OK to do screen must be delete, otherwise JAM is always busy */
        vapp_java_close_venus_screen();
#endif
    if (!jam_is_in_fg_screen(vm_id) && jam_mvm_get_vm_state(vm_id) != JVM_TERMINATE_STATE)
    {
        if (mmi_frm_scrn_enter(
        GRP_ID_JAVA_APP, 
        SCR_JAVA_APP, 
        jam_pause_screen, 
        jam_resume_screen_ext, 
        MMI_FRM_FULL_SCRN))  
        {
             mmi_frm_set_curr_scr_blt_mode(MMI_FRM_SCR_BLT_IMMEDIATE);
            #ifdef __MMI_CABC__
            if (attrib & IS_DEFAULT_GAME)
            {   
                mmi_frm_set_cabc_mode(MMI_FRM_CABC_MODE_MOVING);
            }
            #endif
            if(!is_redraw)
            {
                mmi_java_set_screen_delete_callback_flag(MMI_TRUE);
                mmi_frm_scrn_set_leave_proc(GRP_ID_JAVA_APP,SCR_JAVA_APP,mmi_java_app_screen_proc);

                jam_resmgr_state_transition(vm_id,JVM_FG_RUNNING_STATE);
                g_mmi_java_current_selected_vm_id = -1;/*reset*/  

                if(jui_widget_mvm_get_current_screen(vm_id) == JUI_SCREEN_TYPE_TEXTBOX)
                {
                    if (jui_widget_mvm_textbox_is_data_ready(vm_id)) 
                    { 
                        jui_widget_mvm_textbox_show_internal(MOD_MMI,MOD_MMI,vm_id);
                    }
                }
                else
                {
#ifdef J2ME_SLIM_MEMORY_SUPPORT
                    jui_widget_mvm_fire_event_listener_void_void(vm_id,JUI_EVENT_REPAINT_ALL);
#else
                    jui_widget_mvm_fire_event_listener_void_void(vm_id,JUI_EVENT_REPAINT);
#endif /* J2ME_SLIM_MEMORY_SUPPORT */
                }
                /*
                            * If JVM is waiting for message to wakeup, send the message
                            * * This is for JSR-75. The mounted drive may be unmounted after resumed.
                            * * We have to inform the VM in each case.
                            */
                if (g_jvm_keypad_need_notify)
                {
                    g_jvm_keypad_need_notify = KAL_FALSE;
                    jvm_send_keypad_notify_ind();
                }
            }
            else
            {
                  ShowCategory9Screen(
                        STR_GLOBAL_LOADING,
                        0,
                        NULL);
            }
        }
    }
    return;
}


/*****************************************************************************
 * FUNCTION
 *  jam_add_history
 * DESCRIPTION
 * PARAMETERS
 *  scrnID      [IN]        
 *  func        [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void jam_add_history(kal_uint16 scrnID, FuncPtr func)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    /* history currHistory; */
    mmi_frm_node_struct scr_info;
    kal_uint16 exit_scrn_id = GetExitScrnID();

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /*
     * currHistory.scrnID = scrnID;
     * currHistory.entryFuncPtr = func;
     * app_ucs2_strcpy((kal_int8*) currHistory.inputBuffer, (kal_int8*) L"");
     * GetCategoryHistory(currHistory.guiBuffer);
     * AddHistory(currHistory);
     */
    //GenericExitScreen(scrnID, func);
     scr_info.id = scrnID;
     scr_info.entry_proc = func;
    if(exit_scrn_id != GetActiveScreenId())
        {
            /* invoke jam_add_history in exit function case */
            mmi_frm_scrn_insert(APP_JAVA, exit_scrn_id, &scr_info, MMI_FRM_NODE_AFTER_FLAG );
        }
    else /* other scenario */
        {
            mmi_frm_scrn_insert(APP_JAVA, SCR_ID_INVALID, &scr_info, MMI_FRM_NODE_AT_LATEST_FLAG);
        }
}


/*****************************************************************************
 * FUNCTION
 *  jam_pause_screen
 * DESCRIPTION
 *  only called when use want to resume VM, but cancel
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void jam_pause_screen(void) /* this function is call by MMI */
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_ID group_id;
    MMI_ID screen_id;
    kal_int32 vm_id = jam_mvm_get_current_vm_id();
    kal_char * storage_name = jam_mvm_get_storage_name_by_vm_id(vm_id);
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(vm_id == INVALIDE_VM_ID)
    {
        // if midlet is exit by itself, midlet state has been translated to termianted.
        // then not need to execuate.
        return; 
    }
    mmi_frm_get_active_scrn_id(&group_id,&screen_id);
   
    kal_trace(TRACE_STATE, FUNC_JVM_PAUSE_SCREEN, vm_id, jam_mvm_get_vm_state(vm_id), screen_id);

    g_jam_refresh_screen_after_resume = KAL_TRUE;
    
    if (jam_is_in_fg_screen(vm_id))
    {
        if (jam_is_lock_mmi())
        {
            kal_uint32 event_group;

            kal_retrieve_eg_events(g_java_event_group_2, JAVA_EG_MMI_LOCK_EVENT, KAL_OR_CONSUME, &event_group, KAL_SUSPEND);
        }

        jma_media_player_check_critical_section();

#if defined(__OP01__ ) && (defined(__IJET_VM__)) && defined(J2ME_SUPPORT_BACKGROUND)
                          
        if(jam_call_back_functions.jam_get_running_midlet_domain(storage_name) == 2)
        {
            jvm_util_OP01_ret_enum ret = jvm_util_OP01_check_Keep_Background(vm_id);   
            if(ret == JVM_UTIL_SUCCESS)
            {
            	if(jam_is_enter_fg_mmi_screen())
                {
                    jam_resmgr_state_transition(vm_id,JVM_FG_MMI_RUNNING_STATE);
                }
                else if(mmi_java_is_in_voice_call_op11())
                {
                    jam_resmgr_state_transition(vm_id,JVM_LONG_EVENT_STATE);
                }
                else
                {
                    jam_resmgr_state_transition(vm_id,JVM_BG_RUNNING_STATE);
                }            
            }
            else if(ret == JVM_UTIL_FAIL)
            {
            	if(jam_is_enter_fg_mmi_screen())
                {
                    jam_resmgr_state_transition(vm_id,JVM_FG_MMI_RUNNING_STATE);
                }
                else
                {
                	  jam_resmgr_state_transition(vm_id,JVM_LONG_EVENT_STATE); 
                }                 
            }
            else if(ret == JVM_UTIL_MISS_INFO)
            {
            	if(jam_is_enter_fg_mmi_screen())
                {
                    jam_resmgr_state_transition(vm_id,JVM_FG_MMI_RUNNING_STATE);
                }
                else
                {
                	  jam_resmgr_state_transition(vm_id,JVM_LONG_EVENT_STATE);  
                }                
            }           

        }

        else if(jam_is_enter_fg_mmi_screen())
        {
            jam_resmgr_state_transition(vm_id,JVM_FG_MMI_RUNNING_STATE);
        }
        else
        {
            jam_resmgr_state_transition(vm_id,JVM_LONG_EVENT_STATE);
        }

#elif defined(__OP01__ ) && (defined(__NEMO_VM__)) && defined(J2ME_SUPPORT_BACKGROUND)
        if(jam_mvm_is_vm_support_bg(vm_id))
        {
            if(jam_call_back_functions.jam_get_running_midlet_domain(storage_name) == 2)
            {
                jvm_util_OP01_ret_enum ret = jvm_util_OP01_check_Keep_Background(vm_id);   
                if(ret == JVM_UTIL_SUCCESS)
                {
                	if(jam_is_enter_fg_mmi_screen())
                    {
                        jam_resmgr_state_transition(vm_id,JVM_FG_MMI_RUNNING_STATE);
                    }
                    else if(mmi_java_is_in_voice_call_op11())
                    {
                        jam_resmgr_state_transition(vm_id,JVM_LONG_EVENT_STATE);
                    }
                    else
                    {
                        jam_resmgr_state_transition(vm_id,JVM_BG_RUNNING_STATE);
                    }            
                }
                else if(ret == JVM_UTIL_FAIL)
                {
                	if(jam_is_enter_fg_mmi_screen())
                    {
                        jam_resmgr_state_transition(vm_id,JVM_FG_MMI_RUNNING_STATE);
                    }
                    else
                    {
                    	  jam_resmgr_state_transition(vm_id,JVM_LONG_EVENT_STATE); 
                    }                 
                }
                else if(ret == JVM_UTIL_MISS_INFO)
                {
                	if(jam_is_enter_fg_mmi_screen())
                    {
                        jam_resmgr_state_transition(vm_id,JVM_FG_MMI_RUNNING_STATE);
                    }
                    else
                    {
                    	  jam_resmgr_state_transition(vm_id,JVM_LONG_EVENT_STATE);  
                    }                
                }           
    
            }
    
            else if(jam_is_enter_fg_mmi_screen())
            {
                jam_resmgr_state_transition(vm_id,JVM_FG_MMI_RUNNING_STATE);
            }
            else
            {
                jam_resmgr_state_transition(vm_id,JVM_LONG_EVENT_STATE);
            }
        }
		else
		{
    		if (screen_id == POPUP_SCREENID 
            //#ifdef __MMI_BACKGROUND_CALL__
             //|| screen_id == SCR_ID_UCM_CALL_END
            //#endif 
               )
            {
                jam_resmgr_state_transition(vm_id,JVM_SHORT_EVENT_STATE);
            }
            else if(jam_is_enter_fg_mmi_screen())
            {    
                jam_resmgr_state_transition(vm_id,JVM_FG_MMI_RUNNING_STATE);
            }        
            else
            {
                jam_resmgr_state_transition(vm_id,JVM_LONG_EVENT_STATE);
            }
	    }
#else
        
         if (screen_id == POPUP_SCREENID 
        //#ifdef __MMI_BACKGROUND_CALL__
         //|| screen_id == SCR_ID_UCM_CALL_END
        //#endif 
           )
        {
            jam_resmgr_state_transition(vm_id,JVM_SHORT_EVENT_STATE);
        }
        else if(jam_is_enter_fg_mmi_screen())
        {    
            jam_resmgr_state_transition(vm_id,JVM_FG_MMI_RUNNING_STATE);
        }        
        else
        {
            jam_resmgr_state_transition(vm_id,JVM_LONG_EVENT_STATE);
        }
#endif
        /* too important here !! , goback history will execute this to resume vm */
        //jam_add_history(SCR_JAVA_APP, jam_resume_screen);

        /*
         * If JVM is waiting for message to wakeup, send the message
         * * This is for JSR-75. The mounted drive may be unmounted after resumed.
         * * We have to inform the VM in each case.
         */
        if (g_jvm_keypad_need_notify)
        {
            g_jvm_keypad_need_notify = KAL_FALSE;
            jvm_send_keypad_notify_ind();
        }
    }
    else
    {
        /*
         * jam_pause_screen is JAVA_SCR 's exit screen
         * when we execute jam_exit_screen, will execute jam_pause_screen again
         * therefore, we do nothing here
         */

    }
}


/*****************************************************************************
 * FUNCTION
 *  jam_enter_screen
 * DESCRIPTION
 *  jvm enter screen handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
kal_bool jam_is_allow_enter_java_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if !defined(__MMI_BACKGROUND_CALL__) && !defined(__MMI_NCENTER_SUPPORT__)
        if(mmi_java_is_in_voice_call())
            return KAL_FALSE;
#endif 
#ifdef __DM_LAWMO_SUPPORT__
        if( mmi_dmui_is_phone_lock() 
        #ifdef __DM_MO_SUPPORT__
            || mmi_dmui_get_status(MMI_DMUI_MO_TYPE_LAWMO_LOCK ) == MMI_DMUI_STATUS_LAWMO_LOCK_ON_LOCKING)
        #else
        )
        #endif
        {
            mmi_java_is_allow_stopped_popup_display(MMI_FALSE);
            return KAL_FALSE;
        }
#endif
        if(MMI_SCENARIO_ID_BT_ACCESS_REQ == mmi_frm_get_active_scenario_id())
        {
            return KAL_FALSE;
        }

            if(
#ifdef __PLUTO_MMI_PACKAGE__
            mmi_scr_locker_is_locked()
#elif __COSMOS_MMI_PACKAGE__
            vapp_screen_lock_is_exist()
#else
            0
#endif
            )
            {
                kal_trace(JAM_JAVAAGENCY_GROUP,JAM_IS_ALLOW_ENTER_JAVA_SCREEN_LOCK);
                return MMI_FALSE;
            }
        return KAL_TRUE;
}

kal_bool jam_is_allow_ncenter_show(void)
{
    if (!g_jam_is_allow_show_ncenter||
        jam_is_busy())
    {
        return KAL_FALSE;
    }
    else
    {
        return KAL_TRUE;
    }  
}


/*****************************************************************************
 * FUNCTION
 *  jam_sg_proc
 * DESCRIPTION
 *  Java canvas screen group proc function
 * PARAMETERS
 *  events
 * RETURNS
 *  mmi_ret
 *****************************************************************************/
mmi_ret jam_sg_proc(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_ID group_id;
    MMI_ID screen_id;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_frm_get_active_scrn_id(&group_id,&screen_id); 
    switch(evt->evt_id)
    {
#ifdef __MMI_NCENTER_SUPPORT__
        case EVT_ID_VAPP_NCENTER_DRAG:
#ifdef J2ME_SLIM_MEMORY_SUPPORT
            return MMI_RET_ERR;
#else
            if (screen_id == SCR_ID_JAVA_UI_OPTION_MENU ||
                screen_id == SCR_ID_JAVA_UI_TEXTBOX_EDITOR ||
                screen_id == SCR_ID_JAVA_UI_TEXTBOX_EDITOR_OPTION)
            {
                return MMI_RET_ERR;
            }
            else if (!jam_is_allow_ncenter_show())
            {
                return MMI_RET_ERR;
            }
            else
            {
                if(mmi_frm_group_get_active_id() == GRP_ID_JAVA_APP)
                {
                    g_jam_ncenter_add_ongoing_cell = KAL_FALSE;
                }
                else
                {
                    g_jam_ncenter_add_ongoing_cell = KAL_TRUE;
                }
                g_jvm_is_show_ncenter = KAL_FALSE;
            }
            break;
#endif
#endif
        default:
            break;
    }
    return MMI_RET_OK;
}

/*****************************************************************************
 * FUNCTION
 *  jam_ncenter_event_proc
 * DESCRIPTION
 *  Ncenter event proc function
 * PARAMETERS
 *  events
 * RETURNS
 *  mmi_ret
 *****************************************************************************/
mmi_ret jam_ncenter_event_proc(mmi_event_struct *evt)
{
#ifdef __MMI_NCENTER_SUPPORT__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    kal_int32 idx = 0;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/  
    switch(evt->evt_id)
    {
        case EVT_ID_VAPP_NCENTER_DRAG:
                if(mmi_frm_group_get_active_id() == GRP_ID_JAVA_APP)
                {
                    //g_jam_ncenter_add_ongoing_cell = KAL_FALSE;
                }
                else
                {
                    for(idx = 0; idx < MAX_VM_INSTANCE_NUM;idx++)
                    {
                        if(jam_mvm_is_minimize_mode(idx)||
                            jam_mvm_is_pause_mode(idx))
                        {
                            mmi_java_ncenter_on_going_cell_add(idx);
                        }
                    }
                }
            break;
        default:
            break;
    }
#endif    
    return MMI_RET_OK;
}


void jam_enter_screen_ext(kal_int32 vm_id);
/*****************************************************************************
 * FUNCTION
 *  jam_enter_screen
 * DESCRIPTION
 *  jvm enter screen handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void jam_enter_screen(kal_int32 vm_id) /* this function is call by MMI */
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    kal_trace(TRACE_STATE, FUNC_JVM_ENTER_SCREEN, vm_id,jam_mvm_get_vm_state(vm_id));

    EXT_ASSERT(jam_mvm_get_vm_state(vm_id) == 0,jam_mvm_get_vm_state(vm_id),vm_id,0); /* currently java should not be re-entry */
    if(!jam_is_allow_enter_java_screen())
    {
        kal_trace(JAM_JAVAAGENCY_GROUP,JAM_ENTER_SCREEN_NOT_ALLOW);
        if(jam_mvm_get_running_count()==1)
        {
            jam_mvm_shutdown_all_req();
        }
        else
        {
            jam_enter_terminate_mode(vm_id);
        }
        return;
    }
    
    mmi_frm_group_create(GRP_ID_ROOT, GRP_ID_JAVA_APP, jam_sg_proc, NULL);
    mmi_frm_group_enter(GRP_ID_JAVA_APP, MMI_FRM_NODE_SMART_CLOSE_FLAG);
    jam_enter_screen_ext(vm_id);
}


/*****************************************************************************
 * FUNCTION
 *  jam_enter_screen_ext
 * DESCRIPTION
 *  jvm enter screen handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void jam_enter_screen_ext(kal_int32 vm_id)
{
#ifdef __MMI_CABC__ 
    U8 attrib = g_java.mids_info[g_java.mids_index - g_java.mids_info_start].mids_attributes;
#endif
   if (!mmi_frm_scrn_enter(
        GRP_ID_JAVA_APP, 
        SCR_JAVA_APP, 
        jam_pause_screen, 
        jam_resume_screen, 
        MMI_FRM_FULL_SCRN))  
        {
            return;
        }
   #ifdef __MMI_CABC__
    if (attrib & IS_DEFAULT_GAME)
    {   
        mmi_frm_set_cabc_mode(MMI_FRM_CABC_MODE_MOVING);
    }
   #endif
    mmi_frm_set_curr_scr_blt_mode(MMI_FRM_SCR_BLT_IMMEDIATE);
    ShowCategoryDummyScreen();
    mmi_java_set_screen_delete_callback_flag(MMI_TRUE);
    mmi_frm_scrn_set_leave_proc(GRP_ID_JAVA_APP, SCR_JAVA_APP,mmi_java_app_screen_proc);

    jam_resmgr_state_transition(vm_id,JVM_FG_RUNNING_STATE);
}

kal_bool g_jam_in_terminating = KAL_FALSE;
/*****************************************************************************
 * FUNCTION
 *  jam_enter_terminate_mode
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void jam_enter_terminate_mode(kal_int32 vm_id) /* this function is call by MMI */
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(jam_mvm_get_vm_state(vm_id) == JVM_TERMINATING_STATE||
        jam_mvm_get_vm_state(vm_id) == JVM_TERMINATE_STATE)
    {
        kal_trace(TRACE_STATE, FUNC_JVM_ENTER_TERMINATE_MODE_TERMINATING);
        return;
    }   
    kal_trace(TRACE_STATE, FUNC_JVM_ENTER_TERMINATE_MODE,vm_id);
    /* when no support pause mode, we may invoke this function when jvm_is_own_screen */
    jam_resmgr_state_transition(vm_id,JVM_TERMINATING_STATE);
    jvm_send_keypad_notify_ind();
    if(jam_mvm_get_current_vm_id() == INVALIDE_VM_ID )
    {
        mmi_java_set_screen_delete_callback_flag(MMI_FALSE);
    }
    g_jam_in_terminating = KAL_TRUE;
#ifndef J2ME_SLIM_MEMORY_SUPPORT
    if(jam_mvm_get_current_vm_id() == INVALIDE_VM_ID && g_mmi_java_current_selected_vm_id == vm_id)
    {
        mmi_frm_group_close(GRP_ID_JAVA_APP);
        jam_delete_fg_mmi_screen();
    }
#endif
}

/*****************************************************************************
 * FUNCTION
 *  jam_enter_terminating_mode
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void jam_enter_terminating_mode(kal_int32 vm_id) /* this function is call by MMI */
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    jam_mvm_set_vm_is_auto_terminated(vm_id,KAL_TRUE);
    jam_enter_terminate_mode(vm_id);
	
}


/*****************************************************************************
 * FUNCTION
 *  jam_terminate_by_asm
 * DESCRIPTION
 *  Terminate vm in ASM scinerio
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void jam_terminate_by_asm(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    jam_mvm_shutdown_all_req();
    jam_send_vm_asm_abort_req();
    jvm_send_keypad_notify_ind();

    //ClearDelScrnIDCallbackHandler(SCR_JAVA_APP, NULL);
    mmi_java_set_screen_delete_callback_flag(MMI_FALSE);
    g_jam_in_terminating = KAL_TRUE; 
    //DeleteScreenIfPresent(SCR_JAVA_APP);

    //delete mmi related screens
    jam_delete_fg_mmi_screen();
    //jui_widget_update_vm_bg_status_icon(KAL_FALSE);
    #ifdef __COSMOS_MMI_PACKAGE__
    /* Need to terminate venus java app */
    if(!jam_mvm_has_running_vm() && !jam_mvm_is_shutdowning())
    {
        vapp_java_close_venus_screen();
        applib_mem_ap_notify_stop_finished(APPLIB_MEM_AP_ID_JAVA, KAL_TRUE);
    }
    #endif
}

/*****************************************************************************
 * FUNCTION
 *  jam_enter_pause_mode
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void jam_enter_pause_mode(kal_int32 vm_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    kal_trace(TRACE_STATE, FUNC_JVM_ENTER_PAUSE_MODE,vm_id);

    jam_resmgr_state_transition(vm_id,JVM_PAUSED_STATE);

    //ClearDelScrnIDCallbackHandler(SCR_JAVA_APP, NULL);
    mmi_java_set_screen_delete_callback_flag(MMI_FALSE);
    //DeleteScreenIfPresent(SCR_JAVA_APP);
    mmi_frm_group_close(APP_JAVA);

    //delete mmi releated screends
    jam_delete_fg_mmi_screen();
}


/*****************************************************************************
 * FUNCTION
 *  jam_enter_minimize_mode
 * DESCRIPTION
 *  
 * PARAMETERS
 *  pauseapp        [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void jam_enter_minimize_mode(kal_int32 vm_id, kal_bool pauseapp)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    jvm_state_enum state = (jvm_state_enum)jam_mvm_get_vm_state(vm_id);
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    kal_trace(TRACE_STATE, FUNC_JVM_ENTER_MINIMIZE_MODE,vm_id);
    if(JVM_TERMINATING_STATE == state ||
        JVM_TERMINATE_STATE == state)
    {
        return;
    }
    #ifdef J2ME_SUPPORT_BACKGROUND
    mmi_java_store_setting(); /* Save volume */
    jam_delete_fg_mmi_screen();
	
    if(jui_widget_mvm_get_current_screen(vm_id) == JUI_SCREEN_TYPE_TEXTBOX)
    {
        //backup the current data
        jui_widget_mvm_textbox_backup_text(vm_id);
    }
	
    if (jam_mvm_get_vm_state(vm_id) != JVM_BG_RUNNING_STATE)
    {
        g_jam_is_force_pauseapp = pauseapp;

        jam_resmgr_state_transition(vm_id,JVM_BG_RUNNING_STATE);

        mmi_java_set_screen_delete_callback_flag(MMI_FALSE);
        mmi_frm_group_close(GRP_ID_JAVA_APP);
        #ifdef __COSMOS_MMI_PACKAGE__
        mmi_frm_group_close(APP_JAVA);
        #endif
    }
    else if (pauseapp)
    {
        /* notify vm directly */
        g_jam_is_force_pauseapp = KAL_TRUE;
        jam_pauseVMExternal(vm_id,JVM_BG_RUNNING_STATE, JVM_BG_RUNNING_STATE);
    }        
//#if defined(__OP01__ ) && defined(__IJET_VM__) && defined(J2ME_SUPPORT_BACKGROUND)
#if defined(__IJET_VM__) && defined(J2ME_SUPPORT_BACKGROUND) //modified by haitao,enter java textbox screen, vm is in bg mode
	else
	{
        //ClearDelScrnIDCallbackHandler(SCR_JAVA_APP, NULL);
        mmi_java_set_screen_delete_callback_flag(MMI_FALSE);
        //DeleteScreenIfPresent(SCR_JAVA_APP);      	
        mmi_frm_group_close(GRP_ID_JAVA_APP);

#ifdef J2ME_SUPPORT_BACKGROUND
        jui_widget_update_vm_bg_status_icon(KAL_TRUE, vm_id);
#endif /* J2ME_SUPPORT_BACKGROUND */ 
        //added by haitao,end
	}
#endif         
#endif         
}


/*****************************************************************************
 * FUNCTION
 *  jam_enter_long_event_mode
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void jam_enter_long_event_mode(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    kal_int32 vm_id = jam_mvm_get_current_vm_id();

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    kal_trace(TRACE_STATE, FUNC_JVM_LONG_EVENT_MODE,vm_id);

    if (jam_mvm_get_vm_state(vm_id)== JVM_SHORT_EVENT_STATE)
    {
        jam_resmgr_state_transition(vm_id,JVM_LONG_EVENT_STATE);
    }
}
void jam_shutdownAllExternal(kal_bool is_forced)
{
    jvm_shutdownAllExternal(is_forced);
}
/*****************************************************************************
 * FUNCTION
 *  jam_initVMExternal
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void jam_initVMExternal(kal_int32 vm_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    kal_trace(TRACE_STATE, FUNC_JVM_INITVMEXTERNAL,vm_id);
    jvm_init_vm_external(vm_id);
}

/*****************************************************************************
 * FUNCTION
 *  jam_pauseVMExternal
 * DESCRIPTION
 *  
 * PARAMETERS
 *  vm_id     [IN] 
 *  src     [IN]        
 *  dst     [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void jam_pauseVMExternal(kal_int32 vm_id,kal_int32 src, kal_int32 dst)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    kal_bool pauseapp = KAL_FALSE;
    kal_int32 consume_id = jam_mvm_get_vm_consume_id(vm_id);
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* consume problem */
    if (dst == JVM_LONG_EVENT_STATE)
    {
        jam_drm_midlet_pause_consume(consume_id);
    }
    else if (dst == JVM_BG_RUNNING_STATE)
    {
        jam_drm_midlet_resume_consume(consume_id);
    }
    else if (dst == JVM_PAUSED_STATE && src != JVM_LONG_EVENT_STATE)
    {
        jam_drm_midlet_pause_consume(consume_id);
    }

    /* Timer problem */
    if (dst == JVM_SHORT_EVENT_STATE)
    {
        StartTimer(J2ME_VM_EVENT_TIMER, 2000, jam_enter_long_event_mode);
    }

    /* pauseAPP problem */
    if (dst == JVM_LONG_EVENT_STATE)
    {
        if (jam_mvm_is_vm_need_call_pauseapp(vm_id)
            || mmi_java_is_in_voice_call() 
#ifndef __COSMOS_MMI_PACKAGE__ 
            || mmi_java_is_msg_screen_active() /*it seems phaseout on cosmos*/
#endif
            )
        {
            pauseapp = KAL_TRUE;
        }
    }
    else if (dst == JVM_SHORT_EVENT_STATE)
    {
        pauseapp = KAL_TRUE;
    }
    else if (dst == JVM_PAUSED_STATE)
    {
        pauseapp = KAL_TRUE;
    }
    else if (dst == JVM_BG_RUNNING_STATE && jam_mvm_is_vm_need_call_pauseapp(vm_id))
    {
        pauseapp = KAL_TRUE;
    }

    kal_trace(TRACE_STATE, FUNC_JVM_PAUSEVMEXTERNAL,vm_id, dst, pauseapp);
    jvm_pause_vm_external(vm_id, dst, pauseapp); 
}


/*****************************************************************************
 * FUNCTION
 *  jam_resumeVMExternal
 * DESCRIPTION
 *  
 * PARAMETERS
 *  vm_id     [IN] 
 *  src     [IN]        
 *  dst     [IN] 
 * RETURNS
 *  void
 *****************************************************************************/
void jam_resumeVMExternal(kal_int32 vm_id, kal_int32 src, kal_int32 dst)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    kal_trace(TRACE_STATE, FUNC_JVM_RESUMEVMEXTERNAL,vm_id);

    if (jam_is_in_fg_screen(vm_id) || jam_is_in_fg_mmi_screen(vm_id) || dst == JVM_BG_RUNNING_STATE)
    {
        kal_int32 consume_id = jam_mvm_get_vm_consume_id(vm_id);
        jam_drm_midlet_resume_consume(consume_id);
        jvm_resume_vm_external(vm_id, dst); 
    }
}

/*****************************************************************************
 * FUNCTION
 *  jam_minimizeVMExternal
 * DESCRIPTION
 * 
 * PARAMETERS
 *  vm_id     [IN]     
 *  src     [IN]
 *  dst     [IN]
 * RETURNS
 *  void
 *****************************************************************************/
void jam_minimizeVMExternal(kal_int32 vm_id, kal_int32 src, kal_int32 dst)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    kal_int32 consume_id = jam_mvm_get_vm_consume_id(vm_id);
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    /* consume problem */
    if (src == JVM_FG_RUNNING_STATE || src == JVM_FG_MMI_RUNNING_STATE)
    {
        jam_drm_midlet_resume_consume(consume_id);
    }	

    if (src == JVM_FG_RUNNING_STATE &&
        dst == JVM_BG_RUNNING_STATE &&
        g_jam_is_force_pauseapp)
    {
        jvm_pause_vm_external(vm_id, dst, KAL_TRUE);
    }
    else
    {
        jvm_minimize_vm_external(vm_id); 
    }
}

/*****************************************************************************
 * FUNCTION
 *  jam_activeVMExternal
 * DESCRIPTION
 *  
 * PARAMETERS
 *  vm_id     [IN]
 *  src     [IN]
 *  dst     [IN]
 * RETURNS
 *  void
 *****************************************************************************/
void jam_activeVMExternal(kal_int32 vm_id, kal_int32 src, kal_int32 dst)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (jam_is_in_fg_screen(vm_id) || jam_is_in_fg_mmi_screen(vm_id))
    {
        kal_int32 consume_id = jam_mvm_get_vm_consume_id(vm_id);
        jam_drm_midlet_resume_consume(consume_id);
        jvm_active_vm_external(vm_id); 
    }
}

/*****************************************************************************
 * FUNCTION
 *  jam_stopVMExternal
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void jam_stopVMExternal(kal_int32 vm_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    kal_trace(TRACE_STATE, FUNC_JVM_STOPVMEXTERNAL,vm_id);
    jvm_stop_vm_external(vm_id); 
}


/*****************************************************************************
 * FUNCTION
 *  jam_vm_canbe_paused
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
kal_bool jam_vm_canbe_paused(kal_int32 vm_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    kal_bool canbe_paused = KAL_TRUE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef J2ME_SUPPORT_PAUSE
    if (is_socket_activated()
#ifdef SUPPORT_JSR_205
        || is_mms_activated()
#endif 
#ifdef SUPPORT_JSR_120
        || is_sms_activated() 
#endif        
#ifdef __J2ME_STREAM_SUPPORT__
        || is_stream_activated()
#endif
#ifdef SUPPORT_HTTP_OVER_WSP
        || jnw_http_active(KAL_TRUE,0)
#endif 
#ifdef SUPPORT_JSR_184
        || is_graphics3d_activated()
#endif 
#ifdef __SUPPORT_JBT__
        || (jbt_get_power_status_cmd() != JBT_POWER_OFF)
#endif          
    )
    {
        canbe_paused = KAL_FALSE;
    }
#else /* J2ME_SUPPORT_PAUSE */ 
    canbe_paused = KAL_FALSE;
#endif /* J2ME_SUPPORT_PAUSE */ 

    return canbe_paused;
}


/*****************************************************************************
 * FUNCTION
 *  jam_vm_canbe_minimize
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
kal_bool jam_vm_canbe_minimize(kal_int32 vm_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    kal_bool canbe_minimize = KAL_TRUE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef J2ME_SUPPORT_BACKGROUND

    if(jam_mvm_is_vm_support_bg(vm_id))
    {
        if ( FALSE
#ifdef SUPPORT_JSR_120    
            || is_sms_activated()
#endif            
#ifdef SUPPORT_JSR_205
            || is_mms_activated()
#endif 
#ifdef SUPPORT_JSR_184
            || is_graphics3d_activated()
#endif 
#ifdef __SUPPORT_JBT__
            || (jbt_get_power_status_cmd() != JBT_POWER_OFF)
#endif 
            )
        {
            canbe_minimize = KAL_FALSE;
        }
    }
	else
	{
	    canbe_minimize = KAL_FALSE;
	}

#else /* J2ME_SUPPORT_BACKGROUND */ 
    canbe_minimize = KAL_FALSE;
#endif /* J2ME_SUPPORT_BACKGROUND */ 

    return canbe_minimize;
}


/*****************************************************************************
 * FUNCTION
 *  jam_no_network_connection
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
kal_bool jam_no_network_connection(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (is_socket_activated() 
#ifdef SUPPORT_JSR_205
        || is_mms_activated()
#endif 
#ifdef __J2ME_STREAM_SUPPORT__
        || is_stream_activated()
#endif        
#ifdef SUPPORT_HTTP_OVER_WSP
        || jnw_http_active(KAL_TRUE,0)
#endif 
        )
        return KAL_FALSE;

    return KAL_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  _jam_set_mmi_Lock
 * DESCRIPTION
 *  
 * PARAMETERS
 *  lock        [IN]        
 *  file        [?]         [?]
 *  line        [IN]        
 * RETURNS
 *  TRUE: success
 *  FALSE: fail
 *****************************************************************************/
kal_bool _jam_set_mmi_Lock(kal_bool lock, kal_char *file, kal_uint32 line)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    kal_bool result;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    //kal_trace(TRACE_STATE, J2ME_JVM_SET_MMI_LOCK, jvm_lock_mmi_count, lock, jvm_is_own_screen(), is_resource_suspended());
    //kal_wap_trace(MOD_J2ME, TRACE_GROUP_10, "file: %s , line = %d", basename(file), line);

    /*
     * Do not need to set event for unlocking MMI on the case.
     * * Jvm_mmi_lock will be only set by JVM task and hence no protection
     * * is needed. Ensure Jvm_mmi_lock will not be modified by other task.
     */

    if (kal_get_active_module_id() == MOD_MMI)
    {
        return KAL_FALSE;
    }

    if (lock == KAL_FALSE && g_jam_lock_mmi_count == 0)
    {
        return KAL_FALSE;
    }

    JAM_RES_LOCK;


    if ((!jam_is_own_screen()) && lock == KAL_TRUE)
    {
        result = KAL_FALSE;  
    }
    else
    {
        kal_uint32 event_group;

        g_jam_lock_mmi_count += (lock == KAL_TRUE ? 1 : -1);
        if (g_jam_lock_mmi_count == 0)
        {
            kal_set_eg_events(g_java_event_group_2, JAVA_EG_MMI_LOCK_EVENT, KAL_OR);
            kal_retrieve_eg_events(g_java_event_group_2, JAVA_EG_MMI_LOCK_EVENT, KAL_OR_CONSUME, &event_group, KAL_NO_SUSPEND);
        }
        result = KAL_TRUE;
    }
    JAM_RES_UNLOCK;

    return result;

}

/* fix bug : the Notifypause wont call pauseApp */
kal_bool g_jam_pause_ind_flag = KAL_FALSE;


/*****************************************************************************
 * FUNCTION
 *  jam_mvm_send_pause_ind
 * DESCRIPTION
 *  send message to MMI to show the pause screen
 * PARAMETERS
 *  void
 * RETURNS
 *****************************************************************************/
kal_bool jam_mvm_send_pause_ind(kal_int32 vm_id)   /* called by JVM */
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
   // ilm_struct *ilm_ptr;
    mmi_java_pause_ind_struct *msg;

#if defined(J2ME_SUPPORT_PAUSE)

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if ( jam_mvm_is_vm_pause_ind(vm_id) == KAL_FALSE &&
        (jam_is_own_screen() || jam_mvm_is_minimize_mode(vm_id)))
    {
        jam_mvm_set_vm_pause_ind(vm_id,KAL_TRUE);
        msg = (mmi_java_pause_ind_struct*) construct_local_para(sizeof(mmi_java_pause_ind_struct), TD_CTRL);
        msg->vm_id = vm_id;
        java_send_msg_from_active_mod(MOD_MMI,MMI_J2ME_SAP,MSG_ID_MMI_JAVA_PAUSE_IND,msg);
        g_jam_pause_ind_flag = KAL_TRUE;
        return KAL_TRUE;
    }
#elif defined(J2ME_SUPPORT_BACKGROUND)
    if(jam_mvm_is_vm_support_bg(vm_id) && 
		jam_mvm_is_vm_pause_ind(vm_id) == KAL_FALSE &&
        (jam_is_own_screen() || jam_mvm_is_minimize_mode(vm_id)))
    {
        jam_mvm_set_vm_pause_ind(vm_id,KAL_TRUE);
        msg = (mmi_java_pause_ind_struct*) construct_local_para(sizeof(mmi_java_pause_ind_struct), TD_CTRL);
        msg->vm_id = vm_id;
        java_send_msg_from_active_mod(MOD_MMI,MMI_J2ME_SAP,MSG_ID_MMI_JAVA_PAUSE_IND,msg);
        g_jam_pause_ind_flag = KAL_TRUE;
        return KAL_TRUE;
    }
#endif /* defined(J2ME_SUPPORT_PAUSE) || defined(J2ME_SUPPORT_BACKGROUND) */ 
    return KAL_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  jam_mvm_send_terminate_ind
 * DESCRIPTION
 *  send message to MMI to ask resume background
 * PARAMETERS
 *  vm_id
 * RETURNS
 *****************************************************************************/
kal_bool jam_mvm_send_terminate_ind(kal_int32 vm_id)   /* called by JVM */
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    //ilm_struct *ilm_ptr = NULL;
    mmi_java_terminate_ind_struct *msg = NULL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (jam_is_in_fg_screen(vm_id) &&
        jam_mvm_is_vm_terminate_ind(vm_id) == KAL_FALSE)
    {
        jam_mvm_set_vm_terminate_ind(vm_id,KAL_TRUE);
        msg = (mmi_java_terminate_ind_struct*) construct_local_para(sizeof(mmi_java_terminate_ind_struct), TD_CTRL);
        msg->vm_id = vm_id;
        java_send_msg_from_active_mod(MOD_MMI,MMI_J2ME_SAP,MSG_ID_MMI_JAVA_TERMINATE_IND,msg);
        return KAL_TRUE;
    }
    return KAL_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  jam_mvm_send_resume_ind
 * DESCRIPTION
 *  send message to MMI to ask resume background
 * PARAMETERS
 *  void
 * RETURNS
 *****************************************************************************/
kal_bool jam_mvm_send_resume_ind(kal_int32 vm_id)  /* called by JVM */
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
   // ilm_struct *ilm_ptr = NULL;
    mmi_java_resume_ind_struct *msg = NULL;

#if defined(J2ME_SUPPORT_BACKGROUND)
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (jam_mvm_is_vm_support_bg(vm_id) && 
        jam_mvm_is_vm_resume_ind(vm_id) == KAL_FALSE &&
        jam_mvm_is_minimize_mode(vm_id) == KAL_TRUE)
    {
        jam_mvm_set_vm_resume_ind(vm_id,KAL_TRUE);
        msg = (mmi_java_resume_ind_struct*) construct_local_para(sizeof(mmi_java_resume_ind_struct), TD_CTRL);
        msg->vm_id  = vm_id;
        check_incoming_call_and_block();
        java_send_msg_from_active_mod(MOD_MMI,MMI_J2ME_SAP,MSG_ID_MMI_JAVA_RESUME_IND,msg);
        return KAL_TRUE;
    }
#endif /* defined(J2ME_SUPPORT_BACKGROUND) */ 
    return KAL_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  jam_mvm_send_terminating_ind
 * DESCRIPTION
 *  send message to MMI to tell vm is terminating
 * PARAMETERS
 *  void
 * RETURNS
 *****************************************************************************/
kal_bool jam_mvm_send_terminating_ind(kal_int32 vm_id)  /* called by JVM */ /* 20110221 */
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
   // ilm_struct *ilm_ptr = NULL;
    mmi_java_terminate_ind_struct *msg = NULL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_jam_is_allow_show_ncenter = KAL_FALSE;
    if (jam_mvm_is_vm_terminate_ind(vm_id) == KAL_FALSE)
    {
        msg = (mmi_java_terminate_ind_struct*) construct_local_para(sizeof(mmi_java_terminate_ind_struct), TD_CTRL);
        msg->vm_id = vm_id;
        java_send_msg_from_active_mod(MOD_MMI,MMI_J2ME_SAP,MSG_ID_MMI_JAVA_TERMINATING_IND,msg);
        return KAL_TRUE;
    }
    return KAL_FALSE;

}


/*****************************************************************************
 * FUNCTION
 *  jam_has_entered_idle_screen
 * DESCRIPTION
 * PARAMETERS
 *  void
 * RETURNS
 *****************************************************************************/
kal_bool jam_has_entered_idle_screen(void)  /* called by JVM */
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return g_jam_has_vm_entered_idle_screen;

}


/*****************************************************************************
 * FUNCTION
 *  jam_incoming_call_serial
 * DESCRIPTION
 * PARAMETERS
 *  void
 * RETURNS
 *****************************************************************************/
kal_int32 jam_incoming_call_serial(void)
{

    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return g_jam_incoming_call_serial;
}


/*****************************************************************************
 * FUNCTION
 *  jam_delete_screen_notify
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void jam_delete_screen_notify(kal_int32 vm_id) /* this function is call by MMI */
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    kal_int32 vm_state = jam_mvm_get_vm_state(vm_id);
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    kal_trace(TRACE_STATE, FUNC_JVM_DELETE_SCREEN_NOTIFY, vm_state);
    if (vm_state == JVM_LONG_EVENT_STATE ||
        vm_state == JVM_SHORT_EVENT_STATE||
        vm_state == JVM_FG_RUNNING_STATE ||
        vm_state == JVM_FG_MMI_RUNNING_STATE ||
        vm_state == JVM_PAUSED_STATE
        )
    {
        jam_enter_terminating_mode(vm_id);
#ifdef J2ME_SLIM_MEMORY_SUPPORT
        mmi_java_entry_terminating(MMI_FALSE);
#endif
        jam_send_vm_abort_req(vm_id);
        jvm_send_keypad_notify_ind();
    }
    else
    {
        /* JVM is terminating, but someone try to delete the "terminating screen" */
    }
}


/*****************************************************************************
 * FUNCTION
 *  jam_enter_idle_screen_notify
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
mmi_ret jam_enter_idle_screen_notify(mmi_event_struct *param) /* this function is call by MMI */
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    kal_int32 vm_id = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    kal_trace(TRACE_STATE, FUNC_JVM_ENTER_IDLE_SCREEN_NOTIFY,vm_id);
    g_jam_has_vm_entered_idle_screen = KAL_TRUE;
#ifdef __COSMOS_MMI_PACKAGE__
    mmi_java_entry_mid_launch_from_idle();
#endif
    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  jam_enter_incoming_call_notify
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void jam_enter_incoming_call_notify(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    kal_trace(TRACE_STATE, FUNC_JVM_ENTER_INCOMING_CALL_NOTIFY, jam_incoming_call_serial);

    g_jam_incoming_call_serial++;

}


/*****************************************************************************
 * FUNCTION
 *  jam_stop_FS_action
 * DESCRIPTION
 *  this function is call by MMI, to stop File system action during installation
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void jam_stop_FS_action(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_jam_stopFS = KAL_TRUE;
}

/*****************************************************************************
* FUNCTION
*  jam_notify_vm
* DESCRIPTION
*  
* PARAMETERS
*  void      
* RETURNS
*  void
*****************************************************************************/

void jam_notify_vm(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if (g_jvm_keypad_need_notify)
	{
		g_jvm_keypad_need_notify = KAL_FALSE;
		jvm_send_keypad_notify_ind();
	}
}

/*****************************************************************************
 * FUNCTION
*  jam_change_vm_state
 * DESCRIPTION
*  
 * PARAMETERS
*  oldScreenId       [IN]        
*  newScreenId     [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void jam_change_vm_state(kal_int32 vm_id,kal_uint16 oldScreenId, kal_uint16 newScreenId)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	kal_char * storage_name = jam_mvm_get_storage_name_by_vm_id(vm_id);
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

   kal_trace(TRACE_STATE, FUNC_JVM_VMSTATECHANGED_BEGIN, vm_id,jam_mvm_get_vm_state(vm_id),oldScreenId,newScreenId);

   if(jam_mvm_get_vm_state(vm_id) == JVM_TERMINATE_STATE)
		return;
	if (jam_is_lock_mmi())
	{
		kal_uint32 event_group;
		
		kal_retrieve_eg_events(g_java_event_group_2, JAVA_EG_MMI_LOCK_EVENT, KAL_OR_CONSUME, &event_group, KAL_SUSPEND);
	}
	
	jma_media_player_check_critical_section();
	
#if defined(__OP01__ ) && (defined(__IJET_VM__))&& defined(J2ME_SUPPORT_BACKGROUND)
	if(jam_call_back_functions.jam_get_running_midlet_domain(storage_name) == 2)
	{
		jvm_util_OP01_ret_enum ret = jvm_util_OP01_check_Keep_Background(vm_id);   
		if(ret == JVM_UTIL_SUCCESS)
		{
                    if(jam_is_enter_in_fg_mmi_screen_2(newScreenId))
                    {
                        jam_resmgr_state_transition(vm_id,JVM_FG_MMI_RUNNING_STATE);
                    }
                    else if(mmi_java_is_in_voice_call_op11())
                    {
                        jam_resmgr_state_transition(vm_id,JVM_LONG_EVENT_STATE);
                    }
                    else
                    {
                        jam_resmgr_state_transition(vm_id,JVM_BG_RUNNING_STATE);
                    }            
		}
		else if(ret == JVM_UTIL_FAIL)
		{
                    if(jam_is_enter_in_fg_mmi_screen_2(newScreenId))
                    {
                        jam_resmgr_state_transition(vm_id,JVM_FG_MMI_RUNNING_STATE);
                    }
                    else
                    {
                        jam_resmgr_state_transition(vm_id,JVM_LONG_EVENT_STATE);  
                    }
		}
		else if(ret == JVM_UTIL_MISS_INFO)
		{
		    if(jam_is_enter_in_fg_mmi_screen_2(newScreenId))
                    {
                        jam_resmgr_state_transition(vm_id,JVM_FG_MMI_RUNNING_STATE);
                    }
                    else
                    {
                        jam_resmgr_state_transition(vm_id,JVM_LONG_EVENT_STATE);  
                     }
		}           
		
	}
	else if(jam_is_enter_in_fg_mmi_screen_2(newScreenId))
	{
      jam_resmgr_state_transition(vm_id,JVM_FG_MMI_RUNNING_STATE);
	}
	else
	{
      jam_resmgr_state_transition(vm_id,JVM_LONG_EVENT_STATE);
	}
#elif defined(__OP01__ ) && (defined(__NEMO_VM__))&& defined(J2ME_SUPPORT_BACKGROUND)
    if(jam_mvm_is_vm_support_bg(vm_id))
    {
        if(jam_call_back_functions.jam_get_running_midlet_domain(storage_name) == 2)
    	{
    		jvm_util_OP01_ret_enum ret = jvm_util_OP01_check_Keep_Background(vm_id);   
    		if(ret == JVM_UTIL_SUCCESS)
    		{
                if(jam_is_enter_in_fg_mmi_screen_2(newScreenId))
                {
                    jam_resmgr_state_transition(vm_id,JVM_FG_MMI_RUNNING_STATE);
                }
                else if(mmi_java_is_in_voice_call_op11())
                {
                    jam_resmgr_state_transition(vm_id,JVM_LONG_EVENT_STATE);
                }
                else
                {
                    jam_resmgr_state_transition(vm_id,JVM_BG_RUNNING_STATE);
                }            
    		}
    		else if(ret == JVM_UTIL_FAIL)
    		{
                if(jam_is_enter_in_fg_mmi_screen_2(newScreenId))
                {
                    jam_resmgr_state_transition(vm_id,JVM_FG_MMI_RUNNING_STATE);
                }
                else
                {
                    jam_resmgr_state_transition(vm_id,JVM_LONG_EVENT_STATE);  
                }
    		}
    		else if(ret == JVM_UTIL_MISS_INFO)
    		{
    		    if(jam_is_enter_in_fg_mmi_screen_2(newScreenId))
                {
                    jam_resmgr_state_transition(vm_id,JVM_FG_MMI_RUNNING_STATE);
                }
                else
                {
                    jam_resmgr_state_transition(vm_id,JVM_LONG_EVENT_STATE);  
                 }
    		}           
    		
    	}
    	else if(jam_is_enter_in_fg_mmi_screen_2(newScreenId))
    	{
          jam_resmgr_state_transition(vm_id,JVM_FG_MMI_RUNNING_STATE);
    	}
    	else
    	{
          jam_resmgr_state_transition(vm_id,JVM_LONG_EVENT_STATE);
    	}
    }
    else
    {
        if (newScreenId == POPUP_SCREENID 
    //#ifdef __MMI_BACKGROUND_CALL__
    		//|| newScreenId == SCR_ID_UCM_CALL_END
    //#endif 
    		)
    	{
          jam_resmgr_state_transition(vm_id,JVM_SHORT_EVENT_STATE);
    	} 
    	else if(jam_is_enter_in_fg_mmi_screen_2(newScreenId))
    	{    
          jam_resmgr_state_transition(vm_id,JVM_FG_MMI_RUNNING_STATE);        
    	}
    	else
    	{
          jam_resmgr_state_transition(vm_id,JVM_LONG_EVENT_STATE);
    	}
    }
	
#else
	
	if (newScreenId == POPUP_SCREENID 
//#ifdef __MMI_BACKGROUND_CALL__
		//|| newScreenId == SCR_ID_UCM_CALL_END
//#endif 
		)
	{
      jam_resmgr_state_transition(vm_id,JVM_SHORT_EVENT_STATE);
	} 
	else if(jam_is_enter_in_fg_mmi_screen_2(newScreenId))
	{    
      jam_resmgr_state_transition(vm_id,JVM_FG_MMI_RUNNING_STATE);        
	}
	else
	{
      jam_resmgr_state_transition(vm_id,JVM_LONG_EVENT_STATE);
	}
#endif
	
	/*
	* If JVM is waiting for message to wakeup, send the message
	* * This is for JSR-75. The mounted drive may be unmounted after resumed.
	* * We have to inform the VM in each case.
	*/
	if (g_jvm_keypad_need_notify)
	{
		g_jvm_keypad_need_notify = KAL_FALSE;
		jvm_send_keypad_notify_ind();
	}
   kal_trace(TRACE_STATE, FUNC_JVM_VMSTATECHANGED_END, vm_id,jam_mvm_get_vm_state(vm_id),oldScreenId,newScreenId);
}


/*****************************************************************************
* FUNCTION
*  jam_delete_fg_mmi_screen
* DESCRIPTION
*  
* PARAMETERS

  * RETURNS
  *  kal_bool
*****************************************************************************/

void jam_delete_fg_mmi_screen()
{
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    jui_widget_deregister_extra_symbol_callback();
    
    mmi_ime_register_editor_common_scr_entry_callback(NULL);
    mmi_ime_register_editor_common_scr_exit_callback(NULL);

    mmi_java_ui_textbox_delete_phb_cui();
#if  defined (__COSMOS_MMI_PACKAGE__)   && !defined (J2ME_SLIM_MEMORY_SUPPORT)
    mmi_java_ui_textfield_delete_phb_cui();
#endif

    mmi_ime_delete_editor_common_scr_with_sg(GRP_ID_JAVA_APP, SCR_ID_JAVA_UI_TEXTFIELD_EDITOR);
    mmi_ime_delete_editor_common_scr_with_sg(GRP_ID_JAVA_APP, SCR_ID_JAVA_UI_TEXTFIELD_EDITOR_OPTION);
    mmi_ime_delete_editor_common_scr_with_sg(GRP_ID_JAVA_APP, SCR_ID_JAVA_UI_TEXTBOX_EDITOR);
    mmi_ime_delete_editor_common_scr_with_sg(GRP_ID_JAVA_APP, SCR_ID_JAVA_UI_TEXTBOX_EDITOR_OPTION);

#ifdef __COSMOS_MMI_PACKAGE__
    if (vapp_java_ui_is_option_menu_existed())
    {
        vapp_java_ui_option_menu_hide(KAL_FALSE);
    }
    vapp_java_ui_textfield_hide();
    vapp_java_ui_datefield_hide();
#endif
}


/*****************************************************************************
* FUNCTION
*  jam_is_enter_fg_mmi_screen
* DESCRIPTION
*  
* PARAMETERS

  * RETURNS
  *  kal_bool
*****************************************************************************/
kal_bool jam_is_enter_fg_mmi_screen()
{ 
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_ID group_id;
    MMI_ID screen_id;
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_frm_get_active_scrn_id(&group_id,&screen_id); 
    return jam_is_enter_in_fg_mmi_screen_2( screen_id );
}

/*****************************************************************************
* FUNCTION
*  jam_is_enter_in_fg_mmi_screen_2
* DESCRIPTION
*  
* PARAMETERS
*  screenId     [IN]             
* RETURNS
*  kal_bool
*****************************************************************************/
kal_bool jam_is_enter_in_fg_mmi_screen_2(kal_uint16 screenId)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
   switch(screenId)
   {
   case  SCR_ID_JAVA_UI_TEXTBOX_EDITOR:
   case  SCR_ID_JAVA_UI_TEXTBOX_EDITOR_OPTION:
   case  SCR_ID_JAVA_UI_OPTION_MENU:
   //case  SCR_ID_JAVA_UI_TEXTFIELD_EDITOR:
   //case  SCR_ID_JAVA_UI_TEXTFIELD_EDITOR_OPTION:
   //case  SCR_ID_JAVA_UI_DATEFIELD_DATE:
   //case  SCR_ID_JAVA_UI_DATEFIELD_TIME:
		return KAL_TRUE;
		
	default:
		if(/*IsScreenPresent(SCR_ID_JAVA_UI_TEXTBOX_EDITOR)*/ mmi_frm_scrn_is_present(GRP_ID_JAVA_APP,SCR_ID_JAVA_UI_TEXTBOX_EDITOR,MMI_FRM_NODE_ALL_FLAG))  //10A
		{
			if(screenId>=SCR_INPUT_METHOD_LIST && screenId<SCR_COMMON_SCREENS_END)
			{
				return KAL_TRUE;
			}
		}
	}
	
#ifdef __COSMOS_MMI_PACKAGE__

	if(vapp_java_is_permission_force_fgmmi())
	{
	    return KAL_TRUE;
	}
#endif

	return KAL_FALSE;
}

/*****************************************************************************
* FUNCTION
*  jam_exit_fg_mmi_screen_callback
* DESCRIPTION
*  
* PARAMETERS
*  oldScreenId     [IN]        
*  newScreenId     [IN]   
*  mmi_screen_enter_func   [IN]
* RETURNS
*  void
*****************************************************************************/
void jam_exit_fg_mmi_screen_callback(kal_uint16 oldScreenId, kal_uint16 newScreenId,void (*mmi_screen_enter_func)())
{
	
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
   kal_int32 vm_id = jam_mvm_get_current_vm_id();
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
   kal_trace(TRACE_STATE, FUNC_JVM_EXITFGMMISCREEN, vm_id,jam_mvm_get_vm_state(vm_id),SCR_JAVA_APP,oldScreenId,newScreenId,mmi_screen_enter_func,jam_is_enter_in_fg_mmi_screen_2(newScreenId));
	
	if(newScreenId == SCR_JAVA_APP )
	{ 
	    kal_trace(TRACE_STATE, FUNC_JVM_EXIT_JMA_CALLBACK,1);
	    #ifdef SUPPORT_JSR_135_VIDEO
      jma_media_player_exit_screen_hdlr(vm_id);
      #endif
		mmi_ime_register_editor_common_scr_entry_callback(NULL);
        mmi_ime_register_editor_common_scr_exit_callback(NULL);
		return;
	}
	
    #if 0 // removed for 10A, set entry function in EntryNewScreen
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #endif /* if 0 */
	
	if(jam_is_enter_in_fg_mmi_screen_2(newScreenId))
	{
	    kal_trace(TRACE_STATE, FUNC_JVM_EXIT_JMA_CALLBACK,2);
	    #ifdef SUPPORT_JSR_135_VIDEO
        jma_media_player_exit_screen_hdlr(vm_id);
      #endif
	}
	else
	{
	    mmi_ime_register_editor_common_scr_entry_callback(NULL);
        mmi_ime_register_editor_common_scr_exit_callback(NULL);
        jam_change_vm_state(vm_id,oldScreenId,newScreenId);
	}
}


/*****************************************************************************
* FUNCTION
*  jam_resume_fg_mmi_screen_callback
* DESCRIPTION
*  
* PARAMETERS
*  oldScreenId     [IN]        
*  newScreenId     [IN]        
* RETURNS
*  void
*****************************************************************************/
void jam_resume_fg_mmi_screen_callback(kal_uint16 oldScreenId,kal_uint16 newScreenId,kal_int32 previous_screen,kal_int32 next_screen)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

   kal_int32 vm_id = jam_mvm_get_current_vm_id();
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

   kal_trace(TRACE_STATE, FUNC_JVM_RESUMEFGMMISCREEN, vm_id,jam_mvm_get_vm_state(vm_id),SCR_JAVA_APP,oldScreenId,newScreenId,jam_is_enter_in_fg_mmi_screen_2(oldScreenId));

    //if(oldScreenId == newScreenId)
        //return;
    jui_widget_register_extra_symbol_callback(); 
    
	if (g_jvm_keypad_need_notify)
	{
		g_jvm_keypad_need_notify = KAL_FALSE;
		jvm_send_keypad_notify_ind();
	}
	
	if(/*oldScreenId == SCR_JAVA_APP*/ previous_screen == JAVA_SCREEN_TYPE_JAVA)
	{
	    kal_trace(TRACE_STATE, FUNC_JVM_ENTRY_JMA_CALLBACK,1);
	    #ifdef SUPPORT_JSR_135_VIDEO
      jma_media_player_entry_screen_hdlr(vm_id);
      #endif
		return;
	}
	//if(jam_is_enter_in_fg_mmi_screen_2(oldScreenId) || (jam_is_own_mmi_screen()&& jam_is_enter_in_fg_mmi_screen_2(newScreenId)))
    if(previous_screen == JAVA_SCREEN_TYPE_JAVA_MMI && next_screen == JAVA_SCREEN_TYPE_JAVA_MMI)
    {
	    kal_trace(TRACE_STATE, FUNC_JVM_ENTRY_JMA_CALLBACK,2);
	    #ifdef SUPPORT_JSR_135_VIDEO
      jma_media_player_entry_screen_hdlr(vm_id);
      #endif
	}
	else
	{
      jam_change_vm_state(vm_id,oldScreenId,  newScreenId);
	}
}


/*****************************************************************************
* FUNCTION
*  jam_nw_update_network_setting
* DESCRIPTION
*  this function is to ask user to update network setting
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
kal_bool jam_nw_update_network_setting(void)
{
   // kal_bool is_always_ask;
   // kal_int32 vm_id = 0;
    /* Display always-ask screen */
    return KAL_TRUE;
}


/*****************************************************************************
* FUNCTION
*  jam_get_g_jam_exit_by_asm
* DESCRIPTION
*  
* PARAMETERS
*       
* RETURNS
*  void
*****************************************************************************/
kal_bool jam_get_g_jam_exit_by_asm(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return g_jam_exit_by_asm;
}

kal_bool jam_is_java_running(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(0 == jam_mvm_get_running_count())
        return KAL_FALSE;
    else
        return KAL_TRUE;
}

/*****************************************************************************
* FUNCTION
*  jam_is_enter_fg_mmi_pluto_screen
* DESCRIPTION
*  
* PARAMETERS

  * RETURNS
  *  kal_bool
*****************************************************************************/
kal_bool jam_is_enter_fg_mmi_pluto_screen()
{ 
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	MMI_ID group_id;
    MMI_ID screen_id;
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_frm_get_active_scrn_id(&group_id,&screen_id); 
	switch(screen_id)
    {
    case  SCR_ID_JAVA_UI_TEXTBOX_EDITOR:
    case  SCR_ID_JAVA_UI_TEXTBOX_EDITOR_OPTION:
    case  SCR_ID_JAVA_UI_OPTION_MENU:
		    return KAL_TRUE;

	default:
		if(mmi_frm_scrn_is_present(GRP_ID_JAVA_APP,SCR_ID_JAVA_UI_TEXTBOX_EDITOR,MMI_FRM_NODE_ALL_FLAG))  //10A
		{
			if(screen_id >= SCR_INPUT_METHOD_LIST && screen_id < SCR_COMMON_SCREENS_END)
			{
				return KAL_TRUE;
			}
		}
	}
    return KAL_FALSE;
}


#ifdef __COSMOS_MMI_PACKAGE__
extern long*g_jam_mvm_whole_heap_space;
extern kal_uint32 g_jam_mvm_whole_heap_size;
mmi_ret jam_mem_prepare_proc(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8* ptr;
    kal_uint8* memory_ptr = NULL;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    kal_trace(JAM_JAVAAGENCY_GROUP, JAM_MEM_PREPARE_PROC,evt->evt_id);
    switch(evt->evt_id)
    {
    case EVT_ID_ASM_CANCELED:
        kal_set_eg_events(g_java_event_group_2, JAVA_EG_ASM, KAL_OR);
        if(!g_is_asm_allow_to_launch)
        {
            g_is_asm_allow_to_launch = KAL_TRUE;
        }
        #if defined(__COSMOS_MMI_PACKAGE__)
        mmi_frm_scrn_set_leave_proc(APP_JAVA, SCR_JAVA_DUMMY, NULL);
        mmi_frm_group_close(APP_JAVA);
        #endif        
        break;

    case EVT_ID_ASM_PREPARED:
        memory_ptr = mmi_frm_asm_alloc_r(APP_JAVA, DEFAULTHEAPSIZE + DEFAULT_POOL_SIZE);
        MMI_ASSERT(memory_ptr); // impossible
        javaruntime_space = (long * )(memory_ptr);
        javaruntime_size = DEFAULT_POOL_SIZE;
		jam_javaruntime_set_poolflag(JAVARUNTIME_POOL_RUNTIME);
        g_jam_mvm_whole_heap_space = (long * )(memory_ptr + javaruntime_size);
        g_jam_mvm_whole_heap_size = DEFAULTHEAPSIZE;
        kal_set_eg_events(g_java_event_group_2, JAVA_EG_ASM, KAL_OR);        
        break;
        
    case EVT_ID_ASM_FORCE_FREE:
         jam_exit_screen_callback_for_asm();
         break;
	default :
        break;
    }
    return MMI_RET_OK;
}
#endif



#ifdef __MMI_JAVA_CATEGORY_SUPPORT__

kal_int32 jam_category_op01_magicbox_hilighlight_index = 0;
kal_int32  jam_category_op01_gplusgame_hilighlight_index = 0;

/*****************************************************************************
* FUNCTION
*  jam_set_category_op01_hilighlight_index
* DESCRIPTION
*  
* PARAMETERS
*  oldScreenId     [IN]        
*  newScreenId     [IN]        
* RETURNS
*  void
*****************************************************************************/
void jam_set_category_op01_hilighlight_index(kal_int32 index, jam_getlist_filter_type_enum  type, jam_category_type_enum  filter)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(  JAM_CATEGORY_FILTER   ==  type  &&
          JAM_CATEGORY_OP01_GPLUS ==  filter )
        {
             jam_category_op01_gplusgame_hilighlight_index = index;
        }
    if( JAM_CATEGORY_FILTER   ==  type &&
          JAM_CATEGORY_OP01_MAGICBOX ==   filter )
        {
            jam_category_op01_magicbox_hilighlight_index = index;
        }
          
}


/*****************************************************************************
* FUNCTION
*  jam_get_category_op01_hilighlight_index
* DESCRIPTION
*  
* PARAMETERS
*  oldScreenId     [IN]        
*  newScreenId     [IN]        
* RETURNS
*  void
*****************************************************************************/

kal_int32 jam_get_category_op01_hilighlight_index(jam_getlist_filter_type_enum  type, jam_category_type_enum  filter)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
        if(  JAM_CATEGORY_FILTER   ==  type &&
          JAM_CATEGORY_OP01_GPLUS ==   filter )
        {
            return  jam_category_op01_gplusgame_hilighlight_index;
        }
         if( JAM_CATEGORY_FILTER   ==  type &&
          JAM_CATEGORY_OP01_MAGICBOX ==  filter )
        {
           return jam_category_op01_magicbox_hilighlight_index;
        }
}

#endif

void jam_update_app_info_callback(void *data) /* this function is call by MMI */
{
      srv_appmgr_update_app_info(NULL, EVT_ID_SRV_APPMGR_UPDATE_INSTALLED_PACKAGE);
	  kal_prompt_trace(MOD_MMI,"here MMI Proc will send event to notify mainmenu! ");
	  return;
}

/*****************************************************************************
* FUNCTION 
* jam_preinstall_mids_notify_mainmenu
* DESCRIPTION
* 
* PARAMETERS
* RETURNS 
* void 
*modify/add date: 2012-9-19
*modify/add time: 19:52:43
*****************************************************************************/
void jam_preinstall_mids_notify_mainmenu()
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
     module_type src_mod_id;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    src_mod_id = kal_get_active_module_id();
    g_mmi_java_allow_show_icon=KAL_TRUE; 

    if (src_mod_id == MOD_MMI)
    	{
         srv_appmgr_update_app_info(NULL, EVT_ID_SRV_APPMGR_UPDATE_INSTALLED_PACKAGE);
	     kal_prompt_trace(MOD_MMI,"here MMI will send event to notify mainmenu! ");
    	}
	else
		{
	  	 jam_execute_rpc((func_ptr) jam_update_app_info_callback, NULL,KAL_TRUE);   /* this goback history should run in MMI task. */
         kal_prompt_trace(MOD_JAM,"here JAM will send event to notify mainmenu! ");
		}
    return;

}

#endif /* __J2ME__ */ 

