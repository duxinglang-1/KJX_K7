/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*******************************************************************************
* Filename:
* ---------
*  
*
* Project:
* --------
*  MAUI
*
* Description:
* ------------
*  
*
* Author:
* -------
 * -------
*
*==============================================================================
*             HISTORY
* Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!! 
*------------------------------------------------------------------------------
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
*------------------------------------------------------------------------------
* Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!! 
*==============================================================================
*******************************************************************************/


#include "MMI_features.h"
#include "vmswitch.h"

#ifdef __MRE_LIB_GRAPIC_IMAGE__
#include "gdi_datatype.h"
#include "PixcomFontEngine.h"
#include "gdi_const.h"
#include "MMIDataType.h"
#include "FontRes.h"
#include "kal_non_specific_general_types.h"
#include "DevConfigGprot.h"
#include "devconfiggprot.h"
#include "gdi_include.h"
#include "gui.h"
#include "gui_data_types.h"
#include "gui_resource_type.h"
#include "stdio.h"
#include "gui_typedef.h"
#include "wgui_include.h"
#include "wgui_categories_util.h"
#include "lcd_sw_inc.h"
#include "ui_buffer.h"
#include "vmmacrostub.h"
#include "vmgraph.h"
#include "vmchset.h"
#include "vmlog.h"
#include "vmstdlib.h"
#include "vmopt.h"
#include "string.h"
#include "vmsys.h"
#include "vmmod.h"
#include "vmresmng.h"
#include "vmpromng.h"
#include "vmpromnginner.h"
#include "mmu.h"
#include "cache_sw.h"

#include "gdi_linear_transform.h"
#include "gdi_2d_engine.h"


//#define __MMI_MRE_SWLA_DEBUG__

#if defined(__MTK_INTERNAL__) && defined(__MTK_TARGET__) && defined(__MMI_MRE_SWLA_DEBUG__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#else
#define MRE_SWLA_START(_symbol_)
#define MRE_SWLA_STOP(_symbol_)
#endif


extern void gdi_draw_font_by_abm(
                S32 x, 
                S32 y, 
                gdi_color color, 
                U8 *font_data, 
                S32 char_width, 
                S32 char_height);

/* ------------------------------------------------------------------------- */
/* Define And Typedef                                             							*/
/* ------------------------------------------------------------------------- */


#define  VM_KEY_COLOR						(0XFFFD)

#define  VM_FONT_ATTR_BOLD					0x00000002
#define  VM_FONT_ATTR_ITALIC				0x00000004
#define  VM_FONT_ATTR_OBLIQUE				0x00000008
#define  VM_FONT_ATTR_UNDERLINE			    0x00000010


#define GDI_ACT_COLOR_FROM_RGB(color16) ( gdi_act_color_from_rgb(255, VM_COLOR_GET_RED(color16), VM_COLOR_GET_GREEN(color16), VM_COLOR_GET_BLUE(color16)) )


#define SAL_HANDLE(MREHANDLE)  (layer_trans_tbl[(MREHANDLE)].handle)

#define MAX_PROCESS 16
#define MRE_LIMIT_VALUE(POS, MIN_VALUE, MAX_VALUE) \
   do{                                         \
      if((POS) < (MIN_VALUE))                      \
         (POS) = (MIN_VALUE);                      \
      else if((POS) > (MAX_VALUE))                 \
         (POS) = (MAX_VALUE);                      \
   }while(0)


typedef struct
{
	VM_P_HANDLE phandle;
	VMINT mibrhandle;
}vm_graphic_mibr_node;


typedef struct gif_info_t
{
    VMINT	frames;
    VMINT16 scrWidth,scrHeight;
    VMBYTE	gFlag;
    VMINT	colorRes;
    VMBYTE	gSort;
    VMINT	gSize;
    VMBYTE	BKColorIdx;
    VMBYTE	pixelAspectRatio;
    VMBYTE	* gColorTable;
    VMUINT32 fsize;
}gif_info_t;


typedef struct IHDR_t 
{
    VMINT32	width;
    VMINT32	height; 
    VMBYTE	bitdepth; 
    VMBYTE	colortype; 
}IHDR_t;


typedef struct
{
	VM_P_HANDLE phandle;
	VMINT gcbhandle;
}vm_graphic_gcb_node;


typedef enum
{
    VM_GRAPHIC_FLUSH_FLAG_NON_BLOCKING     = (1 << 0),
    VM_GRAPHIC_FLUSH_FLAG_REGION_BLT  = (1 << 1),

    VM_GRAPHIC_FLUSH_FLAG_END_OF_ENUM
} vm_graphic_flush_flag_enum;

typedef enum
{
	VM_GRAPHIC_FLUSH_WAY_NON_EX_BUFFER,
    VM_GRAPHIC_FLUSH_WAY_SINGLE_EX_BUFFER,
    VM_GRAPHIC_FLUSH_WAY_DOUBLE_EX_BUFFER,

    VM_GRAPHIC_FLUSH_WAY_END_OF_ENUM
} vm_graphic_flush_way_enum;


typedef struct
{
	gdi_handle async_blt_layer;
	vm_graphic_flush_way_enum async_blt_way;
	U8* async_blt_buffer_A;
	U8* async_blt_buffer_B;
	VMINT async_blt_buffer_A_size;
	VMINT async_blt_buffer_B_size;
	VMINT is_first_blt_flag;
	VMINT previous_blt_layers[6];
}vm_graphic_async_blt_cb;

static vm_graphic_async_blt_cb g_vm_blt_cb;

#if !defined(__MMI_SCREEN_SWITCH_EFFECT__) || defined(__MMI_REDUCED_UI_BUFFER__)

kal_mutexid mre_async_blt_mutex = NULL;

#define BEGIN_PROTECT_ASYNC_BLT         \
   if(mre_async_blt_mutex == NULL)         \
      mre_async_blt_mutex = kal_create_mutex("mreAblt");    \
   kal_take_mutex(mre_async_blt_mutex);  \

#define END_PROTECT_ASYNC_BLT           \
   kal_give_mutex(mre_async_blt_mutex);  \

#endif


/* ------------------------------------------------------------------------- */
/* Extern Platform API                                               							*/
/* ------------------------------------------------------------------------- */

extern mmi_devconfig_system_config_struct sysconf;
extern S32 gdi_sizeof_pixels(gdi_color_format cf, S32 width, S32 height);


/* ------------------------------------------------------------------------- */
/* Extern MRE API                                                              */
/* ------------------------------------------------------------------------- */
VMINT vm_is_open_camera_flush_screen_patten(void);
VMINT vm_camera_patten_flush_screen_buffer(void);
void vm_graphic_set_clip_internal(VMINT x1, VMINT y1, VMINT x2, VMINT y2);

vm_graphic_color_argb vm_graphic_getcolor_argb(void);
VM_GDI_RESULT convert_to_mre_color_format(gdi_color_format color_format, vm_graphic_color_famat *cf);

/* ------------------------------------------------------------------------- */
/* Module Internal Function                                                     */
/* ------------------------------------------------------------------------- */
static VM_GDI_HANDLE vm_graphic_mibr_save_layer(void);
static VM_GDI_HANDLE vm_graphic_mibr_release_layer(VMINT mibrlayer);


/* ------------------------------------------------------------------------- */
/* Module External Function                                                     */
/* ------------------------------------------------------------------------- */


/* ------------------------------------------------------------------------- */
/* Global Variable Declare                                                        	    */
/* ------------------------------------------------------------------------- */


/* ------------------------------------------------------------------------- */
/* Local Variable Declare                                              	*/
/* ------------------------------------------------------------------------- */
#ifdef __MRE_LIB_GRAPIC_GFXOLD__
extern VMINT is_base_layer_created ;             //The flag of base layer created
extern  VMINT is_screen_buffer_initialized;      //screen initlized flag
#endif

static VMINT screen_width = -1;
static VMINT screen_height = -1;


/*
 *layer counter
 */
static VMINT layer_count = 0;


/*
 * base layer handle, if not created , it would be -1
 */
static VMINT is_base_layer = -1;

/*
 * current fast layer handle , if not created, it would be -1
 */
static VMINT is_fast_layer = -1;

/*
 *layer tranform table
 */
 layer_param_t layer_trans_tbl[MAX_LAYER];


static vm_graphic_gcb_node gcb_table[MAX_PROCESS];


VM_GDI_RESULT convert_to_gdi_rotate_degree(vm_graphic_rotate_value degree, VMUINT8 *rotate_value)
{
	switch (degree) 
	{
		case VM_GDI_ROTATE_NORMAL:
			*rotate_value = GDI_LAYER_ROTATE_0;
			break;	
		case VM_GDI_ROTATE_90:
			*rotate_value = GDI_LAYER_ROTATE_90;
			break;
		case VM_GDI_ROTATE_180:
			*rotate_value = GDI_LAYER_ROTATE_180;
			break;
		case VM_GDI_ROTATE_270:
			*rotate_value = GDI_LAYER_ROTATE_270;
			break;	
		case VM_GDI_MIRROR:
			*rotate_value = GDI_LAYER_ROTATE_0_MIRROR;
			break;	
		case VM_GDI_MIRROR_ROTATE_90:
			*rotate_value = GDI_LAYER_ROTATE_90_MIRROR;
			break;
		case VM_GDI_MIRROR_ROTATE_180:
			*rotate_value = GDI_LAYER_ROTATE_180_MIRROR;
			break;
		case VM_GDI_MIRROR_ROTATE_270:
			*rotate_value = GDI_LAYER_ROTATE_270_MIRROR;
			break;	
		default:
			MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_976 , degree);
			return VM_GDI_ERR_WRONG_PARAM;
	}	

	return VM_GDI_SUCCEED;
}

VMINT is_color_format_valid(vm_graphic_color_famat cf)
{
     vm_graphic_color_famat_enum temp_cf = (vm_graphic_color_famat_enum)cf;
     
	if ( temp_cf < VM_GRAPHIC_COLOR_FORMAT_16 || temp_cf > VM_GRAPHIC_COLOR_FORMAT_32_PARGB )
	{
		MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_997 , cf);
		return FALSE;
	}

	return TRUE;
}

static const gdi_color_format vm_graphic_color_famat_mapping_table[] =
{
	GDI_COLOR_FORMAT_16,
	GDI_COLOR_FORMAT_24,
	GDI_COLOR_FORMAT_32,
	GDI_COLOR_FORMAT_32_PARGB,
};

VM_GDI_RESULT convert_to_gdi_color_format(vm_graphic_color_famat cf, gdi_color_format *color_format)
{
	if ( is_color_format_valid(cf) )
	{
		*color_format = vm_graphic_color_famat_mapping_table[cf];
		return VM_GDI_SUCCEED;
	}
	else
	{
		MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_1022 , cf);
		return VM_GDI_ERR_WRONG_PARAM;
	}
}


VM_GDI_RESULT convert_to_mre_color_format(gdi_color_format color_format, vm_graphic_color_famat *cf)
{
	switch (color_format) 
	{
		case GDI_COLOR_FORMAT_16:
			*cf = VM_GRAPHIC_COLOR_FORMAT_16;
			break;
		case GDI_COLOR_FORMAT_24:
			*cf = VM_GRAPHIC_COLOR_FORMAT_24;
			break;
		case GDI_COLOR_FORMAT_32:
			*cf = VM_GRAPHIC_COLOR_FORMAT_32;
			break;
		case GDI_COLOR_FORMAT_32_PARGB:
			*cf = VM_GRAPHIC_COLOR_FORMAT_32_PARGB;
			break;		
		default:
			MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_1047 , color_format);
			return VM_GDI_ERR_WRONG_PARAM;
	}	

	return VM_GDI_SUCCEED;
}


//====================================Module Internal Function==========================


static U8 vm_convert_font_size(VMINT size)
{
	U8 font_size;

	switch (size) 
	{
		case VM_SMALL_FONT:
			font_size = SMALL_FONT;
			break;
		case VM_MEDIUM_FONT:
			font_size = MEDIUM_FONT;
			break;
		case VM_LARGE_FONT:
			font_size = LARGE_FONT;
			break;
		default:
			if (vm_graphic_is_use_vector_font())
				font_size = FONT_PIXEL_SIZE(size);
			else
				font_size = MEDIUM_FONT;
			break;
	}	

	return font_size;
}


vm_graphic_cb * vm_graphic_get_current_cb()
{
	VMINT phandle = vm_pmng_get_app_handle();
	vm_graphic_cb *gcb;
	VMINT i;
	VMINT bufsize = 0;

	for (i = 0;i<MAX_PROCESS;i++)
	{
		if (gcb_table[i].phandle == phandle)
			break;
	}	

	if (i == MAX_PROCESS)
	{
		MMI_TRACE(MMI_MRE_TRC_WARNING, TRC_MRE_VMGRAPH_556 );
		return NULL; 	
	}

	if (vm_res_get_data(VM_RES_TYPE_GRAPHIC_CXT, gcb_table[i].gcbhandle, (void **)(&gcb), &bufsize) < 0)
	{
		MMI_TRACE(MMI_MRE_TRC_WARNING, TRC_MRE_VMGRAPH_562 );	
		return NULL;
	}
	
	return gcb;
}


static VMINT INVALID_MRE_HANDLE(VMINT handle)  
{
	if (((handle) < 0) || ((handle) >= MAX_LAYER) ||( !(layer_trans_tbl[(handle)].used)))
		return TRUE;
	return FALSE;

}

static VMINT VALID_MRE_HANDLE(VMINT handle)  
{
	if (((handle) >= 0) && ((handle) < MAX_LAYER) && (layer_trans_tbl[(handle)].used))
		return TRUE;
	
	return FALSE;		
}

static VMINT is_mre_canvas_buf(VMBYTE *buf)
{
	if (memcmp(buf, "MTKCAN", 6) == 0)
		return TRUE;
	
	return FALSE;
}

VMINT vm_graphic_is_use_vector_font(void)
{
    if (sysconf.font_engine.fe_vector_support == MMI_TRUE)
		return TRUE;
	
	return FALSE;
}

VMINT vm_graphic_get_blt_layer_count(void)
{
	if(sysconf.gdi_info.gdi_6_layer == MMI_TRUE)
		return 6;
	else
		return 4;
}

VMINT get_canvas_prop(VMBYTE *buf,vm_canvas_prop  type)
{
	switch(type)
	{
		case VM_CANVAS_LEFT:
			return (VMINT)(buf[VM_CANVAS_SIGNATURE_SIZE+2] * 256 + buf[VM_CANVAS_SIGNATURE_SIZE+1]); 
		
		case VM_CANVAS_TOP:
			return (VMINT)(buf[VM_CANVAS_SIGNATURE_SIZE+4] * 256 + buf[VM_CANVAS_SIGNATURE_SIZE+3]); 
		
		case VM_CANVAS_WIDTH:
			return (VMINT)(buf[VM_CANVAS_SIGNATURE_SIZE+6] * 256 + buf[VM_CANVAS_SIGNATURE_SIZE+5]); 
		
		case VM_CANVAS_HEIGHT:
			return (VMINT)(buf[VM_CANVAS_SIGNATURE_SIZE+8] * 256 + buf[VM_CANVAS_SIGNATURE_SIZE+7]);  

		case VM_CANVAS_CF:
			return (VMINT)(buf[VM_CANVAS_FRAME_NUM_OFFSET+2]); 
		
		case VM_CANVAS_DATASIZE:
			return (VMINT)(buf[VM_CANVAS_SIGNATURE_SIZE+16]
								+ (buf[VM_CANVAS_SIGNATURE_SIZE+17]<<8)
								+ (buf[VM_CANVAS_SIGNATURE_SIZE+18]<<16)
								+ (buf[VM_CANVAS_SIGNATURE_SIZE+19]<<24));  
			
		default:
			return 0;
	}
}

static void save_canvas_to_layer(VMINT handle, VMBYTE *canvasbuf, VMBYTE *canvasbuf_1)
{
	layer_trans_tbl[handle].canvas = canvasbuf;
	layer_trans_tbl[handle].canvas1 = canvasbuf_1;	
	return;
}

#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif

static void save_layer_to_canvas(VMINT handle,VMBYTE *canvasbuf)
{
	VMUINT8  shorthandle;
	
	shorthandle = (VMUINT16)((handle << 24) >> 24);
	canvasbuf[VM_CANVAS_FRAME_NUM_OFFSET+1] = shorthandle;
	return;
}

static void delete_layer_from_canvas(VMBYTE * canvasbuf)
{
	canvasbuf[VM_CANVAS_FRAME_NUM_OFFSET+1] = 0xff;
	return;
}


/*canvas corresponding to layer one to one*/
/*find the canvas in which memory*/
static VMINT find_canvas(VMINT handle)
{
	if ((handle == is_fast_layer) || (handle == is_base_layer))
		return 0;
	if (INVALID_MRE_HANDLE(handle))
		return VM_GDI_ERR_WRONG_PARAM;
	
	return (VMINT)(layer_trans_tbl[handle].canvas);
}

/*find the canvas in which layer*/
static VMINT find_layer(VMBYTE * canvasbuf)
{
	if ((!canvasbuf) || (!is_mre_canvas_buf(canvasbuf)) )
		return VM_GDI_FAILED;

	return (VMINT)(canvasbuf[VM_CANVAS_FRAME_NUM_OFFSET+1]);
}

/*find the empty node*/
static VM_GDI_RESULT find_empty_node_in_layer_table(void)
{
	VMINT i;
		
	for(i=0;i<MAX_LAYER;i++)
    {   
		if (layer_trans_tbl[i].used== FALSE)
			break;
	}
	
    MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_FEN_NO_EMPTY_NODE, i);
	
	return ((i==MAX_LAYER) ? VM_GDI_FAILED : i);
}

/*find layer handle whether belong to current process*/
static VM_GDI_RESULT handle_belong_to_cur_process(VMINT handle) 
{
	VM_P_HANDLE phandle = vm_pmng_get_app_handle();
	VM_P_HANDLE testhandle;
		
	if (phandle <= 0)
		return VM_GDI_MIBR_ERR;
	
	if ((testhandle = vm_res_get_process_handle(VM_RES_TYPE_LAYER_HANDLE,layer_trans_tbl[handle].mibrhandle)) ==  phandle)
	{
		return VM_GDI_SUCCEED;
	}
	
    MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_HBCP_FAIL, phandle, testhandle);

	return VM_GDI_MIBR_RES_ERR;
}

static VMINT enlarge_image(vm_graphic_color_famat cf, VMUINT8 *in_data,VMINT swidth,VMINT sheight,VMUINT8 *out_data,VMINT dwidth,VMINT dheight)
{
	VMUINT pixelvalueb=0,pixelvalueg=0,pixelvaluer=0; 
    VMUINT spixelcolnum=0,spixelrownum=0,destcol=0,destrow=0;   
    VMUINT spixelcoladdr=0,spixelrowaddr=0;   
    VMUINT coldelta=0,rowdelta=0,scalev=0,scaleh=0; 
	VMUINT in_data_idx=0,out_data_idx=0;
		
	if (dwidth > MAX_PIXEL_ENLARGE)
		return VM_GDI_ERR_WRONG_PARAM;

	scaleh = (swidth<<8)/dwidth;	 
	scalev = (sheight<<8)/dheight;  
	
	MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_740 ,scaleh, scalev);
	
	if ( cf == VM_GRAPHIC_COLOR_FORMAT_16 )
	{
		do {
			for(destcol=0;destcol<(VMUINT)dwidth;destcol++)   
			{	
				spixelcoladdr=destcol*scaleh;	
				coldelta=spixelcoladdr&255;   
				spixelcolnum=(spixelcoladdr-coldelta)>>8; 

				in_data_idx = 2*spixelrownum*swidth+2*spixelcolnum;
				out_data_idx = 2*destrow*dwidth+2*destcol;
					
				pixelvalueb = (in_data[in_data_idx] & 0x1F) << 3;
				pixelvalueg = (((in_data[in_data_idx+1] & 0x07) << 4) +( (in_data[in_data_idx] & 0xE0) >>4)) << 1;				   
				pixelvaluer = (in_data[in_data_idx+1] & 0xF8);  
					
				out_data[out_data_idx] = (((pixelvalueg >> 2 ) & 0x07 ) << 5) + ((pixelvalueb & 0xF8) >> 3);	
				out_data[out_data_idx+1]= pixelvaluer + ((pixelvalueg >> 5 ) & 0x07);   
			}
			destrow++;
			spixelrowaddr=destrow*scalev;	
			rowdelta=spixelrowaddr&255;   
			spixelrownum=(spixelrowaddr-rowdelta)>>8;	
		} while (destrow<(VMUINT)dheight);	
	}
 	else if ( cf == VM_GRAPHIC_COLOR_FORMAT_24 )
 	{
		do {
			for(destcol=0;destcol<(VMUINT)dwidth;destcol++)   
			{	
				spixelcoladdr=destcol*scaleh;	
				coldelta=spixelcoladdr&255;   
				spixelcolnum=(spixelcoladdr-coldelta)>>8; 

				in_data_idx = 3*spixelrownum*swidth+3*spixelcolnum;
				out_data_idx = 3*destrow*dwidth+3*destcol;

				out_data[out_data_idx] = in_data[in_data_idx];	
				out_data[out_data_idx+1] = in_data[in_data_idx+1];
				out_data[out_data_idx+2] = in_data[in_data_idx+2];
			}	
			destrow++;
			spixelrowaddr=destrow*scalev;	
			rowdelta=spixelrowaddr&255;   
			spixelrownum=(spixelrowaddr-rowdelta)>>8;	
		} while (destrow<(VMUINT)dheight);	
 	}
 	else if ( cf == VM_GRAPHIC_COLOR_FORMAT_32 || cf == VM_GRAPHIC_COLOR_FORMAT_32_PARGB )
 	{
		do {
			for(destcol=0;destcol<(VMUINT)dwidth;destcol++)   
			{	
				spixelcoladdr=destcol*scaleh;	
				coldelta=spixelcoladdr&255;   
				spixelcolnum=(spixelcoladdr-coldelta)>>8; 

				in_data_idx = 4*spixelrownum*swidth+4*spixelcolnum;
				out_data_idx = 4*destrow*dwidth+4*destcol;

				out_data[out_data_idx] = in_data[in_data_idx];	
				out_data[out_data_idx+1] = in_data[in_data_idx+1];
				out_data[out_data_idx+2] = in_data[in_data_idx+2];
				out_data[out_data_idx+3] = in_data[in_data_idx+3];
			}	
			destrow++;
			spixelrowaddr=destrow*scalev;	
			rowdelta=spixelrowaddr&255;   
			spixelrownum=(spixelrowaddr-rowdelta)>>8;	
		} while (destrow<(VMUINT)dheight);	
 	}
 	else
 	{
		return VM_GDI_ERR_WRONG_PARAM;
 	}
			
	return VM_GDI_SUCCEED;
}


static void set_layer_table_internal(VMINT handle,VMINT x, VMINT y, VMINT width, VMINT height, VMINT trans_color_enable, gdi_color trans_color, VMINT alldelete, VMINT cf)
{
	gdi_color_format color_format;
	vm_graphic_color_famat lcf = VM_GRAPHIC_COLOR_FORMAT_END;

	layer_trans_tbl[handle].x = x;
	layer_trans_tbl[handle].y = y;
	layer_trans_tbl[handle].width = width;
	layer_trans_tbl[handle].height = height;
	layer_trans_tbl[handle].all_delete= alldelete;
	layer_trans_tbl[handle].trans_color_enable = trans_color_enable;
	layer_trans_tbl[handle].trans_color = trans_color;	
	gdi_layer_push_and_set_active(SAL_HANDLE(handle));
	if (layer_trans_tbl[handle].trans_color_enable == TRUE) 
		gdi_layer_set_source_key(TRUE, layer_trans_tbl[handle].trans_color);
	else
		gdi_layer_set_source_key(FALSE, 0);
	gdi_layer_pop_and_restore_active();
	layer_trans_tbl[handle].used = TRUE;
	
	if (cf == VM_GRAPHIC_COLOR_FORMAT_END)
	{
		gdi_layer_get_color_format(&color_format);
		if ( convert_to_mre_color_format(color_format, &lcf) != VM_GDI_SUCCEED )
			MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_SLTI_CF_NOT_SUPPORTED, color_format);
		layer_trans_tbl[handle].cf = lcf;	
	}
	else
	{
		layer_trans_tbl[handle].cf = cf;	
	}	
}


static VM_GDI_HANDLE set_layer_table(gdi_handle hdl, VMINT x, VMINT y, VMINT width, VMINT height, VMINT trans_color_enable, gdi_color trans_color, VMINT alldelete, VMINT cf, VMINT is_double_buffer)
{
	VMUINT8* buf = NULL;
	VMUINT8* buf1 = NULL;	
	VMINT handle = 0;

	if ((handle = find_empty_node_in_layer_table())< 0)
	{
		MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_SLT_NO_EMPTY_NODE);
		return VM_GDI_FAILED;
	}
	
	layer_trans_tbl[handle].handle = hdl;
	
	gdi_layer_push_and_set_active(hdl);
	gdi_layer_get_buffer_ptr(&buf);
	if (is_double_buffer)
	{
		gdi_layer_toggle_double();
		gdi_layer_get_buffer_ptr(&buf1);
		gdi_layer_toggle_double();
	}	
	gdi_layer_pop_and_restore_active();
	layer_trans_tbl[handle].buffer = buf;
	if (is_double_buffer)
	{
		layer_trans_tbl[handle].buffer1 = buf1;
	}

	layer_trans_tbl[handle].buffer_size = ((gdi_layer_struct *)hdl)->layer_size;
	
	if ((layer_trans_tbl[handle].mibrhandle = vm_graphic_mibr_save_layer()) < 0)
	{
		MMI_TRACE(MMI_MRE_TRC_INFO, TRC_MRE_VMGRAPH_SLT_MHANDLE_FAIL, layer_trans_tbl[handle].mibrhandle);	
		return layer_trans_tbl[handle].mibrhandle;
	}
	
	set_layer_table_internal(handle, x, y, width, height, trans_color_enable, trans_color, alldelete, cf);
	layer_count++;	

	MMI_TRACE(MMI_MRE_TRC_INFO, TRC_MRE_VMGRAPH_SLT_INFO_1, handle, layer_count);
    MMI_TRACE(MMI_MRE_TRC_INFO, TRC_MRE_VMGRAPH_SLT_INFO_2, layer_trans_tbl[handle].handle, layer_trans_tbl[handle].mibrhandle);

	return handle;
}


static VM_GDI_RESULT set_layer_table_existed(VMINT handle,VMINT x, VMINT y, VMINT width, VMINT height, VMINT trans_color_enable, gdi_color trans_color, VMINT alldelete, VMINT cf)
{
	if (INVALID_MRE_HANDLE(handle))
	{
		MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_SLTE_INVALID_HANDLE, handle);	
		return VM_GDI_FAILED;
	}
	
	set_layer_table_internal(handle, x, y, width, height, trans_color_enable, trans_color, alldelete, cf);
	
    MMI_TRACE(MMI_MRE_TRC_INFO, TRC_MRE_VMGRAPH_SLTE_INFO_1, handle, layer_count);
    MMI_TRACE(MMI_MRE_TRC_INFO, TRC_MRE_VMGRAPH_SLTE_INFO_2, layer_trans_tbl[handle].handle, layer_trans_tbl[handle].mibrhandle);

	return VM_GDI_SUCCEED;
}


VM_GDI_RESULT calculate_datasize_from_cf(vm_graphic_color_famat cf, VMINT width, VMINT height, VMINT *datasize)
{
	switch (cf) 
	{
		case VM_GRAPHIC_COLOR_FORMAT_16:
			*datasize = width * height;	
			*datasize += 3;
			*datasize &= ~3;
			*datasize = *datasize * 2;
			break;
		case VM_GRAPHIC_COLOR_FORMAT_24:
			*datasize = width * height;	
			*datasize += 3;
			*datasize &= ~3;
			*datasize = *datasize * 3;
			break;
		case VM_GRAPHIC_COLOR_FORMAT_32:
		case VM_GRAPHIC_COLOR_FORMAT_32_PARGB:
			*datasize = width * height * 4;
			break;		
		default:
			MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_1076 , cf);
			return VM_GDI_ERR_WRONG_PARAM;
	}	

	return VM_GDI_SUCCEED;
}


VMINT layer_operation_permission_check(void)
{
	if (vm_pmng_state(VM_PMNG_CUR_HANDLE) == VM_PMNG_BACKGROUND
		|| vm_pmng_state(VM_PMNG_CUR_HANDLE) == VM_PMNG_INACTIVE)
    {
    }
    else if (vm_pmng_state(VM_PMNG_CUR_HANDLE) != VM_PMNG_FOREGROUND)
    { 
        MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_1092 );
        return VM_GDI_MIBR_NOT_FORE;
    }	
    else
    {
    }

	return 0;
}


static VM_GDI_HANDLE vm_graphic_sal_set_base_layer(VMINT x, VMINT y, VMINT width, VMINT height, VMINT trans_color_enable, gdi_color trans_color)
{
	gdi_handle hdl;
	VMINT handle;
	
	if (is_base_layer >= 0)
	{
        MMI_TRACE(MMI_MRE_TRC_INFO, TRC_MRE_VMGRAPH_SSBL_BL_EXISTED, is_base_layer);
		set_layer_table_existed(is_base_layer,x,y,width,height,trans_color_enable,trans_color,FALSE,VM_GRAPHIC_COLOR_FORMAT_END);
		return is_base_layer;
	}

	if (gdi_layer_get_base_handle(&hdl) == GDI_SUCCEED)
	{
		if ((handle = set_layer_table(hdl,x,y,width,height,trans_color_enable,trans_color,FALSE,VM_GRAPHIC_COLOR_FORMAT_END,FALSE)) >= 0)
		{
			is_base_layer = handle;
			return handle;
		}
	}

	return VM_GDI_FAILED;
}

static VM_GDI_HANDLE vm_graphic_sal_set_fast_layer(VMINT x, VMINT y, VMINT width, VMINT height, VMINT trans_color_enable, gdi_color trans_color)
{
	gdi_handle hdl;
	VMINT handle;
	VMINT ret;
	
	if (layer_count > MAX_LAYER -1)
	{
        MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_SSFL_LAYER_LIMIT);
		return VM_GDI_FAILED;	
	}
	
	if (is_fast_layer >= 0)
	{
        MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_SSFL_FL_EXISTED, is_fast_layer);
		set_layer_table_existed(is_fast_layer,x,y,width,height,trans_color_enable,trans_color,FALSE,VM_GRAPHIC_COLOR_FORMAT_END);
		return is_fast_layer;
	}	
	
	if ((ret = gdi_layer_create(x, y, width, height, &hdl)) == GDI_SUCCEED)
	{
		if ((handle = set_layer_table(hdl,x,y,width,height,trans_color_enable,trans_color,FALSE,VM_GRAPHIC_COLOR_FORMAT_END,FALSE)) >= 0)
		{
			is_fast_layer = handle;
			return handle;
		}
	}
	else
	{
        MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_SSFL_FAIL, ret);
	}
	
	return VM_GDI_FAILED;
}


static VM_GDI_RESULT vm_graphic_sal_release_base_layer(gdi_handle salhandle)
{
	//Clear transcolor and opacity;Coordinate on (0,0);Reset rotate value;Resize width and height.
	gdi_layer_push_and_set_active(salhandle);
	gdi_layer_set_opacity(FALSE, 0);
    gdi_layer_set_position(0, 0);
    gdi_layer_set_rotate(VM_GDI_ROTATE_NORMAL);
    gdi_layer_resize(vm_graphic_get_screen_width(), vm_graphic_get_screen_height());     
	gdi_layer_pop_and_restore_active();
	
	return VM_GDI_SUCCEED;
}

static VM_GDI_RESULT vm_graphic_sal_release_layer(gdi_handle salhandle)
{
	gdi_handle hdl;
	GDI_RESULT ret;
	
	gdi_layer_get_base_handle(&hdl);
	if (salhandle == hdl)
	{
        MMI_TRACE(MMI_MRE_TRC_INFO, TRC_MRE_VMGRAPH_SRL_BL);
		return vm_graphic_sal_release_base_layer(salhandle);
	}
	
	ret = gdi_layer_free(salhandle);
	if (ret != GDI_SUCCEED) 
    {
        MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_SRL_FAIL, ret);
        return VM_GDI_FAILED;	
    }
	else
	{
		// clear related blt layer if this layer is deleted
		gdi_handle layers[6] = {0, 0, 0, 0, 0, 0};	
		VMINT i, j;
		VMINT ret;

		ret = gdi_layer_get_blt_layer_ext(&layers[0], &layers[1], &layers[2], &layers[3], &layers[4], &layers[5]);
		if (ret != GDI_SUCCEED)
		{
			MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_SRL_GET_BLT_LAYER_FAIL, ret);
			return VM_GDI_FAILED;	
		}
		else
		{
			for(i = 0; i < 6; i++)
			{
				if (salhandle == layers[i])
				{
					layers[i] = 0;
					for(j = i; j < 5; j++)
					{
						layers[j] = layers[j + 1];
					}
					layers[j] = 0;
					
					ret = gdi_layer_set_blt_layer_ext(layers[0], layers[1], layers[2], layers[3], layers[4], layers[5]);
					if (ret != GDI_SUCCEED)
					{
						MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_SRL_SET_BLT_LAYER_FAIL, ret);
						return VM_GDI_FAILED;	
					}
					
					break;
				}
			}
			for(i = 0; i < 6; i++)
			{
				if (salhandle == g_vm_blt_cb.previous_blt_layers[i])
				{
					g_vm_blt_cb.previous_blt_layers[i] = 0;
					for(j = i; j < 5; j++)
					{
						g_vm_blt_cb.previous_blt_layers[j] = g_vm_blt_cb.previous_blt_layers[j + 1];
					}
					g_vm_blt_cb.previous_blt_layers[j] = 0;
					
					break;
				}
			}
		}
	}
		
	return VM_GDI_SUCCEED;
}


static VM_GDI_RESULT vm_graphic_sal_resize_layer(gdi_handle salhandle,VMINT width,VMINT height)
{
	gdi_handle cur_active_layer;
	
    MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_1197 ,salhandle,width,height);

	gdi_layer_get_active(&cur_active_layer);
	if (salhandle != cur_active_layer)
	{
		gdi_layer_push_and_set_active(salhandle);	
		gdi_layer_resize(width, height);
		gdi_layer_pop_and_restore_active();
		
		return VM_GDI_SUCCEED;
	}
	gdi_layer_resize(width, height);
	
	return VM_GDI_SUCCEED;	
}

VMINT vm_graphic_get_character_height(void) 
{
	VMINT w = 0;
	VMINT h = 0;
	vm_graphic_cb *current_cb;
		
	current_cb = vm_graphic_get_current_cb();
	if (current_cb == NULL)
		return -1;

	gui_set_font(&(current_cb->font));
    MMI_TRACE(MMI_MRE_TRC_INFO, TRC_MRE_VMGRAPH_1223 , current_cb->font.bold, current_cb->font.italic, current_cb->font.underline, current_cb->font.size, current_cb->font.color, current_cb->font.type);

	Get_StringWidthHeight((U8 *)L"AGJPYabgjkqty1°¡!", (S32 *)&w, (S32 *)&h);
    MMI_TRACE(MMI_MRE_TRC_INFO, TRC_MRE_VMGRAPH_1225 ,h);
	
	return h;
}

VMINT vm_graphic_get_character_width(VMWCHAR c) 
{
	VMINT w = 0;
	VMINT h = 0;
	vm_graphic_cb *current_cb;

	current_cb = vm_graphic_get_current_cb();
	if (current_cb == NULL)
		return -1;
		
	if(c == 0)
    {
        MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_1243 );
		return VM_GDI_ERR_WRONG_PARAM;
    }

	gui_set_font(&(current_cb->font));
    MMI_TRACE(MMI_MRE_TRC_INFO, TRC_MRE_VMGRAPH_1248 , current_cb->font.bold, current_cb->font.italic, current_cb->font.underline, current_cb->font.size, current_cb->font.color, current_cb->font.type);

	Get_CharWidthHeight((U32)c , (S32 *)(&w), (S32 *)(&h));
    MMI_TRACE(MMI_MRE_TRC_INFO, TRC_MRE_VMGRAPH_1251 ,c,w,h);
	
    return (w);
}

VMINT vm_graphic_measure_character(VMWCHAR c, VMINT *width, VMINT *height) 
{
    mmi_fe_glyph_metrics_struct matrix;
	vm_graphic_cb *current_cb;

	current_cb = vm_graphic_get_current_cb();
	if (current_cb == NULL)
		return -1;
	
	if ((width == NULL) || (height == NULL))
	{
        MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_1269 );
		return VM_GDI_ERR_WRONG_PARAM;
	}
	
	if (c == 0)
	{
		*width = 0;
		*height = 0;	   
        MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_1276 );        
		return VM_GDI_ERR_WRONG_PARAM;
	}

	gui_set_font(&(current_cb->font));
    MMI_TRACE(MMI_MRE_TRC_INFO, TRC_MRE_VMGRAPH_1280 , current_cb->font.bold, current_cb->font.italic, current_cb->font.underline, current_cb->font.size, current_cb->font.color, current_cb->font.type);

	mmi_fe_get_glyph_metrics((VMUINT16)c, &matrix);    
    MMI_TRACE(MMI_MRE_TRC_INFO, TRC_MRE_VMGRAPH_1282 ,matrix.adv_x,matrix.ascent,matrix.descent);
    if (matrix.adv_x != 0) 
    {
        *width = matrix.adv_x;
        *height= matrix.height;        
    }
    else
    {
		Get_CharWidthHeight((U32)c, (s32 *)width, (s32 *)height);
    }
    
    MMI_TRACE(MMI_MRE_TRC_INFO, TRC_MRE_VMGRAPH_1293 ,c,*width,*height);
	
	return VM_GDI_SUCCEED;
}


VMINT vm_graphic_get_character_info(VMWCHAR c, vm_graphic_char_info *char_info)
{
	mmi_fe_get_string_info_param_struct query;
	vm_graphic_cb *current_cb;
	
	current_cb = vm_graphic_get_current_cb();
	if (current_cb == NULL)
		return -1;	
		        
    if (char_info == NULL)
    {
        MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_1314 );
        return VM_GDI_ERR_WRONG_PARAM;
    }
 	if (c == 0)
	{
		char_info->width = 0;
		char_info->height = 0;
        char_info->dwidth = 0;
        char_info->ascent= 0;
        char_info->descent= 0;
        
        MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_1325 );        
		return VM_GDI_ERR_WRONG_PARAM;
	}   
	gui_set_font(&(current_cb->font));
    MMI_TRACE(MMI_MRE_TRC_INFO, TRC_MRE_VMGRAPH_1329 , current_cb->font.bold, current_cb->font.italic, current_cb->font.underline, current_cb->font.size, current_cb->font.color, current_cb->font.type);
	
    memset(&query, 0, sizeof(mmi_fe_get_string_info_param_struct));
    query.String = (U8*) &c;
    query.n = 1;
    query.enableTruncated = MMI_FALSE;
    query.w = 0;
    mmi_fe_get_string_widthheight(&query);
    char_info->dwidth = query.adv_w; 
	char_info->width  = query.pWidth;
	char_info->height = query.pHeight;

	MMI_TRACE(MMI_MRE_TRC_INFO, TRC_MRE_VMGRAPH_1340 , c,char_info->dwidth,char_info->width,char_info->height);
	
	return VM_GDI_SUCCEED;    
}

static VMINT vm_graphic_get_string_width_height(VMWSTR str, VMINT *swidth, VMINT *sheight) 
{
	vm_graphic_cb *current_cb;

	current_cb = vm_graphic_get_current_cb();
	if (current_cb == NULL)
		return -1;	
		
	if(str == NULL)
    {
		return VM_GDI_ERR_WRONG_PARAM;
    }
	
	gui_set_font(&(current_cb->font));
    MMI_TRACE(MMI_MRE_TRC_INFO, TRC_MRE_VMGRAPH_1364 , current_cb->font.bold, current_cb->font.italic, current_cb->font.underline, current_cb->font.size, current_cb->font.color, current_cb->font.type);

	gui_measure_string((UI_string_type)str, (S32 *)swidth, (S32 *)sheight);
	    
    MMI_TRACE(MMI_MRE_TRC_INFO, TRC_MRE_VMGRAPH_1368, *swidth, *sheight);
    
    return VM_GDI_SUCCEED;
}


VMINT vm_graphic_get_string_width(VMWSTR str) 
{
	VMINT swidth = 0;
	VMINT sheight = 0;
	VMINT ret;

	ret = vm_graphic_get_string_width_height(str, &swidth, &sheight);
	if ( ret == VM_GDI_SUCCEED )
		return swidth;
	else
		return ret;
}

VMINT vm_graphic_get_string_height(VMWSTR str) 
{
	VMINT swidth = 0;
	VMINT sheight = 0;
	VMINT ret;

	ret = vm_graphic_get_string_width_height(str, &swidth, &sheight);
	if ( ret == VM_GDI_SUCCEED )
		return sheight;
	else
		return ret;
}

VMINT vm_graphic_get_screen_width(void) 
{
	gdi_lcd_get_dimension(&screen_width, &screen_height);
	return screen_width;
}

VMINT vm_graphic_get_screen_height(void) 
{
	gdi_lcd_get_dimension(&screen_width, &screen_height);
	return screen_height;
}

void vm_graphic_set_font(font_size_t size) 
{
	vm_graphic_cb *current_cb;

	if (layer_operation_permission_check() < 0)		
		return;	

	current_cb = vm_graphic_get_current_cb();
	if (current_cb == NULL)
		return;	

	switch (size) 
	{
	case VM_SMALL_FONT:
        current_cb->font.size = SMALL_FONT;
		break;
	case VM_MEDIUM_FONT:
        current_cb->font.size = MEDIUM_FONT;
		break;
	case VM_LARGE_FONT:
        current_cb->font.size = LARGE_FONT;
		break;
	default:
        current_cb->font.size = MEDIUM_FONT;
		break;
	}
	gui_set_font(&(current_cb->font));
    MMI_TRACE(MMI_MRE_TRC_INFO, TRC_MRE_VMGRAPH_1438 , current_cb->font.bold, current_cb->font.italic, current_cb->font.underline, current_cb->font.size, current_cb->font.color, current_cb->font.type);	
}

void vm_reg_res_provider(VMUINT8* (*fp)(VMINT resid, VMINT* len)) 
{
	vm_graphic_cb *current_cb;

	current_cb = vm_graphic_get_current_cb();
	if (current_cb == NULL)
		return;	

	current_cb->user_get_resource_fp = fp;
}

vm_graphic_user_get_resource_fp vm_get_res_provider(void) 
{
	vm_graphic_cb *current_cb;

	current_cb = vm_graphic_get_current_cb();
	if (current_cb == NULL)
		return NULL;	

	return current_cb->user_get_resource_fp;
}

VMINT vm_graphic_get_bits_per_pixel(void) 
{
	return gdi_layer_get_bit_per_pixel();
}

VMINT vm_graphic_get_layer_count(void)
{
	return MAX_LAYER;
}

VMINT vm_graphic_get_current_layer_count(void)
{
	return layer_count;
}


VMINT vm_graphic_active_layer_internal(VMINT handle)
{
	VMINT x1,y1,x2,y2;
	vm_graphic_cb *current_cb;

	current_cb = vm_graphic_get_current_cb();
	if (current_cb == NULL)
		return VM_GDI_FAILED;	
	
	if (INVALID_MRE_HANDLE(handle))
		return VM_GDI_FAILED;

	if (handle != current_cb->active_layer)
	{
		current_cb->active_layer = handle;
		gdi_layer_set_active(layer_trans_tbl[handle].handle);
		gdi_layer_get_clip(&x1, &y1, &x2, &y2);
		vm_graphic_set_clip(x1, y1, x2, y2);
        MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_1500 ,current_cb->active_layer);
	}
	
	return VM_GDI_SUCCEED;
}

VMINT vm_graphic_active_layer(VMINT handle)
{

    if (handle_belong_to_cur_process(handle) == VM_GDI_SUCCEED)
        return vm_graphic_active_layer_internal(handle);
    else
    {
        MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_1514 ,handle);
        return VM_GDI_FAILED;
    }
}

VMINT vm_graphic_get_active_layer(void)
{
	gdi_handle handle;
	VMINT i;

	gdi_layer_get_active(&handle);
	for (i = 0; i < MAX_LAYER; i++)
	{
		if (layer_trans_tbl[i].handle == handle && layer_trans_tbl[i].used == TRUE)
			break;
	}
	if (i == MAX_LAYER)
		return -1;

    if (handle_belong_to_cur_process(i) == VM_GDI_SUCCEED)
		return i;
	else
		return -2;
}


static VM_GDI_HANDLE vm_graphic_create_layer_with_buf(
						vm_graphic_create_layer_way way,
						vm_graphic_color_famat cf, 
						VMINT x, VMINT y,
						VMINT width, VMINT height,
						VMBYTE *buf, VMINT buf_size, 
						VMUINT8 *buf1, VMINT buf_size_1, 
						gdi_color trans_color, vm_graphic_color_argb* trans_color_argb,
						VMINT alldelete)
{
	gdi_handle hdl;
	VMINT handle;
    VMINT ret = 0;
	gdi_color tcolor;		
	VMINT trans_color_enable;
	VMINT canvas_cf, canvas_datasize = 0, canvas_width, canvas_height;
	VMINT canvas1_cf, canvas1_datasize = 0, canvas1_width, canvas1_height;
	VMBYTE *canvas_buffer = NULL;
	VMBYTE *canvas1_buffer = NULL;
	gdi_color_format color_format;	
	VMUINT8* tmp_buf;
	//VMUINT8* tmp_buf1;
	VMINT tmp_buf_size, tmp_buf_size_1;
	VMINT is_double_buffer = FALSE;
		
	if ( buf == NULL)
	{
        MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_CLWF_BUF_NULL);
	    return VM_GDI_ERR_WRONG_PARAM;
    }
	
    if ( way == VM_GRAPHIC_CREATE_LAYER_EX && (!is_mre_canvas_buf(buf)) )
    {
        MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_CLWF_NOT_CANBUF, buf);        
	    return VM_GDI_ERR_WRONG_PARAM;
    }

	if ( ( convert_to_gdi_color_format(cf, &color_format) ) < 0 )
		return VM_GDI_FAILED;	

	if( is_mre_canvas_buf(buf) )
	{
		if ((handle = find_layer(buf))!= 0)
		{
			if (VALID_MRE_HANDLE(handle))
			{
				MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_1793 );
				return VM_GDI_ERR_LAYER_BIND;
			}
		}
	
		canvas_cf = get_canvas_prop(buf, VM_CANVAS_CF);
		canvas_datasize = get_canvas_prop(buf, VM_CANVAS_DATASIZE);
		canvas_width = get_canvas_prop(buf, VM_CANVAS_WIDTH);
		canvas_height = get_canvas_prop(buf, VM_CANVAS_HEIGHT);
		canvas_buffer = buf;
		if (cf != canvas_cf || width != canvas_width || height != canvas_height)
		{
			MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_1804 );
			return VM_GDI_FAILED;
		}
		
		tmp_buf = buf + CANVAS_BUF_OFFSET;
		tmp_buf_size = canvas_datasize;
	}
	else
	{		
		calculate_datasize_from_cf(cf, width, height, &tmp_buf_size);
		if (buf_size < tmp_buf_size )
		{
			MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_CLWF_SIZE_NOT_ENOUGH , width, height, buf_size);
			return VM_GDI_FAILED;	
		}	
	
		tmp_buf = buf;
		tmp_buf_size = buf_size;
	}

	if (way == VM_GRAPHIC_CREATE_LAYER_CF_DOUBLE)
	{
		if( is_mre_canvas_buf(buf1) )
		{
			if ((handle = find_layer(buf1))!= 0)
			{
				if (VALID_MRE_HANDLE(handle))
				{
					MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_CLWF_SIZE_INVALID_LHANDLE );
					return VM_GDI_ERR_LAYER_BIND;
				}
			}
		
			canvas1_cf = get_canvas_prop(buf1, VM_CANVAS_CF);
			canvas1_datasize = get_canvas_prop(buf1, VM_CANVAS_DATASIZE);
			canvas1_width = get_canvas_prop(buf1, VM_CANVAS_WIDTH);
			canvas1_height = get_canvas_prop(buf1, VM_CANVAS_HEIGHT);			
			canvas1_buffer = buf1;		
			if (cf != canvas1_cf || width != canvas1_width || height != canvas1_height)
			{
				MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_CLWF_SIZE_INCONSIST_PARAM );
				return VM_GDI_FAILED;
			}
			
			//tmp_buf1 = buf1 + CANVAS_BUF_OFFSET;
			tmp_buf_size_1 = canvas1_datasize;
		}
		else
		{
			calculate_datasize_from_cf(cf, width, height, &tmp_buf_size_1);
			if (buf_size_1 < tmp_buf_size_1 )
			{
				MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_CLWF_SIZE_1_NOT_ENOUGH , width, height, buf_size_1);
				return VM_GDI_FAILED;	
			}
		
			//tmp_buf1 = buf1;
			tmp_buf_size_1 = buf_size_1;
		}
	}

	if (way == VM_GRAPHIC_CREATE_LAYER_EX || way == VM_GRAPHIC_CREATE_LAYER_CF )
	{
		ret = gdi_layer_create_cf_using_outside_memory(color_format, x, y, width, height, &hdl, tmp_buf, tmp_buf_size);
	}
	else if (way == VM_GRAPHIC_CREATE_LAYER_CF_DOUBLE)
	{
		ret = gdi_layer_create_cf_double_using_outside_memory(color_format, x, y, width, height, &hdl, 
					canvas_buffer + CANVAS_BUF_OFFSET, canvas_datasize,
					canvas1_buffer + CANVAS_BUF_OFFSET, canvas1_datasize);
	}	
	else
	{}
	
	if (ret == GDI_SUCCEED)
	{
		if (way == VM_GRAPHIC_CREATE_LAYER_EX)
		{
			if (trans_color == VM_NO_TRANS_COLOR)
				trans_color_enable = 0;
			else
				trans_color_enable = 1;

			tcolor = trans_color;
		}
		else
		{
			gdi_layer_push_and_set_active(hdl);
			if (trans_color_argb == NULL)
			{
				trans_color_enable = 0;
				tcolor = 0;
			}
			else
			{
				trans_color_enable = 1;
				tcolor = gdi_act_color_from_rgb(255, trans_color_argb->r, trans_color_argb->g, trans_color_argb->b);
			}
			gdi_layer_pop_and_restore_active();
		}

		if (way == VM_GRAPHIC_CREATE_LAYER_CF_DOUBLE)
			is_double_buffer = TRUE;
		
		if ((handle = set_layer_table(hdl, x, y, width, height, trans_color_enable, tcolor, alldelete, cf, is_double_buffer)) >= 0)
		{
			save_canvas_to_layer(handle, canvas_buffer, canvas1_buffer);
			if (canvas_buffer != NULL)
				save_layer_to_canvas(handle, canvas_buffer);			
			if (canvas1_buffer != NULL)
				save_layer_to_canvas(handle, canvas1_buffer);			
			return handle;
		}
		else
		{
			MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_1822 , handle);
			return VM_GDI_FAILED;
		}
	}
	else
	{
		MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_1828 , ret);
		return VM_GDI_ERR_CREATE_LAYER_FAILED;
	}
}

static VM_GDI_HANDLE  vm_graphic_create_canvas_and_layer(
						vm_graphic_create_layer_way way,
						vm_graphic_color_famat cf, 
						VMINT x, VMINT y,
						VMINT width, VMINT height,
						gdi_color trans_color, vm_graphic_color_argb* trans_color_argb
						)
{
	VMINT canvas_handle, canvas1_handle;
	VMBYTE *canvas_buffer = NULL;
	VMBYTE *canvas1_buffer = NULL;
	VMINT canvas_datasize = 0;
	VMINT canvas1_datasize = 0;
	
	if ((canvas_handle = vm_graphic_create_canvas_cf(cf, width, height)) < 0)
	{
		MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_CCAL_CREATE_CANVAS_FAIL , canvas_handle);
		return VM_GDI_ERR_CREATE_CANVAS_FAILED;
	}
	canvas_buffer = vm_graphic_get_canvas_buffer(canvas_handle);		
	canvas_datasize = get_canvas_prop(canvas_buffer, VM_CANVAS_DATASIZE);

	if (way == VM_GRAPHIC_CREATE_LAYER_CF_DOUBLE)
	{
		if ((canvas1_handle = vm_graphic_create_canvas_cf(cf, width, height)) < 0)
		{
			vm_graphic_release_canvas(canvas_handle);
			MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_CCAL_CREATE_CANVAS_1_FAIL , canvas1_handle);		 
			return VM_GDI_ERR_CREATE_CANVAS_FAILED;
		}
		canvas1_buffer = vm_graphic_get_canvas_buffer(canvas1_handle);		
		canvas1_datasize = get_canvas_prop(canvas1_buffer, VM_CANVAS_DATASIZE);
	}
		
	return vm_graphic_create_layer_with_buf(way, cf, 
						x, y,
						width, height,
						canvas_buffer, canvas_datasize,
						canvas1_buffer, canvas1_datasize,
						trans_color, trans_color_argb,
						TRUE);
}


static VM_GDI_HANDLE _vm_graphic_create_layer(vm_graphic_create_layer_way way,
						vm_graphic_color_famat cf, 
						VMINT x, VMINT y, 
						VMINT width, VMINT height, 
						VMINT trans_color, vm_graphic_color_argb* trans_color_argb,
						VMINT mode, 
						VMUINT8 *buf, VMINT buf_size, 
						VMUINT8 *buf1, VMINT buf_size_1)
{
	VM_PROCESS_STATUS process_state = vm_pmng_state(VM_PMNG_CUR_HANDLE);
	VMINT trans_color_enable = FALSE;
	VMINT ret = VM_GDI_FAILED;

	// process state permission check
	if ( !( ( process_state == VM_PMNG_FOREGROUND ) || 
				( ( process_state == VM_PMNG_BACKGROUND || process_state == VM_PMNG_INACTIVE ) && 
				( mode == VM_BUF || mode == VM_CREATE_CANVAS ) && 
				( way != VM_GRAPHIC_CREATE_LAYER ) ) ) )
	{
        MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_CL_EX_PROHIBIT);
        return VM_GDI_MIBR_NOT_FORE;
	}

	// camera related - special part
	if ( way == VM_GRAPHIC_CREATE_LAYER )
	{
#ifdef MRE_SUPPORT_CAMERA_FEATURE
		if (vm_is_open_camera_flush_screen_patten())
			return VM_GDI_FAILED;
#endif
	}

	// mode check	
	if ( way == VM_GRAPHIC_CREATE_LAYER_CF || way == VM_GRAPHIC_CREATE_LAYER_CF_DOUBLE )
	{
		if ((mode == VM_BASE_LAYER) || (mode == VM_FAST_LAYER))
		{
			MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_1747 );		   
			return VM_GDI_FAILED;
		}
	}
	
	// layer check
	if ( way == VM_GRAPHIC_CREATE_LAYER )
	{
	    if ((is_base_layer>=0) && (is_fast_layer>=0))
	    {
	        MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_CL_LAYER_EXISTED, is_base_layer, is_fast_layer);
	        return VM_GDI_FAILED; 
	    }
	}
	else
	{
		if ( (vm_pmng_state(VM_PMNG_CUR_HANDLE) == VM_PMNG_FOREGROUND) && 
				(mode != VM_BASE_LAYER) && (is_base_layer < 0) )
		{ 
			MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_CL_EX_BL_NOT_EXISTED, is_base_layer);	  
			return VM_GDI_ERR_BASE_LAYER_NOT_EXIST; 
		}	
		
		if (vm_res_type_avaliable_handle(VM_RES_TYPE_LAYER_HANDLE, vm_pmng_get_app_handle()) <=0)
		{
			MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_CL_EX_NO_HANDLE);			  
			return VM_GDI_MIBR_NO_RES;
		}
	}
	
	if (layer_count > MAX_LAYER -1)
    {
        MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_1759 );        
		return VM_GDI_FAILED;	
    }
	
	// parameter check
	if ((width <= 0) || (height <= 0) || (width > MAX_LAYER_WIDTH) || (height > MAX_LAYER_HEIGHT))
    {
        MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_CL_EX_INVALID_PARA_1);
        return VM_GDI_ERR_WRONG_PARAM;
    }
	
    if ((mode == VM_BASE_LAYER) || (mode == VM_FAST_LAYER))
    {
		if ((x < 0 ) || (y < 0) ||
				(x >= vm_graphic_get_screen_width() ) ||
				(y >= vm_graphic_get_screen_height()) )
		{
			MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_CL_INVALID_PARA );
			return VM_GDI_ERR_WRONG_PARAM;
		}
			
		if (x + width > vm_graphic_get_screen_width())
			width = vm_graphic_get_screen_width() - x;
		if (y + height > vm_graphic_get_screen_height())
			height = vm_graphic_get_screen_height() - y;
    }

	// trans color for base layer and fast layer
	if (mode == VM_BASE_LAYER || mode == VM_FAST_LAYER)
	{
		if (trans_color == VM_NO_TRANS_COLOR)
			trans_color_enable = FALSE;
		else
			trans_color_enable = TRUE;
	}
	
	// create layer
	switch(mode)
	{
		case VM_BASE_LAYER:
			ret = vm_graphic_sal_set_base_layer(x, y, width, height, trans_color_enable, trans_color);
			break;
		case VM_FAST_LAYER:
			ret = vm_graphic_sal_set_fast_layer(x, y, width, height, trans_color_enable, trans_color);
			break;
		case VM_BUF:
			ret = vm_graphic_create_layer_with_buf(way, cf, x, y, width, height, buf, buf_size, buf1, buf_size_1, trans_color, trans_color_argb, FALSE);
			break;
		case VM_CREATE_CANVAS:
			ret = vm_graphic_create_canvas_and_layer(way, cf, x, y, width, height, trans_color, trans_color_argb);
			break;			
		default:
			ret = VM_GDI_ERR_WRONG_PARAM;
			break;	
	}

	MMI_TRACE(MMI_MRE_TRC_INFO, TRC_MRE_VMGRAPH_CL_EX_INFO, mode, ret, layer_count);

	return ret;
}

VM_GDI_HANDLE vm_graphic_create_layer(VMINT x, VMINT y, VMINT width, VMINT height, VMINT trans_color)
{
	VMINT mode;

	if (is_base_layer < 0) 
	{
		mode = VM_BASE_LAYER;
	}
	else if (is_fast_layer < 0) 
	{
		mode = VM_FAST_LAYER;
	}
	else
	{
		MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_CL_LAYER_EXISTED, is_base_layer, is_fast_layer); 
		return VM_GDI_FAILED;
	}

	return _vm_graphic_create_layer(VM_GRAPHIC_CREATE_LAYER,
							VM_GRAPHIC_COLOR_FORMAT_16, 
							x, y, 
							width, height, 
							trans_color, NULL,
							mode, 
							NULL, 0, 
							NULL, 0);
}

VM_GDI_HANDLE vm_graphic_create_layer_ex(VMINT x, VMINT y, VMINT width, VMINT height, VMINT trans_color,VMINT mode,VMUINT8 * buf)
{
	return _vm_graphic_create_layer(VM_GRAPHIC_CREATE_LAYER_EX,
							VM_GRAPHIC_COLOR_FORMAT_16, 
							x, y, 
							width, height, 
							trans_color, NULL,
							mode, 
							buf, 0, 
							NULL, 0);
}

VM_GDI_HANDLE vm_graphic_create_layer_cf(vm_graphic_color_famat cf, VMINT x, VMINT y, VMINT width, VMINT height, vm_graphic_color_argb* trans_color, VMINT mode, VMUINT8 *buf, VMINT buf_size)
{
	return _vm_graphic_create_layer(VM_GRAPHIC_CREATE_LAYER_CF,
							cf, 
							x, y, 
							width, height, 
							VM_NO_TRANS_COLOR, trans_color,
							mode, 
							buf, buf_size, 
							NULL, 0);
}

VM_GDI_HANDLE vm_graphic_create_layer_cf_double(vm_graphic_color_famat cf, VMINT x, VMINT y, VMINT width, VMINT height, vm_graphic_color_argb* trans_color, VMINT mode, VMUINT8 *buf, VMINT buf_size, VMUINT8 *buf1, VMINT buf_size_1)
{
	return _vm_graphic_create_layer(VM_GRAPHIC_CREATE_LAYER_CF_DOUBLE,
							cf, 
							x, y, 
							width, height, 
							VM_NO_TRANS_COLOR, trans_color,
							mode, 
							buf, buf_size, 
							buf1, buf_size_1);
}

VM_GDI_RESULT vm_graphic_layer_toggle_double(VMINT handle)
{
	gdi_handle cur_active_layer;
    VMUINT8* tmp;		
	VMINT ret;

	if (INVALID_MRE_HANDLE(handle))
		return -1;	

	gdi_layer_get_active(&cur_active_layer);
	if (SAL_HANDLE(handle) != cur_active_layer)
	{
		gdi_layer_push_and_set_active(SAL_HANDLE(handle));	
		ret = gdi_layer_toggle_double();
		gdi_layer_pop_and_restore_active();
	}
	else
	{
		ret = gdi_layer_toggle_double();
	}	

	tmp = layer_trans_tbl[handle].buffer;
	layer_trans_tbl[handle].buffer = layer_trans_tbl[handle].buffer1;
	layer_trans_tbl[handle].buffer1 = tmp;

	return ret;
}	


VM_GDI_RESULT  vm_graphic_release_canvas_ex(VMINT hcanvas)
{
	VMINT layerhandle;
    
	if (hcanvas<=0)
    {
        MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_1912 );
		return VM_GDI_ERR_WRONG_PARAM;
    }
	
	layerhandle =  find_layer((VMUINT8*)hcanvas);
	if (layerhandle < 0)
    {   
    
        MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_1919 );        
		return VM_GDI_FAILED;
	}

	if (vm_graphic_delete_layer(layerhandle) < 0)
    {
    
        MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_1925 );        
		return VM_GDI_ERR_FREE_RES;
	}

	vm_graphic_release_canvas(hcanvas);

	return VM_GDI_SUCCEED;
}


VM_GDI_RESULT  vm_graphic_delete_layer_internal(VMINT handle)
{
	VMINT result;
	VMINT canvas;
	vm_graphic_cb *current_cb;

	current_cb = vm_graphic_get_current_cb();
	if (current_cb == NULL)
	{
		MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_DLI_NO_CUR_CB);	
		return VM_GDI_FAILED;	
	}
	
    MMI_TRACE(MMI_MRE_TRC_INFO, TRC_MRE_VMGRAPH_DLI_BEGIN, handle, is_base_layer, layer_count);
	
	if (INVALID_MRE_HANDLE(handle))
    {
        MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_DLI_INVALID_HANDLE, handle);
		return VM_GDI_ERR_WRONG_PARAM;	
    }
	
	//before delete base layer, delete other layers
	if ((handle == is_base_layer) && (layer_count > 1))
    {   
		MMI_TRACE(MMI_MRE_TRC_INFO, TRC_MRE_VMGRAPH_DLI_SEQ_FAIL );
        return VM_GDI_FAILED;
    }

	//if to be deleted layer is current layer , should active first layer
	//if (handle == active_layer)
	//{
	//	vm_graphic_active_layer_internal((is_base_layer >= 0) ? is_base_layer : 0);
	//	vm_graphic_set_layer_clip(active_layer,0, 0, vm_graphic_get_screen_width(), vm_graphic_get_screen_height());
	//}

	if (handle == current_cb->active_layer)
	{
		MMI_TRACE(MMI_MRE_TRC_INFO, TRC_MRE_VMGRAPH_DLI_IS_ACT_LAYER);
	
		if (handle_belong_to_cur_process(is_base_layer) == VM_GDI_SUCCEED)	
		{
			MMI_TRACE(MMI_MRE_TRC_INFO, TRC_MRE_VMGRAPH_DLI_ACTIVE_BL);		
			vm_graphic_active_layer_internal(is_base_layer);
			vm_graphic_set_layer_clip(is_base_layer,0, 0, vm_graphic_get_screen_width(), vm_graphic_get_screen_height());
		}
	}
	
	result = vm_graphic_sal_release_layer(SAL_HANDLE(handle));
	//if delete success, should free MIBR resource ,set related vriable
	if (result >= 0)
	{
		VMINT ret;
		if ((canvas = find_canvas(handle)) > 0)
		{
			if (layer_trans_tbl[handle].all_delete)
				vm_graphic_release_canvas(canvas);
			else
				delete_layer_from_canvas((VMUINT8 *) canvas);
		}
		
		layer_count--;
		ret = vm_graphic_mibr_release_layer(layer_trans_tbl[handle].mibrhandle);
		if (ret < 0)
			MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_DLI_MIBR_RL_FAIL, ret, layer_trans_tbl[handle].mibrhandle); 	
		layer_trans_tbl[handle].used = FALSE;

    	memset(&layer_trans_tbl[handle],0,sizeof(layer_param_t));		
    	layer_trans_tbl[handle].trans_color_enable = FALSE;
    	layer_trans_tbl[handle].trans_color = 0;
    	layer_trans_tbl[handle].mibrhandle= -1;

    	if (handle ==  is_base_layer )
		    is_base_layer = -1;
	    if (handle ==  is_fast_layer )
    		is_fast_layer = -1;			
	}
	else
	{
		MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_DLI_FAIL, result); 	
	}
    	
	return result;
}


VM_GDI_RESULT  vm_graphic_delete_layer(VMINT handle)
{
	if (INVALID_MRE_HANDLE(handle))
    {
        MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_DL_INVALID_HANDLE, handle);	
		return VM_GDI_ERR_WRONG_PARAM;
    }
	
	if (handle_belong_to_cur_process(handle) < 0)
    {
        MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_DL_NOT_FOR_CUR_PROCESS, handle);
		return VM_GDI_MIBR_RES_ERR;
    }
	
    gdi_waiting_blt_finish();

	return vm_graphic_delete_layer_internal(handle);
}

void vm_graphic_flatten_previous_blt_layer_to_base_layer(void)
{
	gdi_handle layers[6] = {0, 0, 0, 0, 0, 0};
	VMINT ret;
	gdi_handle base_layer;
	
	
	gdi_layer_get_base_handle(&base_layer);

	ret = gdi_layer_get_blt_layer_ext(&layers[0], &layers[1], &layers[2], &layers[3], &layers[4], &layers[5]);
	if (ret != GDI_SUCCEED)
	{
		//MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_SRL_GET_BLT_LAYER_FAIL, ret);
	}
	
	if ((layers[0] + layers[1] + layers[2] + layers[3] + layers[4] + layers[5])== 0 )
	{
		//MMI_TRACE
	}
	else
	{
		gdi_waiting_blt_finish();
		
		if ( layers[0] != 0 && layers[0] == g_vm_blt_cb.async_blt_layer && g_vm_blt_cb.async_blt_way == VM_GRAPHIC_FLUSH_WAY_DOUBLE_EX_BUFFER )
		{
			gdi_layer_push_and_set_active(g_vm_blt_cb.async_blt_layer);
			ret = gdi_layer_toggle_double();
			gdi_layer_pop_and_restore_active();
		}
		
		gdi_layer_push_and_set_active(base_layer);
		//gdi_layer_get_source_key(&base_layer_trans_color_enable, &base_layer_trans_color);
		//gdi_layer_set_source_key(FALSE, 0); 
		gdi_layer_reset_clip();
		//gdi_push_and_set_alpha_blending_source_layer(NULL);
		ret = gdi_layer_flatten_with_clipping_ext(base_layer, layers[0], layers[1], layers[2], layers[3], 0);		
		if (ret != GDI_SUCCEED)
		{
			//MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_ABLT_FLUSH_FLATTEN_FAIL, ret);
		}
		//gdi_pop_and_restore_alpha_blending_source_layer();
		//gdi_layer_set_source_key(base_layer_trans_color_enable, base_layer_trans_color);
		gdi_layer_pop_and_restore_active();
	}
}


void vm_graphic_async_blt_reset(void)
{
	VMINT i;

	g_vm_blt_cb.async_blt_layer = 0;
	g_vm_blt_cb.async_blt_way = VM_GRAPHIC_FLUSH_WAY_NON_EX_BUFFER;
	g_vm_blt_cb.async_blt_buffer_A = NULL;
	g_vm_blt_cb.async_blt_buffer_B = NULL;
	g_vm_blt_cb.async_blt_buffer_A_size = 0;
	g_vm_blt_cb.async_blt_buffer_B_size = 0;	
	g_vm_blt_cb.is_first_blt_flag = 0;
	for (i = 0; i < 6; i++) 
	{
		g_vm_blt_cb.previous_blt_layers[i] = 0;
	}
}

static void vm_graphic_clean_freed_blt_layer(gdi_handle handle)
{
	// clear related blt layer if this layer is deleted
	gdi_handle layers[6] = {0, 0, 0, 0, 0, 0};	
	VMINT ret;

	ret = gdi_layer_get_blt_layer_ext(&layers[0], &layers[1], &layers[2], &layers[3], &layers[4], &layers[5]);
	if (ret != GDI_SUCCEED)
	{
		//MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_SRL_GET_BLT_LAYER_FAIL, ret);
	}
	else
	{
		if (handle == layers[0])
		{
			ret = gdi_layer_set_blt_layer_ext(
										g_vm_blt_cb.previous_blt_layers[0], 
										g_vm_blt_cb.previous_blt_layers[1], 
										g_vm_blt_cb.previous_blt_layers[2], 
										g_vm_blt_cb.previous_blt_layers[3], 
										g_vm_blt_cb.previous_blt_layers[4], 
										g_vm_blt_cb.previous_blt_layers[5]);
			if (ret != GDI_SUCCEED)
			{
				//MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_SRL_SET_BLT_LAYER_FAIL, ret);
			}
		}
	}
}

#if !defined(__MMI_SCREEN_SWITCH_EFFECT__) || defined(__MMI_REDUCED_UI_BUFFER__)
static void vm_graphic_async_blt_asm_cache_free_cb(void *mem_ptr)
{
	GDI_RESULT ret;

	MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_ABLT_ASM_CACHE_FREE_CB_BEGIN, g_vm_blt_cb.async_blt_way, mem_ptr, g_vm_blt_cb.async_blt_buffer_A, g_vm_blt_cb.async_blt_buffer_B);

	BEGIN_PROTECT_ASYNC_BLT

	if (g_vm_blt_cb.async_blt_way == VM_GRAPHIC_FLUSH_WAY_DOUBLE_EX_BUFFER)
	{	
		gdi_waiting_blt_finish();

		if (mem_ptr == g_vm_blt_cb.async_blt_buffer_A)
		{
			//applib_mem_ap_cache_free(g_vm_blt_cb.async_blt_buffer_A);
			g_vm_blt_cb.async_blt_buffer_A = g_vm_blt_cb.async_blt_buffer_B;
			g_vm_blt_cb.async_blt_buffer_A_size = g_vm_blt_cb.async_blt_buffer_B_size;
			g_vm_blt_cb.async_blt_buffer_B = NULL;
			g_vm_blt_cb.async_blt_buffer_B_size = 0;
		}
		else if (mem_ptr == g_vm_blt_cb.async_blt_buffer_B)
		{
			//applib_mem_ap_cache_free(g_vm_blt_cb.async_blt_buffer_B);
			g_vm_blt_cb.async_blt_buffer_B = NULL;
			g_vm_blt_cb.async_blt_buffer_B_size = 0;
		}
		else
		{}
		
		ret = gdi_layer_free(g_vm_blt_cb.async_blt_layer);
		if (ret == GDI_SUCCEED)
		{
			vm_graphic_clean_freed_blt_layer(g_vm_blt_cb.async_blt_layer);
		}
		else
		{
			// MMI_TRACE
		}
		
		ret = gdi_layer_create_cf_using_outside_memory(
							GDI_LCD->cf, 
							0,
							0, 
							vm_graphic_get_screen_width(), 
							vm_graphic_get_screen_height(),
							&(g_vm_blt_cb.async_blt_layer), 
							g_vm_blt_cb.async_blt_buffer_A,
							g_vm_blt_cb.async_blt_buffer_A_size);
		if (ret == GDI_SUCCEED)
		{
			g_vm_blt_cb.async_blt_way = VM_GRAPHIC_FLUSH_WAY_SINGLE_EX_BUFFER;
		}
		else
		{
			applib_mem_ap_cache_free(g_vm_blt_cb.async_blt_buffer_A);
			vm_graphic_async_blt_reset();
			MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_ABLT_ASM_CACHE_FREE_CB_CREATE_LAYER_FAIL, ret);
		}
	}
	else if (g_vm_blt_cb.async_blt_way == VM_GRAPHIC_FLUSH_WAY_SINGLE_EX_BUFFER)
	{
		gdi_waiting_blt_finish();
	
		if (mem_ptr == g_vm_blt_cb.async_blt_buffer_A)
		{
			//applib_mem_ap_cache_free(g_vm_blt_cb.async_blt_buffer_A);	
			g_vm_blt_cb.async_blt_buffer_A = NULL;
			g_vm_blt_cb.async_blt_buffer_A_size = 0;
		}
		else if (mem_ptr == g_vm_blt_cb.async_blt_buffer_B)
		{
			//applib_mem_ap_cache_free(g_vm_blt_cb.async_blt_buffer_B);
			g_vm_blt_cb.async_blt_buffer_B = NULL;
			g_vm_blt_cb.async_blt_buffer_B_size = 0;
		}
		else
		{}

		vm_graphic_async_blt_reset();
	}
	else
	{}	

	END_PROTECT_ASYNC_BLT

	MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_ABLT_ASM_CACHE_FREE_CB_END, g_vm_blt_cb.async_blt_way, g_vm_blt_cb.async_blt_buffer_A, g_vm_blt_cb.async_blt_buffer_B);
}
#endif

static void vm_graphic_async_blt_exit(void)
{
	GDI_RESULT ret;
	
	MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_ABLT_EXIT, g_vm_blt_cb.async_blt_layer, g_vm_blt_cb.async_blt_way, g_vm_blt_cb.async_blt_buffer_A, g_vm_blt_cb.async_blt_buffer_B);

#if !defined(__MMI_SCREEN_SWITCH_EFFECT__) || defined(__MMI_REDUCED_UI_BUFFER__)		
	BEGIN_PROTECT_ASYNC_BLT
#endif			

	gdi_waiting_blt_finish();

	if (g_vm_blt_cb.async_blt_layer > 0)
	{
		ret = gdi_layer_free(g_vm_blt_cb.async_blt_layer);
		if (ret == GDI_SUCCEED)
		{
			vm_graphic_clean_freed_blt_layer(g_vm_blt_cb.async_blt_layer);
		}
		else
		{
			// MMI_TRACE
		}
	}
	
#if !defined(__MMI_SCREEN_SWITCH_EFFECT__) || defined(__MMI_REDUCED_UI_BUFFER__)
	if (g_vm_blt_cb.async_blt_buffer_A != NULL)
		applib_mem_ap_cache_free(g_vm_blt_cb.async_blt_buffer_A);
	if (g_vm_blt_cb.async_blt_buffer_B != NULL)	
		applib_mem_ap_cache_free(g_vm_blt_cb.async_blt_buffer_B);
#endif

	vm_graphic_async_blt_reset();

#if !defined(__MMI_SCREEN_SWITCH_EFFECT__) || defined(__MMI_REDUCED_UI_BUFFER__)		
	END_PROTECT_ASYNC_BLT
#endif			

}

static void vm_graphic_async_blt_init(void)
{
	GDI_RESULT ret;
  VMINT size;
	MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_ABLT_INIT_BEGIN, g_vm_blt_cb.async_blt_layer, g_vm_blt_cb.async_blt_way, g_vm_blt_cb.async_blt_buffer_A, g_vm_blt_cb.async_blt_buffer_B);

	//MMI_ASSERT(g_vm_blt_cb.async_blt_layer == 0);
	vm_graphic_async_blt_exit();

#if defined(__MMI_SCREEN_SWITCH_EFFECT__) && !defined(__MMI_REDUCED_UI_BUFFER__)
	g_vm_blt_cb.async_blt_buffer_A = (U8 *)ui_buffer_get_start_addr(UI_BUFFER_ID_GUI_SSE_BUF_A);
	g_vm_blt_cb.async_blt_buffer_A_size = ui_buffer_get_size(UI_BUFFER_ID_GUI_SSE_BUF_A);
	g_vm_blt_cb.async_blt_buffer_B = (U8 *)ui_buffer_get_start_addr(UI_BUFFER_ID_GUI_SSE_BUF_B);
	g_vm_blt_cb.async_blt_buffer_B_size = ui_buffer_get_size(UI_BUFFER_ID_GUI_SSE_BUF_B);

	ret = gdi_layer_create_cf_double_using_outside_memory(
				GDI_LCD->cf, 
				0,
				0, 
				vm_graphic_get_screen_width(), 
				vm_graphic_get_screen_height(),
				&(g_vm_blt_cb.async_blt_layer), 
				g_vm_blt_cb.async_blt_buffer_A,
				g_vm_blt_cb.async_blt_buffer_A_size,
				g_vm_blt_cb.async_blt_buffer_B,
				g_vm_blt_cb.async_blt_buffer_B_size);
	if (ret == GDI_SUCCEED)
	{
		g_vm_blt_cb.async_blt_way = VM_GRAPHIC_FLUSH_WAY_DOUBLE_EX_BUFFER;
		g_vm_blt_cb.is_first_blt_flag = 1;
		MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_ABLT_INIT_CREATE_UI_DOUBLE_LAYER_SUCC, g_vm_blt_cb.async_blt_layer, g_vm_blt_cb.async_blt_way);						
	}
	else
	{
		vm_graphic_async_blt_reset();
		MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_ABLT_INIT_CREATE_DOUBLE_LAYER_FAIL, ret);
	}
#else

    size = gdi_sizeof_pixels(GDI_LCD->cf, vm_graphic_get_screen_width(), vm_graphic_get_screen_height());
    size += 3;
    size &= ~3;

#if !defined(__MMI_SCREEN_SWITCH_EFFECT__) || defined(__MMI_REDUCED_UI_BUFFER__)		
	BEGIN_PROTECT_ASYNC_BLT
#endif			

	g_vm_blt_cb.async_blt_buffer_A = (U8 *)applib_mem_ap_cache_alloc_nc(size, vm_graphic_async_blt_asm_cache_free_cb);
	if(g_vm_blt_cb.async_blt_buffer_A == NULL)
	{
		vm_graphic_async_blt_reset();
		MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_ABLT_INIT_ALLOC_A_BUFFER_FAIL, size);
	}
	else
	{
		g_vm_blt_cb.async_blt_buffer_A_size = size;
		g_vm_blt_cb.async_blt_buffer_B = (U8 *)applib_mem_ap_cache_alloc_nc(size, vm_graphic_async_blt_asm_cache_free_cb);
		if(g_vm_blt_cb.async_blt_buffer_B == NULL)
		{		
			MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_ABLT_INIT_ALLOC_B_BUFFER_FAIL, size);
			ret = gdi_layer_create_cf_using_outside_memory(
							GDI_LCD->cf, 
							0,
							0, 
							vm_graphic_get_screen_width(), 
							vm_graphic_get_screen_height(),
							&(g_vm_blt_cb.async_blt_layer), 
							g_vm_blt_cb.async_blt_buffer_A,
							g_vm_blt_cb.async_blt_buffer_A_size);
			if (ret == GDI_SUCCEED)
			{
				g_vm_blt_cb.async_blt_way = VM_GRAPHIC_FLUSH_WAY_SINGLE_EX_BUFFER;
				g_vm_blt_cb.is_first_blt_flag = 1;
				MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_ABLT_INIT_CREATE_ASM_SINGLE_LAYER_SUCC, g_vm_blt_cb.async_blt_layer, g_vm_blt_cb.async_blt_way);										
			}
			else
			{
				applib_mem_ap_cache_free(g_vm_blt_cb.async_blt_buffer_A);
				vm_graphic_async_blt_reset();
				MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_ABLT_INIT_CREATE_SINGLE_LAYER_FAIL, ret);				
			}
		}
		else
		{
			g_vm_blt_cb.async_blt_buffer_B_size = size;
			ret = gdi_layer_create_cf_double_using_outside_memory(
				GDI_LCD->cf, 
				0,
				0, 
				vm_graphic_get_screen_width(), 
				vm_graphic_get_screen_height(),
				&(g_vm_blt_cb.async_blt_layer), 
				g_vm_blt_cb.async_blt_buffer_A,
				g_vm_blt_cb.async_blt_buffer_A_size,
				g_vm_blt_cb.async_blt_buffer_B,
				g_vm_blt_cb.async_blt_buffer_B_size);
			if (ret == GDI_SUCCEED)
			{
				g_vm_blt_cb.async_blt_way = VM_GRAPHIC_FLUSH_WAY_DOUBLE_EX_BUFFER;
				g_vm_blt_cb.is_first_blt_flag = 1;
				MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_ABLT_INIT_CREATE_ASM_DOUBLE_LAYER_SUCC, g_vm_blt_cb.async_blt_layer, g_vm_blt_cb.async_blt_way);										
			}
			else
			{
				applib_mem_ap_cache_free(g_vm_blt_cb.async_blt_buffer_A);
				applib_mem_ap_cache_free(g_vm_blt_cb.async_blt_buffer_B);
				vm_graphic_async_blt_reset();
				MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_ABLT_INIT_CREATE_DOUBLE_LAYER_FAIL, ret);								
			}
		}
	}
	
#if !defined(__MMI_SCREEN_SWITCH_EFFECT__) || defined(__MMI_REDUCED_UI_BUFFER__)		
	END_PROTECT_ASYNC_BLT
#endif			

	MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_ABLT_INIT_END, g_vm_blt_cb.async_blt_layer, g_vm_blt_cb.async_blt_way, g_vm_blt_cb.async_blt_buffer_A, g_vm_blt_cb.async_blt_buffer_B);

#endif
}

void vm_graphic_async_blt_stop(void)
{
	vm_graphic_async_blt_exit();
}

void vm_graphic_async_blt_start(void)
{
	vm_graphic_async_blt_init();
}


static VMINT vm_graphic_async_blt_internal(gdi_handle *layers, VMINT fx1, VMINT fy1, VMINT fx2, VMINT fy2)
{
	BOOL first_blt_layer_trans_color_enable;
	gdi_color first_blt_layer_trans_color;	
	VMINT ret;

	gdi_layer_push_and_set_active(layers[0]);
	gdi_layer_get_source_key(&first_blt_layer_trans_color_enable, &first_blt_layer_trans_color);
	gdi_layer_set_source_key(FALSE, 0); 
	gdi_layer_pop_and_restore_active();
	
	gdi_layer_push_and_set_active(g_vm_blt_cb.async_blt_layer);
	gdi_layer_push_and_set_clip(fx1, fy1, fx2, fy2);
	gdi_layer_set_source_key(FALSE, 0); 	
	gdi_push_and_set_alpha_blending_source_layer(NULL);
	ret = gdi_layer_flatten_with_clipping_ext(g_vm_blt_cb.async_blt_layer, layers[0], layers[1], layers[2], layers[3], 0);		
	if (ret != GDI_SUCCEED)
		MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_ABLT_FLUSH_FLATTEN_FAIL, ret);
	gdi_pop_and_restore_alpha_blending_source_layer();
	gdi_layer_pop_clip();
	gdi_layer_pop_and_restore_active();
	
	gdi_layer_push_and_set_active(layers[0]);
	gdi_layer_set_source_key(first_blt_layer_trans_color_enable, first_blt_layer_trans_color);
	gdi_layer_pop_and_restore_active();
	
	return ret;
}

static VMINT _vm_graphic_flush_layer(VMINT* layer_handles, VMINT count, VMINT x1, VMINT y1, VMINT x2, VMINT y2, VMINT flag)
{
	VMINT maxbltlayer;
	gdi_handle layers[MAX_LAYER];
	VMINT fx1, fy1, fx2, fy2;
	VMINT i = 0;
	VMINT ret;
		
    MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_2036 ,flag, count);

	if (vm_pmng_state(VM_PMNG_CUR_HANDLE) != VM_PMNG_FOREGROUND)
	{
		MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_2042 );
		return VM_GDI_MIBR_NOT_FORE;	
	}

    if (layer_handles == NULL  )
    {
        MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_2052 );     
		return VM_GDI_ERR_WRONG_PARAM;
    }
	
    if(count <=0)
    {
        MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_2058 );     
        return VM_GDI_ERR_WRONG_PARAM;
    }
	
#ifdef MRE_SUPPORT_CAMERA_FEATURE
	if (vm_is_open_camera_flush_screen_patten())
	{
        VMINT ret;
		ret = vm_camera_patten_flush_screen_buffer();
        return ret;
	}
#endif

	maxbltlayer = vm_graphic_get_blt_layer_count();

	memset(layers, 0x00, sizeof(layers));
			
	if (count > maxbltlayer)
		count = maxbltlayer;

	for (i = 0; i < maxbltlayer; i++) 
	{
		layers[i] = 0;
		if (i < count) 
    		if (VALID_MRE_HANDLE(layer_handles[i]))
				layers[i] = layer_trans_tbl[layer_handles[i]].handle;
	}
    MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_2105 , layers[0], layers[1],layers[2], layers[3],layers[4], layers[5]);
		
	if ((layers[0] +layers[1]+layers[2]+layers[3]+layers[4]+layers[5])== 0 )
    {
 	    MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_2110 );
        return VM_GDI_FAILED;
	}
	else
	{	
        if ( flag & VM_GRAPHIC_FLUSH_FLAG_REGION_BLT )
        {
			fx1 = x1;
			fy1 = y1;
			fx2 = x2;
			fy2 = y2;
		}
		else
		{
			fx1 = 0;
			fy1 = 0;
			fx2 = vm_graphic_get_screen_width() - 1;
			fy2 = vm_graphic_get_screen_height() - 1;
		}

		if ( flag & VM_GRAPHIC_FLUSH_FLAG_NON_BLOCKING )
		{
			// should consider whether the last asnyc blt is completed
			ret = gdi_layer_blt_with_flag(layers[0], layers[1], layers[2], layers[3],
                                        fx1, fy1, fx2, fy2, GDI_LAYER_BLT_FLAG_NON_BLOCKING, NULL);
		}
		else
		{	
#if !defined(__MMI_SCREEN_SWITCH_EFFECT__) || defined(__MMI_REDUCED_UI_BUFFER__)
			BEGIN_PROTECT_ASYNC_BLT
#endif			

			MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_ABLT_FLUSH, g_vm_blt_cb.async_blt_layer, g_vm_blt_cb.async_blt_way, g_vm_blt_cb.async_blt_buffer_A, g_vm_blt_cb.async_blt_buffer_B);

			if (g_vm_blt_cb.async_blt_way == VM_GRAPHIC_FLUSH_WAY_DOUBLE_EX_BUFFER)
			{
				if (g_vm_blt_cb.is_first_blt_flag == 1)
				{
#if !defined(__MMI_SCREEN_SWITCH_EFFECT__) || defined(__MMI_REDUCED_UI_BUFFER__)		
									END_PROTECT_ASYNC_BLT
#endif			
					ret = gdi_layer_blt_ext(layers[0], layers[1], layers[2], layers[3], 0, 0,
											  fx1, fy1, fx2, fy2);			
					g_vm_blt_cb.is_first_blt_flag = 0;
				}
				else
				{
					for (i = 0; i < 6; i++) 
					{
						g_vm_blt_cb.previous_blt_layers[i] = layers[i];
					}
				
					ret = vm_graphic_async_blt_internal(layers, fx1, fy1, fx2, fy2);

					gdi_waiting_blt_finish();
					
					ret = gdi_layer_blt_with_flag(g_vm_blt_cb.async_blt_layer, 0, 0, 0,
		                                        fx1, fy1, fx2, fy2, GDI_LAYER_BLT_FLAG_NON_BLOCKING, NULL);

					gdi_layer_push_and_set_active(g_vm_blt_cb.async_blt_layer);
					ret = gdi_layer_toggle_double();
					gdi_layer_pop_and_restore_active();
					
#if !defined(__MMI_SCREEN_SWITCH_EFFECT__) || defined(__MMI_REDUCED_UI_BUFFER__)		
					END_PROTECT_ASYNC_BLT	
#endif			
				}
			}
			else if (g_vm_blt_cb.async_blt_way == VM_GRAPHIC_FLUSH_WAY_SINGLE_EX_BUFFER)
			{
				for (i = 0; i < 6; i++) 
				{
					g_vm_blt_cb.previous_blt_layers[i] = layers[i];
				}

				gdi_waiting_blt_finish();

				ret = vm_graphic_async_blt_internal(layers, fx1, fy1, fx2, fy2);
								
				ret = gdi_layer_blt_with_flag(g_vm_blt_cb.async_blt_layer, 0, 0, 0,
	                                        fx1, fy1, fx2, fy2, GDI_LAYER_BLT_FLAG_NON_BLOCKING, NULL);
				
#if !defined(__MMI_SCREEN_SWITCH_EFFECT__) || defined(__MMI_REDUCED_UI_BUFFER__)		
				END_PROTECT_ASYNC_BLT
#endif			
			}
			else
			{
#if !defined(__MMI_SCREEN_SWITCH_EFFECT__) || defined(__MMI_REDUCED_UI_BUFFER__)		
				END_PROTECT_ASYNC_BLT
#endif			
				ret = gdi_layer_blt_ext(layers[0], layers[1], layers[2], layers[3], 0, 0,
										  fx1, fy1, fx2, fy2);			
			}
		}
		
        return ret;
	}

}

VMINT vm_graphic_flush_layer(VMINT* layer_handles, VMINT count)
{
    VMINT ret;
    
    MRE_SWLA_START("MG0");
    ret = _vm_graphic_flush_layer(layer_handles, count, 0, 0, 0, 0, 0);
    MRE_SWLA_STOP("MG0");
    return ret;	
}

VMINT vm_graphic_flush_layer_ex(VMINT* layer_handles, VMINT count, VMINT x1, VMINT y1, VMINT x2, VMINT y2)
{
    VMINT ret;
    MRE_SWLA_START("MG1");
    ret = _vm_graphic_flush_layer(layer_handles, count, x1, y1, x2, y2, VM_GRAPHIC_FLUSH_FLAG_REGION_BLT);
    MRE_SWLA_STOP("MG1");	
    return ret;
}

VMINT vm_graphic_flush_layer_non_block(VMINT* layer_handles, VMINT count)
{
    VMINT ret;
    MRE_SWLA_START("MG2");
	  ret = _vm_graphic_flush_layer(layer_handles, count, 0, 0, 0, 0, VM_GRAPHIC_FLUSH_FLAG_NON_BLOCKING);
	  MRE_SWLA_STOP("MG2");
    return ret;
}

VMINT vm_graphic_flush_layer_non_block_ex(VMINT* layer_handles, VMINT count, VMINT x1, VMINT y1, VMINT x2, VMINT y2)
{
    VMINT ret;
    MRE_SWLA_START("MG3");
    ret = _vm_graphic_flush_layer(layer_handles, count, x1, y1, x2, y2, VM_GRAPHIC_FLUSH_FLAG_REGION_BLT | VM_GRAPHIC_FLUSH_FLAG_NON_BLOCKING);
    MRE_SWLA_STOP("MG3");	
    return ret;
}


VMUINT8* vm_graphic_get_layer_buffer(VMINT handle) 
{
	VMUINT8* buf = NULL;
	
	if (VALID_MRE_HANDLE(handle))
		buf = layer_trans_tbl[handle].buffer;
	
    MMI_TRACE(MMI_MRE_TRC_INFO, TRC_MRE_VMGRAPH_2333, handle, buf);
	
	return buf;
}


VMINT vm_graphic_clear_layer_bg(VMINT handle) 
{
	if (layer_operation_permission_check() < 0)
	{
		return VM_GDI_MIBR_NOT_FORE;	
    }
	
	if (VALID_MRE_HANDLE(handle))	
	{
		if (vm_graphic_active_layer(handle) == VM_GDI_SUCCEED) 
		{
			if (layer_trans_tbl[handle].trans_color_enable == TRUE) 
			{
				gdi_layer_set_source_key(TRUE, layer_trans_tbl[handle].trans_color);
				gdi_layer_clear(layer_trans_tbl[handle].trans_color);
			}			
			
			return VM_GDI_SUCCEED;
		}		
	}
	
	return VM_GDI_FAILED;
}

VMINT vm_graphic_set_layer_opacity(VMINT handle, VMINT percent) 
{
	if (layer_operation_permission_check() < 0)
	{
		return VM_GDI_MIBR_NOT_FORE;	
    }

	if((percent < 0) || (percent > 100))
		return VM_GDI_ERR_WRONG_PARAM;
	
	if (VALID_MRE_HANDLE(handle))
	{
		if (vm_graphic_active_layer(handle) == VM_GDI_SUCCEED) 
		{
			if (gdi_layer_set_opacity(TRUE, (VMUINT8)(percent * 255 / 100)) == GDI_SUCCEED) 
			{		
				return VM_GDI_SUCCEED;
			}		
		}
	}
	
	return VM_GDI_FAILED;
}

VMINT vm_graphic_get_layer_position(VMINT handle, VMINT *x, VMINT *y, VMINT *width, VMINT *height)
{	
	if (!x || !y || !width || !height)
		return VM_GDI_ERR_WRONG_PARAM;
	
	if (VALID_MRE_HANDLE(handle))
	{
		*x = layer_trans_tbl[handle].x;
		*y = layer_trans_tbl[handle].y;
		*width = layer_trans_tbl[handle].width;
		*height = layer_trans_tbl[handle].height;

		return VM_GDI_SUCCEED;
	}
	
	return VM_GDI_FAILED;
}

VMINT vm_graphic_get_layer_color_format(VMINT handle, vm_graphic_color_famat *cf)
{
	if (!cf)
		return VM_GDI_ERR_WRONG_PARAM;
	
	if (VALID_MRE_HANDLE(handle))
	{
		*cf = layer_trans_tbl[handle].cf;

		return VM_GDI_SUCCEED;
	}
	
	return VM_GDI_FAILED;
}


VMINT  vm_graphic_get_layer_porp_from_buf(VMUINT8* platform_disp_buffer, VMINT*x, VMINT*y, VMINT *width, VMINT *height, vm_graphic_color_famat *cf)
{
	VMINT i = 0;
	VMINT lx, ly, lw, lh;
	vm_graphic_color_famat lcf;
	VMINT ret = -1;
	
	if (!platform_disp_buffer || !width || !height|| !x || !y || !cf)
		return VM_GDI_ERR_WRONG_PARAM;

	for (i = 0;  i < MAX_LAYER; i++)
	{
        if ((layer_trans_tbl[i].buffer == platform_disp_buffer) && (layer_trans_tbl[i].used))
        {
            if (vm_graphic_get_layer_position(i, &lx, &ly, &lw, &lh) < 0)
			    return VM_GDI_FAILED;	
            *width = lw;
            *height = lh;  
            *x = lx; 
            *y = ly; 			

            if (vm_graphic_get_layer_color_format(i, &lcf) < 0)
			    return VM_GDI_FAILED;	
            *cf = lcf;
            
            ret = 0;
            break;
        }
	}
	if (ret == 0)
		return VM_GDI_SUCCEED;

	return VM_GDI_FAILED;
}


VMINT  vm_graphic_get_layer_porp_from_layer(VMINT handle, VMINT *x , VMINT *y,VMINT *width, VMINT *height)
{
	VMINT lx, ly,lw, lh;

	if ((INVALID_MRE_HANDLE(handle)) || !width || !height|| !x || !y)
		return VM_GDI_ERR_WRONG_PARAM;

	if (vm_graphic_get_layer_position(handle, &lx, &ly, &lw, &lh) < 0)
		return VM_GDI_FAILED;
	
	*x = lx;
	*y = ly; 	
	*width = lw;
	*height = lh;            

	return VM_GDI_SUCCEED;
}

VM_GDI_RESULT vm_graphic_layer_set_trans_color(VMINT hhandle, VMINT trans_color)
{ 
 	//if handle is not legal or fast layer not function
	if (INVALID_MRE_HANDLE(hhandle))
	{
		MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_2501 );
		return VM_GDI_FAILED;
	}

	if (trans_color == VM_NO_TRANS_COLOR)
	{
		layer_trans_tbl[hhandle].trans_color_enable = FALSE;
		layer_trans_tbl[hhandle].trans_color = 0;
	}
	else
	{
		layer_trans_tbl[hhandle].trans_color_enable = TRUE;
		layer_trans_tbl[hhandle].trans_color = trans_color;
	}
		
	gdi_layer_push_and_set_active(SAL_HANDLE(hhandle));
	 (layer_trans_tbl[hhandle].trans_color_enable == TRUE) ?
		gdi_layer_set_source_key(TRUE, layer_trans_tbl[hhandle].trans_color) : 
		gdi_layer_set_source_key(FALSE, 0);
	gdi_layer_pop_and_restore_active();
	
    MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_2511 ,layer_trans_tbl[hhandle].trans_color);
	
	return VM_GDI_SUCCEED;
}


VM_GDI_RESULT vm_graphic_canvas_set_trans_color(VMINT hcanvas, VMINT trans_color)
{
	VMUINT8 *buffer = NULL;
	VMINT handle;
	
	if ((hcanvas < 0) ||((void*)hcanvas == NULL) || ( !is_mre_canvas_buf((VMUINT8 *) hcanvas)))
	{
        MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_2523 );
		return VM_GDI_ERR_WRONG_PARAM;
	}
		
	buffer = (VMUINT8*)hcanvas;

	buffer[VM_CANVAS_SIGNATURE_SIZE] = 1;
	buffer[VM_CANVAS_SIGNATURE_SIZE + 12] = ((VMUINT16)trans_color) % 256;	
	buffer[VM_CANVAS_SIGNATURE_SIZE + 13] = ((VMUINT16)trans_color) >> 8;

	//if no function in base layer
	if ((handle=find_layer(buffer)) == 0)
	{
        MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_2536 );
		return VM_GDI_SUCCEED;
	}
		
 	//if handle is not legal or fast layer not function
	if ((INVALID_MRE_HANDLE(handle)) || ((is_fast_layer > 0) && (handle == is_fast_layer)))
	{
        MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_2543 ,handle);
		return VM_GDI_SUCCEED;
	}
		
	vm_graphic_layer_set_trans_color(handle, trans_color);
	return VM_GDI_SUCCEED;
}


VM_GDI_RESULT vm_graphic_layer_set_trans_color_argb(VMINT hhandle, vm_graphic_color_argb* trans_color)
{
 	if (INVALID_MRE_HANDLE(hhandle))
	{
		return VM_GDI_FAILED;
	}
		
	gdi_layer_push_and_set_active(SAL_HANDLE(hhandle));
	if (trans_color == NULL)
	{
		layer_trans_tbl[hhandle].trans_color_enable = FALSE;
		layer_trans_tbl[hhandle].trans_color = 0;
	}
	else
	{
		layer_trans_tbl[hhandle].trans_color_enable = TRUE;
		layer_trans_tbl[hhandle].trans_color = gdi_act_color_from_rgb(255, trans_color->r, trans_color->g, trans_color->b);
	}
	
	(layer_trans_tbl[hhandle].trans_color_enable == TRUE) ?
		gdi_layer_set_source_key(TRUE, layer_trans_tbl[hhandle].trans_color) : 
		gdi_layer_set_source_key(FALSE, 0);
	gdi_layer_pop_and_restore_active();
	
	return VM_GDI_SUCCEED;
}


VM_GDI_RESULT vm_graphic_canvas_set_trans_color_argb(VMINT hcanvas, vm_graphic_color_argb* trans_color)
{
	VMUINT8 *buffer = NULL;
	VMINT handle;
	vm_graphic_color_famat cf;
	
	if ((hcanvas < 0) ||((void*)hcanvas == NULL) || ( !is_mre_canvas_buf((VMUINT8 *) hcanvas)))
	{
		return VM_GDI_ERR_WRONG_PARAM;
	}
		
	buffer = (VMUINT8*)hcanvas;

	cf = buffer[VM_CANVAS_FRAME_NUM_OFFSET + 2];
	if ( !is_color_format_valid(cf) )
		return -1;

	if (trans_color == NULL)
	{
		buffer[VM_CANVAS_SIGNATURE_SIZE] = 0;
		buffer[VM_CANVAS_SIGNATURE_SIZE + 11] = 0;
		buffer[VM_CANVAS_SIGNATURE_SIZE + 12] = 0;	
		buffer[VM_CANVAS_SIGNATURE_SIZE + 13] = 0;
	}
	else
	{
		if ( cf == VM_GRAPHIC_COLOR_FORMAT_16 )
		{	
			VMUINT trans_color_565;
		
			trans_color_565 = VM_RGB565_ARGB(trans_color->a, trans_color->r, trans_color->g, trans_color->b);
			buffer[VM_CANVAS_SIGNATURE_SIZE] = 1;
			buffer[VM_CANVAS_SIGNATURE_SIZE + 12] = (trans_color_565) % 256;	
			buffer[VM_CANVAS_SIGNATURE_SIZE + 13] = (trans_color_565) >> 8;
		}
		else
		{
			buffer[VM_CANVAS_SIGNATURE_SIZE] = 1;
			buffer[VM_CANVAS_SIGNATURE_SIZE + 11] = trans_color->b;
			buffer[VM_CANVAS_SIGNATURE_SIZE + 12] = trans_color->g;	
			buffer[VM_CANVAS_SIGNATURE_SIZE + 13] = trans_color->r;
		}
	}
	
	//if no function in base layer
	if ((handle=find_layer(buffer)) == 0)
	{
        MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_2537 );
		return VM_GDI_SUCCEED;
	}
		
 	//if handle is not legal or fast layer not function
	if ((INVALID_MRE_HANDLE(handle)) || ((is_fast_layer > 0) && (handle == is_fast_layer)))
	{
        MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_2544 ,handle);
		return VM_GDI_SUCCEED;
	}
		
	vm_graphic_layer_set_trans_color_argb(handle, trans_color);
	
	return VM_GDI_SUCCEED;
}


VMINT vm_graphic_get_string_baseline(VMWSTR string)
{
    mmi_fe_get_string_info_param_struct query; 
	
    if (!string) 
	    return VM_GDI_ERR_WRONG_PARAM;
    
    memset(&query, 0, sizeof(mmi_fe_get_string_info_param_struct));

    query.String = (U8 *)string;
    query.n = vm_wstrlen(string);
    query.enableTruncated = MMI_FALSE;
    query.w = 0;    
    mmi_fe_get_string_widthheight(&query);  
	
    return query.baseline;
}   


static void _vm_textout_internal(VMUINT text_x, VMUINT text_y,VMWSTR text, VMINT length, VMUINT32 text_color,VMINT baseline_flag,VMINT baseline)
{
	VMINT nlen;
	mmi_fe_color c;
	vm_graphic_cb *current_cb;

	current_cb = vm_graphic_get_current_cb();
	if (current_cb == NULL)
		return;	
	
	c.a = 0;
	c.r = (VMUINT8)((text_color & 0xFF00) >> 8);
	c.g = (VMUINT8)((text_color & 0xFF0000) >> 16);
	c.b = (VMUINT8)((text_color & 0xFF000000) >> 24);
	mmi_fe_set_text_color(c);
	
	gui_set_font(&(current_cb->font));
    MMI_TRACE(MMI_MRE_TRC_INFO, TRC_MRE_VMGRAPH_2590 , current_cb->font.bold, current_cb->font.italic, current_cb->font.underline, current_cb->font.size, current_cb->font.color, current_cb->font.type);

	nlen = vm_wstrlen(text);
	if (length > nlen)
		length = nlen;

    if (baseline_flag)
    {
        mmi_fe_show_string_n_baseline(text_x, text_y, (U8 *)text, length, baseline);
        return;        
    }
    
    if(length>0)
    {
		mmi_fe_show_string_n(text_x, text_y, (U8 *)text, length);
		return;
    }
}


static VMINT _vm_layer_textout_internal(VMUINT8* platform_disp_buffer, 
											   VMUINT text_x, VMUINT text_y, 
											   VMUINT clip_x1, VMUINT clip_y1, VMUINT clip_x2, VMUINT clip_y2,
											   VMWSTR text, VMINT length, VMUINT32 text_color,VMINT baseline_flag,VMINT baseline)
{
	U8* ptr = NULL;
	VMINT i = 0;

	if (layer_operation_permission_check() < 0)
	{
		return VM_GDI_MIBR_NOT_FORE;	
    }

	if (!platform_disp_buffer || !text || (length<=0))
    {
		return VM_GDI_ERR_WRONG_PARAM;
    }
	
	gdi_layer_push_and_set_active(GDI_LAYER_MAIN_BASE_LAYER_HANDLE);
	gdi_layer_get_buffer_ptr(&ptr);
	if (ptr == platform_disp_buffer)
	{
		gdi_layer_set_clip(clip_x1, clip_y1, clip_x2, clip_y2);
        _vm_textout_internal(text_x, text_y,text, length, text_color,baseline_flag,baseline);
		gdi_layer_pop_and_restore_active();
		return VM_GDI_SUCCEED;
	}
	else
	{
		gdi_layer_pop_and_restore_active();
		for (i = 0; i < MAX_LAYER; i++)
		{
			if  (layer_trans_tbl[i].used)
			{
				gdi_layer_push_and_set_active(SAL_HANDLE(i));
				gdi_layer_get_buffer_ptr(&ptr);
				if (ptr == platform_disp_buffer) 
				{
					gdi_layer_set_clip(clip_x1, clip_y1, clip_x2, clip_y2);
                    _vm_textout_internal(text_x, text_y,text, length, text_color,baseline_flag,baseline);
					gdi_layer_pop_and_restore_active();
					return VM_GDI_SUCCEED;
				}
				gdi_layer_pop_and_restore_active();
			}
		}

		return VM_GDI_FAILED;
	}
}

static VM_GDI_RESULT _vm_layer_textout_internal_ex(VMINT handle, 
											   VMUINT text_x, VMUINT text_y, 
											   VMUINT clip_x1, VMUINT clip_y1, VMUINT clip_x2, VMUINT clip_y2,
											   VMWSTR text, VMINT length, VMUINT32 text_color,VMUINT rect_flag,VMINT baseline_flag,VMINT baseline)
{
    if (!text || (length<=0))
    {
        MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_2667 );
		return VM_GDI_ERR_WRONG_PARAM;
    }

	gdi_layer_push_and_set_active(SAL_HANDLE(handle));
	gdi_layer_set_clip(clip_x1, clip_y1, clip_x2, clip_y2);
    _vm_textout_internal(text_x, text_y,text, length, text_color,baseline_flag,baseline);        
	gdi_layer_pop_and_restore_active();

	return VM_GDI_SUCCEED;
}

VMINT vm_graphic_layer_textout_internal(VMUINT8* platform_disp_buffer, 
											   VMUINT text_x, VMUINT text_y, 
											   VMUINT clip_x1, VMUINT clip_y1, VMUINT clip_x2, VMUINT clip_y2,
											   VMWSTR text, VMINT length, VMUINT32 text_color)
{
    return _vm_layer_textout_internal(platform_disp_buffer, 
											   text_x, text_y, 
											   clip_x1, clip_y1, clip_x2, clip_y2,
											   text, length, text_color,FALSE,0);
}


VMINT vm_graphic_layer_textout_by_baseline_internal(VMUINT8* platform_disp_buffer, 
											   VMUINT text_x, VMUINT text_y, 
											   VMUINT clip_x1, VMUINT clip_y1, VMUINT clip_x2, VMUINT clip_y2,
											   VMWSTR text, VMINT length, VMUINT32 text_color,VMINT baseline)
{
    return _vm_layer_textout_internal(platform_disp_buffer, 
										   text_x, text_y, 
										   clip_x1, clip_y1, clip_x2, clip_y2,
										   text, length, text_color,TRUE,baseline);
}




static VM_GDI_RESULT vm_graphic_layer_textout_internal_ex(VMINT handle, 
											   VMUINT text_x, VMUINT text_y, 
											   VMUINT clip_x1, VMUINT clip_y1, VMUINT clip_x2, VMUINT clip_y2,
											   VMWSTR text, VMINT length, VMUINT32 text_color,VMUINT rect_flag)
{
    return _vm_layer_textout_internal_ex(handle, 
										   text_x, text_y, 
										   clip_x1, clip_y1, clip_x2, clip_y2,
										   text, length, text_color,rect_flag,FALSE,0);
}


static VM_GDI_RESULT vm_graphic_layer_textout_by_baseline_internal_ex(VMINT handle, 
											   VMUINT text_x, VMUINT text_y, 
											   VMUINT clip_x1, VMUINT clip_y1, VMUINT clip_x2, VMUINT clip_y2,
											   VMWSTR text, VMINT length, VMUINT32 text_color,VMUINT rect_flag,VMINT baseline)
{
    return _vm_layer_textout_internal_ex(handle, 
										   text_x, text_y, 
										   clip_x1, clip_y1, clip_x2, clip_y2,
										   text, length, text_color,rect_flag,TRUE,baseline);
}


static VMINT _vm_canvas_textout_internal(VMUINT8* platform_disp_buffer, 
												VMUINT width, VMUINT height, VMUINT text_x, VMUINT text_y, 
												VMUINT clip_x1, VMUINT clip_y1, VMUINT clip_x2, VMUINT clip_y2,
												VMWSTR text, VMINT length, VMUINT32 text_color,VMINT baseline_flag,VMINT baseline)
{
	gdi_handle gdi_handle = GDI_LAYER_EMPTY_HANDLE;

	VMINT buffer_size;
	
	if (layer_operation_permission_check() < 0)
	{
		return VM_GDI_MIBR_NOT_FORE;	
    }

	if (!platform_disp_buffer || !text || (length<=0))
    {
        MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_2745 );
		return VM_GDI_ERR_WRONG_PARAM;
    }
	
	buffer_size = width * height * 2 + (width * height * 2 ) % 4;
	if (gdi_layer_create_using_outside_memory(0, 0, width, height,  
		&gdi_handle, platform_disp_buffer, buffer_size) != GDI_SUCCEED)
    {
        MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_2752 );
		return VM_GDI_FAILED;
    }
	
	gdi_layer_push_and_set_active(gdi_handle);
	gdi_layer_set_clip(clip_x1, clip_y1, clip_x2, clip_y2);
    _vm_textout_internal(text_x, text_y,text, length, text_color,baseline_flag,baseline);        
	gdi_layer_pop_and_restore_active();
    
	gdi_layer_free(gdi_handle);

	return VM_GDI_SUCCEED;
}


VMINT vm_graphic_canvas_textout_internal(VMUINT8* platform_disp_buffer, 
												VMUINT width, VMUINT height, VMUINT text_x, VMUINT text_y, 
												VMUINT clip_x1, VMUINT clip_y1, VMUINT clip_x2, VMUINT clip_y2,
												VMWSTR text, VMINT length, VMUINT32 text_color)
{
    return _vm_canvas_textout_internal(platform_disp_buffer, 
										   width, height, text_x, text_y, 
										   clip_x1, clip_y1, clip_x2, clip_y2,
										   text, length, text_color,FALSE,0);
}

VMINT vm_graphic_canvas_textout_by_baseline_internal(VMUINT8* platform_disp_buffer, 
												VMUINT width, VMUINT height, VMUINT text_x, VMUINT text_y, 
												VMUINT clip_x1, VMUINT clip_y1, VMUINT clip_x2, VMUINT clip_y2,
												VMWSTR text, VMINT length, VMUINT32 text_color,VMINT baseline)
{
    return _vm_canvas_textout_internal(platform_disp_buffer, 
										   width, height, text_x, text_y, 
										   clip_x1, clip_y1, clip_x2, clip_y2,
										   text, length, text_color,TRUE,baseline);
}

static VM_GDI_RESULT vm_graphic_textout_to_layer_internal (VMINT handle, VMINT x, VMINT y, VMWSTR s, VMINT length, VMBOOL flag, VMINT baseline)
{
	clip_rect cliprect;
	VMINT	ret;
	vm_graphic_color_argb current_color;
	
    MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_2798 ,handle,x,y,s,length);
	
	if (layer_operation_permission_check() < 0)
	{
		return VM_GDI_MIBR_NOT_FORE;	
    }

	if ((INVALID_MRE_HANDLE(handle)) || (length <= 0))
    {
        MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_2807 );
		return VM_GDI_ERR_WRONG_PARAM;
    }

	vm_graphic_get_layer_clip(handle, &cliprect);
	
	current_color = vm_graphic_getcolor_argb();

	if (flag == TRUE)
	{
		ret = vm_graphic_layer_textout_by_baseline_internal_ex(handle, x, y, 
				cliprect.left, cliprect.top, cliprect.right, cliprect.bottom,
				s, length, 
				VM_RGB32_ARGB(current_color.a, current_color.r, current_color.g, current_color.b),
				FALSE,baseline);		
	}
	else
	{
		ret = vm_graphic_layer_textout_internal_ex(handle, x, y, 
				cliprect.left, cliprect.top, cliprect.right, cliprect.bottom,
				s, length, 
				VM_RGB32_ARGB(current_color.a, current_color.r, current_color.g, current_color.b),
				FALSE);
	}
			
	return ret;
}

VM_GDI_RESULT vm_graphic_textout_to_layer (VMINT handle, VMINT x, VMINT y, VMWSTR s, VMINT length)
{
	return vm_graphic_textout_to_layer_internal(handle, x, y, s, length, FALSE, 0);
}

VM_GDI_RESULT vm_graphic_textout_to_layer_by_baseline (VMINT handle, VMINT x, VMINT y, VMWSTR s, VMINT length,VMINT baseline)
{
	return vm_graphic_textout_to_layer_internal(handle, x, y, s, length, TRUE, baseline);	
}


VMINT vm_graphic_draw_abm_text(VMINT handle, VMINT x, VMINT y, VMINT color,VMUINT8* font_data,VMINT font_width,VMINT font_height)
{
    VMINT font_byte_width;
    gdi_handle cur_active_layer;
	
	if (layer_operation_permission_check() < 0)
	{
		return VM_GDI_MIBR_NOT_FORE;	
    }
    
	if ((INVALID_MRE_HANDLE(handle)) || (!font_data)|| (font_width <= 0) || (font_height <= 0))
		return VM_GDI_ERR_WRONG_PARAM;  

    if (x < layer_trans_tbl[handle].x || x >= (layer_trans_tbl[handle].x + layer_trans_tbl[handle].width))
        return VM_GDI_ERR_WRONG_PARAM; 

    if (y < layer_trans_tbl[handle].y || y >= (layer_trans_tbl[handle].y + layer_trans_tbl[handle].height))
        return VM_GDI_ERR_WRONG_PARAM;     
    
    if (font_height!=12 && font_height!=14 && font_height!=16&& font_height!=18
	&& font_height!=20 && font_height!=22&& font_height!=24
	&& font_height!=26 && font_height!=28&& font_height!=30&& font_height!=32)
        return VM_GDI_FONTSIZE_NOT_SUPPORT;

    font_byte_width = font_width;
    if (font_width < 8)
        font_byte_width = 8;    
    else if (font_width % 8)
        font_byte_width = font_width + (8 - font_width % 8);
    
	gdi_layer_get_active(&cur_active_layer);
	if (SAL_HANDLE(handle) != cur_active_layer)
	{
		gdi_layer_push_and_set_active(SAL_HANDLE(handle));
		gdi_draw_font_by_abm(x,y,color,font_data,font_byte_width,font_height);
		gdi_layer_pop_and_restore_active();
		return VM_GDI_SUCCEED;
	}
	gdi_draw_font_by_abm(x,y,color,font_data,font_byte_width,font_height);
	
    return VM_GDI_SUCCEED;
}


VMINT vm_graphic_is_ab2_file(VMUINT8 *img_data)
{
	if( img_data[0] == 0x34 && img_data[1] == 0x1)
		return TRUE;
	return FALSE;	
}

VMINT vm_graphic_is_gif_file(VMUINT8 *img_data)
{
	if( img_data[0] == 'G' && img_data[1] == 'I' && img_data[2] == 'F')
		return TRUE;
	return FALSE;	
}

VMINT vm_graphic_is_bmp_file(VMUINT8 *img_data)
{
	if( img_data[0] == 'B' && img_data[1] == 'M')
		return TRUE;
	return FALSE;
}

VMINT vm_graphic_is_png_file(VMUINT8 *img_data)
{
	if( img_data[0] == 0x89 && img_data[1] == 0x50 && img_data[2] == 0x4E && img_data[3] == 0x47)
		return TRUE;
	return FALSE;
}

VMINT vm_graphic_is_jpeg_file(VMUINT8 *img_data)
{
	if( img_data[0] == 0xff && img_data[1] == 0xd8 && img_data[2] == 0xff)
		return TRUE;
	return FALSE;
}

VMINT vm_graphic_is_gif_virtual_file(VMUINT8 *img_data)
{
    if(img_data[0]==0x18)
        return TRUE;
    else
        return FALSE;
}
//virtual 1
VMINT vm_graphic_is_virtual_file(VMUINT8 *img_data)
{
    if(img_data[0]==0x17 || img_data[0]==0x1f || img_data[0]==0x20 || img_data[0]==0x37)
        return TRUE;
    else
    	return FALSE;
}

static VMINT vm_graphic_get_img_type(VMUINT8 *img_data, VMUINT8 *img_type)
{
	if (vm_graphic_is_ab2_file(img_data))
	{
	    *img_type = GDI_IMAGE_TYPE_AB2;
	}
	else if (vm_graphic_is_gif_file(img_data))
	{
	    *img_type = GDI_IMAGE_TYPE_GIF;
	}
	else if (vm_graphic_is_bmp_file(img_data))
	{
	    *img_type = GDI_IMAGE_TYPE_BMP;
	}
	else if (vm_graphic_is_png_file(img_data))
	{
	    *img_type = GDI_IMAGE_TYPE_PNG;
	}
	else if (vm_graphic_is_jpeg_file(img_data))
	{
	    *img_type = GDI_IMAGE_TYPE_JPG;
	}
	else if (vm_graphic_is_gif_virtual_file(img_data))
	{
	    *img_type = GDI_IMAGE_TYPE_GIF_FILE_OFFSET;
	}
	else if (vm_graphic_is_virtual_file(img_data))
        {   /*here img_type maybe virtual 2
                 GDI_IMAGE_TYPE_BMP_FILE_OFFSET,
                 GDI_IMAGE_TYPE_GIF_FILE_OFFSET,
                 GDI_IMAGE_TYPE_JPG_FILE_OFFSET,
                 GDI_IMAGE_TYPE_PNG_FILE_OFFSET,
                 GDI_IMAGE_TYPE_AB2_FILE_OFFSET, 
                 use GDI_IMAGE_TYPE_BMP_FILE_OFFSET to represent virtual image type
              */
            *img_type = GDI_IMAGE_TYPE_BMP_FILE_OFFSET;
        }
	else
	{
	    MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_2955 );
	    return VM_GDI_ERR_UNSUPPORT_IMAGE_TYPE;
	}
	return VM_GDI_SUCCEED;
}


static VMINT vm_graphic_create_decode_canvas_internal(vm_graphic_color_famat cf, VMINT width,VMINT height,VMUINT8 **frame_buffer, VMINT * buffer_size)
{
    VMINT hcanvas;
    
    if ((hcanvas = vm_graphic_create_canvas_cf(cf, width, height)) < 0)
	{
        MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_2968 );
		return VM_GDI_ERR_CREATE_CANVAS_FAILED;
	}
	
	*frame_buffer = (VMUINT8*)hcanvas + VM_CANVAS_SIGNATURE_SIZE + VM_CANVAS_FRAME_PROPERTY_SIZE;
	*buffer_size = get_canvas_prop((VMUINT8*)hcanvas, VM_CANVAS_DATASIZE);

	return hcanvas;
}

/*
create temp layer with canvas buffer , and draw image on it
buffer_data:decoded data
buffer_len:decoded data size
img_data:un-decoded data
img_len:un-decoded data size
img_width,img_height: 
*/
static VMINT vm_graphic_decode_internal(vm_graphic_color_famat cf, VMUINT8 *buffer_data , VMINT buffer_len, VMUINT8* img_data, VMINT img_len, VMINT img_width, VMINT img_height,VMUINT8 graphic_type, IHDR_t *ihdr, VMINT resize, VMINT flag)
{
	gdi_handle layer_handle = 0;
	gdi_handle source_layer_handle;
	GDI_RESULT gdi_hdl_result = GDI_SUCCEED;	
	gdi_color_format color_format;
	VMINT ret;
	VMINT alpha_blending_flag = 0;
	
    MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_2994 ,buffer_data,buffer_len,img_data,img_len);
    MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_2995 ,img_width,img_height,graphic_type,resize);

	convert_to_gdi_color_format(cf, &color_format);
	if ((ret = gdi_layer_create_cf_using_outside_memory(color_format, 0, 0, img_width, img_height, &layer_handle, buffer_data, buffer_len)) != GDI_SUCCEED)
	{
		MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_3000 ,ret);
		return VM_GDI_ERR_CREATE_LAYER_FAILED;
	}
	
	if (layer_handle == 0)
	{
		MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_3006 );
		return VM_GDI_ERR_CREATE_LAYER_FAILED;
	}

	gdi_layer_push_and_set_active(layer_handle);

	if ( !( flag && graphic_type == GDI_IMAGE_TYPE_PNG && ihdr->colortype <= 3 )	)
		if (cf == VM_GRAPHIC_COLOR_FORMAT_16)
			gdi_layer_clear(gdi_act_color_from_rgb(255, 248, 252, 232));	// (0xFF, 0xF8, 0xFC, 0xE8) = VM_KEY_COLOR (0xFFFD)
		else
			gdi_layer_clear(gdi_act_color_from_rgb(255, 255, 254, 253));
	
	if ( cf == VM_GRAPHIC_COLOR_FORMAT_16 || cf == VM_GRAPHIC_COLOR_FORMAT_24 )
	{
		if ( graphic_type == GDI_IMAGE_TYPE_AB2 || graphic_type == GDI_IMAGE_TYPE_PNG) 
			alpha_blending_flag = 1;
	}

	if (alpha_blending_flag)
	{
		//set transpare layer
		gdi_image_abm_get_source_layer(&source_layer_handle);
		gdi_image_abm_set_source_layer(layer_handle);
	}

	// virtual image virtual 3
	if(graphic_type==GDI_IMAGE_TYPE_BMP_FILE_OFFSET)
	{
	    if (resize)
        {
            gdi_hdl_result = gdi_image_draw_resized(0, 0, img_width,img_height,img_data);
        }
        else
        {
            gdi_hdl_result = gdi_image_draw(0, 0, img_data);
        }
    }
    else
    {
        if (resize)
        {
            gdi_hdl_result = gdi_image_draw_resized_mem(0, 0, img_width,img_height,img_data, graphic_type, img_len);
        }
        else
        {
            gdi_hdl_result = gdi_image_draw_mem(0, 0, img_data, graphic_type, img_len);
        }
    }
    MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_3034 ,gdi_hdl_result,resize);

    if (gdi_hdl_result != GDI_SUCCEED)
	{
		if (alpha_blending_flag)
			gdi_image_abm_set_source_layer(source_layer_handle);
		gdi_layer_pop_and_restore_active();
		gdi_layer_free(layer_handle);
		layer_handle = 0;
		return VM_GDI_ERR_PLATFORM_DECODE_FAILED;
	}
	if (alpha_blending_flag)
		gdi_image_abm_set_source_layer(source_layer_handle);

	gdi_layer_pop_and_restore_active();
	gdi_layer_free(layer_handle);
	layer_handle = 0;
	
	return VM_GDI_SUCCEED;
}


static VMINT vm_graphic_png_get_info(VMUINT8* png_data, VMINT png_len, IHDR_t *ihdr)
{
	VMUINT cursor = 0;
	
	if ((png_data == NULL) || (png_len <= 0))
	{
        MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_3099 );
		return VM_GDI_ERR_WRONG_PARAM;
	}
	ihdr->bitdepth = 0;
	ihdr->colortype = 0;
	ihdr->height = 0;
	ihdr->width = 0;
	
	cursor = 16;		// ´ÓIHDR¿ªÊ¼¶Á 

	ihdr->width = (*(png_data + cursor) <<24) + (*(png_data + cursor + 1) <<16) + (*(png_data + cursor + 2) <<8) + (*(png_data + cursor + 3) );
	cursor += 4;
	ihdr->height = (*(png_data + cursor) <<24) + (*(png_data + cursor + 1) <<16) + (*(png_data + cursor + 2) <<8) + (*(png_data + cursor + 3) );
	cursor += 4;
	ihdr->bitdepth = *(png_data + cursor);
	cursor += 1;
	ihdr->colortype = *(png_data + cursor); 
	
	return VM_GDI_SUCCEED;
}


static VMINT vm_graphic_gif_get_trans_color(VMUINT8* color_table, VMINT color_table_len, VMUINT16 *trans_color)
{
	if (color_table == NULL || color_table_len <= 0 || trans_color == NULL)
		return VM_GDI_ERR_WRONG_PARAM;
	*trans_color = VM_KEY_COLOR;

	return VM_GDI_SUCCEED;
}

static VMINT vm_graphic_gif_get_frames_prop(VMUINT8* gif, VMINT gif_len,VMINT *frame_count, struct frame_prop **frames_p)
{
	VMINT frame_index;
	gif_info_t image_info;
	VMINT cursor = 0;
	VMBYTE temp;

	VMINT file_end = 0;
	VMBYTE frame_info[14] = {0};	
	VMINT lFlag = 0;	
	VMINT lSize = 0;
	VMUINT16 trans_color = 0xfffe;
	VMINT gcolro_table_size = 0;
    GDI_RESULT gdi_hdl_result = GDI_SUCCEED;	    


	gdi_hdl_result = gdi_image_get_frame_count_mem(IMAGE_TYPE_GIF, gif, gif_len, frame_count);
    if (gdi_hdl_result != GDI_SUCCEED)
    {
  		MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_3148 );
       	return  VM_GDI_FAILED;
    }
	
	if (*frame_count <= 0)
		return VM_GDI_FAILED;
	
	if ((	*frames_p = (struct frame_prop *)vm_malloc_nc(sizeof(struct frame_prop) * (*frame_count))) == NULL)
	{
		*frame_count = 0;
		MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_3156 );
		return VM_GDI_ERR_MALLOC_FAILED;
	}
	memset(*frames_p, 0, sizeof(struct frame_prop) * (*frame_count));
	
	//Get global info  
	cursor += 6;	// Skip Signture and Version
	
	//Get Logical Screen Descriptior 	
	memcpy(&(image_info.scrWidth),gif+cursor,2); cursor += 2;	// Logic Screen Width
	memcpy(&(image_info.scrHeight),gif+cursor,2); cursor += 2;	// Logic Screen Height

	memcpy(&temp,gif+cursor,1); cursor +=1;		
	if((temp&0x80) != 0)	// Global Color Table Flag 
		image_info.gFlag = 1;	// Global Color Table exist
	else
		image_info.gFlag = 0;	// Global Color Table do not exist
	image_info.colorRes = ((temp&0x70)>>4)+1;
	if(image_info.gFlag)
	{
		if((temp&0x08) != 0)
			image_info.gSort = 1;
		else
			image_info.gSort = 0;
		image_info.gSize = temp&0x07;
	}
	
	memcpy(&(image_info.BKColorIdx),gif+cursor,1); cursor += 1;
	memcpy(&(image_info.pixelAspectRatio),gif+cursor,1); cursor += 1;

	if(image_info.gFlag)
	{	
		gcolro_table_size = (1<<(image_info.gSize+1))*3;
		vm_graphic_gif_get_trans_color(gif+cursor, gcolro_table_size, &trans_color);

		cursor += (1<<(image_info.gSize+1))*3;
	}
	else
		image_info.gColorTable = NULL;
	image_info.fsize = 0;
	
	frame_index = 0;
	while(cursor<gif_len && !file_end)
	{
		memset(frame_info, 0, 14);
		memcpy(&temp, gif+cursor, 1); cursor += 1;
		switch(temp)
		{
		case 0x21:		// Extension Descriptor
			memcpy(&temp,gif+cursor,1); cursor += 1;
			switch(temp)
			{	
			case 0xf9:		// Graphic Control Extension		
				while(cursor < gif_len)
				{	
					// Get Bock Size
					memcpy(&temp,gif+cursor,1); cursor += 1;
					if(temp == 0)
						break;
					if(temp == 4)
					{					
						// Get Transparent Color Flag
						memcpy(frame_info+10,gif+cursor,1); 
						(*frames_p)[frame_index].flag = (*(gif+cursor)) & 0x1;
						cursor += 1;	
						
						memcpy(frame_info+8,gif+cursor,2); 
						(*frames_p)[frame_index].delay_time = (*(gif+cursor)) + ((*(gif+cursor+1)) << 8);
						cursor += 2;	
						
						memcpy(frame_info+13,gif+cursor,1); cursor += 1;	
					}					
					else
						cursor += temp;
				}
				break;
			case 0xfe:		// Comment Extension
			case 0x01:		// Plain Text Extension
			case 0xff:		// Application Extension
				while(cursor<gif_len)
				{	
					memcpy(&temp,gif+cursor,1); cursor += 1;
					if(temp == 0)
						break;
					cursor += temp;
				}
				break;
			default:
				return VM_GDI_SUCCEED;
			}
			break;
		case 0x2c:	// Image Descriptor
		{	
			memcpy(frame_info,gif+cursor,2); 
			(*frames_p)[frame_index].left = (*(gif+cursor)) + ((*(gif+cursor+1)) << 8);
			cursor += 2;		

			memcpy(frame_info+2,gif+cursor,2); 
			(*frames_p)[frame_index].top = (*(gif+cursor)) + ((*(gif+cursor+1)) << 8);
			cursor += 2;	

			memcpy(frame_info+4,gif+cursor,2); 
			(*frames_p)[frame_index].width = (*(gif+cursor)) +((*(gif+cursor+1))  << 8);
			cursor += 2;	

			memcpy(frame_info+6,gif+cursor,2); 
			(*frames_p)[frame_index].height = (*(gif+cursor)) +((*(gif+cursor+1))  << 8);
			cursor += 2;	

			memcpy(&temp,gif+cursor,1); cursor += 1;			

			if((temp&0x80) != 0)
				lFlag = 1;			
			if(lFlag)
			{				
				lSize = temp&0x07;

				if (gcolro_table_size <=  (1<<(lSize+1))*3)
					vm_graphic_gif_get_trans_color(gif+cursor, (1<<(lSize+1))*3, &trans_color);

				cursor += (1<<(lSize+1))*3;				
			}
			else	
			{
				temp &=0xf8;// /*1111 1000*/
				temp |= 0x80 + image_info.gSize;// /*1000 0000*/
			}
			(*frames_p)[frame_index].trans_color	= trans_color;

			frame_info[11] = temp;
			memcpy(frame_info+12,gif+cursor,1); cursor += 1;//

			while(cursor<gif_len)
			{	
				memcpy(&temp,gif+cursor,1); cursor += 1;
				if(temp == 0)
					break;
				cursor += temp;
                }
                frame_index++;
                break;			
            }
        case 0x3b:	// Trailer
            file_end = 1;
            break;
        case 0x00:
            break;
        default:
            return VM_GDI_SUCCEED;
        }
    }

    return VM_GDI_SUCCEED;
}


static VMINT gif_get_imgprop(VMUINT8* img_data, VMINT img_len,vm_graphic_imgprop *img_prop)
{
	VMINT frame_count = 0;
	struct frame_prop *frames_p = NULL;
	VMINT i;
	VMINT img_width = 0;
	VMINT img_height = 0;

	if (vm_graphic_gif_get_frames_prop(img_data, img_len, &frame_count, &frames_p) < 0 
		|| frame_count <=0 || frames_p == NULL)
		return VM_GDI_FAILED;
	
	for ( i=0; i<frame_count; i++)
	{
	   	if (img_width < frames_p[i].width + frames_p[i].left)
			img_width = frames_p[i].width + frames_p[i].left;
	   	if (img_height < frames_p[i].height+ frames_p[i].top)
			img_height = frames_p[i].height + frames_p[i].top;
	}
	vm_free(frames_p);

	img_prop->height = img_height;
	img_prop->width= img_width;	
	
	return VM_GDI_SUCCEED;
}


static VMINT vm_graphic_gif_decode_frame_internal(vm_graphic_color_famat cf, VMUINT8* img_data, VMINT img_len, VMINT frame_index, struct frame_prop frame_p,VMUINT8 *frame_buffer,VMINT width,VMINT height,VMINT resized, VMINT isVirtual)
{
    gdi_handle gif_layer_handle = 0;
    VMINT buffer_size;
    VMINT layer_width;
    VMINT layer_height;    
	gdi_color_format color_format;
    VMINT ret;
	
    if(resized)
    {
		calculate_datasize_from_cf(cf, width, height, &buffer_size);
        layer_width = width;
        layer_height = height;
    }
    else
    {
		buffer_size = frame_p.offset;
        layer_width = frame_p.width;
        layer_height = frame_p.height;
    }
	
	convert_to_gdi_color_format(cf, &color_format);	
    if (gdi_layer_create_cf_using_outside_memory(color_format, 0, 0, layer_width, layer_height, 
        &gif_layer_handle, frame_buffer, buffer_size) != GDI_SUCCEED)
    {
        MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_3370 );
        return VM_GDI_ERR_CREATE_LAYER_FAILED;
    }
    if (gif_layer_handle == 0)
    {
        MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_3375 );
        return VM_GDI_ERR_CREATE_LAYER_FAILED;
    }	
    gdi_layer_push_and_set_active(gif_layer_handle);
    gdi_layer_set_source_key(TRUE, GDI_ACT_COLOR_FROM_RGB(frame_p.trans_color));
    gdi_layer_clear(GDI_ACT_COLOR_FROM_RGB(frame_p.trans_color));

    if (isVirtual)
    {
        if (resized)
        {
            gdi_layer_set_clip(0, 0, width, height);
            ret = gdi_image_draw_resized_frames(0, 0, width, height, img_data, (VMUINT16)frame_index);
        }
        else
        {
            gdi_layer_set_clip(0, 0, frame_p.width, frame_p.height);
            ret = gdi_image_draw_frames(0-frame_p.left, 0-frame_p.top, img_data, (VMUINT16)frame_index);
        }
    }
    else
    {
        if (resized)
        {
            gdi_layer_set_clip(0, 0, width, height);
            ret = gdi_image_draw_resized_mem_frames(0, 0, width, height, img_data, GDI_IMAGE_TYPE_GIF, (VMUINT)img_len, (VMUINT16)frame_index);
        }
        else
        {
            gdi_layer_set_clip(0, 0, frame_p.width, frame_p.height);
            ret = gdi_image_draw_mem_frames(0-frame_p.left, 0-frame_p.top, img_data, GDI_IMAGE_TYPE_GIF, (VMUINT)img_len, (VMUINT16)frame_index);
        }
    }
    
    MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_3391 ,ret,resized);
	gdi_layer_reset_clip();
    gdi_layer_pop_and_restore_active();
    gdi_layer_free(gif_layer_handle);
    gif_layer_handle = 0;
	
    return VM_GDI_SUCCEED;
}

static VMINT vm_graphic_gif_set_frame_prop_internal(vm_graphic_color_famat cf, VMUINT8* buffer, struct frame_prop *frame_p, VMINT width, VMINT height)
{
	VMINT data_size;
	
	if((buffer == NULL) || (frame_p == NULL))
		return VM_GDI_ERR_WRONG_PARAM;

	calculate_datasize_from_cf(cf, width, height, &data_size);	
	buffer[0] = frame_p->flag;
	buffer[1] = frame_p->left % 256;	buffer[2] = frame_p->left >> 8;	//left
	buffer[3] = frame_p->top % 256;	    buffer[4] = frame_p->top >> 8;	//top
	buffer[5] = width % 256;	buffer[6] = width>> 8;	//width
	buffer[7] = height % 256;	buffer[8] = height>> 8;		//height
	buffer[9] = frame_p->delay_time% 256;	buffer[10] = frame_p->delay_time >> 8;//delay
	buffer[11] = 0;
	buffer[12] = frame_p->trans_color % 256;	buffer[13] = frame_p->trans_color >> 8; //trans color
	buffer[14] = frame_p->is_resize;//if resized
	buffer[15] = 0; //reserved
	buffer[16] = data_size & 0x000000ff; 		//data size
	buffer[17] = (data_size & 0x0000ff00) >> 8; 
	buffer[18] = (data_size & 0x00ff0000) >> 16;
	buffer[19] = (data_size & 0xff000000) >> 24;
	
	return VM_GDI_SUCCEED;
}

static VMINT vm_graphic_gif_decode_internal(vm_graphic_color_famat cf, VMUINT8* img_data, VMINT img_len,VMINT width,VMINT height,VMINT percent, VMINT flag, VMINT isVirtual, VMINT start_frame_index, VMINT end_frame_index)
{
    VMINT frame_count = 0;
	VMINT decode_frame_start_index, decode_frame_end_index;
    VMINT i;
    struct frame_prop *frames_p = NULL;
    VMUINT8 *frame_buffer = NULL;
    VMUINT8 *frame_buffer_l = NULL;
    VMUINT8 *frame_data_buffer = NULL;
    VMUINT8 *frame_data_buffer_l = NULL;
    VMUINT8 * hcanvas = NULL;
    VMUINT8 * hcanvas_l = NULL;
    VMINT canvas_size = 0;
    VMINT canvas_size_l = 0;
    VMINT total_canvas_size = 0;
    VMINT total_canvas_size_l = 0;
    VMINT frame_data_size;
    VMINT frame_data_size_l;
    VMINT ret;
    VMINT width_l,height_l;

	if ((img_data == NULL) || (img_len <= 0))
	{
		MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_3475 );
		return VM_GDI_ERR_WRONG_PARAM;
	}
	
	// get property
	ret = vm_graphic_gif_get_frames_prop(img_data, img_len, &frame_count, &frames_p);
	if (ret < 0 || frame_count <=0 || frames_p == NULL)
	{
		MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_3482 );
		return VM_GDI_FAILED;
	}

	if ( start_frame_index > 0 )
	{
		if ( start_frame_index > frame_count || end_frame_index > frame_count )
		{
			if (frames_p != NULL)
			{
				vm_free(frames_p);
				frames_p = NULL;
			}
			return VM_GDI_FAILED;
		}
		else
		{
			decode_frame_start_index = start_frame_index - 1;
			decode_frame_end_index = end_frame_index - 1;
		}
	}
	else
	{
		decode_frame_start_index = 0;
		decode_frame_end_index = decode_frame_start_index + frame_count - 1;
	}
	
	total_canvas_size = VM_CANVAS_SIGNATURE_SIZE;
	for ( i = decode_frame_start_index; i <= decode_frame_end_index; i++)
	{
		if (flag == VM_GRAPHIC_GIF_DECODE_RESIZED)
		{
			calculate_datasize_from_cf(cf, width, height, &frame_data_size);
		}
		else
		{
			calculate_datasize_from_cf(cf, frames_p[i].width, frames_p[i].height, &frame_data_size);
			frames_p[i].offset = frame_data_size;
		}
		total_canvas_size += VM_CANVAS_FRAME_PROPERTY_SIZE + frame_data_size;
	}
	if ((hcanvas = (VMUINT8*)vm_malloc_nc(total_canvas_size)) == NULL)
	{
		MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_3497 );
		if (frames_p != NULL)
		{
			vm_free(frames_p);
			frames_p = NULL;
		}
		return VM_GDI_ERR_MALLOC_FAILED;		
	}
	memset(hcanvas, 0x00, total_canvas_size);
	memcpy(hcanvas, "MTKCANVAS", 9);
	hcanvas[VM_CANVAS_FRAME_NUM_OFFSET] = 0;
	hcanvas[VM_CANVAS_FRAME_NUM_OFFSET + 2] = cf;


	if (flag == VM_GRAPHIC_GIF_DECODE_RESIZED_BY_PERCENT)
	{
		total_canvas_size_l = VM_CANVAS_SIGNATURE_SIZE;
		for ( i = decode_frame_start_index; i <= decode_frame_end_index; i++)
		{
			calculate_datasize_from_cf(cf, frames_p[i].width * percent / 100, frames_p[i].height * percent / 100, &frame_data_size_l);	  
			total_canvas_size_l += VM_CANVAS_FRAME_PROPERTY_SIZE + frame_data_size_l;
		}
		if ((hcanvas_l = (VMUINT8*)vm_malloc_nc(total_canvas_size_l)) == NULL)
		{
			MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_3670 );
			if (frames_p != NULL)
			{
				vm_free(frames_p);
				frames_p = NULL;
			}
			vm_free(hcanvas);		
			return VM_GDI_ERR_MALLOC_FAILED;		
		}
		memset(hcanvas_l, 0x00, total_canvas_size_l);
		memcpy(hcanvas_l, "MTKCANVAS", 9);
		hcanvas_l[VM_CANVAS_FRAME_NUM_OFFSET] = 0;
		hcanvas_l[VM_CANVAS_FRAME_NUM_OFFSET + 2] = cf;
	}


	// delted by frames
	canvas_size = VM_CANVAS_SIGNATURE_SIZE;
	if (flag == VM_GRAPHIC_GIF_DECODE_RESIZED_BY_PERCENT)
	{
		canvas_size_l = VM_CANVAS_SIGNATURE_SIZE;
	}
	for ( i = decode_frame_start_index; i <= decode_frame_end_index; i++)
	{
		hcanvas[VM_CANVAS_FRAME_NUM_OFFSET] += 1;
		frame_buffer =	hcanvas + canvas_size;
	
		if (flag == VM_GRAPHIC_GIF_DECODE)
		{
		        frames_p[i].is_resize = 0;
			vm_graphic_gif_set_frame_prop_internal(cf, frame_buffer, &frames_p[i], frames_p[i].width, frames_p[i].height);
			frame_data_buffer =  hcanvas + canvas_size + VM_CANVAS_FRAME_PROPERTY_SIZE;
			frame_data_size = frames_p[i].offset;
			canvas_size += VM_CANVAS_FRAME_PROPERTY_SIZE + frame_data_size;
			vm_graphic_gif_decode_frame_internal(cf, img_data, img_len, i, frames_p[i], frame_data_buffer, 0, 0, FALSE, isVirtual);
		}
		else if (flag == VM_GRAPHIC_GIF_DECODE_RESIZED)
		{
		        frames_p[i].is_resize = 1;
			vm_graphic_gif_set_frame_prop_internal(cf, frame_buffer, &frames_p[i], width, height);
			frame_data_buffer =  hcanvas + canvas_size + VM_CANVAS_FRAME_PROPERTY_SIZE;
			calculate_datasize_from_cf(cf, width, height, &frame_data_size);
			canvas_size += VM_CANVAS_FRAME_PROPERTY_SIZE + frame_data_size;
			vm_graphic_gif_decode_frame_internal(cf, img_data, img_len, i, frames_p[i], frame_data_buffer, width, height, TRUE, isVirtual);

		}
		else if (flag == VM_GRAPHIC_GIF_DECODE_RESIZED_BY_PERCENT)
		{
		        frames_p[i].is_resize = 1;
			vm_graphic_gif_set_frame_prop_internal(cf, frame_buffer, &frames_p[i], frames_p[i].width, frames_p[i].height);
			hcanvas_l[VM_CANVAS_FRAME_NUM_OFFSET] += 1;
			frame_buffer_l =  hcanvas_l + canvas_size_l;
			vm_graphic_gif_set_frame_prop_internal(cf, frame_buffer_l, &frames_p[i], (frames_p[i].width)*percent/100, (frames_p[i].height)*percent/100);
			frame_data_buffer =  hcanvas + canvas_size + VM_CANVAS_FRAME_PROPERTY_SIZE;
			frame_data_size = frames_p[i].offset;
			canvas_size += VM_CANVAS_FRAME_PROPERTY_SIZE + frame_data_size;
			frame_data_buffer_l =  hcanvas_l + canvas_size_l + VM_CANVAS_FRAME_PROPERTY_SIZE;
			calculate_datasize_from_cf(cf, frames_p[i].width * percent /100, frames_p[i].height * percent / 100, &frame_data_size_l);		
			canvas_size_l += VM_CANVAS_FRAME_PROPERTY_SIZE + frame_data_size_l; 	
			vm_graphic_gif_decode_frame_internal(cf, img_data, img_len, i, frames_p[i], frame_data_buffer, 0, 0, FALSE, isVirtual);
			width_l = frames_p[i].width * percent /100;
			height_l = frames_p[i].height* percent /100;
			enlarge_image(cf, frame_data_buffer, frames_p[i].width, frames_p[i].height, frame_data_buffer_l, width_l, height_l);
		}
	}
	if (frames_p != NULL)
	{
		vm_free(frames_p);
		frames_p = NULL;
	}

	if (flag == VM_GRAPHIC_GIF_DECODE_RESIZED_BY_PERCENT)
	{
		vm_free(hcanvas);
		return (VMINT)hcanvas_l; 		
	}
	else
	{
		return (VMINT)hcanvas; 
	}
}


static VMINT vm_graphic_get_imgprop(VMUINT8 img_type, VMUINT8* img_data, VMINT img_len,vm_graphic_imgprop *img_prop)
{
	VMINT img_width, img_height;
	IHDR_t ihdr;			

	if ( img_type == GDI_IMAGE_TYPE_GIF )
		return VM_GDI_FAILED;

	if ( img_type == GDI_IMAGE_TYPE_AB2 )
	{
		img_data += 8;
		img_len -= 8;
	}

	if ( img_type == GDI_IMAGE_TYPE_PNG )
	{
		if ( vm_graphic_png_get_info(img_data, img_len, &ihdr) != GDI_SUCCEED )
			return VM_GDI_FAILED;
			
		img_prop->height = ihdr.height;
		img_prop->width = ihdr.width;
	}	
	else
	{
		if ( gdi_image_get_dimension_mem(img_type, img_data, img_len, &img_width, &img_height) != GDI_SUCCEED )
			return VM_GDI_FAILED;
		
		img_prop->height = img_height;
		img_prop->width= img_width; 
	}
	
	return VM_GDI_SUCCEED;
}


static VMINT vm_graphic_image_decode(VMUINT8 img_type, vm_graphic_color_famat cf, VMUINT8* img_data, VMINT img_len, VMINT flag)
{
	VMINT img_width, img_height;
	IHDR_t ihdr;		
	IHDR_t *pihdr = NULL;	
	VMINT hcanvas = 0;
	VMUINT8 *frame_buffer = NULL;
	VMINT buffer_size;
    VMINT result;
	GDI_RESULT ret;
	vm_graphic_color_argb trans_color_argb;
	
	if ( img_type == GDI_IMAGE_TYPE_GIF )
		return VM_GDI_FAILED;
	
	if ((img_data == NULL) || (img_len <= 0))
	{
        MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_3773 );
		return VM_GDI_ERR_WRONG_PARAM;
	}

	if ( img_type == GDI_IMAGE_TYPE_AB2 )
	{
		img_data += 8;
		img_len -= 8;
	}

	if ( img_type == GDI_IMAGE_TYPE_PNG )
	{
		pihdr = &ihdr;
		ret = vm_graphic_png_get_info(img_data, img_len, pihdr);
		img_width = pihdr->width;
		img_height = pihdr->height;
	}	
	else
	{
			// virtual image virtual 4
	    if(img_type==GDI_IMAGE_TYPE_BMP_FILE_OFFSET)
        {   
		    ret = gdi_image_get_dimension(img_data,&img_width, &img_height);
        }
        else
        {
            ret = gdi_image_get_dimension_mem(img_type, img_data, img_len, &img_width, &img_height);
        }	
	}
	if (ret != GDI_SUCCEED)
	{
        MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_3796 , ret);
		return VM_GDI_FAILED;
	}
	
	if ((hcanvas = vm_graphic_create_decode_canvas_internal(cf, img_width,img_height, &frame_buffer, &buffer_size)) <= 0)
    {
        MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_3802 );
		return VM_GDI_ERR_CREATE_CANVAS_FAILED;
    }

	if ((result = vm_graphic_decode_internal(cf, frame_buffer, buffer_size, img_data, img_len, img_width, img_height, img_type, pihdr, FALSE, flag)) < 0)
	{
		vm_graphic_release_canvas(hcanvas);
		return result;
	}

	if ( cf == VM_GRAPHIC_COLOR_FORMAT_16 || cf == VM_GRAPHIC_COLOR_FORMAT_24 )
	{
		if (cf == VM_GRAPHIC_COLOR_FORMAT_16)
		{
			trans_color_argb.a = 255;
			trans_color_argb.r = 248;
			trans_color_argb.g = 252;
			trans_color_argb.b = 232;
		}
		else
		{
			trans_color_argb.a = 255;
			trans_color_argb.r = 255;
			trans_color_argb.g = 254;
			trans_color_argb.b = 253;
		}
	
		if ( img_type == GDI_IMAGE_TYPE_AB2 ) 
			vm_graphic_canvas_set_trans_color_argb(hcanvas, &trans_color_argb);
		else if ( flag && img_type == GDI_IMAGE_TYPE_PNG && pihdr->colortype > 3 )
			vm_graphic_canvas_set_trans_color_argb(hcanvas, &trans_color_argb);
		else if ( !flag && img_type == GDI_IMAGE_TYPE_PNG )
			vm_graphic_canvas_set_trans_color_argb(hcanvas, &trans_color_argb);
	}
	
	return hcanvas;
}


static VMINT vm_graphic_image_decode_resized(VMUINT8 img_type, vm_graphic_color_famat cf, VMUINT8* img_data, VMINT img_len, VMINT width, VMINT height, VMINT flag)
{
	VMINT img_width, img_height;
	IHDR_t ihdr;	
	IHDR_t *pihdr = NULL;	
	VMINT hcanvas = 0, hcanvas_l = 0;
	VMUINT8 *frame_buffer = NULL;
	VMUINT8 *frame_buffer_l = NULL;
	VMINT buffer_size, buffer_size_l;
    VMINT result;
	GDI_RESULT ret;
	VMINT tmp_width, tmp_height;	
	vm_graphic_color_argb trans_color_argb;
 
	if ( img_type == GDI_IMAGE_TYPE_GIF )
		return VM_GDI_FAILED;
	
	if ((img_data == NULL) || (img_len <= 0))
	{
        MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_3840 );
		return VM_GDI_ERR_WRONG_PARAM;
	}

	if ( img_type == GDI_IMAGE_TYPE_AB2 )
	{
		img_data += 8;
		img_len -= 8;
	}

	if ( img_type == GDI_IMAGE_TYPE_PNG )
	{
		pihdr = &ihdr;
		ret = vm_graphic_png_get_info(img_data, img_len, pihdr);
		img_width = pihdr->width;
		img_height = pihdr->height;
	}	
	else
	{
			// virtual image virtual 5
		if(img_type==GDI_IMAGE_TYPE_BMP_FILE_OFFSET)
        {   
		    ret = gdi_image_get_dimension(img_data,&img_width, &img_height);
        }
        else
        {
            ret = gdi_image_get_dimension_mem(img_type, img_data, img_len, &img_width, &img_height);
        }			
	}
	if (ret != GDI_SUCCEED)
	{
        MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_3863 );
		return  VM_GDI_FAILED;
	}
	
	if ((width == img_width) && (height == img_height))
		return vm_graphic_image_decode(img_type, cf, img_data, img_len, flag);
	else if ((width < img_width) && (height < img_height))
	{
	    if ((hcanvas = vm_graphic_create_decode_canvas_internal(cf, width, height, &frame_buffer, &buffer_size)) <= 0)
        {
            MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_3873 );
		    return VM_GDI_ERR_CREATE_CANVAS_FAILED;
        }
		if ((result = vm_graphic_decode_internal(cf, frame_buffer, buffer_size, img_data, img_len, width, height, img_type, pihdr, TRUE, flag)) < 0)
		{
			vm_graphic_release_canvas(hcanvas);
            MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_3879 );
			return result;
		}
		if ( cf == VM_GRAPHIC_COLOR_FORMAT_16 || cf == VM_GRAPHIC_COLOR_FORMAT_24 )
		{
			if (cf == VM_GRAPHIC_COLOR_FORMAT_16)
			{
				trans_color_argb.a = 255;
				trans_color_argb.r = 248;
				trans_color_argb.g = 252;
				trans_color_argb.b = 232;
			}
			else
			{
				trans_color_argb.a = 255;
				trans_color_argb.r = 255;
				trans_color_argb.g = 254;
				trans_color_argb.b = 253;
			}
		
			if ( img_type == GDI_IMAGE_TYPE_AB2 ) 
				vm_graphic_canvas_set_trans_color_argb(hcanvas, &trans_color_argb);
			else if ( flag && img_type == GDI_IMAGE_TYPE_PNG && pihdr->colortype > 3 )
				vm_graphic_canvas_set_trans_color_argb(hcanvas, &trans_color_argb);
			else if ( !flag && img_type == GDI_IMAGE_TYPE_PNG )
				vm_graphic_canvas_set_trans_color_argb(hcanvas, &trans_color_argb);
		}
		return hcanvas;
	}
	else if ((width > img_width) && (height > img_height))
	{
	    if ((hcanvas = vm_graphic_create_decode_canvas_internal(cf, img_width, img_height, &frame_buffer, &buffer_size)) <= 0)
        {
            MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_3891 );
		    return VM_GDI_ERR_CREATE_CANVAS_FAILED;
        }
		if ((result = vm_graphic_decode_internal(cf, frame_buffer, buffer_size, img_data, img_len, img_width, img_height, img_type, pihdr, FALSE, flag)) < 0)
		{
			vm_graphic_release_canvas(hcanvas);
            MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_3897 );
			return  result;
		}
        if ((hcanvas_l = vm_graphic_create_decode_canvas_internal(cf, width, height, &frame_buffer_l, &buffer_size_l)) <= 0)
        {
            vm_graphic_release_canvas(hcanvas);
            return VM_GDI_ERR_CREATE_CANVAS_FAILED;
        }
		enlarge_image(cf, frame_buffer, img_width, img_height, frame_buffer_l, width, height);
		vm_graphic_release_canvas(hcanvas);
		if ( cf == VM_GRAPHIC_COLOR_FORMAT_16 || cf == VM_GRAPHIC_COLOR_FORMAT_24 )
		{
			if (cf == VM_GRAPHIC_COLOR_FORMAT_16)
			{
				trans_color_argb.a = 255;
				trans_color_argb.r = 248;
				trans_color_argb.g = 252;
				trans_color_argb.b = 232;
			}
			else
			{
				trans_color_argb.a = 255;
				trans_color_argb.r = 255;
				trans_color_argb.g = 254;
				trans_color_argb.b = 253;
			}
		
			if ( img_type == GDI_IMAGE_TYPE_AB2 ) 
				vm_graphic_canvas_set_trans_color_argb(hcanvas_l, &trans_color_argb);
			else if ( flag && img_type == GDI_IMAGE_TYPE_PNG && pihdr->colortype > 3 )
				vm_graphic_canvas_set_trans_color_argb(hcanvas_l, &trans_color_argb);
			else if ( !flag && img_type == GDI_IMAGE_TYPE_PNG )
				vm_graphic_canvas_set_trans_color_argb(hcanvas_l, &trans_color_argb);
		}
		return hcanvas_l;		
	}
	else
	{
		if (width >  img_width)
			tmp_width = img_width;
		else
			tmp_width = width;

		if (height >  img_height)
			tmp_height = img_height;
		else
			tmp_height = height;
			
		if ((hcanvas = vm_graphic_create_decode_canvas_internal(cf, tmp_width, tmp_height, &frame_buffer, &buffer_size)) <= 0)
		{
				MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_3928 );
			return VM_GDI_ERR_CREATE_CANVAS_FAILED;
		}
		if ((result = vm_graphic_decode_internal(cf, frame_buffer, buffer_size, img_data, img_len, tmp_width, tmp_height, img_type, pihdr, TRUE, flag)) < 0)
		{
			vm_graphic_release_canvas(hcanvas);
			MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_3934 );
			return	result;
		}

		if ((hcanvas_l = vm_graphic_create_decode_canvas_internal(cf, width, height, &frame_buffer_l, &buffer_size_l)) <= 0)
		{
			vm_graphic_release_canvas(hcanvas);
			return VM_GDI_ERR_CREATE_CANVAS_FAILED;
		}
		enlarge_image(cf, frame_buffer, tmp_width, tmp_height, frame_buffer_l, width, height);		
		vm_graphic_release_canvas(hcanvas);
		if ( cf == VM_GRAPHIC_COLOR_FORMAT_16 || cf == VM_GRAPHIC_COLOR_FORMAT_24 )
		{
			if (cf == VM_GRAPHIC_COLOR_FORMAT_16)
			{
				trans_color_argb.a = 255;
				trans_color_argb.r = 248;
				trans_color_argb.g = 252;
				trans_color_argb.b = 232;
			}
			else
			{
				trans_color_argb.a = 255;
				trans_color_argb.r = 255;
				trans_color_argb.g = 254;
				trans_color_argb.b = 253;
			}
		
			if ( img_type == GDI_IMAGE_TYPE_AB2 ) 
				vm_graphic_canvas_set_trans_color_argb(hcanvas_l, &trans_color_argb);
			else if ( flag && img_type == GDI_IMAGE_TYPE_PNG && pihdr->colortype > 3 )
				vm_graphic_canvas_set_trans_color_argb(hcanvas_l, &trans_color_argb);
			else if ( !flag && img_type == GDI_IMAGE_TYPE_PNG )
				vm_graphic_canvas_set_trans_color_argb(hcanvas_l, &trans_color_argb);
		}
		return hcanvas_l;	
	}
}


static VMINT _vm_graphic_load_image(vm_graphic_color_famat cf, VMUINT8 *img_data, VMINT img_len, VMINT flag)
// The parameter flag is for foreward compatibilty. If old API, it will not handle png transparent for color type 0, 2, 3
{
	VMUINT8 img_type = 0;
    VMINT ret;
    
    MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_3961 ,img_data);    
	
	if ( (img_data == NULL) || (img_len <= 0) )
	{
		MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_3964 );
		return VM_GDI_ERR_WRONG_PARAM;
	}

	ret = vm_graphic_get_img_type(img_data, &img_type);
	if (ret != VM_GDI_SUCCEED)
		return ret;

	if (img_type == GDI_IMAGE_TYPE_GIF || img_type == GDI_IMAGE_TYPE_GIF_FILE_OFFSET)
	{
	     VMINT isVirtual = (img_type == GDI_IMAGE_TYPE_GIF) ? FALSE : TRUE;
		ret = vm_graphic_gif_decode_internal(cf, img_data, img_len, 0, 0, 0, VM_GRAPHIC_GIF_DECODE, isVirtual, 0, 0);
		if (ret < 0)
		{
			MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_3977 );
			return ret;
		}
		return ret;
	}
	else
	{
		ret = vm_graphic_image_decode(img_type, cf, img_data, img_len, flag);
		if (ret < 0)
		{
			MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_3987 );
			return ret;
		}
		return ret;
	}
}

VMINT vm_graphic_load_image(VMUINT8 *img_data, VMINT img_len)
{
	return _vm_graphic_load_image(VM_GRAPHIC_COLOR_FORMAT_16, img_data, img_len, TRUE);
}

VMINT vm_graphic_load_image_cf(vm_graphic_color_famat cf, VMUINT8 *img_data, VMINT img_len)
{
	if ( !is_color_format_valid(cf) )
	{
		return VM_GDI_ERR_WRONG_PARAM;
	}

	return _vm_graphic_load_image(cf, img_data, img_len, FALSE);
}


static VMINT _vm_graphic_load_image_resized(vm_graphic_color_famat cf, VMUINT8 *img_data, VMINT img_len, VMINT width, VMINT height, VMINT flag)
{
	VMUINT8 img_type = 0;
	VMINT ret;

	if ((width <= 0) || (height <=  0))
    {
		return VM_GDI_ERR_WRONG_PARAM;
    }
	if ((img_data == NULL) || (img_len <= 0))
	{
        MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_4022 );
		return VM_GDI_ERR_WRONG_PARAM;
	}

	ret = vm_graphic_get_img_type(img_data, &img_type);
	if (ret != VM_GDI_SUCCEED)
		return ret;

	if (img_type == GDI_IMAGE_TYPE_GIF || img_type == GDI_IMAGE_TYPE_GIF_FILE_OFFSET)
	{
	     VMINT isVirtual = (img_type == GDI_IMAGE_TYPE_GIF) ? FALSE : TRUE;
		ret = vm_graphic_gif_decode_internal(cf, img_data, img_len, width, height, 0, VM_GRAPHIC_GIF_DECODE_RESIZED, isVirtual, 0, 0);
		if (ret < 0)
		{
			MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_4035 );
			return ret;
		}
		return ret;
	}
	else
	{
		ret = vm_graphic_image_decode_resized(img_type, cf, img_data, img_len, width, height, flag);
		if (ret < 0)
		{
			MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_4045 );
			return ret;
		}
		return ret;
	}
}


VMINT vm_graphic_load_image_resized(VMUINT8 *img_data, VMINT img_len,VMINT width,VMINT height)
{
	return _vm_graphic_load_image_resized(VM_GRAPHIC_COLOR_FORMAT_16, img_data, img_len, width, height, TRUE);
}

VMINT vm_graphic_load_image_resized_cf(vm_graphic_color_famat cf, VMUINT8 *img_data, VMINT img_len,VMINT width,VMINT height)
{
	if ( !is_color_format_valid(cf) )
	{
		return VM_GDI_ERR_WRONG_PARAM;
	}

	return _vm_graphic_load_image_resized(cf, img_data, img_len, width, height, FALSE);
}


static VMINT _vm_graphic_load_gif_resized_by_percent(vm_graphic_color_famat cf, VMUINT8 *img_data, VMINT img_len,VMINT percent)
{
    VMINT ret;
    VMUINT8 img_type;
	
    if ((img_data  == NULL) ||( img_len <=0)||(percent <= 100))
    {
		return VM_GDI_ERR_WRONG_PARAM;
    }
	
    ret = vm_graphic_get_img_type(img_data, &img_type);
    if (ret != VM_GDI_SUCCEED)
    	   return ret;
		
    if (img_type == GDI_IMAGE_TYPE_GIF || img_type == GDI_IMAGE_TYPE_GIF_FILE_OFFSET)
    {
        VMINT isVirtual = (img_type == GDI_IMAGE_TYPE_GIF) ? FALSE : TRUE;
        
        ret = vm_graphic_gif_decode_internal(cf, img_data, img_len, 0, 0, percent, VM_GRAPHIC_GIF_DECODE_RESIZED_BY_PERCENT, isVirtual, 0, 0);
    	   if (ret < 0)
    	   {
    		  MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_4082 );
    		  return ret;
    	   }
    }
    else
    {
        return VM_GDI_ERR_UNSUPPORT_IMAGE_TYPE;
    }

    return ret;	
}

VMINT vm_graphic_load_gif_resized_by_percent(VMUINT8 *img_data, VMINT img_len,VMINT percent)
{
	return _vm_graphic_load_gif_resized_by_percent(VM_GRAPHIC_COLOR_FORMAT_16, img_data, img_len, percent);
}

VMINT vm_graphic_load_gif_resized_by_percent_cf(vm_graphic_color_famat cf, VMUINT8 *img_data, VMINT img_len,VMINT percent)
{
	if ( !is_color_format_valid(cf) )
	{
		return VM_GDI_ERR_WRONG_PARAM;
	}

	return _vm_graphic_load_gif_resized_by_percent(cf, img_data, img_len, percent);
}

static VMINT _vm_graphic_load_gif_frame(vm_graphic_color_famat cf, VMUINT8 *img_data, VMINT img_len, VMINT width, VMINT height, VMINT percent, VMINT flag, VMINT start_frame_index, VMINT end_frame_index)
{
    VMINT ret;
    VMUINT8 img_type;

    if ((img_data == NULL) ||(img_len <= 0) 
    	|| (start_frame_index <= 0) || (end_frame_index <= 0)
    	|| (start_frame_index > end_frame_index) )
    {
    	   return VM_GDI_ERR_WRONG_PARAM;
    }

    if (!is_color_format_valid(cf) )
    {
    	   return VM_GDI_ERR_WRONG_PARAM;
    }

    ret = vm_graphic_get_img_type(img_data, &img_type);
    if (ret != VM_GDI_SUCCEED)
    	   return ret;
		
    if (img_type == GDI_IMAGE_TYPE_GIF || img_type == GDI_IMAGE_TYPE_GIF_FILE_OFFSET)
    {
        VMINT isVirtual = (img_type == GDI_IMAGE_TYPE_GIF) ? FALSE : TRUE;
        ret = vm_graphic_gif_decode_internal(cf, img_data, img_len, width, height, percent, flag, isVirtual, start_frame_index, end_frame_index);
        if (ret < 0)
        {
        	  return ret;
        }
    }
    else
    {
        return VM_GDI_ERR_UNSUPPORT_IMAGE_TYPE;
    }

    return ret;	
}

VMINT vm_graphic_load_gif_frame(VMUINT8 *img_data, VMINT img_len, VMINT start_frame_index, VMINT end_frame_index)
{
	return _vm_graphic_load_gif_frame(VM_GRAPHIC_COLOR_FORMAT_16, img_data, img_len, 0, 0, 0, VM_GRAPHIC_GIF_DECODE, start_frame_index, end_frame_index);
}

VMINT vm_graphic_load_gif_frame_cf(vm_graphic_color_famat cf, VMUINT8 *img_data, VMINT img_len, VMINT start_frame_index, VMINT end_frame_index)
{
	return _vm_graphic_load_gif_frame(cf, img_data, img_len, 0, 0, 0, VM_GRAPHIC_GIF_DECODE, start_frame_index, end_frame_index);
}

VMINT vm_graphic_load_gif_frame_resized(VMUINT8 *img_data, VMINT img_len,VMINT width,VMINT height, VMINT start_frame_index, VMINT end_frame_index)
{
	return _vm_graphic_load_gif_frame(VM_GRAPHIC_COLOR_FORMAT_16, img_data, img_len, width, height, 0, VM_GRAPHIC_GIF_DECODE_RESIZED, start_frame_index, end_frame_index);
}

VMINT vm_graphic_load_gif_frame_resized_cf(vm_graphic_color_famat cf, VMUINT8 *img_data, VMINT img_len,VMINT width,VMINT height, VMINT start_frame_index, VMINT end_frame_index)
{
	return _vm_graphic_load_gif_frame(cf, img_data, img_len, width, height, 0, VM_GRAPHIC_GIF_DECODE_RESIZED, start_frame_index, end_frame_index);
}

VMINT vm_graphic_load_gif_frame_resized_by_percent(VMUINT8 *img_data, VMINT img_len,VMINT percent, VMINT start_frame_index, VMINT end_frame_index)
{
	if (percent <= 100)
    {
		return VM_GDI_ERR_WRONG_PARAM;
    }

	return _vm_graphic_load_gif_frame(VM_GRAPHIC_COLOR_FORMAT_16, img_data, img_len, 0, 0, percent, VM_GRAPHIC_GIF_DECODE_RESIZED_BY_PERCENT, start_frame_index, end_frame_index);
}

VMINT vm_graphic_load_gif_frame_resized_by_percent_cf(vm_graphic_color_famat cf, VMUINT8 *img_data, VMINT img_len,VMINT percent, VMINT start_frame_index, VMINT end_frame_index)
{
	if (percent <= 100)
    {
		return VM_GDI_ERR_WRONG_PARAM;
    }

	return _vm_graphic_load_gif_frame(cf, img_data, img_len, 0, 0, percent, VM_GRAPHIC_GIF_DECODE_RESIZED_BY_PERCENT, start_frame_index, end_frame_index);
}

VM_GDI_RESULT vm_graphic_get_img_property_ex(VMUINT8 *img_data, VMINT img_len,vm_graphic_imgprop * img_prop)
{
	VMUINT8 img_type = 0;
	VMINT ret;
	
	if ((img_data  == NULL) ||( img_len <=0)|| (img_prop == NULL))
    {
		return VM_GDI_ERR_WRONG_PARAM;
    }

	ret = vm_graphic_get_img_type(img_data, &img_type);
	if (ret != VM_GDI_SUCCEED)
		return ret;
	
	if (img_type == GDI_IMAGE_TYPE_GIF)
	{
		ret = gif_get_imgprop(img_data, img_len,img_prop);
		if (ret < 0)
		{
			MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_4125 );
			return VM_GDI_FAILED;
		}
		return ret;
	}
	else
	{
		ret = vm_graphic_get_imgprop(img_type, img_data, img_len, img_prop);
		if (ret < 0)
		{
			MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_4135 );
			return VM_GDI_FAILED;
		}
		return ret;
	}
}

VM_GDI_RESULT vm_graphic_get_img_property_from_file(const VMWSTR filename, vm_graphic_imgprop * img_prop)
{
	VMINT img_width, img_height;
	VMINT ret;
	
	if (filename == NULL || img_prop == NULL)
	{
		return VM_GDI_ERR_WRONG_PARAM;		
	}

	ret = gdi_image_get_dimension_file((S8 *)filename, &img_width, &img_height);
	if (ret < 0)
	{
		return VM_GDI_FAILED;
	}
	else
	{
		img_prop->width = img_width;
		img_prop->height = img_height;
	}
	return ret;
}

static VMINT vm_graphic_draw_image_from_memory_internal(VM_GDI_HANDLE dest_layer_handle,VMUINT8* img_data,VMINT img_len,VMINT x,VMINT y,VMINT resized_width,VMINT resized_height,VMBOOL flag, VMINT frame_idx)
{
	VMUINT8 img_type = 0;
    VMINT ret = 0;
    
	if (layer_operation_permission_check() < 0)
	{
		return VM_GDI_MIBR_NOT_FORE;	
    }

    MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_4153 ,dest_layer_handle,x,y,img_data,img_len);

	if (INVALID_MRE_HANDLE(dest_layer_handle) 
		|| img_data == NULL
		|| img_len <=0
		|| (flag == TRUE && ( resized_width<=0 || resized_height<=0 ) ) )
	{
        MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_4157 );
		return VM_GDI_ERR_WRONG_PARAM;		
	}

	ret = vm_graphic_get_img_type(img_data, &img_type);
	if (ret != VM_GDI_SUCCEED)
		return ret;

    MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_4165 ,img_type);

	gdi_layer_push_and_set_active(SAL_HANDLE(dest_layer_handle));	

	if (img_type == GDI_IMAGE_TYPE_AB2)
	{
        img_data += 8;
        img_len -= 8;
	}

	if (flag == TRUE)
	{    // virtual image virtual 7
        if (img_type == GDI_IMAGE_TYPE_BMP_FILE_OFFSET)
            ret = gdi_image_draw_resized(x, y, resized_width, resized_height, img_data);
        else if (img_type == GDI_IMAGE_TYPE_GIF_FILE_OFFSET)
            ret = gdi_image_draw_resized_frames(x, y, resized_width, resized_height, img_data, frame_idx);
        else if (img_type == GDI_IMAGE_TYPE_GIF)
	       ret = gdi_image_draw_resized_mem_frames(x, y,  resized_width, resized_height, img_data, img_type, img_len, frame_idx);
        else
            ret = gdi_image_draw_resized_mem(x, y, resized_width, resized_height, img_data, img_type,img_len);
	}
	else
	{	// virtual image virtual 6
	   if (img_type == GDI_IMAGE_TYPE_BMP_FILE_OFFSET)
		  ret = gdi_image_draw(x,y,img_data);
	   else if (img_type == GDI_IMAGE_TYPE_GIF_FILE_OFFSET)
            ret = gdi_image_draw_frames(x, y, img_data, frame_idx);
	   else if (img_type == GDI_IMAGE_TYPE_GIF)
	       ret = gdi_image_draw_mem_frames(x, y, img_data, img_type, img_len, frame_idx);
	   else
		  ret = gdi_image_draw_mem(x, y, img_data, img_type, img_len);
	}
	
    MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_4176 ,ret);
	
	gdi_layer_pop_and_restore_active();

	return VM_GDI_SUCCEED;
}

VMINT vm_graphic_draw_image_from_memory(VM_GDI_HANDLE dest_layer_handle,VMINT x,VMINT y,VMUINT8* img_data,VMINT img_len)
{
	return vm_graphic_draw_image_from_memory_internal(dest_layer_handle, img_data, img_len, x, y, 0, 0, FALSE, 0);
}

VMINT vm_graphic_draw_resized_image_from_memory(VM_GDI_HANDLE dest_layer_handle,VMINT x,VMINT y,VMINT resized_width,VMINT resized_height,VMUINT8* img_data,VMINT img_len)
{
	return vm_graphic_draw_image_from_memory_internal(dest_layer_handle, img_data, img_len, x, y, resized_width, resized_height, TRUE, 0);
}

VMINT vm_graphic_draw_gif_image_from_memory(VM_GDI_HANDLE dest_layer_handle,VMINT x,VMINT y,VMUINT8* img_data,VMINT img_len, VMINT frame_idx)
{
	return vm_graphic_draw_image_from_memory_internal(dest_layer_handle, img_data, img_len, x, y, 0, 0, FALSE, frame_idx);
}

VMINT vm_graphic_draw_resized_gif_image_from_memory(VM_GDI_HANDLE dest_layer_handle,VMINT x,VMINT y,VMINT resized_width,VMINT resized_height,VMUINT8* img_data,VMINT img_len, VMINT frame_idx)
{
	return vm_graphic_draw_image_from_memory_internal(dest_layer_handle, img_data, img_len, x, y, resized_width, resized_height, TRUE, frame_idx);
}



static VMINT vm_graphic_draw_resized_image_from_file_internal(VM_GDI_HANDLE dest_layer_handle, VMINT x, VMINT y, VMINT resized_width, VMINT resized_height, const VMWSTR filename, VMBOOL flag)
{
    VMINT ret = 0;
	
	if (layer_operation_permission_check() < 0)
	{
		return VM_GDI_MIBR_NOT_FORE;	
    }

    MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_4255 ,dest_layer_handle,x,y,resized_width,resized_height);

	if (INVALID_MRE_HANDLE(dest_layer_handle) 
		|| filename == NULL 
		|| ( flag == TRUE && (resized_width<=0 ||resized_height<=0) ) )
	{
        MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_4259 );
		return VM_GDI_ERR_WRONG_PARAM;		
	}

	gdi_layer_push_and_set_active(SAL_HANDLE(dest_layer_handle));	

	if (flag == TRUE)
	{
		ret = gdi_image_draw_resized_file(x, y, resized_width, resized_height, filename);
	}
	else
	{
		ret = gdi_image_draw_file(x, y, filename);
	}
	
    MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_4265 ,ret);
	
	gdi_layer_pop_and_restore_active();
	
	return VM_GDI_SUCCEED;
}

VMINT vm_graphic_draw_image_from_file(VM_GDI_HANDLE dest_layer_handle, VMINT x, VMINT y, const VMWSTR filename)
{
	return vm_graphic_draw_resized_image_from_file_internal(dest_layer_handle, x, y, 0, 0, filename, FALSE);
}

VMINT vm_graphic_draw_resized_image_from_file(VM_GDI_HANDLE dest_layer_handle, VMINT x, VMINT y, VMINT resized_width, VMINT resized_height, const VMWSTR filename)
{
	return vm_graphic_draw_resized_image_from_file_internal(dest_layer_handle, x, y, resized_width, resized_height, filename, TRUE);
}


VM_GDI_RESULT vm_graphic_flatten_layer_ex(VMINT *hhandle,VMINT count)
{
	gdi_handle flatten_handles[MAX_FLATTEN_LAYER];
	VMINT err = TRUE;
	VMINT i;
	
	if ((count > MAX_FLATTEN_LAYER) ||(hhandle == NULL))
		return VM_GDI_ERR_WRONG_PARAM;

	for (i = 0; i < MAX_FLATTEN_LAYER; i++) 
	{
        flatten_handles[i] = 0;
        if (i < count) 
			if (VALID_MRE_HANDLE(hhandle[i]))
				flatten_handles[i] = layer_trans_tbl[hhandle[i]].handle;
	}
	
    MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_4287 ,flatten_handles[0],flatten_handles[1],flatten_handles[2],flatten_handles[3]);	

	//if all handle is 0, return error
	for (i=0;i<MAX_FLATTEN_LAYER;i++)
	{
		if(flatten_handles[i])
		{
			err = FALSE;
			break;
		}
	}	
	if (err)
		return VM_GDI_FAILED;
	
    gdi_layer_flatten_ext(
		flatten_handles[0] ,
		flatten_handles[1] ,
		flatten_handles[2] ,
		flatten_handles[3] ,
		0,
		0);

	return VM_GDI_SUCCEED;
}


VM_GDI_RESULT vm_graphic_flatten_layer(VMINT *hhandle,VMINT count)
{
    VMINT i;
    VM_GDI_RESULT ret;
	vm_graphic_cb *current_cb;

	current_cb = vm_graphic_get_current_cb();
	if (current_cb == NULL)
		return VM_GDI_FAILED;	
	
    ret = vm_graphic_flatten_layer_ex(hhandle,count);
    if (ret != VM_GDI_SUCCEED)
    {
        return ret;
    }

    MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_4329 , current_cb->active_layer);
	
	for(i=0;i<count;i++)
	{
		if ((VALID_MRE_HANDLE(hhandle[i])) && (hhandle[i] != current_cb->active_layer))
			if (vm_graphic_delete_layer(hhandle[i]) < 0)
				return VM_GDI_ERR_FREE_RES; 
	}
	
	return VM_GDI_SUCCEED;
}


VM_GDI_RESULT  vm_graphic_flatten_canvas_ex(VMINT *hcanvas,VMINT count)
{
	VMINT handles[MAX_FLATTEN_LAYER];
	gdi_handle flatten_handles[MAX_FLATTEN_LAYER];
	VMINT err = TRUE;
	VMINT i;
	
	if ((count > MAX_FLATTEN_LAYER) ||(hcanvas == NULL))
		return VM_GDI_ERR_WRONG_PARAM;
	
	//set init as -1
	for (i=0;i<MAX_FLATTEN_LAYER;i++)
		handles[i] = -1;

	//finc canvas layer, if not find return -1
	for(i=0;i<count;i++)
	{
        if (VALID_MRE_HANDLE(handles[i]))
            if ((handles[i] = find_layer((VMUINT8 *)hcanvas[i])) <= 0)
			    handles[i] = -1;
	}
	
    MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_4360 ,handles[0],handles[1],handles[2],handles[3]);

	for (i = 0; i < MAX_FLATTEN_LAYER; i++) 
	{
        flatten_handles[i] = 0;
        if (i < count) 
			if (VALID_MRE_HANDLE(handles[i]))
				flatten_handles[i] = layer_trans_tbl[handles[i]].handle;
	}
	
    MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_4369 ,flatten_handles[0],flatten_handles[1],flatten_handles[2],flatten_handles[3]);	

	for (i=0;i<MAX_FLATTEN_LAYER;i++)
	{
		if(flatten_handles[i])
		{
			err = FALSE;
			break;
		}
	}	
	if (err)
		return VM_GDI_FAILED;
	
    gdi_layer_flatten_ext(
		flatten_handles[0] ,
		flatten_handles[1] ,
		flatten_handles[2] ,
		flatten_handles[3] ,
		0,
		0);
	
	return VM_GDI_SUCCEED;	 
}


VM_GDI_RESULT  vm_graphic_flatten_canvas(VMINT *hcanvas,VMINT count)
{
	VMINT i;
    VM_GDI_RESULT ret;
	vm_graphic_cb *current_cb;

	current_cb = vm_graphic_get_current_cb();
	if (current_cb == NULL)
		return VM_GDI_FAILED;	

    ret = vm_graphic_flatten_canvas_ex(hcanvas,count);
    if (ret != VM_GDI_SUCCEED)
    {
        return ret;
    }
    
    MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_4411 , current_cb->active_layer);
	
	for(i=0;i<count;i++)
	{
		if (find_layer((VMUINT8 *)hcanvas[i]) != current_cb->active_layer)
			vm_graphic_release_canvas_ex(hcanvas[i]);
	}
	
	return VM_GDI_SUCCEED;	 
}


VM_GDI_RESULT  vm_graphic_resize_layer(VMINT handle,VMINT width,VMINT height)
{
	VMINT lx,ly,lw,lh;
	
	if ((INVALID_MRE_HANDLE(handle)) || (width <= 0) || (height <= 0))
		return VM_GDI_ERR_WRONG_PARAM;	
	if (vm_graphic_get_layer_porp_from_layer(handle, &lx, &ly,  &lw,  &lh) < 0)
		return VM_GDI_FAILED;
	if ((width > lw) || (height > lh))
		return VM_GDI_ERR_WRONG_PARAM;

	return vm_graphic_sal_resize_layer(SAL_HANDLE(handle),width,height);
}


VMUINT vm_graphic_get_trans_handle(VMINT handle)
{
	if (INVALID_MRE_HANDLE(handle))
		return 0;
	if (layer_trans_tbl[handle].used)
		return SAL_HANDLE(handle);
	else
		return 0;
}


VM_GDI_RESULT vm_graphic_get_layer_clip(VMINT handle ,clip_rect * curcliprect)
{
	VMINT x1,x2,y1,y2;
	
	if ((INVALID_MRE_HANDLE(handle)) || (curcliprect == NULL))
		return VM_GDI_ERR_WRONG_PARAM;	
	
	gdi_layer_push_and_set_active(SAL_HANDLE(handle));	
	gdi_layer_get_clip(&x1,&y1,&x2, &y2);
	curcliprect->left =(VMINT16) x1;
	curcliprect->top = (VMINT16)y1;
	curcliprect->right = (VMINT16)x2;
	curcliprect->bottom = (VMINT16)y2;		
	curcliprect->flag = 1;
	gdi_layer_pop_and_restore_active();

	MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_4472 ,x1,y1,x2,y2);
	
	return VM_GDI_SUCCEED;	
}

VM_GDI_RESULT vm_graphic_set_layer_clip(VMINT handle ,VMINT16 x1,VMINT16 y1,VMINT16 x2,VMINT16 y2)
{
	VMINT width,height,tmp;
	gdi_handle cur_active_layer;
	
	if (INVALID_MRE_HANDLE(handle))
		return VM_GDI_ERR_WRONG_PARAM;
	
	width = layer_trans_tbl[handle].width -1;
	height = layer_trans_tbl[handle].height -1;
	MRE_LIMIT_VALUE(x1, 0, width);
	MRE_LIMIT_VALUE(y1, 0, height);
	MRE_LIMIT_VALUE(x2, 0, width);
	MRE_LIMIT_VALUE(y2, 0, height);
	if (x1 >x2)
	{
		tmp = x2;
		x2 = x1;
		x1 =tmp;
	}
	if (y1 >y2)
	{
		tmp = y2;
		y2 = y1;
		y1 =tmp;
	}	
	
    MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_4502 ,x1,y1,x2,y2);	
	gdi_layer_get_active(&cur_active_layer);
	if (SAL_HANDLE(handle)!= cur_active_layer)
	{
		gdi_layer_push_and_set_active(SAL_HANDLE(handle));	
		gdi_layer_set_clip((VMINT)x1, (VMINT)y1,(VMINT)x2, (VMINT)y2);
		gdi_layer_pop_and_restore_active();
		return VM_GDI_SUCCEED;
	}
	gdi_layer_set_clip((VMINT)x1, (VMINT)y1,(VMINT)x2, (VMINT)y2);
	vm_graphic_set_clip_internal(x1, y1, x2, y2); 
	return VM_GDI_SUCCEED;
}

VM_GDI_RESULT vm_graphic_set_layer_clip_internal(VMINT handle ,VMINT16 x1,VMINT16 y1,VMINT16 x2,VMINT16 y2)
{
	VMINT width,height,tmp;
	gdi_handle cur_active_layer;
	
	if (INVALID_MRE_HANDLE(handle))
		return VM_GDI_ERR_WRONG_PARAM;

	width = layer_trans_tbl[handle].width -1;
	height = layer_trans_tbl[handle].height -1;
	MRE_LIMIT_VALUE(x1, 0, width);
	MRE_LIMIT_VALUE(y1, 0, height);
	MRE_LIMIT_VALUE(x2, 0, width);
	MRE_LIMIT_VALUE(y2, 0, height);
	if (x1 >x2)
	{
		tmp = x2;
		x2 = x1;
		x1 =tmp;
	}
	if (y1 >y2)
	{
		tmp = y2;
		y2 = y1;
		y1 =tmp;
	}	
	
    MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_4541 ,x1,y1,x2,y2);	
	gdi_layer_get_active(&cur_active_layer);
	if (SAL_HANDLE(handle)!= cur_active_layer)
	{
		gdi_layer_push_and_set_active(SAL_HANDLE(handle));	
		gdi_layer_set_clip((VMINT)x1, (VMINT)y1,(VMINT)x2, (VMINT)y2);
		gdi_layer_pop_and_restore_active();
		return VM_GDI_SUCCEED;
	}
	gdi_layer_set_clip((VMINT)x1, (VMINT)y1,(VMINT)x2, (VMINT)y2);
	
	return VM_GDI_SUCCEED;
}

VM_GDI_RESULT vm_graphic_translate_layer(VMINT handle , VMINT tx, VMINT ty)
{	
	if (INVALID_MRE_HANDLE(handle))
		return VM_GDI_ERR_WRONG_PARAM;		
	
	gdi_layer_push_and_set_active(SAL_HANDLE(handle));	
	gdi_layer_set_position(tx, ty);
	gdi_layer_pop_and_restore_active();
	layer_trans_tbl[handle].x = tx;
	layer_trans_tbl[handle].y = ty;
	
	return VM_GDI_SUCCEED;
}

VM_GDI_RESULT vm_graphic_rotate_layer(VMINT handle, vm_graphic_rotate_value rotatevalue)
{
	VMUINT8 rotate_value;

	if ( convert_to_gdi_rotate_degree(rotatevalue, &rotate_value) != GDI_SUCCEED )
		return -1;
	
	if (INVALID_MRE_HANDLE(handle))
		return VM_GDI_ERR_WRONG_PARAM;		
	
	gdi_layer_push_and_set_active(SAL_HANDLE(handle));	
	gdi_layer_set_rotate(rotate_value);
	layer_trans_tbl[handle].rotate = (VMINT)rotatevalue;
	gdi_layer_pop_and_restore_active();
	
	return VM_GDI_SUCCEED;
}


VM_GDI_RESULT vm_graphic_2d_linear_transform(VMINT src_handle, VMINT sx,VMINT sy,VMINT sw,VMINT sh,VMINT dx,VMINT dy,VMINT dw,VMINT dh)
{
    gdi_lt_matrix_struct transform;

    if (INVALID_MRE_HANDLE(src_handle))
		return VM_GDI_ERR_WRONG_PARAM;
		
    if (!gdi_2d_linear_transform_hw_support())
		return VM_GDI_FAILED;

    transform.m[0] = (float)dw/sw;
    transform.m[1] = 0.0f;
    transform.m[2] = dx; 
    transform.m[3] = 0.0f;
    transform.m[4] = (float)dh/sh;   
    transform.m[5] = dy; 
    transform.m[6] = 0.0f;
    transform.m[7] = 0.0f;
    transform.m[8] = 1.0f;
    
    if (gdi_2d_linear_transfrom(
            transform.m,
            layer_trans_tbl[src_handle].handle,
            sx,
            sy,
            sw,
            sh,
            dx,
            dy,
            dw,
            dh,
            GDI_LT_SRC_KEY_EDGE_FILTER_DULPLICATE,
            GDI_COLOR_TRANSPARENT,
            GDI_LT_SAMPLE_MODE_BILINEAR_WITH_EDGE_FILTER_DULPLICATE,
            GDI_LT_FLAG_NON_BLOCKING)) 
        return VM_GDI_SUCCEED;
    else 
        return VM_GDI_FAILED;
}




VM_GDI_RESULT vm_graphic_setpen(vm_graphic_pen *pen)
{
	vm_graphic_cb *current_cb;

	current_cb = vm_graphic_get_current_cb();
	if (current_cb == NULL)
		return -1;	

	if (!pen)
		return VM_GDI_ERR_WRONG_PARAM;
	
	if ((pen->cycle == 0) || (pen->bitvalues == NULL))
		return VM_GDI_ERR_WRONG_PARAM;
	
	current_cb->pen.cycle= pen->cycle;
	current_cb->pen.bitvalues= pen->bitvalues;
	
	return VM_GDI_SUCCEED;
}


vm_graphic_pen  vm_graphic_getpen(void)
{
	vm_graphic_cb *current_cb;
	vm_graphic_pen pen = {0,NULL};

	current_cb = vm_graphic_get_current_cb();
	if (current_cb == NULL)
		return pen;	

	return current_cb->pen;
}


VM_GDI_RESULT vm_graphic_setcolor(vm_graphic_color* color)
{
	vm_graphic_cb *current_cb;

	current_cb = vm_graphic_get_current_cb();
	if (current_cb == NULL)
		return -1;	

	if (!color)
		return VM_GDI_ERR_WRONG_PARAM;
	
	current_cb->color.vm_color_565= color->vm_color_565;
	current_cb->color.vm_color_888= color->vm_color_888;

	current_cb->color_argb.a = 255;
	current_cb->color_argb.r = VM_COLOR_GET_RED(color->vm_color_565);
	current_cb->color_argb.g = VM_COLOR_GET_GREEN(color->vm_color_565);
	current_cb->color_argb.b = VM_COLOR_GET_BLUE(color->vm_color_565);
	
	return VM_GDI_SUCCEED;	
}

vm_graphic_color vm_graphic_getcolor(void)
{
	vm_graphic_cb *current_cb;
	vm_graphic_color color = {0, 0};

	current_cb = vm_graphic_get_current_cb();
	if (current_cb == NULL)
		return color;	

	return current_cb->color;
}

VM_GDI_RESULT vm_graphic_setcolor_argb(vm_graphic_color_argb* color)
{
	vm_graphic_cb *current_cb;

	current_cb = vm_graphic_get_current_cb();
	if (current_cb == NULL)
		return -1;	

	if (!color)
		return VM_GDI_ERR_WRONG_PARAM;
	
	current_cb->color_argb.a = color->a;
	current_cb->color_argb.r = color->r;
	current_cb->color_argb.g = color->g;
	current_cb->color_argb.b = color->b;
	
	return VM_GDI_SUCCEED;	
}

vm_graphic_color_argb vm_graphic_getcolor_argb(void)
{
	vm_graphic_cb *current_cb;
	vm_graphic_color_argb color_argb = {255, 0, 0, 0};

	current_cb = vm_graphic_get_current_cb();
	if (current_cb == NULL)
		return color_argb;	

	return current_cb->color_argb;
}


//====================================2D Function=========================================

static VMBOOL vm_graphic_layer_handle_check(VMINT handle, vm_graphic_cb **p_current_cb)
{
	*p_current_cb = vm_graphic_get_current_cb();
	if (*p_current_cb == NULL)
		return FALSE;	
	
	if (INVALID_MRE_HANDLE(handle))
		return FALSE;

	return TRUE;
}

static void vm_graphic_set_layer_environment(VMINT handle, vm_graphic_cb *current_cb, gdi_color *p_current_color)
{		
	gdi_layer_push_and_set_active(SAL_HANDLE(handle));	
	*p_current_color = gdi_act_color_from_rgb(current_cb->color_argb.a, current_cb->color_argb.r, current_cb->color_argb.g, current_cb->color_argb.b);
}

static void vm_graphic_restore_layer_environment(void)
{		
	gdi_layer_pop_and_restore_active();
}

void vm_graphic_line_ex(VMINT handle, VMINT x1, VMINT y1, VMINT x2, VMINT y2)
{
	vm_graphic_cb *current_cb;
	gdi_color current_color;
	
	if ( FALSE == vm_graphic_layer_handle_check(handle, &current_cb) )
		return;
	
	vm_graphic_set_layer_environment(handle, current_cb, &current_color);
	gdi_draw_line(x1, y1, x2, y2, current_color);
	vm_graphic_restore_layer_environment();

	return;	
}	

void vm_graphic_set_pixel_ex(VMINT handle,VMINT x1,VMINT y1)
{
	vm_graphic_cb *current_cb;
	gdi_color current_color;

	if ( FALSE == vm_graphic_layer_handle_check(handle, &current_cb) )
		return;

	vm_graphic_set_layer_environment(handle, current_cb, &current_color);
	gdi_draw_point(x1, y1, current_color);	
	vm_graphic_restore_layer_environment();	
}


void vm_graphic_line_style(VMINT handle,VMINT x1,VMINT y1,VMINT x2,VMINT y2)
{
	vm_graphic_cb *current_cb;
	gdi_color current_color;

	if ( FALSE == vm_graphic_layer_handle_check(handle, &current_cb) )
		return;

	if ((current_cb->pen.cycle == 0) || (current_cb->pen.bitvalues == NULL))
		return;

	vm_graphic_set_layer_environment(handle, current_cb, &current_color);
	gdi_draw_line_style(x1, y1, x2, y2, current_color,current_cb->pen.cycle, current_cb->pen.bitvalues);
	vm_graphic_restore_layer_environment();	

	return;	
}	

void vm_graphic_roundrect_ex(VMINT handle, VMINT x, VMINT y, VMINT width, VMINT height, VMINT frame_width)
{
    VMUINT8 * buf;
	vm_graphic_cb *current_cb;

	if ( FALSE == vm_graphic_layer_handle_check(handle, &current_cb) )
		return;

	if ( width <= 0 || height <= 0 || frame_width < 0 )
		return ;
	
    buf = vm_graphic_get_layer_buffer(handle);
    vm_graphic_roundrect(buf, x, y, width, height, frame_width, 
		VM_RGB565_ARGB(current_cb->color_argb.a, current_cb->color_argb.r, current_cb->color_argb.g, current_cb->color_argb.b));

	return;
}

void vm_graphic_rect_ex(VMINT handle, VMINT x, VMINT y, VMINT width, VMINT height)
{
	vm_graphic_cb *current_cb;
	gdi_color current_color;

	if ( FALSE == vm_graphic_layer_handle_check(handle, &current_cb) )
		return;
	
	if ( width <= 0 || height <= 0 )
		return;	

	vm_graphic_set_layer_environment(handle, current_cb, &current_color);	
	gdi_draw_rect(x,y,x+width-1,y+height-1, current_color);
	vm_graphic_restore_layer_environment();	
	
	return;
}

void vm_graphic_arc(VMINT handle, VMINT x, VMINT  y, VMINT  r, VMINT  startangle, VMINT  angleextent)
{
	vm_graphic_cb *current_cb;
	gdi_color current_color;

	if ( FALSE == vm_graphic_layer_handle_check(handle, &current_cb) )
		return;

	vm_graphic_set_layer_environment(handle, current_cb, &current_color);	
	gdi_draw_arc(x,y,r, startangle, angleextent, current_color);
	vm_graphic_restore_layer_environment();	

	return;
}

void vm_graphic_ellipse_ex(VMINT handle, VMINT x, VMINT y, VMINT width, VMINT height)
{	
    VMUINT8 * buf;
	vm_graphic_cb *current_cb;

	if ( FALSE == vm_graphic_layer_handle_check(handle, &current_cb) )
		return;

    if ( width <= 0 || height <= 0 )
		return;
	
	buf = vm_graphic_get_layer_buffer(handle);
    vm_graphic_ellipse(buf,x,y,width,height,
		VM_RGB565_ARGB(current_cb->color_argb.a, current_cb->color_argb.r, current_cb->color_argb.g, current_cb->color_argb.b));

	return;
}

void vm_graphic_polygon(VMINT handle, vm_graphic_point * points,VMINT npoint)
{
	vm_graphic_cb *current_cb;
	gdi_color current_color;

	if ( FALSE == vm_graphic_layer_handle_check(handle, &current_cb) )
		return;
	
	if ( npoint <= 0 || points == NULL )
		return;	

	vm_graphic_set_layer_environment(handle, current_cb, &current_color);		
	gdi_draw_polygon((gdi_point2D_struct *)points, npoint,current_color);
	vm_graphic_restore_layer_environment();	
	
	return;
}

void vm_graphic_fill_roundrect_ex(VMINT handle, VMINT x, VMINT y, VMINT width, VMINT height, VMINT  frame_width)
{
    VMUINT8 * buf;
	vm_graphic_cb *current_cb;

	if ( FALSE == vm_graphic_layer_handle_check(handle, &current_cb) )
		return;

	if ( frame_width < 0 || width <= 0 || height <= 0 )
		return;
	
    buf = vm_graphic_get_layer_buffer(handle);
    vm_graphic_fill_roundrect(buf, x, y, width, height, frame_width, 
		VM_RGB565_ARGB(current_cb->color_argb.a, current_cb->color_argb.r, current_cb->color_argb.g, current_cb->color_argb.b));

    return;
}

void vm_graphic_fill_rect_ex(VMINT handle, VMINT  x, VMINT  y, VMINT  width, VMINT  height)
{
	vm_graphic_cb *current_cb;
	gdi_color current_color;

	if ( FALSE == vm_graphic_layer_handle_check(handle, &current_cb) )
		return;
	
	if ( width <= 0 ||height <= 0 )
		return;	

	vm_graphic_set_layer_environment(handle, current_cb, &current_color);			
	gdi_draw_solid_rect(x,y,x+width,y+height, current_color);
	vm_graphic_restore_layer_environment();	

	return;
}

void vm_graphic_fill_ellipse_ex(VMINT handle, VMINT  x, VMINT  y, VMINT  width, VMINT  height)
{
    VMUINT8 * buf;
	vm_graphic_cb *current_cb;

	if ( FALSE == vm_graphic_layer_handle_check(handle, &current_cb) )
		return;
	
    if ( width <= 0 || height <= 0 )
		return;
	
    buf = vm_graphic_get_layer_buffer(handle);
    vm_graphic_fill_ellipse(buf, x, y, width, height, 
		VM_RGB565_ARGB(current_cb->color_argb.a, current_cb->color_argb.r, current_cb->color_argb.g, current_cb->color_argb.b));

	return;
}

void vm_graphic_fill_arc(VMINT handle, VMINT x, VMINT y, VMINT r, VMINT startAngle, VMINT angleextent)
{
	vm_graphic_cb *current_cb;
	gdi_color current_color;

	if ( FALSE == vm_graphic_layer_handle_check(handle, &current_cb) )
		return;

	vm_graphic_set_layer_environment(handle, current_cb, &current_color);			
	gdi_draw_solid_arc(x,y,r, startAngle,angleextent,current_color);
	vm_graphic_restore_layer_environment();	

	return;
}


void vm_graphic_fill_polygon(VMINT handle, vm_graphic_point * points,VMINT npoint)
{
	vm_graphic_cb *current_cb;
	gdi_color current_color;

	if ( FALSE == vm_graphic_layer_handle_check(handle, &current_cb) )
		return;
	
	if ( npoint <= 0 || points ==  NULL )
		return;	

	vm_graphic_set_layer_environment(handle, current_cb, &current_color);				
	gdi_draw_solid_polygon((gdi_point2D_struct *)points,npoint,current_color);
	vm_graphic_restore_layer_environment();	

	return;
}

static const gdi_gradient_rect_style_enum vm_gdi_gp_style_mapping_table[] =
{
	GDI_GRADIENT_RECT_HOR,
	GDI_GRADIENT_RECT_VER,
	GDI_GRADIENT_RECT_DIA,
	GDI_GRADIENT_RECT_DIA_INV,
	GDI_GRADIENT_RECT_FLIP
};

void vm_graphic_gradient_paint_rect(VMINT handle, VMINT x1, VMINT y1, VMINT x2, VMINT y2, vm_graphic_color color_start, vm_graphic_color color_end,vm_graphic_gp_style style)
{
	vm_graphic_cb *current_cb;
	gdi_color current_color;

	if ( FALSE == vm_graphic_layer_handle_check(handle, &current_cb) )
		return;

	vm_graphic_set_layer_environment(handle, current_cb, &current_color);				
	gdi_draw_gradient_rect(x1, y1, x2, y2, 
					GDI_ACT_COLOR_FROM_RGB(color_start.vm_color_565),
					GDI_ACT_COLOR_FROM_RGB(color_end.vm_color_565),
				0, 0, vm_gdi_gp_style_mapping_table[style]);
	vm_graphic_restore_layer_environment();	
	
	return;
}


VM_GDI_RESULT vm_font_set_font_size(VMINT size)
{
	vm_graphic_cb *current_cb;

	if (layer_operation_permission_check() < 0)		
		return VM_GDI_MIBR_NOT_FORE;	
	
	current_cb = vm_graphic_get_current_cb();
	if (current_cb == NULL)
		return VM_GDI_FAILED;	

	current_cb->font.size = vm_convert_font_size(size);

	gui_set_font(&(current_cb->font));
    MMI_TRACE(MMI_MRE_TRC_INFO, TRC_MRE_VMGRAPH_5091 , current_cb->font.bold, current_cb->font.italic, current_cb->font.underline, current_cb->font.size, current_cb->font.color, current_cb->font.type);

	return VM_GDI_SUCCEED;
}


VM_GDI_RESULT vm_font_set_font_style(VMINT bold,VMINT italic,VMINT underline)
{
	vm_graphic_cb *current_cb;

	if (layer_operation_permission_check() < 0)		
		return VM_GDI_MIBR_NOT_FORE;	
	
	current_cb = vm_graphic_get_current_cb();
	if (current_cb == NULL)
		return VM_GDI_FAILED;	

	if (vm_graphic_is_use_vector_font())
	{
	
		if (bold)
			current_cb->font.bold= VM_FONT_ATTR_BOLD;
		else
			current_cb->font.bold= 0;

		if (italic)
			current_cb->font.italic= VM_FONT_ATTR_ITALIC;
		else
			current_cb->font.italic= 0;

		if (underline)
			current_cb->font.underline= VM_FONT_ATTR_UNDERLINE;
		else
			current_cb->font.underline= 0;		

	}
	else
	{
		current_cb->font.bold = bold;
		current_cb->font.italic = italic;
		current_cb->font.underline = underline;
	}
	gui_set_font(&(current_cb->font));
    MMI_TRACE(MMI_MRE_TRC_INFO, TRC_MRE_VMGRAPH_5133 , current_cb->font.bold, current_cb->font.italic, current_cb->font.underline, current_cb->font.size, current_cb->font.color, current_cb->font.type);

	return VM_GDI_SUCCEED;    
}


static VM_GDI_HANDLE vm_graphic_mibr_save_layer(void)
{
	VMINT reshandle;
	
    if  ((reshandle = vm_res_save_data(VM_RES_TYPE_LAYER_HANDLE, NULL,0, NULL, vm_pmng_get_app_handle())) < 0)
		return VM_GDI_MIBR_ERR;

	return reshandle;
}

static VM_GDI_HANDLE vm_graphic_mibr_release_layer(VMINT mibrlayer)
{
	if  (vm_res_release_data(VM_RES_TYPE_LAYER_HANDLE, mibrlayer) < 0)
		return VM_GDI_MIBR_ERR;
	
	return VM_GDI_SUCCEED;
}


void vm_graphic_mibr_reset_global_env(void)
{
#ifdef __MRE_LIB_GRAPIC_GFXOLD__
    is_base_layer_created = FALSE;
    is_screen_buffer_initialized = FALSE;
#endif	
}


static VMINT vm_graphic_cb_init()
{
	vm_graphic_cb *gcb;
	VMINT gcbhandle;
	VM_P_HANDLE phandle;
	VMINT i;

	if ((phandle = vm_pmng_get_app_handle()) == 0)
	{
       	MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_5194 );
		return VM_GDI_MIBR_ERR;  		
	}
	
	if((gcb = (vm_graphic_cb *)vm_malloc_nc(sizeof(vm_graphic_cb))) == NULL)
    {
       	MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_5200 );
		return VM_GDI_FAILED;
    }

	gcb->active_layer = 0;

	gcb->old_alpha_blending_layer = 0;	

	gcb->cliprect.left = 0;
	gcb->cliprect.top = 0;
	gcb->cliprect.right= LCD_WIDTH;
	gcb->cliprect.bottom = LCD_HEIGHT;
	gcb->cliprect.flag = 1;

	gcb->pen.cycle = 0;
	gcb->pen.bitvalues = NULL;
	
	gcb->color.vm_color_565 = 0;
	gcb->color.vm_color_888 = 0;

	gcb->color_argb.a = 255;
	gcb->color_argb.r = 0;
	gcb->color_argb.g = 0;
	gcb->color_argb.b = 0;

	memset(&(gcb->font), 0, sizeof(gcb->font));
	gcb->font.bold = 0;
	gcb->font.italic = 0;
	gcb->font.underline = 0;
	gcb->font.size = MEDIUM_FONT;
	gcb->font.color = 0;
	gcb->font.type = 1;

	gcb->baseline = -1;

	gcb->user_get_resource_fp = NULL;
	
	if ((gcbhandle = vm_res_save_data(VM_RES_TYPE_GRAPHIC_CXT, (void *) gcb, sizeof(vm_graphic_cb),NULL, phandle)) < 0)
	{
		vm_free(gcb);
       	MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_5239 );
		return VM_GDI_FAILED;
	}

	for (i = 0; i < MAX_PROCESS; i++)
	{
		if (gcb_table[i].phandle == 0)
		break;
	}

	if (i == MAX_PROCESS)
	{
		vm_res_release_data(VM_RES_TYPE_GRAPHIC_CXT, gcbhandle);
		vm_free(gcb);
		MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_5253 );
		return VM_GDI_MIBR_ERR;
	}
       
	gcb_table[i].phandle = phandle;
	gcb_table[i].gcbhandle = gcbhandle;

	MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_5260 , i, phandle, gcbhandle);

	return VM_GDI_SUCCEED;
}


static VMINT vm_graphic_cb_exit()
{
	vm_graphic_cb *gcb;
	VM_P_HANDLE phandle;
	VMINT i;
	VMINT bufsize = 0;	

	if ((phandle = vm_pmng_get_app_handle()) == 0)
	{
       	MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_5276 );
		return VM_GDI_MIBR_ERR;  	
	}
	
	for (i = 0;i<MAX_PROCESS;i++)
	{
		if (gcb_table[i].phandle == phandle)
			break;
	}	

	if (i == MAX_PROCESS)
	{
		MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_5288 );
		return VM_GDI_MIBR_ERR;  	
	}
	
	if (vm_res_get_data(VM_RES_TYPE_GRAPHIC_CXT, gcb_table[i].gcbhandle, (void **)(&gcb), &bufsize) < 0)
	{
       	MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_5294 );	
		return VM_GDI_FAILED;
	}

	if  (vm_res_release_data(VM_RES_TYPE_GRAPHIC_CXT, gcb_table[i].gcbhandle) < 0)
	{
       	MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_5300 );		
		return VM_GDI_MIBR_ERR;
	}
	
	vm_free(gcb);

	gcb_table[i].phandle = 0;
	gcb_table[i].gcbhandle = 0;	
	
	return VM_GDI_SUCCEED;
}

static void vm_graphic_mibr_layer_notify_callback(VM_P_HANDLE process_handle, VMINT sys_state)
{
 	VMINT i;
	
 	switch(sys_state)
 	{
 		case VM_PMNG_STARTING:
			vm_graphic_cb_init();
#if !defined(__MMI_SCREEN_SWITCH_EFFECT__) || defined(__MMI_REDUCED_UI_BUFFER__)
			vm_graphic_async_blt_reset();
#endif
 			break;
 		case VM_PMNG_CLOSING:
			vm_graphic_flatten_previous_blt_layer_to_base_layer();
 			break;		
		case VM_PMNG_FOREGROUND:
			vm_graphic_async_blt_init();
 			break;	
		case VM_PMNG_INACTIVE:
			vm_graphic_async_blt_exit();
 			break;
 		case VM_PMNG_BACKGROUND:
            //If App is not support BG running,Not clear global variables.
            if (vm_pmng_is_support_bg(process_handle))
            {
				vm_graphic_delete_layer(is_fast_layer);
				vm_graphic_delete_layer(is_base_layer);

            	MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_5328 ); 		
         		vm_graphic_mibr_reset_global_env();
            }  
            else
            	MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_5332 ); 		                

			vm_graphic_async_blt_exit();
     		break; 		
 		case VM_PMNG_UNLOAD:
			if (vm_pmng_get_app_handle() == process_handle)
			{			
				for (i = MAX_LAYER - 1; i>=0; i--)
				{
					if (i != is_base_layer)
						vm_graphic_delete_layer(i);
				}				
				vm_graphic_delete_layer(is_base_layer);

				MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_5342 ); 
				vm_graphic_mibr_reset_global_env();
				vm_graphic_cb_exit();
			}

			vm_graphic_async_blt_exit();
     		break;
		default:
			return;
	}
}

static void vm_graphic_initial(void)
{
    vm_res_type_set_notify_callback(VM_RES_TYPE_LAYER_HANDLE, vm_graphic_mibr_layer_notify_callback);
}

static void vm_graphic_finialize(void)
{
	VMINT i;
	
 	for (i = MAX_LAYER -1 ;  i >=0 ; i--)
		vm_graphic_delete_layer_internal(i);

    vm_graphic_mibr_reset_global_env();
	vm_res_type_set_notify_callback(VM_RES_TYPE_LAYER_HANDLE, NULL);
}

static VMINT vm_graphic_mod_evt_proc(MRE_MOD_LIFECIRCLE_EVT event)
{
	switch(event)
	{
		case EVT_MOD_INIT:
			vm_graphic_initial();
			break;
 		case EVT_MOD_RELEASE:
			vm_graphic_finialize();
			break;
	}
	return 0;
}

VMINT _vm_reg_graphic_modual(void)
{
	VMINT res = 0;

	if ((res = _vm_reg_module("GRAPHIC MODULE", (MOD_EVT_PROCESS)vm_graphic_mod_evt_proc)) 
		!= 0)
	{
		MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_5416 , res);
	}
    else
    {
        MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_5420 );
    }
	
	return res;
}


VMINT  vm_graphic_set_alpha_blending_layer(VMINT handle)
{
	vm_graphic_cb *current_cb;

	current_cb = vm_graphic_get_current_cb();
	if (current_cb == NULL)
		return VM_GDI_FAILED;	
	
    MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_5436 ,handle, current_cb->old_alpha_blending_layer);
	
	if(-1 == handle)
	{
		gdi_image_abm_set_source_layer(current_cb->old_alpha_blending_layer);
		return VM_GDI_SUCCEED;
	}
	
	if (-2 == handle)
	{
		gdi_get_alpha_blending_source_layer(&(current_cb->old_alpha_blending_layer));		
		MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_5448 , current_cb->old_alpha_blending_layer);

		gdi_image_abm_set_source_layer(NULL);
		return VM_GDI_SUCCEED;
	}
	
	if (INVALID_MRE_HANDLE(handle))
		return VM_GDI_ERR_WRONG_PARAM;		
	
	gdi_get_alpha_blending_source_layer(&(current_cb->old_alpha_blending_layer));		
    MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_5448 , current_cb->old_alpha_blending_layer);

	gdi_layer_push_and_set_active(SAL_HANDLE(handle));	
	gdi_image_abm_set_source_layer(SAL_HANDLE(handle));
	gdi_layer_pop_and_restore_active();

	return VM_GDI_SUCCEED;
}

VMINT vm_graphic_is_r2l_state(void)
{
	return (VMINT)mmi_fe_is_r2l_state();
}

VMUINT vm_graphic_get_char_num_in_width(VMWCHAR* string, VMUINT width, VMINT  checklinebreak, VMUINT gap)
{
   return Get_CharNumInWidth_w((U8*)string,  width,  checklinebreak, gap);

}

VMUINT vm_graphic_get_char_num_in_width_ex(VMWCHAR* string, VMUINT width, VMINT  checklinebreak, VMUINT gap)
{
   VMINT Width;
   VMINT Height;
   VMINT n;

   n = vm_wstrlen(string);

   return Get_StringWidthHeight_variant((U8*)string, gap, n, &Width, &Height, width, checklinebreak, 0);
}


VMINT vm_graphic_set_blt_layer(VMINT* layer_handles, VMINT count)
{
    VMINT ret = 0;
    VMINT i = 0;

    MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_5495 ,layer_handles,count);

	if (vm_pmng_state(VM_PMNG_CUR_HANDLE) != VM_PMNG_FOREGROUND)
    {
        MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_5499 );
        return VM_GDI_MIBR_NOT_FORE;	
    }
	if ((layer_handles == NULL) || (count <=0) )
    {
        MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_5505 );
        return VM_GDI_ERR_WRONG_PARAM;
    }
    for(i = 0;i<count;i++)
    {
        if(INVALID_MRE_HANDLE(layer_handles[i]))
        {
            MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_5512 );
            return VM_GDI_ERR_WRONG_PARAM;
        }
    }

    if(count ==1)
    {
        ret =  gdi_layer_set_blt_layer_ext(SAL_HANDLE(layer_handles[0]),0,0,0,0,0);
    }
    else if(count ==2)
    {
        ret =  gdi_layer_set_blt_layer_ext(SAL_HANDLE(layer_handles[0]),SAL_HANDLE(layer_handles[1]),0,0,0,0);
    }
    else if(count ==3)
    {
        ret =  gdi_layer_set_blt_layer_ext(SAL_HANDLE(layer_handles[0]),SAL_HANDLE(layer_handles[1]),SAL_HANDLE(layer_handles[2]),0,0,0);
    }
        else if(count ==4)
    {
        ret =  gdi_layer_set_blt_layer_ext(SAL_HANDLE(layer_handles[0]),SAL_HANDLE(layer_handles[1]),SAL_HANDLE(layer_handles[2]),SAL_HANDLE(layer_handles[3]),0,0);
    }
    else if(count ==5)
    {
        ret =  gdi_layer_set_blt_layer_ext(SAL_HANDLE(layer_handles[0]),SAL_HANDLE(layer_handles[1]),SAL_HANDLE(layer_handles[2]),SAL_HANDLE(layer_handles[3]),SAL_HANDLE(layer_handles[4]),0);
    }
    else if(count ==6)
    {
        ret =  gdi_layer_set_blt_layer_ext(SAL_HANDLE(layer_handles[0]),SAL_HANDLE(layer_handles[1]),SAL_HANDLE(layer_handles[2]),SAL_HANDLE(layer_handles[3]),SAL_HANDLE(layer_handles[4]),SAL_HANDLE(layer_handles[5]));
    }
    MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_5541 ,ret);

    return ret;
}  

VMINT* vm_graphic_get_blt_layer( VMINT* count)
{
    VMINT i,j;
    VMINT sum = 0;
    gdi_handle layers[6] = {0};
	vm_graphic_cb *current_cb;

	current_cb = vm_graphic_get_current_cb();
	if (current_cb == NULL)
		return NULL;	
	
	if (vm_pmng_state(VM_PMNG_CUR_HANDLE) != VM_PMNG_FOREGROUND)
    {
        MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_5563 );
        return NULL;	
    }
    if(NULL == count)
    {
        MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_5569 );
        return NULL;
    }
    gdi_layer_get_blt_layer_ext( &layers[0],&layers[1],&layers[2],&layers[3],&layers[4],&layers[5]);
    for(i= 0 ;i<6;i++)
    {
        current_cb->blt_layers[i] = -1;
        if(layers[i]!=0)
        {
            sum++;
        }
    }

    *count = sum;
    for(i= 0 ;i<MAX_LAYER;i++)
    {
        for(j=0;j<6;j++)
        {
            if(VALID_MRE_HANDLE(i) && vm_graphic_get_trans_handle(i) == layers[j])
            {
                current_cb->blt_layers[j] = i;
                break;
            }
        }
    }

    return current_cb->blt_layers;
}

VMUINT vm_get_string_width_height_ex(VMWCHAR* string,VMINT gap,VMINT n,VMINT *pWidth,VMINT *pHeight,VMINT max_width,VMUINT8 checkLineBreak,VMUINT8 checkCompleteWord)
{
	VMUINT x;

	x = Get_StringWidthHeight_variant(
        (U8*)string,
        (S32)gap,
        (S32)n,
        (S32 *)pWidth,
        (S32 *)pHeight,
        (S32) max_width,
        (U8) checkLineBreak,
        (U8) checkCompleteWord);
    MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_5621 ,x);
	
	return x;
}

vm_font_engine_error_message_enum vm_graphic_show_truncated_text(VM_GDI_HANDLE dest_layer_handle,VMINT x,VMINT y,VMINT xwidth,VMWCHAR *st,VMWCHAR *truncated_symbol,VMINT bordered,VMUINT16 color)
{
    mmi_font_engine_error_message_enum ret ;
    mmi_fe_color c;
	vm_graphic_cb *current_cb;

	if (layer_operation_permission_check() < 0)
	{
		return VM_FONT_ENGINE_ERROR;	
    }

	current_cb = vm_graphic_get_current_cb();
	if (current_cb == NULL)
		return VM_FONT_ENGINE_ERROR;	

	if (INVALID_MRE_HANDLE(dest_layer_handle) )
	{
        MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_5644 );
		return VM_FONT_ENGINE_ERROR;		
	}

	gdi_layer_push_and_set_active(SAL_HANDLE(dest_layer_handle));	
    c.a = 0;
	c.r = VM_COLOR_GET_RED(color);
	c.g = VM_COLOR_GET_GREEN(color);
	c.b = VM_COLOR_GET_BLUE(color);
    mmi_fe_set_text_color(c);

	gui_set_font(&(current_cb->font));
    MMI_TRACE(MMI_MRE_TRC_INFO, TRC_MRE_VMGRAPH_5656 , current_cb->font.bold, current_cb->font.italic, current_cb->font.underline, current_cb->font.size, current_cb->font.color, current_cb->font.type);

	ret = mmi_font_engine_show_truncated_text(
                                    (S32) x,
                                    (S32) y,
                                    (S32) xwidth,
                                    (U8 *)st,
                                    (U8 *)truncated_symbol,
                                    (MMI_BOOL) bordered
                                    );

	gdi_layer_pop_and_restore_active();

	if(ret == MMI_FONT_ENGINE_NO_ERROR)
  		return VM_FONT_ENGINE_NO_ERROR;
	else if(ret ==MMI_FONT_ENGINE_NO_TRUNCATION )
  		return VM_FONT_ENGINE_NO_TRUNCATION;
	else if(ret == MMI_FONT_ENGINE_TRUNCATION)
  		return VM_FONT_ENGINE_TRUNCATION;
	else if(ret == MMI_FONT_ENGINE_ERROR_NULL_STRING)
  		return VM_FONT_ENGINE_ERROR_NULL_STRING;
	else if(ret == MMI_FONT_ENGINE_ZERO_LENGTH)
  		return VM_FONT_ENGINE_ZERO_LENGTH;
	else if(ret == MMI_FONT_ENGINE_ERROR_NO_TRUNCATION_AVAILABLE)
  		return VM_FONT_ENGINE_ERROR_NO_TRUNCATION_AVAILABLE;
    else
        return VM_FONT_ENGINE_ERROR;
}


static const mmi_frm_screen_rotate_enum vm_frm_screen_rotate_mapping_table[] =
{
	MMI_FRM_SCREEN_ROTATE_0,
	MMI_FRM_SCREEN_ROTATE_90,
	MMI_FRM_SCREEN_ROTATE_180,
	MMI_FRM_SCREEN_ROTATE_270,
	MMI_FRM_SCREEN_ROTATE_MIRROR_0,
	MMI_FRM_SCREEN_ROTATE_MIRROR_90,
	MMI_FRM_SCREEN_ROTATE_MIRROR_180,
	MMI_FRM_SCREEN_ROTATE_MIRROR_270
};

void vm_frm_screen_rotate(vm_frm_screen_rotate_enum rotation)
{
    MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_5692 ,rotation);
		
#ifdef __MMI_SCREEN_ROTATE__
    {
        mmi_frm_screen_rotate_enum native_value = vm_frm_screen_rotate_mapping_table[rotation];
        MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_5734 );
        mmi_frm_screen_rotate(native_value);
    }
#endif
}

VMINT vm_graphic_get_highest_char_height_of_all_language(void) 
{
	S32	height;
	vm_graphic_cb *current_cb;

	current_cb = vm_graphic_get_current_cb();
	if (current_cb == NULL)
		return VM_GDI_FAILED;	

	gui_set_font(&(current_cb->font));
    MMI_TRACE(MMI_MRE_TRC_INFO, TRC_MRE_VMGRAPH_5750 , current_cb->font.bold, current_cb->font.italic, current_cb->font.underline, current_cb->font.size, current_cb->font.color, current_cb->font.type);
	height = Get_CharHeightOfAllLang(current_cb->font.size);
	MMI_TRACE(MMI_MRE_TRC_INFO, TRC_MRE_VMGRAPH_5752 , current_cb->font.size, height);
	
	return height;
}

VMINT vm_graphic_get_char_height_alllang(VMINT size) 
{
	S32	height;
	
	height = Get_CharHeightOfAllLang(vm_convert_font_size(size));
	MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_5761 , size, height);
	
	return height;
}


VMINT vm_graphic_get_char_baseline_alllang(VMINT size) 
{
	VMINT height, ascent, descent;

	mmi_fe_get_char_info_of_all_lang(vm_convert_font_size(size), &height, &ascent, &descent);
	MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMGRAPH_5771 , size, height, ascent, descent);

	return ascent;
}


VMINT vm_graphic_get_layer_buffer_size(VMINT handle) 
{	
	if (VALID_MRE_HANDLE(handle))
		return layer_trans_tbl[handle].buffer_size;
		
	return -1;
}

VMINT vm_graphic_is_dynamic_switch_cacheable_region(void * vaddr, VMUINT len)
{
#ifdef __DYNAMIC_SWITCH_CACHEABILITY__
	return is_predef_dyna_c_region((kal_uint32)vaddr, len);
#else
	return 0;
#endif
}

VMINT vm_graphic_dynamic_switch_cacheable_region(void **vaddr, VMUINT len, VMUINT cacheable)
{
	VMINT ret = -1;

#ifdef __DYNAMIC_SWITCH_CACHEABILITY__
	void *cache_ptr;
	VMINT c;

	if (cacheable == VM_NON_CACHEABLE)
		c = PAGE_NO_CACHE;
	else if (cacheable == VM_CACHEABLE)
		c = PAGE_CACHEABLE;
	else
		return ret;

	ret = dynamic_switch_cacheable_region(vaddr, len, c);

	if (cacheable == VM_NON_CACHEABLE)
	{
    	cache_ptr = (void *)phys_to_virt(*vaddr);
    	invalidate_dcache((kal_uint32)cache_ptr, len);
	}
#endif

	return ret;
}

VMINT vm_get_graph_sym(VMCHAR* func_name)
{
	return 0;
}

#endif
