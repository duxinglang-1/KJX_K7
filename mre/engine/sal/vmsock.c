/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*******************************************************************************
* Filename:
* ---------
*  
*
* Project:
* --------
*  MAUI
*
* Description:
* ------------
*  
*
* Author:
* -------
*
*
*==============================================================================
*             HISTORY
* Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!! 
*------------------------------------------------------------------------------
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
*------------------------------------------------------------------------------
* Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!! 
*==============================================================================
*******************************************************************************/
#include "vmswitch.h"
#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include "MMI_mre_trc.h"
#include "mmi_trc.h"
#if 1
void _vm_trace(char* fmt, ...)
{
    char text[260] = {0};
    
    va_list ap;
    
    va_start(ap, fmt);
    
    
#ifdef __MTK_TARGET__
    vsnprintf(text + strlen(text), 150, fmt, ap);
#else 
    _vsnprintf(text + strlen(text), 150, fmt, ap);
#endif

    MMI_PRINT(MOD_MRE, TRACE_GROUP_7, text);


    va_end(ap);

}


#ifdef WIN32
#define vm_trace _vm_trace
#else
#define vm_trace(...) _vm_trace(__VA_ARGS__)
#endif
#else
#ifdef WIN32
/* under construction !*/
#else
/* under construction !*/
#endif
/* under construction !*/
#endif

#ifdef __MRE_SAL_SOCKET__
#include "mmi_features.h"
#include "MMIDataType.h"
#include "custom_data_account.h"
#include "stack_config.h"
#include "stack_msgs.h"
#include "app2soc_struct.h"
#include "cbm_consts.h"
#include "soc_consts.h"
#include "soc_api.h"
#include "cbm_api.h"
#include "DataAccountDef.h"
#include "ModeSwitchSrvGProt.h"
#include "mmi_frm_events_gprot.h"
#include "DtcntSrvGprot.h"
#include "string.h"
#include "wgui_categories_util.h"
#include "mmi_rp_app_mre_def.h"

#include "vmsock.h"
#include "vmsys.h"
#include "vmmod.h"
#include "vmsim.h"
#include "vmopt.h"

#include "vmmem.h"
#include "vmpromng.h"
#include "vmresmng.h"
#include "vmmacrostub.h"
#include "vmlog.h"
#include "vmpromnginner.h"

#ifdef __COSMOS_MMI_PACKAGE__
    #include "vapp_dtcnt_gprot.h"
#else
    #include "DataAccountGProt.h"
#endif


#define VM_SOCK_POOL_SIZE       MRE_SUPPORT_TCP_CONTEXT_MAX_NUM
#define PF_INET                     SOC_PF_INET 
#define SOCK_STREAM             SOC_SOCK_STREAM
#define MAX_CTX_CB 4

/*
 * 得到联网账号。
 */
extern VMUINT vm_get_account_id(VMUINT account_id, VMUINT8 app_id);

extern _vm_pcb_t* vm_sh_pcb_in_pt(VMINT search_type, VMINT value, VM_PROCESS_STATUS* status);


	//abm hold
kal_uint32 vm_get_tcp_acctid_by_resid(VMINT res_id);


/*
  * TCP链路读通道的状态。
  */
typedef enum 
{
    read_block = 0,                             // 读阻塞状态
    read_notify                                 // 读允许状态
} sock_read_pipe_t;

/*
  * TCP链路写通道的状态。
  */
typedef enum 
{
    write_block = 0,                                // 写阻塞状态
    write_notify                                    // 写允许状态
} sock_write_pipe_t;

/*
  * TCP链路的状态。
  */
typedef enum 
{
    conn_init = 0,                              // 未连接状态
    conn_host_by_name,                          // DSN 解析状态
    conn_connected,                             // 已连接状态
    conn_unkown                             // 未知的SOCKET 状态
} sock_connection_t;

/*
  * TCP链路的上下文的结构。
  */
typedef struct vm_sock_context_t 
{
    kal_int8 sock;                              /**< socket 句柄                                */
    kal_uint16 port;                                /**< socket 远程端口                            */
    sock_connection_t socket_state;             /**<socket 链路的状态                       */
    sock_read_pipe_t read_pipe_state;               /**< 写通道的状态                           */
    sock_write_pipe_t write_pipe_state;             /**< 读通道的状态                           */
    void (*callback)(VMINT handle, VMINT event);        /**< 事件回调函数句柄                   */
    VMINT res_handle;                           /**< 该上下的空间是否已经被使用     */
    void (*cb[MAX_CTX_CB])(void);
    VMINT cb_num;
	//abm hold
    kal_uint32 account_id;
} vm_sock_context_t;

/*
  * 从socket 上下文资源池中获得socket上下文。
  */
static vm_sock_context_t* vm_malloc_socket_context(void);

/*
  * 把socket上下文归还到socket上下文资源池中。
  */
static void vm_free_socket_context(vm_sock_context_t*);

/*
  * 根据使用的socket句柄找到对应的socket链路上下
  * 文，如果找不到返回NULL。
  */
	//abm hold
static vm_sock_context_t* vm_get_socket_context(VMINT id, VMINT type);
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
/*
 * 注册到MTK的协议事件里的soc_notify函数。
 */
static MMI_BOOL vm_soc_notify(void*);

/*
 * 注册到MTK的协议事件里的get_host_by_name函数。
 */
static MMI_BOOL vm_get_host_by_name(void*);
static VMINT vm_get_host_by_name_1(VMINT handle, vm_soc_dns_result * rst);

static void * vm_soc_ctx_cb_push(vm_sock_context_t * ctx_p, void (*cb)(void));
static void * vm_soc_ctx_cb_pop(vm_sock_context_t * ctx_p);
/*
  * 初始化本模块的资源。
  */
static VMINT initialize_socket_resource(void);

/*
  * 释放本模块的资源
  */
static VMINT finialize_socket_resource(void);

/*
  * SOCKET模块生命周期事件的处理函数。
  */
static VMINT sock_mod_evt_proc(MRE_MOD_LIFECIRCLE_EVT event);

/*
  * 加入close的保护，防止MTK不传回CLOSE事件。
  */
//static void vm_close_timer_proc(int timer_id);

/*
 * 查找str_1和str_2是否相等，本函数大小不敏感。
 * 例如:str1为L"jie.chen"而str2为L"JIE.chen"则毕竟返回TRUE。
 */
static VMINT vm_cmp_wstr_ignore_case(VMWSTR str_1, VMWSTR str_2, VMUINT count);

static void TCP_PMNG_WRAP_CALLBACK(VM_P_HANDLE p, void (*cb)(VMINT handle, VMINT event), VMINT rid, VMINT state)
{
    if (vm_pmng_set_ctx(p) == VM_PMNG_OP_OK)
    {
        cb(rid, state);
        vm_pmng_reset_ctx(); 
    }
}



static void vm_soc_free_resource(VM_P_HANDLE process_handle)
{
    VMINT resHandle = 0, bufSize = 0;
    vm_sock_context_t* socket_context = NULL;
    
    while ((resHandle = vm_res_findfirst(process_handle, VM_RES_TYPE_TCP_HANDLE)) 
        != VM_RES_NOT_FIND)
    {
        if (vm_res_get_data(VM_RES_TYPE_TCP_HANDLE, 
            resHandle, (void**)&socket_context, &bufSize) == 0 && socket_context != NULL)
        {
            if (socket_context->socket_state == conn_host_by_name)
            {
                soc_abort_dns_query(KAL_TRUE, MOD_MMI, KAL_TRUE, 
                    socket_context->sock, KAL_FALSE, 0, KAL_FALSE, 0);
            }
            soc_close(socket_context->sock);
            /* 分配内存的时候是通过vm_malloc分配的。 */
            _vm_kernel_free(socket_context);
        }
        else
        {
            MMI_TRACE(MMI_MRE_TRC_WARNING, TRC_MRE_VMSOCK_378 );
        }
        vm_res_release_data(VM_RES_TYPE_TCP_HANDLE, resHandle);
        vm_res_findclose(VM_RES_TYPE_TCP_HANDLE); 
    }
}

static void vm_soc_notify_process_status(VM_P_HANDLE process_handle, 
    VMINT sys_state)
{
    switch (sys_state)
    {
    case VM_PMNG_UNLOAD:
        vm_soc_free_resource(process_handle);
        break;
    }
}

static VMINT g_vm_is_ready_dataaccount = FALSE;
static void init_dataaccount_callback(void)
{
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_390 );
    g_vm_is_ready_dataaccount = TRUE;
}

VMINT vm_is_ready_dataaccount(void)
{
    return g_vm_is_ready_dataaccount;
}
static void * vm_soc_ctx_cb_push(vm_sock_context_t * ctx_p, void (*cb)(void))
{
    //ASSERT(ctx_p && cb); // internal function, unnecessary to ASSERT

    if (MAX_CTX_CB == ctx_p->cb_num)
    {
        return 0;
    }
    ctx_p->cb[ctx_p->cb_num++] = cb;
    return (void*)cb;
}

static void * vm_soc_ctx_cb_pop(vm_sock_context_t * ctx_p)
{
    //ASSERT(ctx_p); // internal function, unnecessary to ASSERT

    if (0 == ctx_p->cb_num)
    {
        return 0;
    }
    return (void*)ctx_p->cb[--ctx_p->cb_num];
}

static VMINT vm_never_call_mmi_dtcnt_ready_check_on_background = TRUE;
static kal_uint8 cbm_app_id = 1;
static VMINT initialize_socket_resource(void)
{
    //VMINT ret = 0;

    if (vm_never_call_mmi_dtcnt_ready_check_on_background == TRUE)
    {
        vm_never_call_mmi_dtcnt_ready_check_on_background = FALSE;
        //mmi_dtcnt_ready_check_on_background(init_dataaccount_callback);
#ifdef __COSMOS_MMI_PACKAGE__
        if(MMI_TRUE == vapp_dtcnt_ready_check(init_dataaccount_callback, MMI_FALSE))
#else
        if(MMI_TRUE == mmi_dtcnt_ready_check(init_dataaccount_callback, MMI_FALSE))
#endif  
        {
            g_vm_is_ready_dataaccount = TRUE;
            MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_438 );
        }
    }
    
    if (vm_res_type_set_notify_callback(VM_RES_TYPE_TCP_HANDLE, 
        vm_soc_notify_process_status) != 0)
    {
        return -1;
    }

    //cbm_app_id = cbm_register_app_id(STR_MRE_TITLE, 0);
    //if ((ret = cbm_hold_bearer(MOD_MMI, cbm_app_id)) != CBM_OK)
    //{
    //  cbm_deregister_app_id(cbm_app_id);
    //  MMI_TRACE(MMI_MRE_TRC_WARNING, TRC_MRE_VMSOCK_452 , ret);
    //}
    return 0;
}

static VMINT finialize_socket_resource(void)
{
    vm_soc_free_resource(-1);
    
    vm_res_type_set_notify_callback(VM_RES_TYPE_TCP_HANDLE, NULL);

    mmi_frm_clear_protocol_event_handler(MSG_ID_APP_SOC_GET_HOST_BY_NAME_IND, 
        (PsIntFuncPtr)vm_get_host_by_name);
    mmi_frm_clear_protocol_event_handler(MSG_ID_APP_SOC_NOTIFY_IND, 
        (PsIntFuncPtr)vm_soc_notify);

    //cbm_release_bearer(MOD_MMI, cbm_app_id);
    //cbm_deregister_app_id(cbm_app_id);

    return 0;
}

static VMINT sock_mod_evt_proc(MRE_MOD_LIFECIRCLE_EVT event)
{
    switch(event)
    {
    case EVT_MOD_INIT:
        if (initialize_socket_resource() != 0)
            return -1;
        break;
    case EVT_MOD_RELEASE:
        finialize_socket_resource();
        break;
    case EVT_MOD_ACTIVE:
        break;
    case EVT_MOD_INACTIVE:
        break;
    default:
        MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMSOCK_514 , event);
        return -2;
    }

    return 0;
}

	//abm hold
static vm_sock_context_t* vm_get_socket_context(VMINT id, VMINT type)
{
    VMINT resHandle = 0, bufSize = 0;
    vm_sock_context_t* socketContext = NULL;
    
    if ((resHandle = vm_res_findfirst(-1, VM_RES_TYPE_TCP_HANDLE)) != VM_RES_NOT_FIND)
    {
        if (vm_res_get_data(VM_RES_TYPE_TCP_HANDLE, 
            resHandle, (void**)&socketContext, &bufSize) == 0 && socketContext != NULL)
        {
            if (0 == type)
            {
                if (socketContext->sock == id)
                {
                    vm_res_findclose(VM_RES_TYPE_TCP_HANDLE);
                    return socketContext;
                }
            }
            else if (1 == type)
            {
                if (socketContext->res_handle == id)
                {
                    vm_res_findclose(VM_RES_TYPE_TCP_HANDLE);
                    return socketContext;
                }
            }
        }

        while ((resHandle = vm_res_findnext(-1, VM_RES_TYPE_TCP_HANDLE)) != VM_RES_NOT_FIND)
        {
            if (vm_res_get_data(VM_RES_TYPE_TCP_HANDLE, 
                resHandle, (void**)&socketContext, &bufSize) == 0 && socketContext != NULL)
            {
                if (0 == type)
                {
                if (socketContext->sock == id)
                {
                    vm_res_findclose(VM_RES_TYPE_TCP_HANDLE);
                    return socketContext;
                }
                }
                else if (1 == type)
                {
                    if (socketContext->res_handle == id)
                    {
                        vm_res_findclose(VM_RES_TYPE_TCP_HANDLE);
                        return socketContext;
                    }
                }
            }
        }
        vm_res_findclose(VM_RES_TYPE_TCP_HANDLE);
    }   
    return NULL;
}

	//abm hold
kal_uint32 vm_get_tcp_acctid_by_resid(VMINT res_id)
{
    VMINT resHandle = 0, bufSize = 0;
    vm_sock_context_t* socketContext = NULL;
    
    if ((resHandle = vm_res_findfirst(-1, VM_RES_TYPE_TCP_HANDLE)) != VM_RES_NOT_FIND)
    {
        if (vm_res_get_data(VM_RES_TYPE_TCP_HANDLE, 
            resHandle, (void**)&socketContext, &bufSize) == 0 && socketContext != NULL)
        {
            if (socketContext->res_handle == res_id)
            {
                vm_res_findclose(VM_RES_TYPE_TCP_HANDLE);
                return socketContext->account_id;
            }
        }

        while ((resHandle = vm_res_findnext(-1, VM_RES_TYPE_TCP_HANDLE)) != VM_RES_NOT_FIND)
        {
            if (vm_res_get_data(VM_RES_TYPE_TCP_HANDLE, 
                resHandle, (void**)&socketContext, &bufSize) == 0 && socketContext != NULL)
            {
                if (socketContext->res_handle == res_id)
                {
                    vm_res_findclose(VM_RES_TYPE_TCP_HANDLE);
                    return socketContext->account_id;
                }
            }
        }
        vm_res_findclose(VM_RES_TYPE_TCP_HANDLE);
    }   
    return 0;
}

static vm_sock_context_t* vm_malloc_socket_context(void)
{
    vm_sock_context_t* socket_context = NULL;

    if ((socket_context = _vm_kernel_calloc(sizeof(vm_sock_context_t))) != NULL)
    {
        if ((socket_context->res_handle = vm_res_save_data(VM_RES_TYPE_TCP_HANDLE, 
            (void*)socket_context, sizeof(socket_context), NULL, vm_pmng_get_current_handle())) >= 0)
        {
            MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_564, socket_context->res_handle);
			
            return socket_context;
        }
        else
        {
            _vm_kernel_free(socket_context);
        }
    }

    return NULL;
}

static void vm_free_socket_context(vm_sock_context_t* context_ptr)
{
    //if (context_ptr) // internal function, unnecessary to check
    //{
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_581, context_ptr->res_handle);
		
        vm_res_release_data(VM_RES_TYPE_TCP_HANDLE, context_ptr->res_handle);
        _vm_kernel_free(context_ptr);
    //}
}
static void vm_close_and_free_socket(VMINT8 soc_id)
{
    vm_sock_context_t* context_ptr;
    context_ptr = vm_get_socket_context(soc_id, 0);
    if (context_ptr)
    {
        soc_close(context_ptr->sock);
        vm_free_socket_context(context_ptr);
    }
}

static VMINT vm_cmp_wstr_ignore_case(VMWSTR str_1, VMWSTR str_2, VMUINT count)
{
    if (mmi_wcsnicmp((const WCHAR *)str_1, (const WCHAR *)str_2, count) == 0)
        return TRUE;

    return FALSE;
}

/*
#ifdef __MMI_WLAN_FEATURES__
static U16 wifi_status = DTCNT_BEARER_STATE_INACTIVE;
static void vm_wifi_status_callback_handler(U16 status)
{
    wifi_status = status;
}
#endif


void vm_mre_wifi_init(void)
{
#ifdef __MMI_WLAN_FEATURES__
    mmi_wlan_add_event_notify_hdlr(vm_wifi_status_callback_handler);
#endif  
}

VMINT vm_tcp_wifi_connected (void)
{
#ifdef __MMI_WLAN_FEATURES__
    if (wifi_status == DTCNT_BEARER_STATE_CONNECTED)
    {
        return TRUE;
    }
#endif
    return FALSE;
}
*/

VMINT vm_is_support_wifi(void)
{
    return stub_tcp_is_support_wifi();
}

VMINT vm_wifi_is_connected(void)
{
    return vm_wlan_get_status();
}


VMINT _vm_reg_tcp_module(void)
{
    int res_code = REG_MRE_MODULE_SUCCESS;
    
    if ((res_code = _vm_reg_module("TCP", 
        (MOD_EVT_PROCESS)sock_mod_evt_proc)) != REG_MRE_MODULE_SUCCESS)
    {
        MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMSOCK_672 , res_code);
    }

    return res_code;
}

static VMINT vm_get_apn_info_internal(vm_apn_info_ext *apn_info, kal_uint32 accid);
VMINT vm_tcp_apn_exists(VMINT apn)
{
#ifdef __MRE_SAL_SIM__  
#if 1
    VMUINT dtacct_id;
    vm_apn_info_ext apn_info;

    
    if (VM_E_SOC_SUCCESS == vm_get_encoded_dtacct_id(apn, &dtacct_id) && 
        0 == vm_get_apn_info_internal(&apn_info, dtacct_id))
    {
        return 1;
    }
    else
        return 0;

    

#else
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif

#endif  
}

static VMINT vm_soc_get_host_by_name_int(VMINT handle, 
                                         const VMCHAR * host, 
                                         VMBYTE * addr, 
                                         VMBYTE * addr_len, 
                                         VMUINT dtacct_id, 
                                         VMINT (*callback)(VMINT handle, vm_soc_dns_result * rst));
static VMINT vm_soc_get_host_by_name_cb(VMINT handle, vm_soc_dns_result * rst);
static VMINT vm_soc_get_host_by_name_int_cb(void* msg);
VMINT g_mre_account_id = 0;
VMINT vm_tcp_connect(const char* host, const VMINT port, const VMINT apn,
    void (*callback)(VMINT handle, VMINT event))
{
    VMUINT account_id = 0;
    VMINT i = 0, apn_check;
    //srv_dtcnt_sim_type_enum sim_type;
#ifdef  __MRE_SAL_SIM__
    //operator_t ioperator;// = CMCC;
#endif
    vm_sock_context_t* context_ptr = NULL;
        //srv_dtcnt_sim_type_enum sim_type;
    
    MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_CONNECT, host, port, apn, callback, __LINE__);
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif

    // check params 
    if (!host  || port <= 0 || !callback)
    {
        /* MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMSOCK_776 ); */
        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_CONNECT_ERR_02, VM_TCP_ERR_CREATE_FAILED, __LINE__);
        return VM_TCP_ERR_CREATE_FAILED;
    }

    apn_check = (apn != VM_TCP_APN_CMNET && apn != VM_TCP_APN_CMWAP &&
                 apn != VM_TCP_APN_CMWAP_ONLY && apn != VM_TCP_APN_CMNET_ONLY && 
                 apn != VM_APN_USER_DEFINE);
    // check apn
    if (stub_tcp_is_support_wifi())
    {
        if (apn_check && apn != VM_TCP_APN_WIFI)
        {
            /* MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMSOCK_788 , apn); */
            MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_CONNECT_ERR_03, apn, VM_TCP_ERR_CREATE_FAILED, __LINE__);
            return VM_TCP_ERR_CREATE_FAILED;
        }       
    }
    else
    {
        if (apn_check)
        {
            /* MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMSOCK_798 , apn); */
            MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_CONNECT_ERR_04, apn, VM_TCP_ERR_CREATE_FAILED, __LINE__);
            return VM_TCP_ERR_CREATE_FAILED;
        }
    }

    // 没有更多的资源 
    if ((context_ptr = vm_malloc_socket_context()) == NULL) 
    {
        /* MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMSOCK_807 ); */
        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_CONNECT_ERR_05, apn, VM_TCP_ERR_CREATE_FAILED, __LINE__);
        return VM_TCP_ERR_NO_ENOUGH_RES;
    }
    
    context_ptr->port = port;
    context_ptr->callback = callback;

    if (0 > vm_get_encoded_dtacct_id(apn, &account_id))
    {
        vm_free_socket_context(context_ptr);
    	return VM_TCP_ERR_CREATE_FAILED;
    }

        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_CONNECT_DTCNT_ID, i, account_id);

       
        // 没有找到适合的APN帐号，则返回失败。
        if ((cbm_result_error_enum)account_id == CBM_INVALID_ACCT_ID)
        {
            //vm_free_socket_context(context_ptr);
            /* MMI_TRACE(MMI_MRE_TRC_WARNING, TRC_MRE_VMSOCK_828 ); */
            MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_CONNECT_ERR_11, VM_TCP_ERR_CREATE_FAILED, __LINE__);
            vm_free_socket_context(context_ptr);
            return VM_TCP_ERR_CREATE_FAILED;
        }
    //srv_dtcnt_get_sim_preference(&sim_type);
    if ((stub_tcp_is_support_wifi() && VM_TCP_APN_WIFI == apn)
#ifdef __COSMOS_MMI_PACKAGE__      
       // || (srv_mre_da_get_account_id(SRV_MRE_DA_WIFI_ONLY) == 1)
       // || (sim_type == SRV_DTCNT_SIM_TYPE_NONE)
#endif
        )
    {
        if (SRV_DTCNT_WLAN_STATUS_INACTIVE == srv_dtcnt_wlan_status())
        {
            //MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_E3, 2, __LINE__);
            vm_free_socket_context(context_ptr);
            return VM_TCP_ERR_CREATE_FAILED;
        }
    }

    if ((context_ptr->sock = soc_create(PF_INET, SOCK_STREAM, 0, MOD_MMI, account_id)) >= 0)
    {
        kal_uint8 val = 1;

        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_CONNECT_CREATED_SOC, context_ptr->sock, account_id);
        
        if (soc_setsockopt(context_ptr->sock, SOC_NBIO, &val, sizeof(val)) < 0)
        {
            vm_close_and_free_socket(context_ptr->sock);

            /* MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMSOCK_845 ); */
            MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_CONNECT_ERR_07, VM_TCP_ERR_CREATE_FAILED, __LINE__);
        }
        else
        {   
            val = SOC_READ | SOC_WRITE | SOC_CLOSE | SOC_CONNECT;
            if (soc_setsockopt(context_ptr->sock, SOC_ASYNC, &val, sizeof(val)) < 0)
            {
                vm_close_and_free_socket(context_ptr->sock);

                /* MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMSOCK_856 ); */
                MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_CONNECT_ERR_08, VM_TCP_ERR_CREATE_FAILED, __LINE__);
            }
            else                                            // 开始连接过程
            {
                sockaddr_struct addr;               // connect 地址
                kal_uint8 buf[4] = {0}, addr_len = 0;
                kal_int8 ret = -1;
                kal_bool is_ip_valid;
                kal_char* host_name  = vm_malloc(strlen(host) + 1);
                memset(host_name, 0x00, strlen(host) + 1);
                strcpy(host_name, host);

                //memset(&addr, 0x00, sizeof(addr));
                MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_LOG, 11, __LINE__, 
                    apn, 0, 0, 0, 0, 0);
                if (apn == VM_TCP_APN_CMWAP)    // cmwap 连接
                {
                    //kal_char* host_name  = vm_malloc(strlen(host) + 1);
                    //kal_bool is_ip_valid;
                    //kal_uint8 buf[4];
                    kal_uint8 len = 0;
                    
                    if (!host_name)
                    {
                        vm_free_socket_context(context_ptr);
                        return VM_TCP_ERR_CREATE_FAILED;
                    }
                    //memset(buf, 0x00, sizeof(buf));
                
                    if (soc_ip_check(host_name, addr.addr, &is_ip_valid) == KAL_FALSE)
                    {
                        #define WAP_DNS 
                        #ifdef WAP_DNS 
	//abm hold
                        ret = vm_soc_get_host_by_name_int((VMINT)context_ptr->res_handle, host, buf, &addr_len, account_id, vm_get_host_by_name_1); 
                        if (ret == SOC_SUCCESS)             // success
                        {
                            //addr.addr[0] = buf[0];    
                            //addr.addr[1] = buf[1];
                            //addr.addr[2] = buf[2];
                            //addr.addr[3] = buf[3];
                            memcpy(addr.addr, buf, 4);
                            addr.addr_len = addr_len;
                            addr.port = port;              
                            MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_LOG, 0, __LINE__, 
                                                                                        addr.addr_len > 0 ? addr.addr[addr.addr_len - 4] : -1,
                                                                                        addr.addr_len > 0 ? addr.addr[addr.addr_len - 3] : -1,
                                                                                        addr.addr_len > 0 ? addr.addr[addr.addr_len - 2] : -1,
                                                                                        addr.addr_len > 0 ? addr.addr[addr.addr_len - 1] : -1,
                                                                                        addr.addr_len);
                            
                        }
                        else if (ret == SOC_WOULDBLOCK)         // block
                        {
                            MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_E1, 11, __LINE__);
	//abm hold
                            return context_ptr->res_handle;
                        }
                        else                                    // error
                        {
                            MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_CONNECT_ERR_09, context_ptr->sock);
                            vm_close_and_free_socket(context_ptr->sock);
                            
                            return VM_TCP_ERR_CREATE_FAILED;
                        }
                        
                        vm_free(host_name);

                        #else

                        vm_free(host_name);
                        vm_close_and_free_socket(context_ptr->sock);
                        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_E1, 11, __LINE__);
                        return VM_TCP_ERR_CREATE_FAILED;
                        #endif
                    }
                    else if (is_ip_valid == KAL_FALSE)
                    {
                        vm_free(host_name);
                        vm_close_and_free_socket(context_ptr->sock);
                        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_E2, 11, __LINE__);
                        return VM_TCP_ERR_CREATE_FAILED;
                    }
                    else
                    {
                        vm_free(host_name);
                        addr.addr_len = 4;
                        addr.port = port;
                        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_LOG, 11, __LINE__, 
                            addr.port, addr.addr_len, 0, 0, 0, 0);
                    }                   
                }
                else                                // cmnet 连接
                {

                    if (!host_name)
                    {
                        vm_free_socket_context(context_ptr);
                        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_E3, 11, __LINE__);
                        return VM_TCP_ERR_CREATE_FAILED;
                    }
                    //memset(buf, 0x00, sizeof(buf));
                    //memset(host_name, 0x00, strlen(host) + 1);
                    //strcpy(host_name, host);
                    
                    if (soc_ip_check(host_name, addr.addr, &is_ip_valid) == KAL_FALSE)
                    {
                        // 是主机名而非ip地址 
                        vm_free(host_name);
                        #ifndef OLD_SOCK
	//abm hold
                        ret = vm_soc_get_host_by_name_int((VMINT)context_ptr->res_handle, host, buf, &addr_len, account_id, vm_get_host_by_name_1); 
                        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_LOG, 11, __LINE__, 
                            apn, context_ptr->res_handle, account_id, addr_len, 0, 0);
                        #else
                        ret = soc_gethostbyname(KAL_FALSE, MOD_MMI, context_ptr->sock, 
                            host, buf, &addr_len, 0, account_id); //这里的request id 就是socket id。
                        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_LOG, 11, __LINE__, 
                            apn, context_ptr->sock, account_id, addr_len, 0, 0);
                        #endif
                        if (ret == SOC_SUCCESS)             // success
                        {
                            //addr.addr[0] = buf[0];    
                            //addr.addr[1] = buf[1];
                            //addr.addr[2] = buf[2];
                            //addr.addr[3] = buf[3];
                            memcpy(addr.addr, buf, 4);
                            addr.addr_len = addr_len;
                            addr.port = port;                       
                            MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_LOG, 0, __LINE__, 
                                                                                        addr.addr_len > 0 ? addr.addr[addr.addr_len - 4] : -1,
                                                                                        addr.addr_len > 0 ? addr.addr[addr.addr_len - 3] : -1,
                                                                                        addr.addr_len > 0 ? addr.addr[addr.addr_len - 2] : -1,
                                                                                        addr.addr_len > 0 ? addr.addr[addr.addr_len - 1] : -1,
                                                                                        addr.addr_len, 0);
                        }
                        else if (ret == SOC_WOULDBLOCK)         // block
                        {
                            #ifdef OLD_SOCK
                            context_ptr->socket_state = conn_host_by_name;
                            mmi_frm_set_protocol_event_handler(MSG_ID_APP_SOC_GET_HOST_BY_NAME_IND, (PsIntFuncPtr)vm_get_host_by_name, MMI_TRUE);
	//abm hold
                            MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_CONNECT_GET_HOST, context_ptr->res_handle);
                            #endif
                            MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_E4, 11, __LINE__);
	//abm hold
                            context_ptr->account_id = account_id;
                            return context_ptr->res_handle;
                        }
                        else                                    // error
                        {
                            vm_close_and_free_socket(context_ptr->sock);

                            /* MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMSOCK_1005 ); */
                            MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_CONNECT_ERR_09, context_ptr->sock);
                            return VM_TCP_ERR_CREATE_FAILED;
                        }
                    }
                    else if (is_ip_valid == KAL_FALSE)  
                    {
                        // 非法的ip 地址 
                        vm_free(host_name);
                        vm_close_and_free_socket(context_ptr->sock);
                        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_FAILURE, 11, __LINE__, 0);
                        return VM_TCP_ERR_CREATE_FAILED;
                    }
                    else
                    {
                        vm_free(host_name);
                        addr.addr_len = 4;
                        addr.port = port;
                        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_CONNECT_IP_HOST, context_ptr->sock);
                    }
                }   

                // 对于cmnet ，只有在get_host_by_name成功后才可能走连接过程。 
                switch (soc_connect(context_ptr->sock, &addr))
                {
                    case SOC_SUCCESS:
                    case SOC_WOULDBLOCK:
                        mmi_frm_set_protocol_event_handler(MSG_ID_APP_SOC_NOTIFY_IND, (PsIntFuncPtr)vm_soc_notify, MMI_TRUE);
	//abm hold
                        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_CONNECT_WAIT, context_ptr->res_handle);
                        context_ptr->account_id = account_id;
                        return context_ptr->res_handle;
                    default:
                        vm_close_and_free_socket(context_ptr->sock);
                        break;
                }
            }
        }
    }
    else
    {
        vm_close_and_free_socket(context_ptr->sock);
        
        /* MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMSOCK_1049 ); */
        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_CONNECT_ERR_10, VM_TCP_ERR_CREATE_FAILED, __LINE__);
    }

    return VM_TCP_ERR_CREATE_FAILED;
}

void vm_tcp_close(VMINT handle)
{
    vm_sock_context_t* socketContext = NULL;
    sock_connection_t state;
    //VM_P_HANDLE pHandle = vm_pmng_get_current_handle();


    MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_CLOSE, handle);
    
	//abm hold
    if ((socketContext = vm_get_socket_context(handle, 1)) != NULL)
        //&& vm_res_get_process_handle(VM_RES_TYPE_TCP_HANDLE, socketContext->res_handle) == pHandle)
    {
        state = socketContext->socket_state;
        if (state <= conn_connected 
            || state == conn_unkown)
        {
            if (state == conn_host_by_name)
            {
	//abm hold
                soc_abort_dns_query(KAL_TRUE, MOD_MMI, KAL_TRUE, socketContext->sock, 
                    KAL_FALSE, 0, KAL_FALSE, 0);
                MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_1074 , socketContext->sock);
            }
            MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_1076 , socketContext->sock);
	//abm hold
            soc_close((kal_int8)socketContext->sock);
            vm_free_socket_context(socketContext);
	//abm hold
            MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_CLOSE_END, socketContext->sock);
            return;
        }
    }
}

VMINT vm_tcp_read(VMINT handle, void* buf, VMINT len)
{
    kal_int32 ret = 0;
    vm_sock_context_t* context_ptr = NULL;

    if (!buf || len <= 0)
    {
        return 0;
    }

	//abm hold
    if ((context_ptr = vm_get_socket_context(handle, 1)) == NULL) 
    {
        return (VM_TCP_READ_EOF  -2);
    }
    
    if (context_ptr->socket_state != conn_connected || context_ptr->read_pipe_state <= read_block)
    {
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_1102 , handle);
        return 0; 
    }

    if ((ret = soc_recv(context_ptr->sock, (kal_uint8*)buf, len, 0)) <= 0)
    {
        if (ret == SOC_WOULDBLOCK)
        {
	//abm hold
            MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_1110 , context_ptr->sock);
            context_ptr->read_pipe_state = read_block;
            return 0;
        }
        else if (ret == 0)
        {
	//abm hold
            MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_1116 , context_ptr->sock);
            return VM_TCP_READ_EOF;
        }
        else
        {
	//abm hold
            MMI_TRACE(MMI_MRE_TRC_WARNING, TRC_MRE_VMSOCK_1121 , context_ptr->sock);
            return (VM_TCP_READ_EOF - 1);
        }
    }
    else
    {
	//abm hold
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_1127, context_ptr->sock, ret);
		
    }
    return ret;
}

VMINT vm_tcp_write(VMINT handle, void* buf, VMINT len)
{
    vm_sock_context_t* context_ptr = NULL;
    kal_int32 ret = 0;

    if (!buf || len <= 0)
    {
        return 0;
    }

	//abm hold
    if ((context_ptr = vm_get_socket_context(handle, 1)) == NULL)
    {
        return -1;
    }
    
    if (context_ptr->socket_state != conn_connected || context_ptr->write_pipe_state <= write_block)
    {
	//abm hold
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_1150 , context_ptr->sock);
        return 0;
    }

    if ((ret = soc_send(context_ptr->sock, (kal_uint8*)buf, len, 0)) < 0)
    {
        if (ret == SOC_WOULDBLOCK)
        {
	//abm hold
            MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_1158 , context_ptr->sock);
            context_ptr->write_pipe_state = write_block;
            return 0;
        }
        else
        {
	//abm hold
            MMI_TRACE(MMI_MRE_TRC_WARNING, TRC_MRE_VMSOCK_1164 , context_ptr->sock);
            return -1;
        }
    }
    else
    {
	//abm hold
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_1170 , context_ptr->sock, ret);
    }
    
    return ret;
}

VMINT vm_soc_get_host_by_name(VMINT apn, 
                                                                            const VMCHAR * host, 
                                                                            vm_soc_dns_result * result, 
                                                                            VMINT (*callback)(vm_soc_dns_result *))
{
    vm_sock_context_t * soc_ctx = NULL;
    VMUINT dtacct_id = 0;
    kal_uint8 val = 1;
    VMINT ret = 0;
    VMBYTE addr[32] = {0};
    VMBYTE addr_len = 0;
    
    MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_S, 1, __LINE__);

    if (NULL == host || 
        NULL == callback ||
        NULL == result || 
        (VM_TCP_APN_CMNET != apn && VM_TCP_APN_WIFI != apn) &&
        apn != VM_TCP_APN_CMNET_ONLY && 
        apn != VM_APN_USER_DEFINE)
    {
        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_FAILURE, 1, __LINE__, -8);
        return VM_E_SOC_INVAL;
    }
    
    if (NULL == (soc_ctx = vm_malloc_socket_context())) 
    {
        /* MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMSOCK_1202 ); */
        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_FAILURE, 1, __LINE__, VM_TCP_ERR_NO_ENOUGH_RES);
        return VM_E_SOC_LIMIT_RESOURCE;
    }
    
    //soc_ctx->port = port;
    //soc_ctx->callback = callback;

    // wifi & cmnet use the same apid witch registered from cbm.
    if (0 > vm_get_encoded_dtacct_id(apn, &dtacct_id))
    {
        vm_free_socket_context(soc_ctx);
        // 没有找到适合的APN帐号，则返回失败。
        if (CBM_INVALID_ACCT_ID == (cbm_result_error_enum)dtacct_id)
        {
            MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_FAILURE, 1, __LINE__, -6);
            return VM_E_SOC_INVALID_ACCOUNT; 
        }
        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_FAILURE, 1, __LINE__, -7);
        return VM_E_SOC_INVALID_ACCOUNT;
    }
    
    if (0 > (soc_ctx->sock = soc_create(PF_INET, SOCK_STREAM, 0, MOD_MMI, dtacct_id)))
    {
        vm_free_socket_context(soc_ctx);
        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_FAILURE, 1, __LINE__, -5);
        return VM_E_SOC_ERROR;
    }

    if (0 > soc_setsockopt(soc_ctx->sock, SOC_NBIO, &val, sizeof(val)))
    {
        vm_close_and_free_socket(soc_ctx->sock);
        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_FAILURE, 1, __LINE__, -5);
        return VM_E_SOC_ERROR;
    }
/*
    val = SOC_READ | SOC_WRITE | SOC_CLOSE | SOC_CONNECT;
    if (0 > soc_setsockopt(soc_ctx->sock, SOC_ASYNC, &val, sizeof(val)))
    {
        soc_close(soc_ctx->sock);
        vm_free_socket_context(soc_ctx);
        return -5; // TODO: check value
    }
    */
    //soc_ctx->cb = (void(*)(void))callback;
    if (NULL == vm_soc_ctx_cb_push(soc_ctx, (void (*)(void))callback))
    {
        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_FAILURE, 1, __LINE__, -5);
        return VM_E_SOC_ERROR;
    }

	//abm hold
    if (SOC_SUCCESS == (ret = vm_soc_get_host_by_name_int(soc_ctx->res_handle, 
                                        host,
                                        addr,
                                        &addr_len, 
                                        dtacct_id,
                                        vm_soc_get_host_by_name_cb)))
    {
        //memcpy(&(result.address[0]), addr, 4);
/*        result.address = (VMUINT*)addr;
        result.num = 1;
        result.error_cause = 0;
        callback(&result);*/
        memcpy(result->address, addr, 4);
        result->error_cause = 0;
        result->num = 1;
        {
        VMINT i = 0;
        kal_uint8 * p = NULL;
        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_LOG, 1, __LINE__, 
            result->num, 0, 0, 0, 0, 0);
        for (i = 0; i < result->num; i ++)
        {
            p = (kal_uint8*)(result->address + i);
            MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_LOG, 1, __LINE__, 
                                                    p[0],
                                                    p[1],
                                                    p[2],
                                                    p[3], 0, 0);
        }
        }
        vm_close_and_free_socket(soc_ctx->sock);
    }

    MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_E, 1, __LINE__);

    return ret;    
}

static void vm_fill_app_info(cbm_app_info_struct *app_info, kal_uint16 str_id, kal_uint64 type)
{
    app_info->app_icon_id = GetRootTitleIcon(IMAGE_MRE_SMALL_ICON);
    app_info->app_str_id = str_id;
    app_info->app_type = type;
}

static VMUINT8 app_id_net;
static VMUINT8 app_id_wap;
static VMUINT8 app_id_net_only;
static VMUINT8 app_id_wap_only;
static VMUINT8 app_id_wifi;
// DIS WLAN
#include "vmenv.h"
static VMUINT8 app_id_net_dis_wlan;
static VMUINT8 app_id_wap_dis_wlan;
static VMUINT8 app_id_net_only_dis_wlan;
static VMUINT8 app_id_wap_only_dis_wlan;
VMINT vm_get_app_id(VMINT apn, VMUINT8 *app_id)
{

    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
    cbm_app_info_struct app_info;
    kal_int8 ret = 0;
    // DIS WLAN
    VM_PROCESS_STATUS status = VM_PMNG_UNLOAD;
    _vm_pcb_t* pcb = NULL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    // DIS WLAN
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_DIS_WLAN_S, 2, __LINE__);
    pcb = vm_sh_pcb_in_pt(SH_TYPE_PROCESS_HANDLE, vm_pmng_get_current_handle(), &status);
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_DIS_WLAN_LOG, 
        apn,
        pcb,
        0,
        0,
        0,
        pcb ? (VMUINT)pcb->flag : (VMUINT)pcb,
        2, __LINE__);

    /* register app id */
    if (VM_TCP_APN_WIFI == apn)
    {
        if (app_id_wifi == 0)
        {
            vm_fill_app_info(&app_info, STR_MRE_NETWORK_WIFI, 
                DTCNT_APPTYPE_MRE_NET | DTCNT_APPTYPE_NO_PX);
            ret = cbm_register_app_id_with_app_info(&app_info, &app_id_wifi);
        }
        *app_id = app_id_wifi;
        vm_log_debug("[test] ret[%d] app_id [%d]", ret, app_id_wifi);
    }else if (VM_TCP_APN_CMNET == apn/* || 
        VM_TCP_APN_WIFI == apn*/
        || VM_APN_USER_DEFINE == apn
#ifndef DTCNT_APPTYPE_SKIP_WIFI
        || VM_TCP_APN_CMNET_ONLY == apn 
#endif
        ) 
    {
    // DIS WLAN
        if (pcb && (VM_FLAG_DIS_WLAN_PERFER == (VM_FLAG_DIS_WLAN_PERFER & pcb->flag)))
        {
            if (app_id_net_dis_wlan == 0)
            {
            	vm_fill_app_info(&app_info, STR_MRE_NETWORK_CMNET_DIS_WLAN, 
                	DTCNT_APPTYPE_MRE_NET | DTCNT_APPTYPE_NO_PX | DTCNT_APPTYPE_NO_SCR);
                ret = cbm_register_app_id_with_app_info(&app_info, &app_id_net_dis_wlan);
            }
            MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_DIS_WLAN_E3, 20, __LINE__);
            *app_id = app_id_net_dis_wlan;
        }
        else
        {
            if (app_id_net == 0)
            {
            	vm_fill_app_info(&app_info, STR_MRE_NETWORK_CMNET, 
                	DTCNT_APPTYPE_MRE_NET | DTCNT_APPTYPE_NO_PX);
                ret = cbm_register_app_id_with_app_info(&app_info, &app_id_net);
            }
            *app_id = app_id_net;
        }
    }
    else if (VM_TCP_APN_CMWAP == apn
#ifndef DTCNT_APPTYPE_SKIP_WIFI
                || VM_TCP_APN_CMWAP_ONLY == apn 
#endif
        )
    {
    
    // DIS WLAN
        if (pcb && (VM_FLAG_DIS_WLAN_PERFER == (VM_FLAG_DIS_WLAN_PERFER & pcb->flag)))
        {
            if (app_id_wap_dis_wlan == 0)
            {
            	vm_fill_app_info(&app_info, STR_MRE_NETWORK_CMWAP_DIS_WLAN, 
                	DTCNT_APPTYPE_MRE_NET | DTCNT_APPTYPE_NO_PX | DTCNT_APPTYPE_NO_SCR);
                ret = cbm_register_app_id_with_app_info(&app_info, &app_id_wap_dis_wlan);
            }
            MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_DIS_WLAN_E3, 21, __LINE__);
            *app_id = app_id_wap_dis_wlan;
        }
        else
        {
            if (app_id_wap == 0)
            {
            vm_fill_app_info(&app_info, STR_MRE_NETWORK_CMWAP, 
                DTCNT_APPTYPE_MRE_WAP | DTCNT_APPTYPE_NEED_PX);
                ret = cbm_register_app_id_with_app_info(&app_info, &app_id_wap);
            }
            *app_id = app_id_wap;
        }
    }
    #ifdef DTCNT_APPTYPE_SKIP_WIFI
    else if (VM_TCP_APN_CMNET_ONLY == apn)
    {
    
    // DIS WLAN
        if (pcb && (VM_FLAG_DIS_WLAN_PERFER == (VM_FLAG_DIS_WLAN_PERFER & pcb->flag)))
        {
            if (app_id_net_only_dis_wlan == 0)
            {
            	vm_fill_app_info(&app_info, STR_MRE_NETWORK_CMNET_ONLY_DIS_WLAN, 
                	DTCNT_APPTYPE_MRE_NET | DTCNT_APPTYPE_NO_PX | DTCNT_APPTYPE_NO_SCR);
                ret = cbm_register_app_id_with_app_info(&app_info, &app_id_net_only_dis_wlan);
            }
            MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_DIS_WLAN_E3, 22, __LINE__);
            *app_id = app_id_net_only_dis_wlan;
        }
        else
        {
            if (app_id_net_only == 0)
            {
            	vm_fill_app_info(&app_info, STR_MRE_NETWORK_CMNET_ONLY, 
                	DTCNT_APPTYPE_MRE_NET | DTCNT_APPTYPE_NO_PX | DTCNT_APPTYPE_SKIP_WIFI);
                ret = cbm_register_app_id_with_app_info(&app_info, &app_id_net_only);
            }
            *app_id = app_id_net_only;
        }
    }
    else if (VM_TCP_APN_CMWAP_ONLY == apn)
    {
    
        if (pcb && (VM_FLAG_DIS_WLAN_PERFER == (VM_FLAG_DIS_WLAN_PERFER & pcb->flag)))
        {
            if (app_id_wap_only_dis_wlan == 0)
            {
            	vm_fill_app_info(&app_info, STR_MRE_NETWORK_CMWAP_ONLY_DIS_WLAN, 
                	DTCNT_APPTYPE_MRE_NET | DTCNT_APPTYPE_NO_PX | DTCNT_APPTYPE_NO_SCR);
                ret = cbm_register_app_id_with_app_info(&app_info, &app_id_wap_only_dis_wlan);
            }
            MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_DIS_WLAN_E3, 23, __LINE__);
            *app_id = app_id_wap_only_dis_wlan;
        }
        else
        {
            if (app_id_wap_only == 0)
            {
            	vm_fill_app_info(&app_info, STR_MRE_NETWORK_CMWAP_ONLY, 
                	DTCNT_APPTYPE_MRE_WAP | DTCNT_APPTYPE_SKIP_WIFI | DTCNT_APPTYPE_NEED_PX);
                ret = cbm_register_app_id_with_app_info(&app_info, &app_id_wap_only);
            }
            *app_id = app_id_wap_only;
        }
    }
    #endif
    else
    {
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_DIS_WLAN_E1, 2, __LINE__);
        return VM_E_SOC_INVAL;
    }

    if (0 != ret)
    {
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_DIS_WLAN_E2, 2, __LINE__);
        return VM_E_SOC_INVALID_ACCOUNT;
    }
    
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_DIS_WLAN_E, 2, __LINE__);
    return VM_E_SOC_SUCCESS;
}

// custmized apn
static VMBOOL vm_is_cust_apn_set(void);
VMINT vm_get_encoded_dtacct_id(VMINT apn, VMUINT * dtacct_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    //srv_dtcnt_sim_type_enum sim_type;
    VMUINT dtacct = 0;
    VMUINT8 app_id = 0;
    kal_int8 ret = 0;
    VMBYTE prefer_b = 1;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_S, 3, __LINE__);

    if (NULL == dtacct_id)
    {
        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_E1, 3, __LINE__);
        return VM_E_SOC_INVAL;
    }

    /* Get APP ID */
    ret = vm_get_app_id(apn, &app_id);
    
    MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_LOG, 3, __LINE__, 
                                            apn,
                                            app_id, 
                                            0, 
                                            0, 0, ret);
                                            
    if (ret != VM_E_SOC_SUCCESS)
        return ret;
        
    //srv_dtcnt_get_sim_preference(&sim_type);

    if (stub_tcp_is_support_wifi() && VM_TCP_APN_WIFI == apn)
    {
        if(CBM_OK != cbm_get_valid_account_id(CBM_WIFI, (kal_uint32 *)&dtacct))
        {
            //vm_free_socket_context(context_ptr);
            /* MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMSOCK_1432 ); */
            MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_CONNECT_ERR_06, VM_TCP_ERR_CREATE_FAILED, __LINE__);
            return VM_E_SOC_INVALID_ACCOUNT;
        }

        *dtacct_id = (kal_uint32)cbm_encode_data_account_id((kal_uint32)dtacct, CBM_SIM_ID_SIM1, (kal_uint8)app_id, (kal_bool)0);
        
        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_CONNECT_WIFI_ACNT_ID, *dtacct_id);
    }
    else
    {

        dtacct = CBM_DEFAULT_ACCT_ID;
        
        if (VM_TCP_APN_CMNET_ONLY == apn)
        {
            if (SRV_DTCNT_RESULT_SUCCESS == srv_dtcnt_get_acc_id_by_apn("cmnet", &dtacct) || 
                SRV_DTCNT_RESULT_SUCCESS == srv_dtcnt_get_acc_id_by_apn("uninet", &dtacct))
            {
            }
            else
            {
                MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_FAILURE, 31, __LINE__, VM_E_SOC_INVALID_ACCOUNT);
                return VM_E_SOC_INVALID_ACCOUNT;
            }
        }
        else if (VM_TCP_APN_CMWAP_ONLY == apn)
        {
            if (SRV_DTCNT_RESULT_SUCCESS == srv_dtcnt_get_acc_id_by_apn("cmwap", &dtacct) || 
                SRV_DTCNT_RESULT_SUCCESS == srv_dtcnt_get_acc_id_by_apn("uniwap", &dtacct))
            {
            }
            else
            {
                MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_FAILURE, 32, __LINE__, VM_E_SOC_INVALID_ACCOUNT);
                return VM_E_SOC_INVALID_ACCOUNT;
            }
        }

#if __MMI_MRE_DTCNT_SETTING__
        switch(sim_type)
        {
            case SRV_DTCNT_SIM_TYPE_1:
                if (VM_TCP_APN_CMNET == apn)
                {
                    dtacct = srv_mre_da_get_account_id(SRV_MRE_DA_SIM1);
                }
                else if(VM_TCP_APN_CMWAP == apn)
                {
                    dtacct = srv_mre_da_get_account_id(SRV_MRE_DA_SIM1_PX);
                }
                break;
                
            case SRV_DTCNT_SIM_TYPE_2:
                if (VM_TCP_APN_CMNET == apn)
                {
                    dtacct = srv_mre_da_get_account_id(SRV_MRE_DA_SIM2);
                }
                else if(VM_TCP_APN_CMWAP == apn)
                {
                    dtacct = srv_mre_da_get_account_id(SRV_MRE_DA_SIM2_PX);
                }              
                break;

            default:
                /* Other card use default */
                //dtacct = CBM_DEFAULT_ACCT_ID;
                prefer_b = 0;
                break;
        }

        if (!prefer_b)
        {
            MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_LOG, 3, __LINE__, 
                                                    apn,
                                                    sim_type, 
                                                    0, 
                                                    0, 0, 1);
#ifdef __MRE_SAL_SIM__  
            if (VM_APN_USER_DEFINE == apn) // BAD PARAM CHECKING
            {
                VMUINT32 acct_id = 0;
                VM_PROCESS_STATUS status = VM_PMNG_UNLOAD;
                _vm_pcb_t* pcb = NULL;
                pcb = vm_sh_pcb_in_pt(SH_TYPE_PROCESS_HANDLE, vm_pmng_get_current_handle(), &status);
                if (pcb)
                {
                    MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_LOG, 301, __LINE__, 
                                                        status,
                                                        pcb->sim_id, 
                                                        pcb->accountId, 
                                                        0, 0, 1);
                    // custmized apn
                    if (CBM_MRE_ACCT_ID == (pcb->accountId & CBM_MRE_ACCT_ID))
                    {
                        // it will failure if cust apn was not set
                        if (!vm_is_cust_apn_set())
                        {
                            *dtacct_id = 0;
                            MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_CUST_APN_E5, 4, __LINE__);
                            return VM_E_SOC_ERROR;
                        }
                    }

                    *dtacct_id = cbm_encode_data_account_id(pcb->accountId, (cbm_sim_id_enum)(pcb->sim_id), app_id, (kal_bool)0);

                }
            }
            else
            {
                *dtacct_id = vm_get_account_id(dtacct, app_id);
            }
#endif
        }
        else
        {
            MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_LOG, 3, __LINE__, 
                                                    apn,
                                                    sim_type, 
                                                    0, 
                                                    0, 0, 2);
            if (VM_APN_USER_DEFINE == apn)
            {
                VMUINT32 acct_id = 0;
                VM_PROCESS_STATUS status = VM_PMNG_UNLOAD;
                _vm_pcb_t* pcb = NULL;
                pcb = vm_sh_pcb_in_pt(SH_TYPE_PROCESS_HANDLE, vm_pmng_get_current_handle(), &status);
                if (pcb)
                {
                    MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_LOG, 301, __LINE__, 
                                                        status,
                                                        pcb->sim_id, 
                                                        pcb->accountId, 
                                                        0, 0, 2);

                    // custmized apn
                    if (CBM_MRE_ACCT_ID == (pcb->accountId & CBM_MRE_ACCT_ID))
                    {
                        // it will failure if cust apn was not set
                        if (!vm_is_cust_apn_set())
                        {
                            *dtacct_id = 0;
                            MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_CUST_APN_E5, 4, __LINE__);
                            return VM_E_SOC_ERROR;
                        }
                    }

                    *dtacct_id = cbm_encode_data_account_id(pcb->accountId, (cbm_sim_id_enum)(pcb->sim_id), app_id, (kal_bool)0);

                }
            }
            else
            {
                *dtacct_id = cbm_encode_data_account_id((kal_uint32)dtacct, (cbm_sim_id_enum)(sim_type-1), app_id, (kal_bool)0);
            }
        }

#else /* __MMI_MRE_DTCNT_SETTING__ __COSMOS_MMI_PACKAGE__ */

#ifdef __MRE_SAL_SIM__  
        if (VM_APN_USER_DEFINE == apn)
        {
            VMUINT32 acct_id = 0;
            VM_PROCESS_STATUS status = VM_PMNG_UNLOAD;
            _vm_pcb_t* pcb = NULL;
            pcb = vm_sh_pcb_in_pt(SH_TYPE_PROCESS_HANDLE, vm_pmng_get_current_handle(), &status);
            if (pcb)
            {
                VMUINT result = 0;

                MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_LOG, 301, __LINE__, 
                    status,
                    pcb->sim_id, 
                    pcb->accountId, 
                    0, 0, 3);
                // custmized apn
                if (CBM_MRE_ACCT_ID == (pcb->accountId & CBM_MRE_ACCT_ID))
                {
                    // it will failure if cust apn was not set
                    if (!vm_is_cust_apn_set())
                    {
                        *dtacct_id = 0;
                        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_CUST_APN_E5, 4, __LINE__);
                        return VM_E_SOC_ERROR;
                    }
                }

                *dtacct_id = cbm_encode_data_account_id(pcb->accountId, (cbm_sim_id_enum)(pcb->sim_id), app_id, (kal_bool)0);

            }
            }
        else
        {
            /* encode account id, using default automatic account ID */
            *dtacct_id = vm_get_account_id(dtacct, app_id);
        }
#endif

#endif /* __COSMOS_MMI_PACKAGE__ */
    }
    
    g_mre_account_id = *dtacct_id;
    
    MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_E, 3, __LINE__);

    return VM_E_SOC_SUCCESS;
}

static MMI_BOOL  vm_soc_notify(void* inMsg)
{
    vm_sock_context_t* context_ptr = NULL;
    void (*notify_callback)(VMINT handle, VMINT event) = NULL;
    VM_P_HANDLE processHandle = 0;
    
    app_soc_notify_ind_struct* ind = (app_soc_notify_ind_struct*)inMsg;

    /* 防止对指向null 的指针的操作 */
    if (!ind)                   
    {
        MMI_TRACE(MMI_MRE_TRC_WARNING, TRC_MRE_VMSOCK_1552 );
        return MMI_FALSE;
    }

	//abm hold
    if ((context_ptr = vm_get_socket_context(ind->socket_id, 0)) != NULL)
    {
        /* 得到进程句柄。 */
        processHandle = vm_res_get_process_handle(VM_RES_TYPE_TCP_HANDLE, 
            context_ptr->res_handle);
        
        
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_1563 , 
            processHandle, context_ptr->sock, ind->event_type, context_ptr->res_handle);
    
        switch (ind->event_type)
        {
        case SOC_WRITE:
            context_ptr->write_pipe_state = write_notify;
            
            
            if (context_ptr->callback && context_ptr->socket_state == conn_connected)
            {
	//abm hold
                MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_1574 , context_ptr->res_handle);


	//abm hold
                TCP_PMNG_WRAP_CALLBACK(processHandle, 
                    context_ptr->callback, context_ptr->res_handle, VM_TCP_EVT_CAN_WRITE);
            }
            break;
        case SOC_READ:
            context_ptr->read_pipe_state= read_notify;
            if (context_ptr->callback && context_ptr->socket_state == conn_connected)
            {
	//abm hold
                MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_1591 , 
                    context_ptr->res_handle);


	//abm hold
                TCP_PMNG_WRAP_CALLBACK(processHandle, 
                    context_ptr->callback, context_ptr->res_handle, VM_TCP_EVT_CAN_READ);
            }
            break;
        case SOC_CONNECT:
            if (ind->result != FALSE)
            {
                MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_1608 , ind->socket_id);
                context_ptr->socket_state = conn_connected;
                context_ptr->read_pipe_state = read_notify;
                context_ptr->write_pipe_state = write_notify;

                if (context_ptr->callback)
                {
	//abm hold
                    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_1615 , 
                        context_ptr->res_handle);

	//abm hold
                    TCP_PMNG_WRAP_CALLBACK(processHandle, 
                        context_ptr->callback, context_ptr->res_handle, VM_TCP_EVT_CONNECTED);

                }
            }
            else
            {
                notify_callback = context_ptr->callback;


	//abm hold
                if (notify_callback)
                {
                    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_1636 , ind->socket_id);
                    TCP_PMNG_WRAP_CALLBACK(processHandle, 
                        notify_callback, context_ptr->res_handle, VM_TCP_EVT_PIPE_BROKEN);
                }

                vm_close_and_free_socket(ind->socket_id);
            }
            break;
        case SOC_CLOSE:
            notify_callback = context_ptr->callback;

                
	//abm hold
            if (notify_callback)
            {
                MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_1656 , ind->socket_id);
                TCP_PMNG_WRAP_CALLBACK(processHandle, 
                    notify_callback, context_ptr->res_handle, VM_TCP_EVT_PIPE_CLOSED);

                vm_close_and_free_socket(ind->socket_id);
            }           
            break;
        default:
            MMI_TRACE(MMI_MRE_TRC_WARNING, TRC_MRE_VMSOCK_1669 , ind->event_type);
        }

        return MMI_TRUE;
    }
    
    return MMI_FALSE;
}

static VMINT vm_get_host_by_name_1(VMINT handle, vm_soc_dns_result * rst)
{
    vm_sock_context_t* context_ptr = NULL;
    void (*notify_callback)(VMINT handle, VMINT event) = NULL;
    VM_P_HANDLE processHandle = -1;
    sockaddr_struct address;
    
    MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_S, 2, __LINE__);

    if (!rst)
    {
        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_FAILURE, 2, __LINE__, 0);
        return MMI_FALSE;
    }

    if (!rst->address)
    {
        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_FAILURE, 2, __LINE__, 0);
        return MMI_FALSE;
    }
    
    if (!rst->num)
    {
        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_E1, 2, __LINE__);
        return MMI_FALSE;
    }
    MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_LOG, 2, __LINE__, 
                        rst->address[0], 
                        rst->address[1],
                        rst->address[2],
                        rst->address[3],
                        rst->num, 
                        rst->error_cause);
    //                    rst->error_cause);
	//abm hold
    context_ptr = vm_get_socket_context(handle, 1);
    if (NULL == context_ptr)
        return MMI_FALSE;

    processHandle = vm_res_get_process_handle(VM_RES_TYPE_TCP_HANDLE, context_ptr->res_handle);

    //memset(&address, 0x00, sizeof(address));
    memcpy(address.addr, rst->address, 4);
    address.addr_len = 4;
    address.port = context_ptr->port;

    
    
    switch (soc_connect(context_ptr->sock, &address))
    {
    case SOC_SUCCESS:
    case SOC_WOULDBLOCK:
        mmi_frm_set_protocol_event_handler(MSG_ID_APP_SOC_NOTIFY_IND, (PsIntFuncPtr)vm_soc_notify, MMI_TRUE);
        break;
    default:
        notify_callback = context_ptr->callback;
        vm_free_socket_context(context_ptr);
        soc_close((kal_int8)handle);
        
        if (notify_callback)
        {
            if (processHandle >= 0)
            {
                TCP_PMNG_WRAP_CALLBACK(processHandle, 
                    notify_callback, handle, VM_TCP_EVT_PIPE_BROKEN);
            }
            else
            {
                MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_FAILURE, 2, __LINE__, processHandle);
            }
        }               
        break;
    }

    
    MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_E, 2, __LINE__);

    return MMI_FALSE;
    
}

static VMINT vm_soc_get_host_by_name_cb(VMINT handle, vm_soc_dns_result * rst)
{
    vm_sock_context_t* soc_ctx = NULL;
    VM_P_HANDLE handle_p = -1;
    VMINT (*tmp_cb)(vm_soc_dns_result *);
    VMINT ret = 0;
    
    MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_S, 11, __LINE__);
    
    if (!rst)
    {
        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_FAILURE, 11, __LINE__, rst);
        return MMI_FALSE;
    }

    if (!rst->address)
    {
        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_FAILURE, 11, __LINE__, rst->address);
        return MMI_FALSE;
    }

    
	//abm hold
    soc_ctx = vm_get_socket_context(handle, 1);
    if (NULL == soc_ctx)
    {
        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_FAILURE, 11, __LINE__, soc_ctx);
        return MMI_FALSE;
    }
    
    tmp_cb = (VMINT (*)(vm_soc_dns_result *))vm_soc_ctx_cb_pop(soc_ctx);
    if (NULL == tmp_cb)
    {
        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_FAILURE, 11, __LINE__, soc_ctx->cb_num);
        vm_close_and_free_socket(soc_ctx->sock);
        return MMI_FALSE;
    }
    
    handle_p = vm_res_get_process_handle(VM_RES_TYPE_TCP_HANDLE, 
            soc_ctx->res_handle);
    if (0 > handle_p)
    {
        vm_close_and_free_socket(soc_ctx->sock);
        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_FAILURE, 11, __LINE__, soc_ctx->res_handle);
        return MMI_FALSE;
    }

    

    if (0 == handle_p)
    {
        ret = tmp_cb(rst);
        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_LOG, 11, __LINE__, 
                                    ret, rst->address, rst->num, rst->error_cause, 0, 0);
    }
    else
    {
        if (VM_PMNG_OP_OK == vm_pmng_set_ctx(handle_p))
        {
            ret = tmp_cb(rst);
            vm_pmng_reset_ctx();
            MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_LOG, 11, __LINE__, 
                                        ret, rst->address, rst->num, rst->error_cause, 0, 0);
        }
    }
    
    vm_close_and_free_socket(soc_ctx->sock);
    
    MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_E, 11, __LINE__);

    return ret;
}

static VMINT vm_soc_get_host_by_name_int(VMINT handle, 
                                                                                const VMCHAR * host, 
                                                                                VMBYTE * addr, 
                                                                                VMBYTE * addr_len, 
                                                                                VMUINT dtacct_id, 
                                                                                VMINT (*callback)(VMINT handle, vm_soc_dns_result * rst))
{

    vm_sock_context_t* soc_ctx = NULL;
    kal_int8 ret = 0;

    ASSERT(callback);

	//abm hold
    soc_ctx = vm_get_socket_context(handle, 1);
    
    MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_S, 12, __LINE__);
    
    if (NULL == soc_ctx)
    {
        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_E1, 12, __LINE__);
        return VM_E_SOC_ERROR;
    }
    
    ret = soc_gethostbyname(KAL_FALSE, 
                            MOD_MMI, 
                            soc_ctx->sock, 
                            host, 
                            (kal_uint8*)addr, 
                            (kal_uint8*)addr_len, 
                            0, 
                            dtacct_id);
                            
    if (SOC_WOULDBLOCK == ret)
    {
        if (NULL == vm_soc_ctx_cb_push(soc_ctx, (void (*)(void))callback))
        {
            MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_FAILURE, 12, __LINE__, soc_ctx->cb_num);
            return VM_E_SOC_ERROR;
        }
        soc_ctx->socket_state = conn_host_by_name;
        mmi_frm_set_protocol_event_handler(MSG_ID_APP_SOC_GET_HOST_BY_NAME_IND, (PsIntFuncPtr)vm_soc_get_host_by_name_int_cb, MMI_TRUE);
        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_CONNECT_GET_HOST, soc_ctx->sock);
        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_LOG, 12, __LINE__, 
                                    ret, 0, 0, 0, 0, 0);
    }
    MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_E, 12, __LINE__);
    return ret;
}

static VMINT vm_soc_get_host_by_name_int_cb(void* msg)
{
    vm_sock_context_t* soc_ctx = NULL;
    VM_P_HANDLE handle_p = 0;
    app_soc_get_host_by_name_ind_struct * dns_msg = NULL;
    VMINT (*tmp_cb)(VMINT handle, vm_soc_dns_result * rst);
    VMINT ret = 0;
    vm_soc_dns_result result_tmp = {0};

    MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_S, 13, __LINE__);

    if (NULL == msg)
    {
        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_E1, 13, __LINE__);
        return MMI_FALSE;
    }

    dns_msg = (app_soc_get_host_by_name_ind_struct *)msg;
	//abm hold
    soc_ctx = vm_get_socket_context(dns_msg->request_id, 0);
    if (NULL == soc_ctx)
    {
        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_E2, 13, __LINE__);
        return MMI_FALSE;
    }
    
    tmp_cb = (VMINT (*)(VMINT handle, vm_soc_dns_result * rst))vm_soc_ctx_cb_pop(soc_ctx);
    handle_p = vm_res_get_process_handle(VM_RES_TYPE_TCP_HANDLE, 
            soc_ctx->res_handle);
            
    MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_LOG, 13, __LINE__, 
                        dns_msg->request_id, 
                        soc_ctx ? soc_ctx->res_handle : 0, 
                        handle_p, 
                        soc_ctx->cb, 
                        soc_ctx->callback, 
                        dns_msg->result);

    if (tmp_cb && (0 <= handle_p))
    {
        if (!dns_msg->result)
        {
            result_tmp.error_cause = dns_msg->error_cause;

//abm hold
            if (soc_ctx->callback)
                TCP_PMNG_WRAP_CALLBACK(handle_p, 
                    soc_ctx->callback, soc_ctx->res_handle, VM_TCP_EVT_HOST_NOT_FOUND);
            if (VM_PMNG_OP_OK == vm_pmng_set_ctx(handle_p))
            {
//abm hold
                ret = tmp_cb(soc_ctx->res_handle, &result_tmp);
                vm_pmng_reset_ctx();
                MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_LOG, 13, __LINE__, 
                                            ret, result_tmp.address, result_tmp.num, result_tmp.error_cause, 0, 0);
            }
            MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_FAILURE, 13, __LINE__, result_tmp.error_cause);

            return MMI_FALSE;
        }
        else
        {        
            result_tmp.num = (VMINT)dns_msg->num_entry;
            memcpy(result_tmp.address, dns_msg->entry, VM_SOC_DNS_MAX_ADDR*4);

            {
            VMINT i = 0;
            kal_uint8 * p = NULL;
            MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_LOG, 13, __LINE__, 
                result_tmp.num, 0, 0, 0, 0, 0);
            for (i = 0; i < result_tmp.num; i ++)
            {
                p = (kal_uint8*)(result_tmp.address + i);
                MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_LOG, 13, __LINE__, 
                                                        p[0],
                                                        p[1],
                                                        p[2],
                                                        p[3], 0, 0);
            }
            }
            if (VM_PMNG_OP_OK == vm_pmng_set_ctx(handle_p))
            {
//abm hold
                ret = tmp_cb(soc_ctx->res_handle, &result_tmp);
                vm_pmng_reset_ctx();
                MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_LOG, 13, __LINE__, 
                                            ret, result_tmp.address, result_tmp.num, result_tmp.error_cause, 0, 0);
            }
                
            return MMI_FALSE;
        }
    }
    else
    {
        
        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_LOG, 13, __LINE__, 
            dns_msg->request_id, handle_p, soc_ctx->cb, dns_msg->result, 0, 0);
    }
    
    MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_E, 13, __LINE__);

    return ret;
}

static MMI_BOOL vm_get_host_by_name(void* inMsg)
{
    vm_sock_context_t* context_ptr = NULL;
    void (*notify_callback)(VMINT handle, VMINT event) = NULL;
    app_soc_get_host_by_name_ind_struct* dns_ind = (app_soc_get_host_by_name_ind_struct*)inMsg;

    if ((context_ptr = vm_get_socket_context(dns_ind->request_id, 0)) != NULL)
    {
        return MMI_FALSE;
    }

    if (dns_ind && dns_ind->result != FALSE)
    {
        sockaddr_struct addr;

	//abm hold
        VM_P_HANDLE processHandle = vm_res_get_process_handle(
            VM_RES_TYPE_TCP_HANDLE, context_ptr->res_handle);
    
        if(context_ptr->socket_state != conn_host_by_name)
        {
            /* 当前的状态不为get host by name 状态。    */
            MMI_TRACE(MMI_MRE_TRC_WARNING, TRC_MRE_VMSOCK_2034 , 
                dns_ind->request_id, context_ptr->socket_state);
            return MMI_TRUE;
        }

        memset(&addr, 0x00, sizeof(addr));
        memcpy(addr.addr, dns_ind->addr, dns_ind->addr_len);
        addr.addr_len = dns_ind->addr_len;
        addr.port = context_ptr->port;

        switch (soc_connect(context_ptr->sock, &addr))
        {
        case SOC_SUCCESS:
        case SOC_WOULDBLOCK:
                    mmi_frm_set_protocol_event_handler(MSG_ID_APP_SOC_NOTIFY_IND, (PsIntFuncPtr)vm_soc_notify, MMI_TRUE);
            break;
        default:
            notify_callback = context_ptr->callback;    
            if (notify_callback)
            {
                if (processHandle >= 0)
                {
//abm hold
                    TCP_PMNG_WRAP_CALLBACK(processHandle, 
                        notify_callback, context_ptr->res_handle, VM_TCP_EVT_PIPE_BROKEN);
                }
                else
                {
                    MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMSOCK_2068 , processHandle);
                }
            }               
            
            vm_close_and_free_socket(dns_ind->request_id);
            break;
        }

        return MMI_TRUE;
    }
    else                                // dns analyse error.
    {
        if (dns_ind)
        {
            //abm hold
            VM_P_HANDLE processHandle = vm_res_get_process_handle(
                VM_RES_TYPE_TCP_HANDLE, context_ptr->res_handle);
            MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_2081 , dns_ind->request_id);
            
            notify_callback = context_ptr->callback;
            if (notify_callback)
            {
                if (processHandle >= 0)
                {
//abm hold
                    TCP_PMNG_WRAP_CALLBACK(processHandle, 
                        notify_callback, context_ptr->res_handle, 
                        VM_TCP_EVT_HOST_NOT_FOUND);
                }
                else
                {
                    MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMSOCK_2106 , 
                        processHandle);
                }
            }
            
            vm_close_and_free_socket(dns_ind->request_id);

            return MMI_TRUE;
        }
    }

    return MMI_FALSE;
}

static VMINT vm_get_apn_info_internal(vm_apn_info_ext *apn_info, kal_uint32 accid)
{
    MMI_BOOL bret = MMI_FALSE;
    srv_dtcnt_prof_proxy_info_struct proxy_info = {0};

    bret = srv_dtcnt_get_proxy_info(accid, &proxy_info, SRV_DTCNT_ACCOUNT_PRIMARY);
    if (bret)
    {
        
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_APN_DFT_LOG, 
            proxy_info.use_proxy,
            proxy_info.px_addrtype,
            proxy_info.px_service,
            0,
            0,
            0,
            54, __LINE__);
        
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_APN_DFT_LOG, 
            0,
            0,
            0,
            0,
            0,
            proxy_info.acc_id,
            56, __LINE__);
        
        apn_info->apn_info_id = proxy_info.use_proxy;
        apn_info->proxy_port = proxy_info.px_port;
        apn_info->operator_id[0] = '\0';
        apn_info->operator_name[0] = '\0';
        
        strncpy((char *)apn_info->proxy_ip, (const char *)proxy_info.px_addr, 16);
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_2164 , apn_info->proxy_ip);
        
        apn_info->apn_proxy[0] = '\0';
        apn_info->apn_no_proxy[0] = '\0';
        memcpy(apn_info->user_name, proxy_info.px_authid, 16);
        apn_info->user_name[15] = '\0';
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_2170 , apn_info->user_name);
        memcpy(apn_info->pass_word, proxy_info.px_authpw, 16);
        apn_info->pass_word[15] = '\0';
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_2173 , apn_info->pass_word);
        
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_APN_DFT_LOG, 
            proxy_info.px_addr[0], 
            proxy_info.px_addr[1],
            proxy_info.px_addr[2],
            proxy_info.px_addr[3],
            proxy_info.px_port,
            0,
            55, __LINE__);
        
        vm_trace("[APN DFT] proxy_ip[%s]", apn_info->proxy_ip);
        vm_trace("[APN DFT] px_authid[%s]", proxy_info.px_authid);
        vm_trace("[APN DFT] px_authpw[%s]", proxy_info.px_authpw);
        vm_trace("[APN DFT] px_startpage[%s]", proxy_info.px_startpage);
        
    }
    else
    {
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_APN_DFT_E2, 57, __LINE__);
        return -3;
    }
    
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_APN_DFT_E, 58, __LINE__);
    return 0;
}

VMINT vm_get_default_apn_info(vm_apn_info_ext * apn_info)
{
    VMUINT8 app_id = 0;
    kal_uint32 accid = 0;
    MMI_BOOL bret = MMI_FALSE;
    VMINT i = 0, j = 0;
        
    //vm_trace("[default] S");
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_APN_DFT_S, 51, __LINE__);

    if (NULL == apn_info)
    {
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_APN_DFT_E1, 52, __LINE__);
        return -2;
    }

    accid = vm_get_account_id(CBM_DEFAULT_ACCT_ID, 0);
    
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_APN_DFT_LOG, 
        0,
        0,
        0,
        0,
        0,
        accid,
        53, __LINE__);
    
    return vm_get_apn_info_internal(apn_info, accid);
}

VMINT vm_get_apn_info(vm_apn_info_ext *current_apn_info)
{
    MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMSOCK_2125 , g_mre_account_id);
    return vm_get_apn_info_internal(current_apn_info, g_mre_account_id);
}


typedef struct
{
    VMUINT jid;
    VMINT res_id;
    void (*cb)(vm_wlan_loc_data_t * data, void * user_data);
}vm_wlan_loc_context_t;

static void vm_wlan_loc_free_ctx(VMINT jid);
static vm_wlan_loc_context_t * vm_wlan_loc_malloc_ctx(void);
static vm_wlan_loc_context_t * vm_wlan_loc_get_ctx(VMUINT jid);


static void vm_wlan_free_resource(VM_P_HANDLE process_handle)
{
    VMINT resHandle = 0, bufSize = 0;
    vm_wlan_loc_context_t * ctx_p = NULL;

    while ((resHandle = vm_res_findfirst(process_handle, VM_RES_TYPE_WLAN_LOC)) 
        != VM_RES_NOT_FIND)
    {
        if (vm_res_get_data(VM_RES_TYPE_WLAN_LOC, 
            resHandle, (void**)&ctx_p, &bufSize) == 0 && ctx_p != NULL)
        {
            if (ctx_p)
                vm_wlan_loc_free_ctx(ctx_p->jid);
            MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_2211 );
        }
        else
        {
            MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_2215 );
        }
        vm_res_release_data(VM_RES_TYPE_WLAN_LOC, resHandle);
        vm_res_findclose(VM_RES_TYPE_WLAN_LOC); 
    }
}

static void vm_wlan_loc_notify_process_status(VM_P_HANDLE process_handle, 
    VMINT sys_state)
{
    switch (sys_state)
    {
    case VM_PMNG_UNLOAD:
        vm_wlan_free_resource(process_handle);
        break;
    }
}


static VMINT vm_wlan_loc_initialize_resource(void)
{
    if (vm_res_type_set_notify_callback(VM_RES_TYPE_WLAN_LOC, 
        vm_wlan_loc_notify_process_status) != 0)
    {
        return -1;
    }

    ///TODO: other init.
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_2234 );


    return 0;
}

static VMINT vm_wlan_loc_finialize_resource(void)
{
    vm_wlan_free_resource(-1);
    
    vm_res_type_set_notify_callback(VM_RES_TYPE_WLAN_LOC, NULL);

    ///TODO: Deregister WPS relate functions

    return 0;
}

static VMINT vm_wifi_loc_mod_evt_proc(MRE_MOD_LIFECIRCLE_EVT event)
{
    switch(event)
    {
    case EVT_MOD_INIT:
        if (vm_wlan_loc_initialize_resource() != 0)
            return -1;
        break;
    case EVT_MOD_RELEASE:
        vm_wlan_loc_finialize_resource();
        break;
    case EVT_MOD_ACTIVE:
        break;
    case EVT_MOD_INACTIVE:
        break;
    default:
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_2287 , event);
        return -2;
    }

    return 0;
}

VMINT _vm_reg_wifi_loc_module(void)
{
    int res_code = REG_MRE_MODULE_SUCCESS;
    
    if ((res_code = _vm_reg_module("WIF", (MOD_EVT_PROCESS)vm_wifi_loc_mod_evt_proc)) != REG_MRE_MODULE_SUCCESS)
    {
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_2300 , res_code);
    }

    return res_code;
}

static vm_wlan_loc_context_t * vm_wlan_loc_get_ctx(VMUINT jid)
{
    VMINT resHandle = 0, bufSize = 0;
    vm_wlan_loc_context_t * ctx_p = NULL;

    if ((resHandle = vm_res_findfirst(-1, VM_RES_TYPE_WLAN_LOC)) != VM_RES_NOT_FIND)
    {
        if (vm_res_get_data(VM_RES_TYPE_WLAN_LOC, 
            resHandle, (void**)&ctx_p, &bufSize) == 0 && ctx_p != NULL)
        {
            if (ctx_p->jid == jid)
            {
                vm_res_findclose(VM_RES_TYPE_WLAN_LOC);
                return ctx_p;
            }
        }

        while ((resHandle = vm_res_findnext(-1, VM_RES_TYPE_WLAN_LOC)) != VM_RES_NOT_FIND)
        {
            if (vm_res_get_data(VM_RES_TYPE_WLAN_LOC, 
            resHandle, (void**)&ctx_p, &bufSize) == 0 && ctx_p != NULL)
            {
                if (ctx_p->jid == jid)
                {
                    vm_res_findclose(VM_RES_TYPE_WLAN_LOC);
                    return ctx_p;
                }
            }
        }
        vm_res_findclose(VM_RES_TYPE_WLAN_LOC);
    }	
    return NULL;
}


static vm_wlan_loc_context_t * vm_wlan_loc_malloc_ctx(void)
{
    vm_wlan_loc_context_t * ctx_p = NULL;

    if ((ctx_p = _vm_kernel_calloc(sizeof(vm_wlan_loc_context_t))) != NULL)
    {
        if ((ctx_p->res_id = vm_res_save_data(VM_RES_TYPE_WLAN_LOC, 
            (void*)ctx_p, sizeof(ctx_p), NULL, vm_pmng_get_current_handle())) >= 0)
        {
            return ctx_p;
        }
        else
        {
            _vm_kernel_free(ctx_p);
        }
    }

    return NULL;
}

static void vm_wlan_loc_free_ctx(VMINT jid)
{
    vm_wlan_loc_context_t * ctx_p = NULL;
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_2792 );
    ctx_p = vm_wlan_loc_get_ctx(jid);
    if (ctx_p)
    {
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_2796 );
        if (VM_RES_OK == vm_res_release_data(VM_RES_TYPE_WLAN_LOC, ctx_p->res_id))
        {
            _vm_kernel_free(ctx_p);
            MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_2700 );
        }
    }
    
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_2704 );
}



static void vm_srv_dtcnt_wlan_scan_res_cb(U32 job_id,
                                                                                        void *user_data,
                                                                                        srv_dtcnt_wlan_scan_result_struct *scan_res)
{
    VM_P_HANDLE p_handle = 0;
    vm_wlan_loc_context_t * ctx_p = NULL;
    vm_wlan_loc_data_t data = {0};
    vm_wlan_loc_supc_abm_bss_info_struct * info = NULL;
    VMINT i = 0;
    VMINT jid = -1;

    ctx_p = vm_wlan_loc_get_ctx((VMUINT)(job_id));
    if (NULL == ctx_p)
    {
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_2385 );
        return;
    }
    
    p_handle = vm_res_get_process_handle(VM_RES_TYPE_WLAN_LOC, ctx_p->res_id);
    if (0 > p_handle)
    {
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_2392 );
        return;
    }

    if (NULL == scan_res)
    {
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_2398 );
        return;
    }

    jid = ctx_p->jid;
    
    data.ap_list_num = scan_res->ap_list_num;

    if (data.ap_list_num > 0)
    {
        info = _vm_kernel_malloc(data.ap_list_num * sizeof(vm_wlan_loc_supc_abm_bss_info_struct));
        for (i = 0; i < data.ap_list_num; i++)
        {
            data.ap_list[i] = (const vm_wlan_loc_supc_abm_bss_info_struct *)&info[i];
            memcpy(((vm_wlan_loc_supc_abm_bss_info_struct*)(data.ap_list[i]))->bssid, 
                scan_res->ap_list[i]->bssid, 
                VM_WLAN_LOC_MAC_ADDR_LEN > WNDRV_MAC_ADDRESS_LEN ? WNDRV_MAC_ADDRESS_LEN : VM_WLAN_LOC_MAC_ADDR_LEN);
            ((vm_wlan_loc_supc_abm_bss_info_struct*)(data.ap_list[i]))->rssi = scan_res->ap_list[i]->rssi;
            MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_2414 , 
                data.ap_list[i]->bssid[0],
                data.ap_list[i]->bssid[1],
                data.ap_list[i]->bssid[2],
                data.ap_list[i]->bssid[3],
                data.ap_list[i]->bssid[4],
                data.ap_list[i]->bssid[5],
                data.ap_list[i]->rssi);
        } 
        
    }
    data.handle = ctx_p->res_id;
    data.result = (vm_wlan_loc_scan_result_enum)scan_res->result;

    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_2428 , data.ap_list_num, data.handle, data.result);

    PMNG_WRAP_CALLBACK(p_handle, ctx_p->cb(&data, user_data));

    if (info)
    {
        _vm_kernel_free(info);
    }

    vm_wlan_loc_free_ctx(jid);

}


VMINT vm_wlan_loc_search(void (*callback)(vm_wlan_loc_data_t * data, void * user_data), void * user_data)
{
    U32 jid = 0;
    vm_wlan_loc_context_t * ctx_p = NULL;
    
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_2447 );
    
#if defined (__MMI_WLAN_FEATURES__) && defined(__MTK_TARGET__) && defined(__TCPIP__)

    
    if (SRV_DTCNT_WLAN_STATUS_INACTIVE == srv_dtcnt_wlan_status())
    {
        return VM_WLAN_LOC_ERR_LOGICAL;
    }
    
    ctx_p = vm_wlan_loc_malloc_ctx();
    if (NULL == ctx_p)
    {
        return VM_WLAN_LOC_ERR_NO_RESOURCE;
    }
    
    jid = srv_dtcnt_wlan_scan(vm_srv_dtcnt_wlan_scan_res_cb, user_data);
    if (0 >= jid)
    {
        vm_wlan_loc_free_ctx(jid);
        return VM_WLAN_LOC_ERR_BUSY;
    }

    ctx_p->jid = jid;
    ctx_p->cb = callback;
    
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_2468 , ctx_p->jid, ctx_p->cb);

    
    return ctx_p->res_id;

#else

    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_2475 );
    return VM_WLAN_LOC_ERR_NOT_SUPPORT;

#endif
}

VMINT vm_wlan_loc_search_abort(VMINT handle)
{

    vm_wlan_loc_context_t * ctx_p = NULL;
    VMINT size = 0;
    VMINT jid = 0;

MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_2487 );
#if defined (__MMI_WLAN_FEATURES__) && defined(__MTK_TARGET__) && defined(__TCPIP__)

    if (VM_RES_OK != vm_res_get_data(VM_RES_TYPE_WLAN_LOC, handle, (void**)&ctx_p, &size))
    {
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_2733 );
        return VM_WLAN_LOC_ERR_BAD_PARAM;
    }
    else
    {
        if (NULL == ctx_p)
        {
            MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_2740 );
            return VM_WLAN_LOC_ERR_INTERNAL;
        }
    }

    if (0 >= ctx_p->jid)
    {
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_2747 );
        return VM_WLAN_LOC_ERR_INTERNAL;
    }

    jid = ctx_p->jid;
    srv_dtcnt_wlan_scan_abort((U32)jid);
    vm_wlan_loc_free_ctx(jid);
    
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_2510 , ctx_p->jid);
    return 0;

#else
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_2514 );
    return VM_WLAN_LOC_ERR_NOT_SUPPORT;
#endif

}

VMINT vm_wlan_loc_get_connected_info(vm_wlan_loc_supc_abm_bss_info_struct * info)
{
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_2522 );
    
#if defined (__MMI_WLAN_FEATURES__) && defined(__MTK_TARGET__) && defined(__TCPIP__)
    if (NULL == info)
    {
        return VM_WLAN_LOC_ERR_BAD_PARAM;
    }
    
    if (MMI_FALSE == srv_dtcnt_wlan_get_connected_ap_rssi((S32*)&(info->rssi)))
    {
        return VM_WLAN_LOC_ERR_LOGICAL;
    }


    if (MMI_FALSE == srv_dtcnt_wlan_get_connected_ap_bssid(info->bssid))
    {
        return VM_WLAN_LOC_ERR_LOGICAL;
    }


    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_2542 , 
        info->bssid[0],
        info->bssid[1],
        info->bssid[2],
        info->bssid[3],
        info->bssid[4],
        info->bssid[5],
        info->rssi);
    
    return 0;
#else

    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_2554 );
    return VM_WLAN_LOC_ERR_NOT_SUPPORT;

#endif

}

//#define _MRE_UDP_DEBUG_
typedef struct _vm_udp_ctx_t
{
    VM_P_HANDLE p_hdl;
    void (*cb)(VMINT hdl, VMINT event);
    VMINT soc_id;
    VMINT res_id;
    VMINT apn;
	//abm hold
    kal_uint32 account_id;
}vm_udp_ctx_t;

static void _vm_udp_free_ctx(vm_udp_ctx_t * ctx_p);
static vm_udp_ctx_t * _vm_udp_malloc_ctx(void);
static vm_udp_ctx_t* _vm_udp_get_ctx_by_socid(VMINT sock_id);

static MMI_BOOL _vm_udp_cb(void * data);

static void vm_udp_free_resource(VM_P_HANDLE process_handle)
{
    VMINT resHandle = 0, bufSize = 0;
    vm_udp_ctx_t * ctx_p = NULL;
    
    while ((resHandle = vm_res_findfirst(process_handle, VM_RES_TYPE_UDP_HANDLE)) 
        != VM_RES_NOT_FIND)
    {
        if (vm_res_get_data(VM_RES_TYPE_UDP_HANDLE, 
            resHandle, (void**)&ctx_p, &bufSize) == 0 && ctx_p != NULL)
        {
            _vm_udp_free_ctx(ctx_p);
        }
        else
        {
        }
        vm_res_release_data(VM_RES_TYPE_UDP_HANDLE, resHandle);
        vm_res_findclose(VM_RES_TYPE_UDP_HANDLE); 
    }
}

static void vm_udp_notify_process_status(VM_P_HANDLE process_handle, 
    VMINT sys_state)
{
    switch (sys_state)
    {
    case VM_PMNG_UNLOAD:
        break;
    }
}

static VMINT vm_udp_initialize_resource(void)
{
    if (vm_res_type_set_notify_callback(VM_RES_TYPE_UDP_HANDLE, 
        vm_udp_notify_process_status) != 0)
    {
        return -1;
    }

    ///TODO: other init.


    return 0;
}

static VMINT vm_udp_finialize_resource(void)
{
    vm_udp_free_resource(-1);
    
    vm_res_type_set_notify_callback(VM_RES_TYPE_UDP_HANDLE, NULL);
    
    mmi_frm_clear_protocol_event_handler(MSG_ID_APP_SOC_NOTIFY_IND, 
        (PsIntFuncPtr)_vm_udp_cb);

    return 0;
}

static VMINT vm_udp_mod_evt_proc(MRE_MOD_LIFECIRCLE_EVT event)
{
    switch(event)
    {
    case EVT_MOD_INIT:
        if (vm_udp_initialize_resource() != 0)
            return -1;
        break;
    case EVT_MOD_RELEASE:
        vm_udp_finialize_resource();
        break;
    case EVT_MOD_ACTIVE:
        break;
    case EVT_MOD_INACTIVE:
        break;
    default:
        return -2;
    }

    return 0;
}

VMINT _vm_reg_udp_module(void)
{
    int res_code = REG_MRE_MODULE_SUCCESS;
    
    if ((res_code = _vm_reg_module("UDP", (MOD_EVT_PROCESS)vm_udp_mod_evt_proc)) != REG_MRE_MODULE_SUCCESS)
    {
        
    }

    return res_code;
}

static void _vm_udp_free_ctx(vm_udp_ctx_t * ctx_p)
{    
    if (NULL == ctx_p)
    {
        return;
    }

    if (ctx_p->soc_id >= 0)
    {
        soc_close(ctx_p->soc_id);
        ctx_p->soc_id = -1;
    }

	//abm hold
    ctx_p->account_id = 0;
    
    vm_res_release_data(VM_RES_TYPE_UDP_HANDLE, ctx_p->res_id);
    _vm_kernel_free(ctx_p);
    return;
}

static vm_udp_ctx_t * _vm_udp_malloc_ctx(void)
{
    vm_udp_ctx_t * ctx_p = NULL;

    if ((ctx_p = _vm_kernel_calloc(sizeof(vm_udp_ctx_t))) != NULL)
    {
        if ((ctx_p->res_id = vm_res_save_data(VM_RES_TYPE_UDP_HANDLE, 
            (void*)ctx_p, sizeof(ctx_p), NULL, vm_pmng_get_current_handle())) >= 0)
        {
            ctx_p->p_hdl = vm_pmng_get_current_handle();
            return ctx_p;
        }
        else
        {
            _vm_kernel_free(ctx_p);
        }
    }

    return NULL;
}

static vm_udp_ctx_t* _vm_udp_get_ctx_by_socid(VMINT soc_id)
{
    VMINT resHandle = 0, bufSize = 0;
    vm_udp_ctx_t* ctx_p = NULL;
    
    if ((resHandle = vm_res_findfirst(-1, VM_RES_TYPE_UDP_HANDLE)) != VM_RES_NOT_FIND)
    {
        if (vm_res_get_data(VM_RES_TYPE_UDP_HANDLE, 
            resHandle, (void**)&ctx_p, &bufSize) == 0 && ctx_p != NULL)
        {
            if (ctx_p->soc_id == soc_id)
            {
                vm_res_findclose(VM_RES_TYPE_UDP_HANDLE);
                return ctx_p;
            }
        }

        while ((resHandle = vm_res_findnext(-1, VM_RES_TYPE_UDP_HANDLE)) != VM_RES_NOT_FIND)
        {
            if (vm_res_get_data(VM_RES_TYPE_UDP_HANDLE, 
                resHandle, (void**)&ctx_p, &bufSize) == 0 && ctx_p != NULL)
            {
                if (ctx_p->soc_id == soc_id)
                {
                    vm_res_findclose(VM_RES_TYPE_UDP_HANDLE);
                    return ctx_p;
                }
            }
        }
        vm_res_findclose(VM_RES_TYPE_UDP_HANDLE);
    }	
    return NULL;
}



VMINT vm_udp_create(VMINT port, VMINT apn, void (*callback)(VMINT hdl, VMINT event), VMINT loopback)
{
    VMUINT acct_id = 0;
    vm_udp_ctx_t * ctx_p = NULL;
    VMUINT8 option = 0;
    VMINT8 ret = 0;
    sockaddr_struct addr;
    VMUINT8 app_id = 0;
    
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_S, 1, __LINE__);
    if (0 >= port || NULL == callback)
    {
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_E1, 1, __LINE__);
        return -2;
    }

    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_LOG,
        apn,
        app_id, 
        acct_id, 
        0, 
        0,
        0,
        1, __LINE__);
    if (loopback)
    {
        vm_get_app_id(apn, &app_id);
        acct_id = vm_get_account_id(CBM_LOOPBACK_ACCT_ID, app_id);
        #if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
        #endif
    }
    else
    {
        if (VM_E_SOC_SUCCESS != vm_get_encoded_dtacct_id(apn, &acct_id))
        {
            MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_E2, 1, __LINE__);
            return -2;
        }
    }

    ctx_p = _vm_udp_malloc_ctx();
    if (NULL == ctx_p)
    {
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_E3, 1, __LINE__);
        return -3;
    }

    ctx_p->apn = apn;
    ctx_p->cb = callback;

    ctx_p->soc_id = soc_create(SOC_PF_INET, SOC_SOCK_DGRAM, 0, MOD_MMI, acct_id);
    if (0 > ctx_p->soc_id)
    {
        _vm_udp_free_ctx(ctx_p);
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_E4, 1, __LINE__);
        return -4;
    }

    
    option = KAL_TRUE;
    ret = soc_setsockopt(ctx_p->soc_id, SOC_NBIO, &option, sizeof(option));
    if (SOC_SUCCESS != ret)
    {
        _vm_udp_free_ctx(ctx_p);
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_E5, 1, __LINE__);
        return -5;
    }
    
    option = SOC_READ | SOC_WRITE | SOC_CLOSE;
    ret = soc_setsockopt(ctx_p->soc_id, SOC_ASYNC, &option, sizeof(option));
    if (SOC_SUCCESS != ret)
    {
        _vm_udp_free_ctx(ctx_p);
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_E6, 1, __LINE__);
        return -6;
    }

    addr.sock_type = SOC_SOCK_DGRAM;
    addr.addr_len = 0x04;
    addr.port = port;
#ifdef _MRE_UDP_DEBUG_
    addr.addr[0] = 0;
    addr.addr[1] = 0;
    addr.addr[2] = 0;
    addr.addr[3] = 0;
#else
    //addr.addr[0] = 0;
    //addr.addr[1] = 0;
    //addr.addr[2] = 0;
    //addr.addr[3] = 0;
    memset(addr.addr, 0, sizeof(addr.addr));
#endif
    ret = soc_bind(ctx_p->soc_id, &addr);
    if (SOC_SUCCESS != ret)
    {
        _vm_udp_free_ctx(ctx_p);
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_E7, 1, __LINE__);
        return -7;
    }


    mmi_frm_set_protocol_event_handler(MSG_ID_APP_SOC_NOTIFY_IND, (PsIntFuncPtr)_vm_udp_cb, MMI_TRUE);

    
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_LOG,
        addr.addr[0], 
        addr.addr[1], 
        addr.addr[2], 
        addr.addr[3],
        addr.port,
        ctx_p->res_id,
        1, __LINE__);

	//abm hold
    ctx_p->account_id = acct_id;
    
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_E, 1, __LINE__);
    
    return ctx_p->res_id;
}

VMINT vm_udp_sendto(VMINT hdl, const void * buf, VMINT32 len, const vm_sockaddr_struct * addr)
{
    VMINT32 ret = 0;
    vm_udp_ctx_t * ctx_p = NULL;
    VMINT size = 0;
    //srv_dtcnt_sim_type_enum sim_type;
    sockaddr_struct toaddr;

    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_S, 2, __LINE__);
    if (NULL == buf ||
        0 == len ||
        NULL == addr)
    {
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_E1, 2, __LINE__);
        return -2;
    }
    
    if (vm_res_get_data(VM_RES_TYPE_UDP_HANDLE, 
        hdl, (void**)&ctx_p, &size) < 0 || NULL != ctx_p)
    {
        if (NULL == ctx_p)
        {
            MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_E2, 2, __LINE__);
            return -3;
        }
    }

    memcpy(toaddr.addr, addr->addr, addr->addr_len);
    toaddr.addr_len = addr->addr_len;
    toaddr.port = addr->port;
    toaddr.sock_type = SOC_SOCK_DGRAM;
    
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_LOG,
        ctx_p->soc_id, 
        buf, 
        len, 
        hdl,
        0,
        0,
        2, __LINE__);
        
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_LOG,
        toaddr.addr[0], 
        toaddr.addr[1], 
        toaddr.addr[2], 
        toaddr.addr[3],
        toaddr.port,
        0,
        2, __LINE__);
        
    //srv_dtcnt_get_sim_preference(&sim_type);
    if ((stub_tcp_is_support_wifi() && VM_TCP_APN_WIFI == ctx_p->apn)
#ifdef __COSMOS_MMI_PACKAGE__      
      //  || (srv_mre_da_get_account_id(SRV_MRE_DA_WIFI_ONLY) == 1)
      //  || (sim_type == SRV_DTCNT_SIM_TYPE_NONE)
#endif
        )
    {
        if (SRV_DTCNT_WLAN_STATUS_INACTIVE == srv_dtcnt_wlan_status())
        {
            MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_E3, 2, __LINE__);
            return -4;
        }
    }
    ret = soc_sendto(ctx_p->soc_id, (kal_uint8*)buf, (kal_int32)len, 0, &toaddr);
    if (0 > ret)
    {
        //_vm_udp_free_ctx(ctx_p);
        if (SOC_WOULDBLOCK == ret)
        {
            MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_E3, 2, __LINE__);
            return 0;
        }
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_E4, 2, __LINE__);
        //return -4;
    }

    
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_LOG,
        ret, 
        0, 
        0, 
        0,
        0,
        0,
        2, __LINE__);
        
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_E, 2, __LINE__);
    return ret;
}

VMINT vm_udp_recvfrom(VMINT hdl, void * buf, VMINT32 len, vm_sockaddr_struct * addr)
{
    VMINT32 ret = 0;
    vm_udp_ctx_t * ctx_p = NULL;
    VMINT size = 0;
    sockaddr_struct fromaddr;

    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_S, 3, __LINE__);
    if (NULL == buf ||
        0 == len ||
        NULL == addr)
    {
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_E1, 3, __LINE__);
        return -2;
    }   

    if (vm_res_get_data(VM_RES_TYPE_UDP_HANDLE, 
        hdl, (void**)&ctx_p, &size) < 0 || NULL != ctx_p)
    {
        if (NULL == ctx_p)
        {
            MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_E2, 3, __LINE__);
            return -3;
        }
    }
/*
    strncpy(fromaddr.addr, addr->addr, addr->addr_len);
    fromaddr.addr_len = addr->addr_len;
    fromaddr.port = addr->port;
    fromaddr.sock_type = SOC_SOCK_DGRAM;
*/

    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_LOG,
        ctx_p->soc_id, 
        buf, 
        len, 
        hdl,
        0,
        0,
        3, __LINE__);



    ret = soc_recvfrom(ctx_p->soc_id, (kal_uint8*)buf, (kal_int32)len, 0, &fromaddr);
    if (0 > ret)
    {
        //_vm_udp_free_ctx(ctx_p);
        if (SOC_WOULDBLOCK == ret)
        {
            MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_E3, 3, __LINE__);
            return 0;
        }
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_E4, 3, __LINE__);
        //return -4;
    }

    memcpy(addr->addr, fromaddr.addr, fromaddr.addr_len);
    addr->addr_len = fromaddr.addr_len;
    addr->port = fromaddr.port;
    
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_LOG,
        addr->addr[0], 
        addr->addr[1], 
        addr->addr[2], 
        addr->addr[3],
        addr->port,
        ret,
        3, __LINE__);

    

    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_E, 3, __LINE__);
    return ret;
}

VMINT vm_udp_close(VMINT hdl)
{
    vm_udp_ctx_t * ctx_p = NULL;   
    VMINT size = 0;
    
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_S, 4, __LINE__);
    if (vm_res_get_data(VM_RES_TYPE_UDP_HANDLE, 
        hdl, (void**)&ctx_p, &size) < 0 || NULL != ctx_p)
    {
        if (NULL == ctx_p)
        {
            MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_E1, 4, __LINE__);
            return -2;
        }
    }

    _vm_udp_free_ctx(ctx_p);
    
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_E, 4, __LINE__);
    return 0;
}

static MMI_BOOL _vm_udp_cb(void * data)
{
    app_soc_notify_ind_struct * ind = (app_soc_notify_ind_struct *)data;
    vm_udp_ctx_t * ctx_p = NULL;
    VMINT state = 0, event;
    
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_S, 5, __LINE__);
    if (NULL == ind)
    {
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_E1, 5, __LINE__);
        return MMI_FALSE;
    }
    
    ctx_p = _vm_udp_get_ctx_by_socid(ind->socket_id);
    if (NULL == ctx_p)
    {
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_E2, 5, __LINE__);
        return MMI_FALSE;
    }

    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_LOG,
        ctx_p->p_hdl, 
        ctx_p->res_id, 
        ind->event_type, 
        0,
        0,
        0,
        5, __LINE__);
        
    switch (ind->event_type)
    {
    case SOC_WRITE:
        {
            event = VM_UDP_EVT_WRITE;
            MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_E3, 5, __LINE__);
        }break;
    case SOC_READ:
        {
            event = VM_UDP_EVT_READ;
            MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_E4, 5, __LINE__);
        }break;
    case SOC_CLOSE:
        {
            event = VM_UDP_EVT_PIPE_CLOSED;
            MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_E5, 5, __LINE__);
            
        }break;
    default:
        {
            event = ind->event_type;
            MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_E3, 6, __LINE__);
        }break;
    }
    PMNG_WRAP_CALLBACK(ctx_p->p_hdl, 
        ctx_p->cb(ctx_p->res_id, event));
    
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_E, 5, __LINE__);
    return MMI_TRUE;
}

	//abm hold
kal_uint32 vm_get_udp_acctid_by_resid(VMINT res_id)
{
    VMINT resHandle = 0, bufSize = 0;
    vm_udp_ctx_t* ctx_p = NULL;
    
    if ((resHandle = vm_res_findfirst(-1, VM_RES_TYPE_UDP_HANDLE)) != VM_RES_NOT_FIND)
    {
        if (vm_res_get_data(VM_RES_TYPE_UDP_HANDLE, 
            resHandle, (void**)&ctx_p, &bufSize) == 0 && ctx_p != NULL)
        {
            if (ctx_p->res_id == res_id)
            {
                vm_res_findclose(VM_RES_TYPE_UDP_HANDLE);
                return ctx_p->account_id;
            }
        }

        while ((resHandle = vm_res_findnext(-1, VM_RES_TYPE_UDP_HANDLE)) != VM_RES_NOT_FIND)
        {
            if (vm_res_get_data(VM_RES_TYPE_UDP_HANDLE, 
                resHandle, (void**)&ctx_p, &bufSize) == 0 && ctx_p != NULL)
            {
                if (ctx_p->res_id == res_id)
                {
                    vm_res_findclose(VM_RES_TYPE_UDP_HANDLE);
                    return ctx_p->account_id;
                }
            }
        }
        vm_res_findclose(VM_RES_TYPE_UDP_HANDLE);
    }   
    return 0;
}

#include "NwInfoSrvGprot.h"
VMINT vm_srv_nw_info_get_protocol(VMINT sim_card)
{
    if (sim_card != MMI_SIM1 &&
        sim_card != MMI_SIM2 &&
        sim_card != MMI_SIM3 &&
        sim_card != MMI_SIM4)
    {
        return -2;
    }
    
    return (VMINT)srv_nw_info_get_protocol((mmi_sim_enum)sim_card);
}



VMINT vm_srv_nw_info_channel_supports(VMINT sim_card, vm_network_capability_enum type)
{
    if (sim_card != MMI_SIM1 &&
    sim_card != MMI_SIM2 &&
    sim_card != MMI_SIM3 &&
    sim_card != MMI_SIM4)
    {
        return -2;
    }

    return srv_nw_info_channel_supports((mmi_sim_enum)sim_card, (mmi_network_capability_enum)type);

}



#include "GlobalResDef.h"
#include "DataAccountCuiGprot.h"
#include "vmsock.h"
#include "DataAccountGprot.h"
#include "cbm_api.h"


//#define DTCNT_DEBUG


#ifdef DTCNT_DEBUG
#include "WAPProfResDef.h"
#endif

static mmi_ret vm_dtacct_select_gproc(mmi_event_struct* evt);
extern VMINT vm_get_app_id(VMINT apn, VMUINT8 *app_id);
extern _vm_pcb_t* vm_sh_pcb_in_pt(VMINT search_type, VMINT value, VM_PROCESS_STATUS* status);
typedef struct
{
    mmi_id dtcnt_cid;
    mmi_id parent_gid;
    VM_P_HANDLE p_hdl;
    VMINT (*cb)(VMUINT32 dtacct);
    VMINT sim_id;
}vm_dtacct_selection_ctx_t;

static vm_dtacct_selection_ctx_t dtacct_ctx;

VMINT vm_dtacct_set(VMINT sim_id, VMUINT32 dtacct)
{
    _vm_pcb_t * pcb = NULL;
    VM_PROCESS_STATUS status = VM_PMNG_UNLOAD;
    VMINT i = 0;

    
    MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_VMIO_DTCNT_SEL_S, 1, __LINE__);

    if (MMI_SIM_TOTAL <= sim_id || 0 > sim_id || 0 == dtacct)
    {
        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_VMIO_DTCNT_SEL_E1, 1, __LINE__);
        return -2;
    }
    
    //dtacct_ctx.cb = callback;
    dtacct_ctx.dtcnt_cid = GRP_ID_INVALID;    
    dtacct_ctx.p_hdl = vm_pmng_get_current_handle();
    
    if (0 == dtacct_ctx.p_hdl)
    {
        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_VMIO_DTCNT_SEL_E2, 1, __LINE__);
        return -3;
    }

    pcb = vm_sh_pcb_in_pt(SH_TYPE_PROCESS_HANDLE, dtacct_ctx.p_hdl, &status);
    if (NULL == pcb)
    {
        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_VMIO_DTCNT_SEL_E3, 1, __LINE__);
        return -4;
    }

    pcb->accountId = dtacct;
    pcb->sim_id = sim_id;
    MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_VMIO_DTCNT_SEL_LOG, 
                    pcb->sim_id,
                    0,
                    0,
                    0,
                    0,
                    pcb->accountId,
                    1, __LINE__);

    
    MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_VMIO_DTCNT_SEL_E, 1, __LINE__);

    return 0;
}

VMINT vm_dtacct_select(VMINT sim_id, VMINT (*callback)(VMUINT32 dtacct))
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#ifdef __PLUTO_MMI_PACKAGE__
    cui_dtcnt_select_run_struct select_run_info;
#endif
    VMINT i = 0;
    //kal_uint32 acct_id;
    U32 sim_account_id[MMI_SIM_TOTAL] = {0};
    VMUINT8 cbm_app_id = 0;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    dtacct_ctx.dtcnt_cid = GRP_ID_INVALID;    
    dtacct_ctx.p_hdl = vm_pmng_get_current_handle();
    dtacct_ctx.cb = callback;
    dtacct_ctx.sim_id = sim_id;

    MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_VMIO_DTCNT_SEL_S, 2, __LINE__);
    if (0 == dtacct_ctx.p_hdl)
    {
        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_VMIO_DTCNT_SEL_E1, 2, __LINE__);
        return -2;
    }
    
#ifdef __PLUTO_MMI_PACKAGE__
    //dtacct_ctx.parent_gid = mmi_frm_group_create(GRP_ID_ROOT, GRP_ID_AUTO_GEN, vm_dtacct_select_gproc, (void*)NULL);
    //mmi_frm_group_enter(dtacct_ctx.parent_gid, MMI_FRM_NODE_SMART_CLOSE_FLAG);
    //dtacct_ctx.parent_gid = mmi_frm_group_create_ex(GRP_ID_ROOT, (MMI_ID)GRP_ID_AUTO_GEN, vm_dtacct_select_gproc, NULL, MMI_FRM_NODE_SMART_CLOSE_FLAG);
    //dtacct_ctx.dtcnt_cid = cui_dtcnt_select_create((MMI_ID)dtacct_ctx.parent_gid);
    //#ifdef DTCNT_DEBUG
    dtacct_ctx.parent_gid = mmi_frm_group_create_ex(GRP_ID_ROOT, 
                                    (MMI_ID)GRP_ID_AUTO_GEN, 
                                    vm_dtacct_select_gproc, 
                                    NULL, 
                                    MMI_FRM_NODE_SMART_CLOSE_FLAG);
    dtacct_ctx.dtcnt_cid = cui_dtcnt_select_create((MMI_ID)dtacct_ctx.parent_gid);
    //#endif
    
    MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_VMIO_DTCNT_SEL_LOG, 
                    dtacct_ctx.parent_gid,
                    dtacct_ctx.dtcnt_cid,
                    MMI_SIM_TOTAL,
                    0,
                    0,
                    0,
                    21, __LINE__);
                    

    memset(&select_run_info, 0, sizeof(cui_dtcnt_select_run_struct));
    
#ifdef __PLUTO_MMI_PACKAGE__
    select_run_info.AppMenuID = 0;
#endif

    vm_get_app_id(VM_TCP_APN_CMNET, &cbm_app_id);
    select_run_info.app_id = cbm_app_id;
    select_run_info.bearers = DATA_ACCOUNT_BEARER_GPRS;
    select_run_info.option = CUI_DTCNT_SELECT_NOT_SUBSCRIBE_ACCOUNT;
    select_run_info.type = CUI_DTCNT_SELECT_TYPE_NORMAL;
    select_run_info.sim_selection = (cui_dtcnt_select_sim_enum)sim_id;//CUI_DTCNT_SELECT_SIM_ALL;
    select_run_info.icon_id = IMAGE_MRE_ICON;
    for (i = 0; i < MMI_SIM_TOTAL; i++)
    {
        select_run_info.sim_account_id[i] = CBM_DEFAULT_ACCT_ID;
    }
    
    cui_dtcnt_select_set_param(dtacct_ctx.dtcnt_cid, &select_run_info);
    cui_dtcnt_select_run(dtacct_ctx.dtcnt_cid);
    
    MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_VMIO_DTCNT_SEL_LOG, 
                    dtacct_ctx.dtcnt_cid,
                    cbm_app_id,
                    0,
                    0,
                    0,
                    0, 
                    22, __LINE__);



#else
    {
        extern MMI_ID vm_vapp_dtcnt_select_run(VM_P_HANDLE p_hdl, VMINT (*cb)(VMUINT32 dtacct), VMINT sim_id);
        vm_vapp_dtcnt_select_run(dtacct_ctx.p_hdl, dtacct_ctx.cb, dtacct_ctx.sim_id);
    }
    
#endif

    MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_VMIO_DTCNT_SEL_E, 2, __LINE__);
    return 0;
}

static mmi_ret vm_dtacct_select_gproc(mmi_event_struct* evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
//    cbm_account_info_struct data_account_info;
    U32 get_account_id = 0;
    U8 primary_dtcnt_id = (U8) -1;
    U8 secondary_dtcnt_id = (U8) -1;
    //cui_dtcnt_sim_enum sim;
    _vm_pcb_t* pcb = NULL;
    VM_PROCESS_STATUS status = VM_PMNG_UNLOAD;
    cui_dtcnt_select_event_any_sim_selected_struct *event =  (cui_dtcnt_select_event_any_sim_selected_struct *)evt;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_VMIO_DTCNT_SEL_S, 3, __LINE__);
    pcb = vm_sh_pcb_in_pt(SH_TYPE_PROCESS_HANDLE, dtacct_ctx.p_hdl, &status);
        
    switch(evt->evt_id)
    {
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
    case CUI_DTCNT_SELECT_EVENT_ANY_SIM_ACCOUNT_SELECTED:
        {
            /* If user selected an account and press OK, send this event to APPs proc, APP need to save the account ID and close the CUI */            
            PMNG_WRAP_CALLBACK(dtacct_ctx.p_hdl, 
                dtacct_ctx.cb(/*(VMINT)event->selectSim, */(VMUINT32)event->accountId));
            
            //cui_dtcnt_select_close(event->sender_id);
            
            MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_VMIO_DTCNT_SEL_LOG, 
                            event->selectSim,
                            0,
                            0,
                            0,
                            0,
                            event->accountId,
                            3, __LINE__);
                            
            MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_VMIO_DTCNT_SEL_E1, 3, __LINE__);
        }
        break;
    case CUI_DTCNT_SELECT_EVENT_RESULT_OK:
    case CUI_DTCNT_SELECT_EVENT_RESULT_CANCEL:
        /* If CUIs part screen closed abnormally not by user, send this event to APPs proc, APP can just  close the CUI*/
    case CUI_DTCNT_SELECT_EVENT_CLOSE:
        cui_dtcnt_select_close(event->sender_id);
        mmi_frm_group_close((MMI_ID)dtacct_ctx.parent_gid);
        memset(&dtacct_ctx, 0, sizeof(dtacct_ctx));
        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_VMIO_DTCNT_SEL_E2, 3, __LINE__);
    default:
            break;  
    }

    
    MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_VMIO_DTCNT_SEL_E, 3, __LINE__);
    return MMI_RET_OK;
}
	//abm hold
static kal_uint32 vm_cbm_get_account_id(vm_res_type_t type, VMINT res_id)
{
    kal_uint32 account_id = 0;
    kal_int8 ret = 0;

    switch (type)
    {
    case VM_RES_TYPE_TCP:
        {
            account_id = vm_get_tcp_acctid_by_resid(res_id);
        }break;
    case VM_RES_TYPE_UDP:
        {
            account_id = vm_get_udp_acctid_by_resid(res_id);
        }break;
#ifdef __MRE_LIB_HTTP__
    case VM_RES_TYPE_HTTP:
        {
            VMUINT32 vm_get_http_acctid_by_resid(VMINT res_id);
            VMUINT32 http_acct_id = 0;
            //res_id = VM_RES_TYPE_HTTP_HANDLE;
            http_acct_id = vm_get_http_acctid_by_resid(res_id);
            account_id = http_acct_id;
        }break;
#endif
#ifdef __MRE_SAL_WPS__
    case VM_RES_TYPE_HTTPS:
        {
            //res_id = VM_RES_TYPE_WPS_HANDLE;
            extern kal_uint32 vm_get_https_acctid_by_chnlid(VMINT channel_id);
            kal_uint32 https_acct_id = 0;
            https_acct_id = vm_get_https_acctid_by_chnlid(res_id);
            account_id = https_acct_id;
        }break;
#endif
    default:
        {
            return 0;
        }
    }

    return account_id;

}

static kal_uint8 g_ap_id = 0;

	//abm hold
VMINT vm_cbm_hold_bearer(vm_res_type_t type, VMINT hdl)
{
    kal_uint32 account_id = 0;
    kal_uint8 ap_id = 0;
    kal_int8 ret = 0;

    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_ABM_HOLD_BEARER_S, 1, __LINE__ );
    account_id = vm_cbm_get_account_id(type, hdl);

    if (0 == account_id)
    {
        return -2;
    }
    
    ap_id = cbm_get_app_id((kal_uint32)account_id);

    if (CBM_OK != (ret = cbm_hold_bearer(ap_id)))
    {
        //hold the bearer successfully
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_ABM_HOLD_BEARER_E1, 1, ret );
        return ret;
    }

    g_ap_id = ap_id;

    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_ABM_HOLD_BEARER_E, 1, g_ap_id );
    return 0;
}

VMINT vm_cbm_release_bearer(void)
{
    kal_uint32 account_id = 0;
    kal_uint8 ap_id = 0;
    kal_int8 ret = 0;

    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_ABM_HOLD_BEARER_S, 2, g_ap_id );
    if (0 == g_ap_id)
    {
        return -2;
    }

    ret = cbm_release_bearer(g_ap_id);

    if (CBM_OK != ret && CBM_WOULDBLOCK != ret)
    {
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_ABM_HOLD_BEARER_E1, 2, ret );
        return ret;
    }

    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_ABM_HOLD_BEARER_E, 2, g_ap_id );
    return 0;

}

// custmized apn
#include "MRESrvGprot.h"

static VMINT g_cust_is_set = 0;
static VMBOOL vm_is_cust_apn_set(void)
{
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_CUST_APN_S, 3, __LINE__);
    if (g_cust_is_set)
    {
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_CUST_APN_E1, 3, __LINE__);
        return (~0);
    }
    else
    {
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_CUST_APN_E2, 3, __LINE__);
        return (0);
    }
//    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_CUST_APN_E, 3, __LINE__);
}

VMINT vm_set_cust_apn_info(const vm_dtcnt_info_t * info, VMUINT32 * dtacct)
{
    vm_srv_dtcnt_info_t *  info_int = (vm_srv_dtcnt_info_t *)srv_mre_get_cust_dtcnt_info();
    VMUINT8 app_id = 0;
    VMINT8 ret = 0;
    VMUINT32 account_id = 0;
    VMINT32 status = 0;

    
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_CUST_APN_S, 1, __LINE__);

    if (NULL == info_int || NULL == info)
    {
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_CUST_APN_E1, 1, __LINE__);
        return -2;
    }

    
    ret = vm_get_app_id(VM_APN_USER_DEFINE, &app_id);
    if (ret != VM_E_SOC_SUCCESS)
    {
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_CUST_APN_E2, 1, __LINE__);
        return -3;
    }
    
    *dtacct = vm_get_account_id(CBM_MRE_ACCT_ID, app_id);

    status = cbm_get_bearer_status(*dtacct);
    if (status >= 0)
    {
        if (CBM_ACTIVATED == status || CBM_ACTIVATING == status)
        {
            MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_CUST_APN_E3, 1, __LINE__);
            return -4;
        }
    }
    else
    {
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_CUST_APN_E4, 1, __LINE__);
        return -5;
    }

    g_cust_is_set = 1;

    memcpy(info_int->APN, info->APN, SRV_DTCNT_PROF_MAX_APN_LEN+1);
    memcpy(info_int->PrimaryAddr, info->PrimaryAddr, VM_SRV_DTCNT_PROF_MAX_IP_ADDR_LEN);
    info_int->use_proxy = (U8)info->use_proxy;
    memcpy(info_int->UserName, info->UserName, SRV_DTCNT_PROF_MAX_USER_LEN+1);
    memcpy(info_int->Passwd, info->Passwd, SRV_DTCNT_PROF_MAX_PW_LEN+1);
    memcpy(info_int->px_addr, info->px_addr, VM_SRV_DTCNT_PROF_MAX_IP_ADDR_LEN);
    info_int->px_port = (U16)info->px_port;
    
    MMI_PRINT(MOD_MRE, MMI_MRE_TRC_MOD_VMSOCK,"cust apn[%s, %d]addr[%s:%d]", info_int->APN, info_int->use_proxy, info_int->px_addr, info_int->px_port);

    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_CUST_APN_E, 1, __LINE__);

    return 0;
}

VMINT vm_get_cust_apn_info(vm_dtcnt_info_t * info)
{
    vm_srv_dtcnt_info_t *  info_int = (vm_srv_dtcnt_info_t *)srv_mre_get_cust_dtcnt_info();

    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_CUST_APN_S, 2, __LINE__);
    if (NULL == info)
    {
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_CUST_APN_E1, 2, __LINE__);
        return -2;
    }
    
    if (!vm_is_cust_apn_set())
    {
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_CUST_APN_E2, 2, __LINE__);
        return -3;
    }
    
    memcpy(info->APN, info_int->APN, VM_SRV_DTCNT_PROF_MAX);
    memcpy(info->PrimaryAddr, info_int->PrimaryAddr, VM_SRV_DTCNT_IP_MAX);
    info->use_proxy = (VMUINT8)info_int->use_proxy;
    memcpy(info->UserName, info_int->UserName, VM_SRV_DTCNT_PROF_MAX);
    memcpy(info->Passwd, info_int->Passwd, VM_SRV_DTCNT_PROF_MAX);
    memcpy(info->px_addr, info_int->px_addr, VM_SRV_DTCNT_IP_MAX);
    info->px_port = (VMUINT16)info_int->px_port;

    
    MMI_PRINT(MOD_MRE, MMI_MRE_TRC_MOD_VMSOCK,"cust apn[%s, %d]addr[%s:%d]", info->APN, info->use_proxy, info->px_addr, info->px_port);

    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_CUST_APN_E, 2, __LINE__);
    return 0;
}
// DIS WLAN
VMINT vm_wlan_perfer(VMINT disable)
{
    VM_PROCESS_STATUS status = VM_PMNG_UNLOAD;
    _vm_pcb_t* pcb = NULL;

    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_DIS_WLAN_S, 1, __LINE__);
    pcb = vm_sh_pcb_in_pt(SH_TYPE_PROCESS_HANDLE, vm_pmng_get_current_handle(), &status);

    if (NULL == pcb)
    {
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_DIS_WLAN_E1, 1, __LINE__);
        return -2;
    }

    if (disable)
    {
        pcb->flag |= VM_FLAG_DIS_WLAN_PERFER;
    }
    else
    {
        pcb->flag &= ~VM_FLAG_DIS_WLAN_PERFER;
    }

    
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_DIS_WLAN_LOG, 
        disable,
        0,
        0,
        0,
        0,
        pcb->flag,
        1, __LINE__);
    
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_DIS_WLAN_E, 1, __LINE__);
    return 0;
}

VMINT vm_get_network_sym(VMCHAR* func_name)
{
	return 0;
}

#endif /* __MRE_SAL_SOCKET__ */

