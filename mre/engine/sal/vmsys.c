/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*****************************************************************************
 *
 * Filename:
 * ---------
 * vObjects.c
 *
 * Project:
 * --------
 * MAUI
 *
 * Description:
 * ------------
 * This file is intends for MRE system external funtion.
 *
 * Author:
 * -------
 * 
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *
*------------------------------------------------------------------------------
* Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
*============================================================================
****************************************************************************/
#include "vmswitch.h"
#ifdef __MRE_CORE_BASE__
#include "wgui_categories_list.h"
#include "MMIDataType.h"
#include "mmi_frm_history_gprot.h"
#include "mmi_cb_mgr_gprot.h"
#include "app_datetime.h"
#include "kal_public_defs.h"
#include "kal_public_api.h"
#include "string.h"
#include "app_mem.h"
#include "kal_general_types.h"
#include "stack_config.h"
#include "kal_trace.h"
#include "stdio.h"
#include "mmi_rp_app_mre_def.h"
#include "DevConfigDef.h"
#include "mmi_frm_mem_gprot.h"
#include "mmi_frm_events_gprot.h"
#include "mmi_frm_input_gprot.h"
#include "wgui_categories_util.h"
#include "GlobalResDef.h"
#include "mmi_frm_scenario_gprot.h"
#include "PixcomFontEngine.h"
#include "CustDataRes.h"
#include "DevConfigGprot.h"
#include "Conversions.h"
#include "gui_touch_feedback.h"

#include "med_main.h"
#include "med_api.h"
#include "AMGprot.h"
#include "vmopt.h"
#include "vmtimer.h"
#include "vmsys.h"
#include "vmloader.h"
#include "vmlog.h"
#include "vmio.h"
#include "vmchset.h"
#include "vmmod.h"
#include "vmmem.h"
#include "vmnvram.h"
#include "vmua.h"
#include "vmmacrostub.h"
#include "vmgettag.h"
#include "vmcert.h"
#include "vmcerter.h"
#include "vmmullang.h"
#include "vmresmng.h"
#include "vmpromng.h"
#include "vmproevt.h"
#include "vmenv.h"
#include "vmpromnginner.h"
#include "vmstdlib.h"
#include "vmcermng.h"
#include "gv.h"
#include "tst_def.h"
#include "vmso.h"
#include "kal_release.h"
#include "vmpermng.h"
#include "gpiosrvgprot.h"
#include "lcd_sw_inc.h"
#include "med_mem.h"
/*vm_get_sys_scene*/
#include "ProfilesSrvGprot.h"
#include "med_smalloc.h"
#include "vmsock.h"
#include "vmsms.h"
#include "wgui_categories_popup.h"
#include "FileMgrSrvGProt.h"
#include "devprofilegprot.h"
#include "MREAppMgrSrvGprot.h"
#include "Mmi_clipboard_gprot.h"

#if defined(__MMI_VUI_LAUNCHER_MRE__)
#include "vapp_launcher_system.h"
#include "vapp_launcher_mre_def.h"
#endif

#if defined(__MMI_VUI_SCREEN_LOCK_MRE__)
#include "vapp_screen_lock_system.h"
#include "vapp_screen_lock_mre_def.h"
#endif

#if defined(__MMI_VUI_WALLPAPER_MRE__)	
#include "vapp_wallpaper_content_provider.h"
#endif


//#define __MMI_MRE_SWLA_DEBUG__

#if defined(__MTK_TARGET__)
#include "SST_sla.h"
#endif

#include "verno.h"
#include "vmua.h"

#if defined(__MTK_INTERNAL__) && defined(__MTK_TARGET__) && defined(__MMI_MRE_SWLA_DEBUG__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#else
#define MRE_SWLA_START(_symbol_)
#define MRE_SWLA_STOP(_symbol_)
#endif


#define MRE_APP_NAME_MAX_LEN    127

VMINT g_vm_stub_sb;
VMINT g_vm_stub_sb_vrt;

extern U8 EntryNewScreen(U16 newscrnID, FuncPtr newExitHandler, FuncPtr newEntryHandler, void  *peerBuf);
extern U8 SetDelScrnIDCallbackHandler(U16 ScrnID, HistoryDelCBPtr funcPtr);
extern void GoBackHistory(void);
extern void applib_dt_get_rtc_time(applib_time_struct *t);
extern void mmi_ime_delete_editor_common_scr(U16 scr_id);
extern U16 mmi_frm_group_enter_ex(U16 parent_id, U16 group_id, mmi_proc_func proc, void *user_data, S16 flag);
#ifdef __MRE_SAL_SIM__
extern void _vm_init_sim_card_status(void);
#endif
//extern void vm_set_log_out(int log_out);
//extern void vm_set_log_level(int log_level);
//extern void vm_set_log_mtk(int log_mtk);
extern int mre_get_options_log_level(void);
extern int mre_get_options_log_out(void);
extern int mre_get_options_log_mtk(void);
extern VMINT mre_options_init(char* filename);
extern VMINT vm_nvram_init(void);
extern void vm_go_back_host_platform_history(void);
extern void vm_app_name_change_string(void);
extern VMINT vm_start_mre_app(VMWSTR fileName, vm_mre_app_evt_cb_t vam_cb);
extern VMINT * _vm_per_get_mre_fun_list(void);
void _vm_init_resource_monitor_cb(VMINT tid);
static U8 _vm_init_resource_monitor_all(void * in);

extern _vm_pcb_t* vm_alloc_pcb(VMWSTR filename, _vm_pcb_t* father, VMINT isRemoveDriver);
extern void vm_free_pcb(_vm_pcb_t* pcb);

extern VMINT vm_ce_auth_app_ex( VMWSTR filename, VMUCHAR * cache_buf, VMINT cache_len, VMINT mode );
extern int vm_get_sb(void);
extern void _vm_per_clear_mre_fun_list(void);

//extern void _vm_autorun(void);
extern void vm_chset_memory_init(void);         /* reduce static memory */
extern void vm_chset_memory_deinit(void);   /* reduce static memory */

extern mmi_ret vm_pmng_deal_orientation_event(mmi_event_struct *param);
extern void vm_mre_free_pre_app_mem(void);

extern void * am_mem_ptr;
VMINT mre_running = FALSE;
//kal_mutexid mre_mutex_id;


mmi_devconfig_system_config_struct sysconf;

static VMUINT8* kernel_mem_base = NULL;
#ifdef MRE_ENABLE_MEM_DEBUG
static malloc_stat_t kernel_mem_stat;
#endif

vm_res_monitor_init_struct * res_monitor_init_ptr = NULL;

/*
 * ADM ID of MRE CORE
 */
KAL_ADM_ID g_mre_core_adm_id = NULL;

vm_app_mem_struct g_app_mem_info[MRE_SUPPORT_MAX_APP_NUM];


/* memory pool */
#ifdef __MTK_TARGET__
#ifdef __DYNAMIC_SWITCH_CACHEABILITY__
#pragma arm section zidata = "DYNAMICCACHEABLEZI_C_MMIPOOL"
#else
#pragma arm section zidata = "LARGEPOOL_FIRST_ZI"
#endif
#endif /* __MTK_TARGET__ */

VMUINT8 g_mre_core_mem[MRE_SYS_ASM_CORE_MEMPOOL_SIZE];

#pragma arm section zidata

vm_vsm_mem_struct g_vsm_mem_info[MRE_SUPPORT_MAX_VSM_NUM];

/*modules*/
static const vm_module_struct g_mre_modules = {
        1,
    
#ifdef __MRE_CORE_SANDBOX__
        1,
#else
        0,
#endif
        
#ifdef __MRE_CORE_RESOURCE_MANAGE__
        1,
#else
        0,
#endif
        
#ifdef __MRE_CORE_SAFETY__
        1,
#else
        0,
#endif
    
#ifdef __MRE_CORE_APP_COMMUNICATION__
        1,
#else
        0,
#endif
    
#ifdef __MRE_CORE_SM__
        1,
#else
        0,
#endif
        
#ifdef __MRE_CORE_SO__
        1,
#else
        0,
#endif
    
#ifdef __MRE_LIB_APPRES__
        1,
#else
        0,
#endif
    
#ifdef __MRE_LIB_C__
        1,
#else
        0,
#endif
    
#ifdef __MRE_LIB_CHSET__
        1,
#else
        0,
#endif
    
#ifdef __MRE_LIB_DEF_GAME__
        1,
#else
        0,
#endif
    
#ifdef __MRE_LIB_GRAPIC_DDRAW__
        1,
#else
        0,
#endif
    
#ifdef __MRE_LIB_GRAPIC_GFXOLD__
        1,
#else
        0,
#endif
    
#ifdef __MRE_LIB_GRAPIC_IMAGE__
        1,
#else
        0,
#endif
    
#ifdef __MRE_LIB_HTTP__
        1,
#else
        0,
#endif
    
#ifdef __MRE_LIB_IME__
        1,
#else
        0,
#endif
    
#ifdef __MRE_LIB_INI__
        1,
#else
        0,
#endif
    
#ifdef __MRE_LIB_LOG__
        1,
#else
        0,
#endif    
    
#ifdef __MRE_LIB_MULTI_LANG__
        1,
#else
        0,
#endif   
    
#ifdef __MRE_LIB_NETWORK__
        1,
#else
        0,
#endif       
        
#ifdef __MRE_LIB_NETWORK_VIP__
        1,
#else
        0,
#endif 
    
#ifdef __MRE_LIB_NETWORK_VIP_VG__
        1,
#else
        0,
#endif     
        
#ifdef __MRE_LIB_XML__
        1,
#else
        0,
#endif      
    
#ifdef __MRE_SAL_AUDIO__
        1,
#else
        0,
#endif
    
#ifdef __MRE_SAL_BITSTREAM__
        1,
#else
        0,
#endif
    
#ifdef __MRE_SAL_CAMERA__
        1,
#else
        0,
#endif
    
#ifdef __MRE_SAL_CELL__
        1,
#else
        0,
#endif
    
#ifdef __MRE_SAL_CHE_DES__
        1,
#else
        0,
#endif
    
#ifdef __MRE_SAL_CHE_MD5__
        1,
#else
        0,
#endif
    
#ifdef __MRE_SAL_CHE_SHA1__
        1,
#else
        0,
#endif
        
#ifdef __MRE_SAL_GPS__
        1,
#else
        0,
#endif
    
#ifdef __MRE_SAL_MMS__
        1,
#else
        0,
#endif
    
#ifdef __MRE_SAL_PHONEBOOK__
        1,
#else
        0,
#endif
    
#ifdef __MRE_SAL_SENSOR__
        1,
#else
        0,
#endif
    
#ifdef __MRE_SAL_SIM__
        1,
#else
        0,
#endif
    
#ifdef __MRE_SAL_SMS__
        1,
#else
        0,
#endif
    
#ifdef __MRE_SAL_SOCKET__
        1,
#else
        0,
#endif
    
#ifdef __MRE_SAL_STATUS__
        1,
#else
        0,
#endif
    
#ifdef __MRE_SAL_TELE__
        1,
#else
        0,
#endif
    
#ifdef CFG_MRE_SAL_TIMER
        1,
#else
        0,
#endif
    
#ifdef __MRE_SAL_VIDEO__
        1,
#else
        0,
#endif
    
#ifdef __MRE_SAL_WALLPAPER__
        1,
#else
        0,
#endif
    
#ifdef __MRE_SAL_WPS__
        1,
#else
        0,
#endif
    
#ifdef __MRE_APP_LAUNCH__
        1,
#else
        0,
#endif    
        
#ifdef __MRE_SAL_PAYMENT__
        1,
#else
        0,
#endif
};



vm_mre_evt_cb_t vam_callback = NULL;
static vm_mre_app_evt_cb_t vam_app_callback = NULL;
static VMWSTR g_mre_app_file_name = NULL;
static void vm_asm_alloc_entry(void);
static void vm_app_name_change_string_int(VMINT index);
static VMINT vm_start_mre_envirment_ex(void);



void vm_mutex_init(vm_mutex_struct *pMutex)
{
	pMutex->state = VM_MUTEX_STATE_GIVEN;
}


static void vm_mutex_lock(vm_mutex_struct *pMutex)
{
#ifdef __MTK_TARGET__
    static const int locked = VM_MUTEX_STATE_TAKEN;

    volatile int *addr = &pMutex->state;
    int state;

    __asm
    {
        MOV   state, locked
    try_spin_lock:
        SWP   state, state, [addr]
        CMP   state, locked
        BNE   end_spin_lock
        BL    kal_sleep_task, { r0 = 1 }
        B     try_spin_lock
    end_spin_lock:
    }

#else
    U32 save_irq_mask;
    while (1)
    {
        save_irq_mask = SaveAndSetIRQMask();
        if (pMutex->state == VM_MUTEX_STATE_GIVEN)
        {
            pMutex->state = VM_MUTEX_STATE_TAKEN;
            RestoreIRQMask(save_irq_mask);
            break;
        }
        RestoreIRQMask(save_irq_mask);
        kal_sleep_task(1);
    }
#endif

}


static void vm_mutex_unlock(vm_mutex_struct *pMutex)
{
#ifdef __MTK_TARGET__
    pMutex->state = VM_MUTEX_STATE_GIVEN;
#else
    U32 save_irq_mask;
    save_irq_mask = SaveAndSetIRQMask();
    pMutex->state = VM_MUTEX_STATE_GIVEN;
    RestoreIRQMask(save_irq_mask);
#endif
}

VMUINT8* vm_graphic_get_resource(VMINT resid,VMINT* len)
{
	return NULL;
}
extern void vm_mre_register_callback(void);
extern void vm_mre_cmd_init(void);
void vm_mre_init(void)
{
#ifdef __VRE_CORE_APP_COMMUNICATION__
        vm_appcomm_init();
#endif /* __VRE_CORE_APP_COMMUNICATION__ */
	vm_frm_init();
	vm_start_mre_envirment_ex();
	vm_mre_cmd_init();
	vm_ncenter_init();
    vm_mre_register_callback(); 
}

/* this function is for engine only, in vmpromngine.h */
VMUINT vm_get_pool_size_from_ptr(void *_ptr)
{
	VMINT i;
	VMUINT8 *ptr = (VMUINT8 *)_ptr;
	
	for (i = 0; i < MRE_SUPPORT_MAX_APP_NUM; i++) {
		if ((g_app_mem_info[i].adm_id != NULL)
			   && (g_app_mem_info[i].mem_base <= ptr)
			   && (ptr < g_app_mem_info[i].mem_base + g_app_mem_info[i].mem_size)) {
			   	return g_app_mem_info[i].mem_size;
		}
	}
	
	return 0;
}

void *__vm_kernel_malloc(int size, kal_uint32 link_register,kal_uint32 malloc_flag) 
{
    void *ptr = NULL;

    if (g_mre_core_adm_id != NULL)
    {
        if(malloc_flag==1)
        {
#if defined(__MTK_TARGET__)
            ptr =  kal_adm_alloc_topmost_dbg(g_mre_core_adm_id, size,4, NULL, link_register);
#else
            ptr = kal_adm_alloc_topmost(g_mre_core_adm_id, size,4);
#endif
        }
        else
        {
#if defined(__MTK_TARGET__)
            ptr =  kal_adm_alloc_dbg(g_mre_core_adm_id, size, NULL, link_register);
#else
            ptr = kal_adm_alloc(g_mre_core_adm_id, size);
#endif
        }
    }
#ifdef MRE_ENABLE_MEM_DEBUG
    if (ptr == NULL)
    {
        kernel_mem_stat.fail_times ++;
        if (size > kernel_mem_stat.max_fail_size)
        {
            kernel_mem_stat.max_fail_size = size;
        }
    }
    else
    {     
        kernel_mem_stat.malloc_count ++;
        kernel_mem_stat.current += size;
        if (size > kernel_mem_stat.peak)
        {
            kernel_mem_stat.peak = size;
        }
        kernel_mem_stat.avail_heap_size = kal_adm_get_max_alloc_size(g_mre_core_adm_id);
        kernel_mem_stat.current = MRE_SYS_ASM_CORE_MEMPOOL_SIZE - kal_adm_get_total_left_size(g_mre_core_adm_id);
    }
         
#endif

    return ptr;
}

void *_vm_kernel_malloc(int size) 
{
	kal_uint32 link_register = 0;

#if defined(__MTK_TARGET__)
		
#if defined(__RVCT__)
	link_register = __return_address();
#else
	__asm {
		mov link_register, lr;
	}
#endif /*__RVCT__*/
		
	if(link_register&0x01)
	{
		link_register -= 5;
	}
	else
	{
		link_register -= 4;	   
	} 
#endif   /* __MTK_TARGET__  */

	return __vm_kernel_malloc(size, link_register,0);
}

void *_vm_kernel_calloc(int size)
{
    void* p = NULL;

	kal_uint32 link_register = 0;

#if defined(__MTK_TARGET__)
		
#if defined(__RVCT__)
	link_register = __return_address();
#else
	__asm {
		mov link_register, lr;
	}
#endif /*__RVCT__*/
		
	if(link_register&0x01)
	{
		link_register -= 5;
	}
	else
	{
		link_register -= 4;	   
	} 
#endif   /* __MTK_TARGET__  */

    p = __vm_kernel_malloc(size, link_register,0);
    
    if (p != NULL)
    {
        memset(p, 0, size);
    }
        
    return p;
    
}

void *_vm_kernel_realloc(void * p,int size)
{
    void* ptr = NULL;

	kal_uint32 link_register = 0;

#if defined(__MTK_TARGET__)
		
#if defined(__RVCT__)
	link_register = __return_address();
#else
	__asm {
		mov link_register, lr;
	}
#endif /*__RVCT__*/
		
	if(link_register&0x01)
	{
		link_register -= 5;
	}
	else
	{
		link_register -= 4;	   
	} 
#endif   /* __MTK_TARGET__  */

    ptr = __vm_kernel_malloc(size, link_register,0);
    if (ptr != NULL)
    {
        memcpy(ptr, p, size);
        _vm_kernel_free(p);
    }    

    return ptr;
}

void _vm_kernel_free(void* ptr)
{
    if ((g_mre_core_adm_id != NULL)&&(ptr != NULL))
    {
        kal_adm_free(g_mre_core_adm_id, ptr);
    }
#ifdef MRE_ENABLE_MEM_DEBUG
     kernel_mem_stat.free_count ++;
     kernel_mem_stat.avail_heap_size = kal_adm_get_max_alloc_size(g_mre_core_adm_id);
     kernel_mem_stat.current = MRE_SYS_ASM_CORE_MEMPOOL_SIZE - kal_adm_get_total_left_size(g_mre_core_adm_id);
#endif
}

/*
malloc_flag: 0:normal alloc; 1:topmost alloc
*/
void *_vm_malloc(int size, kal_uint32 link_register,kal_uint32 malloc_flag) 
{
    VMINT pHandle = vm_pmng_get_current_handle(), i = 0;
    void *ptr = NULL;
	VMINT mem_idx;
    
    if (pHandle == 0)
    {
		return __vm_kernel_malloc(size, link_register,malloc_flag);
    }
    else
    {
        for (i=0; i<MRE_SUPPORT_MAX_APP_NUM; i++)
        {
            if (g_app_mem_info[i].p_handle == pHandle)
            {
                break;
            }
        }
        if (i == MRE_SUPPORT_MAX_APP_NUM)
        {
			for (mem_idx=0; mem_idx<MRE_SUPPORT_MAX_VSM_NUM; mem_idx++)
			{
				if (g_vsm_mem_info[mem_idx].p_handle == pHandle)
				{
					break;
				}
			}
			
			if (mem_idx == MRE_SUPPORT_MAX_VSM_NUM)
			{
				return NULL;
			}
			else
			{
				if (g_vsm_mem_info[mem_idx].adm_id != NULL)
				{
				    if(malloc_flag==1)
                    {
#if defined(__MTK_TARGET__)
					    ptr =  kal_adm_alloc_topmost_dbg(g_vsm_mem_info[mem_idx].adm_id, size, 4,NULL, link_register);
#else
					    ptr =  kal_adm_alloc_topmost(g_vsm_mem_info[mem_idx].adm_id, size,4);
#endif
                    }            
                    else
                    {
#if defined(__MTK_TARGET__)
					    ptr =  kal_adm_alloc_dbg(g_vsm_mem_info[mem_idx].adm_id, size, NULL, link_register);
#else
					    ptr =  kal_adm_alloc(g_vsm_mem_info[mem_idx].adm_id, size);
#endif
                    }
				}
#ifdef MRE_ENABLE_MEM_DEBUG
				if (ptr == NULL)
				{
					g_vsm_mem_info[mem_idx].mem_stat.fail_times ++;
					if (size > g_vsm_mem_info[mem_idx].mem_stat.max_fail_size)
					{
						g_vsm_mem_info[mem_idx].mem_stat.max_fail_size = size;
					}
				}
				else
				{	  
					g_vsm_mem_info[mem_idx].mem_stat.malloc_count++;
					g_vsm_mem_info[mem_idx].mem_stat.avail_heap_size = kal_adm_get_max_alloc_size(g_vsm_mem_info[mem_idx].adm_id);
					g_vsm_mem_info[mem_idx].mem_stat.current = g_vsm_mem_info[mem_idx].heap_size - kal_adm_get_total_left_size(g_vsm_mem_info[mem_idx].adm_id);
					if (g_vsm_mem_info[mem_idx].mem_stat.current > g_vsm_mem_info[mem_idx].mem_stat.peak)
					{
						g_vsm_mem_info[mem_idx].mem_stat.peak = g_vsm_mem_info[mem_idx].mem_stat.current;
					}
				}						 

				vm_app_res_info(
					pHandle, 
					VM_RES_TYPE_MEMORY,
					g_vsm_mem_info[mem_idx].heap_size, 
					g_vsm_mem_info[mem_idx].mem_stat.current,
					g_vsm_mem_info[mem_idx].mem_stat.peak);
#else
				vm_app_res_info(
						pHandle, 
						VM_RES_TYPE_MEMORY, 
						VM_RES_VALUE_NOT_AVAILABLE, 
						VM_RES_VALUE_NOT_AVAILABLE, 
						VM_RES_VALUE_NOT_AVAILABLE);
#endif
			}
        }
		else
		{
		
	        if (g_app_mem_info[i].adm_id != NULL)
	        {
	            if(malloc_flag==1)
                {
                    vm_mutex_lock(&(g_app_mem_info[i].mutex));
#if defined(__MTK_TARGET__)
	                ptr =  kal_adm_alloc_topmost_dbg(g_app_mem_info[i].adm_id, size,4, NULL, link_register);
#else
	                ptr =  kal_adm_alloc_topmost(g_app_mem_info[i].adm_id, size,4); 
#endif
				    vm_mutex_unlock(&(g_app_mem_info[i].mutex));
                }
                else
                {
	            vm_mutex_lock(&(g_app_mem_info[i].mutex));
#if defined(__MTK_TARGET__)
	            ptr =  kal_adm_alloc_dbg(g_app_mem_info[i].adm_id, size, NULL, link_register);
#else
	            ptr =  kal_adm_alloc(g_app_mem_info[i].adm_id, size); 
#endif
				vm_mutex_unlock(&(g_app_mem_info[i].mutex));
                }
	        }
	        
#ifdef MRE_ENABLE_MEM_DEBUG
        if (ptr == NULL)
        {
            g_app_mem_info[i].mem_stat.fail_times ++;
            if (size > g_app_mem_info[i].mem_stat.max_fail_size)
            {
                g_app_mem_info[i].mem_stat.max_fail_size = size;
            }
        }
        else
        {     
            g_app_mem_info[i].mem_stat.malloc_count ++;
//            g_app_mem_info[i].mem_stat.current += size;
            g_app_mem_info[i].mem_stat.avail_heap_size = kal_adm_get_max_alloc_size(g_app_mem_info[i].adm_id);
            g_app_mem_info[i].mem_stat.current = g_app_mem_info[i].heap_size - kal_adm_get_total_left_size(g_app_mem_info[i].adm_id);
            if (g_app_mem_info[i].mem_stat.current > g_app_mem_info[i].mem_stat.peak)
            {
                g_app_mem_info[i].mem_stat.peak = g_app_mem_info[i].mem_stat.current;
            }
        }
     
        vm_app_res_info(
            pHandle, 
            VM_RES_TYPE_MEMORY,
            g_app_mem_info[i].heap_size, 
            g_app_mem_info[i].mem_stat.current,
            g_app_mem_info[i].mem_stat.peak);
#else
        vm_app_res_info(
	            pHandle, 
	            VM_RES_TYPE_MEMORY, 
	            VM_RES_VALUE_NOT_AVAILABLE, 
	            VM_RES_VALUE_NOT_AVAILABLE, 
	            VM_RES_VALUE_NOT_AVAILABLE);
#endif
    	}
    }

	return ptr;
}

void *vm_malloc(int size) 
{
	kal_uint32 link_register = 0;
	
#if defined(__MTK_TARGET__)
			
#if defined(__RVCT__)
	link_register = __return_address();
#else
	__asm {
		mov link_register, lr;
	}
#endif /*__RVCT__*/
			
	if(link_register&0x01)
	{
		link_register -= 5;
	}
	else
	{
		link_register -= 4;    
	} 
#endif   /* __MTK_TARGET__  */

	return _vm_malloc(size, link_register,0);
}

void *vm_malloc_topmost(int size) 
{
	kal_uint32 link_register = 0;
	
#if defined(__MTK_TARGET__)
			
#if defined(__RVCT__)
	link_register = __return_address();
#else
	__asm {
		mov link_register, lr;
	}
#endif /*__RVCT__*/
			
	if(link_register&0x01)
	{
		link_register -= 5;
	}
	else
	{
		link_register -= 4;    
	} 
#endif   /* __MTK_TARGET__  */

	return _vm_malloc(size, link_register,1);
}

/*
malloc_flag: 0:normal alloc; 1:topmost alloc
*/
void *_vm_malloc_nc(int size, kal_uint32 link_register,kal_uint32 malloc_flag) 
{
    VMINT pHandle = vm_pmng_get_current_handle(), i = 0;
    void *ptr = NULL;
    VMINT mem_idx;
    if (pHandle == 0)
	{
		if (g_mre_core_adm_id != NULL)
        {
            if( malloc_flag==1 )
            {
#if defined(__MTK_TARGET__)
                ptr =  kal_adm_alloc_nc_topmost_dbg(g_mre_core_adm_id, size, 32,NULL, link_register);
#else
                ptr =  kal_adm_alloc_nc_topmost(g_mre_core_adm_id, size,32);
#endif
            }
            else
            {
#if defined(__MTK_TARGET__)
                ptr =  MMI_FRM_ADM_ALLOC_FRAMEBUFFER_DBG(g_mre_core_adm_id, size, NULL, link_register);
#else
                ptr =  MMI_FRM_ADM_ALLOC_FRAMEBUFFER(g_mre_core_adm_id, size);
#endif
            }
			return ptr;
        }
		else
			return NULL;
	}
	else
    {
        for (i=0; i<MRE_SUPPORT_MAX_APP_NUM; i++)
        {
            if (g_app_mem_info[i].p_handle == pHandle)
            {
                break;
            }
        }

        if (i == MRE_SUPPORT_MAX_APP_NUM)
        {
			for (mem_idx=0; mem_idx<MRE_SUPPORT_MAX_VSM_NUM; mem_idx++)
			{
				if (g_vsm_mem_info[mem_idx].p_handle == pHandle)
				{
					break;
				}
			}
			
			if (mem_idx == MRE_SUPPORT_MAX_VSM_NUM)
			{
				return NULL;
			}
			else
			{
				if (g_vsm_mem_info[mem_idx].adm_id != NULL)
				{
				    if(malloc_flag==1)
                    {
#if defined(__MTK_TARGET__)
                        ptr =  kal_adm_alloc_nc_topmost_dbg(g_vsm_mem_info[mem_idx].adm_id, size, 32,NULL, link_register);
#else
                        ptr =  kal_adm_alloc_nc_topmost(g_vsm_mem_info[mem_idx].adm_id, size,32);
#endif
                    }
                    else
                    {
#if defined(__MTK_TARGET__)
					    ptr =  MMI_FRM_ADM_ALLOC_FRAMEBUFFER_DBG(g_vsm_mem_info[mem_idx].adm_id, size, NULL, link_register);
#else
					    ptr =  MMI_FRM_ADM_ALLOC_FRAMEBUFFER(g_vsm_mem_info[mem_idx].adm_id, size);
#endif
                }
				}
#ifdef MRE_ENABLE_MEM_DEBUG
				if (ptr == NULL)
				{
					g_vsm_mem_info[mem_idx].mem_stat.fail_times ++;
					if (size > g_vsm_mem_info[mem_idx].mem_stat.max_fail_size)
					{
						g_vsm_mem_info[mem_idx].mem_stat.max_fail_size = size;
					}
				}
				else
				{	  
					g_vsm_mem_info[mem_idx].mem_stat.malloc_count ++;
					g_vsm_mem_info[mem_idx].mem_stat.avail_heap_size = kal_adm_get_max_alloc_size(g_vsm_mem_info[mem_idx].adm_id);
					g_vsm_mem_info[mem_idx].mem_stat.current = g_vsm_mem_info[mem_idx].heap_size - kal_adm_get_total_left_size(g_vsm_mem_info[mem_idx].adm_id);
					if (g_vsm_mem_info[mem_idx].mem_stat.current > g_vsm_mem_info[mem_idx].mem_stat.peak)
					{
						g_vsm_mem_info[mem_idx].mem_stat.peak = g_vsm_mem_info[mem_idx].mem_stat.current;
					}
				}						 

				vm_app_res_info(
					pHandle, 
					VM_RES_TYPE_MEMORY,
					g_vsm_mem_info[mem_idx].heap_size, 
					g_vsm_mem_info[mem_idx].mem_stat.current,
					g_vsm_mem_info[mem_idx].mem_stat.peak);
#else
				vm_app_res_info(
						pHandle, 
						VM_RES_TYPE_MEMORY, 
						VM_RES_VALUE_NOT_AVAILABLE, 
						VM_RES_VALUE_NOT_AVAILABLE, 
						VM_RES_VALUE_NOT_AVAILABLE);
#endif
			}
        }
		else
		{
	        if (g_app_mem_info[i].adm_id != NULL)
	        {
	            if( malloc_flag == 1)
                {
                 	vm_mutex_lock(&(g_app_mem_info[i].mutex));
#if defined(__MTK_TARGET__)
 	                ptr =  kal_adm_alloc_nc_topmost_dbg(g_app_mem_info[i].adm_id, size,32, NULL, link_register);
#else
 	                ptr =  kal_adm_alloc_nc_topmost(g_app_mem_info[i].adm_id, size,32);
#endif
 				    vm_mutex_unlock(&(g_app_mem_info[i].mutex));
                }
                else
                {
 				    vm_mutex_lock(&(g_app_mem_info[i].mutex));
#if defined(__MTK_TARGET__)
 	                ptr =  MMI_FRM_ADM_ALLOC_FRAMEBUFFER_DBG(g_app_mem_info[i].adm_id, size, NULL, link_register);
#else
 	                ptr =  MMI_FRM_ADM_ALLOC_FRAMEBUFFER(g_app_mem_info[i].adm_id, size);
#endif
 				    vm_mutex_unlock(&(g_app_mem_info[i].mutex));
                }
	        }
	        
#ifdef MRE_ENABLE_MEM_DEBUG
        if (ptr == NULL)
        {
            g_app_mem_info[i].mem_stat.fail_times ++;
            if (size > g_app_mem_info[i].mem_stat.max_fail_size)
            {
                g_app_mem_info[i].mem_stat.max_fail_size = size;
            }
        }
        else
        {     
            g_app_mem_info[i].mem_stat.malloc_count ++;
//            g_app_mem_info[i].mem_stat.current += size;
            g_app_mem_info[i].mem_stat.avail_heap_size = kal_adm_get_max_alloc_size(g_app_mem_info[i].adm_id);
            g_app_mem_info[i].mem_stat.current = g_app_mem_info[i].heap_size - kal_adm_get_total_left_size(g_app_mem_info[i].adm_id);
            if (g_app_mem_info[i].mem_stat.current > g_app_mem_info[i].mem_stat.peak)
            {
                g_app_mem_info[i].mem_stat.peak = g_app_mem_info[i].mem_stat.current;
            }
        }
     
        vm_app_res_info(
            pHandle, 
            VM_RES_TYPE_MEMORY,
            g_app_mem_info[i].heap_size, 
            g_app_mem_info[i].mem_stat.current,
            g_app_mem_info[i].mem_stat.peak);
#else
        vm_app_res_info(
	            pHandle, 
	            VM_RES_TYPE_MEMORY, 
	            VM_RES_VALUE_NOT_AVAILABLE, 
	            VM_RES_VALUE_NOT_AVAILABLE, 
	            VM_RES_VALUE_NOT_AVAILABLE);
#endif
		}
    }

	return ptr;
}
void *vm_malloc_nc(int size) 
{
    kal_uint32 link_register = 0;
#if defined(__MTK_TARGET__)		
#if defined(__RVCT__)
    link_register = __return_address();
#else
    __asm {
        mov link_register, lr;
    }
#endif /*__RVCT__*/
			
    if(link_register&0x01)
    {
        link_register -= 5;
    }
    else
    {
        link_register -= 4;	   
    } 
#endif		
    return _vm_malloc_nc(size, link_register,0);
	
}
void *vm_malloc_nc_topmost(int size)
{
        kal_uint32 link_register = 0;
#if defined(__MTK_TARGET__)              
#if defined(__RVCT__)
        link_register = __return_address();
#else
        __asm {
            mov link_register, lr;
        }
#endif /*__RVCT__*/
                
        if(link_register&0x01)
        {
            link_register -= 5;
        }
        else
        {
            link_register -= 4;    
        } 
#endif /*__MTK_TARGET__*/          
        return _vm_malloc_nc(size, link_register,1);

}

void *vm_calloc(int size)
{
    void* p = NULL;

	kal_uint32 link_register = 0;

#if defined(__MTK_TARGET__)
		
#if defined(__RVCT__)
	link_register = __return_address();
#else
	__asm {
		mov link_register, lr;
	}
#endif /*__RVCT__*/
		
	if(link_register&0x01)
	{
		link_register -= 5;
	}
	else
	{
		link_register -= 4;	   
	} 
#endif   /* __MTK_TARGET__  */

	p = _vm_malloc(size, link_register,0);
    
    if (p != NULL)
    {
        memset(p, 0, size);
    }
        
    return p;
    
}

void *vm_realloc(void * p,int size)
{
    void* ptr = NULL;

	kal_uint32 link_register = 0;

#if defined(__MTK_TARGET__)
		
#if defined(__RVCT__)
	link_register = __return_address();
#else
	__asm {
		mov link_register, lr;
	}
#endif /*__RVCT__*/
		
	if(link_register&0x01)
	{
		link_register -= 5;
	}
	else
	{
		link_register -= 4;	   
	} 
#endif   /* __MTK_TARGET__  */

    ptr = _vm_malloc(size, link_register,0);

    if (ptr != NULL)
    {
        memcpy(ptr, p, size);
        vm_free(p);
    }    

    return ptr;
}
void *vm_realloc_topmost(void * p,int size)
{
    void* ptr = NULL;

	kal_uint32 link_register = 0;

#if defined(__MTK_TARGET__)
		
#if defined(__RVCT__)
	link_register = __return_address();
#else
	__asm {
		mov link_register, lr;
	}
#endif /*__RVCT__*/
		
	if(link_register&0x01)
	{
		link_register -= 5;
	}
	else
	{
		link_register -= 4;	   
	} 
#endif   /* __MTK_TARGET__  */

    ptr = _vm_malloc(size, link_register,1);

    if (ptr != NULL)
    {
        memcpy(ptr, p, size);
        vm_free(p);
    }    

    return ptr;
}


void vm_free(void* ptr)
{
    VMINT pHandle = vm_pmng_get_current_handle(), i = 0;
	VMINT mem_idx;
    
    if (pHandle == 0)
    {
        _vm_kernel_free(ptr);
    }
    else
    {
        for (i=0; i<MRE_SUPPORT_MAX_APP_NUM; i++)
        {
            if (g_app_mem_info[i].p_handle == pHandle)
            {
                break;
            }
        }
        if (i == MRE_SUPPORT_MAX_APP_NUM)
        {
			for (mem_idx=0; mem_idx<MRE_SUPPORT_MAX_VSM_NUM; mem_idx++)
			{
				if (g_vsm_mem_info[mem_idx].p_handle == pHandle)
				{
					break;
				}
			}
			
			if (mem_idx == MRE_SUPPORT_MAX_VSM_NUM)
			{
				return ;
			}
			else
			{
				if ((g_vsm_mem_info[mem_idx].adm_id != 0) && (ptr != 0))
				{
					kal_adm_free(g_vsm_mem_info[mem_idx].adm_id, ptr);
				}
#ifdef MRE_ENABLE_MEM_DEBUG
				g_vsm_mem_info[mem_idx].mem_stat.free_count ++;
				g_vsm_mem_info[mem_idx].mem_stat.avail_heap_size = kal_adm_get_max_alloc_size(g_vsm_mem_info[mem_idx].adm_id);
				g_vsm_mem_info[mem_idx].mem_stat.current = g_vsm_mem_info[mem_idx].heap_size - kal_adm_get_total_left_size(g_vsm_mem_info[mem_idx].adm_id);

				vm_app_res_info(
					pHandle, 
					VM_RES_TYPE_MEMORY,
					g_vsm_mem_info[mem_idx].heap_size, 
					g_vsm_mem_info[mem_idx].mem_stat.current,
					g_vsm_mem_info[mem_idx].mem_stat.peak);
#else
				vm_app_res_info(
					pHandle, 
					VM_RES_TYPE_MEMORY, 
					VM_RES_VALUE_NOT_AVAILABLE, 
					VM_RES_VALUE_NOT_AVAILABLE, 
					VM_RES_VALUE_NOT_AVAILABLE);
#endif
			}
        }
        else
        {
            if ((g_app_mem_info[i].adm_id != 0) && (ptr != 0))
            {
				vm_mutex_lock(&(g_app_mem_info[i].mutex));
                kal_adm_free(g_app_mem_info[i].adm_id, ptr);
				vm_mutex_unlock(&(g_app_mem_info[i].mutex));
            }
#ifdef MRE_ENABLE_MEM_DEBUG
            g_app_mem_info[i].mem_stat.free_count ++;
            g_app_mem_info[i].mem_stat.avail_heap_size = kal_adm_get_max_alloc_size(g_app_mem_info[i].adm_id);
            g_app_mem_info[i].mem_stat.current = g_app_mem_info[i].heap_size - kal_adm_get_total_left_size(g_app_mem_info[i].adm_id);

            vm_app_res_info(
                pHandle, 
                VM_RES_TYPE_MEMORY,
                g_app_mem_info[i].heap_size, 
                g_app_mem_info[i].mem_stat.current,
                g_app_mem_info[i].mem_stat.peak);
#else
            vm_app_res_info(
                pHandle, 
                VM_RES_TYPE_MEMORY, 
                VM_RES_VALUE_NOT_AVAILABLE, 
                VM_RES_VALUE_NOT_AVAILABLE, 
                VM_RES_VALUE_NOT_AVAILABLE);
#endif
        }
    }
    
}


malloc_stat_t* vm_get_malloc_stat(void) 
{
#ifdef MRE_ENABLE_MEM_DEBUG
    VMINT pHandle = vm_pmng_get_current_handle_ignore_status(), i = 0;

    if (pHandle == 0)
    {
        return &(kernel_mem_stat);
    }
    else
    {
        for (i=0; i<MRE_SUPPORT_MAX_APP_NUM; i++)
        {
            if (g_app_mem_info[i].p_handle == pHandle)
            {
                return &g_app_mem_info[i].mem_stat;
            }
        }
		for (i=0; i<MRE_SUPPORT_MAX_VSM_NUM; i++)
		{
			if (g_vsm_mem_info[i].p_handle == pHandle)
			{
				return &g_vsm_mem_info[i].mem_stat;
			}
		}
        return NULL;
    }
#else
    return NULL;
#endif
}

/*****************************************************************************
* FUNCTION
 *    vm_global_malloc
 * DESCRIPTION
 *  allocate extra memory excluding the size announced when packing, size must larger than 10KB. 
 * PARAMETERS
 *  size : [IN]  size of byte to be allocated.
 * RETURNS
 *  memory pointer allocated, NULL means allocation failed.
*****************************************************************************/
void *vm_global_malloc(unsigned int size)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    VMINT pHandle = vm_pmng_get_current_handle(), i = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MRE_MEDIA_BUF__ /* PHASE OUT! */
    if (sysconf.memory_provide == MMI_DEVCONFIG_MEMPEY_PROVIDER_MEDIA)
    {
        return NULL;
    }
#endif
    
    if ((pHandle == 0) || (size < 10240))
    {
        return NULL;
    }
    
    for (i=0; i<MRE_SUPPORT_MAX_APP_NUM; i++)
    {
        if (g_app_mem_info[i].p_handle == pHandle)
        {
            break;
        }
    }
    if (i == MRE_SUPPORT_MAX_APP_NUM)
    {
        return NULL;
    }
    
    return  applib_mem_ap_alloc(APPLIB_MEM_AP_ID_MRE_APP0+i, size);

        
}


/*****************************************************************************
* FUNCTION
 *    vm_free
 * DESCRIPTION
 *  free memory allocated by vm_global_malloc();
 * PARAMETERS
 *  ptr : [IN]  memory pointer to be free.
*****************************************************************************/
void vm_global_free(void* ptr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    VMINT pHandle = vm_pmng_get_current_handle(), i = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    
    if (pHandle == 0)
    {
        return;
    }
    else
    {
        for (i=0; i<MRE_SUPPORT_MAX_APP_NUM; i++)
        {
            if (g_app_mem_info[i].p_handle == pHandle)
            {
                break;
            }
        }
        if (i == MRE_SUPPORT_MAX_APP_NUM)
        {
            return ;
        }
        else
        {
            applib_mem_ap_free(ptr);
        }
    }

}


/*****************************************************************************
* FUNCTION
 *    vm_global_get_max_alloc_size
 * DESCRIPTION
 *  Get the max possible size of single allocation from app-based ASM. 
 *  Return value of it is typically less than applib_mem_ap_get_total_left_size()
 *  if the pool is fragmented.
 *
 *  Remark: we can use this function to dynamically decide the allocation size 
 *  (for example, use larger image cache when there is more memory)
 *  
 *  However, sometimes we cannot allocate 2 * 10KB blocks if the maximum allocation size 
 *  is 20KB because of the overheads of memory management bookkeeping. 
 *
 *  It is suggested to use "fail-safe" allocation regardless the internal 
 *  implementation of ASM if we want to allocate more memory adaptively according
 *  to the free space
 *  Step 1. Decide the size of free space => e.g. 100KB
 *  Step 2. Allocate 100KB
 *  Step 3. If failed, allocate 95 KB
 *  Step 4. If failed, allocate 90 KB
 *  Step 5. ...
 * PARAMETERS
 *  void
 * RETURNS
 *  memory size
*****************************************************************************/
VMINT vm_global_get_max_alloc_size(void)
{
    return applib_mem_ap_get_max_alloc_size();
}


VMINT vm_get_time(vm_time_t* time) 
{
    applib_time_struct mt;

    if (time == NULL)
    {
        //vm_log_debug("vm_get_time : malloc vm_time_t fail");
        return -1;
    }
    
    memset(time, 0x00, sizeof(vm_time_t));
    
        applib_dt_get_rtc_time(&mt);
        
    time->year = mt.nYear;
    time->mon = mt.nMonth;
    time->day = mt.nDay;
    time->hour = mt.nHour;
    time->min = mt.nMin;
    time->sec = mt.nSec;
    
    return 0;
}
extern kal_uint32 app_getcurrtime(void);
VMINT vm_get_curr_utc(VMUINT * utc)
{
    if (NULL == utc)
    {
        return -2;
    }
    else
    {
        *utc = app_getcurrtime();
        //void applib_dt_get_date_time(applib_time_struct *t);
    }

    return 0;
}

/*****************************************************************************
 * FUNCTION
 *  vm_exit_app_by_asm
 * DESCRIPTION
 *  stop mre app callback of ASM
 * PARAMETERS
 *  p_handle : [IN] process handle to stop
 *****************************************************************************/
static void vm_exit_app_by_asm(VM_P_HANDLE p_handle)
{

    if (!mre_running)
    {
        return;
    }

    vm_pmng_delete_process(p_handle);

}

static MMI_RET vm_app_asm_stop_cb(mmi_event_struct *evt)
{
	U32 id = (U32) evt->user_data;

	applib_mem_ap_notify_stop_finished(APPLIB_MEM_AP_ID_MRE_APP0+id, KAL_TRUE);

	return MMI_RET_OK;
}

static void vm_app_asm_stop_ex(VMINT index)
{
    mmi_event_struct evt;

	if ( MMI_FALSE == mmi_frm_asm_manager_is_launched(NULL) )
		vm_send_msg(0,VM_MSG_FORCE_FREE,0,0);

    vm_exit_app_by_asm(g_app_mem_info[index].p_handle);

	MMI_FRM_INIT_EVENT(&evt, 0);
	MMI_FRM_POST_EVENT(&evt, vm_app_asm_stop_cb, index);
}

static void vm_app_asm_stop_cb0(void)
{
	vm_app_asm_stop_ex(0);
}

static void vm_app_asm_stop_cb1(void)
{
	vm_app_asm_stop_ex(1);
}

static void vm_app_asm_stop_cb2(void)
{
	vm_app_asm_stop_ex(2);
}

static void vm_app_asm_stop_cb3(void)
{
	vm_app_asm_stop_ex(3);
}

static void vm_app_asm_stop_cb4(void)
{
	vm_app_asm_stop_ex(4);
}

static void vm_app_asm_stop_cb5(void)
{
	vm_app_asm_stop_ex(5);
}

static void vm_app_asm_stop_cb6(void)
{
	vm_app_asm_stop_ex(6);
}

static void vm_app_asm_stop_cb7(void)
{
	vm_app_asm_stop_ex(7);
}

static void vm_app_asm_stop_cb8(void)
{
	vm_app_asm_stop_ex(8);
}

static void vm_app_asm_stop_cb9(void)
{
	vm_app_asm_stop_ex(9);
}

static void (*g_app_asm_stop_cb[10])(void) = 
{
    vm_app_asm_stop_cb0,vm_app_asm_stop_cb1,vm_app_asm_stop_cb2,vm_app_asm_stop_cb3,vm_app_asm_stop_cb4,
    vm_app_asm_stop_cb5,vm_app_asm_stop_cb6,vm_app_asm_stop_cb7,vm_app_asm_stop_cb8,vm_app_asm_stop_cb9
};

static void vm_app_asm_success_cb(void)
{
    if (vam_app_callback != NULL)
    {
        vam_app_callback((VMUWSTR)g_mre_app_file_name, MRE_EVT_START_ASM_READY);
    }
}

void vm_start_app_success_cb(void)
{
    if (vam_app_callback != NULL)
    {
        vam_app_callback((VMUWSTR)g_mre_app_file_name, MRE_EVT_START_SUCCESS);
    }
}

static VMINT vm_start_mre_envirment_ex(void)
{
    //kal_uint32 full_pool_size;
    VMCHAR log_filename[50];
    VMCHAR options_filename[50];
    VMINT drv;
    
    MMI_TRACE(MMI_MRE_TRC_G2_SYS, TRC_MRE_SYS_START_ENV, 0, 0, mre_running);
    
    mmi_devconfig_get_system_config(&sysconf);

    //mre_mutex_id = kal_create_mutex("MRE ENGINE");
        
        if ((drv = vm_get_removeable_driver()) < 0)
        {
            drv = (char)vm_get_system_driver();
        }
        sprintf(log_filename, "%c:\\mre.log", drv);
        
        vm_log_init(log_filename, VM_DEBUG_LEVEL);      
        vm_log_info("MRE initialize....");  
        
        
        /* initialize MRE application memory structure. */
        memset(g_app_mem_info, 0, sizeof (vm_app_mem_struct)*MRE_SUPPORT_MAX_APP_NUM);
        
        if (sysconf.memory_provide == MMI_DEVCONFIG_MEMPEY_PROVIDER_ASM)
        {
            VMINT i;
            for (i = 0; i < MRE_SUPPORT_MAX_APP_NUM; i++)
			{
			    g_app_mem_info[i].stop_cb = g_app_asm_stop_cb[i];
			}
    }

    /* initialize MRE core ADM pool */
    if (0 == g_mre_core_adm_id)
        {
            g_mre_core_adm_id = kal_adm_create(
                                        (void*)g_mre_core_mem,
                                        MRE_SYS_ASM_CORE_MEMPOOL_SIZE,
                                        NULL,
                                        KAL_TRUE);
            MMI_TRACE(MMI_MRE_TRC_G2_SYS, TRC_MRE_SYS_START_ENV_ADM_ID, g_mre_core_adm_id);
        }

#ifdef MRE_ENABLE_MEM_DEBUG
        memset(&kernel_mem_stat, 0, sizeof(malloc_stat_t));
#endif
        
        vm_chset_memory_init(); /* reduce static memory */        
        
        
		/* init process manager*/
	if (vm_pmng_init() != 0)
	{   
        MMI_TRACE(MMI_MRE_TRC_G2_SYS, TRC_MRE_SYS_START_ENV_ERR, __LINE__, VM_VLC_INTERNEL_ERROR);
        return VM_VLC_INTERNEL_ERROR;
    }
    
    /* init resource manager*/
        if (vm_res_initialize() != 0)
    {
		vm_pmng_finialize();
        MMI_TRACE(MMI_MRE_TRC_G2_SYS, TRC_MRE_SYS_START_ENV_ERR, __LINE__, VM_VLC_INTERNEL_ERROR);
        return VM_VLC_INTERNEL_ERROR;
    }

        vm_nvram_init();

        /* register module and init it*/
        _vm_initizlize_module_manager();
        _vm_reg_modules();
        if (_vm_notify_modules(EVT_MOD_INIT) != 0)
    {
        vm_exit();
        MMI_TRACE(MMI_MRE_TRC_G2_SYS, TRC_MRE_SYS_START_ENV_ERR, __LINE__, VM_VLC_INTERNEL_ERROR);
        return VM_VLC_INTERNEL_ERROR;
    }

   
        vm_log_info("MRE initialize complete. MRE version is %s.", MRE_SYS_MRESION_NUMBER);
        MMI_TRACE(MMI_MRE_TRC_G2_SYS, TRC_MRE_SYS_START_ENV_VER, MRE_VERSION);

        
#ifdef __MRE_LIB_LOG__
        sprintf(options_filename, "%c:\\mre.cfg", drv);
        mre_options_init(options_filename);
        vm_log_debug("vm_start_mre_envirment:log_out=%d, log_mtk=%d, log_level =%d",mre_get_options_log_out(), mre_get_options_log_mtk(),mre_get_options_log_level());
#endif
        

        MMI_TRACE(MMI_MRE_TRC_G2_SYS, TRC_MRE_SYS_START_ENV_END);
        /* init MRE resource monitor */
        res_monitor_init_ptr = _vm_kernel_malloc(sizeof (vm_res_monitor_init_struct));
		if(NULL == res_monitor_init_ptr)
			return VM_VLC_START_SUCCESS;
        res_monitor_init_ptr->p_handle = 0;
        res_monitor_init_ptr->res_type = VM_RES_TYPE_APP_NAME;
        res_monitor_init_ptr->next_app = NULL;
        vm_create_timer(VM_RES_MONITOR_LOG_INTERVAL, (VM_TIMERPROC_T)_vm_init_resource_monitor_cb);

        mmi_frm_set_protocol_event_handler(MSG_ID_TST_INJECT_STRING, (PsIntFuncPtr)_vm_init_resource_monitor_all, MMI_TRUE);
	
	mmi_frm_cb_reg_event(EVT_ID_ORIENTATION_CHANGED, vm_pmng_deal_orientation_event, NULL);

    return VM_VLC_START_SUCCESS;
}

VMINT vm_start_mre_envirment(vm_mre_evt_cb_t vam_cb, VMINT state)
{   
    kal_uint32 full_pool_size;
    
    vam_callback = vam_cb;

    if (!mre_running)
    {    
            /* init SIM*/
#ifdef __MRE_SAL_SIM__      
        _vm_init_sim_card_status();
#endif   

        if (sysconf.memory_provide != MMI_DEVCONFIG_MEMPEY_PROVIDER_ASM)
        {
		    applib_mem_ap_register(APPLIB_MEM_AP_ID_MRE_CORE, STR_MRE_TITLE, IMAGE_MRE_SMALL_ICON, vm_exit_by_asm);
            /* allocate full ASM pool if use MED memory */
            if ((kernel_mem_base = applib_mem_ap_alloc_full_pool(APPLIB_MEM_AP_ID_MRE_CORE, 
                &full_pool_size)) == NULL)
            {
                mmi_frm_appmem_prompt_to_release_full_pool(
                    APPLIB_MEM_AP_ID_MRE_CORE, 
                    IMAGE_MRE_SMALL_ICON, 
                    vm_asm_alloc_entry);
                vm_log_close();

                MMI_TRACE(MMI_MRE_TRC_G2_SYS, TRC_MRE_SYS_START_ENV_ERR, __LINE__, VM_VLC_ASYN_ALLOC_ASM);
                return VM_VLC_ASYN_ALLOC_ASM;
            }
            /*alloc memory for AM*/
            am_mem_ptr = _vm_kernel_malloc(MMI_AM_MAX_DYN_MEM_SIZE);
        }

        /* init process manager*/
    	if (vm_pmng_init() != 0)
    	{   
            MMI_TRACE(MMI_MRE_TRC_G2_SYS, TRC_MRE_SYS_START_ENV_ERR, __LINE__, VM_VLC_INTERNEL_ERROR);
            return VM_VLC_INTERNEL_ERROR;
        }

         /* set running flag */          
        mre_running = TRUE;
    
        if (state && vam_callback)
        {
            MMI_TRACE(MMI_MRE_TRC_G2_SYS, TRC_MRE_SYS_START_ENV_VAM_CB, vam_callback);
            vam_callback(MRE_EVT_START_SUCCESS);
        }    
    }
    return VM_VLC_START_SUCCESS;    
}

VMINT vm_get_tick_count(void)
{
    kal_uint32 time;

    kal_get_time(&time);
    return kal_ticks_to_milli_secs(time);
}

void vm_stop_mre_envirment(void)
{
    vm_stop_mre_envirment_ex(0);
}

void vm_stop_mre_envirment_ex(VMINT param)
{
    MMI_TRACE(MMI_MRE_TRC_G2_SYS, TRC_MRE_SYS_STOP_ENV, mre_running);
#if ((defined(__PLUTO_MMI_PACKAGE__))&&(!defined(__MMI_FTE_SUPPORT__))&&!defined(__MMI_MRE_MAIN_MENU__)&& !defined(__MMI_MRE_SUB_MENU__)&& !defined(__MMI_MAINMENU_SPREAD_SUPPORT__))   
#else
    vm_pmng_finialize_ex(param);
#endif    

	if (sysconf.memory_provide != MMI_DEVCONFIG_MEMPEY_PROVIDER_ASM)
	{
	    if (am_mem_ptr != NULL)
	    {
			_vm_kernel_free(am_mem_ptr);
			am_mem_ptr = NULL;
	    }
    }
    /* free core ASM */
    if (kernel_mem_base != NULL)
    {
        applib_mem_ap_free(kernel_mem_base);
        kernel_mem_base = NULL;
    }   

     /* set running flag */          
    mre_running = FALSE;
    vam_callback = NULL; 
    MMI_TRACE(MMI_MRE_TRC_G2_SYS, TRC_MRE_SYS_STOP_ENV_END);
}

static VMINT vm_start_app_check(vm_preload_app_info_t *preload_info)
{
    /*  check parameter */
    if ((preload_info->fullFileName == NULL) || preload_info->fullFileName[0] == 0)
    {
        MMI_TRACE(MMI_MRE_TRC_G2_SYS, TRC_MRE_SYS_START_APP_END, __LINE__, VM_PMNG_ERROR_PARAM);
        return VM_PMNG_ERROR_PARAM;
    }
    
    //check resolution
    if( (preload_info->resolution & 0x0000ffff) > LCD_HEIGHT ||
            (preload_info->resolution >> 16) > LCD_WIDTH )
    {
        return VM_PMNG_SEC_TAG_PLATFORM_PARAM_DISMATCH;	
    }
    
#ifndef __VENUS_UI_ENGINE__
    /* get venus flag from vxp file tag. if not support venus engine, return error */
    if (preload_info->is_support_vp)
    {
        MMI_TRACE(MMI_MRE_TRC_G2_SYS, TRC_MRE_SYS_START_APP_END, __LINE__, VM_PMNG_NOT_SUPPORT_VP);
        return VM_PMNG_NOT_SUPPORT_VP;
    }
#endif /* __VENUS_UI_ENGINE__ */

    return 0;
}

static VMINT vm_get_avaliable_mem_index(void)
{
    VMINT mem_idx;
    /* find an available MEM ID */
    for (mem_idx=0; mem_idx<MRE_SUPPORT_MAX_APP_NUM; mem_idx++)
    {
        if (g_app_mem_info[mem_idx].mem_base == NULL)
        {
            break;
        }
    }
    return mem_idx;
}
/*****************************************************************************
 * FUNCTION
 *  vm_start_mre_app
 * DESCRIPTION
 *  start MRE application
 * PARAMETERS
 *  filename : [IN] application file name encoding with USC2 format.
 *  vam_cb : [IN] start mre application asyn, mainly for ASM allocation async currently.
 * RETURNS
 *  start app result.
 *****************************************************************************/
VMINT vm_start_mre_app(VMWSTR fileName, vm_mre_app_evt_cb_t vam_cb)
{
    VMINT ret = 0, error_pos = 0;
    VMINT bufSize = 4, i = 0;
    VMUINT mem_idx = 0, total_mem=0;
    VMSTR temp_buf;
	VMINT namesize = 0;

    VMINT bUCS2 = 0;
    void* asm_mem = NULL;
    vm_preload_app_info_t preload_info;

    MRE_SWLA_START("M31");
    MMI_TRACE(MMI_MRE_TRC_G2_SYS, TRC_MRE_SYS_START_APP, fileName, vam_cb);

    vam_app_callback = vam_cb;
    if (!g_mre_app_file_name)
	{
        g_mre_app_file_name = _vm_kernel_calloc(2*(MAX_APP_NAME_LEN+1));
    }
    if (!g_mre_app_file_name)
    {
        return VM_PMNG_NO_MEM;
    }
    
    vm_init_preload_app_info(&preload_info);
    ret = vm_read_preload_app_info(&preload_info,fileName);
    if (ret)
    {
        error_pos = 1;
        ret = VM_PMNG_ERROR_IO;
        goto error;
    }

    ret = vm_start_app_check(&preload_info);
    if (ret)
    {
        error_pos = 2;
        goto error;
    }

    if (!preload_info.isNoScreen)
    {
        //   entry dumy group
        mmi_frm_group_enter(mmi_frm_group_create(GRP_ID_ROOT, GRP_ID_AUTO_GEN, NULL,NULL),
                                MMI_FRM_NODE_SMART_CLOSE_FLAG);
    }    

    vm_mre_free_pre_app_mem();
    total_mem = preload_info.loadSize+preload_info.heapSize+sizeof(vm_preload_app_info_t);
    if (total_mem > (mmi_res_get_asm_common_pool_size()))
    {
        error_pos = 3;
        ret = VM_PMNG_NO_MEM;
        goto error;
    }

    mem_idx = vm_get_avaliable_mem_index();
    
    if (mem_idx == MRE_SUPPORT_MAX_APP_NUM)
    {
        error_pos = 4;
        ret =  VM_PMNG_MAX_APP_NUM_REACHED;
        goto error;
    }

    preload_info.isMREmem = 1;
    preload_info.mem = &g_app_mem_info[mem_idx];
    // get file name relative
    {
        VMINT temp_buf;
    	VMINT bufSize = sizeof(VMINT);
    	if (vm_get_vm_tag(fileName, VM_CE_INFO_CHARSET, &temp_buf, &bufSize) == GET_TAG_TRUE)
    	{
    		/* IT's a MRE 2.0 or after app*/
    		bUCS2 = 1;
    	}
    }

    memset(g_app_mem_info[mem_idx].p_name,0,MAX_APP_NAME_LEN);
    g_app_mem_info[mem_idx].multiname = FALSE;

#ifndef LOW_COST_SUPPORT
    if (vm_get_vm_tag(fileName, VM_CE_INFO_MULTI_NAME_LIST, NULL, &namesize) == GET_TAG_TRUE)
    {

    	S32 language = 44;
    	CHAR *lang = NULL;
    	char temp[12] = {0};
    	VMINT i = 0, j = 0;

    	lang = (CHAR *)srv_dev_profile_get_value_string(dev_profile_current_language);

    	for(i=0;i<strlen(lang);i++)
    	{
    		if(lang[i]>='0' && lang[i]<='9')
    		{
    			if(lang[i] != '0')
    			{
    				temp[j] = lang[i];
    				j++;
    			}
    		}
    	}

    	if( j > 0 )
    	{
    		language = atoi(temp);
    	}
    	
    	if (vm_get_tag_by_lang_id(fileName, VM_CE_INFO_MULTI_NAME_LIST, NULL, &namesize, language) == GET_TAG_TRUE)
    	{
    		vm_get_tag_by_lang_id(fileName, VM_CE_INFO_MULTI_NAME_LIST, g_app_mem_info[mem_idx].p_name, &namesize, language);
    		g_app_mem_info[mem_idx].multiname = TRUE;
    	}
    	else if (vm_get_tag_by_lang_id(fileName, VM_CE_INFO_MULTI_NAME_LIST, NULL, &namesize, 44) == GET_TAG_TRUE)
    	{
    		vm_get_tag_by_lang_id(fileName, VM_CE_INFO_MULTI_NAME_LIST, g_app_mem_info[mem_idx].p_name, &namesize, 44);
    		g_app_mem_info[mem_idx].multiname = TRUE;
    	}
    }
#endif

    /* get app_name string from vxp file tag */
    temp_buf = _vm_kernel_malloc((MRE_APP_NAME_MAX_LEN+1)<<1);
    if (temp_buf == NULL)
    {
        error_pos = 10;
        ret = VM_PMNG_NO_MEM;
        goto error;
    }
    
    for (i=0; i<3; i++)
    {
        VMINT tmp_size;
        if ((vm_get_tag_by_lang_id(fileName, VM_CE_INFO_NAME_LIST, NULL, &bufSize, i+1) <= 0)
            ||(bufSize > MRE_APP_NAME_MAX_LEN*2))
        {
            if ((vm_get_vm_tag(fileName, VM_CE_INFO_NAME, NULL, &bufSize) <= 0)||(bufSize > MRE_APP_NAME_MAX_LEN*2))
            {
                error_pos = 11;
                ret = VM_PMNG_ERROR_IO;
                goto error;
            }
            else
            {   
                tmp_size = (bufSize + 1) << 1;
                vm_get_vm_tag(fileName, VM_CE_INFO_NAME, temp_buf, &bufSize);
                *(temp_buf+bufSize*2) = 0;
                *(temp_buf+bufSize*2+1) = 0;
                g_app_mem_info[mem_idx].name_buf[i] = _vm_kernel_malloc(tmp_size);
                if (g_app_mem_info[mem_idx].name_buf[i] == NULL)
                {
                    _vm_kernel_free(temp_buf);
                    error_pos = 12;
                    ret = VM_PMNG_NO_MEM;
                    goto error;
                }

                if (!bUCS2)
                {
                    /* get only SC string */
                    mmi_chset_convert(
                            MMI_CHSET_GB2312,
                            MMI_CHSET_UCS2,
                            (S8*) temp_buf,
                            (S8*) g_app_mem_info[mem_idx].name_buf[i],
                            tmp_size);
                }
                else
                {
                    memcpy(g_app_mem_info[mem_idx].name_buf[i],temp_buf,tmp_size);
                }
 
            }
        }
        else
        {
            tmp_size = (bufSize + 1) << 1;
            vm_get_tag_by_lang_id(fileName, VM_CE_INFO_NAME_LIST, temp_buf, &bufSize, i+1);
            *(temp_buf+bufSize*2) = 0;
            *(temp_buf+bufSize*2+1) = 0;
            g_app_mem_info[mem_idx].name_buf[i] = _vm_kernel_malloc(tmp_size);
            if (g_app_mem_info[mem_idx].name_buf[i] == NULL)
            {
                _vm_kernel_free(temp_buf);
                while (i>0)
                {
                    if (g_app_mem_info[mem_idx].name_buf[i-1] != NULL)
                    {
                        _vm_kernel_free(g_app_mem_info[mem_idx].name_buf[i-1]);
                        g_app_mem_info[mem_idx].name_buf[i-1] = NULL;
                    }
                    i--;
                }
                error_pos = 13;
                ret = VM_PMNG_NO_MEM;
                goto error;
            }

            if (!bUCS2)
            {
                if (2 == i)//TC
                {
                    mmi_chset_convert(
                                MMI_CHSET_BIG5,
                                MMI_CHSET_UCS2,
                                (S8*) temp_buf,
                                (S8*) g_app_mem_info[mem_idx].name_buf[i],
                                tmp_size);
                }
                else if (1 == i)//C
                {
                    
                    mmi_chset_convert(
                            MMI_CHSET_GB2312,
                            MMI_CHSET_UCS2,
                            (S8*) temp_buf,
                            (S8*) g_app_mem_info[mem_idx].name_buf[i],
                            tmp_size);
                }
                else //E
                {
                    mmi_chset_convert(
                            MMI_CHSET_ASCII,
                            MMI_CHSET_UCS2,
                            (S8*) temp_buf,
                            (S8*) g_app_mem_info[mem_idx].name_buf[i],
                            tmp_size);
                }
            }
            else
            {
                memcpy(g_app_mem_info[mem_idx].name_buf[i],temp_buf,tmp_size);
            }
        }
        
    }

    _vm_kernel_free(temp_buf);

    vm_app_name_change_string_int(mem_idx);
    
    applib_mem_ap_register((APPLIB_MEM_AP_ID_MRE_APP0+mem_idx), STR_MRE_APP0+mem_idx, IMAGE_MRE_SMALL_ICON, g_app_mem_info[mem_idx].stop_cb);

    /* allocate App memory from ASM pool */
    asm_mem = applib_mem_ap_alloc(APPLIB_MEM_AP_ID_MRE_APP0+mem_idx, total_mem);

    if (asm_mem == NULL)
    {
        kal_wstrcpy(g_mre_app_file_name,fileName);
        mmi_frm_appmem_prompt_to_release_mem(
            APPLIB_MEM_AP_ID_MRE_APP0+mem_idx, 
            IMAGE_MRE_SMALL_ICON, 
            total_mem,
            vm_app_asm_success_cb);
            
        for (i=0; i<3; i++)
        {
            if (g_app_mem_info[mem_idx].name_buf[i] != NULL)
            {
                _vm_kernel_free(g_app_mem_info[mem_idx].name_buf[i]);
                g_app_mem_info[mem_idx].name_buf[i] = NULL;
            }
        }
        error_pos = 20;
        ret = VM_PMNG_WAIT_ASM;
        goto error;
    }
  
    preload_info.loadBufSize = preload_info.loadSize;
    preload_info.heapBufSize = preload_info.heapSize;
    preload_info.loadBase = preload_info.loadBufSize?(void*)((VMINT8*)asm_mem+sizeof(vm_preload_app_info_t)):NULL;
    preload_info.heapBase = preload_info.heapBufSize?(void*)((VMINT8*)asm_mem+sizeof(vm_preload_app_info_t)+preload_info.loadBufSize):NULL;
    memcpy(asm_mem,&preload_info,sizeof(preload_info));

    g_app_mem_info[mem_idx].mem_base = asm_mem;
    ret = vm_preload_app(asm_mem, VM_PRELOAD_RORW);

    if (ret)
    {
        error_pos = 25;
        ret = VM_PMNG_ERROR_IO;
        applib_mem_ap_free((void*)asm_mem);
        goto error;
    }
    ret = vm_start_mre_preload_app((vm_preload_app_info_t*)asm_mem,vam_cb);
    
error:
    MMI_TRACE(MMI_MRE_TRC_G2_SYS, TRC_MRE_SYS_START_APP_END, __LINE__, (ret<<8)+error_pos);
    MRE_SWLA_STOP("M31");
    return ret;
}


/*****************************************************************************
 * FUNCTION
 *  vm_start_mre_preload_app
 * DESCRIPTION
 *  start MRE application
 * PARAMETERS
 *  filename : [IN] application file name encoding with USC2 format.
 *  vam_cb : [IN] start mre application asyn, mainly for ASM allocation async currently.
 * RETURNS
 *  start app result.
 *****************************************************************************/
VMINT vm_start_mre_preload_app(vm_preload_app_info_t *preload_info, vm_mre_app_evt_cb_t vam_cb)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    VMWSTR fileName = preload_info->fullFileName;
    VMINT i = 0, ret = 0;
    VMUINT memSize = 0, mem_idx = 0;

    vm_app_mem_struct* app_mem;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    MMI_TRACE(MMI_MRE_TRC_G2_SYS, TRC_MRE_SYS_START_APP, fileName, vam_cb);

    vam_app_callback = vam_cb;
    if (!g_mre_app_file_name)
	{
        g_mre_app_file_name = _vm_kernel_calloc(2*(MAX_APP_NAME_LEN+1));
    }
    if (!g_mre_app_file_name)
    {
        return VM_PMNG_NO_MEM;
    }
    kal_wstrcpy(g_mre_app_file_name,fileName);

    ret = vm_start_app_check(preload_info);
    if (ret)
    {
        return ret;
    }

    if (!preload_info->isMREmem)
    {
        mem_idx = vm_get_avaliable_mem_index();
        if (mem_idx == MRE_SUPPORT_MAX_APP_NUM)
        {
            MMI_TRACE(MMI_MRE_TRC_G2_SYS, TRC_MRE_SYS_ERR_NO_MEM, __LINE__, memSize);
            return VM_PMNG_MAX_APP_NUM_REACHED;
        }
        preload_info->mem = &g_app_mem_info[mem_idx];
        g_app_mem_info[mem_idx].user_mem = KAL_TRUE;
        preload_info->mem->mem_base = preload_info->loadBase?preload_info->loadBase:preload_info->heapBase;
    }
    
    app_mem = preload_info->mem;
    app_mem->p_handle = -1;    
    app_mem->mem_size = preload_info->loadBufSize + preload_info->heapBufSize;
    app_mem->heap_size = preload_info->heapBufSize;
       
    
    /* create process */
    ret = vm_pmng_create_process_from_preload_info(preload_info, preload_info->mem);
    if (ret >= 0)
    {
        app_mem->p_handle = ret;
        /* init resource monitor log */
        if (res_monitor_init_ptr == NULL)
        {
            res_monitor_init_ptr = _vm_kernel_malloc(sizeof (vm_res_monitor_init_struct));
            res_monitor_init_ptr->p_handle = app_mem->p_handle;
            res_monitor_init_ptr->res_type = VM_RES_TYPE_APP_NAME;
            res_monitor_init_ptr->next_app = NULL;
            vm_create_timer(VM_RES_MONITOR_LOG_INTERVAL, (VM_TIMERPROC_T)_vm_init_resource_monitor_cb);
        }
        else
        {
            vm_res_monitor_init_struct* temp_ptr;
            vm_res_monitor_init_struct* tail_ptr;
            temp_ptr = _vm_kernel_malloc(sizeof (vm_res_monitor_init_struct));
            temp_ptr->p_handle = app_mem->p_handle;
            temp_ptr->res_type = VM_RES_TYPE_APP_NAME;
            temp_ptr->next_app = NULL;
            /* find out the tail app node */
            tail_ptr = res_monitor_init_ptr;
            while (tail_ptr->next_app != NULL)
            {
                tail_ptr = tail_ptr->next_app;
            }
            tail_ptr->next_app = temp_ptr;
        }
    }
    else
    {
        /* free memory */
        if (preload_info->isMREmem && app_mem->mem_base != NULL)
        {
            applib_mem_ap_free((void*)app_mem->mem_base);
            for (i=0; i<3; i++)
            {
                if (app_mem->name_buf[i] != NULL)
                {
                    _vm_kernel_free(app_mem->name_buf[i]);
                    app_mem->name_buf[i] = NULL;
                }
            }
        }
        
        app_mem->p_handle = -1;
        app_mem->mem_base = NULL;
        app_mem->mem_size = 0;
        app_mem->heap_size = 0;
        app_mem->adm_id = NULL;
        app_mem->user_mem = KAL_FALSE;
    }

    MMI_TRACE(MMI_MRE_TRC_G2_SYS, TRC_MRE_SYS_START_APP_END, __LINE__, ret);
    return ret;
}

static void vm_asm_alloc_entry(void)
{
    vm_start_mre_envirment(vam_callback, 1);
}

static void sys_pen_down_proc(mmi_pen_point_struct pos)
{
    vm_pmng_deal_pen_event(VM_PEN_EVENT_TAP, pos.x, pos.y);
}

static void sys_pen_up_proc(mmi_pen_point_struct pos)
{
    vm_pmng_deal_pen_event(VM_PEN_EVENT_RELEASE, pos.x, pos.y);
}

static void sys_pen_move_proc(mmi_pen_point_struct pos)
{
    vm_pmng_deal_pen_event(VM_PEN_EVENT_MOVE, pos.x, pos.y);
}

static void sys_pen_long_tap_proc(mmi_pen_point_struct pos)
{
    vm_pmng_deal_pen_event(VM_PEN_EVENT_LONG_TAP, pos.x, pos.y);
}

static void sys_pen_double_click_proc(mmi_pen_point_struct pos)
{
    vm_pmng_deal_pen_event(VM_PEN_EVENT_DOUBLE_CLICK, pos.x, pos.y);
}

static void sys_pen_repeat_proc(mmi_pen_point_struct pos)
{
    vm_pmng_deal_pen_event(VM_PEN_EVENT_REPEAT, pos.x, pos.y);
}

static void sys_pen_abort_proc(mmi_pen_point_struct pos)
{
    vm_pmng_deal_pen_event(VM_PEN_EVENT_ABORT, pos.x, pos.y);
}

void vm_reg_pen_handler(void) 
{
    mmi_pen_register_down_handler(sys_pen_down_proc);
    mmi_pen_register_up_handler(sys_pen_up_proc);
    mmi_pen_register_move_handler(sys_pen_move_proc);
    mmi_pen_register_long_tap_handler(sys_pen_long_tap_proc);
    mmi_pen_register_double_click_handler(sys_pen_double_click_proc);
    mmi_pen_register_repeat_handler(sys_pen_repeat_proc);
    mmi_pen_register_abort_handler(sys_pen_abort_proc);
}

static VMINT vm_query_userid(void)
{
#ifdef __MRE_CORE_SAFETY__
    vm_nvram_sysconf_t sys_conf;

    if (vm_get_sysconf(&sys_conf))
        return sys_conf.uid;
    else
#endif
        return -1;

}

VMINT mmi_mre_pre_format_hdlr(VMINT8 drv)
{
    return (!mre_running);
}

VMUINT vm_get_sys_property(const VMINT key, VMCHAR* value, VMUINT len)
{
    VMCHAR s[64] = {0};
    VMUINT length = 0;
    VMINT tmp = -1;
    VMWCHAR home_dir[31] = {0};
    
    if (value && len > 0)
    {
        switch(key)
        {
        case MRE_SYS_SUBSCRIBER_ID: 
            if ((tmp = vm_query_userid()) < 0)
                break;
            
            sprintf(s, "%d", tmp);
            length = strlen(s);
            if (length >= len)
                length = len - 1;
            strncpy(value, s, length);
            value[length] = '\0';
            break;
#ifdef __MRE_CORE_SAFETY__
        case MRE_SYS_EQUIPMENT_ID:
            length = vm_get_useragent(value, len);
            break;
#endif
        case MRE_SYS_VERSION:
            length = strlen(MRE_SYS_MRESION_NUMBER);
            if (length >= len)
                length = len - 1;
            strncpy(value, MRE_SYS_MRESION_NUMBER, length);
            value[length] = '\0';
            break;

        case MRE_SYS_HOST_VERSION:
            length = vm_get_host_version(value, len);
            break;

        case MRE_SYS_HOME_DIR:
            if ((tmp = vm_get_removable_driver()) < 0)
                tmp = vm_get_system_driver();
            sprintf(s, "%c:\\MRE", (char)tmp);
            vm_ascii_to_ucs2(home_dir, sizeof(home_dir), s);
            vm_file_mkdir(home_dir);
            
            length = strlen(s);
            if (length >= len)
                length = len - 1;
            strncpy(value, s, length);
            value[length] = '\0';
            break;
        case MRE_SYS_HOST_MAX_MEM:
            sprintf(s, "%d", ((sysconf.memory_size) >> 10));
            
            length = strlen(s);
            if (length >= len)
                length = len - 1;
            strncpy(value, s, length);
            value[length] = '\0';
            break;
		case MRE_SYS_BUILD_DATE_TIME:
            length = vm_get_build_date_time(value, len);
			break;
        case MRE_SYS_RELEASE_BRANCH:
            length = vm_get_release_branch(value, len);
			break;
        }
    }

    return length;
}

extern FLOAT GetTimeZone(U8 cityIndex);
extern U8 PhnsetGetHomeCity(void);
float vm_get_sys_time_zone(void)
{
    return GetTimeZone(PhnsetGetHomeCity());
}

VMINT vm_get_sys_scene(void)
{
    srv_prof_external_profile_enum profile;
    
    for(profile = SRV_PROF_MEETING_MODE; profile < SRV_PROF_MODE_END_OF_ENUM; profile++)
    {
        if (srv_prof_is_profile_activated(profile) > 0)
        {
            return (VMINT)profile+1;
        }
    }   
    return VM_PROF_NORMAL_MODE;
}

VMINT vm_get_battery_level(void) 
{
    return stub_vm_get_battery_level();
}


void vm_set_mainlcd_brightness(vm_mainlcd_brightness_level_enum brightness_level)
{
#ifndef __COSMOS_MMI_PACKAGE__
	/* if not define COSMOS we only support 0~5 level  */
	if(brightness_level>=VM_MAINLCD_BRIGHTNESS_LEVEL0&& brightness_level<=VM_MAINLCD_BRIGHTNESS_LEVEL5)
	{
		srv_gpio_set_device_level(SRV_GPIO_DEV_MAINLCD,(srv_gpio_dev_level_enum)brightness_level);
	}
#else
	/* if define COSMOS we support 0~20 level */
	if(brightness_level>=VM_MAINLCD_BRIGHTNESS_LEVEL0 && brightness_level<=VM_MAINLCD_BRIGHTNESS_LEVEL20)
	{
		srv_gpio_set_device_level(SRV_GPIO_DEV_MAINLCD,(srv_gpio_dev_level_enum)brightness_level);
	}	
#endif
}	

VMINT vm_get_mainlcd_brightness()
{ 
	return srv_backlight_get_level(SRV_BACKLIGHT_TYPE_MAINLCD);
}	

void vm_set_touch_feedback ( vm_touch_feedback_enum type)
{
    vm_log_debug("vm_set_touch_feedback =%d", type);
    
    gui_touch_feedback_play(type);
}
/*****************************************************************************
 * FUNCTION
 *  vm_app_name_change_string
 * DESCRIPTION
 *  set app name string for ASM once language changes
 *****************************************************************************/
void vm_app_name_change_string(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    VMUINT i, lang_id;
    U8 *lang_str = NULL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mre_running)
    {
    
        lang_str = Get_Current_Lang_CountryCode();
        if (strcmp((PS8) lang_str, "en-US") == 0)   /* means english */
        {
            lang_id = VM_LANG_ENG;
        }
        else if (strcmp((PS8) lang_str, "zh-CN") == 0)
        {
            lang_id = VM_LANG_CHS;
        }
        else if (strcmp((PS8) lang_str, "zh-TW") == 0)
        {
            lang_id = VM_LANG_CHT;
        }
        else
        {
            /* default is English*/
            lang_id = VM_LANG_ENG;
        }
        for (i=0; i<MRE_SUPPORT_MAX_APP_NUM; i++)
        {
            if (g_app_mem_info[i].mem_base != 0)
            {
                mmi_res_dynamic_str_remove(STR_MRE_APP0+i);
				
				if(g_app_mem_info[i].multiname == TRUE)
                {
					mmi_res_dynamic_str_add(STR_MRE_APP0+i, g_app_mem_info[i].p_name);
				}
				else
				{
					mmi_res_dynamic_str_add(STR_MRE_APP0+i, g_app_mem_info[i].name_buf[lang_id-1]);
				}
            }
        }
    }
    
}
/*****************************************************************************
 * FUNCTION
 *  vm_app_name_change_string
 * DESCRIPTION
 *  set app name string for ASM once language changes
 *****************************************************************************/
static void vm_app_name_change_string_int(VMINT index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    VMUINT lang_id;
    U8 *lang_str = NULL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    lang_str = Get_Current_Lang_CountryCode();
    if (strcmp((PS8) lang_str, "en-US") == 0)   /* means english */
    {
        lang_id = VM_LANG_ENG;
    }
    else if (strcmp((PS8) lang_str, "zh-CN") == 0)
    {
        lang_id = VM_LANG_CHS;
    }
    else if (strcmp((PS8) lang_str, "zh-TW") == 0)
    {
        lang_id = VM_LANG_CHT;
    }
    else
    {
        /* default is English*/
        lang_id = VM_LANG_ENG;
    }

    mmi_res_dynamic_str_remove(STR_MRE_APP0+index);
	
	if(g_app_mem_info[index].multiname == TRUE)
	{
		mmi_res_dynamic_str_add(STR_MRE_APP0+index, g_app_mem_info[index].p_name);    
	}
	else
	{
		mmi_res_dynamic_str_add(STR_MRE_APP0+index, g_app_mem_info[index].name_buf[lang_id-1]);    
	}
}

/*****************************************************************************
 * FUNCTION
 *  vm_app_name_change_string
 * DESCRIPTION
 *  set app name string for ASM once language changes
 *****************************************************************************/
void vm_free_mre_app_mem(_vm_pcb_t* tmp)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    VMINT mem_idx=0, i=0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (mem_idx=0; mem_idx<MRE_SUPPORT_MAX_APP_NUM; mem_idx++)
    {
        if (g_app_mem_info[mem_idx].p_handle == tmp->pHandle)
        {
            break;
        }
    }
    
    if (mem_idx >= MRE_SUPPORT_MAX_APP_NUM)
    {
        return;
    }
    
    if (g_app_mem_info[mem_idx].adm_id != 0)
    {
        kal_adm_delete(g_app_mem_info[mem_idx].adm_id);
        g_app_mem_info[mem_idx].adm_id = 0;
    }

    if (g_app_mem_info[mem_idx].user_mem == 0)
    {
#ifdef __MRE_MEDIA_BUF__ /* PHASE OUT! */
        if (sysconf.memory_provide == MMI_DEVCONFIG_MEMPEY_PROVIDER_MEDIA)
        {
            media_free_ext_buffer(MOD_MMI, (void**)&g_app_mem_info[mem_idx].mem_base);
            g_app_mem_info[mem_idx].mem_base = NULL;
            g_app_mem_info[mem_idx].mem_size = 0;
            g_app_mem_info[mem_idx].p_handle = 0;
            
        }
        else
#endif
        {
            applib_mem_ap_free((void*)g_app_mem_info[mem_idx].mem_base);
            
            for (i=0; i<3; i++)
            {
                if (g_app_mem_info[mem_idx].name_buf[i] != NULL)
                {
                    _vm_kernel_free(g_app_mem_info[mem_idx].name_buf[i]);
                    g_app_mem_info[mem_idx].name_buf[i] = NULL;
                }
            }
            //remove tmp str!!!
            mmi_res_dynamic_str_remove(STR_MRE_APP0+mem_idx);
            
            /* if last app exit, clear ASM hide flag for MRE core */
            for (i=0; i<MRE_SUPPORT_MAX_APP_NUM; i++)
            {
                if (g_app_mem_info[i].mem_base != NULL)
                {
                    break;
                }
            }
            /*if (i == MRE_SUPPORT_MAX_APP_NUM)
            {
                mmi_frm_appmem_clear_hide_list_screen();
            }*/
    
        }
        
        vm_app_name_info(
            tmp->pHandle, 
            VM_RES_TYPE_APP_NAME, 
            L"");
    }
    g_app_mem_info[mem_idx].user_mem = KAL_FALSE;
    
    g_app_mem_info[mem_idx].mem_base = NULL;
    g_app_mem_info[mem_idx].mem_size = 0;
    g_app_mem_info[mem_idx].p_handle = -1;
    g_app_mem_info[mem_idx].heap_size = 0;
}

/*****************************************************************************
 * FUNCTION
 *  vm_alloc_memory
 * DESCRIPTION
 *  load so file
 * PARAMETERS
 *  
 * RETURNS
 *  
 *****************************************************************************/
VMINT vm_alloc_memory(VMUINT memSize)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    #ifdef __MRE_MEDIA_BUF__
    VMINT i = 0;
    VMUINT total_mem=0
    #endif
    VMUINT mem_idx = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MRE_MEDIA_BUF__ /* PHASE OUT! */
    if (sysconf.memory_provide == MMI_DEVCONFIG_MEMPEY_PROVIDER_MEDIA)
    {
        /* if memsize > total annouced, return no memory directly*/
        for (i=0; i<MRE_SUPPORT_MAX_APP_NUM; i++)
        {
            total_mem += g_app_mem_info[i].mem_size;
        }

        for (i=0; i<MRE_SUPPORT_MAX_VSM_NUM; i++)
        {
            total_mem += g_vsm_mem_info[i].mem_size;
        }
		
        if ((total_mem + memSize) > sysconf.memory_size)
        {
            MMI_TRACE(MMI_MRE_TRC_G2_SYS, TRC_MRE_SYS_ERR_NO_MEM, __LINE__, sysconf.memory_size);
            return VM_PMNG_NO_MEM;
        }
            
        /* find an available MED ID */
        for (mem_idx=0; mem_idx<MRE_SUPPORT_MAX_VSM_NUM; mem_idx++)
        {
            if (g_vsm_mem_info[mem_idx].mem_base == NULL)
            {
                break;
            }
        }
		
        if (mem_idx == MRE_SUPPORT_MAX_VSM_NUM)
        {
            MMI_TRACE(MMI_MRE_TRC_G2_SYS, TRC_MRE_SYS_ERR_NO_MEM, __LINE__, 0);
            return VM_PMNG_NO_MEM;
        }
    
        /* allocate MED memory */
        if ((media_get_ext_buffer_cacheable(MOD_MMI, (void**)&g_vsm_mem_info[mem_idx].mem_base, memSize) != MED_RES_OK)
                || (g_vsm_mem_info[mem_idx].mem_base == 0))
        {
            MMI_TRACE(MMI_MRE_TRC_G2_SYS, TRC_MRE_SYS_ERR_NO_MEM, __LINE__, memSize);
            return VM_PMNG_NO_MEM;
        }
        g_vsm_mem_info[mem_idx].mem_size = memSize ;
    }
    else /* if use ASM memory */
#endif
    {
        /* if memsize > total ASM-core, return no memory directly*/
        if (memSize > (mmi_res_get_asm_common_pool_size()))
        {
            MMI_TRACE(MMI_MRE_TRC_G2_SYS, TRC_MRE_SYS_ERR_NO_MEM, __LINE__, memSize);
            return VM_PMNG_NO_MEM;
        }
		
        /* find an available ASM ID */
        for (mem_idx=0; mem_idx<MRE_SUPPORT_MAX_VSM_NUM; mem_idx++)
        {
            if (g_vsm_mem_info[mem_idx].mem_base == NULL)
            {
                break;
            }
        }
		
        if (mem_idx == MRE_SUPPORT_MAX_VSM_NUM)
        {
            MMI_TRACE(MMI_MRE_TRC_G2_SYS, TRC_MRE_SYS_ERR_NO_MEM, __LINE__, 0);
            return VM_PMNG_NO_MEM;
        }
    
        /* allocate App memory from ASM pool */
        g_vsm_mem_info[mem_idx].mem_base = applib_mem_ap_alloc(APPLIB_MEM_AP_ID_MRE_SM0+mem_idx, memSize);
    
        if (g_vsm_mem_info[mem_idx].mem_base == NULL)
        {
			return VM_PMNG_NO_MEM;
        }
        else
        {            
            g_vsm_mem_info[mem_idx].mem_size = memSize;
        }       
           
		applib_mem_ap_set_hide(APPLIB_MEM_AP_ID_MRE_SM0+mem_idx,KAL_TRUE);
    }
    
    return mem_idx;
    
}


void vm_free_memory(VMINT handle)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    VMINT mem_idx;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (mem_idx=0; mem_idx<MRE_SUPPORT_MAX_VSM_NUM; mem_idx++)
    {
        if (g_vsm_mem_info[mem_idx].p_handle == handle)
        {
            break;
        }
    }
    
    if (mem_idx < MRE_SUPPORT_MAX_VSM_NUM)
    {
        if (g_vsm_mem_info[mem_idx].adm_id != 0)
        {
            kal_adm_delete(g_vsm_mem_info[mem_idx].adm_id);
            g_vsm_mem_info[mem_idx].adm_id = 0;
        }

#ifdef __MRE_MEDIA_BUF__ /* PHASE OUT! */
        if (sysconf.memory_provide == MMI_DEVCONFIG_MEMPEY_PROVIDER_MEDIA)
        {
            media_free_ext_buffer(MOD_MMI, (void**)&g_vsm_mem_info[mem_idx].mem_base);
            
        }
        else
#endif
        {
            applib_mem_ap_free((void*)g_vsm_mem_info[mem_idx].mem_base);
        }
		g_vsm_mem_info[mem_idx].mem_base = NULL;
		g_vsm_mem_info[mem_idx].mem_size = 0;

#ifdef MRE_ENABLE_MEM_DEBUG
		vm_app_name_info(g_vsm_mem_info[mem_idx].p_handle, VM_RES_TYPE_APP_NAME, L"");
#endif
	g_vsm_mem_info[mem_idx].p_handle = -1;

    }
}


/*****************************************************************************
 * FUNCTION
 *  _vm_init_resource_monitor_cb
 * DESCRIPTION
 *  timer proc for initializing resource manager for print resource
 * PARAMETERS
 *  tid : [IN] timer ID, 
 *****************************************************************************/
void _vm_init_resource_monitor_cb(VMINT tid)
{    
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    VMINT res_type = 0;
    VMINT app_type = 0;
    VMUINT app_id=0;
    VM_P_HANDLE p_handle;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!mre_running)
    {
        return;
    }
    
    /* if process has been deleted, return */
    if (res_monitor_init_ptr == NULL)
    {
        vm_delete_timer(tid);
        return;
    }
    
    p_handle = res_monitor_init_ptr->p_handle;
    res_type = res_monitor_init_ptr->res_type;

    
    if (p_handle != 0)
    {
        /* find an memory pool ID of specified process */
        for (app_id=0; app_id<MRE_SUPPORT_MAX_APP_NUM; app_id++)
        {
            if (g_app_mem_info[app_id].p_handle == p_handle)
            {
            	app_type = 1;
                break;
            }
        }
        
        /* if process has deleted, delete the app node from resource monitor init linked list */
        if (app_id == MRE_SUPPORT_MAX_APP_NUM)
        {
        	for (app_id=0; app_id<MRE_SUPPORT_MAX_VSM_NUM; app_id++)
			{
				if (g_vsm_mem_info[app_id].p_handle == p_handle)
				{
					app_type = 2;
					break;
				}
			}
			
			if (app_id == MRE_SUPPORT_MAX_VSM_NUM)
			{
            /* send clean up command to resource monitor */
            vm_app_name_info(
                res_monitor_init_ptr->p_handle, 
                VM_RES_TYPE_APP_NAME, 
                L"");
            
            if (res_monitor_init_ptr->next_app != NULL)
            {
                vm_res_monitor_init_struct* temp_ptr;
                temp_ptr = res_monitor_init_ptr;
                res_monitor_init_ptr = res_monitor_init_ptr->next_app;
                _vm_kernel_free(temp_ptr);
            }
            else
            {
                _vm_kernel_free(res_monitor_init_ptr);
                res_monitor_init_ptr = NULL;
                vm_delete_timer(tid);
            }

            return;
        }
			
    }
    }
	
    if (res_type == VM_RES_TYPE_APP_NAME)
    {
        
        /* print app name info firstly */
        if (p_handle == 0)
        {
            vm_app_name_info(
                VM_RES_APP_ID_TOTAL, 
                VM_RES_TYPE_APP_NAME, 
                L"MRE total");
            
        }
        else if(app_type == 1)
        {
            if (g_app_mem_info[app_id].name_buf[0] == NULL)
            {
                S8 temp_str[8];
                S8 temp_wstr[16];
                
                sprintf(temp_str, "App %d", app_id);
                mmi_asc_n_to_ucs2(temp_wstr,temp_str,8);
                vm_app_name_info(
                    res_monitor_init_ptr->p_handle, 
                    VM_RES_TYPE_APP_NAME, 
                    (VMSHORT*)temp_wstr);
                
            }
            else
            {
                vm_app_name_info(
                    res_monitor_init_ptr->p_handle, 
                    VM_RES_TYPE_APP_NAME, 
                    g_app_mem_info[app_id].name_buf[0]);
            }
        }
		else if(app_type == 2)
		{
            S8 temp_str[8];
            S8 temp_wstr[16];
            
            sprintf(temp_str, "Sm %d", app_id);
            mmi_asc_n_to_ucs2(temp_wstr,temp_str,8);
            vm_app_name_info(
                res_monitor_init_ptr->p_handle, 
                VM_RES_TYPE_APP_NAME, 
                (VMSHORT*)temp_wstr);
		}

        res_monitor_init_ptr->res_type = VM_RES_TYPE_MEMORY;
    }
    else if (res_type == VM_RES_TYPE_MEMORY)
    {
        /* print memory info secondly */
        if (p_handle == 0)
        {
            vm_app_res_info(
                VM_RES_APP_ID_TOTAL, 
                VM_RES_TYPE_MEMORY, 
                VM_RES_VALUE_NOT_AVAILABLE, 
                VM_RES_VALUE_NOT_AVAILABLE, 
                VM_RES_VALUE_NOT_AVAILABLE);
        }
        else
        {
#ifdef MRE_ENABLE_MEM_DEBUG
			if(app_type == 1)
            {
            	vm_app_res_info(
	                p_handle, 
	                VM_RES_TYPE_MEMORY,
	                g_app_mem_info[app_id].heap_size, 
	                g_app_mem_info[app_id].mem_stat.current,
	                g_app_mem_info[app_id].mem_stat.peak);
			}
			else if(app_type == 2)
			{
            	vm_app_res_info(
	                p_handle, 
	                VM_RES_TYPE_MEMORY,
	                g_vsm_mem_info[app_id].heap_size, 
	                g_vsm_mem_info[app_id].mem_stat.current,
	                g_vsm_mem_info[app_id].mem_stat.peak);
			}
#else
            vm_app_res_info(
                p_handle, 
                VM_RES_TYPE_MEMORY, 
                VM_RES_VALUE_NOT_AVAILABLE, 
                VM_RES_VALUE_NOT_AVAILABLE, 
                VM_RES_VALUE_NOT_AVAILABLE);
#endif
        }

        res_monitor_init_ptr->res_type = 0;
    }
    else
    {
        /* normal resource type */
        vm_res_print_monitor_log(p_handle, res_monitor_init_ptr->res_type);
        res_monitor_init_ptr->res_type ++;

        /* if finish resource log */
        if (res_monitor_init_ptr->res_type == VM_RES_TYPE_TOTAL)
        {
            if (res_monitor_init_ptr->next_app != NULL)
            {
                /* if there is app not printed out for resource monitor, continue with next app */
                vm_res_monitor_init_struct* temp_ptr;
                temp_ptr = res_monitor_init_ptr;
                res_monitor_init_ptr = res_monitor_init_ptr->next_app;
                _vm_kernel_free(temp_ptr);
            }
            else
            {
                _vm_kernel_free(res_monitor_init_ptr);
                res_monitor_init_ptr = NULL;
                vm_delete_timer(tid);
            }
        }
    }


}

/*****************************************************************************
 * FUNCTION
 *  _vm_init_resource_monitor_next
 * DESCRIPTION
 *  timer proc for initializing resource manager for print resource
 * PARAMETERS
 *  tid : [IN] timer ID, 
 *****************************************************************************/
static U8 _vm_init_resource_monitor_all(void * in)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    VMUINT app_id;
    tst_inject_string_struct *inject_str = (tst_inject_string_struct *)in;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
   
    if (strncmp((const kal_char*)inject_str->string, "MREINIT", 7))
    {
        return 0;
    }
    else
    {
		if (!mre_running)
        {
            return 1;
        }
        
        if (res_monitor_init_ptr == NULL)
        {
            vm_create_timer(VM_RES_MONITOR_LOG_INTERVAL, (VM_TIMERPROC_T)_vm_init_resource_monitor_cb);
        
        }
        
        while (res_monitor_init_ptr != NULL)
        {
            if (res_monitor_init_ptr->next_app != NULL)
            {
                /* if there is app not printed out for resource monitor, continue with next app */
                vm_res_monitor_init_struct* temp_ptr;
                temp_ptr = res_monitor_init_ptr;
                res_monitor_init_ptr = res_monitor_init_ptr->next_app;
                _vm_kernel_free(temp_ptr);
            }
            else
            {
                _vm_kernel_free(res_monitor_init_ptr);
                res_monitor_init_ptr = NULL;
            }
        }
        
        res_monitor_init_ptr = _vm_kernel_malloc(sizeof (vm_res_monitor_init_struct));
        res_monitor_init_ptr->p_handle = 0;
        res_monitor_init_ptr->res_type = VM_RES_TYPE_APP_NAME;
        res_monitor_init_ptr->next_app = NULL;
        
        for (app_id=0; app_id<MRE_SUPPORT_MAX_APP_NUM; app_id++)
        {
            /* if an app running, add a node to resource monitor init linked list */
            if (g_app_mem_info[app_id].mem_size != 0)
            {
                vm_res_monitor_init_struct* temp_ptr;
                vm_res_monitor_init_struct* tail_ptr;
                temp_ptr = _vm_kernel_malloc(sizeof (vm_res_monitor_init_struct));
                temp_ptr->p_handle = g_app_mem_info[app_id].p_handle;
                temp_ptr->res_type = VM_RES_TYPE_APP_NAME;
                temp_ptr->next_app = NULL;
                /* find out the tail app node */
                tail_ptr = res_monitor_init_ptr;
                while (tail_ptr->next_app != NULL)
                {
                    tail_ptr = tail_ptr->next_app;
                }
                tail_ptr->next_app = temp_ptr;
                
            }
        }
        
        
        return 1;
    }

    
}

extern BOOL mmiapi_is_MMI_task(void);


VMINT vm_get_running_app_sb(void)
{ 
	BOOL isMMI = TRUE;
	isMMI = mmiapi_is_MMI_task() ? TRUE : FALSE;

	if(isMMI)
	{
		return g_vm_stub_sb;
	}
	else
	{
		return g_vm_stub_sb_vrt;
	}
}



VMINT vm_get_mre_modules(vm_module_struct *modules, VMUINT size)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    VMUINT minsize;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    if (!modules)
    {
        return -1;
    }
    memset(modules, 0, size);
    minsize = size > sizeof (vm_module_struct)? sizeof (vm_module_struct):size;
    memcpy((void*)modules,(void*)&g_mre_modules,minsize);
    return 0;
}

VMUINT vm_get_mre_version(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return MRE_VERSION;
}

VMUINT vm_get_mre_total_mem_size(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    VMUINT mem_size = 0;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MRE_MEDIA_BUF__ /* PHASE OUT! */
    if (sysconf.memory_provide == MMI_DEVCONFIG_MEMPEY_PROVIDER_MEDIA)
	{
		mem_size = MED_EXT_MEM_SIZE;
	}
	else
#endif
	{
		mem_size = mmi_res_get_asm_common_pool_size();
	}
	return mem_size;
}

//system infor

VMINT vm_get_system_info(VMCHAR info[], VMUINT* size)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	VMWCHAR tmpbuf[1024] = {0};
	VMUINT mem_size = 0;
	VMINT info_length, i;
    static const VMCHAR*  const modules[]= 
    {
    "base",
#ifdef __MRE_CORE_SANDBOX__
    "sand",
#endif
            
#ifdef __MRE_CORE_RESOURCE_MANAGE__
    "resmgr",
#endif
            
#ifdef __MRE_CORE_SAFETY__
    "safe",
#endif
        
#ifdef __MRE_CORE_APP_COMMUNICATION__
    "comm",
#endif
        
#ifdef __MRE_CORE_SM__
    "sm",
#endif
            
#ifdef __MRE_CORE_SO__
    "so",
#endif
        
#ifdef __MRE_LIB_APPRES__
    "res",
#endif
        
#ifdef __MRE_LIB_C__
    "c",
#endif
        
#ifdef __MRE_LIB_CHSET__
    "ch",
#endif
        
#ifdef __MRE_LIB_GRAPIC_DDRAW__
    "draw",
#endif
        
#ifdef __MRE_LIB_GRAPIC_GFXOLD__
    "gfxold",
#endif
        
#ifdef __MRE_LIB_GRAPIC_IMAGE__
    "image",
#endif
        
#ifdef __MRE_LIB_HTTP__
    "http",
#endif
        
#ifdef __MRE_LIB_IME__
    "ime",
#endif
        
#ifdef __MRE_LIB_INI__
    "ini",
#endif
        
#ifdef __MRE_LIB_LOG__
    "log",
#endif    
        
#ifdef __MRE_LIB_MULTI_LANG__
    "mul",
#endif   
        
#ifdef __MRE_LIB_NETWORK__
    "net",
#endif       
            
#ifdef __MRE_LIB_NETWORK_VIP__
    "vip",
#endif 
        
#ifdef __MRE_LIB_NETWORK_VIP_VG__
    "vg",
#endif     
            
#ifdef __MRE_LIB_XML__
    "xml",
#endif      
        
#ifdef __MRE_SAL_AUDIO__
    "aud",
#endif
        
#ifdef __MRE_SAL_BITSTREAM__
    "stream",
#endif
        
#ifdef __MRE_SAL_CAMERA__
    "camera",
#endif
        
#ifdef __MRE_SAL_CELL__
    "cell",
#endif
        
#ifdef __MRE_SAL_CHE_DES__
    "des",
#endif
        
#ifdef __MRE_SAL_CHE_MD5__
    "md5",
#endif
        
#ifdef __MRE_SAL_CHE_SHA1__
    "sha1",
#endif
            
#ifdef __MRE_SAL_GPS__
    "gps",
#endif
        
#ifdef __MRE_SAL_MMS__
    "mms",
#endif 
#ifdef __MRE_SAL_PHONEBOOK__
    "pb",
#endif
        
#ifdef __MRE_SAL_SENSOR__
    "sensor",
#endif
        
#ifdef __MRE_SAL_SIM__
    "sim",
#endif
        
#ifdef __MRE_SAL_SMS__
    "sms",
#endif
        
#ifdef __MRE_SAL_SOCKET__
    "soc",
#endif
        
#ifdef __MRE_SAL_STATUS__
    "status",
#endif
        
#ifdef __MRE_SAL_TELE__
    "tel",
#endif
        
#ifdef CFG_MRE_SAL_TIMER
    "timer",
#endif
        
#ifdef __MRE_SAL_VIDEO__
    "video",
#endif
        
#ifdef __MRE_SAL_WPS__
    "wps",
#endif
        
#ifdef __MRE_APP_LAUNCH__
    "launch",
#endif    
            
#ifdef __MRE_SAL_PAYMENT__
    "pay",
#endif
    };

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
	mem_size = vm_get_mre_total_mem_size();

	sprintf((CHAR*)tmpbuf, (char *)"[Version] %d\n[Build time] %s\n[Mem size] %d\n",MRE_VERSION,build_date_time(),mem_size);

    strcat((CHAR*)tmpbuf, (CHAR*)"[Support modules] \n");
	for (i = 0; i < sizeof(modules)/sizeof(VMCHAR*); i++)
	{
    	    strcat((CHAR*)tmpbuf,(CHAR*)modules[i]);
    	    strcat((CHAR*)tmpbuf,(CHAR*)"\n");
	}
	
	info_length = strlen((CHAR *)tmpbuf);
	if (NULL == info)
	{
		*size = 2*(info_length+1);
	}
	else
	{
		if (*size <= 2*info_length)
		{
			return -1;
		}
		*size = 2*(info_length+1);
		mmi_asc_to_ucs2((CHAR*)info,(CHAR*)tmpbuf);
	}
	return 0;
}

/*****************************************************************************/
/*    update relative API                                                                                                   */
/******************************************************************************/
#ifdef __MRE_SAL_SOCKET__
typedef struct
{
    VMWCHAR app_file_path[MAX_APP_NAME_LEN + 10];
    VMWCHAR update_file_path[MAX_APP_NAME_LEN + 10];
    VMINT   bExited;
    VM_P_HANDLE app_handle;    
    void   (*cb)(VMINT result,VMWSTR path, void* user_data);
    void*   user_data;
}vm_update_replace_data;

typedef struct
{
    VM_P_HANDLE                 handle;
    vm_update_mre_app_callback  cb;
    void*                       user_data;
    VMCHAR*                     ua;
}vm_update_user_data;
extern _vm_pcb_t* vm_sh_pcb_in_pt(VMINT search_type, VMINT value, VM_PROCESS_STATUS* status);
extern _vm_sm_t * _vm_sm_list_find(VMINT type, VMINT value);

VMINT vm_update_unpackage_file(VMWSTR path,
                                    VMWSTR folder,
                                    void  (*cb)(VMINT result,VMWSTR path,void* user_data),
                                    void* user_data);
static VMWSTR vm_update_get_app_path()
{
    _vm_pcb_t* pcb = NULL;
    VMINT currAppR9 = vm_get_running_app_sb();
    
    pcb = vm_sh_pcb_in_pt(SH_TYPE_R9, currAppR9, NULL);
    if (!pcb)
    {
        _vm_sm_t * sm_ptr = _vm_sm_list_find(SM_FIND_BY_R9, currAppR9);
        if (sm_ptr && sm_ptr->pcb)
        {
            return sm_ptr->pcb->fullFileName;
        }
        return NULL;
    }
    return pcb->fullFileName;
}

static VMBOOL vm_update_can_be_replaced(VMWSTR path)
{
    VMINT length = kal_wstrlen(path);
    if (0 == kal_wstrcmp(path+length-4,L".ROM") || 0 == kal_wstrcmp(path+length-4,L".rom")
        || 0 == kal_wstrcmp(path+length-4,L".sht"))
    {
        return VM_FALSE;
    }  
    return VM_TRUE;
}

static VMBOOL vm_update_is_file_exist(VMWSTR path)
{
    int file;
    file = FS_Open(path,FS_READ_ONLY);
    if (file < 0)
    {
        return VM_FALSE;
    }
    FS_Close(file);
    return VM_TRUE;
}

static VMBOOL vm_update_is_packaged_file(VMWSTR path)
{
    int file;
    CHAR head[8];
    int readed;
    file = FS_Open(path,FS_READ_ONLY);
    if (file < 0)
    {
        return VM_FALSE;
    }

    if (FS_NO_ERROR == FS_Read(file,head,8,&readed))
    {
        if (0 == memcmp(head,"VPK_FILE",8))
        {
            FS_Close(file);
            return VM_TRUE;
        }
    }
    FS_Close(file);
    return VM_FALSE;
}

static VMBOOL vm_update_can_be_installed(VMWSTR path)
{
    VMINT length = kal_wstrlen(path);
    if (0 == mmi_ucs2icmp((CHAR*)(path+length-4),(CHAR*)L".vxp")
        || 0 == mmi_ucs2icmp((CHAR*)(path+length-4),(CHAR*)L".vpp") )
    {
        return VM_TRUE;
    }  
    return VM_FALSE;
}
static VMINT vm_update_get_path(VMWCHAR *path, VMWCHAR *apppath, VMINT bOnCard)
{
    VMINT driver = 0;
    VMINT fh;
    VMWCHAR* p;
    
    if (bOnCard)
    {
        driver = vm_get_removeable_driver();
    }
    else
    {
        driver = vm_get_system_driver();
    }

    if (driver <= 0)
    {
        return VM_UPDATE_ERROR;
    }
    
    kal_wsprintf(path,"%c:\\MRE",driver);
	if ((fh = FS_Open(path,FS_OPEN_DIR))<=0)
	{
	    FS_CreateDir(path);
	}
	else
	{
	    FS_Close(fh);
	}

	p = apppath+kal_wstrlen(apppath)-1;
	while(*p != (VMWCHAR)L'\\' && p != apppath)
	{
	    p--;
	}
	kal_wstrcat(path,p);

    if (!vm_update_can_be_replaced(path))
    {
        kal_wstrcpy(path+kal_wstrlen(path)-4,L".vxp");
    }
    
    return VM_UPDATE_OK;
}

static VMUINT vm_update_get_version(VMWSTR appPath, VMCHAR buff[], VMINT size)
{
    VMINT bufSize = 4;
    VMUINT version = 0;

	if(vm_get_vm_tag(appPath, VM_CE_INFO_VER, &version, &bufSize) == GET_TAG_TRUE)
	{
	    if (buff)
	    {
	        VMCHAR* p = (VMCHAR*)&version;
	        _snprintf(buff,size,"%d.%d.%d",*(p+1),*(p+2),*(p+3));
        }  
        return (version >> 24)&0x000000ff | ((version >> 8)&0x0000ff00 ) | ((version << 8)&0x00ff0000);
	}
	else
	{
		return 0;
	}
}

static VMINT vm_update_check_version_int(VMWSTR appPath, VMWCHAR path[])
{
    VMINT fh;
    //VMCHAR appVer1[8] = "";
    //VMCHAR appVer2[8] = "";
    
    if (!path || !appPath)
    {
        return VM_UPDATE_ERROR;
    }

    // check memory card
    vm_update_get_path(path,appPath,1);
    kal_wstrcat(path,L".tmp");
    
    fh = FS_Open(path,FS_READ_ONLY);
    if (fh >= 0)
    {
        FS_Close(fh);
        //make sure the version of the vxp is the newer than the running one.
/*        if (vm_update_get_version(path,NULL,0) > vm_update_get_version(appPath, NULL, 0))
        {
            return VM_UPDATE_OK;
        }
        else
        {
            //delete this tmp file
            FS_Delete(path);
        }*/
        return VM_UPDATE_OK;
    }
    
    //check phone
    vm_update_get_path(path,appPath,0);
    kal_wstrcat(path,L".tmp");
    
    fh = FS_Open(path,FS_READ_ONLY);
    if (fh < 0)
    {
        return VM_UPDATE_ERROR;
    }
    FS_Close(fh);
    //make sure the version of the vxp is the newer than the running one.
/*    if (vm_update_get_version(path,NULL,0) > vm_update_get_version(appPath, NULL, 0))
    {
        return VM_UPDATE_OK;
    }
    else
    {
        //delete this tmp file
        FS_Delete(path);
    }*/
    
    return VM_UPDATE_OK;
}

static void vm_update_callback(VMINT hdl, void * para)
{
    vm_preload_recv_data_t data;
    vm_update_user_data* user_data;
    
    memcpy(&data,para,sizeof(vm_preload_recv_data_t));

    MMI_TRACE(TRACE_GROUP_8,TRC_MRE_UPDATE_CB_S,data.head.state);
    user_data = data.head.user_data;
    if (vm_pmng_set_ctx(user_data->handle) == VM_PMNG_OP_OK)
    {
        data.head.user_data = user_data->user_data;
        if (user_data->cb)
        {
            user_data->cb(hdl, &data);
        }
		vm_pmng_reset_ctx();
	}

	MMI_TRACE(TRACE_GROUP_8,TRC_MRE_UPDATE_CB_E);
	
    if (E_PRELOAD_AVAILABLE_UPDATE == data.head.state ||
            E_PRELOAD_NO_UPDATE == data.head.state ||
            E_PRELOAD_HOST_NOT_FOUND == data.head.state ||
            E_PRELOAD_FAILURE == data.head.state ||
            E_PRELOAD_DOWNLOADED == data.head.state)
    {        
        _vm_kernel_free(user_data->ua);
        user_data->ua = NULL;
        _vm_kernel_free(user_data);
    }
    
}

VMINT vm_update_check_version(VMSTR URL, VMINT port, VMINT apn, vm_update_mre_app_callback callback, void* user_data)
{
    //VM_P_HANDLE pHandle = 0;    
    int bufSize;
    //VMSTR tmpStr;
    //vm_update_user_data* data = NULL;
    VMWCHAR path[MAX_APP_NAME_LEN + 10];
    VMCHAR version[12];
    VMINT result;
    vm_update_check_version_param param;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_PRINT(MOD_MRE,TRACE_GROUP_8,"[MRE]check version:%s,%d,%d",URL,port,apn);
    
    memset(&param,0,sizeof(vm_update_check_version_param));
    param.URL = URL;
    param.port = port;
    param.apn = apn;
    param.callback = callback;
    param.user_data = user_data;
    
    param.app_path = vm_update_get_app_path();
    if (!param.app_path)
    {
        result = VM_UPDATE_ERROR;
        goto error;
    }
    
    if (0 == vm_update_check_version_int(param.app_path, path))
    {
        result = VM_UPDATE_OK_ALREADY_DOWNLOADED;
        goto error;
    }

    if (0 == vm_update_get_version(param.app_path, version, sizeof(version)))
    {
        result = VM_UPDATE_ERROR_GET_VERSION_FAIL;
        goto error;
    }

    param.app_ver = version;
    
    bufSize = 4;
    if (GET_TAG_TRUE != vm_get_vm_tag(param.app_path, VM_CE_INFO_APP_ID, &(param.app_id), &bufSize))
    {
        result = VM_UPDATE_ERROR_GET_APP_ID_FAIL;
        goto error;
    }

    if (GET_TAG_TRUE == vm_get_vm_tag(param.app_path, VM_CE_INFO_UPDATE_INFO, NULL, &bufSize) && bufSize > 0)
    {
        param.app_info = (VMCHAR*)_vm_kernel_calloc(bufSize);
        if (!param.app_info)
        {
            result = VM_UPDATE_ERROR_NO_MEMORY;
            goto error;
        }
        
        vm_get_vm_tag(param.app_path, VM_CE_INFO_UPDATE_INFO, param.app_info, &bufSize);
    }

    result = vm_update_check_version_ex(&param);
    _vm_kernel_free(param.app_info);
error:    
    MMI_TRACE(TRACE_GROUP_8,TRC_MRE_UPDATE_CHECK,result);
    return result;
}

VMINT vm_update_check_version_ex(vm_update_check_version_param *param)
{
    VMINT result = VM_UPDATE_OK;
    //VM_P_HANDLE pHandle = 0;    
    vm_preload_query_info_t info;
    //int bufSize;
    //VMSTR tmpStr;
    vm_update_user_data* data = NULL;
    VMWCHAR path[MAX_APP_NAME_LEN + 10]={0};
    mmi_devconfig_system_config_struct config;

    MMI_TRACE(TRACE_GROUP_8,TRC_MRE_UPDATE_CHECK_EX_S);
    memset(&config,0,sizeof(config));
    mmi_devconfig_get_system_config(&config);
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
//    memset(&info, 0, sizeof(info));
    data = (vm_update_user_data*)_vm_kernel_calloc(sizeof(vm_update_user_data));
    if (!data)
    {
        result = VM_UPDATE_ERROR_NO_MEMORY;
        goto error;
    }

    data->handle = vm_pmng_get_current_handle();
    data->cb = param->callback;
    data->user_data = param->user_data;
    
    
    if (0 == vm_update_check_version_int(param->app_path, path))
    {
        result = VM_UPDATE_OK_ALREADY_DOWNLOADED;
        goto error;
    }    

    data->ua = (VMCHAR*)_vm_kernel_calloc(1024);
    if (!data->ua)
    {
        result = VM_UPDATE_ERROR_NO_MEMORY;
        goto error;
    }

    sprintf(data->ua,"app_id=%d&",param->app_id);

    strcat(data->ua,"ver=");
    if (param->app_ver)
    {
        strcat(data->ua,param->app_ver);
    }
    sprintf(data->ua+strlen(data->ua),"&imsi=%s&imei=%s&ua=",vm_get_imsi(),vm_get_imei());
    if (param->app_info)
    {
        strcat(data->ua,param->app_info);
    }
    sprintf(data->ua+strlen(data->ua),"&MRE_ver=%d.%d.%02d&",MRE_VERSION/1000,(MRE_VERSION%1000)/100,MRE_VERSION%100);
    
    sprintf(data->ua+strlen(data->ua),"mem=%d&",config.memory_size>>10);
    sprintf(data->ua+strlen(data->ua),"touch=%d&",config.input_device.touch_screen);
    sprintf(data->ua+strlen(data->ua),"fingtouch=%d&",config.input_device.figner_touch_support);
    {
        VMINT cam_support = 0;
        #ifdef __MRE_SAL_CAMERA__
        if (config.camera_device.camcorder_support)
        {
            cam_support = 1;
        }
        #endif
        sprintf(data->ua+strlen(data->ua),"camera=%d&", cam_support);
    }
    sprintf(data->ua+strlen(data->ua),"sensor=%d&",config.remote_sensing.motion_sensor);
    strcat(data->ua,"keyboard=");
    
    if (MMI_DEVCONFIG_KEYPAD_TYPE_NORMAL == config.input_device.keypad_type)
    {
        strcat(data->ua,"normal&");
    }
    else if (MMI_DEVCONFIG_KEYPAD_TYPE_REDUCED == config.input_device.keypad_type)
    {
        strcat(data->ua,"reduced&");
    }
    else if (MMI_DEVCONFIG_KEYPAD_TYPE_QWERTY == config.input_device.keypad_type)
    {
        strcat(data->ua,"qwerty&");
    }
    sprintf(data->ua+strlen(data->ua),"lang=%s&",Get_Current_Lang_CountryCode());
    sprintf(data->ua+strlen(data->ua),"w=%d&",LCD_WIDTH);
    sprintf(data->ua+strlen(data->ua),"h=%d&",LCD_HEIGHT);
    sprintf(data->ua+strlen(data->ua),"platform=%s&",PLATFORM);
    sprintf(data->ua+strlen(data->ua),"module=%s&", HW_VER_STR);
    sprintf(data->ua+strlen(data->ua),"user_agent=%s", MRE_SYS_USER_AGENT);

    info.app_id = param->app_id;
    info.ua = data->ua;
    if ((result = vm_preload_query(param->apn, param->URL, param->port, &info, vm_update_callback, data)) < 0)
    {
        _vm_kernel_free(data->ua);
        _vm_kernel_free(data);
        result += VM_UPDATE_ERROR_INTER;
    }
    else
    {
        result = VM_UPDATE_OK;
    }
error:    
    MMI_TRACE(TRACE_GROUP_8,TRC_MRE_UPDATE_CHECK_EX_E,result);
    return result;
}

VMINT vm_update_download(VMINT handle, VMINT bOnCard, vm_update_mre_app_callback callback, void* user_data)
{
    //VMWCHAR path[MAX_APP_NAME_LEN + 10];
    vm_update_user_data* data = NULL;
    VMINT result;
    vm_update_download_param param;
    MMI_TRACE(TRACE_GROUP_8,TRC_MRE_UPDATE_DOWNLOAD_S);
    data = (vm_update_user_data*)_vm_kernel_calloc(sizeof(vm_update_user_data));
    if (!data)
    {
        result = VM_UPDATE_ERROR_NO_MEMORY;
        goto error;
    }

    param.handle = handle;
    param.bSaveOnCard = bOnCard;
    param.callback = callback;
    param.user_data= user_data;
    param.bUseDLA=0;
    param.app_path= vm_update_get_app_path();
    if (!param.app_path)
    {
        _vm_kernel_free(data);
        result =  VM_UPDATE_ERROR;
        goto error;
    }

    result = vm_update_download_ex(&param);
error:
    MMI_TRACE(TRACE_GROUP_8,TRC_MRE_UPDATE_DOWNLOAD_E,result);
    return result;
}

VMINT vm_update_download_ex(vm_update_download_param *param)
{
    VMWCHAR path[MAX_APP_NAME_LEN + 10];
    vm_update_user_data* data = NULL;
    VMINT result = VM_UPDATE_OK;

    MMI_TRACE(TRACE_GROUP_8,TRC_MRE_UPDATE_DOWNLOAD_EX_S);
    data = (vm_update_user_data*)_vm_kernel_calloc(sizeof(vm_update_user_data));
    if (!data)
    {
        result = VM_UPDATE_ERROR_NO_MEMORY;
        goto error;
    }

    data->handle = vm_pmng_get_current_handle();
    data->cb = param->callback;
    data->user_data = param->user_data;
    if (vm_update_get_path(path,param->app_path,param->bSaveOnCard))
    {
        _vm_kernel_free(data);
        result = VM_UPDATE_ERROR_PATH_NOT_EXIST;
        goto error;
    }
    kal_wstrcat(path,L".tmp");
	result = vm_preload_download_ex(param->handle,path,param->bUseDLA,vm_update_callback,data);
	if (result < 0)
	{
	    _vm_kernel_free(data);
	    result += VM_UPDATE_ERROR_INTER;
	}
error:	
	MMI_TRACE(TRACE_GROUP_8,TRC_MRE_UPDATE_DOWNLOAD_EX_E,result);
    return VM_UPDATE_OK;
}

static mmi_ret vm_update_move_cb(mmi_event_struct *info)
{
    VMINT result = -9;
    vm_update_replace_data* update_data = (vm_update_replace_data*)info->user_data;
    VMWCHAR tmp_name[MAX_APP_NAME_LEN + 20] = {0};
    srv_fmgr_async_done_event_struct* p = (srv_fmgr_async_done_event_struct*)info;
    
    kal_wstrcpy(tmp_name,update_data->app_file_path);
    kal_wstrcat(tmp_name,L".update_bak");
        
    if (EVT_ID_SRV_FMGR_ASYNC_DONE == info->evt_id)
    {
        if(p->result == 0)
        {          
            if (vm_update_can_be_installed(update_data->app_file_path))
            {
                if (!srv_mre_appmgr_update_install(update_data->app_file_path))
                {
                    goto error;
                }
            }
            FS_Delete(tmp_name);
            
            if (update_data->cb)
            {
                result = 0;
                (*update_data->cb)(result,update_data->app_file_path,update_data->user_data);
            }
        }
        else //error
        {
            goto error;
        }
        _vm_kernel_free(update_data);
    }
    else if (EVT_ID_SRV_FMGR_ASYNC_ABORTING == info->evt_id)
    {
error:     
        FS_Delete(update_data->app_file_path);
        FS_Rename(tmp_name, update_data->app_file_path);
        if (update_data->cb)
        {
            result = -1;
            (*update_data->cb)(result,update_data->app_file_path,update_data->user_data);
        }
        _vm_kernel_free(update_data);
    }
    MMI_TRACE(TRACE_GROUP_8,TRC_MRE_UPDATE_MOVE_CB,info->evt_id,p->result,result);
    return 0;
}

static void vm_update_check_folder(VMWSTR app_path)
{
    VMWSTR p;
    
    p = app_path + kal_wstrlen(app_path)-1;
    if (*app_path != vm_get_removeable_driver() && *app_path != vm_get_system_driver())
    {
        *app_path = 0;
        return;
    }
    
    while (p != app_path)
    {
        if (*p == '\\')
        {
            *p = 0;
            return;
        }
        p--;
    }
    *app_path = 0;
}
static void_vm_update_unpackage_cb(VMINT result, VMWSTR path, void* user_data)
{
    vm_update_replace_data* update_data = (vm_update_replace_data*)user_data;
    if (update_data->cb)
    {
        (*update_data->cb)(result,path,update_data->user_data);
    }
    _vm_kernel_free(update_data);
}
static void vm_update_update_file_cb(void* param)
{
    VMINT result = -9;
    vm_update_replace_data* update_data = (vm_update_replace_data*)param;

    MMI_TRACE(TRACE_GROUP_8,TRC_MRE_UPDATE_FILE_CB_S);
    if (!update_data->bExited)
    {
        //exit app first
        if (!vm_sh_pcb_in_pt(SH_TYPE_PROCESS_HANDLE, update_data->app_handle, NULL))
        {
             _vm_sm_t * sm_ptr = _vm_sm_list_find(SH_TYPE_PROCESS_HANDLE, update_data->app_handle);
            if (sm_ptr && sm_ptr->pcb)
            {
                vm_pmng_delete_process(sm_ptr->pcb->pHandle);
            }
        }
        else
        {
            vm_pmng_delete_process(update_data->app_handle);
        }
        
        //clear tag cache
        vm_get_tag_deinit(0);
        update_data->bExited = TRUE;
        
        StartTimerEx(0xffea, 0, vm_update_update_file_cb, update_data);
        return;
    }
    else
    {
        //replace file        
        if (vm_update_is_packaged_file(update_data->update_file_path))
        {
            vm_update_check_folder(update_data->app_file_path);
            if (VM_UPDATE_OK == vm_update_unpackage_file(update_data->update_file_path,update_data->app_file_path,
                        void_vm_update_unpackage_cb,(void*)update_data))
            {
                result = 0;                
            }
            else
            {
                result = -3;
                if (update_data->cb)
                {
                    (*update_data->cb)(result,update_data->app_file_path,update_data->user_data);
                }
                _vm_kernel_free(update_data);
            }
        }
        else if (vm_update_can_be_replaced(update_data->app_file_path) && vm_update_is_file_exist(update_data->app_file_path))
        {
            VMWCHAR tmp_name[MAX_APP_NAME_LEN + 10] = {0};
            
            kal_wstrcpy(tmp_name,update_data->app_file_path);
            kal_wstrcat(tmp_name,L".update_bak");
            FS_Delete(tmp_name);
            FS_Rename(update_data->app_file_path,tmp_name);

            if (srv_fmgr_async_move((const WCHAR*)update_data->update_file_path,
                           (const WCHAR*)update_data->app_file_path,
                           NULL,
                           vm_update_move_cb,
                           (void*)update_data) < 0)
            {
                result = -1;
                if (update_data->cb)
                {
                    (*update_data->cb)(result,update_data->app_file_path,update_data->user_data);
                }
                _vm_kernel_free(update_data);
            }
        }
        else
        {
            VMWCHAR path[MAX_APP_NAME_LEN + 10];
            memcpy(path, update_data->update_file_path, MAX_APP_NAME_LEN + 10);
            memset(path+kal_wstrlen(path)-4, 0, 4);
            FS_Delete(path);
            result = (VMINT)FS_Rename(update_data->update_file_path, path);
            if (0 == result)
            {
                result = srv_mre_appmgr_update_install(path)?0:-2;
            }
            if (result)
            {
                FS_Delete(path);
            }
            
            if (update_data->cb)
            {
                (*update_data->cb)(result,path,update_data->user_data);
            }
            _vm_kernel_free(update_data);
        }
    }
    MMI_TRACE(TRACE_GROUP_8,TRC_MRE_UPDATE_FILE_CB_E,result);
}

extern void vm_update_show_screen(void* param, int size);
extern void vapp_mre_app_update(void* param, int size);
static vm_update_replace_data* g_vm_update_data;
VMINT vm_update_update_file()
{
    VMINT result = VM_UPDATE_OK;
    //VMINT fh;
    VMWSTR appPath;
    vm_update_replace_data* update_data;

    MMI_TRACE(TRACE_GROUP_8,TRC_MRE_UPDATE_FILE_S);
    update_data = _vm_kernel_calloc(sizeof(vm_update_replace_data));

    if (!update_data)
    {
        result = VM_UPDATE_ERROR_NO_MEMORY;
        goto error;
    }
    g_vm_update_data = update_data;
    appPath = vm_update_get_app_path();    
    if (!appPath)
    {
        _vm_kernel_free(update_data);
        result = VM_UPDATE_ERROR;
        goto error;
    }
    
    memcpy(update_data->app_file_path, appPath, sizeof(update_data->app_file_path));

    update_data->app_handle = vm_pmng_get_current_handle();
    if (0 == vm_update_check_version_int(appPath, update_data->update_file_path))
    {
#ifdef __COSMOS_MMI_PACKAGE__
        vapp_mre_app_update(&update_data, sizeof(U32));
#else
        vm_update_show_screen(&update_data, sizeof(U32));
#endif
    }
    else
    {
        _vm_kernel_free(update_data);
        result = VM_UPDATE_ERROR_NO_UPDATE_FILE;
    }
error:
    MMI_TRACE(TRACE_GROUP_8,TRC_MRE_UPDATE_FILE_E,result);
    return result;
}

typedef struct _stack_datas
{
    VMWSTR  path; 
    VMWSTR  new_path;
    VMWSTR  tmpbuff;
    VMWSTR  vxp_path;
    void*   work_buff;
    VMINT   file;
    VMINT   new_file;
    VMINT   number;
    VMINT   i;
    VMINT   size;
    VMINT   readed_size;
    VMINT   length;
    void  (*cb)(VMINT result,VMWSTR path,void* user_data);
    void*   user_data;
    VMWSTR  sub_vxp_file[5];
    VMINT   goto_pos;
}stack_datas;

static int g_writed;

static VMINT vm_update_unpackage_file_cb(fs_job_id job_id,kal_int64 ret,void * data);
static VMINT vm_update_unpackage_file_ex(stack_datas * stack_data)
{
    VMINT result = VM_UPDATE_OK;
    VMWSTR new_path = NULL;
    int file,new_file, number,readed,i,size,readed_size;
    VMWSTR tmpbuff = NULL;
    VMWSTR vxp_path = NULL;
    VMWSTR p;
    VMINT length = NULL;
    
    if (!stack_data)
    {
        return -1;
    }      

    new_path = stack_data->new_path;
    tmpbuff = stack_data->tmpbuff ;
    vxp_path = stack_data->vxp_path ;
    file = stack_data->file;
    new_file = stack_data->new_file ;
    number = stack_data->number ;
    i = stack_data->i ;
    size = stack_data->size ;
    readed_size = stack_data->readed_size;
    length = stack_data->length;

    if (1 == stack_data->goto_pos)
    {
        goto async_pos;
    }
    else if (2 == stack_data->goto_pos)
    {
        goto async_pos2;
    }
    else if (3 == stack_data->goto_pos)
    {
        goto error;
    }
   
    for (i = 0; i < number; i++)
    {
        int tmp_flag = 0;
        //read path size
        if (FS_NO_ERROR != FS_Read(file,(void*)&size,4,&readed) || 4 != readed || size > MAX_APP_NAME_LEN*2)
        {
            result = -1;
            goto error;
        }
        //path
        memset((void*)tmpbuff,0,MAX_APP_NAME_LEN*2);
        if (FS_NO_ERROR != FS_Read(file,(void*)tmpbuff,size,&readed) || size != readed)
        {
            result = -2;
            goto error;
        }
        //create folder
        p = tmpbuff;
        while (*p != 0)
        {
            if (*p == '\\')
            {
                WCHAR tmp = *p;
                *p = 0;
                kal_wstrcat(new_path,L"\\");
                kal_wstrcat(new_path,tmpbuff);
                FS_CreateDir(new_path);
                new_path[length] = 0;
                *p = tmp;
            }
            p++;
        }
        kal_wstrcat(new_path,L"\\");
        kal_wstrcat(new_path,tmpbuff);
        //rename old file
        kal_wstrcpy(tmpbuff,new_path);
        kal_wstrcat(tmpbuff,L".tp");
        FS_Rename(new_path,tmpbuff);

        if (0 == mmi_ucs2icmp((CHAR*)(new_path+kal_wstrlen(new_path)-4),(CHAR*)L".vxp"))
        {
            int k;
            for (k = 0; k < 5; k++)
            {
                if (NULL == stack_data->sub_vxp_file[k])
                {
                    stack_data->sub_vxp_file[k] = (VMWSTR)_vm_kernel_malloc(MAX_APP_NAME_LEN*2);
                    if (!stack_data->sub_vxp_file[k])
                    {
                        MMI_PRINT(MOD_MRE,TRACE_GROUP_8,"[MRE]vm_update_unpackage_file_ex no mem");
                        goto error;
                    }
                    tmp_flag = 1;
                    kal_wstrcpy(stack_data->sub_vxp_file[k],new_path);
                    break;
                }
            }
            if (0 == tmp_flag)
            {
                MMI_PRINT(MOD_MRE,TRACE_GROUP_8,"[MRE]vm_update_unpackage_file_ex max vxp");
                goto error;
            }
        }
        
        //create file
        new_file = FS_Open(new_path,FS_CREATE_ALWAYS);
        if (new_file < 0)
        {
            if (0 == tmp_flag)
            {
                result = -3;
                goto error;
            }
            else
            {
                new_path[length] = 0;

                //read file size
                if (FS_NO_ERROR != FS_Read(file,(void*)&size,4,&readed) || 4 != readed)
                {
                    result = -41;
                    goto error;
                }
                if (FS_Seek(file,size,FS_FILE_CURRENT) < 0)
                {
                    result = -42;
                    goto error;
                }
                continue;
            }
        }

        
        
        new_path[length] = 0;

        //read file size
        if (FS_NO_ERROR != FS_Read(file,(void*)&size,4,&readed) || 4 != readed)
        {
            result = -43;
            goto error;
        }

        readed_size = 0;
        while (readed_size < size)
        {
            int should_read_size;
            fs_overlapped_struct overlapped;
            should_read_size = (MAX_APP_NAME_LEN*2) > (size-readed_size)?(size-readed_size):MAX_APP_NAME_LEN*2;
            if (FS_NO_ERROR != FS_Read(file,(void*)tmpbuff,should_read_size,&readed) || should_read_size != readed)
            {
                result = -44;
                goto error;
            }
            readed_size += readed;
            
            overlapped.priority = FS_PRIORITY_DEFAULT;
            overlapped.priority_value = 0;
            overlapped.response_flag = 0;
            overlapped.callback = (fs_async_callback)vm_update_unpackage_file_cb;
            overlapped.param = (void*)stack_data;
            overlapped.buf = stack_data->work_buff;
            overlapped.buf_size = FS_ASYNC_WORKING_BUFFER_SIZE;

            
            stack_data->file = file;
            stack_data->new_file = new_file;
            stack_data->number = number;
            stack_data->i = i;
            stack_data->size = size;
            stack_data->readed_size = readed_size;
            stack_data->length = length;
             
            fs_async_write(new_file, (void*)tmpbuff,readed,&g_writed, &overlapped);
            return VM_UPDATE_OK;
async_pos:      
            should_read_size = 0;
        }
        FS_Close(new_file);
    }

    //install other vxps
    {
        int k;
        MMI_BOOL bResult = 0;
        for (k = 0; k < 5;k++)
        {
            if (stack_data->sub_vxp_file[k]!=0)
            {                
                bResult = srv_mre_appmgr_update_install(stack_data->sub_vxp_file[k]);
                MMI_PRINT(MOD_MRE,TRACE_GROUP_8,"[MRE]vm_update_unpackage_file_ex install tmp_vxp %d",bResult);
                MMI_PRINT(MOD_MRE,TRACE_GROUP_8,"[MRE]path %s",stack_data->sub_vxp_file[k]);
            }
            else
            {
                if (k > 0)
                {
                    kal_wstrcpy(vxp_path,stack_data->sub_vxp_file[k-1]);
                }
                break;
            }
        }
        if (!bResult)
        {
            result = -6;
            goto error;
        }
    }
    
    //delete old tmp file
    FS_Seek(file,12,FS_FILE_BEGIN);
    if (FS_NO_ERROR != FS_Read(file,(void*)&number,4,&readed) || 4 != readed)
    {
        result = -7;
        goto remove_old;
    }

    FS_Seek(file,4,FS_FILE_CURRENT);
    for (i = 0; i < number; i++)
    {
        fs_overlapped_struct overlapped;
        //read path size
        if (FS_NO_ERROR != FS_Read(file,(void*)&size,4,&readed) || 4 != readed || size > MAX_APP_NAME_LEN*2)
        {
            result = -8;
            goto remove_old;
        }
        //path
        memset((void*)tmpbuff,0,MAX_APP_NAME_LEN*2);
        if (FS_NO_ERROR != FS_Read(file,(void*)tmpbuff,size,&readed) || size != readed)
        {
            result = -9;
            goto remove_old;
        }
        kal_wstrcat(new_path,L"\\");
        kal_wstrcat(new_path,tmpbuff);
        //delete new file
        kal_wstrcat(new_path,L".tp");

        overlapped.priority = FS_PRIORITY_DEFAULT;
        overlapped.priority_value = 0;
        overlapped.response_flag = 0;
        overlapped.callback = (fs_async_callback)vm_update_unpackage_file_cb;
        overlapped.param = (void*)stack_data;
        overlapped.buf = stack_data->work_buff;
        overlapped.buf_size = FS_ASYNC_WORKING_BUFFER_SIZE;

        stack_data->file = file;
        stack_data->new_file = new_file;
        stack_data->number = number;
        stack_data->i = i;
        stack_data->size = size;
        stack_data->readed_size = readed_size;
        stack_data->length = length;
            
        fs_async_delete(new_path,&overlapped);
        return VM_UPDATE_OK;
async_pos2:            
        new_path[length] = 0;
        //read file size
        if (FS_NO_ERROR != FS_Read(file,(void*)&size,4,&readed) || 4 != readed)
        {
            result = -10;
            goto remove_old;
        }
        FS_Seek(file,size,FS_FILE_CURRENT);
   }
remove_old:        
    FS_Close(file);
    FS_Delete(stack_data->path);
    if (stack_data->cb)
    {
        (*stack_data->cb)(0,vxp_path,stack_data->user_data);
    }
    _vm_kernel_free(new_path);
    _vm_kernel_free(stack_data->work_buff);
    _vm_kernel_free(stack_data->path);
    {
        int k;
        for (k = 0; k < 5;k++)
        {
            _vm_kernel_free(stack_data->sub_vxp_file[k]);
        }
    }
    _vm_kernel_free(stack_data);
    _vm_kernel_free(vxp_path);
    _vm_kernel_free(tmpbuff);
    return result;
error: 
    FS_Close(new_file);
    FS_Seek(file,12,FS_FILE_BEGIN);
    if (FS_NO_ERROR != FS_Read(file,(void*)&number,4,&readed) || 4 != readed)
    {
        result = -11;
        goto error2;
    }

    FS_Seek(file,4,FS_FILE_CURRENT);
    for (i = 0; i < number; i++)
    {
        //read path size
        if (FS_NO_ERROR != FS_Read(file,(void*)&size,4,&readed) || 4 != readed || size > MAX_APP_NAME_LEN*2)
        {
            result = -12;
            goto error2;
        }
        //path
        memset((void*)tmpbuff,0,MAX_APP_NAME_LEN*2);
        if (FS_NO_ERROR != FS_Read(file,(void*)tmpbuff,size,&readed) || size != readed)
        {
            result = -13;
            goto error2;
        }
        kal_wstrcat(new_path,L"\\");
        kal_wstrcat(new_path,tmpbuff);
        //delete new file
        FS_Delete(new_path);
        //rename old file
        kal_wstrcpy(tmpbuff,new_path);
        kal_wstrcat(tmpbuff,L".tp");
        FS_Rename(tmpbuff,new_path);
        new_path[length] = 0;
        //read file size
        if (FS_NO_ERROR != FS_Read(file,(void*)&size,4,&readed) || 4 != readed)
        {
            result = -14;
            goto error2;
        }
        if (FS_Seek(file,size,FS_FILE_CURRENT) < 0)
        {
            result = -15;
            goto error2;
        }
    }
error2:
    FS_Close(file);
    FS_Delete(stack_data->path);
    if (stack_data->cb)
    {
        (*stack_data->cb)(-1,vxp_path,stack_data->user_data);
    }
    _vm_kernel_free(new_path);
    _vm_kernel_free(stack_data->work_buff);
    _vm_kernel_free(stack_data->path);
    {
        int k;
        for (k = 0; k < 5;k++)
        {
            _vm_kernel_free(stack_data->sub_vxp_file[k]);
        }
    }
    _vm_kernel_free(stack_data);
    _vm_kernel_free(vxp_path);
    _vm_kernel_free(tmpbuff);    
    return result;
}

static VMINT vm_update_unpackage_file_cb(fs_job_id job_id,kal_int64 ret,void * data)
{
    stack_datas* stack_data;
    fs_job_struct* job;
    
    if (!data)
    {
        return -1;
    }      
    job = (fs_job_struct*)data;
    stack_data = (stack_datas*)job->param;

    if (FS_API_WRITE == job->api)
    {           
        if (ret)
        {
            stack_data->goto_pos = 3;
        }
        else
        {
            stack_data->goto_pos = 1;
        }
    }
    else
    {
        stack_data->goto_pos = 2;
    }

    return vm_update_unpackage_file_ex(stack_data);
}

VMINT vm_update_unpackage_file(VMWSTR path,
                                    VMWSTR folder,
                                    void  (*cb)(VMINT result,VMWSTR path,void* user_data),
                                    void* user_data)
{
    VMINT result = VM_UPDATE_OK;
    VMWSTR new_path = NULL;
    int file,number,readed,drive;
    VMWSTR tmpbuff = NULL;
    VMWSTR vxp_path = NULL;
    VMINT length = NULL;
    stack_datas* stack_data = NULL;

    file = FS_Open(path,FS_READ_ONLY);
    if (file <= 0)
    {
        return -1;
    }

    stack_data = (stack_datas*)_vm_kernel_malloc(sizeof(stack_datas));
    if (!stack_data)
    {
        result = 3;
        goto error;
    }

    memset(stack_data,0,sizeof(stack_datas));
    
        new_path = (VMWSTR)_vm_kernel_malloc(MAX_APP_NAME_LEN*2);
        if (!new_path)
        {
            result = 3;
            goto error;
        }
        
        tmpbuff = (VMWSTR)_vm_kernel_malloc(MAX_APP_NAME_LEN*2);
        if (!tmpbuff)
        {
            result = 3;
            goto error;
        }
        vxp_path = (VMWSTR)_vm_kernel_malloc(MAX_APP_NAME_LEN*2);
        if (!vxp_path)
        {
            result = 3;
            goto error;
        }
        vxp_path[0] = 0;
        
    
        stack_data->user_data = user_data;
        stack_data->new_path = new_path;
        stack_data->tmpbuff = tmpbuff;
        stack_data->vxp_path = vxp_path;
        stack_data->work_buff = _vm_kernel_malloc(FS_ASYNC_WORKING_BUFFER_SIZE);     
        if (!stack_data->work_buff)
        {
            result = 3;
            goto error;
        }
        
        stack_data->cb = cb;
        stack_data->path = (VMWSTR)_vm_kernel_malloc(MAX_APP_NAME_LEN*2);        
        
        if (!stack_data->path)
        {
            result = 3;
            goto error;
        }
        kal_wstrcpy(stack_data->path, path);
        
        if (NULL == folder || 0 == folder[0])
        {      
        /*
            kal_wstrncpy(new_path,path,MAX_APP_NAME_LEN);
            length = kal_wstrlen(new_path); 
            if (length <= 8)
            {
                result = 4;
                goto error;
            }

            drive = vm_get_removeable_driver();
            if (drive < 0)
            {
                drive = vm_get_system_driver();
            }
            new_path[0] = drive;
            new_path[length-8] = 0;
            length -= 8;
            */
            kal_wstrcpy(new_path,L"z:\\MRE");
            drive = vm_get_removeable_driver();
            if (drive < 0)
            {
                drive = vm_get_system_driver();
            }
            new_path[0] = drive;
            length = kal_wstrlen(new_path); 
            FS_CreateDir(new_path);
        }
        else
        {
            kal_wstrncpy(new_path,folder,MAX_APP_NAME_LEN);
            length = kal_wstrlen(new_path);
            FS_CreateDir(new_path);
        }
        
        FS_Seek(file,12,FS_FILE_BEGIN);
        if (FS_NO_ERROR != FS_Read(file,(void*)&number,4,&readed) || 4 != readed)
        {
            result = 1;
            goto error;
        }

        FS_Seek(file,4,FS_FILE_CURRENT);

    stack_data->file = file;
    stack_data->length = length;
    stack_data->number = number;
    stack_data->goto_pos = 0;

    return vm_update_unpackage_file_ex(stack_data);
    
error:
    FS_Close(file);
    FS_Delete(stack_data->path);
  
    _vm_kernel_free(new_path);
    _vm_kernel_free(stack_data->work_buff);
    _vm_kernel_free(stack_data->path);
    _vm_kernel_free(stack_data);
    _vm_kernel_free(vxp_path);
    _vm_kernel_free(tmpbuff);
    return result;
}

VMINT vm_update_update_file_ex(VMWSTR path,void (*callback)(VMINT result,VMWSTR path, void* user_data),void* user_data)
{
    VMINT result = VM_UPDATE_OK;
    //VMINT fh;
    vm_update_replace_data* update_data;

    MMI_TRACE(TRACE_GROUP_8,TRC_MRE_UPDATE_FILE_EX_S,result);
    update_data = _vm_kernel_calloc(sizeof(vm_update_replace_data));

    if (!update_data)
    {
        result = VM_UPDATE_ERROR_NO_MEMORY;
        goto error;
    }
    g_vm_update_data = update_data;
    
    memcpy(update_data->app_file_path, path, sizeof(update_data->app_file_path));

    update_data->app_handle = vm_pmng_get_handle(path);
    update_data->cb = callback;
    update_data->user_data = user_data;
    if (0 == vm_update_check_version_int(path, update_data->update_file_path))
    {
        vm_update_update_file_cb(update_data);
    }
    else
    {
        _vm_kernel_free(update_data);
        result = VM_UPDATE_ERROR_NO_UPDATE_FILE;
    }
error:
    MMI_TRACE(TRACE_GROUP_8,TRC_MRE_UPDATE_FILE_EX_E,result);
    return result;
}

VMINT vm_update_update_int(void (*callback)(VMINT result))
{
    g_vm_update_data->cb = callback;
    StartTimerEx(0xffea, 0, vm_update_update_file_cb, g_vm_update_data);
    return 0;
}

VMINT vm_update_cancel(VMINT handle)
{
    return vm_preload_cancel(handle);
}

VMINT vm_update_check_launch(VMWSTR path, VMWSTR new_path)
{
    VMINT fh;

    if (!new_path || !path)
    {
        return FALSE;
    }
    
    if (vm_update_can_be_replaced(path))
    {
        return FALSE;
    }

    vm_update_get_path(new_path,path,1);
    fh = FS_Open(new_path,FS_READ_ONLY);
    if (fh >= 0)
    {
        FS_Close(fh);
        return TRUE;
    }

    vm_update_get_path(new_path,path,0);
    fh = FS_Open(new_path,FS_READ_ONLY);
    if (fh >= 0)
    {
        FS_Close(fh);
        return TRUE;
    }
    return FALSE;
}

#ifndef __COSMOS_MMI_PACKAGE__

static VMWSTR g_vm_update_path = NULL;

static void vm_update_launch_app(void)
{
    mmi_frm_scrn_close_active_id();
    mmi_am_launch_app_by_path((U16*)g_vm_update_path); 
    _vm_kernel_free(g_vm_update_path);
    g_vm_update_path = NULL;
}

static void vm_update_launch_cancel(void)
{
    mmi_frm_scrn_close_active_id();  
    _vm_kernel_free(g_vm_update_path);
    g_vm_update_path = NULL;
}

static void vm_update_show_result(mmi_scrn_essential_struct* data)
{
    U8* guiBuffer = NULL;
    VMINT result = (VMINT)data->user_data;
    //U16 msg_id = 0;
    //U16 msg_icon = 0;

    mmi_frm_scrn_enter(GRP_ID_ROOT, SCR_ID_MRE_UPDATE_RESULT, (FuncPtr)NULL, (FuncPtr)vm_update_show_result, MMI_FRM_FULL_SCRN);
	guiBuffer = mmi_frm_scrn_get_active_gui_buf();        /* get current guibuffer */

    if (0 == result)
    {
        ShowCategory8Screen( STR_MRE_UPDATE_TITLE, 
                         0, 
                         STR_GLOBAL_OK,
                         0, 
                         STR_GLOBAL_CANCEL, 
                         0, 
                         STR_MRE_UPDATE_SUCCESS,//message
                         IMG_GLOBAL_INFO, 
                         guiBuffer);
                         
        SetLeftSoftkeyFunction(vm_update_launch_app, KEY_EVENT_UP);  
        SetRightSoftkeyFunction(vm_update_launch_cancel, KEY_EVENT_UP);
    }
    else
    {
        ShowCategory8Screen( STR_MRE_UPDATE_TITLE, 
                         0, 
                         STR_GLOBAL_OK,
                         0, 
                         0, 
                         0, 
                         STR_MRE_UPDATE_FAIL,//message
                         IMG_GLOBAL_ERROR, 
                         guiBuffer);
                         
        SetLeftSoftkeyFunction(vm_update_launch_cancel, KEY_EVENT_UP);                           
    }                      
}

static void vm_update_close_waiting(VMINT result,VMWSTR path,void* user_data)
{
    mmi_frm_scrn_close(GRP_ID_ROOT, SCR_ID_MRE_UPDATE_WAIT);
    mmi_frm_scrn_close(GRP_ID_ROOT, SCR_ID_MRE_UPDATE_QUERY);

    g_vm_update_path = _vm_kernel_malloc(MAX_APP_NAME_LEN*2);
    if (g_vm_update_path)
    {
        memcpy(g_vm_update_path,path,MAX_APP_NAME_LEN*2);
    }
    
    mmi_frm_scrn_first_enter(GRP_ID_ROOT, SCR_ID_MRE_UPDATE_RESULT, 
                (FuncPtr)vm_update_show_result, (void*)result);
}
static void vm_update_waiting()
{
    U8* guiBuffer = NULL;
    
	mmi_frm_scrn_enter(GRP_ID_ROOT, SCR_ID_MRE_UPDATE_WAIT, (FuncPtr)NULL, (FuncPtr)vm_update_waiting, MMI_FRM_FULL_SCRN);
	guiBuffer = mmi_frm_scrn_get_active_gui_buf();        /* get current guibuffer */

	ShowCategory121Screen(0,0,0,0,(U8*)GetString(STR_GLOBAL_PLEASE_WAIT),
	                            IMG_GLOBAL_PROGRESS,guiBuffer,1); 
}

static void vm_update_yes()
{    
    vm_update_waiting();
    vm_update_update_int(vm_update_close_waiting);
}

static void vm_update_no()
{
    mmi_frm_scrn_close_active_id();
}

static void vm_update_entry_func(mmi_scrn_essential_struct* data)
{
    U8* guiBuffer = NULL;
    
	mmi_frm_scrn_enter(data->group_id, data->scrn_id, (FuncPtr)NULL, (FuncPtr)vm_update_entry_func, MMI_FRM_FULL_SCRN);
	guiBuffer = mmi_frm_scrn_get_active_gui_buf();        /* get current guibuffer */
    ShowCategory2Screen( STR_MRE_UPDATE_TITLE, 
                         0, 
                         STR_GLOBAL_YES,
                         0, 
                         STR_GLOBAL_NO, 
                         0, 
                         STR_MRE_UPDATE_QUERY,//message,  
                         guiBuffer);

    SetLeftSoftkeyFunction(vm_update_yes, KEY_EVENT_UP);    
    SetRightSoftkeyFunction(vm_update_no, KEY_EVENT_UP);    
}


void vm_update_show_screen(void* param, int size)
{
    mmi_frm_scrn_first_enter(GRP_ID_ROOT, SCR_ID_MRE_UPDATE_QUERY, 
                (FuncPtr)vm_update_entry_func, NULL);             
}

#endif
#else //__MRE_SAL_SOCKET__
VMINT vm_update_check_version(VMSTR URL, VMINT port, VMINT apn, vm_update_mre_app_callback callback, void* user_data)
{
    return -1;
}
VMINT vm_update_download(VMINT handle, VMINT bOnCard, vm_update_mre_app_callback callback, void* user_data)
{
    return -1;
}

VMINT vm_update_update_file(void)
{
    return -1;
}

VMINT vm_update_cancel(VMINT handle)
{
    return -1;
}

VMINT vm_update_check_launch(VMWSTR path, VMWSTR new_path)
{
    return FALSE;
}

VMINT vm_update_update_int(void (*callback)(VMINT result))
{
    return 0;
}

#endif //__MRE_SAL_SOCKET__




static VMINT vm_appmgr_trans_flag(VMINT flag)
{
    switch (flag)
    {
    case 0:       
    case VM_APPMGR_MRE_ALL_FLAG:
        return SRV_APPMGR_ALL_APP_PACKAGE_FLAG_TYPE;
        
    case VM_APPMGR_MRE_INSTALLED_FLAG:
        return SRV_APPMGR_INSTALLED_APP_PACKAGE_FLAG_TYPE;
        
    case VM_APPMGR_MRE_SHORTCUT_FLAG:
        return SRV_APPMGR_SHORTCUT_APP_PACKAGE_FLAG_TYPE; 
    default:
        return flag;
    }
}

static vm_appmgr_install_type vm_appmgr_trans_type(srv_mre_appmgr_app_type_enum type)
{
    if (type & SRV_MRE_APPMGR_APP_TYPE_ROM)
    {
        return VM_APPMGR_INSTALL_TYPE_ROM;
    }
    
    if (type & SRV_MRE_APPMGR_APP_TYPE_SHORTCUT)
    {
        return VM_APPMGR_INSTALL_TYPE_SHORTCUT;
    }
    
    if (type & SRV_MRE_APPMGR_APP_TYPE_LOCAL_INSTALL)
    {
        return  VM_APPMGR_INSTALL_TYPE_LOCAL_INSTALL;
    }
    return VM_APPMGR_INSTALL_TYPE_UNKNOWN;
}
VMINT vm_appmgr_install(VMWSTR path, VMINT flag, vm_install_id install_id)
{
    return srv_mre_appmgr_install_app((U16*)path, 
                SRV_MRE_APPMGR_APP_TYPE_LOCAL_INSTALL, (mmi_app_package_char*)install_id)?0:-2;
}

VMINT vm_appmgr_uninstall(vm_install_id install_id)
{
    return srv_mre_appmgr_app_uninstall((mmi_app_package_char *)install_id)?0:-2;
}

VMBOOL vm_appmgr_is_installed(VMWSTR path, vm_install_id install_id)
{
    U16 app_name_tmp[MMI_APP_NAME_MAX_LEN];
    mmi_app_package_char app_name[MMI_APP_NAME_MAX_LEN];
    
    srv_mre_appmgr_generate_identification((U16 *)path, app_name_tmp);
    mmi_chset_convert(MMI_CHSET_UCS2, MMI_CHSET_UTF8,(char *)app_name_tmp, (char *)app_name, MMI_APP_NAME_MAX_LEN);

    if (install_id)
    {
        memcpy(install_id,app_name,MMI_APP_NAME_MAX_LEN);
    }
    return srv_mre_appmgr_is_app_installed(app_name);
}

VMINT vm_appmgr_get_installed_list(VMINT flag ,vm_install_id* install_id_list, VMUINT* num)
{
    VMINT native_flag;
    
    if (NULL == num)
    {
        return -2;
    }
    native_flag = vm_appmgr_trans_flag(flag);
    if (NULL == install_id_list)   
    {
        *num = srv_mre_appmgr_get_app_num(native_flag);
        return 0;
    }
    return srv_mre_appmgr_get_app_list(native_flag,install_id_list,*num);
}
extern MMI_BOOL srv_mre_appmgr_get_installed_info(
                    U16 *app_name,
                    srv_mre_appmgr_installed_info_struct *info);
                    
VMINT vm_appmgr_get_install_info(vm_install_id install_id, vm_install_info* install_info)
{
    srv_mre_appmgr_installed_info_struct* info;
    U16 app_name_tmp[MMI_APP_NAME_MAX_LEN];

    if (NULL == install_id || NULL == install_info)
    {
        return -2;
    }
    info = (srv_mre_appmgr_installed_info_struct*)vm_malloc(sizeof(srv_mre_appmgr_installed_info_struct));
    if (NULL == info)
    {
        return -3;
    }
    
    mmi_chset_convert(MMI_CHSET_UTF8, MMI_CHSET_UCS2, (char *)install_id, (char *)app_name_tmp, MMI_APP_NAME_MAX_LEN*2);  
    
    if (!srv_mre_appmgr_get_installed_info(app_name_tmp,info))
    {
        vm_free(info);
        return -4;
    }

    memset(install_info,0,sizeof(vm_install_info));
    
    install_info->app_id = info->app_id;
    install_info->app_size = info->app_size;
    install_info->install_type = vm_appmgr_trans_type(info->app_type);
    install_info->store_pos = info->store_pos;
    
    install_info->installed_time.year = info->installed_time.nYear;
    install_info->installed_time.mon = info->installed_time.nMonth;
    install_info->installed_time.day = info->installed_time.nDay;
    install_info->installed_time.hour = info->installed_time.nHour;
    install_info->installed_time.min = info->installed_time.nMin;
    install_info->installed_time.sec = info->installed_time.nSec;

    memcpy(install_info->developer,info->developer,VM_APPMGR_DEVELOPER_NAME_LEN);
    memcpy(install_info->tel,info->tel,VM_APPMGR_TEL_NUM_LEN);
    memcpy(install_info->app_path,info->app_path,VM_APPMGR_FILEPATH_LEN);

    vm_free(info);
    
    return srv_mre_appmgr_get_app_name(install_id,install_info->app_name);
}


/*****************************************************************************
 * FUNCTION
 *  vm_appmgr_activate_launcher
 * DESCRIPTION
 *  Active launcher plug-in
 * PARAMETERS
 *  install_id : [IN] identification of installed app, can get 
 *                            by using vm_appmgr_get_installed_list or vm_appmgr_is_installed
 * RETURNS
 *  error code 0 means success
 *****************************************************************************/
VMINT vm_appmgr_activate_launcher(vm_install_id install_id)
{
#if defined(__MMI_VUI_LAUNCHER_MRE__)
    vapp_launcher_activate_by_vm((CHAR *)install_id);
    return 0;
#else
    return -1;
#endif
}

/*****************************************************************************
 * FUNCTION
 *  vm_appmgr_activate_screen_lock
 * DESCRIPTION
 *  Active Screen-Lock plug-in 
 * PARAMETERS
 *  install_id : [IN] identification of installed app, can get 
 *                            by using vm_appmgr_get_installed_list or vm_appmgr_is_installed
 * RETURNS
 *  error code 0 means success
 *****************************************************************************/
VMINT vm_appmgr_activate_screen_lock(vm_install_id install_id)
{
#if defined(__MMI_VUI_SCREEN_LOCK_MRE__)
    vapp_screen_lock_activate_by_vm((CHAR *)install_id);
    return 0;    
#else
    return -1;
#endif
}

/*****************************************************************************
 * FUNCTION
 *  vm_appmgr_activate_wallpaper
 * DESCRIPTION
 *  Active wallpaper plug-in
 * PARAMETERS
 *  install_id : [IN] identification of installed app, can get 
 *                            by using vm_appmgr_get_installed_list or vm_appmgr_is_installed
 * RETURNS
 *  error code 0 means success
 *****************************************************************************/
VMINT vm_appmgr_activate_wallpaper(vm_install_id install_id, vm_app_mgr_wallpaper_src_enum src)
{
#if defined(__MMI_VUI_WALLPAPER_MRE__)	
    if (src == VM_WALLPAPER_SRC_HOME_SCREEN)
    {
        vapp_wallpaper_provider_activate_by_vm((CHAR *)install_id, VAPP_WALLPAPER_SRC_HOMESCREEN);
    }
    else if (src == VM_WALLPAPER_SRC_LOCK_SCREEN)
    {
        vapp_wallpaper_provider_activate_by_vm((CHAR *)install_id, VAPP_WALLPAPER_SRC_LOCK);
    }
    else
    {
        return -2;
    }
    return 0;    
#else
    return -1;
#endif
}




void vm_sla_custom_logging(VMSTR custom_label, vm_sla_action_type action)
{
#if defined(__MTK_TARGET__)
	switch(action)
	{
	case VM_SLA_STOP:
		SLA_CustomLogging((kal_char *)custom_label, SA_stop);
		break;

	case VM_SLA_START:
		SLA_CustomLogging((kal_char *)custom_label, SA_start);
		break;

	case VM_SLA_LABEL:
		SLA_CustomLogging((kal_char *)custom_label, SA_label);
		break;

	default:
		break;
	}
#endif
}

static void* g_vm_pre_app_mem = NULL;
static VMINT g_pre_malloc_result = 0;
static VMINT g_mem_size = 0;
static VMINT g_mem_idx = 0;
static void (*g_pre_malloc_callback)(void) = 0;


static void vm_mre_pre_malloc_stop(void)
{   
		vm_mre_free_pre_app_mem();
		applib_mem_ap_notify_stop_finished(APPLIB_MEM_AP_ID_MRE_APP0+g_mem_idx, KAL_TRUE);
}

static void vm_mre_pre_malloc_callback(void)
{
    g_mem_idx = vm_get_avaliable_mem_index();
    
    mmi_frm_group_enter(mmi_frm_group_create(GRP_ID_ROOT, GRP_ID_AUTO_GEN, NULL,NULL), MMI_FRM_NODE_SMART_CLOSE_FLAG);
    applib_mem_ap_register((APPLIB_MEM_AP_ID_MRE_APP0+g_mem_idx), STR_MRE_APP0+g_mem_idx, IMAGE_MRE_SMALL_ICON, vm_mre_pre_malloc_stop);
    #if defined(__LOW_COST_SUPPORT_COMMON__)
    applib_mem_ap_free_all_cache();
    #endif
    g_vm_pre_app_mem = applib_mem_ap_alloc(APPLIB_MEM_AP_ID_MRE_APP0+g_mem_idx, g_mem_size);
    if (g_vm_pre_app_mem == NULL)
    {
        g_pre_malloc_result = -4;
    }
    else
    {
        g_pre_malloc_result = 0;
    }
    (*g_pre_malloc_callback)();
}

VMINT vm_mre_pre_malloc_app_mem(WCHAR* path, void (*callback)(void))
{
    VMINT memSize, bufSize;
    VMINT mem_idx;
    //void* mem = NULL;
    //WCHAR* tmp_path;
    
    /* get memory request from vxp file tag. */
    g_pre_malloc_result = -1;
    bufSize = 4;
    if (vm_get_vm_tag(path, VM_CE_INFO_MEM_REQ, &memSize, &bufSize) 
        != GET_TAG_TRUE || memSize <= 0)
    {
        MMI_PRINT(MOD_MRE,TRACE_GROUP_8,"[MRE]check vm_mre_pre_malloc_app_mem 1");
        return -1;
    }  

    memSize = ((memSize+1) << 10);
    g_mem_size = memSize;
#if defined(__LOW_COST_SUPPORT_COMMON__)
    memSize += 200*1024;
#else
    memSize += 600*1024;
#endif  
    
    g_pre_malloc_callback = callback;
    
    if (memSize > (mmi_res_get_asm_common_pool_size()))
    {
        MMI_PRINT(MOD_MRE,TRACE_GROUP_8,"[MRE]check vm_mre_pre_malloc_app_mem 2");
        return -2;
    }
    
    mem_idx = vm_get_avaliable_mem_index();
    
    if (mem_idx == MRE_SUPPORT_MAX_APP_NUM)
    {
        MMI_PRINT(MOD_MRE,TRACE_GROUP_8,"[MRE]check vm_mre_pre_malloc_app_mem 3");
        return -3;
    }
    vm_mre_free_pre_app_mem();
    
    mmi_frm_appmem_prompt_to_release_mem(
        APPLIB_MEM_AP_ID_MRE_APP0+mem_idx, 
        IMAGE_MRE_SMALL_ICON, 
        memSize,
        vm_mre_pre_malloc_callback);

    if (-1 != g_pre_malloc_result)
    {
        return g_pre_malloc_result;
    }
    MMI_PRINT(MOD_MRE,TRACE_GROUP_8,"[MRE]check vm_mre_pre_malloc_app_mem 4");
    return 1;
}

void vm_mre_free_pre_app_mem(void)
{
    if (g_vm_pre_app_mem)
    {
        applib_mem_ap_free(g_vm_pre_app_mem);
    }

    g_vm_pre_app_mem = NULL;
}

/******************************************************************************
 * FUNCTION
 *  vm_appmgr_is_launcher_activated
 * DESCRIPTION
 *  check whether launcher is activated.
 * PARAMETERS
 *  install_id  :   [IN]    identification of installed app, can get by using
 *                          vm_appmgr_get_installed_list or vm_appmgr_is_installed.
 * RETURNS
 *  TRUE means activated, FALSE means NOT activated.
 ******************************************************************************/
VMINT vm_appmgr_is_launcher_activated(vm_install_id install_id)
{
    #if defined(__MMI_VUI_LAUNCHER_MRE__)
        if (vapp_launcher_mre_is_activated((CHAR*) install_id) == MMI_TRUE)
        {
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    #else /* __MMI_VUI_LAUNCHER_MRE__ */
        return FALSE;
    #endif /* __MMI_VUI_LAUNCHER_MRE__ */
}

/******************************************************************************
 * FUNCTION
 *  vm_appmgr_is_wallpaper_activated
 * DESCRIPTION
 *  check whether wallpaper is activated.
 * PARAMETERS
 *  install_id  :   [IN]    identification of installed app, can get by using
 *                          vm_appmgr_get_installed_list or vm_appmgr_is_installed.
 *  src :   [IN]    wallpaper src.
 * RETURNS
 *  TRUE means activated, FALSE means NOT activated.
 ******************************************************************************/
VMINT vm_appmgr_is_wallpaper_activated(
            vm_install_id install_id,
            VMINT src)
{
    #if defined(__MMI_VUI_WALLPAPER_MRE__)
        if ((src == VM_WALLPAPER_SRC_HOME_SCREEN || src == VM_WALLPAPER_SRC_LOCK_SCREEN)
            && vapp_wallpaper_provider_mre_is_activated(
                    (CHAR*) install_id,
                    (VappWallpaperSrcEnum) src) == MMI_TRUE)
        {
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    #else /* __MMI_VUI_WALLPAPER_MRE__ */
        return FALSE;
    #endif /* __MMI_VUI_WALLPAPER_MRE__ */
}

/******************************************************************************
 * FUNCTION
 *  vm_appmgr_is_screen_lock_activated
 * DESCRIPTION
 *  check whether screen lock is activated.
 * PARAMETERS
 *  install_id  :   [IN]    identification of installed app, can get by using
 *                          vm_appmgr_get_installed_list or vm_appmgr_is_installed.
 * RETURNS
 *  TRUE means activated, FALSE means NOT activated.
 ******************************************************************************/
VMINT vm_appmgr_is_screen_lock_activated(vm_install_id install_id)
{
    #if defined(__MMI_VUI_SCREEN_LOCK_MRE__)
        if (vapp_screen_lock_mre_is_activated((CHAR*) install_id) == MMI_TRUE)
        {
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    #else /* __MMI_VUI_SCREEN_LOCK_MRE__ */
        return FALSE;
    #endif /* __MMI_VUI_SCREEN_LOCK_MRE__ */
}

/******************************************************************************
 * FUNCTION
 *	vm_appmgr_is_support_launcher
 * DESCRIPTION
 *	check whether launcher is supported.
 * PARAMETERS
 *	void.
 * RETURNS
 *	TRUE means support, FALSE means NOT support.
 ******************************************************************************/
VMINT vm_appmgr_is_support_launcher(void)
{
	#ifdef __MMI_VUI_LAUNCHER_MRE__
		return TRUE;
	#else
		return FALSE;
	#endif
}

/******************************************************************************
 * FUNCTION
 *	vm_appmgr_is_support_wallpaper
 * DESCRIPTION
 *	check whether wallpaper is supported.
 * PARAMETERS
 *	void.
 * RETURNS
 *	TRUE means support, FALSE means NOT support.
 ******************************************************************************/
VMINT vm_appmgr_is_support_wallpaper(void)
{
	#ifdef __MMI_VUI_WALLPAPER_MRE__
		return TRUE;
	#else
		return FALSE;
	#endif
}

/******************************************************************************
 * FUNCTION
 *	vm_appmgr_is_support_screen_lock
 * DESCRIPTION
 *	check whether screen_lock is supported.
 * PARAMETERS
 *	void.
 * RETURNS
 *	TRUE means support, FALSE means NOT support.
 ******************************************************************************/
VMINT vm_appmgr_is_support_screen_lock(void)
{
	#ifdef __MMI_VUI_SCREEN_LOCK_MRE__
		return TRUE;
	#else
		return FALSE;
	#endif
}

/******************************************************************************
 * FUNCTION
 *	vm_appmgr_is_support_widget
 * DESCRIPTION
 *	check whether widget is supported.
 * PARAMETERS
 *	void.
 * RETURNS
 *	TRUE means support, FALSE means NOT support.
 ******************************************************************************/
VMINT vm_appmgr_is_support_widget(void)
{
	#ifdef __MMI_VUI_WIDGET_MRE__
		return TRUE;
	#else
		return FALSE;
	#endif
}

/******************************************************************************
 * FUNCTION
 *  vm_appmgr_get_mem_size
 * DESCRIPTION
 *  Get Memory size of DLUI components
 * PARAMETERS
 *  Package  :   [IN]       VM_APPMGR_WIDGET_PACKAGE_FLAG
 *                          VM_APPMGR_LAUNCHER_PACKAGE_FLAG
 *                          VM_APPMGR_WALLPAPER_PACKAGE_FLAG
 *                          VM_APPMGR_SCRLOCK_PACKAGE_FLAG
 * RETURNS
 *  Memory Size requirement, -1 means not support.
 ******************************************************************************/
VMINT vm_appmgr_get_mem_size(VMUINT32 package)
{
    VMINT mem_size = 0;
    switch(package)
    {
        case VM_APPMGR_WIDGET_PACKAGE_FLAG:
            #if defined(__MMI_VUI_WIDGET_MRE__)
                mem_size = mmi_res_get_app_base_mem_size(VAPP_WIDGET_MRE);
            #else
                mem_size = -1;
            #endif
            break;
            
        case VM_APPMGR_LAUNCHER_PACKAGE_FLAG:
            #if defined(__MMI_VUI_LAUNCHER_MRE__)
                #if defined(__MMI_VUI_LAUNCHER_MRE_USE_ASM__)
                    mem_size = VAPP_LAUNCHER_MRE_ASM_SIZE;
                #else
                    mem_size = VAPP_LAUNCHER_MRE_GLOBAL_SIZE;
                #endif
            #else /* defined(__MMI_VUI_LAUNCHER_MRE__) */
                mem_size = -1;
            #endif /* defined(__MMI_VUI_LAUNCHER_MRE__) */
            break;
            
        case VM_APPMGR_WALLPAPER_PACKAGE_FLAG:
            #if defined(__MMI_VUI_WALLPAPER_MRE__)
                mem_size = mmi_res_get_app_base_mem_size(VAPP_WALLPAPER_MRE);
            #else
                mem_size = -1;
            #endif
            break;
            
        case VM_APPMGR_SCRLOCK_PACKAGE_FLAG:
            #if defined(__MMI_VUI_SCREEN_LOCK_MRE__)
                mem_size = VAPP_SCRNLOCK_MRE_HEAP_SIZE;
            #else
                mem_size = -1;
            #endif
            break;
            
        default:
            mem_size = -1;
            break;
    }
    
    return mem_size;
}

VMBOOL vm_clipboard_is_available(void)
{
#ifdef __MMI_CLIPBOARD__
    return TRUE;
#else
    return FALSE;
#endif
}

#ifdef __MMI_CLIPBOARD__
VMBOOL vm_clipboard_text_set_data(const VMWSTR str, VMUINT str_len)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_clipboard_unicodetext_data_struct data;
    VMWCHAR buffer[MMI_CLIPBOARD_MAX_SIZE/2];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    vm_log_info("vm_clipboard_text_set_data(), str=%d, str_len=%d", str, str_len);
    if (NULL == str)
    {
        if (mmi_clipboard_get_data_by_type(MMI_CLIPBOARD_FORMAT_UNICODETEXT) == NULL)
        {
            return TRUE;
        }
        else
        {
            return (VMBOOL)mmi_clipboard_empty_data_by_type(MMI_CLIPBOARD_FORMAT_UNICODETEXT);
        }
    }

    if (str_len == 0)
    {
        return FALSE;
    }

    if (str_len >= MMI_CLIPBOARD_MAX_SIZE/2)
    {
        data.len = MMI_CLIPBOARD_MAX_SIZE/2 - 1;
    }
    else
    {
        data.len = (S32)str_len;
    }
    mmi_ucs2ncpy((CHAR*)buffer, (CHAR*)str, data.len);
    buffer[data.len] = 0;
    data.len++;
    data.data = (S8*)buffer;
    if (NULL == mmi_clipboard_set_data(MMI_CLIPBOARD_FORMAT_UNICODETEXT, &data))
    {
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}


VMWSTR vm_clipboard_text_get_data(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_clipboard_unicodetext_data_struct *data;
    VMWSTR read_buf;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    data = mmi_clipboard_get_data_by_type(MMI_CLIPBOARD_FORMAT_UNICODETEXT);
    if (data == NULL || data->data == NULL || data->len == 0)
    {
        return NULL;
    }
    else
    {
        read_buf = (VMWSTR)data->data;
        read_buf[data->len] = 0;
        return read_buf;
    }
}
#endif /* __MMI_CLIPBOARD__ */

VMINT vm_get_sys_sym(VMCHAR* func_name)
{
	return 0;
}

#endif /* __MRE_CORE_BASE__ */
