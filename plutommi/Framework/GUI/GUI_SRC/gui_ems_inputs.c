/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*****************************************************************************
 *
 * Filename:
 * ---------
 *   gui_ems_inputs.c
 *
 * Project:
 * --------
 *   MAUI
 *
 * Description:
 * ------------
 *   Ems editor layout
 *
 * Author:
 * -------
 * -------
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/
//#include "mmi_frm_gprot.h"
//#include "WguiCategoryGprot.h"
//#include "lcd_sw_rnd.h"
#if defined(__UI_PAGING_IN_MULTILINE_EDITOR__)
#endif 

#ifdef __MMI_INDIC_ALG__
#include "IndicEngineGprot.h"
#define MAX_EDITOR_DISP_LEN      60
#endif /* __MMI_INDIC_ALG__ */ 

#include "LangModuleGProt.h"


/* MTK Elvis for R2L characters */
#include "BIDIDEF.h"
#include "BIDIProt.h"

#include "gui_inputs_internal.h"
#include "IMERes.h"
#if defined (__MMI_ARSHAPING_ENGINE__)
//#include "ArabicGProt.h"
#endif 

    #include "MMIDataType.h"
    #include "gui_ems.h"
    #include "gui_data_types.h"
    #include "ems.h"
    #include "kal_general_types.h"
    #include "string.h"
    #include "wgui_inputs.h"
    #include "gui_scrollbars.h"
    #include "CustThemesRes.h"
    #include "gui.h"
    #include "wgui_categories_util.h"
    #include "gdi_include.h"
    #include "mmi_rp_app_uiframework_def.h"
    #include "gui_inputs.h"
    #include "PixcomFontEngine.h"
    #include "MMI_features.h"
    #include "FontRes.h"
    #include "lcd_sw_inc.h"
    #include "kal_public_api.h"
    #include "DebugInitDef_Int.h"
    #include "gui_config.h"
    #include "Unicodexdcl.h"
    #include "gui_themes.h"
    #include "ImeGprot.h"
    
    #include "gdi_datatype.h"

#ifdef UI_EMS_SUPPORT

/* static function declaration */
static U8 gui_get_ems_current_cluster(
            UI_EMS_input_box *b,
            ems_input_box_show_struct *bs,
            UI_character_type *current_character_p,
            U16 cur_index,
            EMSObject **current_object_p);

static U8 gui_get_ems_pure_text_cluster(
            UI_EMS_input_box *b,
            ems_input_box_show_struct *bs,
            UI_character_type *current_character_p,
            U16 cur_index);

static void gui_parse_ems_object(
                UI_EMS_input_box *b,
                ems_input_box_show_struct *bs,
                gui_editor_character_unit_struct *unit);

static void gui_parse_ems_text(
                UI_EMS_input_box *b,
                ems_input_box_show_struct *bs,
                UI_character_type current_character,
                gui_editor_character_unit_struct *unit);

static U16 gui_map_ems_cursor_to_line_offset(UI_EMS_input_box *b, ems_input_box_show_struct *bs);
static S32 gui_get_ems_current_object(ems_input_box_show_struct *bs, S32 disp_count);
static U16 gui_check_ems_character_highlight(UI_EMS_input_box *b, ems_input_box_show_struct *bs, U16 count);
static void gui_draw_ems_current_line_highlight(UI_EMS_input_box *b, ems_input_box_show_struct *bs);
static void gui_draw_ems_object(UI_EMS_input_box *b, ems_input_box_show_struct *bs);
static void gui_draw_ems_single_character(UI_EMS_input_box *b, ems_input_box_show_struct *bs);
static void gui_handle_ems_cursor(UI_EMS_input_box *b, ems_input_box_show_struct *bs);
static U32 gui_check_ems_is_in_range(EMSData *data, EMSPosition *p, EMSPosition *start, EMSPosition *end);
static void gui_find_ems_cursor_position(UI_EMS_input_box *b, ems_input_box_show_struct *bs);
static void gui_set_ems_cursor_at_current_object(UI_EMS_input_box *b, ems_input_box_show_struct *bs);
static U8 gui_check_ems_cursor_for_current_position(UI_EMS_input_box *b, ems_input_box_show_struct *bs);
static void gui_draw_ems_extention_charset_cluster(UI_EMS_input_box *b, ems_input_box_show_struct *bs);
static void gui_draw_ems_text(UI_EMS_input_box *b, ems_input_box_show_struct *bs);
static MMI_BOOL gui_ems_inputs_is_cluster_gap(UI_EMS_input_box *b, ems_input_box_show_struct *bs);
#ifdef __MMI_BIDI_ALG__
static void gui_apply_ems_text_format(UI_EMS_input_box *b, ems_input_box_show_struct *bs);
#endif

/*****************************************************************************
 * FUNCTION
 *  gui_init_ems_show_struct
 * DESCRIPTION
 *  
 * PARAMETERS
 *  b       [IN]     
 *  bs      [OUT]     
 * RETURNS
 *  void
 *****************************************************************************/
void gui_init_ems_show_struct(UI_EMS_input_box *b, ems_input_box_show_struct *bs)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* maybe this init-zero can be  optimized */
    memset(bs, 0, sizeof(ems_input_box_show_struct));

    bs->default_direction = BIDI_L;
    bs->flags = b->flags;

    b->hilite_s_x = 0;
    b->hilite_s_y = 0;
    b->hilite_e_x = 0;
    b->hilite_e_y = 0;
}

#ifdef __MMI_BIDI_ALG__
/*****************************************************************************
 * FUNCTION
 *  gui_get_ems_text_language_type
 * DESCRIPTION
 *  
 * PARAMETERS
 *  b       [?]     
 *  bs      [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void gui_get_ems_text_language_type(UI_EMS_input_box *b, ems_input_box_show_struct *bs)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 iCount;
    U8 lastest_char_type;
    U16 strongCharType = 0xFFFF;
    const sIMEModeDetails *mode_details_ptr = NULL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (b->data->textLength != 0)
    {
        for (iCount = 0; iCount < (U32) (b->data->textLength >> 1); iCount++)
        {
            bidi_get_char_type((U8*) (b->data->textBuffer + iCount * ENCODING_LENGTH), (U8*) & lastest_char_type);
            if ((lastest_char_type == AL 
                || lastest_char_type == BIDI_L 
                || lastest_char_type == BIDI_R
                || lastest_char_type == AN)
                && strongCharType == 0xFFFF)
            {
                strongCharType = lastest_char_type;
            }

            if ((lastest_char_type == AL) || (lastest_char_type == AN) || (lastest_char_type == BIDI_R))
            {
                bs->arabic_char_flag = MMI_TRUE;
                break;
            }
        }

        bidi_get_char_type(b->data->textBuffer, (U8*) & bs->default_direction);
    #ifdef GUI_INPUTBOX_ALIGNMENT_WHEN_EXIST_R2L_CHAR
        if (bs->arabic_char_flag)
    #else 
        if (strongCharType == AL || strongCharType == BIDI_R || strongCharType == AN)
    #endif 
        {
            bs->default_direction = BIDI_R;
        }
        else
        {
            bs->default_direction = BIDI_L;

            if (strongCharType == 0xFFFF)
            {
                if (mmi_imc_is_connected())
                {
                    mode_details_ptr = mmi_imm_get_input_mode_array_item(mmi_imm_get_curr_input_mode());
                    
                    if (mode_details_ptr)
                    {
                        if (mode_details_ptr->lang_id == IME_WRITING_LANG_AR
                            || mode_details_ptr->lang_id == IME_WRITING_LANG_UR
                            || mode_details_ptr->lang_id == IME_WRITING_LANG_PS
                            || mode_details_ptr->lang_id == IME_WRITING_LANG_HE)
                        {
                            bs->default_direction = BIDI_R;
                        }
                    }
                }
            }
        }
    }
    else
    {
        if (mmi_imc_is_connected())
        {
            mode_details_ptr = mmi_imm_get_input_mode_array_item(mmi_imm_get_curr_input_mode());
            
            if (mode_details_ptr)
            {
                if (mode_details_ptr->lang_id == IME_WRITING_LANG_AR
                     || mode_details_ptr->lang_id == IME_WRITING_LANG_UR
                     || mode_details_ptr->lang_id == IME_WRITING_LANG_PS
                     || mode_details_ptr->lang_id == IME_WRITING_LANG_HE)
                {
                    bs->default_direction = BIDI_R;
                }
            }
        }
    }
}

/*****************************************************************************
 * FUNCTION
 *  gui_translate_ems_bidi_text
 * DESCRIPTION
 *  
 * PARAMETERS
 *  b       [?]     
 *  bs      [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void gui_translate_ems_bidi_text(UI_EMS_input_box *b, ems_input_box_show_struct *bs)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 num_char, iCount, i;
    U8 char_type;
    pBOOL line_arabic_char_flag = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (bs->arabic_char_flag || bs->default_direction != BIDI_L)
    {
        num_char = g_editor_line.line_char_count;

        MMI_ASSERT(!(num_char > ((GUI_INPUTS_MAX_NUM_OF_CHAR_FOR_EACH_LINE >> 1) - 1)));

        if (num_char == 0)
        {
            return;
        }

        /* adjust the cursor position */
        if (g_editor_line.cursor_line_flag)
            bs->logical_cur_pos = gui_map_ems_cursor_to_line_offset(b, bs);
        else
            bs->logical_cur_pos = 0xFFFF;

        for (iCount = 0; iCount < num_char; iCount++)
        {
            bidi_get_char_type((U8*) (bs->total_str + iCount * ENCODING_LENGTH), (U8*) & char_type);
            if ((char_type == AL) 
                || (char_type == AN) 
                || (char_type == BIDI_R)
                || (char_type == WS)
                || (char_type == NSM))
            {
                line_arabic_char_flag = MMI_TRUE;
                break;
            }
        }

        bidi_main_ext(
            bs->total_str,
            (U16) num_char,
            bs->logical_cur_pos,
            g_editor_line.visual_str,
            &bs->visual_str_len,
            &bs->visual_cur_pos,
            g_editor_line.logic_to_visual_map,
            g_editor_line.visual_to_logic_map,
            0,
            MMI_bidi_input_type,
            0,
            (bs->default_direction == BIDI_L) ? P_LTR : (line_arabic_char_flag ? P_RTL : P_LTR));

        bs->current_text_p = g_editor_line.visual_str;
        
        g_editor_line.bidi_done_flag = 1;
        gui_convert_bidi_map_to_unit_map(bs->visual_str_len);

        if (bs->visual_cur_pos != 0xFFFF)
        {
            g_editor_line.cursor_unit_index = g_editor_line.line_unit_count;

            for (i = 0, num_char = 0; i<g_editor_line.visual_unit_count; i++)
            {
                iCount = g_editor_line.visual_to_logic_map[i];
                num_char += g_editor_line.line_char[iCount].c_info.data_len;
                if (bs->visual_cur_pos < num_char)
                {
                    g_editor_line.cursor_unit_index = iCount;
					break;
                }
            }
        }
    }
}
#endif /* __MMI_BIDI_ALG__ */ 


/*****************************************************************************
 * FUNCTION
 *  gui_prepare_ems_show_area
 * DESCRIPTION
 *  
 * PARAMETERS
 *  b       [?]     
 *  bs      [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void gui_prepare_ems_show_area(UI_EMS_input_box *b, ems_input_box_show_struct *bs)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (r2lMMIFlag)
    {
        if (b->flags & UI_EMS_INPUT_BOX_DISABLE_SCROLLBAR)
        {
            bs->x1 = b->x;
        }
        else if (b->flags & UI_EMS_INPUT_BOX_AUTO_DISABLE_SCROLLBAR)
        {
            if (b->vbar.scale < b->vbar.range)
            {
                bs->x1 = b->x + b->vbar.width + 1;
            }
            else
            {
                bs->x1 = b->x;
            }
        }
        else
        {
            bs->x1 = b->x + b->vbar.width + 1;
        }
    }
    else
    {
        bs->x1 = b->x;
    }

    bs->y1 = b->y;
    bs->x2 = b->x + b->width - 2;  /* one pixtel for cursor */
    bs->y2 = bs->y1 + b->height - 1;
    b->display_height = 0;
    bs->edit_width = bs->x2 - bs->x1;

}


/*****************************************************************************
 * FUNCTION
 *  gui_draw_ems_background_area
 * DESCRIPTION
 *  
 * PARAMETERS
 *  b       [?]     
 *  bs      [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void gui_draw_ems_background_area(UI_EMS_input_box *b, ems_input_box_show_struct *bs)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    UI_filled_area f;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!(bs->flags & UI_EMS_INPUT_BOX_DISABLE_DRAW))
    {
        if (bs->flags & UI_EMS_INPUT_BOX_STATE_SELECTED)
        {
            f = *b->selected_filler;
        }
        else if (bs->flags & UI_EMS_INPUT_BOX_STATE_DISABLED)
        {
            f = *b->disabled_filler;
        }
        else
        {
            f = *b->normal_filler;
        }

        gui_set_clip(b->x, bs->y1, bs->x2 + 2, bs->y2 + 2);

        if (!(bs->flags & UI_EMS_INPUT_BOX_DISABLE_BACKGROUND)) /* if not disable background then do ... */
        {
            if (!(bs->flags & UI_EMS_INPUT_BOX_INCLUDE_INFO_AREA))
            {
                if ((wgui_is_wallpaper_on_bottom() == MMI_TRUE) &&
                    (bs->flags & UI_EMS_INPUT_BOX_TRANSPARENT_BACKGROUND))
                {
                    gdi_draw_solid_rect(b->x, bs->y1, bs->x2, bs->y2, GDI_COLOR_TRANSPARENT);
                }
                else
                {
                    gui_draw_filled_area(b->x, bs->y1, bs->x2, bs->y2, &f);
                }
            }
            else
            {
                gui_set_clip(b->x, bs->y1 - wgui_EMS_inputbox_information_bar_height, bs->x2, bs->y2);

                f.flags = UI_FILLED_AREA_TYPE_BITMAP;
           //     f.b = get_image(WGUI_VOLUME_LEVEL1);
#ifndef __MMI_FTE_SUPPORT__
                if ((wgui_is_wallpaper_on_bottom() == MMI_TRUE) &&
                    (bs->flags & UI_EMS_INPUT_BOX_TRANSPARENT_BACKGROUND))
                {
                    gdi_draw_solid_rect(
                        b->x,
                        bs->y1 - wgui_EMS_inputbox_information_bar_height,
                        bs->x2,
                        bs->y2,
                        GDI_COLOR_TRANSPARENT);
                }
                else
#endif
                {
                    gui_draw_filled_area(b->x, bs->y1 - wgui_EMS_inputbox_information_bar_height, bs->x2, bs->y2, &f);
                }
                /* 070405 Calvin End */
                gui_draw_rectangle(b->x, bs->y1, bs->x2, bs->y2, b->boundary_color);

                if (bs->flags & UI_MULTI_LINE_INPUT_BOX_USE_PRESET_CLIPPING)
                {
                    gui_set_clip_preset(bs->x1, bs->y1, bs->x2 + 2, bs->y2 + 2);
                }
                else
                {
                    gui_set_clip(bs->x1, bs->y1, bs->x2 + 2, bs->y2 + 2);
                }
            }
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  gui_set_ems_text_area_range
 * DESCRIPTION
 *  
 * PARAMETERS
 *  b       [?]     
 *  bs      [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void gui_set_ems_text_area_range(UI_EMS_input_box *b, ems_input_box_show_struct *bs)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    UI_filled_area f;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!(bs->flags & UI_EMS_INPUT_BOX_DISABLE_SCROLLBAR) && !r2lMMIFlag)
    {
        if (bs->flags & UI_EMS_INPUT_BOX_AUTO_DISABLE_SCROLLBAR)
        {
            if ((b->vbar.scale < b->vbar.range))
                bs->x2 -= b->vbar.width + 1;
        }
        else
            bs->x2 -= b->vbar.width + 1;
    }

    bs->edit_width = (bs->x2 - bs->x1 - 3);
    bs->ty = 2;

    if (bs->flags & UI_EMS_INPUT_BOX_DISPLAY_HEADER)
    {
        S32 h, ty1, ty2;

        h = b->measure_header();
        b->header_height = h;
        ty1 = bs->y1 + bs->ty + b->display_y - 2;
        ty2 = bs->y1 + bs->ty + b->display_y + h - 1;

        gui_push_clip();

        if (bs->flags & UI_EMS_INPUT_BOX_STATE_SELECTED)
        {
            f = *b->selected_filler;
        }
        else if (bs->flags & UI_EMS_INPUT_BOX_STATE_DISABLED)
        {
            f = *b->disabled_filler;
        }
        else
        {
            f = *b->normal_filler;
        }
        if ((f.flags & UI_FILLED_AREA_DOUBLE_BORDER) == UI_FILLED_AREA_DOUBLE_BORDER)
        {
            gui_set_clip(b->x + 2, bs->y1 + 2, bs->x2 - 2, bs->y2  - 2);
        }
        else if (f.flags & UI_FILLED_AREA_BORDER)
        {
            gui_set_clip(b->x + 1, bs->y1 + 1, bs->x2 - 1, bs->y2  - 1);
        }
        else
        {
            gui_set_clip(b->x, bs->y1, bs->x2, bs->y2);
        }

        if (!(bs->flags & UI_EMS_INPUT_BOX_DISABLE_DRAW) && (ty2 > bs->y1))
        {
            b->display_header(bs->x1, ty1, bs->x2, ty2);
        }
        else if (!(bs->flags & UI_EMS_INPUT_BOX_DISABLE_DRAW))
        {
            UI_inputbox_hide_cursor();
        }
        gui_pop_clip();
        bs->ty += h;
        bs->ty++;   /* hjf, for keep one pixel between header & first line text */
    }
    else
    {
        b->header_height = 0;
    }

    if (!(bs->flags & UI_EMS_INPUT_BOX_DISABLE_DRAW))
    {
        gui_set_clip(bs->x1 + 1, bs->y1 + 1, bs->x2, bs->y2 - 1);
        EMS_SET_FONT(&UI_EMS_inputbox_medium_font);
        EMS_SET_TEXT_COLOR(b->normal_text_color);
    }

}


/*****************************************************************************
 * FUNCTION
 *  gui_adjust_ems_cursor_for_language
 * DESCRIPTION
 *  
 * PARAMETERS
 *  b       [?]     
 *  bs      [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void gui_adjust_ems_cursor_for_language(UI_EMS_input_box *b, ems_input_box_show_struct *bs)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    EMSPosition temp_cursor_position;
    mmi_lm_cluster_info cur_cluster;
    UI_buffer_type start, end, cursor_p, pre_cluster_p;
    EMSData *data = b->data;
    UI_character_type current_character;
    EMSObject *current_object;
    U8 object_type;
    S32 movement;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (bs->find_new_cursor_flag != NORMAL_CURSOR
        || !bs->cursor_line_found_flag
        || g_editor_line.cursor_line_flag == 0
        || EMS_view_mode)
    {
        /* the current cursor is invalid */
        return;
    }

    temp_cursor_position = b->data->CurrentPosition;
    object_type = gui_EMS_input_box_get_previous_object(data, &temp_cursor_position, &current_character, &current_object);
    if (object_type != 1)
        return;

    temp_cursor_position = b->data->CurrentPosition;
    object_type = gui_EMS_input_box_get_next_object(data, &temp_cursor_position, &current_character, &current_object);
    if (object_type != 1)
        return;

    if (b->current_line >= 1)
    {
        start = data->textBuffer + b->line_positions_text_offset[b->current_line - 1];
    }
    else
        start = data->textBuffer;

    cursor_p = data->textBuffer + data->CurrentPosition.OffsetToText;
    end = data->textBuffer + data->textLength;

    mmi_lm_get_prev_cluster(start, end, cursor_p, MMI_TRUE, &cur_cluster);
    pre_cluster_p = cur_cluster.data_ptr;
    mmi_lm_get_next_cluster(start, end, pre_cluster_p, MMI_TRUE, &cur_cluster);
    movement = (S32)(cur_cluster.data_ptr - cursor_p)/ENCODING_LENGTH;

    if (movement > 0)
    {
         ForwardCurrentPosition(data, (U16)movement);
         gui_EMS_input_box_set_text_format_cursor_position(b);
    } 
}


/*****************************************************************************
 * FUNCTION
 *  gui_prepare_ems_new_line_loop
 * DESCRIPTION
 *  
 * PARAMETERS
 *  b       [?]     
 *  bs      [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void gui_prepare_ems_new_line_loop(UI_EMS_input_box *b, ems_input_box_show_struct *bs)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* set the last line end format to the current line */
    bs->line_start_text_format = bs->line_end_text_format;

    /* set the current line format */
#ifdef __MMI_MESSAGES_EMS__
    gui_EMS_input_box_set_text_format(b, bs->line_start_text_format);
#else /* __MMI_MESSAGES_EMS__ */ 
    {
        EMS_SET_FONT(&UI_EMS_inputbox_medium_font);
        EMS_SET_TEXT_COLOR(UI_EMS_inputbox_text_color);
        b->flags &= ~(UI_EMS_INPUT_BOX_CURRENT_ALIGN_LEFT |
                      UI_EMS_INPUT_BOX_CURRENT_ALIGN_RIGHT | UI_EMS_INPUT_BOX_CURRENT_ALIGN_CENTER);
    }
#endif /* __MMI_MESSAGES_EMS__ */ 

    /* restore the last UI_EMS_current_alignment */
    UI_EMS_current_alignment = lastest_EMS_alignment;
    
    g_editor_line.cursor_line_flag = 0;
    g_editor_line.bidi_done_flag = 0;
}


/*****************************************************************************
 * FUNCTION
 *  gui_find_ems_one_line
 * DESCRIPTION
 *  
 * PARAMETERS
 *  b       [?]     
 *  bs      [?]     
 * RETURNS
 *  
 *****************************************************************************/
U8 gui_find_ems_one_line(UI_EMS_input_box *b, ems_input_box_show_struct *bs)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 count = 0, current_char_type;
    EMSALIGNMENT temp_alignment;
    UI_character_type current_character = 0;
    EMSObject *current_object = NULL, *break_text_format = NULL;
    EMSPosition break_position, backup_position;
    U16 break_line_count = 0, break_unit_count = 0, break_line_width = 0, break_line_height = 0;
    U16 break_ascent = 0, break_dscent = 0, break_highlight = 0;
    S32 break_text_format_count = 0, temp_width = 0, former_width = 0, disp_width = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* init the line information */
    g_editor_line.line_height = gui_inputs_get_char_info_for_all_lang(MEDIUM_FONT, &g_editor_line.line_ascent, &g_editor_line.line_dscent);
    g_editor_line.line_height += EDITOR_LINE_ADDITION_PIXTEL;
    g_editor_line.line_ascent += EDITOR_LINE_UPPER_PIXTEL;
    g_editor_line.line_dscent += EDITOR_LINE_LOWER_PIXTEL;
    g_editor_line.line_char_count = 0;
    g_editor_line.line_unit_count = 0;
    g_editor_line.highlight_flag = 0;
#ifdef __MMI_INDIC_ALG__
    g_editor_line.line_width = 1;
#else 
    g_editor_line.line_width = 0;
#endif 

    bs->line_start_position = bs->current_position;
    g_editor_line.line_start_p = b->data->textBuffer + bs->current_position.OffsetToText;
    bs->current_text_p = g_editor_line.line_start_p;
    break_position = bs->current_position;

    while (g_editor_line.line_char_count < (GUI_INPUTS_MAX_NUM_OF_CHAR_FOR_EACH_LINE/2))
    {
        backup_position = bs->current_position;

        if (TestLastPosition(b->data, &bs->current_position))
        {
            if (UI_EMS_inputbox_current_font.italic && g_editor_line.line_char_count != 0)
            {
                g_editor_line.line_width += 3;
            }
            bs->line_end_position = bs->current_position;
            return 0;
        }

        /* get the current character type */
        g_editor_line.line_char[count].offset_text =
            bs->current_position.OffsetToText - bs->line_start_position.OffsetToText;
        g_editor_line.line_char[count].char_type = gui_get_ems_current_cluster(b, bs, &current_character, count, &current_object);
        current_char_type = g_editor_line.line_char[count].char_type;
        g_editor_line.line_char[count].highlight_flag = 0;
        g_editor_line.line_char[count].object_unit = NULL;
        g_editor_line.line_char[count].obj_width = 0;
        g_editor_line.line_char[count].obj_height = 0;

#if defined(__MMI_LANG_THAI__)
        if (g_editor_line.line_char[count].char_type == THAI_CLUSTER)
        {
            if (b->data->CurrentPosition.OffsetToText > backup_position.OffsetToText
                && b->data->CurrentPosition.OffsetToText < backup_position.OffsetToText + g_editor_line.line_char[count].c_info.data_len * ENCODING_LENGTH)
            {
                /* adjust the cursor position for THAI cluster */
                ForwardCurrentPosition(b->data, 
                (U16)(g_editor_line.line_char[count].c_info.data_len - (b->data->CurrentPosition.OffsetToText - backup_position.OffsetToText)/ENCODING_LENGTH));
            }
        }
#endif

        switch (g_editor_line.line_char[count].char_type)
        {
            case EMS_OBJECT_UNIT:
            {
                /* parsing ems object unit */
                g_editor_line.line_char[count].object_unit = current_object;
                gui_parse_ems_object(b, bs, &(g_editor_line.line_char[count]));
            }
                break;

            default:
            {
                /* parsing ems text unit */
                gui_parse_ems_text(b, bs, current_character, &(g_editor_line.line_char[count]));
            }
                break;
        }

        if (count > 0)
        {
            if (g_editor_line.line_char[count-1].char_type == EMS_OBJECT_UNIT)
                g_editor_line.line_char[count].c_info.is_connect = MMI_LM_CLUSTER_ATTR_CONNECT;
        }

        /* check the highlight information */
        g_editor_line.line_char[count].highlight_flag = (U8)gui_check_ems_character_highlight(b, bs, count);
        if (g_editor_line.highlight_flag == 0 && g_editor_line.line_char[count].highlight_flag)
            g_editor_line.highlight_flag = 1;

        if (current_char_type == EMS_OBJECT_UNIT)
        {
            disp_width = temp_width = former_width
                + g_editor_line.line_char[count].obj_width 
                + g_editor_line.line_char[count].c_info.rx
                + g_editor_line.line_char[count].c_info.is_gap;
        }
        else
        {
            /* Check if there is gap between pevious char */
            g_editor_line.cur_read = count;
            if (gui_ems_inputs_is_cluster_gap(b, bs))
            {
                disp_width = temp_width = former_width
                    + g_editor_line.line_char[count].c_info.adv_x 
                    + g_editor_line.line_char[count].c_info.rx
                    + g_editor_line.line_char[count].c_info.is_gap;
            }
            else
            {
                disp_width = temp_width = former_width
                    + g_editor_line.line_char[count].c_info.adv_x 
                    + g_editor_line.line_char[count].c_info.rx;
            }
        }
        
        if (g_editor_line.line_char[count].c_info.w > g_editor_line.line_char[count].c_info.adv_x)
            disp_width += (g_editor_line.line_char[count].c_info.w - g_editor_line.line_char[count].c_info.adv_x);
        
        if (disp_width < (bs->edit_width)
            && (g_editor_line.line_char_count + g_editor_line.line_char[count].c_info.data_len < (GUI_INPUTS_MAX_NUM_OF_CHAR_FOR_EACH_LINE/2)))
        {
            /* backup the break line info if necessary */
            if (count > 0 
                && g_editor_line.line_char[count].c_info.is_connect == MMI_LM_CLUSTER_ATTR_DISCONNECT
                && g_editor_line.line_width != 0)
            {
                break_line_count = g_editor_line.line_char_count;
                break_unit_count = g_editor_line.line_unit_count;
                break_line_width = g_editor_line.line_width + 1;
                break_line_height = g_editor_line.line_height;
                break_ascent = g_editor_line.line_ascent;
                break_dscent = g_editor_line.line_dscent;
                break_position = backup_position;
                break_text_format = bs->line_end_text_format;
                break_text_format_count = bs->text_format_count;
                break_highlight = bs->word_highlight;
                    
            }

            /* the current character is belong to the current line */
            former_width = temp_width;
            
            /* the current line real width */
            g_editor_line.line_width = disp_width + 1;
            
            if (g_editor_line.line_ascent < g_editor_line.line_char[count].c_info.by + EDITOR_LINE_UPPER_PIXTEL)
                g_editor_line.line_ascent = g_editor_line.line_char[count].c_info.by + EDITOR_LINE_UPPER_PIXTEL;
            
            /* update the line dscent */
            if (g_editor_line.line_dscent < g_editor_line.line_char[count].c_info.h 
                                                - g_editor_line.line_char[count].c_info.by + EDITOR_LINE_LOWER_PIXTEL)
                g_editor_line.line_dscent = g_editor_line.line_char[count].c_info.h 
                                                - g_editor_line.line_char[count].c_info.by + EDITOR_LINE_LOWER_PIXTEL;

            g_editor_line.line_height = g_editor_line.line_ascent + g_editor_line.line_dscent;

            /* we translate one ems object to an Neutral character, so the line_char_count include the ems object */
            g_editor_line.line_char_count += g_editor_line.line_char[count].c_info.data_len;
            bs->current_text_p += g_editor_line.line_char[count].c_info.data_len * ENCODING_LENGTH;

            /* update the text_format if necessary */
            if (bs->text_format_count > 0 && current_char_type != EMS_OBJECT_UNIT)
            {
                bs->text_format_count -= g_editor_line.line_char[count].c_info.data_len;
                if ((bs->text_format_count <= 0) && (bs->current_position.OffsetToText <= b->data->textLength))
                {
                    temp_alignment = UI_EMS_current_alignment;
#ifdef __MMI_MESSAGES_EMS__
                    /* restore the text format to the default */
                    gui_EMS_input_box_set_text_format(b, &UI_EMS_normal_text_format_object);
#endif
                    /*
                     * the line alignment is different to the other format. 
                     * It is applied to the current line, not the next line 
                     */
                    /* if (g_editor_line.line_char[count].char_type == CRLF_CLUSTER
                        || UI_TEST_LF_CHARACTER(current_character) 
                        || UI_TEST_CR_CHARACTER(current_character)
                        || bs->current_position.OffsetToText == b->data->textLength) */
                        UI_EMS_current_alignment = temp_alignment;

                    bs->line_end_text_format = &UI_EMS_normal_text_format_object;
                }
            }

            count++;
            g_editor_line.line_unit_count = count;
        }
        else
        {
            /* the current line is end */
            if (count > 0 && g_editor_line.line_char[count].c_info.is_connect == MMI_LM_CLUSTER_ATTR_DISCONNECT)
                break_line_count = 0;
            bs->current_position = backup_position;
            break;
        }

        if (current_char_type != EMS_OBJECT_UNIT
            && (UI_TEST_LF_CHARACTER(current_character) 
                || UI_TEST_CR_CHARACTER(current_character)
                || UI_STRING_END_OF_STRING_CHARACTER(current_character)))
        {
            /* the current line is end */
            bs->line_end_position = bs->current_position;
            return 1;
        }
    }

    if (break_line_count)
    {
        /* This line should be cut*/
        g_editor_line.line_char_count = break_line_count;
        g_editor_line.line_unit_count = break_unit_count;
        g_editor_line.line_width = break_line_width;
        g_editor_line.line_height = break_line_height;
        g_editor_line.line_ascent = break_ascent;
        g_editor_line.line_dscent = break_dscent;
        bs->current_position = break_position;
        bs->line_end_text_format = break_text_format;
        bs->text_format_count = break_text_format_count;
        bs->word_highlight = (U8)break_highlight;
    }

    bs->line_end_position = bs->current_position;
    return 1;
}


/*****************************************************************************
 * FUNCTION
 *  gui_get_ems_current_cluster
 * DESCRIPTION
 *  
 * PARAMETERS
 *  b                       [?]         
 *  bs                      [?]         
 *  current_character_p     [?]         
 *  cur_index               [IN]         
 *  current_object_p        [IN]        
 * RETURNS
 *  
 *****************************************************************************/
U8 gui_get_ems_current_cluster(
    UI_EMS_input_box *b,
    ems_input_box_show_struct *bs,
    UI_character_type *current_character_p,
    U16 cur_index,
    EMSObject **current_object_p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 object_type = 0, i, t;
    U32 cnt;
    UI_character_type current_character = 0;
    EMSObject *current_object;
    EMSPosition current_position;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    current_position = bs->current_position;

    /* get the next content */
    object_type = gui_EMS_input_box_get_next_object(b->data, &current_position, &current_character, &current_object);

    switch (object_type)
    {
        case 0:
            /* we should always to get one content */
            MMI_ASSERT(0);
            break;

        case 1:
            /* get one character. so we check whether it's a cluster of some language */
            object_type = gui_get_ems_pure_text_cluster(b, bs, current_character_p, cur_index);
            if (g_editor_line.line_char[cur_index].c_info.data_len > 1)
            {
                /* forward the current_position */
                i = 1;
                
                while(i < g_editor_line.line_char[cur_index].c_info.data_len)
                {
                    t = gui_EMS_input_box_get_next_object(b->data, &current_position, &current_character, &current_object);
                    if (t == 1)
                        i++;
                }
            }
            break;

        case 2:
            gui_get_ems_pure_text_cluster(b, bs, current_character_p, cur_index);
            cnt = g_editor_line.line_char[cur_index].c_info.is_connect;
            mmi_lm_cluster_init(&g_editor_line.line_char[cur_index].c_info);
            g_editor_line.line_char[cur_index].c_info.is_connect = cnt;
            *current_object_p = current_object;
            object_type = EMS_OBJECT_UNIT;
            break;
    }

    bs->current_position = current_position;
    return object_type;
}


/*****************************************************************************
 * FUNCTION
 *  gui_get_ems_pure_text_cluster
 * DESCRIPTION
 *  
 * PARAMETERS
 *  b                       [?]     
 *  bs                      [?]     
 *  current_character_p     [?]     
 *  cluster_count_p         [?]     
 * RETURNS
 *  
 *****************************************************************************/
U8 gui_get_ems_pure_text_cluster(
    UI_EMS_input_box *b,
    ems_input_box_show_struct *bs,
    UI_character_type *current_character_p,
    U16 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    UI_buffer_type text_p, text_end_p;
    UI_character_type current_character;
    mmi_lm_cluster_info pre2_cluster, pre_cluster;
    mmi_lm_cluster_info_p pre_cl, pre2_cl;
    EMSObject *temp_object;
    U16 max_n;


    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    text_p = text_end_p = (UI_buffer_type) (b->data->textBuffer + bs->current_position.OffsetToText);
    UI_STRING_GET_NEXT_CHARACTER(text_end_p, current_character);

    /* at first, we check the nearest ems object to get the max cluster length range */
    if (bs->current_position.Object)
    {
        temp_object = bs->current_position.Object->next;
        if (temp_object == NULL)
            max_n = 0xFFFF;
        else
            max_n = temp_object->OffsetToText - bs->current_position.OffsetToText;
    }
    else if (b->data->listHead != NULL)
    {
        max_n = b->data->listHead->OffsetToText - bs->current_position.OffsetToText;
    }
    else
        max_n = 0xFFFF;
    
    if (max_n != 0xFFFF)
        text_end_p = text_p + max_n;
    else
        text_end_p = (UI_buffer_type)(b->data->textBuffer + b->data->textLength);
    
    mmi_lm_cluster_init(&g_editor_line.line_char[index].c_info);
    if (index >= 2)
	{
		pre_cl = &g_editor_line.line_char[index - 1].c_info;
        pre2_cl = &g_editor_line.line_char[index - 2].c_info;
        if (g_editor_line.line_char[index - 1].char_type == EMS_OBJECT_UNIT)
        {
            pre_cl = &pre_cluster;
            pre2_cl = &pre2_cluster;
            mmi_lm_cluster_init(&pre_cluster);
            mmi_lm_cluster_init(&pre2_cluster);
        }
        else if(g_editor_line.line_char[index - 2].char_type == EMS_OBJECT_UNIT)
        {
            pre2_cl = &pre2_cluster;
            mmi_lm_cluster_init(&pre2_cluster);
        }
	}
	else if (index == 1)
	{
		pre_cl = &g_editor_line.line_char[index - 1].c_info;
		pre2_cl = &pre2_cluster;
    
        if (g_editor_line.line_char[index - 1].char_type == EMS_OBJECT_UNIT)
        {
            pre_cl = &pre_cluster;
            mmi_lm_cluster_init(&pre_cluster);
        }

		mmi_lm_cluster_init(&pre2_cluster);
	}
	else
    {
        pre_cl = &pre_cluster;
        pre2_cl = &pre2_cluster;
        mmi_lm_cluster_init(&pre_cluster);
        mmi_lm_cluster_init(&pre2_cluster);
    }

    mmi_lm_get_current_cluster(text_p, text_end_p, pre2_cl, pre_cl, &g_editor_line.line_char[index].c_info);
    
    *current_character_p = current_character;
    return gui_get_char_type_by_lm_lang((mmi_lm_lang_enum)(g_editor_line.line_char[index].c_info.lang_id));
}


/*****************************************************************************
 * FUNCTION
 *  gui_parse_ems_object
 * DESCRIPTION
 *  
 * PARAMETERS
 *  b           [?]     
 *  bs          [?]     
 *  unit        [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void gui_parse_ems_object(UI_EMS_input_box *b, ems_input_box_show_struct *bs, gui_editor_character_unit_struct *unit)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#ifdef __MMI_MESSAGES_EMS__
    EMSObject *current_object;
    S32 object_width, object_height;
#endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

#ifdef __MMI_MESSAGES_EMS__
    current_object = unit->object_unit;
    switch (current_object->Type)
    {
        case EMS_TYPE_TEXT_FORMAT:
        {
            bs->line_alignment = current_object->data->text_format.Alignment;
            lastest_EMS_alignment = (EMSALIGNMENT)bs->line_alignment;
            bs->line_end_text_format = current_object;
#ifdef __MMI_MESSAGES_EMS__
            gui_EMS_input_box_set_text_format(b, current_object);
#endif
            bs->text_format_count = ((current_object->data->text_format.textLength) >> 1);
            unit->obj_height= gui_get_character_height();
            unit->obj_width = 0;
            mmi_lm_cluster_init(&unit->c_info);
            unit->c_info.is_gap = MMI_LM_CLUSTER_ATTR_NO_GAP;
            /* unit->c_info.is_connect = MMI_LM_CLUSTER_ATTR_CONNECT; */
        }
            break;

        default:
        {
            gui_EMS_input_box_measure_object(current_object, &object_width, &object_height);
            MMI_ASSERT(object_width <= 0xFF && object_height <= 0xFF);
            unit->c_info.by = ((object_height + 2) > 0x7F ? 0x7F : (object_height + 2));
            unit->c_info.adv_x = object_width;
            unit->c_info.h = object_height + 2;
            unit->c_info.rx = 2;
            unit->obj_width = object_width;
            unit->obj_height = object_height;
            unit->c_info.is_gap = MMI_LM_CLUSTER_ATTR_GAP;
            /* unit->c_info.is_connect = MMI_LM_CLUSTER_ATTR_CONNECT; */
        }
            break;
    }
#else /* __MMI_MESSAGES_EMS__ */ 
    unit->obj_width = 0;
    unit->obj_height = 0;
#endif /* __MMI_MESSAGES_EMS__ */ 

}


/*****************************************************************************
 * FUNCTION
 *  gui_parse_ems_text
 * DESCRIPTION
 *  
 * PARAMETERS
 *  b                       [?]         
 *  bs                      [?]         
 *  current_character       [IN]        
 *  unit                    [?]         
 * RETURNS
 *  void
 *****************************************************************************/
void gui_parse_ems_text(
        UI_EMS_input_box *b,
        ems_input_box_show_struct *bs,
        UI_character_type current_character,
        gui_editor_character_unit_struct *unit)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    EMSObject *temp_object = NULL;
    EMSPosition temp_position;
    UI_character_type next_character;
    mmi_fe_get_string_info_param_struct query;
    U8 type;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if(EMS_USE_CRLF_COMBINATION)
    if (UI_TEST_CR_CHARACTER(current_character))
    {
        temp_position = bs->current_position;
        type = gui_EMS_input_box_get_next_object(b->data, &temp_position, &next_character, &temp_object);
        if (type == 1 && UI_TEST_LF_CHARACTER(next_character))
        {
            unit->char_type = CRLF_CLUSTER;
            unit->c_info.adv_x = 0;
            unit->c_info.w = 0;
            unit->c_info.h = 0;
            unit->c_info.by = 0;
            unit->c_info.data_len = 2;  
            unit->c_info.is_gap = 1;
            bs->current_position = temp_position;
        }
    }
#endif /* (EMS_USE_CRLF_COMBINATION) */ /* (MULTILINE_INPUTBOX_USE_CRLF_COMBINATION) */

#if(EMS_USE_ESC_COMBINATION)
    if (UI_TEST_ESC_CHARACTER(current_character))
    {
        temp_position = bs->current_position;
        type = gui_EMS_input_box_get_next_object(b->data, &temp_position, &next_character, &temp_object);
        if (type == 1)
        {
            memset(&query, 0, sizeof(mmi_fe_get_string_info_param_struct));
            query.String = (U8*)(unit->c_info.data_ptr + ENCODING_LENGTH);
            query.n = 1;
            query.enableTruncated = MMI_FALSE;
            query.w = 0;

            if (next_character == EMS_EURO_SYMBOL_GSM_CHARACTER)
            {
                /* Display Euro Symbol by the real unicode */
                next_character = EMS_EURO_SYMBOL_ORINGINAL_CHARACTER;
                query.String = (U8*)&next_character;
            }

            mmi_fe_get_string_widthheight(&query);

            unit->char_type = EMS_EXT_CHARSET_CLUSTER;
            unit->c_info.data_len = 2;
            unit->c_info.by = query.baseline;
            unit->c_info.h = query.pHeight;
            unit->c_info.adv_x = query.pWidth;
            
            bs->current_position = temp_position;
        }
        else
        {
            unit->c_info.adv_x = 0;
            unit->c_info.h = gui_get_character_height();
        }
    }
#endif /* (EMS_USE_ESC_COMBINATION) */ 

    switch (unit->char_type)
    {
        case SINGLE_CHAR:
        #if(EMS_DISPLAY_SPECIAL_CHARACTERS)
            if (UI_TEST_CR_CHARACTER(current_character) ||
                UI_TEST_LF_CHARACTER(current_character) || UI_TEST_ESC_CHARACTER(current_character))
            {
                unit->c_info.adv_x = 10;
                unit->c_info.h = 10;
                unit->c_info.by = 10;
                unit->c_info.is_gap = 1;
            }
        #else /* (EMS_DISPLAY_SPECIAL_CHARACTERS) */ 
            if (UI_TEST_LF_CHARACTER(current_character) || UI_TEST_CR_CHARACTER(current_character))
            {
                unit->c_info.adv_x = 0;
                unit->c_info.w = 0;
                unit->c_info.h = 0;
                unit->c_info.by = 0;
                unit->c_info.is_gap = 1;
                unit->char_type = CRLF_CLUSTER;

                /* the alignment is changed to default */
                if (bs->text_format_count <= 1)
                    lastest_EMS_alignment = UI_EMS_normal_text_format_object.data->text_format.Alignment;
            }
        #endif /* (EMS_DISPLAY_SPECIAL_CHARACTERS) */ 
            break;

        case CRLF_CLUSTER:
            /* the alignment is changed to default */
            if (bs->text_format_count <= 2)
                lastest_EMS_alignment = UI_EMS_normal_text_format_object.data->text_format.Alignment;
            break;

        default:
            break;
    }
}


/*****************************************************************************
 * FUNCTION
 *  gui_prepare_ems_one_line_show
 * DESCRIPTION
 *  
 * PARAMETERS
 *  b       [?]     
 *  bs      [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void gui_prepare_ems_one_line_show(UI_EMS_input_box *b, ems_input_box_show_struct *bs)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    EMSALIGNMENT alignment = UI_EMS_current_alignment;
    EMSPosition position;
    EMSObject *object;
    S32 i, flag = 0;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* 
     * the first pass apply the line alignment, we can't restore it to draw the current line.
     * so we calculate the line position before restoring text format.
     */

    /*
     * if the current line is the cursor line and its text count == 0,
     * * the alignment should use the b->text_format
     */
    if (EMS_view_mode == 0)
    {
        for (i=0; i<g_editor_line.line_unit_count; i++)
    {
            if (g_editor_line.line_char[i].char_type != EMS_OBJECT_UNIT)
                flag = 1;
        }

        if (!flag)
        {
            if (g_editor_line.cursor_line_flag)
                alignment = b->text_format.Alignment;
            else
            {
                position.OffsetToText = bs->line_start_position.OffsetToText;
                position.Object = NULL;

                object = GetTextFormatObjectAtPosition(b->data, &position);
                if (object != NULL)
                    alignment = object->data->text_format.Alignment;
            }
        }
    }

    bs->tx = 0;

    switch (alignment)
    {
        case EMS_ALIGN_LEFT:
            bs->tx = 0;
            break;

        case EMS_ALIGN_RIGHT:
            bs->tx = bs->edit_width - g_editor_line.line_width;
            if (bs->tx < 0)
            {
                bs->tx = 0;
            }
            break;

        case EMS_ALIGN_CENTER:
            bs->tx = ((bs->edit_width >> 1) - (g_editor_line.line_width >> 1));
            if (bs->tx < 0)
            {
                bs->tx = 0;
            }
            break;

        case EMS_ALIGN_LANG_DEP:
            if (bs->default_direction == BIDI_L)
                bs->tx = 0;
#ifdef __MMI_BIDI_ALG__
            else
            {
                bs->tx = bs->edit_width - g_editor_line.line_width;
                if (bs->tx < 0)
                {
                    bs->tx = 0;
                }
            }
#endif /* __MMI_BIDI_ALG__ */
            break;

    }

#ifdef __MMI_MESSAGES_EMS__
    gui_EMS_input_box_set_text_format(b, bs->line_start_text_format);
    UI_EMS_current_alignment = lastest_EMS_alignment;
#else /* __MMI_MESSAGES_EMS__ */ 
    {
        EMS_SET_FONT(&UI_EMS_inputbox_medium_font);
        EMS_SET_TEXT_COLOR(UI_EMS_inputbox_text_color);
        b->flags &= ~(UI_EMS_INPUT_BOX_CURRENT_ALIGN_LEFT |
                      UI_EMS_INPUT_BOX_CURRENT_ALIGN_RIGHT | UI_EMS_INPUT_BOX_CURRENT_ALIGN_CENTER);
    }
#endif /* __MMI_MESSAGES_EMS__ */ 

    /* set the current line y offset */
    bs->yty = bs->yy + bs->ty;
}


/*****************************************************************************
 * FUNCTION
 *  gui_prepare_ems_total_str
 * DESCRIPTION
 *  
 * PARAMETERS
 *  b       [?]     
 *  bs      [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void gui_prepare_ems_total_str(UI_EMS_input_box *b, ems_input_box_show_struct *bs)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i, new_char_count = 0, old_char_count = 0, char_num = 0;
    U16 cursor_offset;
    UI_character_type *p = (UI_character_type*) bs->total_str;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (i = 0; i < g_editor_line.line_unit_count; i++)
    {
        if (g_editor_line.line_char[i].char_type == EMS_OBJECT_UNIT
            && g_editor_line.line_char[i].object_unit->Type != EMS_TYPE_TEXT_FORMAT)
        {
            /* we translate the ems object into one Neutral character */
            p[new_char_count] = EMS_INPUT_BOX_EMS_OBJECT_REPLACE_CHARACTER;
            g_editor_line.line_char[i].c_info.data_len= 1;
            new_char_count++;
        }
        else
        {
            /* copy the current cluster to the total_str */
            if (g_editor_line.line_char[i].c_info.data_len > 0)
            {
                mmi_ucs2ncpy(
                    (S8*) & p[new_char_count],
                    (S8*) ((UI_character_type*) g_editor_line.line_start_p + old_char_count),
                    g_editor_line.line_char[i].c_info.data_len);
                new_char_count += g_editor_line.line_char[i].c_info.data_len;
                old_char_count += g_editor_line.line_char[i].c_info.data_len;
            }
        }
    }

    g_editor_line.line_char_count = new_char_count;
    p[new_char_count] = 0;

    /* update the cursor information */
    if (g_editor_line.cursor_line_flag)
    {
        cursor_offset = gui_map_ems_cursor_to_line_offset(b, bs);

        g_editor_line.cursor_unit_index = g_editor_line.line_unit_count;
        for (i=0; i<g_editor_line.line_unit_count; i++)
        {
            char_num += g_editor_line.line_char[i].c_info.data_len;
            if (cursor_offset < char_num)
            {
                g_editor_line.cursor_unit_index = i;
				break;
            }
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  gui_map_ems_cursor_to_line_offset
 * DESCRIPTION
 *  
 * PARAMETERS
 *  b       [?]     
 *  bs      [?]     
 * RETURNS
 *  
 *****************************************************************************/
U16 gui_map_ems_cursor_to_line_offset(UI_EMS_input_box *b, ems_input_box_show_struct *bs)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i, char_counter = 0, all_counter = 0;
    S32 text_index = bs->mapped_cursor_position.OffsetToText - bs->line_start_position.OffsetToText;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    text_index >>= 1;

    if (bs->mapped_cursor_position.Object != NULL)
    {
        /* the cursor is pointed to one object */
        for (i = 0; i < g_editor_line.line_unit_count; i++)
        {
            if (g_editor_line.line_char[i].char_type == EMS_OBJECT_UNIT
                && g_editor_line.line_char[i].object_unit == bs->mapped_cursor_position.Object)
                break;

            all_counter += g_editor_line.line_char[i].c_info.data_len;
        }

        return all_counter;
    }
    else
    {
        /* the cursor is pointed to one text */
        for (i = 0; i < g_editor_line.line_unit_count; i++)
        {
            if (char_counter >= text_index && g_editor_line.line_char[i].char_type != EMS_OBJECT_UNIT)
                break;

            if (g_editor_line.line_char[i].char_type != EMS_OBJECT_UNIT)
                char_counter += g_editor_line.line_char[i].c_info.data_len;

            all_counter += g_editor_line.line_char[i].c_info.data_len;
        }

        return all_counter;
    }
}


/*****************************************************************************
 * FUNCTION
 *  gui_ems_inputs_is_cluster_gap
 * DESCRIPTION
 *  Check if there is gap between current cluster and previous cluster, ignore text format object
 *  Eg: "otOT", t is an hidi cluster with object o, and T is another hidi cluster with object O,
 *       in this case, there should be no gap between t and T if they are join together in the same format
 * PARAMETERS
 *  b       [?]     
 *  bs      [?]     
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
static MMI_BOOL gui_ems_inputs_is_cluster_gap(UI_EMS_input_box *b, ems_input_box_show_struct *bs)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 index = g_editor_line.cur_read;
    mmi_lm_cluster_info pre_cl, pre2_cl, current_cl;
    MMI_BOOL ret = MMI_TRUE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    index--;
    while (index >= 0)
    {
        if (g_editor_line.line_char[index].char_type == EMS_OBJECT_UNIT)
        {
            if (g_editor_line.line_char[index].object_unit->Type == EMS_TYPE_TEXT_FORMAT)
            {
                index--;
                continue;
            }
            else
            {
                break;
            }
        }
        else
        {
            pre_cl = g_editor_line.line_char[index].c_info;
            mmi_lm_cluster_init(&pre2_cl);
            mmi_lm_cluster_init(&current_cl);
            current_cl.data_ptr = g_editor_line.line_char[g_editor_line.cur_read].c_info.data_ptr;
            mmi_lm_get_current_cluster(
                (UI_buffer_type)(g_editor_line.line_char[index].c_info.data_ptr),
                (UI_buffer_type)(g_editor_line.line_char[g_editor_line.cur_read].c_info.data_ptr),
                &pre2_cl,
                &pre_cl,
                &current_cl);
            if (!current_cl.is_gap)
            {
                ret = MMI_FALSE;
            }
            break;
        }
    }
    return ret;
}


/*****************************************************************************
 * FUNCTION
 *  gui_draw_ems_one_line
 * DESCRIPTION
 *  
 * PARAMETERS
 *  b       [?]     
 *  bs      [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void gui_draw_ems_one_line(UI_EMS_input_box *b, ems_input_box_show_struct *bs)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 count = 0, width;
    UI_buffer_type current_text_p = NULL;
    S32 i;
    S32 gap = 0;
    S32 def_text_width, def_text_height;
    UI_string_type default_text = NULL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!g_editor_line.bidi_done_flag)
    {
        count = g_editor_line.line_unit_count;
    }
#ifdef __MMI_BIDI_ALG__
    else
    {
        count = g_editor_line.visual_unit_count;
    }
#endif /* __MMI_BIDI_ALG__ */ 

    g_editor_line.cur_read = 0;

    if (bs->previous_text_format_count)
    {
        /* the previous line has some text format to apply */
#ifdef __MMI_MESSAGES_EMS__
        gui_EMS_input_box_set_text_format(b, bs->line_start_text_format);
#endif
    }

    /* draw all the highlight for current line */
    if (g_editor_line.highlight_flag)
        gui_draw_ems_current_line_highlight(b, bs);

    if (g_editor_line.line_char_count == 0)
    {
        /* this is a blank line, try to draw the cursor and back */
        bs->xtx = bs->xx + bs->tx;
        bs->current_text_p = (UI_buffer_type) bs->total_str;
        
        if (!(bs->flags & UI_EMS_INPUT_BOX_DISABLE_DRAW) 
               && gui_EMS_inputbox_empty(b)
               && (bs->flags & UI_EMS_INPUT_BOX_DISABLE_CURSOR_DRAW)) 
        {
            if (b->default_text)
            {
                default_text = b->default_text;
            }
            if (default_text != NULL)
            {
			#ifdef __MMI_FTE_SUPPORT__
                gui_set_text_color(*(current_MMI_theme->inputbox_default_text_color));
			#else
				gui_set_text_color(gui_color(160, 160, 160));
			#endif /* __MMI_FTE_SUPPORT__ */
                if (!r2lMMIFlag)
                {
                    mmi_fe_show_string_n_baseline(bs->xtx,
                        bs->yty,
                        (PU8)default_text,
                        mmi_ucs2strlen((const PS8)default_text),
                        g_editor_line.line_ascent);
                }
                else
                {
                    Get_StringWidthHeight((PU8)default_text, &def_text_width, &def_text_height);
                    mmi_fe_show_string_n_baseline(bs->xtx + def_text_width,
                        bs->yty,
                        (PU8)default_text,
                        mmi_ucs2strlen((const PS8)default_text),
                        g_editor_line.line_ascent);
                }
            }
        }
        gui_handle_ems_cursor(b, bs);
        return;
    }
    
    for(i=0; i<count; i++)
    {
        bs->xtx = bs->xx + bs->tx;

        if (gui_get_ems_current_object(bs, i) >= 0)
            bs->current_text_p = current_text_p = g_editor_line.line_char[g_editor_line.cur_read].c_info.data_ptr;

        /* adjust the xtx for rx */
        bs->tx += g_editor_line.line_char[g_editor_line.cur_read].c_info.rx;
        bs->xtx += g_editor_line.line_char[g_editor_line.cur_read].c_info.rx;

        if (g_editor_line.line_char[g_editor_line.cur_read].char_type == EMS_OBJECT_UNIT)
            width = g_editor_line.line_char[g_editor_line.cur_read].obj_width;
        else
            width = g_editor_line.line_char[g_editor_line.cur_read].c_info.adv_x;

        if ((g_editor_line.line_char[g_editor_line.cur_read].c_info.is_gap == MMI_LM_CLUSTER_ATTR_GAP) &&
            (gui_ems_inputs_is_cluster_gap(b, bs)))
        {
            gap = 1;
            bs->tx ++;
            bs->xtx ++;

#ifdef __MMI_BIDI_ALG__
            if (g_editor_line.line_char[g_editor_line.cur_read].char_type != EMS_OBJECT_UNIT)
            {
                U8 char_type;
                
                bidi_get_char_type((U8*) current_text_p, (U8*) & char_type);
                if ((char_type == AL) || (char_type == BIDI_R))
                {
                    bs->tx--;
                    bs->xtx--;
                    width++;
                }
            }
#endif
        }
        
        if (!(bs->flags & UI_EMS_INPUT_BOX_DISABLE_DRAW))
        {
            /* draw the text content */
            if (g_editor_line.line_char[g_editor_line.cur_read].highlight_flag &&
                (g_editor_line.line_char[g_editor_line.cur_read].highlight_flag != EDITOR_HILITE_LIST_HIGHLIGHT))
            {
                UI_MULTI_LINE_INPUT_BOX_SET_TEXT_COLOR(b->selected_text_color);
            }
            else
                EMS_SET_TEXT_COLOR(b->normal_text_color);

        #ifdef __MMI_BIDI_ALG__
            if (g_editor_line.bidi_done_flag)
            {
                /* this is a line applied by BIDI. Mapping to the logical buffer to find its format */
                gui_apply_ems_text_format(b, bs);
            }
        #endif /* __MMI_BIDI_ALG__ */ 
        
            switch (g_editor_line.line_char[g_editor_line.cur_read].char_type)
            {
                case EMS_OBJECT_UNIT:
                    gui_draw_ems_object(b, bs);
                    break;

                case SINGLE_CHAR:
                    gui_draw_ems_single_character(b, bs);
                    break;

                case EMS_EXT_CHARSET_CLUSTER:
                    gui_draw_ems_extention_charset_cluster(b, bs);
                    break;

                default:    /* draw the common cluster */
                    gui_draw_ems_single_character(b, bs);
                    break;
            }
        }

        if (!g_editor_line.bidi_done_flag)
        {
            /* only the non-bidi process need to update the bs->previous_text_format_count */
            if (bs->previous_text_format_count)
            {
                if (g_editor_line.line_char[g_editor_line.cur_read].char_type != EMS_OBJECT_UNIT)
                {
                    bs->previous_text_format_count -= g_editor_line.line_char[g_editor_line.cur_read].c_info.data_len;

                    if (bs->previous_text_format_count <= 0)
                    {
                        bs->previous_text_format_count = 0;
#ifdef __MMI_MESSAGES_EMS__
                        gui_EMS_input_box_set_text_format(b, &UI_EMS_normal_text_format_object); 
#endif
                    }
                }
            }
        }

        /* handle the cursor */
        if (g_editor_line.line_char[g_editor_line.cur_read].char_type!= EMS_OBJECT_UNIT
            || g_editor_line.line_char[g_editor_line.cur_read].object_unit->Type != EMS_TYPE_TEXT_FORMAT)
            gui_handle_ems_cursor(b, bs);

        bs->tx += width;
    }

    UI_UNUSED_PARAMETER(current_text_p);
    UI_UNUSED_PARAMETER(gap);
}


/*****************************************************************************
 * FUNCTION
 *  gui_get_ems_current_object
 * DESCRIPTION
 *  
 * PARAMETERS
 *  bs                  [?]         
 *  current_text_p      [IN]        
 * RETURNS
 *  
 *****************************************************************************/
S32 gui_get_ems_current_object(ems_input_box_show_struct *bs, S32 disp_count)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!g_editor_line.bidi_done_flag)
    {
        g_editor_line.cur_read = disp_count;
        if (g_editor_line.cur_read >= g_editor_line.line_unit_count)
        {
            /* to the current line end */
            return -1;
        }
    }
#ifdef __MMI_BIDI_ALG__
    else
    {
        if (disp_count >= g_editor_line.visual_unit_count)
        {
            /* to the current line end */
            return NULL;
        }
        
        g_editor_line.cur_v_read = disp_count;
        g_editor_line.cur_read = g_editor_line.visual_to_logic_map[disp_count];
        
    }

#endif /* __MMI_BIDI_ALG__ */ 

    return 1;
}


/*****************************************************************************
 * FUNCTION
 *  gui_check_ems_character_highlight
 * DESCRIPTION
 *  
 * PARAMETERS
 *  b       [?]     
 *  bs      [?]     
 * RETURNS
 *  
 *****************************************************************************/
U16 gui_check_ems_character_highlight(UI_EMS_input_box *b, ems_input_box_show_struct *bs, U16 count)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 highlight = 0;
    S32 inside1 = 0, inside2 = 0, offset_text;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_editor_line.line_char[count].char_type == EMS_OBJECT_UNIT)
        return MMI_FALSE;

#ifdef __UI_EMS_HIGHLIGHT_LIST_SUPPORT__
	/* Check for hilite list, which maybe overrided by common highlight */
    if (b->hilite_str_number != 0)
    {
        if (gui_EMS_input_box_is_pos_inside_hilite_ext(b, ((g_editor_line.line_char[count]).c_info).data_ptr, &g_editor_line.line_char[count].hilite_idx))
        {
            highlight = EDITOR_HILITE_LIST_HIGHLIGHT;
        }
    }
#endif /* __UI_EMS_HIGHLIGHT_LIST_SUPPORT__ */

    /* check the single highlight */
    if (bs->flags & UI_EMS_INPUT_BOX_WORD_HIGHLIGHT)
    {
        if ((g_editor_line.line_char[count].offset_text + ENCODING_LENGTH*(g_editor_line.line_char[count].c_info.data_len -1)) >=
            (U32)(b->highlight_start_position.OffsetToText - bs->line_start_position.OffsetToText)
            || b->highlight_start_position.OffsetToText < bs->line_start_position.OffsetToText)
        {
            inside1 = 1;
        }

        if (b->highlight_end_position.OffsetToText > bs->line_start_position.OffsetToText
            && g_editor_line.line_char[count].offset_text <
            (b->highlight_end_position.OffsetToText - bs->line_start_position.OffsetToText))
        {
            inside2 = 1;
        }

        if (inside1 && inside2)
            bs->word_highlight = 1;
        else
            bs->word_highlight = 0;
        
        if (bs->word_highlight)
        {
            if (highlight == EDITOR_HILITE_LIST_HIGHLIGHT)
            {
            	highlight = EDITOR_HILITE_LIST_COMMON_HIGHLIGHT;
            }
            else
            {
            	highlight = EDITOR_COMMON_HIGHLIGHT;
            }
        }
    }

    /* check the multitap highlight */
    if (bs->multitap_flag)
    {
        offset_text = bs->line_start_position.OffsetToText + g_editor_line.line_char[count].offset_text;
        
#if defined(__MMI_ARSHAPING_ENGINE__) && defined(__MMI_BIDI_ALG__)
        if(bs->cursor_moved_by_shaping)
        {
            if (offset_text == bs->mapped_cursor_position.OffsetToText)
                highlight = EDITOR_MULTITAP_HIGHLIGHT;
        }
        else
        {   
            if (offset_text <= bs->mapped_cursor_position.OffsetToText - ENCODING_LENGTH
                && offset_text + g_editor_line.line_char[count].c_info.data_len*ENCODING_LENGTH > bs->mapped_cursor_position.OffsetToText - ENCODING_LENGTH)
                highlight = EDITOR_MULTITAP_HIGHLIGHT;
        }
#else
        if (offset_text <= bs->mapped_cursor_position.OffsetToText - ENCODING_LENGTH
            && offset_text + g_editor_line.line_char[count].c_info.data_len*ENCODING_LENGTH > (U32)bs->mapped_cursor_position.OffsetToText - ENCODING_LENGTH)
            highlight = EDITOR_MULTITAP_HIGHLIGHT;
#endif
        /* This logic ensures that the characters entered by multitap mode are highlighted 
         * The logic works by looking that the character is in between the input mode start
         * and cursor position and highlight the characters.
         */
        /* We can remove the above condition and use the more 
             generalized condition using variable input_start_position. Kindly comment 
             and make appropriate changes if possible */
        if(offset_text >= b->input_start_position.OffsetToText && offset_text < bs->mapped_cursor_position.OffsetToText - ENCODING_LENGTH)
        {
           highlight = EDITOR_MULTITAP_HIGHLIGHT; 
        }
    }

    return highlight;
}

#ifdef __MMI_BIDI_ALG__
/*****************************************************************************
 * FUNCTION
 *  gui_apply_ems_text_format
 * DESCRIPTION
 *  
 * PARAMETERS
 *  b       [?]     
 *  bs      [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void gui_apply_ems_text_format(UI_EMS_input_box *b, ems_input_box_show_struct *bs)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gui_editor_character_unit_struct *current_unit;
    EMSObject *text_format;
    S32 i, count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    current_unit = &g_editor_line.line_char[g_editor_line.cur_read];

    if (current_unit->char_type == EMS_OBJECT_UNIT)
    {
        return;
    }

    text_format = bs->line_start_text_format;
    count = bs->previous_text_format_count;
    for (i = 0; i < g_editor_line.cur_read; i++)
    {
        current_unit = &g_editor_line.line_char[i];
        if (current_unit->char_type == EMS_OBJECT_UNIT)
        {
            if (current_unit->object_unit->Type == EMS_TYPE_TEXT_FORMAT)
            {
                count = current_unit->object_unit->data->text_format.textLength >> 1;
                if (count > 0)
                    text_format = current_unit->object_unit;
            }
        }
        else
        {
            if (text_format != &UI_EMS_normal_text_format_object)
            {
                count -= current_unit->c_info.data_len;
                if (count <= 0)
                    text_format = &UI_EMS_normal_text_format_object;
            }
        }
    }
#ifdef __MMI_MESSAGES_EMS__
    gui_EMS_input_box_set_text_format(b, text_format);
#endif

}
#endif

/*****************************************************************************
 * FUNCTION
 *  gui_draw_ems_object
 * DESCRIPTION
 *  
 * PARAMETERS
 *  b       [?]     
 *  bs      [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void gui_draw_ems_object(UI_EMS_input_box *b, ems_input_box_show_struct *bs)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gui_editor_character_unit_struct *current_unit;
    U16 object_width = g_editor_line.line_char[g_editor_line.cur_read].obj_width;
    U16 object_height = g_editor_line.line_char[g_editor_line.cur_read].obj_height;
    S32 y;
    U8 highlight;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    current_unit = &g_editor_line.line_char[g_editor_line.cur_read];

    if (current_unit->object_unit->Type == EMS_TYPE_TEXT_FORMAT)
    {
        /* if This line is applied by BIDI, its text format is handled by gui_apply_ems_text_format, not this */
        if (!g_editor_line.bidi_done_flag)
        {
            bs->previous_text_format_count = current_unit->object_unit->data->text_format.textLength >> 1;
#ifdef __MMI_MESSAGES_EMS__
            gui_EMS_input_box_set_text_format(b, current_unit->object_unit);
#endif
        }

    }
    else
    {
    #ifdef __UI_EMS_HIGHLIGHT_LIST_SUPPORT__
        if(b->hilite_str_number != 0)
        {
            highlight = ((bs->mapped_cursor_position.Object == current_unit->object_unit) &&
                         (b->hilite_list[b->current_hilite_idx].object == current_unit->object_unit)) ? 1 : 0;
        }
        else
        {
            highlight = (bs->mapped_cursor_position.Object == current_unit->object_unit) ? 1 : 0;
        }
    #else /* __UI_EMS_HIGHLIGHT_LIST_SUPPORT__ */
        highlight = (bs->mapped_cursor_position.Object == current_unit->object_unit) ? 1 : 0;
    #endif /* __UI_EMS_HIGHLIGHT_LIST_SUPPORT__ */
        y = highlight ? bs->yty + g_editor_line.line_ascent - object_height - 1
            : bs->yty + g_editor_line.line_ascent - object_height;

        if (y < bs->yty)
            y = bs->yty;

        if (EMS_view_mode && highlight)
        {
            gui_show_EMS_input_box_cursor(
                b,
                bs->xtx - 1,
                y,
                object_width,
                object_height,
                3);
        }
#ifdef __MMI_MESSAGES_EMS__
        gui_EMS_input_box_display_object(
            bs->xtx - 1,
            y,
            current_unit->object_unit,
            highlight);
#endif
    }
}


/*****************************************************************************
 * FUNCTION
 *  gui_draw_ems_single_character
 * DESCRIPTION
 *  
 * PARAMETERS
 *  b       [?]     
 *  bs      [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void gui_draw_ems_single_character(UI_EMS_input_box *b, ems_input_box_show_struct *bs)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    UI_character_type current_character;
    UI_buffer_type current_text_p = bs->current_text_p;

#if(EMS_DISPLAY_SPECIAL_CHARACTERS)
    S32 base_line = g_editor_line.line_char[g_editor_line.cur_read].c_info.by;
    U16 character_width = g_editor_line.line_char[g_editor_line.cur_read].c_info.adv_x;
    U16 character_height = g_editor_line.line_char[g_editor_line.cur_read].c_info.h;
#endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_STRING_GET_NEXT_CHARACTER(current_text_p, current_character);

#if(EMS_DISPLAY_SPECIAL_CHARACTERS)
    if (UI_TEST_CR_CHARACTER(current_character))
    {
        gdi_image_draw_id(bs->xtx, base_line - character_height + bs->yty, WGUI_CR_CHARACTER_IMAGE_ID);
        return;
    }
    else if (UI_TEST_LF_CHARACTER(current_character))
    {
        gdi_image_draw_id(bs->xtx, base_line - character_height + bs->yty, WGUI_LF_CHARACTER_IMAGE_ID);
        return;
    }
    else if (UI_TEST_ESC_CHARACTER(current_character))
    {
        gdi_image_draw_id(bs->xtx, base_line - character_height + bs->yty, WGUI_ESC_CHARACTER_IMAGE_ID);
        return;
    }
#endif /* (EMS_DISPLAY_SPECIAL_CHARACTERS) */ 

    if (!(UI_STRING_END_OF_STRING_CHARACTER(current_character) ||
          UI_TEST_LF_CHARACTER(current_character) ||
          UI_TEST_CR_CHARACTER(current_character) || UI_TEST_ESC_CHARACTER(current_character)))
    {
        gui_draw_ems_text(b, bs);
    }
}


/*****************************************************************************
 * FUNCTION
 *  gui_draw_ems_text
 * DESCRIPTION
 *  
 * PARAMETERS
 *  b       [?]     
 *  bs      [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void gui_draw_ems_text(UI_EMS_input_box *b, ems_input_box_show_struct *bs)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_lm_show_cluster_param lm_show_param;
    mmi_lm_cluster_info_p info_p = &g_editor_line.line_char[g_editor_line.cur_read].c_info;
    S32 width;
    mmi_lm_cluster_info_p prev_cluster = NULL;

#ifdef __MMI_BIDI_ALG__
    U8 *mirror_buffer, *original_buffer;
    UI_character_type current_character, mirror_character, backup_character;
    S32 i, len;
#endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_editor_line.cur_read)
    {
        prev_cluster = &g_editor_line.line_char[g_editor_line.cur_read - 1].c_info;
    }
    lm_show_param.cluster= info_p;
    lm_show_param.x = bs->xtx;
    lm_show_param.y = bs->yty + EDITOR_LINE_UPPER_PIXTEL;
    lm_show_param.baseline = g_editor_line.line_ascent - EDITOR_LINE_UPPER_PIXTEL;
    lm_show_param.bordered = 0;
    lm_show_param.prev_cluster = prev_cluster;

#ifdef __MMI_BIDI_ALG__
    if (g_editor_line.bidi_done_flag 
        && g_editor_line.line_unit_count > 0
        && g_editor_line.line_char_count > 0
        && lm_show_param.cluster->data_len == 1)
    {
        mirror_buffer = &g_editor_line.visual_str[0];
        original_buffer = lm_show_param.cluster->data_ptr;

        for (i=0; i<g_editor_line.cur_v_read; i++)
        {
            len = g_editor_line.line_char[g_editor_line.visual_to_logic_map[i]].c_info.data_len;
            mirror_buffer += len * ENCODING_LENGTH;
        }


        UI_STRING_GET_NEXT_CHARACTER(mirror_buffer, mirror_character);
        UI_STRING_GET_NEXT_CHARACTER(original_buffer, current_character);

        if (mirror_character != current_character)
        {
            backup_character = lm_show_param.cluster->display_buffer[0];
            lm_show_param.cluster->display_buffer[0] = mirror_character;
            mmi_lm_draw_cluster(&lm_show_param);
            lm_show_param.cluster->display_buffer[0] = backup_character;
        }
        else
            mmi_lm_draw_cluster(&lm_show_param);

    }
    else
    {
        mmi_lm_draw_cluster(&lm_show_param);
    }
#else
    mmi_lm_draw_cluster(&lm_show_param);
#endif /*__MMI_BIDI_ALG__*/

    if (info_p->w > info_p->adv_x)
    {
        width = info_p->w - 1;
    }
    else
    {
        width = info_p->adv_x - 1;
    }

    if (UI_EMS_strikethrough 
        && info_p->adv_x != 0)
    {
        UI_draw_horizontal_line(
            bs->xtx - info_p->is_gap,
            bs->xtx + width,
            bs->yty + g_editor_line.line_ascent - EDITOR_STRIKETHOUGH_LINE_PIXTEL,
            b->strikethrough_color);
    }

#ifdef __UI_EMS_HIGHLIGHT_LIST_SUPPORT__    
    if (UI_font->underline ||
        ((b->hilite_str_number != 0) && 
         ((g_editor_line.line_char[g_editor_line.cur_read].highlight_flag == EDITOR_HILITE_LIST_HIGHLIGHT) ||
          (g_editor_line.line_char[g_editor_line.cur_read].highlight_flag == EDITOR_HILITE_LIST_COMMON_HIGHLIGHT))))
#else /* __UI_EMS_HIGHLIGHT_LIST_SUPPORT__ */
    if (UI_font->underline)
#endif /* __UI_EMS_HIGHLIGHT_LIST_SUPPORT__ */
    {
#ifdef __MMI_BIDI_ALG__
        {
            U8 char_type;
            
            bidi_get_char_type((U8*) info_p->data_ptr, (U8*) & char_type);
            if ((char_type == AL) || (char_type == BIDI_R))
            {
                width++;
            }
        }
#endif
        UI_draw_horizontal_line(
            bs->xtx - info_p->is_gap,
            bs->xtx + width,
            bs->yty + (g_editor_line.line_height) - 2,
            UI_get_text_color());       
    }

    return;
}


/*****************************************************************************
 * FUNCTION
 *  gui_draw_ems_extention_charset_cluster
 * DESCRIPTION
 *  
 * PARAMETERS
 *  b       [?]     
 *  bs      [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void gui_draw_ems_extention_charset_cluster(UI_EMS_input_box *b, ems_input_box_show_struct *bs)
{
    UI_buffer_type current_text_p = bs->current_text_p;
    UI_character_type current_character;
    S32 character_width, character_height;
    mmi_lm_cluster_info_p info_p = &g_editor_line.line_char[g_editor_line.cur_read].c_info;
    U32 i;
#ifdef __MMI_BIDI_ALG__
    U8 *mirror_buffer, *original_buffer;
    UI_character_type current_character_bidi, mirror_character;
    S32 j, len;
#endif

    for (i = 0; i < info_p->data_len; i++)
    {
        UI_STRING_GET_NEXT_CHARACTER(current_text_p, current_character);

        if (UI_TEST_ESC_CHARACTER(current_character))
            continue;
        
        gui_measure_character(current_character, &character_width, &character_height);
        FONT_CANCEL_WIDTH(1);
    #ifdef __UI_EMS_HIGHLIGHT_LIST_SUPPORT__    
        if (UI_font->underline ||
            ((b->hilite_str_number != 0) && 
             ((g_editor_line.line_char[g_editor_line.cur_read].highlight_flag == EDITOR_HILITE_LIST_HIGHLIGHT) ||
              (g_editor_line.line_char[g_editor_line.cur_read].highlight_flag == EDITOR_HILITE_LIST_COMMON_HIGHLIGHT))))
    #else /* __UI_EMS_HIGHLIGHT_LIST_SUPPORT__ */
        if (UI_font->underline)
    #endif /* __UI_EMS_HIGHLIGHT_LIST_SUPPORT__ */
        {
            UI_font->underline = 0;
            gui_set_font(UI_font);
            ShowString_n_baseline(bs->xtx, bs->yty + EDITOR_LINE_UPPER_PIXTEL, *UI_font, 0, (U8*)&current_character, 1, g_editor_line.line_ascent - EDITOR_LINE_UPPER_PIXTEL);
            UI_font->underline = 1;
            gui_set_font(UI_font);
        }
        else
        {
        #ifdef __MMI_BIDI_ALG__
            if (g_editor_line.bidi_done_flag 
                && g_editor_line.line_unit_count > 0
                && g_editor_line.line_char_count > 0)
            {
                mirror_buffer = &g_editor_line.visual_str[0];
                original_buffer = info_p->data_ptr + ENCODING_LENGTH; /* Get the character after 0x1b */

                for (j=0; j<g_editor_line.cur_v_read; j++)
                {
                    len = g_editor_line.line_char[g_editor_line.visual_to_logic_map[j]].c_info.data_len;
                    mirror_buffer += len * ENCODING_LENGTH;
                }

                UI_STRING_GET_NEXT_CHARACTER(mirror_buffer, mirror_character);
                if (UI_TEST_ESC_CHARACTER(mirror_character))
                {
                    UI_STRING_GET_NEXT_CHARACTER(mirror_buffer, mirror_character); /* Get the character after 0x1b */
                }
                UI_STRING_GET_NEXT_CHARACTER(original_buffer, current_character_bidi);

                if (mirror_character != current_character_bidi)
                {
                    ShowString_n_baseline(bs->xtx, bs->yty + EDITOR_LINE_UPPER_PIXTEL, *UI_font, 0, (U8*)&mirror_character, 1, g_editor_line.line_ascent - EDITOR_LINE_UPPER_PIXTEL);
                }
                else
                {
                    ShowString_n_baseline(bs->xtx, bs->yty + EDITOR_LINE_UPPER_PIXTEL, *UI_font, 0, (U8*)&current_character, 1, g_editor_line.line_ascent - EDITOR_LINE_UPPER_PIXTEL);
                }
            }
            else
            {
                ShowString_n_baseline(bs->xtx, bs->yty + EDITOR_LINE_UPPER_PIXTEL, *UI_font, 0, (U8*)&current_character, 1, g_editor_line.line_ascent - EDITOR_LINE_UPPER_PIXTEL);
            }
        #else
            ShowString_n_baseline(bs->xtx, bs->yty + EDITOR_LINE_UPPER_PIXTEL, *UI_font, 0, (U8*)&current_character, 1, g_editor_line.line_ascent - EDITOR_LINE_UPPER_PIXTEL);
        #endif /*__MMI_BIDI_ALG__*/
        }
        FONT_CANCEL_WIDTH(0);
        /* draw the strikethrough */
        if (UI_EMS_strikethrough)
        {
            UI_draw_horizontal_line(
                bs->xtx - info_p->is_gap,
                bs->xtx + info_p->adv_x - 1,
                bs->yty + g_editor_line.line_ascent - EDITOR_STRIKETHOUGH_LINE_PIXTEL,
                b->strikethrough_color);
        }

        if (UI_font->underline)
        {
            UI_draw_horizontal_line(
                bs->xtx - info_p->is_gap,
                bs->xtx + info_p->adv_x - 1,
                bs->yty + (g_editor_line.line_height) - 2,
                UI_get_text_color());       
        }

    }
}


/*****************************************************************************
 * FUNCTION
 *  gui_end_ems_new_line_loop
 * DESCRIPTION
 *  
 * PARAMETERS
 *  b       [?]     
 *  bs      [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void gui_end_ems_new_line_loop(UI_EMS_input_box *b, ems_input_box_show_struct *bs)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x1, x2;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    x1 = bs->x1;
    x2 = b->x + b->width - 2;
    if (b->normal_filler->flags & UI_FILLED_AREA_SINGLE_BORDER)
    {
        x1++;
        x2--;
    }

#ifndef __OP01_FWPBW__
    /* draw the underline */
    if (g_editor_line.line_unit_count > 0
        && (g_editor_line.line_char[0].char_type == CRLF_CLUSTER
            || g_editor_line.line_char[g_editor_line.line_unit_count - 1].char_type == CRLF_CLUSTER))
    {
        if (!(bs->flags & UI_EMS_INPUT_BOX_DISABLE_DRAW))
        {
#ifdef __MMI_FTE_EDITOR_SCROLLBAR_STYLE__
            gui_push_clip();
            gui_set_clip(bs->x1 + 1, bs->y1 + 1, b->x + b->width - 2, bs->y2 - 1);
            EMS_EDITOR_DRAW_DOTTED_LINE(
                x1,
                x2,
                bs->yty + g_editor_line.line_height - 1,
                b->paragraph_color);
            gui_pop_clip();
#else
            EMS_EDITOR_DRAW_DOTTED_LINE(
                bs->x1 + 2,
                bs->x2 - 1,
                bs->yty + g_editor_line.line_height - 1,
                b->paragraph_color);
#endif
        }
    }
    else
    {
        if (!(bs->flags & UI_EMS_INPUT_BOX_DISABLE_DRAW))
        {
#ifdef __MMI_FTE_EDITOR_SCROLLBAR_STYLE__
            gui_push_clip();
            gui_set_clip(bs->x1 + 1, bs->y1 + 1, b->x + b->width - 2, bs->y2 - 1);
            UI_draw_horizontal_line(
                x1,
                x2,
                bs->yty + g_editor_line.line_height - 1,
                *(current_MMI_theme->inputbox_base_line_color));
            gui_pop_clip();
#else /* __MMI_FTE_EDITOR_SCROLLBAR_STYLE__ */
            UI_draw_horizontal_line(
                bs->x1 + 2,
                bs->x2 - 1,
                bs->yty + g_editor_line.line_height - 1,
                *(current_MMI_theme->inputbox_base_line_color));
#endif /* __MMI_FTE_EDITOR_SCROLLBAR_STYLE__ */
        }
    }
#endif

    bs->ty += g_editor_line.line_height;
    b->display_height += g_editor_line.line_height;
    bs->n_lines++;

    bs->previous_text_format_count = bs->text_format_count;
}


/*****************************************************************************
 * FUNCTION
 *  gui_draw_ems_under_line
 * DESCRIPTION
 *  
 * PARAMETERS
 *  b       [?]     
 *  bs      [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void gui_draw_ems_under_line(UI_EMS_input_box *b, ems_input_box_show_struct *bs)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 minimum_line_height;
    S32 last_line_y = bs->yy + bs->ty;
    S32 x1 = bs->x1, x2 = bs->x2 - 1;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __OP01_FWPBW__
    // do not draw ems underline for TD FWPBW project
    return;
#endif

#if(EMS_SHOW_HORIZONTAL_RULE_FOR_ALL_LINES)
    if (bs->flags & UI_EMS_INPUT_BOX_ALL_LINE_DRAW)
    {
        minimum_line_height = Get_CharHeightOfAllLang(MEDIUM_FONT) + EDITOR_LINE_ADDITION_PIXTEL;       /* object_height; */
        if (!(bs->flags & UI_EMS_INPUT_BOX_DISABLE_DRAW))
        {
#ifdef __MMI_FTE_EDITOR_SCROLLBAR_STYLE__
            gui_push_clip();
            gui_set_clip(bs->x1 + 1, bs->y1 + 1, b->x + b->width - 2, bs->y2 - 1);
            x2 = b->x + b->width - 2;
            if (b->normal_filler->flags & UI_FILLED_AREA_SINGLE_BORDER)
            {
                x1++;
                x2--;
            }

            while (last_line_y <= bs->y2)
            {
                last_line_y += minimum_line_height;
                UI_draw_horizontal_line(x1, x2, last_line_y - 1, *(current_MMI_theme->inputbox_base_line_color));
            }
#else
            while (last_line_y <= bs->y2)
            {
                last_line_y += minimum_line_height;
                UI_draw_horizontal_line(bs->x1 + 2, x2, last_line_y - 1, *(current_MMI_theme->inputbox_base_line_color));
            }
#endif /* __MMI_FTE_EDITOR_SCROLLBAR_STYLE__ */

#ifdef __MMI_FTE_EDITOR_SCROLLBAR_STYLE__
            gui_pop_clip();
#endif /* __MMI_FTE_EDITOR_SCROLLBAR_STYLE__ */
        }
    }
#endif /* (EMS_SHOW_HORIZONTAL_RULE_FOR_ALL_LINES) */ 
    UI_UNUSED_PARAMETER(x1);
}


/*****************************************************************************
 * FUNCTION
 *  gui_show_ems_scroll_bar
 * DESCRIPTION
 *  
 * PARAMETERS
 *  b       [?]     
 *  bs      [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void gui_show_ems_scroll_bar(UI_EMS_input_box *b, ems_input_box_show_struct *bs)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#ifdef __MMI_FTE_EDITOR_SCROLLBAR_STYLE__
    gdi_handle layer;
#endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!(bs->flags & UI_EMS_INPUT_BOX_DISABLE_DRAW) && !(bs->flags & UI_EMS_INPUT_BOX_DISABLE_SCROLLBAR))
    {

#ifdef __MMI_FTE_EDITOR_SCROLLBAR_STYLE__
        gdi_layer_get_active(&layer);
        gui_vertical_scrollbar_set_alpha_blend_layer(&b->vbar, layer);
#endif

        if (bs->flags & UI_EMS_INPUT_BOX_DISPLAY_HEADER)
        {
            gui_set_vertical_scrollbar_scale(&b->vbar, b->height - 2);
            gui_set_vertical_scrollbar_range(&b->vbar, b->display_height + b->header_height + 3);
            gui_set_vertical_scrollbar_value(&b->vbar, -b->display_y);
        }
        else
        {
            gui_set_vertical_scrollbar_scale(&b->vbar, b->height - 2);
            /* W06.12 Use b->display_height + 2 instead of cursor_ay 
               1.cursor_ay is different when the cusrosr at the last line
               2.(+2)because that the box_height is b->height - 4 in gui_EMS_input_box_locate_cursor */
            gui_set_vertical_scrollbar_range(&b->vbar, b->display_height + 2);
            gui_set_vertical_scrollbar_value(&b->vbar, -b->display_y);
        }

        if (bs->flags & UI_EMS_INPUT_BOX_AUTO_DISABLE_SCROLLBAR)
        {
            if (b->vbar.scale < b->vbar.range)
            {
                if (r2lMMIFlag)
                {
                    /* move vertical scrollbar to the left side */
                    gui_move_vertical_scrollbar(&b->vbar, b->x + 1, b->vbar.y);
                }

                gui_show_vertical_scrollbar(&b->vbar);
                b->scrollbar_state = 1;
            }
            else
            {
                b->scrollbar_state = 0;
            }

        }
        else
        {
            if (r2lMMIFlag)
            {
                /* move vertical scrollbar to the left side */
                gui_move_vertical_scrollbar(&b->vbar, b->x + 1, b->vbar.y);
            }

            gui_show_vertical_scrollbar(&b->vbar);
            b->scrollbar_state = 1;
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  gui_set_ems_cursor_information
 * DESCRIPTION
 *  
 * PARAMETERS
 *  b       [?]     
 *  bs      [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void gui_set_ems_cursor_information(UI_EMS_input_box *b, ems_input_box_show_struct *bs, MMI_BOOL force_cursor)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    EMSPosition line_end_position = bs->line_end_position;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (bs->find_new_cursor_flag)
    {
        /* In this case, We can't use the b->data->CurrentPosition to find the cursor line */
        return;
    }
    
    if (!EMS_view_mode)
    {
        force_cursor = MMI_TRUE;
    }

#ifdef __MMI_CLIPBOARD__
    if (mmi_imc_is_clipboard_state())
    {
        force_cursor = MMI_TRUE;
    }
#endif

    line_end_position.OffsetToText += ENCODING_LENGTH;

    if ((bs->end_line && 
            gui_check_ems_is_in_range(
                b->data, &bs->mapped_cursor_position, &bs->line_start_position, &line_end_position) &&
            force_cursor)
            /* this is the last line and the cursor is not found.so we assume the cursor must be at this line. */         
        || (gui_check_ems_is_in_range(
                b->data, &bs->mapped_cursor_position, &bs->line_start_position, &bs->line_end_position))
            /* the cursor is located at the current line */
       )
    {
        /* the cursor is located at the current line */
        bs->cursor_line_found_flag = 1;

        /* update the cursor information */
        g_editor_line.cursor_line_flag = 1;
        b->current_line = bs->n_lines;
        b->cursor_line_height = g_editor_line.line_height;
        b->cursor_ay = b->display_height;
    }
}


/*****************************************************************************
 * FUNCTION
 *  gui_ems_get_object_index
 * DESCRIPTION
 *  Get EMS object index in the object list
 * PARAMETERS
 *  b           [IN]     
 *  object      [IN]     
 * RETURNS
 *  Object index
 *****************************************************************************/
U8 gui_ems_get_object_index(UI_EMS_input_box *b, EMSObject *object)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 o_idx = 0;
    EMSObject *obj;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    obj = b->data->listHead;
    while (obj)
    {
        if (obj == object)
        {
            break;
        }
        obj = obj->next;
        o_idx++;
    }
    return o_idx;
}


/*****************************************************************************
 * FUNCTION
 *  gui_ems_get_object_by_index
 * DESCRIPTION
 *  Get EMS object by index in the object list
 * PARAMETERS
 *  b          [IN]     
 *  index      [IN]     
 * RETURNS
 *  EMSObject*
 *****************************************************************************/
EMSObject* gui_ems_get_object_by_index(UI_EMS_input_box *b, U8 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    EMSObject *obj = NULL;
    U8 o_idx = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (b->object_count > 0)
    {
        obj = b->data->listHead;
        while (obj)
        {
            if (o_idx == index)
            {
                break;
            }
            obj = obj->next;
            o_idx++;
        }
    }
    return obj;
}


/*****************************************************************************
 * FUNCTION
 *  gui_set_ems_line_information
 * DESCRIPTION
 *  
 * PARAMETERS
 *  b       [?]     
 *  bs      [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void gui_set_ems_line_information(UI_EMS_input_box *b, ems_input_box_show_struct *bs)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#ifdef __MMI_MESSAGES_EMS__
    U8 o_idx = 0;
#endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (bs->n_lines < MAX_EMS_EDITOR_LINES)
        b->line_positions_text_offset[bs->n_lines] = bs->line_start_position.OffsetToText;

#ifdef __MMI_MESSAGES_EMS__
    if (b->object_count > 0)
    {
        o_idx = gui_ems_get_object_index(b, bs->line_start_position.Object);
    }
#endif
    
#ifdef __MMI_MESSAGES_EMS__
    if (bs->n_lines < MAX_EMS_EDITOR_LINES)
        b->line_positions_object_index[bs->n_lines] = o_idx;
#endif
}


/*****************************************************************************
 * FUNCTION
 *  gui_check_ems_is_in_range
 * DESCRIPTION
 *  
 * PARAMETERS
 *  data        [?]     
 *  p           [?]     
 *  start       [?]     
 *  end         [?]     
 * RETURNS
 *  
 *****************************************************************************/
U32 gui_check_ems_is_in_range(EMSData *data, EMSPosition *p, EMSPosition *start, EMSPosition *end)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    EMSPosition start_p, end_p;
    EMSObject *t;
    U32 flag = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* this function assume 'p' has already been mapped */
    EMS_map_position(data, start, &start_p);
    EMS_map_position(data, end, &end_p);

    if (p->OffsetToText > start_p.OffsetToText && p->OffsetToText < end_p.OffsetToText)
    {
        return 1;
    }

    if (p->OffsetToText == start_p.OffsetToText)
    {
        if (p->Object && start_p.Object)
        {
            t = data->listHead;
            while (t)
            {
                if (t == p->Object || t == start_p.Object)
                {
                    if (t == p->Object && t != start_p.Object)
                    {
                        /* the 'p' is before the 'start_p' */
                        return 0;
                    }

                    flag = 1;
                    break;
                }

                t = t->next;
            }
        }
        else if (p->Object && !start_p.Object)
            return 0;
        else
        {
            /* the cursor must be after the first object */
            flag = 1;
        }
    }

    if (p->OffsetToText == end_p.OffsetToText)
    {
        if (p->Object && end_p.Object)
        {
            t = data->listHead;
            while (t)
            {
                if (t == p->Object || t == end_p.Object)
                {
                    if (t == end_p.Object)
                    {
                        /* the 'p' is after the 'end_p' */
                        flag = 0;
                        break;
                    }
                    return 1;
                }
                t = t->next;
            }
        }
        else if (p->Object && !end_p.Object)
            return 1;
        else
        {
            /* the cursor is after the end object */
            flag = 0;
        }
    }

    return flag;
}


/*****************************************************************************
 * FUNCTION
 *  gui_handle_ems_cursor
 * DESCRIPTION
 *  
 * PARAMETERS
 *  b       [?]     
 *  bs      [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void gui_handle_ems_cursor(UI_EMS_input_box *b, ems_input_box_show_struct *bs)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x, y, height;
    U8 show_cursor = 0;
    U16 character_width = g_editor_line.line_char[g_editor_line.cur_read].c_info.adv_x;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (bs->find_new_cursor_flag == FINDING_CURSOR)
    {
        gui_find_ems_cursor_position(b, bs);
        return;
    }
    
    show_cursor = gui_check_ems_cursor_for_current_position(b, bs);
    
    if (show_cursor)
    {
        /* update cursor information */
        b->cursor_ax = (show_cursor == 1) ? bs->xtx : bs->xtx + character_width + 1;
        
        if (!(bs->flags & UI_EMS_INPUT_BOX_DISABLE_DRAW))
        {
            if (!(bs->flags & UI_EMS_INPUT_BOX_DISABLE_CURSOR_DRAW))
            {
                x = bs->xtx;
                y = bs->yty;
                height = g_editor_line.line_height - 1;                

                if (y + height < b->y 
                    || y >= b->y + b->height)
                    return;

                if (show_cursor == 1 && g_editor_line.line_unit_count > 0)
                {
                    if (g_editor_line.line_char[g_editor_line.cur_read].char_type == EMS_OBJECT_UNIT
                        && g_editor_line.line_char[g_editor_line.cur_read].object_unit->Type != EMS_TYPE_TEXT_FORMAT)
                    {
                        x -= g_editor_line.line_char[g_editor_line.cur_read].c_info.rx;
                    }
                }
                else if (show_cursor == 2)
                    x = bs->xtx + character_width + 1;
                
                gui_show_EMS_input_box_cursor(b, x, y, 0, height, 1);
            }
        }
    }
}


U8 gui_check_ems_cursor_for_current_position(UI_EMS_input_box *b, ems_input_box_show_struct *bs)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
  
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_editor_line.cursor_line_flag)
    {
        if (g_editor_line.cur_read == g_editor_line.cursor_unit_index)
            return 1;
        
        if (g_editor_line.cursor_unit_index == g_editor_line.line_unit_count)
        {
            if (!g_editor_line.bidi_done_flag)
            {
                if (g_editor_line.line_unit_count == g_editor_line.cur_read + 1)
                    return 2;
            }
#ifdef __MMI_BIDI_ALG__
            else
            {
                if (g_editor_line.cur_v_read == g_editor_line.visual_unit_count - 1)
                    return 2;
            }
#endif
        }
    }
    
    return 0;
}


/*****************************************************************************
 * FUNCTION
 *  gui_find_ems_cursor_position
 * DESCRIPTION
 *  
 * PARAMETERS
 *  b       [?]     
 *  bs      [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void gui_find_ems_cursor_position(UI_EMS_input_box *b, ems_input_box_show_struct *bs)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x = b->saved_cursor_ax, d = 0;
    EMSPosition new_position;


    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (EMS_view_mode
        && bs->move_to_x == -1
        && bs->move_to_y == -1)
    {
        return;
    }

    
    if (x == -1)
        x = b->cursor_ax;

    if (bs->flags & UI_EMS_INPUT_BOX_PREVIOUS_LINE)
    {
        if (b->current_line == 0)
        {
            if (bs->flags & UI_EMS_INPUT_BOX_DISABLE_TONE)
            {
                b->flags &= ~UI_EMS_INPUT_BOX_DISABLE_TONE;
            }
            else
            {
                UI_editor_play_tone_cannot_navigate();
            }

            bs->find_new_cursor_flag = FOUND_CURSOR;
            return;
        }

        if (bs->n_lines == b->current_line - 1)
        {
            if (b->saved_cursor_ax == -1)
                b->saved_cursor_ax = b->cursor_ax;

            d = 1;
        }

    }
    else if (bs->flags & UI_EMS_INPUT_BOX_NEXT_LINE)
    {
        if (b->current_line == b->n_lines - 1)
        {
            if (bs->flags & UI_EMS_INPUT_BOX_DISABLE_TONE)
            {
                b->flags &= ~UI_EMS_INPUT_BOX_DISABLE_TONE;
            }
            else
            {
                UI_editor_play_tone_cannot_navigate();
            }

            bs->find_new_cursor_flag = FOUND_CURSOR;
            return;
        }

        if (bs->n_lines == b->current_line + 1)
        {
            if (b->saved_cursor_ax == -1)
                b->saved_cursor_ax = b->cursor_ax;
            d = 2;
        }
    }
    else if (bs->move_to_x != -1 || bs->move_to_y != -1)
    {
        x = bs->move_to_x;
        if (bs->move_to_y >= bs->yty && bs->move_to_y < bs->yty + g_editor_line.line_height)
            d = 3;

        if (bs->end_line 
            && (bs->move_to_y >= bs->yty + g_editor_line.line_height))
        {
            d = 3;
            x = b->x + b->width;
        }
    }

    if (d)
    {
        if (bs->xtx + g_editor_line.line_char[g_editor_line.cur_read].c_info.adv_x > x)
        {
            /* ok, have found it */
            if (bs->default_direction == BIDI_R && bs->xtx >= x && bs->end_line)
            {
            #ifdef __MMI_BIDI_ALG__
                if ((g_editor_line.bidi_done_flag && g_editor_line.logic_to_visual_map[g_editor_line.cur_read] == 0)
                    || (!g_editor_line.bidi_done_flag && g_editor_line.cur_read == 0))
            #else /* __MMI_BIDI_ALG__ */ 
                if (g_editor_line.cur_read == 0
                    || (g_editor_line.cur_read == 1 
                       && g_editor_line.line_char[0].c_info.data_len == 0))
            #endif /* __MMI_BIDI_ALG__ */ 
                {
                    /* 
                     * the x offset is less than the first display character,
                     * we need to set the cursor to the end of this line.
                     */
                    new_position.OffsetToText = b->data->textLength;
                    new_position.Object = b->data->listTail;
                    MoveCursorToPosition(b->data, &new_position);
                }
                else
                    gui_set_ems_cursor_at_current_object(b, bs);
            }
            else
                gui_set_ems_cursor_at_current_object(b, bs);
            bs->find_new_cursor_flag = FOUND_CURSOR;
        }
        else
        {
        #ifdef __MMI_BIDI_ALG__
            if (g_editor_line.bidi_done_flag)
            {
                if (g_editor_line.logic_to_visual_map[g_editor_line.cur_read] >= g_editor_line.visual_unit_count - 1)
                {
                    /*
                     * the current character is the last one of this line, 
                     * * but we still can't find the cursor_p.
                     */
                    if (bs->end_line)
                    {
                        /* 
                         * This is the last line of the whole text, we should set the cursor
                         * at the front of the NULL, not the last unit.
                         */
                        new_position.OffsetToText = b->data->textLength;
                        new_position.Object = b->data->listTail;
                        MoveCursorToPosition(b->data, &new_position);
                    }
                    else
                    {
                        gui_set_ems_cursor_at_current_object(b, bs);
                    }
                    bs->find_new_cursor_flag = FOUND_CURSOR;
                }
            }
            else
        #endif /* __MMI_BIDI_ALG__ */ 
            {
                if (g_editor_line.cur_read + 1 >= g_editor_line.line_unit_count)
                {
                    /*
                     * the current character is the last one of this line, 
                     * * but we still can't find the cursor_p. 
                     */
                    if (bs->end_line)
                    {
                        /* 
                         * This is the last line of the whole text, we should set the cursor
                         * at the front of the NULL, not the last unit.
                         */
                        new_position.OffsetToText = b->data->textLength;
                        new_position.Object = b->data->listTail;
                        MoveCursorToPosition(b->data, &new_position);
                    }
                    else
                    {
                        gui_set_ems_cursor_at_current_object(b, bs);
                    }
                    bs->find_new_cursor_flag = FOUND_CURSOR;
                }
            }
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  gui_set_ems_cursor_at_current_object
 * DESCRIPTION
 *  
 * PARAMETERS
 *  b       [?]     
 *  bs      [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void gui_set_ems_cursor_at_current_object(UI_EMS_input_box *b, ems_input_box_show_struct *bs)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 offset_text_at_line = g_editor_line.line_char[g_editor_line.cur_read].offset_text;
    EMSPosition mapped_position;
    EMSObject *unmapped_object;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mapped_position.OffsetToText = bs->line_start_position.OffsetToText + offset_text_at_line;
    mapped_position.Object = g_editor_line.line_char[g_editor_line.cur_read].object_unit;

    if (mapped_position.Object != NULL)
    {
        /* the current unit is a object */
        mapped_position.Object = mapped_position.Object->prev;
        MoveCursorToPosition(b->data, &mapped_position);
        return;
    }
    else
    {
        /* the current unit is text */
        unmapped_object = b->data->listHead;

        while (unmapped_object)
        {
            if (unmapped_object->OffsetToText > mapped_position.OffsetToText)
            {
                mapped_position.Object = unmapped_object->prev;
                
                if (mapped_position.Object != NULL
                    && mapped_position.Object->Type == EMS_TYPE_TEXT_FORMAT
                    && mapped_position.OffsetToText == mapped_position.Object->OffsetToText)
                    mapped_position.Object = mapped_position.Object->prev;

                MoveCursorToPosition(b->data, &mapped_position);
                return;
            }

            unmapped_object = unmapped_object->next;
        }

        mapped_position.Object = b->data->listTail;

        if (mapped_position.Object != NULL
            && mapped_position.Object->Type == EMS_TYPE_TEXT_FORMAT
            && mapped_position.OffsetToText == mapped_position.Object->OffsetToText)
            mapped_position.Object = mapped_position.Object->prev;

        MoveCursorToPosition(b->data, &mapped_position);
        return;
    }

}


/*****************************************************************************
 * FUNCTION
 *  gui_find_ems_cursor_position_for_view_mode
 * DESCRIPTION
 *  
 * PARAMETERS
 *  b       [?]     
 *  bs      [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void gui_find_ems_cursor_position_for_view_mode(UI_EMS_input_box *b, ems_input_box_show_struct *bs)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 fdl = b->first_displayed_line;
    S32 ldl = b->last_displayed_line;
    EMSPosition new_position, old_position;
    U8 flag;
    U8 done = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (bs->flags & UI_EMS_INPUT_BOX_PREVIOUS_LINE)
    {
        if (b->data->listHead == NULL)
        {
            b->current_line = fdl;
            if (b->current_line > 0)
            {
                b->current_line--;
            }
            else
            {
                b->cursor_ay = 0;
            }
            new_position.OffsetToText= b->line_positions_text_offset[b->current_line];
            #ifdef __MMI_MESSAGES_EMS__
            new_position.Object= gui_ems_get_object_by_index(b, b->line_positions_object_index[b->current_line]);
            #else
            new_position.Object= NULL;
            #endif
            MoveCursorToPosition(b->data, &new_position);
        }
        else
        {
            if ((b->data->CurrentPosition.OffsetToText > 0) || (b->data->CurrentPosition.Object != NULL))
            {
                while (!done)
                {
                    flag = 0;
                    if (b->current_line > 0)
                    {
                        flag = 1;
                        b->current_line--;
                    }
                    else
                    {
                        b->cursor_ay = 0;
                    }

                    new_position.OffsetToText= b->line_positions_text_offset[b->current_line];
                    #ifdef __MMI_MESSAGES_EMS__
                    new_position.Object= gui_ems_get_object_by_index(b, b->line_positions_object_index[b->current_line]);
                    #else
                    new_position.Object = NULL;
                    #endif
                    if (BackwardCurrentPositionObject(b->data, &new_position))
                    {
                        if (flag)
                        {
                            b->current_line++;
                        }
                    }
                    else
                    {
                        break;
                    }
                    if (b->current_line > 0)
                    {
                        b->current_line--;
                    }
                    else
                    {
                        break;
                    }
                    if (b->current_line <= (fdl - 1))
                    {
                        break;
                    }
                }
            }
        }
    }
    else if (bs->flags & UI_EMS_INPUT_BOX_PREVIOUS_OBJECT)
    {
        if (b->data->listHead)
        {
            if ((b->data->CurrentPosition.OffsetToText > 0) || (b->data->CurrentPosition.Object != NULL))
            {
                EMSPosition new_position;

                new_position.OffsetToText= b->line_positions_text_offset[b->current_line];
                #ifdef __MMI_MESSAGES_EMS__
                new_position.Object = gui_ems_get_object_by_index(b, b->line_positions_object_index[b->current_line]);
                #else
                new_position.Object = NULL;
                #endif
                
                BackwardCurrentPositionSeekObject(b->data, &new_position);
            }
        }
    }
    else if (bs->flags & UI_EMS_INPUT_BOX_NEXT_LINE)
    {
        if (b->data->listHead == NULL)
        {
            b->current_line = ldl;
            if (b->current_line < (b->n_lines - 1))
            {
                b->current_line++;
            }
            new_position.OffsetToText= b->line_positions_text_offset[b->current_line];
            #ifdef __MMI_MESSAGES_EMS__
            new_position.Object = gui_ems_get_object_by_index(b, b->line_positions_object_index[b->current_line]);
            #else
            new_position.Object = NULL;
            #endif
            MoveCursorToPosition(b->data, &new_position);
        }
        else
        {
            if (!TestLastPosition(b->data, &b->data->CurrentPosition))
            {
                while (!done)
                {
                    flag = 0;
                    if (b->current_line < (b->n_lines - 1))
                    {
                        flag = 1;
                        b->current_line++;
                    }
                    new_position.OffsetToText= b->line_positions_text_offset[b->current_line];
                    #ifdef __MMI_MESSAGES_EMS__
                    new_position.Object = gui_ems_get_object_by_index(b, b->line_positions_object_index[b->current_line]);
                    #else
                    new_position.Object = NULL;
                    #endif
                    if (ForwardCurrentPositionObject(b->data, &new_position))
                    {
                        if (flag)
                        {
                            b->current_line--;
                        }
                    }
                    else
                    {
                        break;
                    }
                    flag = 0;
                    if (b->current_line < (b->n_lines - 1))
                    {
                        new_position.OffsetToText= b->line_positions_text_offset[b->current_line + 1];
                        #ifdef __MMI_MESSAGES_EMS__
                        new_position.Object = gui_ems_get_object_by_index(b, b->line_positions_object_index[b->current_line + 1]);
                        #else
                        new_position.Object = NULL;
                        #endif
                    }
                    else
                    {
                        new_position.OffsetToText = b->data->textLength;
                        new_position.Object = b->data->listTail;
                        flag = 1;
                    }
                    old_position = b->data->CurrentPosition;
                    if (ForwardCurrentPositionObject(b->data, &new_position))
                    {
                        if (!flag)
                        {
                            MoveCursorToPosition(b->data, &old_position);
                        }
                    }
                    else
                    {
                        break;
                    }
                    if (b->current_line < (b->n_lines - 1))
                    {
                        b->current_line++;
                    }
                    else
                    {
                        break;
                    }
                    if (b->current_line >= (ldl + 1))
                    {
                        break;
                    }
                }
            }
        }
    }
    else if (bs->flags & UI_EMS_INPUT_BOX_NEXT_OBJECT)
    {
        if (b->data->listHead != NULL)
        {
            if (!TestLastPosition(b->data, &b->data->CurrentPosition))
            {
                if (b->current_line >= (b->n_lines - 1))
                {
                    new_position.OffsetToText = b->data->textLength;
                    new_position.Object = b->data->listTail;
                }
                else
                {
                    new_position.OffsetToText= b->line_positions_text_offset[b->current_line + 1];
                    #ifdef __MMI_MESSAGES_EMS__
                    new_position.Object = gui_ems_get_object_by_index(b, b->line_positions_object_index[b->current_line + 1]);
                    #else
                    new_position.Object = NULL;
                    #endif
                }
                ForwardCurrentPositionSeekObject(b->data, &new_position);
            }
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  gui_draw_ems_current_line_highlight
 * DESCRIPTION
 *  draw all the highlight for the current line
 * PARAMETERS
 *  b       [?]     
 *  bs      [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void gui_draw_ems_current_line_highlight(UI_EMS_input_box *b, ems_input_box_show_struct *bs)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 xtx, xx, tx, i;
    S32 char_width, char_height, highlight_width;
    S32 count = g_editor_line.line_unit_count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (bs->flags & UI_EMS_INPUT_BOX_DISABLE_DRAW)
        return;
    
    xx = bs->xx;
    tx = bs->tx;
    if (g_editor_line.highlight_flag)
    {
        if (!g_editor_line.bidi_done_flag)
        {
            count = g_editor_line.line_unit_count;
        }
#ifdef __MMI_BIDI_ALG__
        else
        {
            count = g_editor_line.visual_unit_count;
        }
#endif /* __MMI_BIDI_ALG__ */ 
        
        for(i=0; i<count; i++)
        {
            xtx = xx + tx;
            
            if (gui_get_ems_current_object(bs, i) < 0)
            {
                /* to the line end */
                break;
            }
            
            /* adjust the xtx for rx */
            tx += g_editor_line.line_char[g_editor_line.cur_read].c_info.rx;
            xtx += g_editor_line.line_char[g_editor_line.cur_read].c_info.rx;

            char_width = g_editor_line.line_char[g_editor_line.cur_read].c_info.adv_x;
            highlight_width = g_editor_line.line_char[g_editor_line.cur_read].c_info.w;
            highlight_width = char_width > highlight_width ? char_width : highlight_width;
            
            if ((g_editor_line.line_char[g_editor_line.cur_read].c_info.is_gap == MMI_LM_CLUSTER_ATTR_GAP) &&
                (gui_ems_inputs_is_cluster_gap(b, bs)))
            {
                char_width++;
                highlight_width++;
            }

            char_height = g_editor_line.line_height;
            
            if ((g_editor_line.line_char[g_editor_line.cur_read].highlight_flag) &&
                (g_editor_line.line_char[g_editor_line.cur_read].highlight_flag != EDITOR_HILITE_LIST_HIGHLIGHT))
            {
                gui_fill_rectangle(xtx, bs->yty, xtx + highlight_width, bs->yty + char_height - 2, b->selection_color);

                if (b->hilite_s_x == 0 && b->hilite_s_y == 0)
                {
                    b->hilite_s_x = xtx;
                    b->hilite_s_y = bs->yty;
                }
                b->hilite_e_x = xtx + highlight_width - 1;
                b->hilite_e_y = bs->yty;
            }

            tx += char_width;
        }
    }
}


#ifdef GUI_INPUT_BOX_CACHE_SUPPORT
/*****************************************************************************
* FUNCTION
*  gui_preset_ems_visible_line
* DESCRIPTION
*  
* PARAMETERS
*  b       [?]     
*  bs      [?]     
* RETURNS
*  void
*****************************************************************************/
S32 gui_preset_ems_visible_line(UI_EMS_input_box *b, ems_input_box_show_struct *bs)
{
    ems_all_line_struct *line_info;
   
    /* set the start line to the visible start line */
    gui_emsc_visible_start_line_get(&bs->sl);
    gui_emsc_visible_end_line_get(&bs->el);
    
    bs->current_position = bs->sl.current_position;
    bs->ty += bs->sl.offset_y;
    bs->n_lines = bs->sl.index;
    g_editor_line.line_start_p = b->data->textBuffer;
    b->display_height = bs->sl.offset_y;
    
    if(bs->sl.index > 0)
    {
        line_info = gui_emsc_line_info_get(bs->sl.index - 1);
        g_editor_line.line_height = line_info->line_height;
        g_editor_line.line_width = line_info->line_width;
        g_editor_line.line_char_count = line_info->char_count;
    }
    
    return 1;
}

/*****************************************************************************
 * FUNCTION
 *  gui_prepare_ems_one_line_context
 * DESCRIPTION
 *  
 * PARAMETERS
 *  b       [?]     
 *  bs      [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void gui_prepare_ems_one_line_context(UI_EMS_input_box *b, ems_input_box_show_struct *bs)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    ems_all_line_struct *lf;
    input_box_visible_line_struct *vlf;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* read line information from the line cache and visible line cache */
    lf = gui_emsc_line_info_get(bs->n_lines);
    vlf = gui_emsc_visible_info_get(bs->n_lines);

    gui_emsc_text_format_apply(b, bs, bs->n_lines);
	lastest_EMS_alignment = UI_EMS_current_alignment;
    bs->line_start_text_format = bs->line_end_text_format;
    bs->line_start_position = lf->current_position;
    bs->line_end_position = lf->end_position;
    bs->current_position = lf->current_position;

    /* set the line information to g_editor_line */
    g_editor_line.bidi_done_flag = 0;
    g_editor_line.cursor_line_flag = 0;
    
    g_editor_line.line_height = lf->line_height;
    g_editor_line.line_width = lf->line_width;
    g_editor_line.line_ascent = lf->line_ascent;
    g_editor_line.line_dscent = lf->line_dscent;
    g_editor_line.line_char_count = lf->char_count;
    g_editor_line.line_start_p = b->data->textBuffer + bs->current_position.OffsetToText;

    g_editor_line.highlight_flag = vlf->highlight_flag;
    g_editor_line.line_unit_count = vlf->line_unit_count;
    g_editor_line.marker_flag = vlf->marker_flag;
    g_editor_line.override_flag = vlf->override_flag;
    
#ifdef __MMI_MESSAGES_EMS__
    g_editor_line.line_char = temp_line_char;
    memcpy(g_editor_line.line_char, vlf->line_char, sizeof (gui_editor_character_unit_struct) * vlf->line_unit_count);
#else
    g_editor_line.line_char = vlf->line_char;
#endif

    if (bs->n_lines == b->n_lines - 1)
        bs->end_line = 1;
    
    gui_set_ems_highlight_information(b, bs);
    gui_prepare_ems_one_line_show(b, bs);
}


/*****************************************************************************
* FUNCTION
*  gui_set_ems_highlight_information
* DESCRIPTION
*  
* PARAMETERS
*  b       [?]     
*  bs      [?]     
* RETURNS
*  void
*****************************************************************************/
void gui_set_ems_highlight_information(UI_EMS_input_box *b, ems_input_box_show_struct *bs)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (i=0; i<g_editor_line.line_unit_count; i++)
    {
        g_editor_line.line_char[i].highlight_flag = (U8)gui_check_ems_character_highlight(b, bs, (U16)i);
        if (g_editor_line.highlight_flag == 0 && g_editor_line.line_char[i].highlight_flag)
            g_editor_line.highlight_flag = 1;
    }
}


/*****************************************************************************
* FUNCTION
*  gui_find_ems_cursor_from_cache
* DESCRIPTION
*  
* PARAMETERS
*  b       [?]     
*  bs      [?]     
* RETURNS
*  void
*****************************************************************************/
void gui_find_ems_cursor_from_cache(UI_EMS_input_box *b, ems_input_box_show_struct *bs)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 line_index, cursor_y, i, max_count;
    ems_all_line_struct *lf = NULL;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* read line information from the line cache and visible line cache */
 
    if (bs->find_new_cursor_flag
        || bs->cursor_line_found_flag)
        return;

    max_count = gui_emsc_total_line_count();
    if (max_count == 0)
    {
        b->current_line = 0;
        b->cursor_ay = 0;
        return;
    }
    
    for (i=0; i < max_count; i++)
    {
        lf = gui_emsc_line_info_get(i);
        if (lf == NULL)
        {
            if (!gui_inputs_cache_is_not_in_update())
            {
                gui_emsc_partial_line_update();
            }
        }

        if (i == max_count - 1)
            break;

        if (lf)
        {
            if (gui_check_ems_is_in_range
                 (b->data, &bs->mapped_cursor_position, &lf->current_position, &lf->end_position))
                 break;
        }
    }

    line_index = i;
    
    cursor_y = gui_emsc_line_cache_one_line_offset_y(line_index);
    b->current_line = line_index;
    if (lf)
    {
        b->cursor_line_height = lf->line_height;
    }
    b->cursor_ay = cursor_y;
}
#endif
#endif /* UI_EMS_SUPPORT */

