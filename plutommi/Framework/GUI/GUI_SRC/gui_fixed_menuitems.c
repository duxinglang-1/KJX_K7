/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*****************************************************************************
 *
 * Filename:
 * ---------
 *   gui_fixed_menuitems.c
 *
 * Project:
 * --------
 *   MAUI
 *
 * Description:
 * ------------
 *   Menu items in fixed menu - UI component
 *
 *   [Text menu item]
 *   [Icontext menu item]
 *   [Icontext-list menu item]
 *   [Twostate menu item]
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/

/***************************************************************************** 
 * Include 
 *****************************************************************************/
#include "MMI_features.h"
#include "gui_fixed_menuitems.h"
#include "kal_non_specific_general_types.h"
#include "gdi_include.h"
#include "wgui.h"
#include "CustMenuRes.h"
#include "ScreenRotationGprot.h"
#include "wgui_fixed_menuitems.h"
#include "gui_font_size.h"
#include "gui_theme_struct.h"
#include "gui_windows.h"
#include "gui_config.h"
#include "gui_typedef.h"
#include "MMIDataType.h"
#include "kal_general_types.h"
#include "CustThemesRes.h"
#include "gui.h"
#include "gui_data_types.h"
#include "gui_switch.h"
#include "gui_effect_oem.h"
#include "gdi_datatype.h"
#include "gui_fixed_menus.h"
#include "mmi_frm_input_gprot.h"
#include "CustDataProts.h"
#include "gdi_const.h"
#include "gui_themes.h"
#include "gui_scrollbars.h"
#include "GlobalConstants.h"
#ifndef __OPTR_NONE__
#include "operator_gui.h"
#endif
#include "string.h"
#include "wgui_fixed_menus.h"
#include "PixcomFontEngine.h"
#include "Unicodexdcl.h"
#include "kal_public_api.h"
#include "DebugInitDef_Int.h"
#include "wgui_include.h"
#include "mmi_frm_history_gprot.h"
#include "mmi_frm_events_gprot.h"
#include "mmi_frm_at_util_gprot.h"
#include "gui_main_menu_post_oem.h"
#include "wgui_inline_edit.h"
#include "wgui_categories_enum.h"
#include "wgui_draw_manager.h"
#include "gui_menu_post_oem.h"
#include "mmi_rp_app_uiframework_def.h"
#include "wgui_categories_util.h"
#include "CustDataRes.h"
#include "app_mem_med.h"

//#define __MAUI_SOFTWARE_LA__

#if defined(__MAUI_SOFTWARE_LA__) && defined(__MTK_TARGET__)
#include "SST_sla.h"
#define gui_swla_log_start(log)     SLA_CustomLogging(log, SA_start)
#define gui_swla_log_stop(log)     SLA_CustomLogging(log, SA_stop)
#else
#define gui_swla_log_start(log)
#define gui_swla_log_stop(log)
#endif

/***************************************************************************** 
 * Static Declaration
 *****************************************************************************/ 
/* current scrolling text */ 
scrolling_text gui_current_scroll_text[FIXED_ICONTEXT_LIST_MAX_TEXT_COLUMNS]; 
#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
/* For list highlighter effects */
#ifdef __MMI_UI_LIST_FLASH_HIGHLIGHT_EFFECTS__
static S32 g_flash_feel_state = GUI_LIST_EFFECT_FLASH_FEELING_STOP;
#endif
S32 gblock_list_effect = 0;
#endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */ 
S32 gblock_list_animation_highlight = 0;

static MMI_BOOL g_gui_menuitem_need_scroll = MMI_FALSE;


#ifdef  __MMI_GUI_LIST_MENUITEM_FULL_PACKAGE__
/* orange color poup dialog */
static UI_filled_area colorangewgui_pop_up_dialog_background =
    {UI_FILLED_AREA_TYPE_COLOR | UI_FILLED_AREA_VERTICAL_FILL | UI_FILLED_AREA_SINGLE_BORDER,
    UI_NULL_IMAGE,
    NULL,
    {255, 220, 185, 100},
    {0, 0, 0, 0},
    {255, 163, 70, 100},
    {50, 50, 50, 100},
    0
};
#endif  // __MMI_GUI_LIST_MENU_FULL_PACKAGE__

static gui_animation_with_background_struct g_gui_animation_with_background_cntx;
static gui_animation_with_background_struct * const anim_with_bkg_p = &g_gui_animation_with_background_cntx;

static void UI_dummy_scrolling_text_draw_background(S32 x1, S32 y1, S32 x2, S32 y2);
#ifndef __MMI_UI_MENU_SLIM__
static MMI_BOOL gui_filled_area_is_animation(UI_filled_area *f);
static void gui_scroll_text_draw_animated_effect_filler(S32 x1, S32 y1, S32 x2, S32 y2, UI_filled_area *f);
#else
 #define gui_scroll_text_draw_animated_effect_filler(_arg1, _arg2, _arg3, _arg4, _arg5) 
 #define gui_filled_area_is_animation(_arg) 
#endif
//#define scrolling_text_draw_two_line_background(_arg1, _arg2, _arg3, _arg4) gui_show_two_line_background(_arg1, _arg2, _arg3, _arg4)
static void gui_fixed_icontext_menuitem_scroll_handler(void);
static void gui_fixed_icontext_menuitem_get_text_dimension(fixed_icontext_menuitem_type *mi, UI_string_type text, S32 *width, S32 *height);
static void scrolling_text_draw_icontext_single_line_background(S32 x1,S32 y1,S32 x2,S32 y2);
static void scrolling_text_draw_twostate_single_line_background(S32 x1,S32 y1,S32 x2,S32 y2);
static void scrolling_text_draw_icontext_list_single_line_background(S32 x1,S32 y1,S32 x2,S32 y2);

/*
* Global function 
*/
void gui_get_fixed_menuitem_flag(void *item, void *common_item_data, S32 index, U32* flags, U32* flags_ext,S32 Is_two_state);
/***************************************************************************** 
 * Global Variable
 *****************************************************************************/
/*
 * current UI menuitem theme
 */
UI_fixed_text_menuitem_theme *current_fixed_text_menuitem_theme = NULL;
UI_fixed_icontext_menuitem_theme *current_fixed_icontext_menuitem_theme = NULL;
UI_fixed_icontext_list_menuitem_theme *current_fixed_icontext_list_menuitem_theme = NULL;
UI_fixed_twostate_menuitem_theme *current_fixed_twostate_menuitem_theme = NULL;

/* 
 * tempoary highlight fillers for the transparent color effect 
 * in HIGHLIGHTER_COLOR_OPACITY_VALUE, defined in gui_fixed_menuitems.h
 */
// TODO: REMOVE THESE, SHOULD CHANGE THE HIGHLIGHT FILLER ALPHA VALUE DIRECTLY
#ifdef __MMI_UI_TRANSPARENT_EFFECT__
UI_filled_area fixed_icontext_menuitem_transparent_filled_area;
UI_filled_area fixed_icontext_list_menuitem_transparent_filled_area;
UI_filled_area fixed_twostate_menuitem_transparent_filled_area;
UI_filled_area fixed_two_line_menuitem_transparent_filled_area;
#endif /* __MMI_UI_TRANSPARENT_EFFECT__ */

#if (defined __MMI_UI_TWO_LINE_MENUITEM_STYLES__ || defined __MMI_UI_HINTS_IN_MENUITEM__)
static UI_filled_area *fixed_two_line_menuitem_filler = NULL;
static UI_filled_area *fixed_two_line_menuitem_without_sc_filler = NULL;
#endif

/* text scrolling related data */
S32 UI_text_menuitem_scroll_time = UI_TEXT_MENUITEM_SCROLL_TIME;
S32 UI_text_menuitem_scroll_size = UI_TEXT_MENUITEM_SCROLL_SIZE;
S32 UI_text_menuitem_scroll_gap = UI_TEXT_MENUITEM_SCROLL_GAP;
S32 UI_text_menuitem_scroll_pause = UI_TEXT_MENUITEM_SCROLL_PAUSE;
UI_filled_area fixed_single_line_menuitem_filled_area;
/* Text scrolling related functions within the menu item */
fixed_icontext_list_menuitem *GUI_current_fixed_icontext_list_menuitem_common_data = NULL;
fixed_icontext_list_menuitem_type *GUI_current_fixed_icontext_list_menuitem_data = NULL;
U8 GUI_current_fixed_icontext_list_menuitem_text_is_scroll[FIXED_ICONTEXT_LIST_MAX_TEXT_COLUMNS];
U8 GUI_current_fixed_icontext_list_menuitem_scroll = 0;
U8 GUI_current_fixed_icontext_list_menuitem_scroll_direction;
S32 GUI_current_fixed_icontext_list_menuitem_x;
S32 GUI_current_fixed_icontext_list_menuitem_y;
S32 GUI_current_fixed_icontext_list_menuitem_scroll_counter = 0;

/* Current text column for marqueeing. Auto selected with UI_MENUITEM_AUTO_CHOOSE_MARQUEE. */
S32 GUI_current_fixed_icontext_list_menuitem_column = 0;
//UI_string_type GUI_current_fixed_icontext_list_menuitem_scroll_text = NULL;
//UI_string_type GUI_current_fixed_icontext_list_menuitem_scroll_text_end = NULL;

#ifdef __MMI_OP11_SIDEBAR__
static MMI_BOOL in_show_fixed_list = MMI_FALSE;
#endif

extern PU8 MMI_mm_animation;


extern gui_effect_struct    *g_slide_effect;

#if defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN)
extern gui_list_smooth_scrolling_by_pen_state_enum g_gui_ssp_state;
#endif

extern S32 gdi_anim_get_current_frame_number(gdi_handle serial_handle);
extern gdi_handle g_gui_ssp_static_layer; 

#if defined(__MMI_UI_TWO_LINE_MENUITEM_STYLES__) && defined(__MMI_TOUCH_SCREEN__)
extern void mmi_two_line_translate_pen_event(S32 x, S32 y, mmi_pen_event_type_enum pen_event,gui_list_pen_enum *menuitem_event);
#endif /* defined(__MMI_UI_TWO_LINE_MENUITEM_STYLES__) && defined(__MMI_TOUCH_SCREEN__) */
extern MMI_BOOL g_current_display_half_menuitem;


#if (defined __MMI_UI_TWO_LINE_MENUITEM_STYLES__ || defined __MMI_UI_HINTS_IN_MENUITEM__)
#define GUI_TWO_LINE_TEXT_ICON_GAP 5
extern void line_scrolling_text_timer_handler(void);
#endif 

#define GUI_MENUITEM_DATA_LEFT_GAP 5

static S32 gui_menuitem_dummy_checkbox_clicked_callback(S32 item_index);
static S32 gui_menuitem_dummy_checkbox_get_image_callback(S32 item_index, PU8 *checkbox_image);

static void gui_menuitem_icontext_show_checkbox(fixed_icontext_menuitem *m, S32 x1, S32 y1);
static void gui_menuitem_icontext_checkbox_get_data(gui_menuitem_icontext_checkbox_struct *checkbox, fixed_icontext_menuitem *m, S32 x1, S32 y1);

static void gui_menuitem_icontext_list_show_checkbox(fixed_icontext_list_menuitem *m, S32 x1, S32 y1);
static void gui_menuitem_icontext_list_checkbox_get_data(gui_menuitem_icontext_checkbox_struct *checkbox, fixed_icontext_list_menuitem *m, S32 x1, S32 y1);

static void gui_menuitem_adjust_text_clip_for_right_gap(void *common_item_data);
#ifdef __MMI_UI_LIST_SLIDE_EFFECT__
static S32 gui_menuitem_is_image_highlight(void *common_item_data);
#else
#define gui_menuitem_is_image_highlight(_arg) 
#endif
static void gui_menuitem_draw_list_filler(S32 x1, S32 y1, S32 x2, S32 y2, UI_filled_area *f, MMI_BOOL isAnimate, MMI_BOOL onTran);
#ifndef __MMI_UI_MENU_SLIM__
static void gui_draw_animated_effect_filler(S32 x1, S32 y1, S32 x2, S32 y2, UI_filled_area *f);
#else
 #define gui_draw_animated_effect_filler(_arg1, _arg2, _arg3, _arg4, _arg5) 
#endif
static void gui_get_fixed_menuitem_flags_int(void *item, void *common_item_data, U32* flags, U32* flags_ext);
static void gui_get_menu_region_V(void* common_item_data, S32* menu_y1, S32* menu_y2);

#define scrolling_text_draw_two_line_background gui_show_two_line_background
void gui_menuitem_set_text_position(void *m, S32 x, S32 y);

//static void gui_menuitem_set_icon_position(void *m, S32 x, S32 y);
void gui_menuitem_set_icon_position(void *m, S32 x, S32 y);
static void gui_show_two_line_icontext_list_menuitem(void *item, void *common_item_data, UI_filled_area **f);
#ifdef  __MMI_UI_HINTS_IN_MENUITEM__
static MMI_BOOL gui_menuitem_has_hint(gui_common_menuitem_base_struct *m, U32 flags);
#endif

#ifdef  __MMI_CAT203_SUPPORT__
GetUnderLineFuncPtr g_gui_list_get_underline = NULL;
#endif

UI_font_type g_gui_list_data_font = NULL;
S32 g_gui_list_data_gap = 0;
/* this is used to show different text color for icontext list menuitem */
#ifdef  __MMI_OP01_DCD__
color g_gui_list_text_color = {0,0,0,100};
#endif

#ifdef __MMI_OP11_SIDEBAR__
U32 g_gui_list_clock = WGUI_CLOCK_INVALID_INDEX;
#endif

GetMenuitemFlags g_gui_list_get_menuitem_flags = NULL;
#if defined(__MMI_UI_LIST_HIGHLIGHT_EFFECTS__)|| !defined(__MMI_UI_MENU_SLIM__)
static S32 xstart_effect, ystart_effect, xend_effect, yend_effect;
static S32 list_highlight_effect_current_frame = 0;
#endif

#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
static S32 list_highlight_effect_times = 0;
#endif
#ifndef __MMI_UI_MENU_SLIM__
static MMI_BOOL gui_list_in_scroll = MMI_FALSE;
#endif
#if defined(__MMI_UI_LIST_HIGHLIGHT_EFFECTS__)|| !defined(__MMI_UI_MENU_SLIM__)
static void *ghighlight_item;
static void *ghighlight_common_item_data;
static S32 gstartX1, gstartY1;
#endif
#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
static S32 is_draw_next_frame_list_highlight_effect = 0;
#endif
void (*gui_call_menuitem_scroll) (void);


/* Pop up description related data  */

/*****************************************************************************
 * FUNCTION
 *  UI_dummy_display_pop_up_description
 * DESCRIPTION
 *  dummy function of display popup
 * PARAMETERS
 *  x           [IN]        Start x position
 *  y           [IN]        Start y position
 *  width       [IN]        Width of popup
 *  height      [IN]        Hieght of popup
 * RETURNS
 *  void
 *****************************************************************************/
void UI_dummy_display_pop_up_description(S32 x, S32 y, S32 width, S32 height)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(x);
    UI_UNUSED_PARAMETER(y);
    UI_UNUSED_PARAMETER(width);
    UI_UNUSED_PARAMETER(height);
}

#ifdef __MMI_UI_HINTS_IN_MENUITEM__


/*****************************************************************************
 * FUNCTION
 *  UI_dummy_get_current_pop_up_description_string
 * DESCRIPTION
 *  Dummy function to get popup description string.
 * PARAMETERS
 *  void
 * RETURNS
 *  NULL
 *****************************************************************************/
UI_string_type UI_dummy_get_current_pop_up_description_string(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return NULL;
}

#endif /* __MMI_UI_HINTS_IN_MENUITEM__ */ 


// intern use
gdi_handle gui_list_set_alpha_blending_layer_ex(U32 flags, MMI_BOOL ext)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gdi_handle old_alpha_layer = GDI_NULL_HANDLE;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (MMI_fixed_list_menu.alpha_blend_layer_handle)
    {
        old_alpha_layer = gdi_set_alpha_blending_source_layer(MMI_fixed_list_menu.alpha_blend_layer_handle);
    }
    else if (ext)
    {
        if ((flags & UI_MENUITEM_STATE_FOCUSSED && !(flags & UI_MENUITEM_DISABLE_HIGHLIGHT)) || g_slide_effect->in_flatten)
        {
            gdi_layer_get_active(&old_alpha_layer);
            old_alpha_layer = gdi_set_alpha_blending_source_layer(old_alpha_layer);
        }
    }

    return old_alpha_layer;
}

#define gui_list_set_alpha_blending_layer() gui_list_set_alpha_blending_layer_ex(0, MMI_FALSE)

void gui_list_reset_alpha_blending_layer(gdi_handle old_alpha_layer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (old_alpha_layer)
    {
        gdi_set_alpha_blending_source_layer(old_alpha_layer);
    }
}

UI_filled_area * gui_list_get_focussed_filler(gui_common_menuitem_base_struct *m)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    UI_filled_area *f = NULL;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if ((MMI_current_menu_type == LIST_MENU) && 
        ((MMI_fixed_list_menu.flags & UI_LIST_MENU_DISABLE_SCROLLBAR) ||
        ((MMI_fixed_list_menu.flags & UI_LIST_MENU_AUTO_DISABLE_SCROLLBAR) &&
        (MMI_fixed_list_menu.displayed_items >= MMI_fixed_list_menu.n_items))))
    {
        f = m->focussed_without_sc_filler;
    }
    else
    {
        f = m->focussed_filler;
    }

    return f;
}

#ifdef __MMI_UI_TRANSPARENT_EFFECT__
static BOOL block_transparency = FALSE;
UI_filled_area non_transparent_focussed_filler;
UI_filled_area *backup_focussed_filler;
S32 transparency_in_list = 0;

/*****************************************************************************
 * FUNCTION
 *  gui_block_transparency_effect
 * DESCRIPTION
 *  Block the transparency effect.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gui_block_transparency_effect(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    block_transparency = TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  gui_unblock_transparency_effect
 * DESCRIPTION
 *  Unblock the transparency effect.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gui_unblock_transparency_effect(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    block_transparency = FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  gui_fixed_icontext_enable_transparent_effect
 * DESCRIPTION
 *  Enable the transparent effect for the icontext menu item.
 * PARAMETERS
 *  m           [IN]    common icontext menu item object
 * RETURNS
 *  void
 *****************************************************************************/
void gui_fixed_icontext_enable_transparent_effect(void* common_item_data)//(fixed_icontext_menuitem *m)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gui_common_menuitem* m = (gui_common_menuitem*)common_item_data;  
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (block_transparency)
    {
        return;
    }

    /* to enable transparency only when it is required */
    if (transparency_in_list)
    {
        m->focussed_filler = backup_focussed_filler;
    }
    transparency_in_list = 0;
}


/*****************************************************************************
 * FUNCTION
 *  gui_fixed_icontext_disable_transparent_effect
 * DESCRIPTION
 *  Disable the transparent effect for the icontext menu item.
 * PARAMETERS
 *  m           [IN]    common icontext menu item object     
 * RETURNS
 *  void
 *****************************************************************************/
void gui_fixed_icontext_disable_transparent_effect(void*common_item_data)//(fixed_icontext_menuitem *m)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gui_common_menuitem* m = (gui_common_menuitem*)common_item_data;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (block_transparency)
    {
        return;
    }
    /* disable transparency only when it is enabled */
    if (m->focussed_filler->flags & UI_FILLED_AREA_TYPE_TRANSPARENT_COLOR)
    {
        transparency_in_list = 1;
        backup_focussed_filler = m->focussed_filler;
        non_transparent_focussed_filler = *backup_focussed_filler;
        m->focussed_filler = &non_transparent_focussed_filler;
        m->focussed_filler->flags = m->focussed_filler->flags & ~UI_FILLED_AREA_TYPE_TRANSPARENT_COLOR;
    }
}






#endif /* __MMI_UI_TRANSPARENT_EFFECT__ */ 


/*****************************************************************************
 * FUNCTION
 *  gui_menuitem_dummy_checkbox_clicked_callback
 * DESCRIPTION
 *  Dummy function of checkbox clicked callback.
 * PARAMETERS
 *  item_index       [IN]       item index
 * RETURNS
 *  MMI_TRUE
 *****************************************************************************/
static S32 gui_menuitem_dummy_checkbox_clicked_callback(S32 item_index)
{    
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(item_index);
    
    return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  gui_menuitem_dummy_checkbox_get_image_callback
 * DESCRIPTION
 *  Dummy function of checkbox get image callback.
 * PARAMETERS
 *  item_index      [IN]        item index
 *  checkbox_image  [IN]        image data
 * RETURNS
 *  MMI_TRUE
 *****************************************************************************/
static S32 gui_menuitem_dummy_checkbox_get_image_callback(S32 item_index, PU8 *checkbox_image)
{    
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(item_index);
    *checkbox_image = (PU8)GetImage(CHECKBOX_OFF_IMAGE_ID);
    
    return MMI_TRUE;
}


/* Fixed menuitem dummy functions: Do not delete any of these functions */


/*****************************************************************************
 * FUNCTION
 *  UI_fixed_menuitem_dummy_display_function
 * DESCRIPTION
 *  Dummy item display function.
 * PARAMETERS
 *  item                    [IN]        private menu item
 *  common_item_data        [IN]        common menu item
 *  x                       [IN]        x
 *  y                       [IN]        y
 * RETURNS
 *  void
 *****************************************************************************/
void UI_fixed_menuitem_dummy_display_function(void *item, void *common_item_data, S32 x, S32 y)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(item);
    UI_UNUSED_PARAMETER(common_item_data);
    UI_UNUSED_PARAMETER(x);
    UI_UNUSED_PARAMETER(y);
}


/*****************************************************************************
 * FUNCTION
 *  UI_fixed_menuitem_dummy_hide_function
 * DESCRIPTION
 *  Dummy item hide function.
 * PARAMETERS
 *  item                    [IN]        private menu item
 *  common_item_data        [IN]        common menu item
 *  x                       [IN]        x
 *  y                       [IN]        y       
 * RETURNS
 *  void
 *****************************************************************************/
void UI_fixed_menuitem_dummy_hide_function(void *item, void *common_item_data, S32 x, S32 y)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(item);
    UI_UNUSED_PARAMETER(common_item_data);
    UI_UNUSED_PARAMETER(x);
    UI_UNUSED_PARAMETER(y);
}


/*****************************************************************************
 * FUNCTION
 *  UI_fixed_menuitem_dummy_measure_function
 * DESCRIPTION
 *  Dummy item measure function.
 * PARAMETERS
 *  item                    [IN]        private menu item
 *  common_item_data        [IN]        common menu item      
 *  width                   [OUT]       item width
 *  height                  [OUT]       item height    
 * RETURNS
 *  void
 *****************************************************************************/
void UI_fixed_menuitem_dummy_get_length_function(void *item, void *common_item_data, S32 *width)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(item);
    UI_UNUSED_PARAMETER(common_item_data);
    UI_UNUSED_PARAMETER(width);
}


/*****************************************************************************
 * FUNCTION
 *  UI_fixed_menuitem_dummy_measure_function
 * DESCRIPTION
 *  Dummy item measure function.
 * PARAMETERS
 *  item                    [IN]        private menu item
 *  common_item_data        [IN]        common menu item      
 *  width                   [OUT]       item width
 *  height                  [OUT]       item height    
 * RETURNS
 *  void
 *****************************************************************************/
void UI_fixed_menuitem_dummy_measure_function(void *item, void *common_item_data, S32 *width, S32 *height)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(item);
    UI_UNUSED_PARAMETER(common_item_data);
    UI_UNUSED_PARAMETER(width);
    UI_UNUSED_PARAMETER(height);
}


/*****************************************************************************
 * FUNCTION
 *  UI_fixed_menuitem_dummy_highlight_function
 * DESCRIPTION
 *  Dummy item highlight function.
 * PARAMETERS
 *  item                    [IN]        private menu item
 *  common_item_data        [IN]        common menu item       
 * RETURNS
 *  void
 *****************************************************************************/
void UI_fixed_menuitem_dummy_highlight_function(void *item, void *common_item_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(item);
    UI_UNUSED_PARAMETER(common_item_data);
}


/*****************************************************************************
 * FUNCTION
 *  UI_fixed_menuitem_dummy_remove_highlight_function
 * DESCRIPTION
 *  Dummy item remove highlight function.
 * PARAMETERS
 *  item                    [IN]        private menu item
 *  common_item_data        [IN]        common menu item         
 * RETURNS
 *  void
 *****************************************************************************/
void UI_fixed_menuitem_dummy_remove_highlight_function(void *item, void *common_item_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(item);
    UI_UNUSED_PARAMETER(common_item_data);
}


/*****************************************************************************
 * FUNCTION
 *  UI_fixed_menuitem_dummy_resize_function
 * DESCRIPTION
 *  Dummy item resize function.
 * PARAMETERS
 *  x       [IN]        item width
 *  y       [IN]        item height
 * RETURNS
 *  void
 *****************************************************************************/
void UI_fixed_menuitem_dummy_resize_function(S32 x, S32 y)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(x);
    UI_UNUSED_PARAMETER(y);
}


#ifdef __MMI_TOUCH_SCREEN__

/*****************************************************************************
 * FUNCTION
 *  UI_fixed_menuitem_dummy_pen_function
 * DESCRIPTION
 *  Dummy menu item pen handler.
 * PARAMETERS
 *  item                    [IN]        private menu item
 *  common_item_data        [IN]        common menu item
 *  item_x                  [IN]        item x1
 *  item_y                  [IN]        item y1
 *  pen_event               [IN]        pen event type
 *  x                       [IN]        pen x
 *  y                       [IN]        pen y
 *  menuitem_event          [OUT]       pen event result
 *  menuitem_param          [IN]        pen event parameter
 * RETURNS
 *  Return MMI_TRUE if the pen event is handled; otherwise, MMI_FALSE.
 *****************************************************************************/
BOOL UI_fixed_menuitem_dummy_pen_function(
        void *item,
        void *common_item_data,
        S32 item_x,
        S32 item_y,
        mmi_pen_event_type_enum pen_event,
        S16 x,
        S16 y,
        gui_list_pen_enum *menuitem_event,
        gui_pen_event_param_struct *menuitem_param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(item);
    UI_UNUSED_PARAMETER(common_item_data);
    UI_UNUSED_PARAMETER(pen_event);
    UI_UNUSED_PARAMETER(x);
    UI_UNUSED_PARAMETER(y);
    UI_UNUSED_PARAMETER(menuitem_event);
    UI_UNUSED_PARAMETER(menuitem_param);
    return MMI_FALSE;
}
#endif /* __MMI_TOUCH_SCREEN__ */ 


/*****************************************************************************
 *
 * TEXT MENUITEM                                                             
 *                                                                           
 * implemented by the icontext menuitem                                      
 *
 *****************************************************************************/

/*****************************************************************************
 * FUNCTION
 *  gui_set_fixed_text_menuitem_theme
 * DESCRIPTION
 *  Apply the given theme to a common text menu item.
 * PARAMETERS
 *  m           [IN]        common text menu item object
 *  t           [IN]        text menu item theme
 * RETURNS
 *  void
 *****************************************************************************/
void gui_set_fixed_text_menuitem_theme(fixed_text_menuitem *m, UI_fixed_text_menuitem_theme *t)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_set_fixed_icontext_menuitem_theme(
        (fixed_icontext_menuitem*)m, 
        (UI_fixed_icontext_menuitem_theme*)t);
}


/*****************************************************************************
 * FUNCTION
 *  gui_set_fixed_text_menuitem_current_theme
 * DESCRIPTION
 *  Apply the current theme to a common text menuitem.
 * PARAMETERS
 *  m           [IN]        common text menu item object
 * RETURNS
 *  void
 *****************************************************************************/
void gui_set_fixed_text_menuitem_current_theme(fixed_text_menuitem *m)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_set_fixed_icontext_menuitem_theme(
        (fixed_icontext_menuitem*)m, 
        (UI_fixed_icontext_menuitem_theme*)current_fixed_text_menuitem_theme);
}


/*****************************************************************************
 * FUNCTION
 *  gui_create_fixed_text_menuitem
 * DESCRIPTION
 *  Create a common text menu item.
 * PARAMETERS
 *  m           [IN]        common text menu item object
 *  width       [IN]        width
 *  height      [IN]        height
 * RETURNS
 *  void
 *****************************************************************************/
void gui_create_fixed_text_menuitem(fixed_text_menuitem *m, S32 width, S32 height)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    UI_fixed_icontext_menuitem_theme *old_theme;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    old_theme = current_fixed_icontext_menuitem_theme;
    current_fixed_icontext_menuitem_theme = (UI_fixed_icontext_menuitem_theme*)current_fixed_text_menuitem_theme;
    gui_create_fixed_icontext_menuitem(m, width, height);
    current_fixed_icontext_menuitem_theme = old_theme;
}


/*****************************************************************************
 * FUNCTION
 *  gui_fixed_text_menuitem_set_text_position
 * DESCRIPTION
 *  Set the text position of a common text menuitem
 * PARAMETERS
 *  m           [IN]        common text menu item object
 *  x           [IN]        x
 *  y           [IN]        y
 * RETURNS
 *  void
 *****************************************************************************/
void gui_fixed_text_menuitem_set_text_position(fixed_text_menuitem *m, S32 x, S32 y)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    m->text_x = x;
    m->text_y = y;
	m->scroll_width = m->width - m->text_x;
}


/*****************************************************************************
 * FUNCTION
 *  gui_resize_fixed_text_menuitem
 * DESCRIPTION
 *  Resize a common text menu item.
 * PARAMETERS
 *  m           [IN]        common text menu item object
 *  width       [IN]        new width
 *  height      [IN]        new height
 * RETURNS
 *  void
 *****************************************************************************/
void gui_resize_fixed_text_menuitem(fixed_text_menuitem *m, S32 width, S32 height)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    m->width = width;
    m->height = height;
	m->scroll_width = m->width - m->text_x - 1;
}


/*****************************************************************************
 * FUNCTION
 *  gui_fixed_text_menuitem_scroll_handler
 * DESCRIPTION
 *  Scroll handler of the highlighted text menu item.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gui_fixed_text_menuitem_scroll_handler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_fixed_icontext_menuitem_scroll_handler();
}



/*****************************************************************************
 * FUNCTION
 *  gui_fixed_text_menuitem_stop_scroll
 * DESCRIPTION
 *  Stop scrolling for the highlighted text menu item.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gui_fixed_text_menuitem_stop_scroll(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_fixed_icontext_menuitem_stop_scroll();
}


/*****************************************************************************
 * FUNCTION
 *  gui_show_fixed_text_menuitem
 * DESCRIPTION
 *  Show a text menu item.
 * PARAMETERS
 *  item                    [IN]        private text menu item object
 *  common_item_data        [IN]        common text menu item object
 *  x                       [IN]        x
 *  y                       [IN]        y
 * RETURNS
 *  void
 *****************************************************************************/
void gui_show_fixed_text_menuitem(void *item, void *common_item_data, S32 x, S32 y)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_show_fixed_icontext_menuitem(item, common_item_data, x, y);
}


/*****************************************************************************
 * FUNCTION
 *  gui_measure_fixed_text_menuitem
 * DESCRIPTION
 *  Measure a text menu item for dimension.
 * PARAMETERS
 *  item                    [IN]        private text menu item object
 *  common_item_data        [IN]        common text menu item object
 *  width                   [OUT]       item width
 *  height                  [OUT]       item height
 * RETURNS
 *  void
 *****************************************************************************/
void gui_measure_fixed_text_menuitem(void *item, void *common_item_data, S32 *width, S32 *height)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_measure_fixed_icontext_menuitem(item, common_item_data, width, height);
}


/*****************************************************************************
 * FUNCTION
 *  gui_measure_fixed_text_menuitem
 * DESCRIPTION
 *  Measure a text menu item for dimension.
 * PARAMETERS
 *  item                    [IN]        private text menu item object
 *  common_item_data        [IN]        common text menu item object
 *  width                   [OUT]       item width
 *  height                  [OUT]       item height
 * RETURNS
 *  void
 *****************************************************************************/
void gui_get_fixed_text_length_menuitem(void *item, void *common_item_data, S32 *width)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 sh;//sw, 
    UI_string_type _text;    
    fixed_icontext_menuitem_type *mi = (fixed_icontext_menuitem_type*) item;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    _text = mi->item_text;
	gui_measure_string(_text, width, &sh);
}


/*****************************************************************************
 * FUNCTION
 *  gui_highlight_fixed_text_menuitem
 * DESCRIPTION
 *  Highlight a text menu item (not visually).
 * PARAMETERS
 *  item                    [IN]        private text menu item object
 *  common_item_data        [IN]        common text menu item object       
 * RETURNS
 *  void
 *****************************************************************************/
void gui_highlight_fixed_text_menuitem(void *item, void *common_item_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_highlight_fixed_icontext_menuitem(item, common_item_data);
}


/*****************************************************************************
 * FUNCTION
 *  gui_remove_highlight_fixed_text_menuitem
 * DESCRIPTION
 *  Remove the highlight of a text menu item (not visually).
 * PARAMETERS
 *  item                    [IN]        private text menu item object
 *  common_item_data        [IN]        common text menu item object    
 * RETURNS
 *  void
 *****************************************************************************/
void gui_remove_highlight_fixed_text_menuitem(void *item, void *common_item_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_remove_highlight_fixed_icontext_menuitem(item, common_item_data);
}


/*****************************************************************************
 *
 * ICONTEXT MENUITEM                                                             
 *                                                                           
 *                                
 *
 *****************************************************************************/

/*****************************************************************************
 * FUNCTION
 *  gui_set_fixed_icontext_menuitem_current_theme
 * DESCRIPTION
 *  Apply the current theme to an icontext menu item.
 * PARAMETERS
 *  m           [IN]        common icontext menu item object
 * RETURNS
 *  void
 *****************************************************************************/
void gui_set_fixed_icontext_menuitem_current_theme(fixed_icontext_menuitem *m)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_set_fixed_icontext_menuitem_theme(m, current_fixed_icontext_menuitem_theme);
}


/*****************************************************************************
 * FUNCTION
 *  gui_set_fixed_icontext_menuitem_theme
 * DESCRIPTION
 *  Apply the given theme to an icontext menu item.
 * PARAMETERS
 *  m           [IN]        common icontext menu item object
 *  t           [IN]        icontext menu item theme
 * RETURNS
 *  void
 *****************************************************************************/
void gui_set_fixed_icontext_menuitem_theme(fixed_icontext_menuitem *m, UI_fixed_icontext_menuitem_theme *t)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    m->disabled_filler = t->disabled_filler;
    m->disabled_text_color = t->disabled_text_color;
    m->flags |= t->flags;
    m->focussed_filler = t->focussed_filler;
    if (t->focussed_without_sc_filler)
    {
        m->focussed_without_sc_filler = t->focussed_without_sc_filler;
    }
    else
    {
        m->focussed_without_sc_filler = t->focussed_filler;
    }
#ifdef __MMI_UI_TRANSPARENT_EFFECT__
    /* This is to replace the UI_FILLED_AREA_TYPE_TRANSPARENT_COLOR flag and alpha value from the themecomponent.h */
    if (m->focussed_filler && 
        (m->focussed_filler->flags & 0xFF) != UI_FILLED_AREA_TYPE_BITMAP &&
        (m->focussed_filler->flags & 0xFF) != UI_FILLED_AREA_TYPE_IMAGE_RIGHT_ALIGN &&
        (m->focussed_filler->flags & 0xFF) != UI_FILLED_AREA_TYPE_IMAGE_LEFT_ALIGN)
    {
        fixed_icontext_menuitem_transparent_filled_area = *(m->focussed_filler);
        m->focussed_filler = &fixed_icontext_menuitem_transparent_filled_area;
        fixed_icontext_menuitem_transparent_filled_area.flags |= UI_FILLED_AREA_TYPE_TRANSPARENT_COLOR;
        fixed_icontext_menuitem_transparent_filled_area.c.alpha = HIGHLIGHTER_COLOR_OPACITY_VALUE;
    }
#endif /* __MMI_UI_TRANSPARENT_EFFECT__ */ 
    m->focussed_text_color = t->focussed_text_color;
    m->normal_filler = t->normal_filler;
    m->normal_text_color = t->normal_text_color;
    m->selected_filler = t->selected_filler;
    m->selected_text_color = t->selected_text_color;
    m->text_font = t->text_font;
}


/*****************************************************************************
 * FUNCTION
 *  gui_create_fixed_icontext_menuitem
 * DESCRIPTION
 *  Create a common icontext menu item.
 * PARAMETERS
 *  m           [IN]        common icontext menu item object
 *  width       [IN]        width
 *  height      [IN]        height
 * RETURNS
 *  void
 *****************************************************************************/
void gui_create_fixed_icontext_menuitem(fixed_icontext_menuitem *m, S32 width, S32 height)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	memset(m, 0, sizeof(fixed_icontext_menuitem));
    m->width = width;
    m->height = height;
    gui_set_fixed_icontext_menuitem_current_theme(m);
    m->scroll_width = width;

    m->checkbox_clicked_callback = gui_menuitem_dummy_checkbox_clicked_callback;
    m->checkbox_get_image_callback = gui_menuitem_dummy_checkbox_get_image_callback;    
}


/*****************************************************************************
 * FUNCTION
 *  gui_fixed_icontext_menuitem_set_icon_position
 * DESCRIPTION
 *  Set the icon position of a common icontext menuitem.
 * PARAMETERS
 *  m           [IN]        common icontext menu item object
 *  x           [IN]        icon x
 *  y           [IN]        icon y
 * RETURNS
 *  void
 *****************************************************************************/
void gui_fixed_icontext_menuitem_set_icon_position(fixed_icontext_menuitem *m, S32 x, S32 y)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_menuitem_set_icon_position(m, x, y);
}


/*****************************************************************************
 * FUNCTION
 *  gui_resize_fixed_icontext_menuitem
 * DESCRIPTION
 *  Resize a common icontext menu item.
 * PARAMETERS
 *  m           [IN]        common icontext menu item object
 *  width       [IN]        new width
 *  height      [IN]        new height
 * RETURNS
 *  void
 *****************************************************************************/
void gui_resize_fixed_icontext_menuitem(fixed_icontext_menuitem *m, S32 width, S32 height)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    m->width = width;
    m->height = height;
    if (m->icon_x > m->text_x)
    {
        m->scroll_width = m->icon_x - m->text_x;
    }
    else
    {
        m->scroll_width = m->width - m->text_x;
    }

    /* keep the text right clip spacing for list menu image highlight */
    if (MMI_current_menu_type == LIST_MENU)
    {

#ifdef __MMI_FTE_SUPPORT__
        if ( !(MMI_fixed_list_menu.flags & UI_LIST_MENU_INLINE_EDIT))
        {
            m->scroll_width -= GUI_MENUITEM_TEXT_RIGHT_GAP;
        }
        else
        {
            m->scroll_width -= 1;
        }
#else
        /* adjust the scrolling width if image highlight is used */
#ifdef __MMI_UI_LIST_SLIDE_EFFECT__
        if (gui_menuitem_is_image_highlight(m) || !(MMI_fixed_list_menu.flags & UI_LIST_MENU_INLINE_EDIT))
#else
        if (!(MMI_fixed_list_menu.flags & UI_LIST_MENU_INLINE_EDIT))
#endif
        {
            m->scroll_width -= GUI_MENUITEM_TEXT_RIGHT_GAP;
        }
        else
        {
            m->scroll_width -= 1;
        }
#endif
    }
}


/* Text scrolling related functions within the menu item */
fixed_icontext_menuitem *GUI_current_fixed_icontext_menuitem_common_data = NULL;
fixed_icontext_menuitem_type *GUI_current_fixed_icontext_menuitem_data = NULL;
U8 GUI_current_fixed_icontext_menuitem_scroll = 0;
U8 GUI_current_fixed_icontext_menuitem_scroll_direction;
S32 GUI_current_fixed_icontext_menuitem_x;
S32 GUI_current_fixed_icontext_menuitem_y;
S32 GUI_current_fixed_icontext_menuitem_y2;
S32 GUI_current_fixed_icontext_menuitem_x2;
S32 GUI_current_fixed_icontext_menuitem_scroll_counter = 0;
UI_string_type GUI_current_fixed_icontext_menuitem_scroll_text = NULL;
UI_string_type GUI_current_fixed_icontext_menuitem_scroll_text_end = NULL;


/*****************************************************************************
 * FUNCTION
 *  scrolling_text_draw_background_filler
 * DESCRIPTION
 *  Draw background filler for the scrolling menu item.
 * PARAMETERS
 *  x1          [IN]        x1
 *  y1          [IN]        y1
 *  x2          [IN]        x2
 *  y2          [IN]        y2
 *  f             [IN]        background filler
 *  has_round_rect  [IN]  the menu item has UI_MENUITEM_EXT_SHOW_IN_ROUNDED_RECT flags
 * RETURNS
 *  void
 *****************************************************************************/
static void scrolling_text_draw_background_filler(
        S32 x1, S32 y1, S32 x2, S32 y2, 
        UI_filled_area *f, 
        MMI_BOOL has_round_rect)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#ifndef __MMI_UI_MENU_SLIM__	
    S32 count;
#endif
    gdi_handle old_alpha_layer;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    old_alpha_layer = gui_list_set_alpha_blending_layer();
#ifndef __MMI_UI_MENU_SLIM__
    if (gui_filled_area_is_animation(f))
    {
        gdi_image_get_frame_count(f->b, &count);
        if (count >= 1)
        {
            gui_scroll_text_draw_animated_effect_filler(x1, y1, x2, y2, f);
        }                    
    }            
    else
#endif		
		if (f)
    {
        if (has_round_rect)
        {
            gui_draw_filled_area(x1, y1 + 1, x2, y2 - 1, f);
        }
        else
        {
            gui_draw_filled_area(x1, y1, x2, y2, f);
        }
    }
    else
    {
        gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_TRANSPARENT);
    }

    gui_list_reset_alpha_blending_layer(old_alpha_layer);
}


/*****************************************************************************
 * FUNCTION
 *  scrolling_text_draw_icontext_single_line_background
 * DESCRIPTION
 *  Draw background for the scrolling single line menu item.
 * PARAMETERS
 *  x1          [IN]        x1
 *  y1          [IN]        y1
 *  x2          [IN]        x2
 *  y2          [IN]        y2
 * RETURNS
 *  void
 *****************************************************************************/
static void scrolling_text_draw_icontext_single_line_background(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    UI_filled_area *f;
    fixed_icontext_menuitem *m;
    MMI_BOOL has_round_rect = MMI_FALSE;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    //m = (fixed_icontext_menuitem*)MMI_fixed_list_menu.common_item_data;
	m = (fixed_icontext_menuitem*)GUI_current_fixed_icontext_menuitem_common_data;

	if (m->hide_function)
    {
        m->hide_function(x1, y1, x2, y2);
        return;
    }
    gdi_layer_push_and_set_clip(x1, y1, x2, y2);
    f = &fixed_single_line_menuitem_filled_area;

    if ((MMI_current_menu_type == LIST_MENU) && 
        (GUI_current_fixed_icontext_menuitem_data->ext_flags & UI_MENUITEM_EXT_SHOW_IN_ROUNDED_RECT))
    {
        has_round_rect = MMI_TRUE;
    }

#ifdef  __MMI_MAINLCD_320X480__
    if (MMI_current_menu_type == MATRIX_MENU)
    {
        if (current_MMI_theme->matrix_main_menu_highlight_image)
        {
            f->b = current_MMI_theme->matrix_main_menu_highlight_image;
            f->flags = UI_FILLED_AREA_TYPE_BITMAP;
        }
        else
        {
            f = NULL;
        }
    }
#endif  // __MMI_MAINLCD_320X480__

    if (g_dm_data.s32CatId == MMI_CATEGORY_CASCADING_MENU_ID)
    {
        if (g_gui_list_hide_menu)
        {
            g_gui_list_hide_menu(x1, y1, x2, y2);
        }
    }

    scrolling_text_draw_background_filler(
        GUI_current_fixed_icontext_menuitem_x,
        GUI_current_fixed_icontext_menuitem_y,
        GUI_current_fixed_icontext_menuitem_x2,
        GUI_current_fixed_icontext_menuitem_y2, 
        f,
        has_round_rect);

    gdi_layer_pop_clip();
}


/*****************************************************************************
 * FUNCTION
 *  scrolling_text_draw_icontext_list_single_line_background
 * DESCRIPTION
 *  Draw background for the scrolling single line menu item.
 * PARAMETERS
 *  x1          [IN]        x1
 *  y1          [IN]        y1
 *  x2          [IN]        x2
 *  y2          [IN]        y2
 * RETURNS
 *  void
 *****************************************************************************/
static void scrolling_text_draw_icontext_list_single_line_background(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    UI_filled_area *f;
    fixed_icontext_list_menuitem m;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    m = MMI_fixed_icontext_list_menuitem;

    if (m.ext_flags & UI_MENUITEM_SHOW_HIGHLIGHTED_HINT)
    {
        /* verify two line menuitem highlight image dimension */
        m.height *= 2;
        
        m.focussed_filler = current_MMI_theme->menuitem_two_line_highlight_filler;
        m.focussed_without_sc_filler = current_MMI_theme->menuitem_two_line_highlight_filler;//menuitem_two_line_highlight_without_scroll_filler

        f = gui_list_get_focussed_filler((gui_common_menuitem_base_struct*) &m);
        if (f)
        {
            fixed_single_line_menuitem_filled_area = *f;
        }
    }   
    f = &fixed_single_line_menuitem_filled_area;

    if (g_dm_data.s32CatId == MMI_CATEGORY_CASCADING_MENU_ID)
    {
        if (g_gui_list_hide_menu)
        {
            g_gui_list_hide_menu(x1, y1, x2, y2);
        }
    }

    scrolling_text_draw_background_filler(
        GUI_current_fixed_icontext_list_menuitem_x,
        GUI_current_fixed_icontext_list_menuitem_y,
        GUI_current_fixed_icontext_list_menuitem_x + MMI_fixed_icontext_list_menuitem.width - 1,
        GUI_current_fixed_icontext_list_menuitem_y + m.height - 1, 
        f,
        MMI_FALSE);
}


/*****************************************************************************
 * FUNCTION
 *  gui_fixed_icontext_menuitem_scroll_text_handler
 * DESCRIPTION
 *  Scroll text handler of the highlighted icontext menu item.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gui_fixed_icontext_menuitem_scroll_text_handler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 flags = GUI_current_fixed_icontext_menuitem_common_data->flags;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!(flags & UI_MENUITEM_MARQUEE_SCROLL) && !(flags & UI_MENUITEM_TWO_DIRECTION_SCROLL))
    {
        return;
    }

    if (GUI_current_fixed_icontext_menuitem_scroll == 0)
    {
        return;
    }

#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
#ifdef  __MMI_UI_LIST_FLASH_HIGHLIGHT_EFFECTS__
    /* If the flash feeling list effect is running, wait for it to finish. */
    if ((gui_get_current_list_effect() == MMI_UI_LIST_HIGHLIGHT_EFFECT_FLASH_FEELING) &&
        (MMI_current_menu_type == LIST_MENU) &&
        (g_flash_feel_state != GUI_LIST_EFFECT_FLASH_FEELING_STOP))        
    {        
        return;
    }
#endif  /* __MMI_UI_LIST_FLASH_HIGHLIGHT_EFFECTS__ */    
#endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */
#ifndef __MMI_UI_MENU_SLIM__
    gui_list_in_scroll = MMI_TRUE;
#endif
#if defined(__MMI_MAINLCD_320X480__)
#ifdef __MMI_MATRIX_MAIN_MENU_OPTIMIZE__
    if (MMI_current_menu_type == MATRIX_MENU)
    {
        gui_show_fixed_icontext_menuitem(
            (void*)GUI_current_fixed_icontext_menuitem_data,
            (void*)GUI_current_fixed_icontext_menuitem_common_data,
            GUI_current_fixed_icontext_menuitem_x,
            GUI_current_fixed_icontext_menuitem_y);
    }
#endif
#endif
    gui_handle_scrolling_text(&gui_current_scroll_text[0]);
    
    flags |= GUI_current_fixed_icontext_menuitem_data->flags;
    GUI_current_fixed_icontext_menuitem_common_data->ext_flags |= UI_MENUITEM_EXT_SHOW_IN_MARQUEE;

    #ifdef __MMI_UI_TRANSPARENT_EFFECT__
        if (!gui_is_current_transparency_with_multi_layer())
        {
            gui_fixed_icontext_disable_transparent_effect(GUI_current_fixed_icontext_menuitem_common_data);     /* To hide text below scrolling text */
        }
    #endif /* __MMI_UI_TRANSPARENT_EFFECT__ */ 

    #ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
        /*
         * Disable the list effect for showing the highlighted menu item later.
         * When scrolling, no list effect is allowed. e.g., HIGHLIGHT_EFFECT_FLASH_FEELING.
         */
        gui_reset_current_list_effect();
    #endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */

    #ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
        /* restore list effect */
        gui_restore_current_list_effect();
    #endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */

    #ifdef __MMI_UI_TRANSPARENT_EFFECT__
        gui_fixed_icontext_enable_transparent_effect(GUI_current_fixed_icontext_menuitem_common_data);  /* Enable after scrolling text */
    #endif 

        GUI_current_fixed_icontext_menuitem_common_data->ext_flags &= ~UI_MENUITEM_EXT_SHOW_IN_MARQUEE;
#ifndef __MMI_UI_MENU_SLIM__   
    gui_list_in_scroll = MMI_FALSE;    
#endif
}


/*****************************************************************************
 * FUNCTION
 *  gui_fixed_icontext_menuitem_scroll_handler
 * DESCRIPTION
 *  Scroll handler of the highlighted icontext menu item.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_fixed_icontext_menuitem_scroll_handler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 flags = GUI_current_fixed_icontext_menuitem_common_data->flags;
#ifdef __MMI_SUBLCD__
    gdi_handle act_lcd;
#endif

	S32 layer_offset_x, layer_offset_y;
	S32	x1, y1;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!(flags & UI_MENUITEM_MARQUEE_SCROLL) && !(flags & UI_MENUITEM_TWO_DIRECTION_SCROLL))
    {
        return;
    }

    if (GUI_current_fixed_icontext_menuitem_scroll == 0)
    {
        return;
    }

#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
#ifdef  __MMI_UI_LIST_FLASH_HIGHLIGHT_EFFECTS__
    /* If the flash feeling list effect is running, wait for it to finish. */
    if ((gui_get_current_list_effect() == MMI_UI_LIST_HIGHLIGHT_EFFECT_FLASH_FEELING) &&
        (MMI_current_menu_type == LIST_MENU) &&
        (g_flash_feel_state != GUI_LIST_EFFECT_FLASH_FEELING_STOP))        
    {        
        return;
    }
#endif  /* __MMI_UI_LIST_FLASH_HIGHLIGHT_EFFECTS__ */    
#endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */

#ifndef __MMI_UI_MENU_SLIM__
    gui_list_in_scroll = MMI_TRUE;
#endif
    if (GUI_current_fixed_icontext_menuitem_common_data->parent_list)
    {
        fixed_list_menu *parent_list = GUI_current_fixed_icontext_menuitem_common_data->parent_list;
        #ifdef __MMI_SUBLCD__
		gdi_lcd_get_active(&act_lcd);
        gdi_lcd_set_active(parent_list->act_lcd_handle);
		#endif
        gdi_layer_push_and_set_active(parent_list->act_layer_handle);

        GUI_current_fixed_icontext_menuitem_common_data->parent_list->current_displayed_item = -1;
    }

    flags |= GUI_current_fixed_icontext_menuitem_data->flags;
    if (GUI_current_fixed_icontext_menuitem_scroll_counter)
    {
        GUI_current_fixed_icontext_menuitem_scroll_counter--;
    }
    else
    {
        if (flags & UI_MENUITEM_MARQUEE_SCROLL)
        {
            if (mmi_fe_get_r2l_state())
            {
                GUI_current_fixed_icontext_menuitem_common_data->scroll_x += UI_text_menuitem_scroll_size;
                if (GUI_current_fixed_icontext_menuitem_common_data->scroll_x >=
                    (GUI_current_fixed_icontext_menuitem_common_data->text_width + UI_text_menuitem_scroll_gap))
                {
                    GUI_current_fixed_icontext_menuitem_common_data->scroll_x = 0;
                }
            }
            else
            {
                GUI_current_fixed_icontext_menuitem_common_data->scroll_x -= UI_text_menuitem_scroll_size;
                if (GUI_current_fixed_icontext_menuitem_common_data->scroll_x <=
                    (-(GUI_current_fixed_icontext_menuitem_common_data->text_width + UI_text_menuitem_scroll_gap)))
                {
                    GUI_current_fixed_icontext_menuitem_common_data->scroll_x = 0;
                }
            }
        }
        else
        {
            if (GUI_current_fixed_icontext_menuitem_scroll_direction == 0)
            {
                GUI_current_fixed_icontext_menuitem_common_data->scroll_x -= UI_text_menuitem_scroll_size;
                if ((GUI_current_fixed_icontext_menuitem_common_data->scroll_x +
                     GUI_current_fixed_icontext_menuitem_common_data->text_width) <=
                    (GUI_current_fixed_icontext_menuitem_common_data->scroll_width))
                {
                    GUI_current_fixed_icontext_menuitem_scroll_direction = 1;
                    GUI_current_fixed_icontext_menuitem_scroll_counter = UI_text_menuitem_scroll_pause;
                }
            }
            else if (GUI_current_fixed_icontext_menuitem_scroll_direction == 1)
            {
                GUI_current_fixed_icontext_menuitem_common_data->scroll_x += UI_text_menuitem_scroll_size;
                if (GUI_current_fixed_icontext_menuitem_common_data->scroll_x >= 0)
                {
                    GUI_current_fixed_icontext_menuitem_scroll_direction = 0;
                    GUI_current_fixed_icontext_menuitem_scroll_counter = UI_text_menuitem_scroll_pause;
                }
            }
        }
        GUI_current_fixed_icontext_menuitem_common_data->ext_flags |= UI_MENUITEM_EXT_SHOW_IN_MARQUEE;

    #ifdef __MMI_UI_TRANSPARENT_EFFECT__
        if (!gui_is_current_transparency_with_multi_layer())
        {
            gui_fixed_icontext_disable_transparent_effect(GUI_current_fixed_icontext_menuitem_common_data);     /* To hide text below scrolling text */
        }
    #endif /* __MMI_UI_TRANSPARENT_EFFECT__ */ 

    #ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
        /*
         * Disable the list effect for showing the highlighted menu item later.
         * When scrolling, no list effect is allowed. e.g., HIGHLIGHT_EFFECT_FLASH_FEELING.
         */
        gui_reset_current_list_effect();
    #endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */
    
        gui_show_fixed_icontext_menuitem(
            (void*)GUI_current_fixed_icontext_menuitem_data,
            (void*)GUI_current_fixed_icontext_menuitem_common_data,
            GUI_current_fixed_icontext_menuitem_x,
            GUI_current_fixed_icontext_menuitem_y);

#ifdef __MMI_FTE_SUPPORT__        
        {
            gdi_handle layers[4], act_layer;
            gdi_layer_get_blt_layer(&layers[0], &layers[1], &layers[2], &layers[3]);
            if (mmi_fe_get_r2l_state())
            {
                gdi_layer_push_and_set_clip(
                    MMI_fixed_list_menu.x, 
                    GUI_current_fixed_icontext_menuitem_y, 
                    MMI_fixed_list_menu.x + MMI_fixed_list_menu.vbar.width - 1, 
                    GUI_current_fixed_icontext_menuitem_y2);
            }
            else
            {
                gdi_layer_push_and_set_clip(
                    MMI_fixed_list_menu.x + MMI_fixed_list_menu.width - 1 - MMI_fixed_list_menu.vbar.width, 
                    GUI_current_fixed_icontext_menuitem_y, 
                    MMI_fixed_list_menu.x + MMI_fixed_list_menu.width - 1, 
                    GUI_current_fixed_icontext_menuitem_y2);
            }
            /* menu height might be larger than normal one. Prevent the scrollbar mismatch when going back to the normal menu */
            
            gdi_layer_flatten_with_clipping(layers[0], layers[1], layers[2], layers[3]);
            gdi_layer_get_active(&act_layer);
            
            gui_enable_scrollbar_redraw_clip(MMI_FALSE);
            gui_vertical_scrollbar_set_alpha_blend_layer(&MMI_fixed_list_menu.vbar, act_layer);
            gui_show_vertical_scrollbar(&MMI_fixed_list_menu.vbar);
            gui_vertical_scrollbar_set_alpha_blend_layer(&MMI_fixed_list_menu.vbar, MMI_fixed_list_menu.act_layer_handle);
            gui_enable_scrollbar_redraw_clip(MMI_TRUE);
            gui_pop_clip();
        }   
#endif


    #ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
        /* restore list effect */
        gui_restore_current_list_effect();
    #endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */

    #ifdef __MMI_UI_TRANSPARENT_EFFECT__
        gui_fixed_icontext_enable_transparent_effect(GUI_current_fixed_icontext_menuitem_common_data);  /* Enable after scrolling text */
    #endif 

        GUI_current_fixed_icontext_menuitem_common_data->ext_flags &= ~UI_MENUITEM_EXT_SHOW_IN_MARQUEE;

		/* consider layer offset for JUI category 176 */
		gdi_layer_get_position(&layer_offset_x, &layer_offset_y);
		x1 = GUI_current_fixed_icontext_menuitem_x + layer_offset_x;
		y1 = GUI_current_fixed_icontext_menuitem_y + layer_offset_y;

    #if defined(__MMI_UI_TWO_LINE_MENUITEM_STYLES__) && defined(__MMI_UI_HINTS_IN_MENUITEM__)
        if (GUI_current_fixed_icontext_menuitem_common_data->ext_flags & UI_MENUITEM_EXT_SHOW_TWO_LINE_SELECT)
        {
            gui_BLT_double_buffer(
                x1,
                y1,
                x1 + GUI_current_fixed_icontext_menuitem_common_data->width - 1,
                y1 + (GUI_current_fixed_icontext_menuitem_common_data->height << 1) - 1);
        }
        else if ((GUI_current_fixed_icontext_menuitem_common_data->ext_flags & UI_MENUITEM_SHOW_ALL_HINTS ||
                  ((GUI_current_fixed_icontext_menuitem_data->flags & UI_MENUITEM_STATE_FOCUSSED) &&
                   (GUI_current_fixed_icontext_menuitem_common_data->ext_flags & UI_MENUITEM_SHOW_HIGHLIGHTED_HINT))) &&
                   GUI_current_fixed_icontext_menuitem_common_data->parent_list && 
                   GUI_current_fixed_icontext_menuitem_common_data->parent_list->gui_get_current_pop_up_description_string && 
                 (GUI_current_fixed_icontext_menuitem_common_data->parent_list->gui_get_current_pop_up_description_string()))
        {
            gui_BLT_double_buffer(
                x1,
                y1,
                x1 + GUI_current_fixed_icontext_menuitem_common_data->width - 1,
                y1 + (GUI_current_fixed_icontext_menuitem_common_data->height << 1) - 1);
        }
        else
        {
            gui_BLT_double_buffer(
                x1,
                y1,
                x1 + GUI_current_fixed_icontext_menuitem_common_data->width - 1,
                y1 + GUI_current_fixed_icontext_menuitem_common_data->height - 1);
        }        
    #else /* defined(__MMI_UI_TWO_LINE_MENUITEM_STYLES__) && defined(__MMI_UI_HINTS_IN_MENUITEM__) */ 
    #ifdef __MMI_UI_TWO_LINE_MENUITEM_STYLES__
        if (GUI_current_fixed_icontext_menuitem_common_data->ext_flags & UI_MENUITEM_EXT_SHOW_TWO_LINE_SELECT)
        {
            gui_BLT_double_buffer(
                x1,
                y1,
                x1 + GUI_current_fixed_icontext_menuitem_common_data->width - 1,
                y1 + (GUI_current_fixed_icontext_menuitem_common_data->height << 1) - 1);
        }
        else
        {
            gui_BLT_double_buffer(
                x1,
                y1,
                x1 + GUI_current_fixed_icontext_menuitem_common_data->width - 1,
                y1 + GUI_current_fixed_icontext_menuitem_common_data->height - 1);
        }
    #else /* __MMI_UI_TWO_LINE_MENUITEM_STYLES__ */ 

    #ifdef __MMI_UI_HINTS_IN_MENUITEM__
        if ((GUI_current_fixed_icontext_menuitem_common_data->ext_flags & UI_MENUITEM_SHOW_ALL_HINTS ||
             ((GUI_current_fixed_icontext_menuitem_data->flags & UI_MENUITEM_STATE_FOCUSSED) &&
              (GUI_current_fixed_icontext_menuitem_common_data->ext_flags & UI_MENUITEM_SHOW_HIGHLIGHTED_HINT))) &&
            (GUI_current_fixed_icontext_menuitem_common_data->parent_list->gui_get_current_pop_up_description_string()))
        {
            gui_BLT_double_buffer(
                x1,
                y1,
                x1 + GUI_current_fixed_icontext_menuitem_common_data->width - 1,
                y1 + (GUI_current_fixed_icontext_menuitem_common_data->height << 1) - 1);
        }
        else
        {
            gui_BLT_double_buffer(
                x1,
                y1,
                x1 + GUI_current_fixed_icontext_menuitem_common_data->width - 1,
                y1 + GUI_current_fixed_icontext_menuitem_common_data->height - 1);
        }
    #else /* __MMI_UI_HINTS_IN_MENUITEM__ */

        gui_BLT_double_buffer(
            x1,
            y1,
            x1 + GUI_current_fixed_icontext_menuitem_common_data->width - 1,
            y1 + GUI_current_fixed_icontext_menuitem_common_data->height - 1);

    #endif /* __MMI_UI_HINTS_IN_MENUITEM__ */ 

    #endif /* __MMI_UI_TWO_LINE_MENUITEM_STYLES__ */ 
    #endif /* defined(__MMI_UI_TWO_LINE_MENUITEM_STYLES__) && defined(__MMI_UI_HINTS_IN_MENUITEM__) */ 
    }

    if (GUI_current_fixed_icontext_menuitem_common_data->parent_list)
    {
        gdi_layer_pop_and_restore_active();
		#ifdef __MMI_SUBLCD__
        gdi_lcd_set_active(act_lcd);
		#endif
    }
#ifndef __MMI_UI_MENU_SLIM__    
    gui_list_in_scroll = MMI_FALSE;    
#endif
#ifdef  __MMI_CAT203_SUPPORT__    
    if (g_gui_list_get_underline)
    {
        gui_start_timer(UI_text_menuitem_scroll_time, gui_fixed_icontext_menuitem_scroll_handler);
    }
#endif  // __MMI_CAT203_SUPPORT__    
}


/*****************************************************************************
 * FUNCTION
 *  gui_menuitem_redraw_scrolling_text
 * DESCRIPTION
 *  redraw the scolling text in menu item.
 * PARAMETERS
 *  scrolling_text  [IN]    scrolling text instance
 *  x                 [IN]        x
 *  y                 [IN]        y
 *  width           [IN]        width
 *  height          [IN]        height
 *  text_color    [IN]        the text color of scolling text
 *  text_border_color  [IN]  the text border color of scolling text
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_menuitem_redraw_scrolling_text(
        scrolling_text *scrolling_text,
        S32 x,
        S32 y,
        S32 width,
        S32 height,
        color *text_color,
        color *text_border_color
    )
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    void (*draw_background_temp)(S32 x1, S32 y1, S32 x2, S32 y2);
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (scrolling_text)
    {
        scrolling_text->x = x;
        scrolling_text->y = y;
        scrolling_text->width = width;
        scrolling_text->height = height;
        if (text_color)
        {
            scrolling_text->text_color = *text_color;
        }
        
        if (text_border_color)
        {
            scrolling_text->text_border_color = *text_border_color;
        }
        gdi_layer_lock_frame_buffer();
        draw_background_temp = scrolling_text->draw_background;
        scrolling_text->draw_background = UI_dummy_scrolling_text_draw_background;
        gui_redraw_scrolling_text(scrolling_text);
        scrolling_text->draw_background = draw_background_temp;
        gdi_layer_unlock_frame_buffer();
    }
}


/*****************************************************************************
 * FUNCTION
 *  gui_list_menuitem_set_font
 * DESCRIPTION
 *  set the font fot menu item
 * PARAMETERS
 *  cm      [IN]    the menu item's base structure
 *  flags    [IN]    the flags of menu items
 * RETURNS
 *  void
 *****************************************************************************/
void gui_list_menuitem_set_font(gui_common_menuitem_base_struct *cm, U32 flags)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#ifdef __MMI_UI_LIST_HIGHLIGHT_BOLD
    stFontAttribute highlight_font;
#endif /*__MMI_UI_LIST_HIGHLIGHT_BOLD*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_UI_LIST_HIGHLIGHT_BOLD
    if (flags & UI_MENUITEM_STATE_FOCUSSED)
    {
        highlight_font = *cm->text_font;
        highlight_font.bold = 2;
        gui_set_font(&highlight_font);
    }
    else
#endif /*__MMI_UI_LIST_HIGHLIGHT_BOLD*/
    {
        if ((flags & UI_MENUITEM_STATE_FOCUSSED) &&
            (MMI_current_menu_type == LIST_MENU) &&
            !(flags & UI_MENUITEM_DISABLE_HIGHLIGHT) &&
            cm && !(cm->flags & UI_MENUITEM_DISABLE_HIGHLIGHT))
        {
            gui_set_font((UI_font_type)gui_font_get_type(GUI_FONT_SIZE_LIST_HIGHLIGHT));
        }
        else
        {
            gui_set_font(cm->text_font);
        }
    }
}



extern void wgui_inline_get_default_indicator_width( S32 *pwidth, S32 *pheight);
/*****************************************************************************
 * FUNCTION
 *  gui_fixed_icontext_menuitem_start_scroll
 * DESCRIPTION
 *  Start scrolling for the highlighted icontext menu item.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gui_fixed_icontext_menuitem_start_scroll(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    fixed_icontext_menuitem_type *t = (fixed_icontext_menuitem_type*) GUI_current_fixed_icontext_menuitem_data;
    fixed_icontext_menuitem *m = (fixed_icontext_menuitem*) GUI_current_fixed_icontext_menuitem_common_data;
    S32 w, h, scroll_width;
    U32 flags, ret_flag = 0, ret_flag_ext = 0;
#ifdef __MMI_UI_LIST_HIGHLIGHT_BOLD
    stFontAttribute highlight_font;
#endif /*__MMI_UI_LIST_HIGHLIGHT_BOLD*/
    UI_filled_area *f = NULL;
    S32 i_width = 0, i_height = 0;
#ifdef  __MMI_CAT203_SUPPORT__    
    S32 *underline_array;
    S32 count = 0;
#endif  // __MMI_CAT203_SUPPORT__

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (t == NULL || m == NULL)
    {
        return;
    }

    t->flags |= UI_MENUITEM_STATE_FOCUSSED;
    flags = m->flags;
    flags |= t->flags;
    if (flags & UI_MENUITEM_DISABLE_TEXT_DISPLAY)
    {
        return;
    }
    if (MMI_current_menu_type == LIST_MENU)
    {
        if(!gui_show_list_menu_check_scrollbar(&MMI_fixed_list_menu))
        {
            if (MMI_fixed_list_menu.width == MMI_content_width)
            {
                MMI_fixed_list_menu.item_resize_function(MMI_fixed_list_menu.width - 4, 0);
            }
        }
        else
        {
#ifdef __MMI_FTE_SUPPORT__
            MMI_fixed_list_menu.item_resize_function(MMI_fixed_list_menu.width - GUI_MENUITEM_X1_GAP - GUI_MENUITEM_X2_GAP, 0);
#else
            MMI_fixed_list_menu.item_resize_function(MMI_fixed_list_menu.width - MMI_fixed_list_menu.vbar.width - GUI_MENUITEM_X1_GAP - GUI_MENUITEM_X2_GAP, 0);
#endif
        }
    }

    if (g_gui_list_get_menuitem_flags)
    {
        g_gui_list_get_menuitem_flags(MMI_fixed_list_menu.highlighted_item, &ret_flag, &ret_flag_ext);
        flags |= ret_flag;
    }

#ifdef __MMI_UI_LIST_HIGHLIGHT_BOLD
    highlight_font = *m->text_font;
    highlight_font.bold = 2;
    gui_set_font(&highlight_font);
#else /*__MMI_UI_LIST_HIGHLIGHT_BOLD*/

#if defined(__MMI_OP11_HOMESCREEN__) || defined(__MMI_OP11_SIDEBAR__)
    if (t->ext_flags & UI_MENUITEM_EXT_SHOW_DATA)
    {
        if (g_gui_list_data_font)
        {
            gui_set_font(g_gui_list_data_font);
        }
        else
        {
            gui_set_font(&MMI_small_font);
        }
    }
    else
#endif  //  defined(__MMI_OP11_HOMESCREEN__) || defined(__MMI_OP11_SIDEBAR__)
    {
        if (MMI_current_menu_type == LIST_MENU && !(flags & UI_MENUITEM_DISABLE_HIGHLIGHT))
        {
            gui_set_font((UI_font_type)gui_font_get_type(GUI_FONT_SIZE_LIST_HIGHLIGHT));
        }
        else
        {
            gui_set_font(m->text_font);
        }
    }
#endif /*__MMI_UI_LIST_HIGHLIGHT_BOLD*/

    gui_fixed_icontext_menuitem_get_text_dimension(t, t->item_text, &w, &h);
    m->text_width = w;
    m->scroll_x = 0;
    if (flags & UI_MENUITEM_DISABLE_ICON && t->item_icon == UI_NULL_IMAGE)
    {
        scroll_width = m->scroll_width + GUI_ICONTEXT_MENUITEM_TEXT_X - 2;
    }
    else
    {
        scroll_width = m->scroll_width;
    }
#ifdef  __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__
    /* For move the cursor by 3 pixels when the default text effect is enabled and the
       menu item is to be shown inside rectangle in in-line screen. */
    if (t->ext_flags & UI_MENUITEM_EXT_SHOW_IN_ROUNDED_RECT)
    {
         scroll_width -= 3;
    }
#endif  // __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__
    if (t->ext_flags & UI_MENUITEM_EXT_SHOW_INDICATOR)
    {
        wgui_inline_get_default_indicator_width(&i_width, &i_height);
        scroll_width -= i_width; 
    }

    if (MMI_current_menu_type == LIST_MENU)
    {
        f = gui_list_get_focussed_filler((gui_common_menuitem_base_struct*) m);
    }
    if (f && (f->flags & UI_FILLED_AREA_BORDER))
    {
        scroll_width -= 2;
    }

    if (MMI_fixed_matrix_menu.flags & UI_MATRIX_MENU_FOR_MAINMENU)
    {
        scroll_width = MMI_fixed_icontext_menuitem.width;
    }

    if ((w > scroll_width) && !(flags & UI_MENUITEM_TRUNCATE_CONTENT))
    {
        if ((flags & UI_MENUITEM_MARQUEE_SCROLL) || (flags & UI_MENUITEM_TWO_DIRECTION_SCROLL))
        {
            GUI_current_fixed_icontext_menuitem_scroll = 1;
            GUI_current_fixed_icontext_menuitem_scroll_direction = 0;
            GUI_current_fixed_icontext_menuitem_scroll_counter = UI_text_menuitem_scroll_pause;

        #ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
            if (gui_get_current_list_effect() && gblock_list_effect != 1)
            {
#ifdef  __MMI_CAT203_SUPPORT__    
                if (g_gui_list_get_underline)
                {
                    /* to see how to show scrolling text in under line case */
                    underline_array = (S32*) applib_asm_alloc_anonymous(sizeof(S32) * MAX_SUB_MENU_SIZE);
                    if (underline_array)
                    {
                        memset(underline_array, 0, sizeof(S32) * MAX_SUB_MENU_SIZE);
                        g_gui_list_get_underline(MMI_fixed_list_menu.highlighted_item, underline_array, &count);

                        applib_asm_free_anonymous(underline_array);
                    }
                }
                
                if (count)
                {
                    gui_register_callback_menuitem_scroll(gui_fixed_icontext_menuitem_scroll_handler);
                }
                else
#endif  // __MMI_CAT203_SUPPORT__
                {
                    gui_create_scrolling_text(
                        &gui_current_scroll_text[0],
                        0,
                        0,
                        0,
                        0,
                        (UI_string_type)t->item_text,
                        gui_fixed_icontext_menuitem_scroll_text_handler,
                        scrolling_text_draw_icontext_single_line_background,
                        MMI_fixed_icontext_menuitem.focussed_text_color,
                        MMI_fixed_icontext_menuitem.focussed_text_color);
                    if (flags & UI_MENUITEM_TWO_DIRECTION_SCROLL)
                    {
                        gui_current_scroll_text[0].flags = UI_SCROLLING_TEXT_TWO_DIRECTION_SCROLL;
                    }
                    gui_scrolling_text_start(&gui_current_scroll_text[0]);
                    gui_register_callback_menuitem_scroll(gui_fixed_icontext_menuitem_scroll_text_handler);    
                }
            }
            else
        #endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */ 
        {
#ifdef  __MMI_CAT203_SUPPORT__            
            if (g_gui_list_get_underline)
            {
                underline_array = (S32*) applib_asm_alloc_anonymous(sizeof(S32) * MAX_SUB_MENU_SIZE);
                if (underline_array)
                {
                    memset(underline_array, 0, sizeof(S32) * MAX_SUB_MENU_SIZE);
                    g_gui_list_get_underline(MMI_fixed_list_menu.highlighted_item, underline_array, &count);

                    applib_asm_free_anonymous(underline_array);
                }
            }
            
            if (count!= 0)
            {
                gui_start_timer(UI_text_menuitem_scroll_time, gui_fixed_icontext_menuitem_scroll_handler);
            }
            else
#endif  //__MMI_CAT203_SUPPORT__
            {
                gui_create_scrolling_text(
                    &gui_current_scroll_text[0],
                    0,
                    0,
                    0,
                    0,
                    (UI_string_type)t->item_text,
                    gui_fixed_icontext_menuitem_scroll_text_handler,
                    scrolling_text_draw_icontext_single_line_background,
                    MMI_fixed_icontext_menuitem.focussed_text_color,
                    MMI_fixed_icontext_menuitem.focussed_text_color);
                if (flags & UI_MENUITEM_TWO_DIRECTION_SCROLL)
                {
                    gui_current_scroll_text[0].flags = UI_SCROLLING_TEXT_TWO_DIRECTION_SCROLL;
                }
                gui_scrolling_text_start(&gui_current_scroll_text[0]);
            }
            }
        }
    }
    else
#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
    {
        gui_register_callback_menuitem_scroll(gui_dummy_scroll_handler_for_list_effects);
        GUI_current_fixed_icontext_menuitem_scroll = 0;
    }
#else /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */ 
    {
        GUI_current_fixed_icontext_menuitem_scroll = 0;
    }
#endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */ 
}

#ifdef __MMI_OP11_SIDEBAR__

/*****************************************************************************
 * FUNCTION
 *  gui_fixed_icontext_menuitem_hide_time
 * DESCRIPTION
 *  Stop scrolling for the highlighted icontext menu item.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_fixed_icontext_menuitem_hide_time(S32 x1, S32 y1, S32 x2, S32 y2)
{
    gui_push_and_set_clip(x1, y1, x2, y2);
    if (!in_show_fixed_list)
    {
        show_fixed_list();
    }    
    gui_pop_clip();
}
#endif

/*****************************************************************************
 * FUNCTION
 *  gui_fixed_icontext_menuitem_stop_scroll
 * DESCRIPTION
 *  Stop scrolling for the highlighted icontext menu item.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gui_fixed_icontext_menuitem_stop_scroll(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
//    gui_cancel_timer(gui_fixed_icontext_menuitem_start_scroll);
    if (GUI_current_fixed_icontext_menuitem_scroll)
    {
#ifdef  __MMI_CAT203_SUPPORT__        
        if (g_gui_list_get_underline)
        {
            gui_cancel_timer(gui_fixed_icontext_menuitem_scroll_handler);        
        }
        else
#endif  // __MMI_CAT203_SUPPORT__
        {
            gui_scrolling_text_stop(&gui_current_scroll_text[0]);
        }            
        GUI_current_fixed_icontext_menuitem_scroll = 0;
    }
#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
    gui_register_callback_menuitem_scroll(gui_dummy_scroll_handler_for_list_effects);
    gui_restore_current_list_effect();
#endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */ 
}


/* External used to display inline edit menu items */
void wgui_show_inline_edit_menuitem(S32 x1, S32 y1, S32 width, S32 height);
extern S32 MMI_current_menu_type;
extern fixed_matrix_menu MMI_fixed_matrix_menu;
extern gdi_handle animation_handle;


/*****************************************************************************
 * FUNCTION
 *  gui_list_show_text
 * DESCRIPTION
 *  show text
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gui_list_show_text (fixed_icontext_menuitem *m, fixed_icontext_menuitem_type *mi, S32 x1, S32 y1, S32 item_width, S32 text_width, S32 text_height)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    

#ifdef  __MMI_CAT203_SUPPORT__
    s32 count = 0;
    S32 *underline_array = NULL;
	S32 i=0, x, width, iwidth;
	U32 n, nlen;
#endif  // __MMI_CAT203_SUPPORT__
    S32 height=0;

#ifdef  __MMI_CAT203_SUPPORT__
    UI_string_type text;
    stFontAttribute text_font;
    mmi_fe_get_string_info_param_struct query;
    U8 underline, bold;
#endif
    S32 scrolling_text_x;
    S32 menu_y1, menu_y2;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
   

     gui_get_menu_region_V(m, &menu_y1, &menu_y2);

    height = text_height;
#ifdef  __MMI_CAT203_SUPPORT__
    width = text_width;

    text_font = *m->text_font;
	
    underline = m->text_font->underline;
    bold = m->text_font->bold;
    
    if (g_gui_list_get_underline)
    {
        underline_array = (S32*) applib_asm_alloc_anonymous(sizeof(S32) * MAX_SUB_MENU_SIZE);
        
        if (underline_array)
        {
            memset(underline_array, 0, sizeof(S32) * MAX_SUB_MENU_SIZE);
            if (MMI_fixed_list_menu.current_displayed_item == -1)
            {
                g_gui_list_get_underline(MMI_fixed_list_menu.highlighted_item, underline_array, &count);
            }
            else
            {
                g_gui_list_get_underline(MMI_fixed_list_menu.current_displayed_item, underline_array, &count);
            }
        }
    }
    if (count != 0)
    {
        memset(&query, 0, sizeof(mmi_fe_get_string_info_param_struct));
        query.String = (U8*)mi->item_text;
        query.checkCompleteWord = MMI_FALSE;
        query.enableTruncated = MMI_FALSE;
        query.n =  mmi_ucs2strlen((const char*)mi->item_text);
        query.w = 0;
        mmi_fe_get_string_widthheight(&query);
        if (mmi_fe_get_r2l_state())
        {
            width = 0;
            text = mi->item_text;
            nlen = mmi_ucs2strlen((const CHAR *)text);
            if(underline_array[0] != 0)
            {
                n = underline_array[0];
                gui_set_font(&text_font);
                gui_measure_string_n(text, n, &iwidth, &height);
                width += iwidth;
                text += n;
                nlen -= n;
            }

            while(nlen > 0)
            {
                n = underline_array[i + 1] - underline_array[i] + 1;
                
                text_font.underline = 1;
                text_font.bold = 1;
                gui_set_font(&text_font);
                gui_measure_string_n(text, n, &iwidth, &height);
                width += iwidth;
                text += n;
                nlen -= n;
                if (underline_array[i + 2])
                {
                    n = underline_array[i + 2] - underline_array[i + 1] - 1;
                    text_font.underline = underline;
                    text_font.bold = bold;
                    gui_set_font(&text_font);
                    gui_measure_string_n(text, n, &iwidth, &height);
                    width += iwidth;
                    text += n;
                    nlen -= n;
                }
                i = i + 2;
                count --;
                if (count == 0)
                {
                    break;
                }
                if(underline_array[i] == 0 || i >= MAX_SUB_MENU_SIZE - 2)
                {
                    break;
                }
            }
            if (nlen)
            {
                text_font.underline = underline;
                text_font.bold = bold;
                gui_set_font(&text_font);
                gui_measure_string(text, &iwidth, &height);
                width += iwidth;
            }
        }
        x = x1;
        text = mi->item_text;
        nlen = mmi_ucs2strlen((const CHAR *)text);
        i = 0;
        if (mmi_fe_get_r2l_state())
        {
            x -= width;
        }
        if(underline_array[0] != 0)
        {
            n = underline_array[0];
            gui_set_font(&text_font);
            gui_measure_string_n(text, n, &width, &height);
            if (mmi_fe_get_r2l_state())
            {
                x += width;
                gui_move_text_cursor(x, y1);
            }
#ifdef __MMI_UI_LIST_TRUNCATE_ITEM__
            if ((!((mi->flags & UI_MENUITEM_STATE_FOCUSSED) && 
                    (GUI_current_fixed_icontext_menuitem_scroll || g_gui_menuitem_need_scroll))) &&
                (x + width - x1 > item_width))
            {
                gui_print_truncated_text(x, y1, item_width - (x - x1), text);
            }
            else
#endif
            {
                if ((mi->flags & UI_MENUITEM_TRUNCATE_CONTENT) || (m->flags & UI_MENUITEM_TRUNCATE_CONTENT))
                {
                    gui_print_truncated_text(x, y1, item_width - (x - x1), text);
                }
                else
                {
                    mmi_fe_show_string_n_baseline(x, y1, (U8*)text, n, query.baseline);
                }
            }
                
            if (!mmi_fe_get_r2l_state())
            {
                x += width;
            }
            gui_move_text_cursor(x, y1);
            text += n;
            nlen -= n;
        }

        while(nlen > 0)
        {
            n = underline_array[i + 1] - underline_array[i] + 1;
            
            text_font.underline = 1;
            text_font.bold = 1;
            gui_set_font(&text_font);
            gui_measure_string_n(text, n, &width, &height);
            if (mmi_fe_get_r2l_state())
            {
                x += width;
                gui_move_text_cursor(x, y1);
            }
#ifdef __MMI_UI_LIST_TRUNCATE_ITEM__
            if ((!((mi->flags & UI_MENUITEM_STATE_FOCUSSED) && 
                    (GUI_current_fixed_icontext_menuitem_scroll || g_gui_menuitem_need_scroll))) &&
                (x + width - x1 > item_width))
            {
                gui_print_truncated_text(x, y1, item_width - (x - x1), text);
            }
            else
#endif      
            {
                if ((mi->flags & UI_MENUITEM_TRUNCATE_CONTENT) || (m->flags & UI_MENUITEM_TRUNCATE_CONTENT))
                {
                    gui_print_truncated_text(x, y1, item_width - (x - x1), text);
                }
                else
                {
                    mmi_fe_show_string_n_baseline(x, y1, (U8*)text, n, query.baseline);
                }
            }
            
            if (!mmi_fe_get_r2l_state())
            {
                x += width;
            }
            text += n;
            nlen -= n;
            gui_move_text_cursor(x, y1);
            if (underline_array[i + 2])
            {
                n = underline_array[i + 2] - underline_array[i + 1] - 1;
                text_font.underline = underline;
                text_font.bold = bold;
                gui_set_font(&text_font);
                gui_measure_string_n(text, n, &width, &height);
                if (mmi_fe_get_r2l_state())
                {
                    x += width;
                    gui_move_text_cursor(x, y1);
                }
#ifdef __MMI_UI_LIST_TRUNCATE_ITEM__
                if ((!((mi->flags & UI_MENUITEM_STATE_FOCUSSED) && 
                        (GUI_current_fixed_icontext_menuitem_scroll || g_gui_menuitem_need_scroll))) &&
                    (x + width - x1 > item_width))
                {
                    gui_print_truncated_text(x, y1, item_width - (x - x1), text);
                }
                else
#endif
                {
                    if ((mi->flags & UI_MENUITEM_TRUNCATE_CONTENT) || (m->flags & UI_MENUITEM_TRUNCATE_CONTENT))
                    {
                        gui_print_truncated_text(x, y1, item_width - (x - x1), text);
                    }
                    else
                    {
                        mmi_fe_show_string_n_baseline(x, y1, (U8*)text, n, query.baseline);
                    }
                }
                if (!mmi_fe_get_r2l_state())
                {
                    x += width;
                }
                gui_move_text_cursor(x, y1);                
                text += n;
                nlen -= n;
            }
            i = i + 2;
            count --;
            if (count == 0)
            {
                break;
            }
            if(underline_array[i] == 0 || i >= MAX_SUB_MENU_SIZE - 2)
            {
                break;
            }
        }
        if (nlen)
        {
            text_font.underline = underline;
            text_font.bold = bold;
            gui_set_font(&text_font);
            gui_measure_string(text, &width, &height);
            if (mmi_fe_get_r2l_state())
            {
                x += width;
                gui_move_text_cursor(x, y1);
            }
#ifdef __MMI_UI_LIST_TRUNCATE_ITEM__
            if ((!((mi->flags & UI_MENUITEM_STATE_FOCUSSED) && 
                    (GUI_current_fixed_icontext_menuitem_scroll || g_gui_menuitem_need_scroll))) &&
                (x + width - x1 > item_width))
            {
                gui_print_truncated_text(x, y1, item_width - (x - x1), text);
            }
            else
#endif
            {
                if ((mi->flags & UI_MENUITEM_TRUNCATE_CONTENT) || (m->flags & UI_MENUITEM_TRUNCATE_CONTENT))
                {
                    gui_print_truncated_text(x, y1, item_width - (x - x1), text);
                }
                else
                {
                    mmi_fe_show_string_n_baseline(x, y1, (U8*)text, nlen, query.baseline);
                }
            }
        }
    }
    else
#endif  // __MMI_CAT203_SUPPORT__
    {
        if (mi->ext_flags & UI_MENUITEM_EXT_SHOW_DATA)
        {
            if (g_gui_list_data_font)
            {
                gui_set_font(g_gui_list_data_font);
            }
            else
            {
                gui_set_font(&MMI_small_font);
            }
        }
        else
        {
            gui_list_menuitem_set_font((gui_common_menuitem_base_struct *) m, mi->flags);
        }

#ifdef __MMI_UI_LIST_TRUNCATE_ITEM__
        if ((mi->flags & UI_MENUITEM_STATE_FOCUSSED) && 
			(GUI_current_fixed_icontext_menuitem_scroll || g_gui_menuitem_need_scroll) &&
            (!(m->flags & UI_MENUITEM_DISABLE_HIGHLIGHT)) &&
            ((y1 >= menu_y1 && y1 + height <= menu_y2) || !g_current_display_half_menuitem))
        {
#ifdef  __MMI_CAT203_SUPPORT__
            if (mmi_fe_get_r2l_state() && g_gui_list_get_underline)
            {
                scrolling_text_x = x1 - item_width + 1;
            }
            else
#endif  // __MMI_CAT203_SUPPORT__
            {
                scrolling_text_x = x1;
            }

            gui_menuitem_redraw_scrolling_text(
                &(gui_current_scroll_text[0]),
                scrolling_text_x,
                y1,
                item_width,
                height + 1,
                &(m->focussed_text_color),
                &(m->focussed_text_color)
            );
        }
        else
        {
            gui_print_truncated_text(x1, y1, item_width, mi->item_text);
        }  
#else
        if ((mi->flags & UI_MENUITEM_STATE_FOCUSSED) && 
			(GUI_current_fixed_icontext_menuitem_scroll || g_gui_menuitem_need_scroll) &&
            ((y1 >= menu_y1 && y1 + height <= menu_y2) || !g_current_display_half_menuitem))
        {    
#ifdef  __MMI_CAT203_SUPPORT__
            if (mmi_fe_get_r2l_state() && g_gui_list_get_underline)
            {
                scrolling_text_x = x1 - item_width + 1;
            }
            else
#endif  // __MMI_CAT203_SUPPORT__
            {
                scrolling_text_x = x1;
            }

            gui_menuitem_redraw_scrolling_text(
                &(gui_current_scroll_text[0]),
                scrolling_text_x,
                y1,
                item_width,
                height + 1,
                &(m->focussed_text_color),
                &(m->focussed_text_color)
            );
        }
        else if ((mi->flags & UI_MENUITEM_TRUNCATE_CONTENT) || (m->flags & UI_MENUITEM_TRUNCATE_CONTENT))
        {
            gui_print_truncated_text(x1, y1, item_width, mi->item_text);
        }
#ifdef __MMI_MAINLCD_320X480__
        else if (MMI_current_menu_type == MATRIX_MENU)
        {
            if ((mi->flags & UI_MENUITEM_STATE_FOCUSSED) && GUI_current_fixed_icontext_menuitem_scroll)
            {
#ifdef  __MMI_CAT203_SUPPORT__
                if (mmi_fe_get_r2l_state() && g_gui_list_get_underline)
                {
                    scrolling_text_x = x1 - item_width + 1;
                }
                else
#endif  // __MMI_CAT203_SUPPORT__
                {
                    scrolling_text_x = x1;
                }

                gui_menuitem_redraw_scrolling_text(
                   &(gui_current_scroll_text[0]),
                   scrolling_text_x,
                   y1,
                   item_width,
                   height + 1,
                   &(m->focussed_text_color),
                   &(m->focussed_text_color)
                );
            }
            else
            {
                gui_print_truncated_text(x1, y1, item_width, mi->item_text);
            }
        }
#endif

        else
        {
            if (mi->item_text == NULL)
            {
                return;
            }
            nlen = mmi_ucs2strlen((CHAR *)mi->item_text);
            mmi_fe_show_string_n_baseline(x1, y1, (U8*)mi->item_text, nlen, mi->baseline);
        }
#endif
    }

#ifdef  __MMI_CAT203_SUPPORT__
    if (underline_array)
    {
        applib_asm_free_anonymous(underline_array);
    }
#endif  //  __MMI_CAT203_SUPPORT__
    gui_list_menuitem_set_font((gui_common_menuitem_base_struct *) m, mi->flags);
}


/*****************************************************************************
 * FUNCTION
 *  gui_get_fixed_icontext_menuitem_flag
 * DESCRIPTION
 *  get the flag of  icontext menu item.
 * PARAMETERS
 *  item                    [IN]        private icontext menu item object
 *  common_item_data        [IN]        common icontext menu item object
 * item_type[IN]  0,icontext, 1,icontext list, 2,twostate
 * RETURNS
 *  flag
 *****************************************************************************/
void gui_get_fixed_menuitem_flag(void *item, void *common_item_data, S32 index, U32* flags, U32* flags_ext, S32 Is_two_state)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	U32 ret_flag = 0, ret_flag_ext = 0;

	gui_common_menuitem*m = (gui_common_menuitem*) common_item_data;
	fixed_menuitem_type* mi = (fixed_menuitem_type*) item;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    *flags = 0;
    if (m && mi)
    {
        *flags = mi->flags | m->flags;
		if(Is_two_state)
			*flags_ext = m->ext_flags;
		else
            *flags_ext = mi->ext_flags | m->ext_flags;
    }
    if (g_gui_list_get_menuitem_flags)
    {
        g_gui_list_get_menuitem_flags(index, &ret_flag, &ret_flag_ext);
        *flags |= ret_flag;
        *flags_ext |= ret_flag_ext;
    }


}

//hujin
//#if 0
/*****************************************************************************
 * FUNCTION
 *  gui_get_fixed_icontext_menuitem_flag
 * DESCRIPTION
 *  get the flag of  icontext menu item.
 * PARAMETERS
 *  item                    [IN]        private icontext menu item object
 *  common_item_data        [IN]        common icontext menu item object
 * RETURNS
 *  flag
 *****************************************************************************/
void gui_get_fixed_icontext_menuitem_flag(void *item, void *common_item_data, S32 index, U32* flags, U32* flags_ext)
{
    gui_get_fixed_menuitem_flag(item, common_item_data, index, flags,flags_ext, 0);
}
#ifndef __MMI_UI_MENU_SLIM__
/*****************************************************************************
 * FUNCTION
 *  gui_scroll_start_handler_for_list_effects
 * DESCRIPTION
 *  Start the associated scroll handler for the list effect.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gui_scroll_start_handler_for_list_effects(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (gui_call_menuitem_scroll)
    {
        gui_call_menuitem_scroll(); /* call the corresponding scroll handler */
    }
}
#endif

#ifndef __MMI_UI_MENU_SLIM__
/*****************************************************************************
 * FUNCTION
 *  gui_callback_highlighter_text_filler
 * DESCRIPTION
 *  Timer callback function for the list effect.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gui_callback_highlighter_text_filler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#ifdef __MMI_SUBLCD__	
    GDI_HANDLE lcd;
#endif
    S32 iwidth, iheight;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!ghighlight_item || !ghighlight_common_item_data)
    {
        MMI_DBG_ASSERT(0);
        return;
    }
    
    #ifdef __MMI_SUBLCD__
    gdi_lcd_get_active(&lcd);
    gdi_lcd_set_active(MMI_fixed_list_menu.act_lcd_handle);
    #endif

    gui_lock_double_buffer();
#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__    
    is_draw_next_frame_list_highlight_effect = 1;
#endif
    if (MMI_fixed_list_menu.n_items > 0)
    {
        gdi_layer_push_and_set_active(MMI_fixed_list_menu.act_layer_handle);

        MMI_fixed_list_menu.current_displayed_item = -1;
        MMI_fixed_list_menu.item_measure_function(ghighlight_item, ghighlight_common_item_data, &iwidth, &iheight);
        
        MMI_fixed_list_menu.item_display_function(ghighlight_item, ghighlight_common_item_data, gstartX1, gstartY1);
#ifdef UI_ENABLE_POP_UP_DESCRIPTIONS
        
        if (MMI_fixed_list_menu.menu_style == GUI_MENU_TYPE_FIXED)
        {
            wgui_display_fixed_text_list_pop_up_description();
        }
        else if (MMI_fixed_list_menu.menu_style == GUI_MENU_TYPE_DYNAMIC)
        {
            wgui_display_dynamic_text_list_pop_up_description();
        }
        else if (MMI_fixed_list_menu.menu_style == GUI_MENU_TYPE_ASYNCDYNAMIC)
        {
            wgui_display_asyncdynamic_text_list_pop_up_description();  
        }
#endif
        gdi_layer_pop_and_restore_active();
    }
#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__	
    is_draw_next_frame_list_highlight_effect = 0;
#endif    
    gui_unlock_double_buffer();
    gui_BLT_double_buffer(xstart_effect, ystart_effect, xend_effect, yend_effect);
    
  #ifdef __MMI_SUBLCD__
    gdi_lcd_set_active(lcd);
  #endif
}
#endif

#ifndef __MMI_UI_MENU_SLIM__
/*****************************************************************************
 * FUNCTION
 *  set_start_position_and_item_parameters_for_list_highlighter_effect
 * DESCRIPTION
 *  Save menu item information for the list effect.
 * PARAMETERS
 *  item                    [IN]        private menu item object
 *  common_item_data        [IN]        common menu item object
 *  x                       [IN]        x
 *  y                       [IN]        y
 * RETURNS
 *  void
 *****************************************************************************/
void set_start_position_and_item_parameters_for_list_highlighter_effect(
        void *item,
        void *common_item_data,
        S32 x,
        S32 y)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ghighlight_item = item;
    ghighlight_common_item_data = common_item_data;
    gstartX1 = x;
    gstartY1 = y;
}
#endif


#ifndef __MMI_UI_MENU_SLIM__
/*****************************************************************************
 * FUNCTION
 *  gui_draw_animated_effect_filler
 * DESCRIPTION
 *  Draw the animated highlighter filler.
 * PARAMETERS
 *  x1      [IN]        x1
 *  y1      [IN]        y1
 *  x2      [IN]        x2
 *  y2      [IN]        y2
 *  f       [IN]        filler
 * RETURNS
 *  void
 *****************************************************************************/
void gui_draw_animated_effect_filler(S32 x1, S32 y1, S32 x2, S32 y2, UI_filled_area *f)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 max_frame, repeat_time;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    xstart_effect = x1;
    ystart_effect = y1;
    xend_effect = x2;
    yend_effect = y2;

    /* get the number of frames in the animation */
    repeat_time = gdi_anim_get_count(f->b);
    gdi_image_get_frame_count(f->b, &max_frame);  

    if (list_highlight_effect_current_frame >= max_frame)
    {
        list_highlight_effect_current_frame = 0;
    }


    gui_push_and_set_clip(x1, y1, x2, y2);    
    gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_TRANSPARENT);
    if (mmi_is_redrawing_bk_screens())
    {
        gdi_image_draw_animation_single_frame(x1, y1, f->b, (S16) max_frame - 1); 
    }
    else if (gui_list_in_scroll && list_highlight_effect_current_frame == 0 && repeat_time == 1)
    {
        gdi_image_draw_animation_single_frame(x1, y1, f->b, (S16) max_frame - 1);      /* Show frame by frame no. */
    }
    else if (list_highlight_effect_current_frame == max_frame - 1 && repeat_time == 1)
    {   
        /* the last frame is already shown, go back to the first frame */
        //gdi_image_draw_animation_single_frame(x1, y1, f->b, 0);
        gdi_image_draw_frames(x1, y1, f->b, (S16) list_highlight_effect_current_frame);  
        //gui_draw_list_highlight_effect_last_frame();                
        list_highlight_effect_current_frame = 0;
#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__		
        list_highlight_effect_times = 1;
#endif
        /* prevent from drawing the menu item twice when it is already scrolling */
        gui_start_timer(UI_text_menuitem_scroll_time, gui_scroll_start_handler_for_list_effects);
        
    }
#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
    else if (list_highlight_effect_current_frame <= max_frame && list_highlight_effect_times == 0)
#else
    else if (list_highlight_effect_current_frame <= max_frame)
#endif
    {   
        U32 *header32 = (U32*)f->b;
        U32 frame_delay = header32[4];
        MMI_BOOL need_start_timer = MMI_TRUE;
        
        gdi_image_draw_frames(x1, y1, f->b, (S16) list_highlight_effect_current_frame);      /* Show frame by frame no. */
        if (list_highlight_effect_current_frame == max_frame - 1)
        {
            list_highlight_effect_current_frame = 0;
        }
        else
        {
            list_highlight_effect_current_frame++;  /* Treat list_highlight_effect_current_frame as frame no. */
        }
        if (repeat_time == 1)
        {
        }        
        else if ((GUI_current_fixed_icontext_menuitem_scroll || GUI_current_fixed_icontext_list_menuitem_scroll)&&
            list_highlight_effect_current_frame == 0)
        {
            GUI_current_fixed_icontext_menuitem_scroll_counter = 0;
        }
        else if (!gui_list_in_scroll)
        {
        }
        else
        {
            need_start_timer = MMI_FALSE;
        }

        if (need_start_timer)
        {
            gui_start_timer(frame_delay, gui_callback_highlighter_text_filler);
        }
    }
    else
    {
        gdi_image_draw_animation_single_frame(x1, y1, f->b, (S16) max_frame - 1);      /* Show frame by frame no. */
    }

    gui_pop_clip();

}
#endif

/*****************************************************************************
 * FUNCTION
 *  gui_register_fixed_icontext_menuitem_hide_function
 * DESCRIPTION
 *  Register hide callback function
 * PARAMETERS
 *  hide_funtion            [IN]        hide callback function
 * RETURNS
 *  void
 *****************************************************************************/
void gui_register_fixed_icontext_menuitem_hide_function(void *common_item_data, void (*f) (S32 x1, S32 y1, S32 x2, S32 y2))
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    fixed_icontext_menuitem *m = (fixed_icontext_menuitem*) common_item_data;
    m->hide_function = f;
}


/*****************************************************************************
 * FUNCTION
 *  gui_list_inline_draw_icon
 * DESCRIPTION
 *  draw the icon for inline item
 * PARAMETERS
 *  m         [IN]      inline menu item base structure
 *  mi        [IN]      inline menu item
 *  x1        [IN]      x1
 *  x2        [IN]      x2
 *  y1        [IN]      y1
 *  y2        [IN]      y2
 *  flags     [IN]      the flags of menu item
 *  _icon    [IN]      the icon pointer
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_list_inline_draw_icon(
    fixed_icontext_menuitem *m,
    fixed_icontext_menuitem_type *mi,
    S32 x1, S32 x2, S32 y1, S32 y2,
    U32 flags,
    PU8 _icon
    )
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gdi_handle old_alpha_layer;
    S32 clip_x1, clip_y1, clip_x2, clip_y2;

    S32 i_width, i_height, icon_width = 0, icon_height = 0;
    S32 icon_x;

    S32 menu_y2;
	//unimportant issues
	#ifndef __MMI_UI_MENU_SLIM__
    gdi_handle act_layer = GDI_NULL_HANDLE;
	#endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    menu_y2 = m->parent_list->y + m->parent_list->height - 1;

    gui_measure_fixed_icontext_menuitem(mi, m, &i_width, &i_height);
    
    if (_icon != UI_NULL_IMAGE)
    {
        gui_measure_image(_icon, &icon_width, &icon_height);

		if (flags & UI_MENUITEM_CENTER_ICON_Y)
        {
            m->icon_y = (i_height >> 1) - (icon_height >> 1);
        }
    }

    old_alpha_layer = gui_list_set_alpha_blending_layer_ex(flags, MMI_TRUE);
#ifdef  __MMI_GUI_LIST_MENU_FULL_PACKAGE__
    if (mi->item_icon_handle != GDI_ERROR_HANDLE)
    {
        gdi_image_stop_animation(mi->item_icon_handle);
        mi->item_icon_handle = GDI_ERROR_HANDLE;
    }
    
    if (animation_flag)
    {
        S32 icon_x;
        
        /* have to handle R2L list menu animation icon x position */
        if (mmi_fe_get_r2l_state() && (MMI_current_menu_type == LIST_MENU))
        {                   
            icon_x = x2 - m->icon_x - icon_width + 1;
        }
        else
        {
            icon_x = x1 + m->icon_x;
        }
        
        gdi_image_draw_animation(
            icon_x,
            y1 + m->icon_y,
            mi->item_icon,
            (gdi_handle*)&mi->item_icon_handle);                    
    }
    else if (m->flags & UI_MENUITEM_STATE_ANIMATE)
    {
        gdi_image_draw_frames(
            x1 + m->icon_x,
            y1 + m->icon_y,
            _icon,
            1);
        m->flags &= ~UI_MENUITEM_STATE_ANIMATE;
    }
    else if (MMI_current_menu_type == LIST_MENU)
#endif  // __MMI_GUI_LIST_MENU_FULL_PACKAGE__        
    {
        S32 x_clip = 0, y_clip = 0, y_gap = 0;
        
        gui_push_clip();
        if (m->icon_x > 0)
        {
            x_clip = m->icon_x;
        }
#ifdef __MMI_UI_LIST_GRID_LINE__
        if (m->icon_y <= 0)
        {
            y_clip = 1;
        }
#endif /* __MMI_UI_LIST_GRID_LINE__ */
        if (m->icon_y > 0)
        {
            y_clip = m->icon_y;
        }
        
        clip_y1 = y1 + y_clip;
        clip_y2 = menu_y2;

        if (flags & UI_MENUITEM_STATE_FOCUSSED)
        {
            y_gap = y_clip;
        }

//unimportant issues
#ifndef __MMI_UI_MENU_SLIM__
        gdi_layer_get_active(&act_layer);
        if (MMI_current_menu_type == LIST_MENU && clip_y1 < m->parent_list->y && m->parent_list->act_layer_handle == act_layer)
        {
            clip_y1 = m->parent_list->y;
        }
#endif
        if (y1 + y_gap >= menu_y2)
        {
            clip_y1 = menu_y2;
        }
        else if (y1 + i_height - 1 < menu_y2)
        {
            clip_y2 = y1 + i_height - 1;
        }
        
        if (!mmi_fe_get_r2l_state())
        {
            clip_x1 = x1 + x_clip;
            clip_x2 = x1 + m->text_x - 2;

            icon_x = x1 + m->icon_x;
        }
        else
        {
            clip_x1 = x2 - m->text_x + 2;
            clip_x2 = x2 - x_clip;

            icon_x = x2 - m->icon_x - icon_width + 1;
        }
        
       //unimportant issues
       #ifndef __MMI_UI_MENU_SLIM__
        gui_set_clip(clip_x1, clip_y1, clip_x2, clip_y2);
	   #else
	   gui_set_clip_preset(clip_x1, clip_y1, clip_x2, clip_y2);
	   #endif
        gdi_image_draw_animation_single_frame(icon_x, y1 + m->icon_y, (U8*) _icon, 0);

        gui_pop_clip();
    }
#ifdef  __MMI_GUI_LIST_MENU_FULL_PACKAGE__
    else
    {
        gdi_image_draw_animation_single_frame(x1 + m->icon_x, y1 + m->icon_y, (U8*) _icon, 0);
    }
#endif  // __MMI_GUI_LIST_MENU_FULL_PACKAGE__

    gui_list_reset_alpha_blending_layer(old_alpha_layer);
}


/*****************************************************************************
 * FUNCTION
 *  gui_show_fixed_icontext_menuitem
 * DESCRIPTION
 *  Show an icontext menu item.
 * PARAMETERS
 *  item                    [IN]        private icontext menu item object
 *  common_item_data        [IN]        common icontext menu item object
 *  x                       [IN]        x
 *  y                       [IN]        y      
 * RETURNS
 *  void
 *****************************************************************************/
void gui_show_fixed_icontext_menuitem(void *item, void *common_item_data, S32 x, S32 y)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x1, y1, x2, y2, menu_y1, menu_y2;
    /* offset in y to bottom */
    S32 yoff;

    /* relative x offset of text inside menu item. 
       (which might be different from m->text_x in Arabic or scrolling) */
    S32 text_x = 0;

    /* relative y offset of text inside menu item. */
    S32 text_y = 0;

#if (defined __MMI_UI_HINTS_IN_MENUITEM__ || defined __MMI_UI_TWO_LINE_MENUITEM_STYLES__)
    MMI_BOOL show_hint_in_menuitem = MMI_FALSE;
#endif 

    S32 ani_w, ani_h;
    color text_color;
    UI_filled_area *f = NULL;
    fixed_icontext_menuitem *m = (fixed_icontext_menuitem*) common_item_data;
    fixed_icontext_menuitem_type *mi = (fixed_icontext_menuitem_type*) item;
    U32 flags, flags_ext;
    UI_string_type _text;
    PU8 _icon;
    U8 animation_flag = 0;
    S32 sw = 0, sh = 0, max_text_width = 0, time_w = 0;
#ifdef __MMI_OP11_SIDEBAR__
	S32 time_h = 0;
#endif
    S32 is_text_full_width = 0, old_text_x = 0, old_text_y = 0, old_icon_x = 0, old_icon_y = 0;
    S32 icon_width, icon_height;
    U32  ret_flag_ext = 0;//ret_flag = 0,
    gdi_handle old_alpha_layer = GDI_NULL_HANDLE;
#ifndef __LOW_COST_PROJECT__
#ifdef __MMI_OP11_SIDEBAR__
    gdi_handle target_layer;
#endif
#endif
#ifdef __MMI_UI_LIST_HIGHLIGHT_BOLD
    stFontAttribute highlight_font;
#endif /*__MMI_UI_LIST_HIGHLIGHT_BOLD*/
#if defined(__MMI_MAINLCD_320X480__) || defined(__MMI_MAINMENU_SPREAD_SUPPORT__)
    UI_filled_area background_filler;
#endif
    /* position of inline indicator */
    S32 i_x = 0, i_y = 0;
    /* dimension of indicator in inline edit */
    S32 i_width = 0, i_height = 0;

    S32 clip_x1, clip_y1, clip_x2, clip_y2;
	//unimportant issues
	#ifndef __MMI_UI_MENU_SLIM__
    gdi_handle act_layer = GDI_NULL_HANDLE;
	#endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_fixed_list_menu.default_inline_item = 0;
	g_gui_menuitem_need_scroll = MMI_FALSE;

//get flags
    gui_get_fixed_menuitem_flags_int(item, common_item_data, &flags, &flags_ext);
    
    _text = mi->item_text;
    _icon = mi->item_icon;
    x1 = x;
    y1 = y;
    x2 = x1 + m->width - 1;
    y2 = y1 + m->height - 1;
     gui_get_menu_region_V(m, &menu_y1, &menu_y2);
    yoff = (MMI_fixed_matrix_menu.height - (m->height * MMI_fixed_matrix_menu.displayed_rows)) % (MMI_fixed_matrix_menu.displayed_rows + 1);
	if (mi->ext_flags & UI_MENUITEM_EXT_SHOW_INDICATOR)
	{
		wgui_inline_get_default_indicator_width(&i_width, &i_height);
	}

    if (flags & UI_MENUITEM_STATE_FOCUSSED)
    {
    #ifdef __MMI_SUPPORT_DUMP_SCREEN_STRING__
        mmi_frm_dss_set_menu_highlight(MMI_SCREEN_FOCUSED_ICONTEXT_ITEM);
	#endif
        GUI_current_fixed_icontext_menuitem_x = x;
        GUI_current_fixed_icontext_menuitem_y = y;
        GUI_current_fixed_icontext_menuitem_x2 = x2;
        GUI_current_fixed_icontext_menuitem_y2 = y2;
    }
    
#ifdef __MMI_UI_HINTS_IN_MENUITEM__
    show_hint_in_menuitem = gui_menuitem_has_hint((gui_common_menuitem_base_struct*) m, flags & UI_MENUITEM_STATE_FOCUSSED);
#endif /* __MMI_UI_HINTS_IN_MENUITEM__ */ 

#if (defined __MMI_UI_HINTS_IN_MENUITEM__ || defined __MMI_UI_TWO_LINE_MENUITEM_STYLES__)
    if (show_hint_in_menuitem
#ifdef __MMI_UI_TWO_LINE_MENUITEM_STYLES__
        || (m->ext_flags & UI_MENUITEM_EXT_SHOW_TWO_LINE_SELECT)
#endif 
        )
    {
        if (!(flags & UI_MENUITEM_DISABLE_HIGHLIGHT))
        {
            gui_show_two_line_icontext_menuitem(item, common_item_data, x, y);
            if (ret_flag_ext & UI_MENUITEM_EXT_SHOW_SEPARATORLINE || mi->ext_flags & UI_MENUITEM_EXT_SHOW_SEPARATORLINE)
            {
                gui_draw_horizontal_line(x1, x2, y1, *(current_MMI_theme->list_grid_line_color));//list_separator_color
            }
            else if (ret_flag_ext & UI_MENUITEM_EXT_SHOW_DOWN_SEPARATORLINE || mi->ext_flags & UI_MENUITEM_EXT_SHOW_DOWN_SEPARATORLINE)
            {
                gui_draw_horizontal_line(x1, x2, y2, *(current_MMI_theme->list_grid_line_color));//list_separator_color
            }
#if defined(__MMI_OP11_HOMESCREEN_0301__) || defined(__MMI_OP11_HOMESCREEN_0302__)
            else if (ret_flag_ext & UI_MENUITEM_EXT_SHOW_DOWN_SHORT_SEPARATORLINE || mi->ext_flags & UI_MENUITEM_EXT_SHOW_DOWN_SHORT_SEPARATORLINE)
            {
                gui_draw_horizontal_line(x1, x + m->text_x, y2, *(current_MMI_theme->list_grid_line_color));//list_separator_color
            }
#endif  // defined(__MMI_OP11_HOMESCREEN_0301__) || defined(__MMI_OP11_HOMESCREEN_0302__)
            return;
        }
    }
#endif /* (defined __MMI_UI_HINTS_IN_MENUITEM__ || defined __MMI_UI_TWO_LINE_MENUITEM_STYLES__) */ 

    if (flags & UI_MENUITEM_INLINE_EDIT_OBJECT)
    {
        gui_measure_fixed_icontext_menuitem(item, common_item_data, &i_width, &i_height);
        /* calculate the icon position */
        if (_icon != UI_NULL_IMAGE)
        {
            gui_measure_image(_icon, &icon_width, &icon_height);
        }

        if (flags & UI_MENUITEM_STATE_FOCUSSED)
        {
            /* Remove the display of background filler when the default text effect is enabled */
        #ifdef __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__
            if (!(mi->ext_flags & UI_MENUITEM_EXT_SHOW_IN_ROUNDED_RECT))
        #endif 
            {
                old_alpha_layer = gui_list_set_alpha_blending_layer();
                if (!(flags & UI_MENUITEM_DISABLE_BACKGROUND_ALWAYS))
                {
#ifdef  __OP01_FWPBW__
                    gui_draw_filled_area(x1 + m->text_x, y1, x2, y2, gui_list_get_focussed_filler((gui_common_menuitem_base_struct*) m));
#else
                    gui_draw_filled_area(x1, y1, x2, y2, gui_list_get_focussed_filler((gui_common_menuitem_base_struct*) m));
#endif
                }
                gui_list_reset_alpha_blending_layer(old_alpha_layer);
            }
        }
        else
        {
            gui_list_menuitem_set_font((gui_common_menuitem_base_struct *) m, flags);
        }

        if (_icon != UI_NULL_IMAGE)
        {
            gui_list_inline_draw_icon(m, mi, x1, x2, y1, y2, flags, _icon);
        }

#ifdef __MMI_FTE_SUPPORT__
        /* display the focussed inline item with different coordinates when the default
           text effect is enabled. */
        gui_push_clip();
        gui_measure_fixed_icontext_menuitem(item, common_item_data, &i_width, &i_height);

        clip_x1 = x;
        clip_y1 = y;
        clip_x2 = x + i_width - 1;
        clip_y2 = menu_y2;

//unimportant issues
       #ifndef __MMI_UI_MENU_SLIM__
        gdi_layer_get_active(&act_layer);
        if (MMI_current_menu_type == LIST_MENU && clip_y1 < m->parent_list->y && m->parent_list->act_layer_handle == act_layer)
        {
            clip_y1 = m->parent_list->y;
        }
		#endif
        if (y >= menu_y2)
        {
            clip_y1 = menu_y2;
        }
        else if (menu_y2 >= y + i_height - 1)
        {
            clip_y2 = y + i_height - 1;
        }
		//unimportant issues
		#ifndef __MMI_UI_MENU_SLIM__
        gui_set_clip(clip_x1, clip_y1, clip_x2, clip_y2);
		#else		
        gui_set_clip_preset(clip_x1, clip_y1, clip_x2, clip_y2);
		#endif
        
        if (flags & UI_MENUITEM_STATE_FOCUSSED)
        {
            if (m->parent_list && m->parent_list->gui_display_pop_up_description)
            {
                m->parent_list->gui_display_pop_up_description(x, y, i_width, i_height);
            }
        }
        else
        {
            wgui_show_inline_edit_menuitem(x, y, i_width, i_height);
        }
        gui_pop_clip();
#else /* __MMI_FTE_SUPPORT__ */
        /* display inline item with different coordinates when the default
           text effect is enabled. */
    #ifdef __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__
        if ((mi->ext_flags & UI_MENUITEM_EXT_SHOW_IN_ROUNDED_RECT))
        {
            i_y = y + 1;
            
            i_width = m->width - m->text_x;
            i_height = i_height - 2;
            if (mmi_fe_get_r2l_state())
            {
                i_x = x + 2;
            }
            else
            {
                i_x = x + m->text_x;
            }
        }
        else
    #endif /* __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__ */ 
        {
            i_x = x + 2;
            i_y = y;

            i_width = m->width - 2;
        }

        if (flags & UI_MENUITEM_STATE_FOCUSSED)
        {
            if (m->parent_list && m->parent_list->gui_display_pop_up_description)
            {
                gdi_layer_lock_frame_buffer();
                m->parent_list->gui_display_pop_up_description(i_x, i_y, i_width, i_height);
                gdi_layer_unlock_frame_buffer();
            }
        }
        else
        {
            wgui_show_inline_edit_menuitem(i_x, i_y, i_width, i_height);
        }
    #endif /* __MMI_FTE_SUPPORT__ */

        return;
    }
    else if (mi->ext_flags & UI_MENUITEM_EXT_SHOW_INDICATOR)
    {
        i_y = y + ((m->height - i_height) >> 1);
        if (mmi_fe_get_r2l_state())
        {
            i_x = x;
        }
        else
        {
            i_x = x + m->width - i_width - 1 ;
        }
    }

    if (!(flags & UI_MENUITEM_DISABLE_TEXT_DISPLAY))
    {
        /* Autocalculate the text position based on font   */
#if defined(__MMI_OP11_SIDEBAR__) || defined(__MMI_OP11_HOMESCREEN__)            
        if (mi->ext_flags & UI_MENUITEM_EXT_SHOW_DATA)
        {
            if (g_gui_list_data_font)
            {
                gui_set_font(g_gui_list_data_font);
            }
            else
            {
                gui_set_font(&MMI_small_font);
            }
        }
        else
#endif  //  defined(__MMI_OP11_SIDEBAR__) || defined(__MMI_OP11_HOMESCREEN__) 
        {
            gui_list_menuitem_set_font((gui_common_menuitem_base_struct *) m, flags);
        }
        gui_fixed_icontext_menuitem_get_text_dimension(mi, _text, &sw, &sh);
        if (flags & UI_MENUITEM_CENTER_TEXT_X)
        {
            old_text_x = m->text_x;
            m->text_x = (m->width - sw) >> 1;

            /* if the text width is too large, display from the beginning. */
            if (m->text_x < 0)
            {
                m->text_x = 0;
            }            
#ifdef __MMI_BI_DEGREE_MAIN_MENU_STYLE__
            if (MMI_current_menu_type == LIST_MATRIX_MENU)
            {
                if (m->text_x < 2)
                {
                    m->text_x = 2;
                }            
            }
#endif /* __MMI_BI_DEGREE_MAIN_MENU_STYLE__ */ 
        }
        if (flags & UI_MENUITEM_CENTER_TEXT_Y)
        {
            old_text_y = m->text_y;
            m->text_y = (m->height >> 1) - (sh >> 1);
        }
    }

    /* calculate the icon position */
    if (_icon != UI_NULL_IMAGE)
    {
        gui_measure_image(_icon, &icon_width, &icon_height);

        if (flags & UI_MENUITEM_CENTER_ICON_X)
        {
            old_icon_x = m->icon_x;
            m->icon_x = (m->width >> 1) - (icon_width >> 1);
        }
        if (flags & UI_MENUITEM_CENTER_ICON_Y)
        {
            old_icon_y = m->icon_y;
#ifdef  __MMI_BI_DEGREE_MAIN_MENU_STYLE__
            if (MMI_current_menu_type == LIST_MATRIX_MENU)
            {
                m->icon_y = (m->text_y >> 1) - (icon_height >> 1);
            }
            else
#endif  // __MMI_BI_DEGREE_MAIN_MENU_STYLE__
            {
                m->icon_y = (m->height >> 1) - (icon_height >> 1);
            }
        }
        if (flags & UI_MENUITEM_ICON_CENTER_JUSTIFY)
        {
            old_icon_x = m->icon_x;
            if (m->text_x > m->icon_x)
            {
                m->icon_x += ((m->text_x - m->icon_x + 1) >> 1) - (icon_width >> 1);
            }
            else
            {
                m->icon_x += ((m->width - m->icon_x + 1) >> 1) - (icon_width >> 1);
            }
        }
    }

    /* Compute text_x and text_y */
    text_x = m->text_x;
    text_y = m->text_y;

    /* For inline edit captions to appear from left when there is no icon   */
    if ((flags & UI_MENUITEM_DISABLE_ICON) && (_icon == UI_NULL_IMAGE) && !(flags & UI_MENUITEM_CENTER_TEXT_X))
    {
        is_text_full_width = 1;
        text_x = 2;
    }

    if (mmi_fe_get_r2l_state())
    {
        /* short one pixel for vector font in Abric language */
        text_x = m->width - 1 - text_x - 1;
    }

#if defined(__MMI_OP11_SIDEBAR__) || defined(__MMI_OP11_HOMESCREEN__)
    if (mi->ext_flags & UI_MENUITEM_EXT_SHOW_DATA)
    {
        if (g_gui_list_data_font)
        {
            text_x += g_gui_list_data_gap;
        }
        else
        {
            text_x += GUI_MENUITEM_DATA_LEFT_GAP;
        }
    }
#endif  // defined(__MMI_OP11_SIDEBAR__) || defined(__MMI_OP11_HOMESCREEN__)   

#ifdef __MMI_BI_DEGREE_MAIN_MENU_STYLE__
    if (MMI_current_menu_type == LIST_MATRIX_MENU)
    {
        is_text_full_width = 1;
    }
#endif /* __MMI_BI_DEGREE_MAIN_MENU_STYLE__ */ 
#ifdef __MMI_MAINLCD_320X480__
    if (MMI_current_menu_type == MATRIX_MENU && MMI_fixed_matrix_menu.flags & UI_MATRIX_MENU_FOR_MAINMENU)
        is_text_full_width = 1;
#endif

#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
#ifdef  __MMI_UI_LIST_FLASH_HIGHLIGHT_EFFECTS__
    /* To hide the text and icon of the menuitem up to the last frame for flash feel effect */
    if (gblock_list_effect == 0)
    {
        if (gui_get_current_list_effect() == MMI_UI_LIST_HIGHLIGHT_EFFECT_FLASH_FEELING &&
            MMI_current_menu_type == LIST_MENU)
        {
            if (g_flash_feel_state != GUI_LIST_EFFECT_FLASH_FEELING_LAST_FRAME)
            {
                if (flags & UI_MENUITEM_STATE_FOCUSSED)
                {
                    _icon = UI_NULL_IMAGE;
                    flags |= UI_MENUITEM_DISABLE_TEXT_DISPLAY;
                }
            }
        }
    }
#endif  /* __MMI_UI_LIST_FLASH_HIGHLIGHT_EFFECTS__ */    
#endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */ 

#ifdef  __MMI_CAT203_SUPPORT__
    if ((g_gui_list_get_underline != NULL) && (flags & UI_MENUITEM_STATE_FOCUSSED))
    {
        text_x += m->scroll_x;
    }
#endif  // __MMI_CAT203_SUPPORT__

    if ((flags & UI_MENUITEM_STATE_FOCUSSED) && (flags & UI_MENUITEM_FOCUSSED_ANIMATE))
    {
        animation_flag = 1;
    }
    
    if ((flags & UI_MENUITEM_STATE_FOCUSSED) && !(flags & UI_MENUITEM_DISABLE_HIGHLIGHT))
    {
        if (!(flags & UI_MENUITEM_DISABLE_BACKGROUND_ALWAYS))
        {
            f = gui_list_get_focussed_filler((gui_common_menuitem_base_struct*) m);
            fixed_single_line_menuitem_filled_area = *f;
        }
#ifndef __MMI_MAINLCD_320X480__
        text_color = m->focussed_text_color;
#else
        if (MMI_current_menu_type == LIST_MATRIX_MENU)
            text_color = m->normal_text_color;
        else
            text_color = m->focussed_text_color;
#endif
    }
    else if (flags & UI_MENUITEM_STATE_DISABLED)
    {
        if (!(flags & UI_MENUITEM_DISABLE_BACKGROUND) && !(flags & UI_MENUITEM_DISABLE_BACKGROUND_ALWAYS))
        {
            f = m->disabled_filler;
        }
        if ((mi->ext_flags & UI_MENUITEM_EXT_DISABLED_NORMAL_TEXT) || (ret_flag_ext & UI_MENUITEM_EXT_DISABLED_NORMAL_TEXT))
        {
            text_color = m->normal_text_color;
        }
        else
        {
            text_color = m->disabled_text_color;
        }
    }
    else if (flags & UI_MENUITEM_STATE_SELECTED)
    {
        f = m->selected_filler;
        text_color = m->selected_text_color;
        if (flags & UI_MENUITEM_SELECTED_ANIMATE)
        {
            animation_flag = 1;
        }
    }
    else
    {
        if (!(flags & UI_MENUITEM_DISABLE_BACKGROUND) && !(flags & UI_MENUITEM_DISABLE_BACKGROUND_ALWAYS))
        {
            f = m->normal_filler;
        }
    #ifdef __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__
        // if condition is not correct. It fails when any other flag is ON 
        // along with UI_MENUITEM_EXT_SHOW_IN_ROUNDED_RECT.
        if (mi->ext_flags & UI_MENUITEM_EXT_SHOW_IN_ROUNDED_RECT)
        {
            f = m->selected_filler;
        }
    #endif /* __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__ */ 

#ifdef  __MMI_SCREEN_ROTATE__
        if (mmi_frm_is_screen_width_height_swapped() && !current_MMI_theme->rotated_bkg_filler)
        {
            text_color = UI_COLOR_BLACK;
        }
        else
#endif  // __MMI_SCREEN_ROTATE__
        {
            text_color = m->normal_text_color;
        }

    }
    gui_push_clip();

    if (MMI_current_menu_type == MATRIX_MENU || (MMI_current_menu_type == MATRIX_PAGE_MENU))
    {
        S32 vbar_width = 0;
        S32 l_gap = 0, r_gap = 0; 
        if (animation_flag)
        {
            gui_measure_image(MMI_mm_animation, &ani_w, &ani_h);
            if (MMI_fixed_matrix_menu.flags & UI_MATRIX_MENU_SHOW_VERTICAL_SCROLLBAR)
            {
                vbar_width = MMI_fixed_matrix_menu.vbar.width;
            }
            if (mmi_fe_get_r2l_state())
            {
                l_gap = vbar_width;    
            }
            else
            {
                r_gap = vbar_width;
            }
            if (ani_w > m->width)
            {
                m->icon_x -= ((ani_w - m->width) >> 1);
                if (x1 + m->icon_x < MMI_fixed_matrix_menu.x + l_gap)
                {
                    m->icon_x = MMI_fixed_matrix_menu.x  + l_gap - x1;
                }
                if (x1 + m->icon_x + ani_w > MMI_fixed_matrix_menu.x + MMI_fixed_matrix_menu.width - r_gap)
                {
                    m->icon_x = MMI_fixed_matrix_menu.x + MMI_fixed_matrix_menu.width - r_gap - x1 - ani_w;
                }
            }
            
            if (ani_h > m->height)
            {
                m->icon_y -= ((ani_h - m->height) >> 1);
                if (y1 + m->icon_y < MMI_fixed_matrix_menu.y)
                {
                    m->icon_y = MMI_fixed_matrix_menu.y - y1;
                }
                if (y1 + m->icon_y + ani_h > MMI_fixed_matrix_menu.y + MMI_fixed_matrix_menu.height - yoff)
                {
                    m->icon_y = MMI_fixed_matrix_menu.y + MMI_fixed_matrix_menu.height - yoff - y1 - ani_h;
                }
            }

            clip_x1 = x1 + m->icon_x;
            clip_y1 = y1 + m->icon_y;
            clip_x2 = x1 + m->icon_x + ani_w - 1;
            clip_y2 = menu_y2;
            
            if (y1 + m->icon_y >= menu_y2)
            {
                clip_y1 = menu_y2;
            }
            else if (y1 + m->icon_y + ani_h - 1 < menu_y2)
            {
                clip_y2 = y1 + m->icon_y + ani_h - 1;
            }
            gui_set_clip(clip_x1, clip_y1, clip_x2, clip_y2);
        }
        else
        {
            /* for fixed text matrix, _icon = NULL, don't touch the clip */
            if (_icon)
            {
                gui_measure_image(_icon, &ani_w, &ani_h);
                
                clip_x1 = x1 + m->icon_x;
                clip_y1 = y1 + m->icon_y;
                clip_x2 = x1 + m->icon_x + ani_w - 1;
                clip_y2 = menu_y2;
                
                if (y1 + m->icon_y >= menu_y2)
                {
                    clip_y1 = menu_y2;
                }
                else if (y1 + m->icon_y + ani_h - 1 < menu_y2)
                {
                    clip_y2 = y1 + m->icon_y + ani_h - 1;
                }
                gui_set_clip(clip_x1, clip_y1, clip_x2, clip_y2);
            }
        }
    }
    else
    {
        clip_y2 = menu_y2;
        
        if (MMI_current_menu_type == MATRIX_MENU_EMS)
        {
            clip_x1 = x1 - 2;
            clip_y1 = y1 - 2;
            clip_x2 = x2 + 2;
            
            /* reserve a 1-pixel rect out of the menuitem */
            if (y1 - 2 >= menu_y2)                
            {
                clip_y1 = menu_y2;
            }
            else if (y2 < menu_y2)
            {
                clip_y2 = y2 + 2;
            }
        }
        else
        {
            clip_x1 = x1;
            clip_y1 = y1;
            clip_x2 = x2;

            //unimportant issues
            #ifndef __MMI_UI_MENU_SLIM__
            gdi_layer_get_active(&act_layer);
            if (MMI_current_menu_type == LIST_MENU && clip_y1 < m->parent_list->y && m->parent_list->act_layer_handle == act_layer)
            #else
            if (y1 < m->parent_list->y && g_current_display_half_menuitem)
			#endif
			{
                clip_y1 = m->parent_list->y;
            }            
            if (y1 >= menu_y2)
            {
                clip_y1 = menu_y2;
            }
            else if (y2 < menu_y2)
            {
                clip_y2 = y2;
            }
        }
        gui_set_clip(clip_x1, clip_y1, clip_x2, clip_y2);
    }

    if (m->flags & UI_MENUITEM_DISABLE_HIGHLIGHT_DISPLAY)
    {
        f = NULL;
    }

    if (m->hide_function)
    {
        gui_swla_log_start("IFL");
        m->hide_function(x1, y1, x2, y2);
        gui_swla_log_stop("IFL");
    }
    else if (f != NULL  && !g_slide_effect->in_flatten)
    {
    //unimportant issues
    #ifndef __MMI_UI_MENU_SLIM__
        if (MMI_current_menu_type == LIST_MENU && m->parent_list)
        {
            if (m->parent_list->alpha_blend_layer_handle)
            {
                old_alpha_layer = gdi_set_alpha_blending_source_layer(m->parent_list->alpha_blend_layer_handle);
            }
        }
        else
	#endif
        {
            old_alpha_layer = gui_list_set_alpha_blending_layer();
        }

    #ifdef __MMI_BI_DEGREE_MAIN_MENU_STYLE__
        if (MMI_current_menu_type == LIST_MATRIX_MENU)
        {
        #ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
            set_start_position_and_item_parameters_for_list_highlighter_effect(item, common_item_data, x1, y1);
        #endif 
        #ifndef __MMI_MAINLCD_320X480__
            if (mmi_fe_get_r2l_state())
            {
                gui_swla_log_start("IFL");
                gui_draw_filled_area(x1, y1 + text_y, x1 + text_x, y2, f);
                gui_swla_log_stop("IFL");
            }
            else
            {
                
                clip_x1 = x1;
                clip_y1 = y1;
                clip_x2 = x2 + 2;
                clip_y2 = menu_y2;
                
                if (y1 >= menu_y2)
                {
                    clip_y1 = menu_y2;
                }
                else if (y2 < menu_y2)
                {
                    clip_y2 = y2;
                }
                gui_push_and_set_clip(clip_x1, clip_y1, clip_x2, clip_y2);
                gui_swla_log_start("IFL");
                gui_draw_filled_area(x1, y1 + text_y, x2 + 2, y1 + text_y + sh, f);
                gui_swla_log_stop("IFL");
                gui_pop_clip();
            }
        #else
            if (mmi_fe_get_r2l_state())
            {
                gui_swla_log_start("IFL");
                gdi_draw_solid_rect(x1, y1 + text_y, x1 + text_x, y2, GDI_COLOR_TRANSPARENT);
                gui_swla_log_stop("IFL");
            }
            else
            {
                
                clip_x1 = x1;
                clip_y1 = y1;
                clip_x2 = x2 + 2;
                clip_y2 = menu_y2;
                
                if (y1 >= menu_y2)
                {
                    clip_y1 = menu_y2;
                }
                else if (y2 < menu_y2)
                {
                    clip_y2 = y2;
                }
                gui_push_and_set_clip(clip_x1, clip_y1, clip_x2, clip_y2);
                gui_swla_log_start("IFL");
                gdi_draw_solid_rect(x1 + text_x, y1 + text_y, x2 + 2, y1 + text_y + sh, GDI_COLOR_TRANSPARENT);
                gui_swla_log_stop("IFL");
                gui_pop_clip();
            }
        #endif
        }
        else
    #endif /* __MMI_BI_DEGREE_MAIN_MENU_STYLE__ */ 
        {
        #ifdef __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__
            // if condition is not correct. It fails when any other flag is ON 
            // along with UI_MENUITEM_EXT_SHOW_IN_ROUNDED_RECT.

            /* 
             * special menu item background filler drawing for inline items
             *
             * 1. y1 + 1 and y2 - 1 are to keep the border not touch each other. 
             * (That is a 2 pixel spacing.)
             * 2. The filler does not cover the icon, unlike normal list menu items.
             */
            if (mi->ext_flags & UI_MENUITEM_EXT_SHOW_IN_ROUNDED_RECT)
            {
                gui_swla_log_start("IFL");
                if (text_y)
                {
                    if (mmi_fe_get_r2l_state())
                    {
                        gui_draw_filled_area(x1, y1 + 1, x2 - m->text_x, y2 - 1, f);
                    }
                    else
                    {
                        gui_draw_filled_area(x1 + m->text_x, y1 + 1, x2, y2 - 1, f);
                    }
                }
                else
                {   
                    if (mmi_fe_get_r2l_state())
                    {
                        gui_draw_filled_area(x1, y1, x2 - m->text_x, y2, f);
                    }
                    else
                    {
                        gui_draw_filled_area(x1 + m->text_x, y1, x2, y2, f);
                    }
                }
                gui_swla_log_stop("IFL");
            }
            else
        #endif /* __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__ */ 
            {
           	#ifdef __MMI_SUPPORT_DUMP_SCREEN_STRING__
           	#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
                if (is_draw_next_frame_list_highlight_effect_value())
            #endif
                {
                    mmi_frm_dss_set_menu_highlight(MMI_SCREEN_HIGHLIGHT_ICONTEXT_ITEM);
                }
            #endif	

                set_start_position_and_item_parameters_for_list_highlighter_effect(item, common_item_data, x1, y1);
            #if defined(__MMI_OP11_HOMESCREEN_0301__) || defined(__MMI_OP11_HOMESCREEN_0302__)
                if (ret_flag_ext & UI_MENUITEM_EXT_SHOW_DOWN_SHORT_SEPARATORLINE)
                {
                    y2 --;
                }
            #endif  // defined(__MMI_OP11_HOMESCREEN_0301__) || defined(__MMI_OP11_HOMESCREEN_0302__)

                gui_swla_log_start("IFL");
#ifdef  __OP01_FWPBW__
                if (flags & UI_MENUITEM_DISABLE_ICON && _icon == NULL)
                {
                    gui_draw_filled_area(x1, y1, x2, y2, f);
                }
                else
                {
                    gui_draw_filled_area(x1 + m->text_x, y1, x2, y2, f);
                }
#else   // __OP01_FWPBW__
            #ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
                gui_draw_list_filled_area(x1, y1, x2, y2, f);
            #else /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */ 
			  #ifdef __MMI_MAINLCD_96X64__
			    gui_menuitem_draw_list_filler(x1 + m->text_x, y1, x2, y2, f, MMI_TRUE, MMI_FALSE);
			  #else
                gui_menuitem_draw_list_filler(x1, y1, x2, y2, f, MMI_TRUE, MMI_FALSE);
			  #endif
            #endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */ 
#endif  // __OP01_FWPBW__
                gui_swla_log_stop("IFL");
            #if defined(__MMI_OP11_HOMESCREEN_0301__) || defined(__MMI_OP11_HOMESCREEN_0302__)
                if (ret_flag_ext & UI_MENUITEM_EXT_SHOW_DOWN_SHORT_SEPARATORLINE)
                {
                    y2 ++;
                }
            #endif  // defined(__MMI_OP11_HOMESCREEN_0301__) || defined(__MMI_OP11_HOMESCREEN_0302__)
            }
        }

        gui_list_reset_alpha_blending_layer(old_alpha_layer);
    }

    if (_icon != UI_NULL_IMAGE && !((m->ext_flags & UI_MENUITEM_EXT_SHOW_IN_MARQUEE) && animation_flag))
    {
        old_alpha_layer = GDI_NULL_HANDLE;
        if (MMI_fixed_list_menu.alpha_blend_layer_handle)
        {
            old_alpha_layer = gdi_set_alpha_blending_source_layer(MMI_fixed_list_menu.alpha_blend_layer_handle);
        }
        else if ((flags & UI_MENUITEM_STATE_FOCUSSED && !(flags & UI_MENUITEM_DISABLE_HIGHLIGHT)) || g_slide_effect->in_flatten)
        {
#ifdef __MMI_BI_DEGREE_MAIN_MENU_STYLE__
            if (MMI_current_menu_type != LIST_MATRIX_MENU)
#endif
            {
                gdi_layer_get_active(&old_alpha_layer);
                old_alpha_layer = gdi_set_alpha_blending_source_layer(old_alpha_layer);
            } 
        }
        if (mi->item_icon_handle != GDI_ERROR_HANDLE)
        {
            gdi_image_stop_animation(mi->item_icon_handle);
            mi->item_icon_handle = GDI_ERROR_HANDLE;
        }
        if (animation_flag)
        {
        
			/* imageResource violation */
		//#if defined __MMI_RESOURCE_IMAGE_GROUP_COMPRESS__
			PU8 imgBuffer = NULL;
		//#endif
		
#if defined __MMI_RESOURCE_IMAGE_GROUP_COMPRESS__
			imgBuffer = (PU8)GetImageData((S8*)MMI_mm_animation) ;
#else
			imgBuffer = MMI_mm_animation ;
#endif

            if (MMI_current_menu_type == MATRIX_MENU || (MMI_current_menu_type == MATRIX_PAGE_MENU))
            {
                if ((MMI_fixed_matrix_menu.flags & UI_MATRIX_MENU_FOR_MAINMENU))
                {
//unimportant issues
#if(!(defined __MMI_UI_MENU_SLIM__ ))&& (defined(__MMI_MAINMENU_SPREAD_SUPPORT__))
                    gdi_handle active_layer;
                    S32 w, h;
    
                    gdi_image_get_dimension(current_MMI_theme->matrix_main_menu_highlight_image, &w, &h);
    
                    clip_x1 = x1 + (((x2 - x1) - w) >> 1);
                    clip_y1 = y1;
                    clip_x2 = x1 + (((x2 - x1) - w) >> 1) + w - 1;
                    clip_y2 = menu_y2;
    
                    if (y1 + m->icon_y >= menu_y2)
                    {
                        clip_y1 = menu_y2;
                    }
                    else if (y1 + m->height - 1 < menu_y2)
                    {
                        clip_y2 = y1 + m->height - 1;
                    }
                    gui_push_and_set_clip(clip_x1, clip_y1, clip_x2, clip_y2);
    
                    background_filler.b = current_MMI_theme->matrix_main_menu_highlight_image;
                    background_filler.flags = UI_FILLED_AREA_TYPE_BITMAP;
                    gui_draw_filled_area(x1 + (((x2 - x1) - w) >> 1), y1, x1 + (((x2 - x1) - w) >> 1) + w, y2,&background_filler);
                    gdi_layer_flatten_with_clipping(dm_get_layer_handle(0), dm_get_layer_handle(1), dm_get_layer_handle(2), dm_get_layer_handle(3));
                    gdi_layer_get_active(&active_layer);
                    gdi_push_and_set_alpha_blending_source_layer(active_layer);
    
                    gdi_image_draw_frames(
                        x1 + m->icon_x,
                        y1 + m->icon_y,
                        _icon,
                        1);
    
                    gdi_pop_and_restore_alpha_blending_source_layer();
                    gui_pop_clip();
#else /* defined(__MMI_MAINMENU_SPREAD_SUPPORT__) */
                    /* matrix main menu. call special function for drawing animation on a highlight image.  */
                    if ((!gui_main_menu_matrix_slide_is_under_control()))// &&
                        //(!gui_matrix_screen_smooth_scrolling_moved_by_pen()))
                    {
#ifdef  __MMI_MAINLCD_320X480__

                        clip_x1 = x1 + m->icon_x;
                        clip_y1 = y1 + m->icon_y;
                        clip_x2 = x1 + m->width - 1;
                        clip_y2 = menu_y2;

                        if (y1 + m->icon_y >= menu_y2)
                        {
                            clip_y1 = menu_y2;
                        }
                        else if (y1 + m->height - 1 < menu_y2)
                        {
                            clip_y2 = y1 + m->height - 1;
                        }
                        gui_push_and_set_clip(clip_x1, clip_y1, clip_x2, clip_y2);
                        
                        background_filler.b = current_MMI_theme->matrix_main_menu_highlight_image;
                        background_filler.flags = UI_FILLED_AREA_TYPE_BITMAP;
                        gui_draw_filled_area(x1 + m->icon_x, y1 + m->icon_y, x2, y2,&background_filler);
                        gui_pop_clip();
#endif  // __MMI_MAINLCD_320X480__
                        gui_show_animation_with_background_image(
                            x1 + m->icon_x, 
                            y1 + m->icon_y,
                            imgBuffer,///MMI_mm_animation,
                            current_MMI_theme->matrix_main_menu_highlight_image,
                            (gdi_handle*)&mi->item_icon_handle);
#if defined __MMI_RESOURCE_IMAGE_GROUP_COMPRESS__
							  SetImageFlushable(MMI_mm_animation);
#endif

                    }
                    else
                    {
                        gdi_image_draw_animation(
                            x1 + m->icon_x,
                            y1 + m->icon_y,
                            imgBuffer,//MMI_mm_animation,
                            (gdi_handle*)&mi->item_icon_handle);
						
#if defined __MMI_RESOURCE_IMAGE_GROUP_COMPRESS__
						
						SetImageFlushable(MMI_mm_animation);
#endif
                    }
//unimportant issues
//#ifndef __MMI_UI_MENU_SLIM__
#endif /* defined(__MMI_MAINMENU_SPREAD_SUPPORT__) */
//#endif
                }
                else
                {   /* normal matrix menu */             
                    gdi_image_draw_animation(
                        x1 + m->icon_x,
                        y1 + m->icon_y,
                        mi->item_icon,
                        (gdi_handle*)&mi->item_icon_handle);
                }                
            }
#if defined (__MMI_MAINLCD_320X480__) && defined (__MMI_BI_DEGREE_MAIN_MENU_STYLE__)
            else if (MMI_current_menu_type == LIST_MATRIX_MENU)
            {
                gdi_image_draw_animation(
                    x1 + m->icon_x,
                    y1 + m->icon_y,
                    imgBuffer,//MMI_mm_animation,
                    (gdi_handle*)&mi->item_icon_handle);
				
#if defined __MMI_RESOURCE_IMAGE_GROUP_COMPRESS__
					 SetImageFlushable(MMI_mm_animation);
#endif

            }
#endif  // defined (__MMI_MAINLCD_320X480__) && defined (__MMI_BI_DEGREE_MAIN_MENU_STYLE__)
            else if (MMI_current_menu_type == MATRIX_MENU_EMS)
            {
                /* extern gdi_color GDI_COLOR_BLACK; */
                gdi_image_draw_animation(
                    x1 + m->icon_x,
                    y1 + m->icon_y,
                    mi->item_icon,
                    (gdi_handle*) & mi->item_icon_handle);
                gdi_draw_rect(x1 - 1, y1 - 1, x2 + 1, y2 + 1, GDI_COLOR_BLACK);
                gdi_draw_rect(x1 - 2, y1 - 2, x2 + 2, y2 + 2, GDI_COLOR_WHITE);
            }
            else
            {
                S32 icon_x;

                /* have to handle R2L list menu animation icon x position */
                if (mmi_fe_get_r2l_state() && (MMI_current_menu_type == LIST_MENU))
                {                   
                    icon_x = x2 - m->icon_x - icon_width + 1;
                }
                else
                {
                    icon_x = x1 + m->icon_x;
                }

                gui_swla_log_start("ICO");
                gdi_image_draw_animation(
                    icon_x,
                    y1 + m->icon_y,
                    mi->item_icon,
                    (gdi_handle*)&mi->item_icon_handle);                    
                gui_swla_log_stop("ICO");
            }
        }
        else if (m->flags & UI_MENUITEM_STATE_ANIMATE)
        {
            gui_swla_log_start("ICO");
            gdi_image_draw_frames(
                x1 + m->icon_x,
                y1 + m->icon_y,
                _icon,
                1);
            gui_swla_log_stop("ICO");
            m->flags &= ~UI_MENUITEM_STATE_ANIMATE;
        }
        else if (MMI_current_menu_type == LIST_MENU)
        {
            S32 x_clip = 0, y_clip = 0;

            gui_push_clip();
            if (m->icon_x > 0)
            {
                x_clip = m->icon_x;
            }
#ifdef __MMI_UI_LIST_GRID_LINE__
            if (m->icon_y <= 0)
            {
                y_clip = 1;
            }
#endif /* __MMI_UI_LIST_GRID_LINE__ */
            if (m->icon_y > 0)
            {
                y_clip = m->icon_y;
            }

            clip_y1 = y1 + y_clip;
            clip_y2 = menu_y2;

//unimportant issues
			#ifndef __MMI_UI_MENU_SLIM__
            gdi_layer_get_active(&act_layer);
            if (MMI_current_menu_type == LIST_MENU && clip_y1 < m->parent_list->y && m->parent_list->act_layer_handle == act_layer)
            {
                clip_y1 = m->parent_list->y;
            }
			#endif
            if (!mmi_fe_get_r2l_state())
            {
                clip_x1 = x1 + x_clip;
                clip_x2 = x1 + m->text_x - 2;
                
                if (y1 + y_clip >= menu_y2)
                {
                    clip_y1 = menu_y2;
                }
                else if (y1 + m->height - 1 < menu_y2)
                {
                    clip_y2 = y1 + m->height - 1;
                }
				//unimportant issues
				#ifndef __MMI_UI_MENU_SLIM__
                gui_set_clip(clip_x1, clip_y1, clip_x2, clip_y2);
                #else				
                gui_set_clip_preset(clip_x1, clip_y1, clip_x2, clip_y2);
				#endif
                gui_swla_log_start("ICO");
                gdi_image_draw_animation_single_frame(x1 + m->icon_x, y1 + m->icon_y, (U8*) _icon, 0);
                gui_swla_log_stop("ICO");
            }
            else
            {
                clip_x1 = x2 - m->text_x + 2;
                clip_x2 = x2 - x_clip;
                
                /* R2L icons are right-aligned. */
                if (y1 + y_clip >= menu_y2)
                {
                    clip_y1 = menu_y2;
                }
                else if (y1 + m->height - 1 < menu_y2)
                {
                    clip_y2 = y1 + m->height - 1;
                }
				//unimportant issues
				#ifndef __MMI_UI_MENU_SLIM__
                gui_set_clip(clip_x1, clip_y1, clip_x2, clip_y2);
                #else				
                gui_set_clip_preset(clip_x1, clip_y1, clip_x2, clip_y2);
				#endif

                gui_swla_log_start("ICO");
                gdi_image_draw_animation_single_frame(x2 - m->icon_x - icon_width + 1, y1 + m->icon_y, (U8*) _icon, 0);
                gui_swla_log_stop("ICO");
            }

            gui_pop_clip();

            /* show checkbox, show it here to correspond to list effects since */
            if (m->ext_flags & UI_MENUITEM_EXT_SHOW_ICONTEXT_CHECKBOX)
            {
                gui_menuitem_icontext_show_checkbox(m, x1, y1);
            }
        }
        else
        {
            gdi_image_draw_animation_single_frame(x1 + m->icon_x, y1 + m->icon_y, (U8*) _icon, 0);
        }

        gui_list_reset_alpha_blending_layer(old_alpha_layer);
    }

#ifdef __MMI_OP11_SIDEBAR__
    if (mi->ext_flags & UI_MENUITEM_EXT_SHOW_TIME)
    {
        if (!wgui_clock_is_available_id(g_gui_list_clock))
        {
            wgui_clock_create(&g_gui_list_clock, 0, 0, 0, 0, GUI_CLOCK_MAINLCD_TYPE_DIGITAL_TIME);
            if (mi->ext_flags & UI_MENUITEM_EXT_SHOW_DATA)
            {
                if (g_gui_list_data_font)
                {
                    wgui_clock_set_time_text_font(g_gui_list_clock, g_gui_list_data_font);
                    wgui_clock_measure_time_text(g_gui_list_clock, &time_w, &time_h, g_gui_list_data_font);
                }
                else
                {
                    wgui_clock_set_time_text_font(g_gui_list_clock, &MMI_small_font);
                    wgui_clock_measure_time_text(g_gui_list_clock, &time_w, &time_h, &MMI_small_font);
                }                
            }
            else
            {
                wgui_clock_set_time_text_font(g_gui_list_clock, m->text_font);
                wgui_clock_measure_time_text(g_gui_list_clock, &time_w, &time_h, m->text_font);
            }        
            
            gdi_layer_get_active(&target_layer);
            wgui_clock_set_target_layer(g_gui_list_clock, target_layer);            
            wgui_clock_resize(g_gui_list_clock, time_w + 3, time_h); 
            if (mmi_fe_get_r2l_state())
            {
                wgui_clock_move(g_gui_list_clock, x1, y1+((m->height - time_h)>>1));
            }
            else
            {
                wgui_clock_move(g_gui_list_clock, x2 - time_w - 6, y1+((m->height - time_h)>>1));
            }            
            wgui_clock_set_hide_function(g_gui_list_clock, gui_fixed_icontext_menuitem_hide_time);
            wgui_clock_set_text_border_enable(g_gui_list_clock, MMI_FALSE);
        }
        else
        {
            wgui_clock_measure_time_text(g_gui_list_clock, &time_w, &time_h, m->text_font);
            wgui_clock_move(g_gui_list_clock, x2 - time_w - 6, y1+((m->height - time_h)>>1));
        } 
    }
#endif  //  __MMI_OP11_SIDEBAR__

    if (!(flags & UI_MENUITEM_DISABLE_TEXT_DISPLAY))
    {
#ifdef  __MMI_VECTOR_FONT_SUPPORT__
        old_alpha_layer = GDI_NULL_HANDLE;
        if (MMI_fixed_list_menu.alpha_blend_layer_handle)
        {
            old_alpha_layer = gdi_set_alpha_blending_source_layer(MMI_fixed_list_menu.alpha_blend_layer_handle);
        }
        else if ((flags & UI_MENUITEM_STATE_FOCUSSED && !(flags & UI_MENUITEM_DISABLE_HIGHLIGHT)) || g_slide_effect->in_flatten)
        {
#ifdef __MMI_BI_DEGREE_MAIN_MENU_STYLE__
            if (MMI_current_menu_type != LIST_MATRIX_MENU)
#endif
            {
                gdi_layer_get_active(&old_alpha_layer);
                old_alpha_layer = gdi_set_alpha_blending_source_layer(old_alpha_layer);
            } 
        }
#endif  // __MMI_VECTOR_FONT_SUPPORT__
        gui_push_text_clip();
        if (!(flags & UI_MENUITEM_DISABLE_TEXT_CLIP))
        {
            clip_y1 = y1;
            clip_y2 = menu_y2;

//unimportant issues
			#ifndef __MMI_UI_MENU_SLIM__
            gdi_layer_get_active(&act_layer);
            if (MMI_current_menu_type == LIST_MENU && clip_y1 < m->parent_list->y && m->parent_list->act_layer_handle == act_layer)
            {
                clip_y1 = m->parent_list->y;
            }
			#endif
            if (y1 >= menu_y2)
            {
                clip_y1 = menu_y2;
            }
            else if (y2 < menu_y2)
            {
                clip_y2 = y2;
            }
            
            if (is_text_full_width)
            {
                /* FIXME. text_x might not be 0 */
#ifdef __MMI_BI_DEGREE_MAIN_MENU_STYLE__
                if (MMI_current_menu_type == LIST_MATRIX_MENU)
                {
                    clip_x1 = x1 + 1;
                    clip_x2 = x2;

                    gui_set_text_clip(clip_x1, clip_y1, clip_x2, clip_y2);
                    
                    max_text_width = m->width - 1;
                }
                else
#endif  // __MMI_BI_DEGREE_MAIN_MENU_STYLE__
                {
                    clip_x1 = x1;
                    clip_x2 = x2;
                    
                   //unimportant issues
                   #ifndef __MMI_UI_MENU_SLIM__
                    gui_set_text_clip(clip_x1, clip_y1, clip_x2, clip_y2);
				   #else 
				   gui_set_text_clip_preset(clip_x1, clip_y1, clip_x2, clip_y2);
				   #endif
                    
                    if (mmi_fe_get_r2l_state())
                    {
                        max_text_width = text_x;
                    }
                    else
                    {
                        max_text_width = m->width - text_x;
                    }
#ifdef __MMI_FTE_SUPPORT__
                    if (MMI_current_menu_type == LIST_MENU)
                    {
                        max_text_width -= GUI_MENUITEM_TEXT_RIGHT_GAP;
                    }
#else
#ifdef __MMI_UI_LIST_SLIDE_EFFECT__
                    if ((MMI_current_menu_type == LIST_MENU) && gui_menuitem_is_image_highlight(m))
                    {
                        max_text_width -= GUI_MENUITEM_TEXT_RIGHT_GAP;
                    }
#endif					
#endif
                }
                if (mi->ext_flags & UI_MENUITEM_EXT_SHOW_INDICATOR)
                {
                    max_text_width -= i_width;
                }
            }
            else
            {
                if ((m->icon_x > m->text_x) && !(flags & UI_MENUITEM_DISABLE_ICON))
                {
                    clip_x1 = x1;
                    clip_x2 = x1 + m->icon_x - 1;
                    
                   //unimportant issues
                   #ifndef __MMI_UI_MENU_SLIM__
                    gui_set_text_clip(clip_x1, clip_y1, clip_x2, clip_y2);
				   #else 
				   gui_set_text_clip_preset(clip_x1, clip_y1, clip_x2, clip_y2);
				   #endif
                    
                    max_text_width = m->icon_x - m->text_x;
                }
                else
                {
                    if (time_w)
                        time_w += GUI_MENUITEM_DATA_LEFT_GAP;
                    if (!mmi_fe_get_r2l_state())
                    {
                        clip_x1 = x1 + m->text_x;
                        clip_x2 = x2 - time_w - i_width;
                        
                        if (f && (f->flags & UI_FILLED_AREA_BORDER))
                        {
                            /* Leave space for border of background filler */
                            clip_x2 -= 2;
                        }
                    }
                    else
                    {
                        clip_x1 = x1 + time_w + i_width;
                        clip_x2 = x2 - m->text_x;
                        
                        if (f && (f->flags & UI_FILLED_AREA_BORDER))
                        {
                            clip_x1 += 2;
                            /* Leave space for border of background filler */
                        }
                    }
                   //unimportant issues
                   #ifndef __MMI_UI_MENU_SLIM__
                    gui_set_text_clip(clip_x1, clip_y1, clip_x2, clip_y2);
				   #else 
				   gui_set_text_clip_preset(clip_x1, clip_y1, clip_x2, clip_y2);
				   #endif
                    
                    if (flags & UI_MENUITEM_CENTER_TEXT_X)
                    {
                        max_text_width = x2 - (x1 + old_text_x) + 1 - i_width;
                    }
                    else
                    {
                        max_text_width = x2 - (x1 + m->text_x) + 1 - i_width;
                    }

                    gui_menuitem_adjust_text_clip_for_right_gap(m);                
#ifdef  __MMI_FTE_SUPPORT__                    
                    if (MMI_current_menu_type == LIST_MENU)
                    {
                        max_text_width -= GUI_MENUITEM_TEXT_RIGHT_GAP;
                    }
#else   // __MMI_FTE_SUPPORT__
#ifdef __MMI_UI_LIST_SLIDE_EFFECT__
                    if ((MMI_current_menu_type == LIST_MENU) && gui_menuitem_is_image_highlight(m))
                    {
                        max_text_width -= GUI_MENUITEM_TEXT_RIGHT_GAP;
                    }
                    else 
#endif/*__MMI_UI_LIST_SLIDE_EFFECT__*/						
						if (MMI_current_menu_type == LIST_MENU)
                    {
                        max_text_width -= 1;
                    }
#endif  // __MMI_FTE_SUPPORT__
                }
            }
        }
        else
        {
            max_text_width = m->width - m->text_x;
        }

#if defined(__MMI_OP11_SIDEBAR__) || defined(__MMI_OP11_HOMESCREEN__)
        if (mi->ext_flags & UI_MENUITEM_EXT_SHOW_DATA)
        {
            if (g_gui_list_data_font)
            {
                max_text_width -=  g_gui_list_data_gap;
            }
            else
            {
                max_text_width -=  GUI_MENUITEM_DATA_LEFT_GAP;
            }
        }
#endif  // defined(__MMI_OP11_SIDEBAR__) || defined(__MMI_OP11_HOMESCREEN__)
        if (f && (f->flags & UI_FILLED_AREA_BORDER))
        {
            if (text_x < 1)
            {
                gui_get_text_clip(&clip_x1, &clip_y1, &clip_x2, &clip_y2);
                clip_x1++;
                clip_x2--;
                if (mmi_fe_get_r2l_state())
                {
                    text_x -= 1;
                }
                else
                {
                    text_x += 1;
                }

               //unimportant issues
               #ifndef __MMI_UI_MENU_SLIM__
                gdi_layer_get_active(&act_layer);
                if (MMI_current_menu_type == LIST_MENU && clip_y1 < m->parent_list->y && m->parent_list->act_layer_handle == act_layer)
                {
                    clip_y1 = m->parent_list->y;
                }
				#endif
                if (clip_y1 >= menu_y2)
                {
                //hujin
                //unimportant issues
                #ifndef __MMI_UI_MENU_SLIM__
                    gui_set_clip(clip_x1, menu_y2, clip_x2, menu_y2);
				#else				  
				gui_set_clip_preset(clip_x1, menu_y2, clip_x2, menu_y2);
  				#endif
                }
                else if (clip_y2 >= menu_y2)
                {
                    //unimportant issues
                    #ifndef __MMI_UI_MENU_SLIM__
                    gui_set_text_clip(clip_x1, clip_y1, clip_x2, menu_y2);
					#else					
                    gui_set_text_clip_preset(clip_x1, clip_y1, clip_x2, menu_y2);
					#endif
                }
                else
                {
                    //unimportant issues
                    #ifndef __MMI_UI_MENU_SLIM__
                    gui_set_text_clip(clip_x1, clip_y1, clip_x2, clip_y2);
					#else
                    gui_set_text_clip_preset(clip_x1, clip_y1, clip_x2, clip_y2);
					#endif
                }           
            }           
            max_text_width -= 1;
        }
        /* move the cursor by 3 pixels when the default text effect is enabled and the
           menu item is to be shown inside rectangle. */
    #ifdef __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__
        if (mi->ext_flags & UI_MENUITEM_EXT_SHOW_IN_ROUNDED_RECT)
        {
            /* 
             * This is a workaround to make the text y not 0 since the rect filler starts
             * at y1 + 1.
             */
            // TODO: The menu height should be at least (font height + 2).
            //if (text_y == 0)
            //{
             //   text_y = 1;
            //}
            S32 x_offset = 0;

            if (flags & UI_MENUITEM_STATE_FOCUSSED)
            {
                x_offset = 3;
            }

            if (!mmi_fe_get_r2l_state())
            {
                gui_move_text_cursor(x1 + text_x + x_offset, y1 + text_y);
                text_x += x_offset;
                max_text_width -= x_offset;
            }
            else
            {
                gui_move_text_cursor(x1 + text_x - x_offset, y1 + text_y);
                text_x -= x_offset;
                max_text_width -= x_offset;
            }
        }
        else
    #endif /* __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__ */ 
        {
            gui_move_text_cursor(x1 + text_x, y1 + text_y);
        }

        gui_set_line_height(sh);
        gui_set_text_color(text_color);

        if ((sw > max_text_width) && !(flags & UI_MENUITEM_TRUNCATE_CONTENT))
        {
            if (((flags & UI_MENUITEM_MARQUEE_SCROLL) || (flags & UI_MENUITEM_TWO_DIRECTION_SCROLL)) &&
                (!(flags & UI_MENUITEM_DISABLE_HIGHLIGHT)))
            {
                g_gui_menuitem_need_scroll = MMI_TRUE;
            }
        }

        if ((flags & UI_MENUITEM_STATE_FOCUSSED) && 
            (flags & UI_MENUITEM_MARQUEE_SCROLL) &&
            (GUI_current_fixed_icontext_menuitem_scroll || g_gui_menuitem_need_scroll) &&
            !(mi->ext_flags & UI_MENUITEM_EXT_DISABLE_FOCUSSED_TEXT_DISPLAY) &&
            ((y1 >= menu_y1 && y1 + sh <= menu_y2) || !g_current_display_half_menuitem))
        {
        #ifdef __MMI_SUPPORT_DUMP_SCREEN_STRING__
            mmi_frm_dss_set_menu_highlight(MMI_SCREEN_HIGHLIGHT_ICONTEXT_MARQUEE_SCROLL);
		#endif
#ifdef __MMI_MAINLCD_320X480__
            if ((MMI_current_menu_type == MATRIX_MENU) &&(mi->flags & UI_MENUITEM_STATE_FOCUSSED) 
                && GUI_current_fixed_icontext_menuitem_scroll)
            {
                if (!gui_main_menu_matrix_slide_is_under_control() && current_MMI_theme->matrix_main_menu_highlight_image)
                {
                    background_filler.b = current_MMI_theme->matrix_main_menu_highlight_image;
                    background_filler.flags = UI_FILLED_AREA_TYPE_BITMAP;

                    clip_y1 = y1 = y1 + text_y;
                    clip_y2 = menu_y2;

                    if (y1 + text_y >= menu_y2)
                    {
                        clip_y1 = menu_y2;
                    }
                    else if (y2 < menu_y2)
                    {
                        clip_y2 = y2;
                    }
                    gui_push_and_set_clip(x1, clip_y1, x2, clip_y2);
                    
                    gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_TRANSPARENT);
                    gui_draw_filled_area(x1, y1, x2, y2,&background_filler);
                    gui_pop_clip();
                }
                else
                {
                    gdi_draw_solid_rect(x1, y1 + text_y, x2, y2, GDI_COLOR_TRANSPARENT);
                }
            }
#endif  // __MMI_MAINLCD_320X480__

#ifdef  __MMI_CAT203_SUPPORT__
            if (g_gui_list_get_underline == NULL && mmi_fe_get_r2l_state() && (GUI_current_fixed_icontext_menuitem_scroll || g_gui_menuitem_need_scroll))
#else
            if (mmi_fe_get_r2l_state() && (GUI_current_fixed_icontext_menuitem_scroll || g_gui_menuitem_need_scroll))
#endif                
            {
                /* short one pixel for vector font in Abric language */
                gui_list_show_text(m, mi, x1 + text_x - max_text_width + 2, y1 + text_y, max_text_width - 1, sw, sh);
            }
            else
            {
                /* print the text at the normal position */
                gui_list_show_text(m, mi, x1 + text_x, y1 + text_y, max_text_width, sw, sh);
            }
#ifdef  __MMI_CAT203_SUPPORT__            
            if (g_gui_list_get_underline)
            {
                S32 *underline_array;
                S32 underline_count = 0;
                underline_array = (S32*) applib_asm_alloc_anonymous(sizeof(S32) * MAX_SUB_MENU_SIZE);
                if (underline_array)
                {
                    memset(underline_array, 0, sizeof(S32) * MAX_SUB_MENU_SIZE);
                    if (MMI_fixed_list_menu.current_displayed_item == -1)
                    {
                        g_gui_list_get_underline(MMI_fixed_list_menu.highlighted_item, underline_array, &underline_count);
                    }
                    else
                    {
                        g_gui_list_get_underline(MMI_fixed_list_menu.current_displayed_item, underline_array, &underline_count);
                    }

                    applib_asm_free_anonymous(underline_array);
                    
                    /* print the text again for scrolling */
                    if (underline_count != 0)
                    {
                        if (!mmi_fe_get_r2l_state())
                        {
                            gui_move_text_cursor(x1 + text_x + m->text_width + UI_text_menuitem_scroll_gap, y1 + text_y);
                            gui_set_line_height(sh);
                            gui_list_show_text(m, mi, x1 + text_x + m->text_width + UI_text_menuitem_scroll_gap, y1 + text_y, max_text_width, sw, sh);
                        }
                        else
                        {
                            gui_move_text_cursor(x1 + text_x - (m->text_width + UI_text_menuitem_scroll_gap), y1 + text_y);
                            gui_set_line_height(sh);
                            gui_list_show_text(m, mi, x1 + text_x - (m->text_width + UI_text_menuitem_scroll_gap), y1 + text_y, max_text_width, sw, sh);
                        }
                    }
                }
            }
#endif  // __MMI_CAT203_SUPPORT__            
        }
    #ifdef __MMI_BI_DEGREE_MAIN_MENU_STYLE__
        else if (MMI_current_menu_type == LIST_MATRIX_MENU)
        {
            S32 text_available_width;
			S32 text_x1, text_horizontal_center_align_offset;
			s32	sw, sh;
            
			text_x1 = text_x;

			/*
			 * do horizontal alignment by moving the text start x coordinate
			 */
			gui_measure_string(_text, &sw, &sh);

			if (sw <= max_text_width)
			{
				text_horizontal_center_align_offset = (max_text_width - sw) / 2;

				if (mmi_fe_get_r2l_state())
				{
					text_x1 = text_x1 - text_horizontal_center_align_offset;
				}
				else
				{
					text_x1 = text_x1 + text_horizontal_center_align_offset;
				}
			}

			/* calculate string display width */
            if (mmi_fe_get_r2l_state())
            {
                /* right to left, text_x is the rightest x point of the string */
                text_available_width = text_x1 + 1;              
            }
            else
            {
                /* left to right, max_text_width = m->width for __MMI_BI_DEGREE_MAIN_MENU_STYLE__ */
                text_available_width = max_text_width - text_x1; 
            }

            /* 
             * [TODO] gui_print_truncated_text() does not do BIDI. In right to left languages,
             *        gui_print_truncated_text() will print left to right strings (such as English)
             *        in the right to left order.
             */             
            gui_print_truncated_text(x1 + text_x1, y1 + text_y, max_text_width, _text);
        }
    #endif /* __MMI_BI_DEGREE_MAIN_MENU_STYLE__ */ 
        else
        {
            /* 
             * Text is getting displayed behind the left button in case of Inline Selection
             * when the menu item is focussed. So remove the display of text when the item
             * is focussed and UI_MENUITEM_EXT_DISABLE_FOCUSSED_TEXT_DISPLAY flag is ON
             * for that item. 
             */
            if (!
                ((flags & UI_MENUITEM_STATE_FOCUSSED) &&
                 (mi->ext_flags & UI_MENUITEM_EXT_DISABLE_FOCUSSED_TEXT_DISPLAY)))
            {
                gui_list_show_text(m, mi, x1 + text_x, y1 + text_y, max_text_width, sw, sh);
            }
        }
        gui_pop_text_clip();
#ifdef __MMI_VECTOR_FONT_SUPPORT__
        gui_list_reset_alpha_blending_layer(old_alpha_layer);
#endif
    }

#ifdef __MMI_OP11_SIDEBAR__
    if (mi->ext_flags & UI_MENUITEM_EXT_SHOW_TIME)
    {
        in_show_fixed_list = MMI_TRUE;
		
        if ((flags & UI_MENUITEM_STATE_FOCUSSED) && !(flags & UI_MENUITEM_DISABLE_HIGHLIGHT))
        {
            wgui_clock_set_time_text_color(g_gui_list_clock, m->focussed_text_color);
        }
        else if (flags & UI_MENUITEM_STATE_DISABLED)
        {
            wgui_clock_set_time_text_color(g_gui_list_clock, m->disabled_text_color);
        }
        else if (flags & UI_MENUITEM_STATE_SELECTED)
        {
            wgui_clock_set_time_text_color(g_gui_list_clock, m->selected_text_color);
        }
        else
        {
            wgui_clock_set_time_text_color(g_gui_list_clock, m->normal_text_color);
        }  
        wgui_clock_show_clock(g_gui_list_clock);
        in_show_fixed_list = MMI_FALSE;
    }
#endif /* __LOW_COST_PROJECT__ */

    if (flags & UI_MENUITEM_DOTTED_UNDERLINE)
    {
        static const U8 dotted_line_bitvalues[] = {1, 1, 1, 1, 0, 0, 0};
        S32 r = max_text_width % 7; /* pattern width */

        if (r == 0)
        {
            r = 7;
        }
        gdi_draw_line_style(
            m->text_x,
            y2,
            m->text_x + max_text_width - 1 - r,
            y2,
            gdi_act_color_from_rgb(255, 112, 125, 240),
            sizeof(dotted_line_bitvalues),
            dotted_line_bitvalues);
    }
    
    if (ret_flag_ext & UI_MENUITEM_EXT_SHOW_SEPARATORLINE || mi->ext_flags & UI_MENUITEM_EXT_SHOW_SEPARATORLINE)
    {
        gui_draw_horizontal_line(x1, x2, y1, *(current_MMI_theme->list_grid_line_color));//list_separator_color
    }
    else if (ret_flag_ext & UI_MENUITEM_EXT_SHOW_DOWN_SEPARATORLINE || mi->ext_flags & UI_MENUITEM_EXT_SHOW_DOWN_SEPARATORLINE)
    {
        gui_draw_horizontal_line(x1, x2, y2, *(current_MMI_theme->list_grid_line_color));//list_separator_color
    }
#if defined(__MMI_OP11_HOMESCREEN_0301__) || defined(__MMI_OP11_HOMESCREEN_0302__)
    else if (ret_flag_ext & UI_MENUITEM_EXT_SHOW_DOWN_SHORT_SEPARATORLINE || mi->ext_flags & UI_MENUITEM_EXT_SHOW_DOWN_SHORT_SEPARATORLINE)
    {
        gui_draw_horizontal_line(x1, x + m->text_x, y2, *(current_MMI_theme->list_grid_line_color));//list_separator_color
    }
#endif  // defined(__MMI_OP11_HOMESCREEN_0301__) || defined(__MMI_OP11_HOMESCREEN_0302__)

    if (m->post_display_function)
    {
        m->post_display_function(item, common_item_data, x, y);
    }
    gui_pop_clip();

    if (mi->ext_flags & UI_MENUITEM_EXT_SHOW_INDICATOR)
    {	
		MMI_fixed_list_menu.item_indicator_display_callback(MMI_fixed_list_menu.default_inline_item, i_x, i_y);   
    }

#if(UI_ENABLE_POP_UP_DESCRIPTIONS)
    if ((flags & UI_MENUITEM_STATE_FOCUSSED) && !(m->ext_flags & UI_MENUITEM_EXT_SHOW_IN_MARQUEE) && 
	!(flags & UI_MENUITEM_DISABLE_HIGHLIGHT) &&
        m->parent_list &&
	m->parent_list->gui_display_pop_up_description)
    {
    #ifdef __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__
        /* pass the modified parameters in the function so that there is proper gapping
           between the menu items. */
        if (mi->ext_flags & UI_MENUITEM_EXT_SHOW_IN_ROUNDED_RECT)
        {
            m->parent_list->gui_display_pop_up_description(x, y + 1, m->width, ((m->height - 1) - 1));
        }
        else
    #endif /* __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__ */ 
        {
            m->parent_list->gui_display_pop_up_description(x, y, m->width, m->height);
        }
    }
#endif /* (UI_ENABLE_POP_UP_DESCRIPTIONS) */ 

#ifdef __MMI_SUPPORT_DUMP_SCREEN_STRING__
    mmi_frm_dss_set_menu_highlight(MMI_SCREEN_HIGHLIGHT_NONE);
#endif
    if (!(flags & UI_MENUITEM_DISABLE_TEXT_DISPLAY))
    {
        if (flags & UI_MENUITEM_CENTER_TEXT_X)
        {
            m->text_x = old_text_x;
        }
        if (flags & UI_MENUITEM_CENTER_TEXT_Y)
        {
            m->text_y = old_text_y;
        }
    }
    
    /* calculate the icon position */
    if (_icon != UI_NULL_IMAGE)
    {
        if (flags & UI_MENUITEM_CENTER_ICON_X)
        {
            m->icon_x = old_icon_x;
        }
        if (flags & UI_MENUITEM_CENTER_ICON_Y)
        {
            m->icon_y = old_icon_y;
        }
        if (flags & UI_MENUITEM_ICON_CENTER_JUSTIFY)
        {
            m->icon_x = old_icon_x;
        }
    }
}


#ifdef __MMI_TOUCH_SCREEN__

/*****************************************************************************
 * FUNCTION
 *  gui_fixed_icontext_menuitem_translate_pen_event
 * DESCRIPTION
 *  Pen event handler of the icontext menu item.
 * PARAMETERS
 *  item                    [IN]        private icontext menu item
 *  common_item_data        [IN]        common icontext menu item
 *  item_x                  [IN]        item x1
 *  item_y                  [IN]        item y1
 *  pen_event               [IN]        pen event type
 *  x                       [IN]        pen x
 *  y                       [IN]        pen y
 *  menuitem_event          [OUT]       pen event result
 *  menuitem_param          [IN]        pen event parameter
 * RETURNS
 *  Return MMI_TRUE if the pen event is handled; otherwise, MMI_FALSE. 
 *****************************************************************************/
#if (defined __MMI_UI_TWO_LINE_MENUITEM_STYLES__)
extern wgui_get_display_style get_current_menu_item_displaystyle;
extern wgui_horizontal_select_menuitem_struct two_line_horizontal_select_menuitem;
#endif
BOOL gui_fixed_icontext_menuitem_translate_pen_event(
        void *item,
        void *common_item_data,
        S32 item_x,
        S32 item_y,
        mmi_pen_event_type_enum pen_event,
        S16 x,
        S16 y,
        gui_list_pen_enum *menuitem_event,
        gui_pen_event_param_struct *menuitem_param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 flags = 0;

#ifndef __MMI_FTE_SUPPORT__
    fixed_icontext_menuitem *m = (fixed_icontext_menuitem*) common_item_data;

    gui_menuitem_icontext_checkbox_struct checkbox;
    S32 is_pen_in_checkbox;

#endif  // ifndef   __MMI_FTE_SUPPORT__    
#ifdef __MMI_UI_TWO_LINE_MENUITEM_STYLES__
    gui_list_pen_enum old_event;
#endif
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (item)
    {
        flags |= ((fixed_icontext_menuitem_type*) item)->ext_flags;
    }

    *menuitem_event = GUI_LIST_PEN_NONE;

#ifndef __MMI_FTE_SUPPORT__

    if (m->ext_flags & UI_MENUITEM_EXT_SHOW_ICONTEXT_CHECKBOX)
    {       
        gui_menuitem_icontext_checkbox_get_data(&checkbox, m, item_x, item_y);
#if defined(__MMI_UI_HINTS_IN_MENUITEM__) || defined(__MMI_UI_TWO_LINE_MENUITEM_STYLES__)
        is_pen_in_checkbox = PEN_CHECK_BOUND(x, y, checkbox.x, checkbox.y, checkbox.image_width, checkbox.image_height) || 
                             ((menuitem_param->i2 == GUI_LIST_PEN_HIGHLIGHT_CHANGED) && 
                              PEN_CHECK_BOUND(x, y, checkbox.x, checkbox.y + m->height, checkbox.image_width, checkbox.image_height));
#else /* defined(__MMI_UI_HINTS_IN_MENUITEM__) || defined(__MMI_UI_TWO_LINE_MENUITEM_STYLES__) */
        is_pen_in_checkbox = PEN_CHECK_BOUND(x, y, checkbox.x, checkbox.y, checkbox.image_width, checkbox.image_height);
#endif /* defined(__MMI_UI_HINTS_IN_MENUITEM__) || defined(__MMI_UI_TWO_LINE_MENUITEM_STYLES__) */

        if (pen_event == MMI_PEN_EVENT_DOWN)
        {
            if (is_pen_in_checkbox)
            {            
                *menuitem_event = GUI_LIST_PEN_DOWN_ON_STATE_BOX;
            }
            else
            {
                *menuitem_event = GUI_LIST_PEN_NONE;
            }
            
            return MMI_TRUE;
        }
        else if (pen_event == MMI_PEN_EVENT_UP)
        {
            if (m->checkbox_clicked_callback(menuitem_param->_u.i) == MMI_TRUE)
            {                    
                *menuitem_event = GUI_LIST_PEN_NEED_REDRAW;
            }
            else
            {
                *menuitem_event = GUI_LIST_PEN_NONE;
            }
            
            return MMI_TRUE;
        }            
    }
#endif  // #ifndef  __MMI_FTE_SUPPORT__
    

#ifdef __MMI_UI_TWO_LINE_MENUITEM_STYLES__
    /* FIXME: do not check pen up/down here */
    if( ( pen_event == MMI_PEN_EVENT_UP || pen_event == MMI_PEN_EVENT_DOWN || 
        pen_event == MMI_PEN_EVENT_MOVE) && gui_get_two_line_menuitem_height())
    {
        old_event = two_line_horizontal_select_menuitem.menuitem_current_event;
	    mmi_two_line_translate_pen_event(x, y, pen_event, menuitem_event);
        if (pen_event == MMI_PEN_EVENT_DOWN)
            two_line_horizontal_select_menuitem.menuitem_down_event = *menuitem_event;
        
        if (get_current_menu_item_displaystyle(MMI_fixed_list_menu.highlighted_item) ==
            TWO_LINE_MENUITEM_STYLE_DISPLAY_HORIZONTAL_SELECT)
        {
            two_line_horizontal_select_menuitem.menuitem_current_event = *menuitem_event;
            if (old_event != *menuitem_event)
            {
                if (*menuitem_event == GUI_LIST_PEN_NONE || (*menuitem_event != GUI_LIST_PEN_NONE && 
                    two_line_horizontal_select_menuitem.menuitem_down_event == *menuitem_event))
                {	
                    if (get_current_menu_item_displaystyle)
                    {
                        wgui_show_two_line_horizontal_select();
                        gui_BLT_double_buffer(
                            two_line_horizontal_select_menuitem.x,
                            two_line_horizontal_select_menuitem.y,
                            two_line_horizontal_select_menuitem.x + two_line_horizontal_select_menuitem.width - 1,
                            two_line_horizontal_select_menuitem.y + two_line_horizontal_select_menuitem.height - 1);
                    }
                }
            }
            if (pen_event == MMI_PEN_EVENT_UP)
                two_line_horizontal_select_menuitem.menuitem_current_event = GUI_LIST_PEN_NONE;
        }
        if (*menuitem_event == GUI_LIST_PEN_TWO_LINE_NEXT || *menuitem_event == GUI_LIST_PEN_TWO_LINE_PREVIOUS)
        {
            if (pen_event == MMI_PEN_EVENT_DOWN || pen_event == MMI_PEN_EVENT_MOVE)
            {
                *menuitem_event = GUI_LIST_PEN_NONE;
            }
            else if (*menuitem_event != two_line_horizontal_select_menuitem.menuitem_down_event)
            {
                *menuitem_event = GUI_LIST_PEN_NONE;
            }
            return MMI_TRUE;
        }
    }
#endif /* __MMI_UI_TWO_LINE_MENUITEM_STYLES__ */

    GUI_PEN_EVENT_PARAM_SET_VOID(menuitem_param);

    if (flags & UI_MENUITEM_PEN_USE_LONGPRESS)
    {
        if (gui_pen_wait_longpress(pen_event, x, y) == GUI_WAIT_LONGPRESS_READY)
        {
            *menuitem_event = GUI_LIST_PEN_ITEM_SELECTED;
        }
        return MMI_TRUE;
    }
    else
    {
        return MMI_FALSE;
    }
}



/*****************************************************************************
 * FUNCTION
 *  gui_fixed_icontext_list_menuitem_translate_pen_event
 * DESCRIPTION
 *  Pen event handler of the icontext list menu item.
 * PARAMETERS
 *  item                    [IN]        private icontext menu item
 *  common_item_data        [IN]        common icontext menu item
 *  item_x                  [IN]        item x1
 *  item_y                  [IN]        item y1
 *  pen_event               [IN]        pen event type
 *  x                       [IN]        pen x
 *  y                       [IN]        pen y
 *  menuitem_event          [OUT]       pen event result
 *  menuitem_param          [IN]        pen event parameter
 * RETURNS
 *  Return MMI_TRUE if the pen event is handled; otherwise, MMI_FALSE. 
 *****************************************************************************/
BOOL gui_fixed_icontext_list_menuitem_translate_pen_event(
        void *item,
        void *common_item_data,
        S32 item_x,
        S32 item_y,
        mmi_pen_event_type_enum pen_event,
        S16 x,
        S16 y,
        gui_list_pen_enum *menuitem_event,
        gui_pen_event_param_struct *menuitem_param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 flags = 0;

#ifndef __MMI_FTE_SUPPORT__
    fixed_icontext_list_menuitem *m = (fixed_icontext_list_menuitem*) common_item_data;

    gui_menuitem_icontext_checkbox_struct checkbox;
    S32 checkbox_x, checkbox_y;
    S32 iwidth, iheight;
    S32 is_pen_in_checkbox;

    S32 item_index;
#endif  // #ifndef  __MMI_FTE_SUPPORT__

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (item)
    {
        flags |= ((fixed_icontext_list_menuitem_type*) item)->ext_flags;
    }

    *menuitem_event = GUI_LIST_PEN_NONE;

#ifndef __MMI_FTE_SUPPORT__
    item_index = menuitem_param->_u.i;

    if (m->ext_flags & UI_MENUITEM_EXT_SHOW_ICONTEXT_CHECKBOX)
    {       
        gui_menuitem_icontext_list_checkbox_get_data(&checkbox, m, item_x, item_y);
        checkbox_x = checkbox.x;
        checkbox_y = checkbox.y;
        iwidth = checkbox.image_width;
        iheight = checkbox.image_height;
    
    #if defined(__MMI_UI_HINTS_IN_MENUITEM__) || defined(__MMI_UI_TWO_LINE_MENUITEM_STYLES__)
        is_pen_in_checkbox = PEN_CHECK_BOUND(x, y, checkbox_x, checkbox_y, iwidth, iheight) || 
                             ((menuitem_param->i2 == GUI_LIST_PEN_HIGHLIGHT_CHANGED) && 
                              PEN_CHECK_BOUND(x, y, checkbox_x, checkbox_y + m->height, iwidth, iheight));
    #else /* defined(__MMI_UI_HINTS_IN_MENUITEM__) || defined(__MMI_UI_TWO_LINE_MENUITEM_STYLES__) */
        is_pen_in_checkbox = PEN_CHECK_BOUND(x, y, checkbox_x, checkbox_y, iwidth, iheight);
    #endif /* defined(__MMI_UI_HINTS_IN_MENUITEM__) || defined(__MMI_UI_TWO_LINE_MENUITEM_STYLES__) */

        //if (is_pen_in_checkbox)
        {            
            if (pen_event == MMI_PEN_EVENT_DOWN)
            {
                if (is_pen_in_checkbox)
                {            
                    *menuitem_event = GUI_LIST_PEN_DOWN_ON_STATE_BOX;
                }
                else
                {
                    *menuitem_event = GUI_LIST_PEN_NONE;
                }
                
                return MMI_TRUE;
            }
            else if (pen_event == MMI_PEN_EVENT_UP)
            {
                if (m->checkbox_clicked_callback(item_index) == MMI_TRUE)
                {                    
                    *menuitem_event = GUI_LIST_PEN_NEED_REDRAW;
                }
                else
                {
                    *menuitem_event = GUI_LIST_PEN_NONE;
                }
                
                return MMI_TRUE;
            }            
        }        
    }
#endif  // #ifndef  __MMI_FTE_SUPPORT__
    

#ifdef __MMI_UI_TWO_LINE_MENUITEM_STYLES__
    /* FIXME: do not check pen up/down here */
    if( ( pen_event == MMI_PEN_EVENT_UP || pen_event == MMI_PEN_EVENT_DOWN ) && gui_get_two_line_menuitem_height())
    {
	    mmi_two_line_translate_pen_event(x, y, pen_event, menuitem_event);
        
        if (*menuitem_event == GUI_LIST_PEN_TWO_LINE_NEXT || *menuitem_event == GUI_LIST_PEN_TWO_LINE_PREVIOUS)
        {
            if (pen_event == MMI_PEN_EVENT_DOWN)
            {
                *menuitem_event = GUI_LIST_PEN_NONE;
            }
            return MMI_TRUE;
        }
    }
#endif /* __MMI_UI_TWO_LINE_MENUITEM_STYLES__ */

    GUI_PEN_EVENT_PARAM_SET_VOID(menuitem_param);

    if (flags & UI_MENUITEM_PEN_USE_LONGPRESS)
    {
        if (gui_pen_wait_longpress(pen_event, x, y) == GUI_WAIT_LONGPRESS_READY)
        {
            *menuitem_event = GUI_LIST_PEN_ITEM_SELECTED;
        }
        return MMI_TRUE;
    }
    else
    {
        return MMI_FALSE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  gui_fixed_icontext_list_menuitem_is_pen_in_checkbox
 * DESCRIPTION
 *  
 * PARAMETERS
 *  item                    [IN]        private icontext menu item object
 *  common_item_data        [IN]        common icontext menu item object
 *  x                       [IN]        x
 *  y                       [IN]        y   
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL gui_fixed_icontext_list_menuitem_is_pen_in_checkbox(
        void *item,
        void *common_item_data,
        S32 item_x,
        S32 item_y,
        S16 x,
        S16 y)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    fixed_icontext_list_menuitem *m = (fixed_icontext_list_menuitem*) common_item_data;
    gui_menuitem_icontext_checkbox_struct checkbox;
    S32 checkbox_x, checkbox_y;
    S32 iwidth, iheight;
    MMI_BOOL is_pen_in_checkbox = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (m->ext_flags & UI_MENUITEM_EXT_SHOW_ICONTEXT_CHECKBOX)
    {
        gui_menuitem_icontext_list_checkbox_get_data(&checkbox, m, item_x, item_y);
        checkbox_x = checkbox.x;
        checkbox_y = checkbox.y;
        iwidth = checkbox.image_width;
        iheight = checkbox.image_height;
    
        is_pen_in_checkbox = (MMI_BOOL)PEN_CHECK_BOUND(x, y, checkbox_x, checkbox_y, iwidth, iheight);
    }

    return is_pen_in_checkbox;
}

#endif /* __MMI_TOUCH_SCREEN__ */ 

#ifndef __MMI_UI_MENU_SLIM__
/*****************************************************************************
 * FUNCTION
 *  gui_hide_fixed_icontext_menuitem
 * DESCRIPTION
 *  Hide an icontext menu item.
 * PARAMETERS
 *  item                    [IN]        private icontext menu item object
 *  common_item_data        [IN]        common icontext menu item object
 *  x                       [IN]        x
 *  y                       [IN]        y   
 * RETURNS
 *  void
 *****************************************************************************/
void gui_hide_fixed_icontext_menuitem(void *item, void *common_item_data, S32 x, S32 y)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x1, y1, x2, y2;
    UI_filled_area *f;
    fixed_icontext_menuitem *m = (fixed_icontext_menuitem*) common_item_data;
    fixed_icontext_menuitem_type *mi = (fixed_icontext_menuitem_type*) item;
    U32 flags;
    PU8 _icon;
    gdi_handle old_alpha_layer;
    S32 icon_width = 0, icon_height = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    flags = mi->flags;
    flags |= m->flags;
    _icon = mi->item_icon;

    gui_measure_image(_icon, &icon_width, &icon_height);
    /* Autocalculate the icon position */
    if (_icon != UI_NULL_IMAGE)
    {
        if (flags & UI_MENUITEM_CENTER_ICON_X)
        {
            m->icon_x = (m->width >> 1) - (icon_width >> 1);
        }
        if (flags & UI_MENUITEM_CENTER_ICON_Y)
        {
            m->icon_y = (m->height >> 1) - (icon_height >> 1);
        }
    }

    x1 = x;
    y1 = y;
    x2 = x1 + m->width - 1;
    y2 = y1 + m->height - 1;

    if ((flags & UI_MENUITEM_STATE_FOCUSSED) && !(flags & UI_MENUITEM_DISABLE_HIGHLIGHT))
    {
        f = gui_list_get_focussed_filler((gui_common_menuitem_base_struct*) m);
    }
    else if (flags & UI_MENUITEM_STATE_DISABLED)
    {
        f = m->disabled_filler;
    }
    else if (flags & UI_MENUITEM_STATE_SELECTED)
    {
        f = m->selected_filler;
    }
    else
    {
        f = m->normal_filler;
    }
    gui_set_clip(x1, y1, x2, y2);
    gui_push_and_set_clip(m->icon_x + x1, m->icon_y + y1, m->icon_x + x1 + icon_width - 1, m->icon_y + y1 + icon_height - 1);

    old_alpha_layer = gui_list_set_alpha_blending_layer();
    gui_draw_filled_area(x1, y1, x2, y2, f);
    gui_list_reset_alpha_blending_layer(old_alpha_layer);
    gui_pop_clip();
}
#endif

/*****************************************************************************
 * FUNCTION
 *  gui_measure_fixed_icontext_menuitem
 * DESCRIPTION
 *  Measure an icontext menu item for dimension.
 * PARAMETERS
 *  item                    [IN]        private icontext menu item object
 *  common_item_data        [IN]        common icontext menu item object
 *  width                   [OUT]       item width
 *  height                  [OUT]       item height     
 * RETURNS
 *  void
 *****************************************************************************/
void gui_measure_fixed_icontext_menuitem(void *item, void *common_item_data, S32 *width, S32 *height)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    fixed_icontext_menuitem *t = (fixed_icontext_menuitem*) common_item_data;
    fixed_icontext_menuitem_type *mi = (fixed_icontext_menuitem_type*) item;
#ifdef __MMI_UI_HINTS_IN_MENUITEM__
	UI_string_type curr_hint_string = NULL;
#endif
#ifdef __MMI_FTE_SUPPORT__
    U32 index;
#else
  #if defined(__MMI_INSCREEN_MULTILINE_TEXTBOX__)
  #if defined( __MMI_INLINE_ITEM_MULTILINE_READ_ONLY__) || defined( __MMI_INLINE_ITEM_MULTILINE_EDIT__)
    U32 index;
  #endif
  #endif
#endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(item);
    *width = t->width;
    *height = t->height;

#ifdef __MMI_UI_TWO_LINE_MENUITEM_STYLES__
    // TODO: configure UI_MENUITEM_EXT_SHOW_TWO_LINE_SELECT in other place
    if (MMI_fixed_list_menu.current_displayed_item == -1 && gui_get_two_line_menuitem_height())
    {
        *height = *height << 1;
        t->ext_flags |= UI_MENUITEM_EXT_SHOW_TWO_LINE_SELECT;
        t->ext_flags |= UI_MENUITEM_EXT_CONTAIN_TWO_LINE_MENU_ITEM;
        return;
    }
    else
    {
        t->ext_flags &= ~UI_MENUITEM_EXT_SHOW_TWO_LINE_SELECT;
    }
#endif /* __MMI_UI_TWO_LINE_MENUITEM_STYLES__ */ 

#ifdef __MMI_UI_HINTS_IN_MENUITEM__
    if (t->parent_list && t->parent_list->gui_get_current_pop_up_description_string)
    {
  	    curr_hint_string = t->parent_list->gui_get_current_pop_up_description_string();
    }
    if (curr_hint_string && mmi_ucs2strlen((CHAR *)curr_hint_string))
    {
        if ((t->ext_flags & UI_MENUITEM_SHOW_HIGHLIGHTED_HINT) && 
            MMI_fixed_list_menu.current_displayed_item == -1 && !(t->flags & UI_MENUITEM_DISABLE_HIGHLIGHT))
        {
            *height = (*height) << 1;
            t->ext_flags |= UI_MENUITEM_EXT_CONTAIN_TWO_LINE_MENU_ITEM;
        }
        else if (t->ext_flags & UI_MENUITEM_SHOW_ALL_HINTS)
        {
            *height = (*height) << 1;
            t->ext_flags |= UI_MENUITEM_EXT_CONTAIN_TWO_LINE_MENU_ITEM;
        }    
    }       
#endif /* __MMI_UI_HINTS_IN_MENUITEM__ */ 

        if (mi && mi->flags & UI_MENUITEM_INLINE_EDIT_OBJECT)
        {
#ifdef __MMI_FTE_SUPPORT__
            if (MMI_fixed_list_menu.current_displayed_item == -1)
	        {
                index = MMI_fixed_list_menu.highlighted_item;
            }
            else
            {
                index = MMI_fixed_list_menu.current_displayed_item;
            }
            *height = wgui_get_inline_item_height(index);
#else /* __MMI_FTE_SUPPORT__ */
#if defined(__MMI_INSCREEN_MULTILINE_TEXTBOX__)
#if defined( __MMI_INLINE_ITEM_MULTILINE_READ_ONLY__) || defined( __MMI_INLINE_ITEM_MULTILINE_EDIT__)
            if (MMI_fixed_list_menu.current_displayed_item == -1)
	        {
                index = MMI_fixed_list_menu.highlighted_item;
            }
            else
            {
                index = MMI_fixed_list_menu.current_displayed_item;
            }
            if (((wgui_inline_items[index].flags & 0xFF) == INLINE_ITEM_TYPE_MULTI_LINE_EDIT) ||
                ((wgui_inline_items[index].flags & 0xFF) == INLINE_ITEM_TYPE_MULTI_LINE_RD_ONLY))
            {
                *height = wgui_get_inline_item_height(index);
            }
#endif
#endif
#endif /* __MMI_FTE_SUPPORT__ */ 
        }
	
}


/*****************************************************************************
 * FUNCTION
 *  gui_highlight_fixed_icontext_menuitem
 * DESCRIPTION
 *  Highlight a text menu item (not visually).
 * PARAMETERS
 *  item                    [IN]        private icontext menu item object
 *  common_item_data        [IN]        common icontext menu item object           
 * RETURNS
 *  void
 *****************************************************************************/
void gui_highlight_fixed_icontext_menuitem(void *item, void *common_item_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    fixed_icontext_menuitem_type *t = (fixed_icontext_menuitem_type*)item;
    fixed_icontext_menuitem *m = (fixed_icontext_menuitem*)common_item_data;
    U32 flags;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    flags = m->flags;
    flags |= t->flags;
    GUI_current_fixed_icontext_menuitem_common_data = m;
    GUI_current_fixed_icontext_menuitem_data = t;

    t->text_width = 0;
    t->text_height = 0;
#ifdef __MMI_UI_TWO_LINE_MENUITEM_STYLES__
    gui_set_current_two_line_menuitem_data();
#endif 

    if (m->ext_flags & UI_MENUITEM_EXT_DISABLED_SCROLL)
    {
        GUI_current_fixed_icontext_menuitem_scroll = 0;
        m->scroll_x = 0;
    }
    gui_fixed_icontext_menuitem_stop_scroll();

#ifdef __MMI_UI_HINTS_IN_MENUITEM__
    /* do not need to resize here, since measure menuitem already changes the height */
    // gui_resize_fixed_icontext_menuitem(m, m->width, m->height);
    
    if (MMI_current_menu_type == LIST_MATRIX_MENU)
    {
        m->scroll_width = m->width - m->text_x;
    }
#endif /* __MMI_UI_HINTS_IN_MENUITEM__ */ 

    if (!(m->ext_flags & UI_MENUITEM_EXT_DISABLED_SCROLL))
    {
        gui_fixed_icontext_menuitem_start_scroll();
    }
    if (t->flags & UI_MENUITEM_DISABLE_HIGHLIGHT)
    {
        return;
    }
    t->flags |= UI_MENUITEM_STATE_FOCUSSED;
    t->flags |= UI_MENUITEM_STATE_ANIMATE;

#ifdef __IV_TTS__
	if(NPR_TTS_get_menu_read_enble())
	NPR_TTS_menu_read(t->item_text );
#endif
}


/*****************************************************************************
 * FUNCTION
 *  gui_remove_highlight_fixed_icontext_menuitem
 * DESCRIPTION
 *  Remove the highlight of an icontext menu item (not visually).
 * PARAMETERS
 *  item                    [IN]        private icontext menu item object
 *  common_item_data        [IN]        common icontext menu item object  
 * RETURNS
 *  void
 *****************************************************************************/
#if (defined __MMI_UI_TWO_LINE_MENUITEM_STYLES__ || defined __MMI_UI_HINTS_IN_MENUITEM__)
static scrolling_text gui_two_line_scroll_text;
#endif 
void gui_remove_highlight_fixed_icontext_menuitem(void *item, void *common_item_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    fixed_icontext_menuitem_type *t = (fixed_icontext_menuitem_type*) item;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    t->text_width = 0;
    t->text_height = 0;
#if (defined __MMI_UI_TWO_LINE_MENUITEM_STYLES__ || defined __MMI_UI_HINTS_IN_MENUITEM__)
    gui_scrolling_text_stop(&gui_two_line_scroll_text);
#endif 
    gui_fixed_icontext_menuitem_stop_scroll();

    UI_UNUSED_PARAMETER(common_item_data);
    t->flags &= ~UI_MENUITEM_STATE_FOCUSSED;
#if (defined __MMI_UI_TWO_LINE_MENUITEM_STYLES__ || defined __MMI_UI_HINTS_IN_MENUITEM__)
    gui_reset_current_two_line_menuitem_data();
#endif 
    t->flags &= ~UI_MENUITEM_STATE_ANIMATE;
    if (t->item_icon_handle != GDI_ERROR_HANDLE)
    {
        gdi_image_stop_animation(t->item_icon_handle);
        t->item_icon_handle = GDI_ERROR_HANDLE;
    }
#ifdef __MMI_UI_HINT_TOGGLE_TRANSITION__
    gui_reset_pop_up_description_transition_ex(&wgui_pop_up_description);
#endif 
}


/*****************************************************************************
 *
 * ICONTEXT LIST MENUITEM                                                             
 *                                                                           
 *                                   
 *
 *****************************************************************************/

/*****************************************************************************
 * FUNCTION
 *  gui_set_fixed_icontext_list_menuitem_current_theme
 * DESCRIPTION
 *  Apply the current theme to a common icontext list menu item.
 * PARAMETERS
 *  m           [IN]        common icontext list menu item object
 * RETURNS
 *  void
 *****************************************************************************/
void gui_set_fixed_icontext_list_menuitem_current_theme(fixed_icontext_list_menuitem *m)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_set_fixed_icontext_list_menuitem_theme(m, current_fixed_icontext_list_menuitem_theme);
}


/*****************************************************************************
 * FUNCTION
 *  gui_set_fixed_icontext_list_menuitem_theme
 * DESCRIPTION
 *  Apply the given theme to a common icontext list menu item.
 * PARAMETERS
 *  m           [IN]        common icontext list menu item object
 *  t           [IN]        icontext list menu item theme
 * RETURNS
 *  void
 *****************************************************************************/
void gui_set_fixed_icontext_list_menuitem_theme(
        fixed_icontext_list_menuitem *m,
        UI_fixed_icontext_list_menuitem_theme *t)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    m->disabled_filler = t->disabled_filler;
    m->flags |= t->flags;
    m->focussed_filler = t->focussed_filler;
    if (t->focussed_without_sc_filler)
    {
        m->focussed_without_sc_filler = t->focussed_without_sc_filler;
    }
    else
    {
        m->focussed_without_sc_filler = t->focussed_filler;
    }
#ifdef __MMI_UI_TRANSPARENT_EFFECT__
    if (m->focussed_filler &&
        (m->focussed_filler->flags & 0xFF) != UI_FILLED_AREA_TYPE_BITMAP &&
        (m->focussed_filler->flags & 0xFF) != UI_FILLED_AREA_TYPE_IMAGE_RIGHT_ALIGN &&
        (m->focussed_filler->flags & 0xFF) != UI_FILLED_AREA_TYPE_IMAGE_LEFT_ALIGN)
    {
        fixed_icontext_list_menuitem_transparent_filled_area = *(m->focussed_filler);
        m->focussed_filler = &fixed_icontext_list_menuitem_transparent_filled_area;
        fixed_icontext_list_menuitem_transparent_filled_area.flags |= UI_FILLED_AREA_TYPE_TRANSPARENT_COLOR;
        fixed_icontext_list_menuitem_transparent_filled_area.c.alpha = HIGHLIGHTER_COLOR_OPACITY_VALUE;
    }
#endif /* __MMI_UI_TRANSPARENT_EFFECT__ */ 
    m->normal_filler = t->normal_filler;
    m->selected_filler = t->selected_filler;
    for (i = 0; i < m->n_text_columns; i++)
    {
        m->normal_text_colors[i] = t->normal_text_colors[i];
        m->focussed_text_colors[i] = t->focussed_text_colors[i];
        m->selected_text_colors[i] = t->selected_text_colors[i];
        m->disabled_text_colors[i] = t->disabled_text_colors[i];
        m->text_fonts[i] = t->text_fonts[i];
        m->selected_fonts[i] = NULL;
    }
}


/*****************************************************************************
 * FUNCTION
 *  gui_create_fixed_icontext_list_menuitem
 * DESCRIPTION
 *  Create a common icontext list menu item.
 * PARAMETERS
 *  m               [IN]        common icontext list menu item object
 *  width           [IN]        width
 *  height          [IN]        height
 *  n_text_columns  [IN]        number of text columns
 *  n_icon_columns  [IN]        number of icon columns
 * RETURNS
 *  void
 *****************************************************************************/
void gui_create_fixed_icontext_list_menuitem(
        fixed_icontext_list_menuitem *m,
        S32 width,
        S32 height,
        S32 n_text_columns,
        S32 n_icon_columns)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	memset(m, 0, sizeof(fixed_icontext_list_menuitem));
    m->width = width;
    m->height = height;
    if (n_icon_columns > FIXED_ICONTEXT_LIST_MAX_ICON_COLUMNS)
    {
        n_icon_columns = FIXED_ICONTEXT_LIST_MAX_ICON_COLUMNS;
    }
    if (n_text_columns > FIXED_ICONTEXT_LIST_MAX_TEXT_COLUMNS)
    {
        n_text_columns = FIXED_ICONTEXT_LIST_MAX_TEXT_COLUMNS;
    }
    m->n_icon_columns = n_icon_columns;
    m->n_text_columns = n_text_columns;
    gui_set_fixed_icontext_list_menuitem_current_theme(m);
    m->scroll_width = width;
    m->checkbox_clicked_callback = gui_menuitem_dummy_checkbox_clicked_callback;
    m->checkbox_get_image_callback = gui_menuitem_dummy_checkbox_get_image_callback; 
}


/*****************************************************************************
 * FUNCTION
 *  gui_fixed_icontext_list_menuitem_set_post_display
 * DESCRIPTION
 *  Set the post-display callback function for the icontext list menu item.
 * PARAMETERS
 *  m                       [IN]        common icontext list menu item object       
 *  post_display_function   [IN]        post-display callback function
 * RETURNS
 *  void
 *****************************************************************************/
void gui_fixed_icontext_list_menuitem_set_post_display(
        fixed_icontext_list_menuitem *m,
        void (*post_display_function) (void *item, void *common_item_data, S32 x, S32 y))
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    m->post_display_function = post_display_function;
}


/*****************************************************************************
 * FUNCTION
 *  gui_fixed_icontext_list_menuitem_set_post_display
 * DESCRIPTION
 *  Set the post-display callback function for the icontext list menu item.
 * PARAMETERS
 *  m                       [IN]        common icontext list menu item object       
 *  post_display_function   [IN]        post-display callback function
 * RETURNS
 *  void
 *****************************************************************************/
void gui_fixed_icontext_menuitem_set_post_display(
        fixed_icontext_menuitem *m,
        void (*post_display_function) (void *item, void *common_item_data, S32 x, S32 y))
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    m->post_display_function = post_display_function;
}


/*****************************************************************************
 * FUNCTION
 *  gui_fixed_icontext_list_menuitem_scroll_handler
 * DESCRIPTION
 *  Scroll handler of the highlighted icontext list menu item.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gui_fixed_icontext_list_menuitem_scroll_handler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 flags = GUI_current_fixed_icontext_list_menuitem_common_data->flags;
    S32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
#ifdef  __MMI_UI_LIST_FLASH_HIGHLIGHT_EFFECTS__
    /* If the flash feeling list effect is running, wait for it to finish. */
    if ((gui_get_current_list_effect() == MMI_UI_LIST_HIGHLIGHT_EFFECT_FLASH_FEELING) &&
        (MMI_current_menu_type == LIST_MENU) &&
        (g_flash_feel_state != GUI_LIST_EFFECT_FLASH_FEELING_STOP))        
    {         
        return;
    }
#endif  /* __MMI_UI_LIST_FLASH_HIGHLIGHT_EFFECTS__ */    
#endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */    
#ifndef __MMI_UI_MENU_SLIM__
    gui_list_in_scroll = MMI_TRUE;
#endif
    flags |= GUI_current_fixed_icontext_list_menuitem_data->flags;
    GUI_current_fixed_icontext_list_menuitem_common_data->ext_flags |= UI_MENUITEM_EXT_SHOW_IN_MARQUEE;
#ifdef __MMI_UI_TRANSPARENT_EFFECT__
    if (!gui_is_current_transparency_with_multi_layer())
    {
        gui_fixed_icontext_list_disable_transparent_effect(GUI_current_fixed_icontext_list_menuitem_common_data);   /* To hide text below scrolling text */
    }
#endif /* __MMI_UI_TRANSPARENT_EFFECT__ */ 
#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
   /*
    * Disable the list effect for showing the highlighted menu item later.
    * When scrolling, no list effect is allowed. e.g., HIGHLIGHT_EFFECT_FLASH_FEELING.
    */
    gui_reset_current_list_effect();
#endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */

    for (i = 0; i < MMI_fixed_icontext_list_menuitem.n_text_columns; i++)
    {
        if (GUI_current_fixed_icontext_list_menuitem_text_is_scroll[i])
        {
            gui_handle_scrolling_text(&gui_current_scroll_text[i]);
        }
    }
#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
    /* restore list effect */
    gui_restore_current_list_effect();
#endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */

#ifdef __MMI_UI_TRANSPARENT_EFFECT__
    gui_fixed_icontext_list_enable_transparent_effect(GUI_current_fixed_icontext_list_menuitem_common_data);        /* To enable transparency */
#endif 

    GUI_current_fixed_icontext_list_menuitem_common_data->ext_flags &= ~UI_MENUITEM_EXT_SHOW_IN_MARQUEE;
#ifndef __MMI_UI_MENU_SLIM__
    gui_list_in_scroll = MMI_FALSE;
#endif
}


/*****************************************************************************
 * FUNCTION
 *  gui_fixed_icontext_list_menuitem_reset_scroll_text_column
 * DESCRIPTION
 *  Set the scrolling text column to the first column.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gui_fixed_icontext_list_menuitem_reset_scroll_text_column(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* This cannot be done in gui_fixed_icontext_list_menuitem_stop_scroll() 
       because we need to keep text scroll column unchanged when highlight is switched */
    GUI_current_fixed_icontext_list_menuitem_column = 0;
}


/*****************************************************************************
 * FUNCTION
 *  gui_fixed_icontext_list_menuitem_start_scroll
 * DESCRIPTION
 *  Start scrolling for the highlighted icontext list menu item.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gui_fixed_icontext_list_menuitem_start_scroll(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    fixed_icontext_list_menuitem_type *t =
        (fixed_icontext_list_menuitem_type*) GUI_current_fixed_icontext_list_menuitem_data;
    fixed_icontext_list_menuitem *m =
        (fixed_icontext_list_menuitem*) GUI_current_fixed_icontext_list_menuitem_common_data;
    S32 w , text_column;
    U32 flags;
    MMI_BOOL do_scroll = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (t == NULL || m == NULL)
    {
        return;
    }

    flags = m->flags;
    flags |= t->flags;

    for (text_column = 0; text_column < FIXED_ICONTEXT_LIST_MAX_TEXT_COLUMNS; text_column ++)
    {
        GUI_current_fixed_icontext_list_menuitem_text_is_scroll[text_column] = 0;
    }
    if (MMI_current_menu_type == LIST_MENU)
    {
        if(!gui_show_list_menu_check_scrollbar(&MMI_fixed_list_menu)) 
        {
            if (!(m->flags & UI_MENUITEM_DISABLE_TEXT_DISPLAY) && MMI_fixed_list_menu.width == MMI_content_width)
                MMI_fixed_list_menu.item_resize_function(MMI_fixed_list_menu.width - 4, 0);
        }
        else
        {
#ifdef __MMI_FTE_SUPPORT__
            MMI_fixed_list_menu.item_resize_function(MMI_fixed_list_menu.width - GUI_MENUITEM_X1_GAP - GUI_MENUITEM_X2_GAP, 0);
#else
            MMI_fixed_list_menu.item_resize_function(MMI_fixed_list_menu.width - MMI_fixed_list_menu.vbar.width - GUI_MENUITEM_X1_GAP - GUI_MENUITEM_X2_GAP, 0);
#endif
        }
    }

    gui_add_cleanup_hook(gui_fixed_icontext_list_menuitem_reset_scroll_text_column);

    if (flags & UI_MENUITEM_AUTO_CHOOSE_MARQUEE)
    {
        S32 i;

        for (i = 0; i < m->n_text_columns; i++)
        {
            if (m->selected_fonts[i])
            {
                gui_set_font(m->selected_fonts[i]);
            }
            else
            {
                gui_set_font(m->text_fonts[i]);
            }
            w = gui_get_string_width(t->item_texts[i]);
            if (i == 0)
            {
                m->text_width = w;
            }
            else if (w > m->text_width)
            {
                m->text_width = w;
            }

            m->scroll_x = 0;
            if (w > m->text_coordinates[i].width)
            {
                GUI_current_fixed_icontext_list_menuitem_text_is_scroll[i] = 1;
                GUI_current_fixed_icontext_list_menuitem_column = i;
                m->scroll_width = m->text_coordinates[i].width;
                do_scroll = MMI_TRUE;
                
                gui_create_scrolling_text(
                    &gui_current_scroll_text[i],
                    0,
                    0,
                    0,
                    0,
                    (UI_string_type)t->item_texts[i],
                    gui_fixed_icontext_list_menuitem_scroll_handler,
                    scrolling_text_draw_icontext_list_single_line_background,
                    MMI_fixed_icontext_list_menuitem.focussed_text_colors[i],
                    MMI_fixed_icontext_list_menuitem.focussed_text_colors[i]);
                gui_scrolling_text_start(&gui_current_scroll_text[i]);
                //break;
            }
        }
    }
    else
    {
        if (GUI_current_fixed_icontext_list_menuitem_column >= m->n_text_columns)
        {
            MMI_DBG_ASSERT(0);
            GUI_current_fixed_icontext_list_menuitem_column = 0;
        }

        if (m->selected_fonts[GUI_current_fixed_icontext_list_menuitem_column])
        {
            gui_set_font(m->selected_fonts[GUI_current_fixed_icontext_list_menuitem_column]);
        }
        else
        {
            gui_set_font(m->text_fonts[GUI_current_fixed_icontext_list_menuitem_column]);
        }
        w = gui_get_string_width(t->item_texts[GUI_current_fixed_icontext_list_menuitem_column]);
        m->scroll_width = m->text_coordinates[GUI_current_fixed_icontext_list_menuitem_column].width;
        m->text_width = w;
        m->scroll_x = 0;
        
        /* only scroll when the text is not empty (a fix for the bi-degree main menu) */
        if (w && (w > m->scroll_width))
        {
            do_scroll = MMI_TRUE;
            GUI_current_fixed_icontext_list_menuitem_text_is_scroll[GUI_current_fixed_icontext_list_menuitem_column] = 1;
            gui_create_scrolling_text(
                &gui_current_scroll_text[GUI_current_fixed_icontext_list_menuitem_column],
                0,
                0,
                0,
                0,
                (UI_string_type)t->item_texts[GUI_current_fixed_icontext_list_menuitem_column],
                gui_fixed_icontext_list_menuitem_scroll_handler,
                scrolling_text_draw_icontext_list_single_line_background,
                MMI_fixed_icontext_list_menuitem.focussed_text_colors[GUI_current_fixed_icontext_list_menuitem_column],
                MMI_fixed_icontext_list_menuitem.focussed_text_colors[GUI_current_fixed_icontext_list_menuitem_column]);
            gui_scrolling_text_start(&gui_current_scroll_text[GUI_current_fixed_icontext_list_menuitem_column]);
        }
    }

    if (do_scroll)
    {
        if ((flags & UI_MENUITEM_MARQUEE_SCROLL) || (flags & UI_MENUITEM_TWO_DIRECTION_SCROLL))
        {
            GUI_current_fixed_icontext_list_menuitem_scroll = 1;
            GUI_current_fixed_icontext_list_menuitem_scroll_direction = 0;
            GUI_current_fixed_icontext_list_menuitem_scroll_counter = UI_text_menuitem_scroll_pause;

        #ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
            if (gui_get_current_list_effect() && gblock_list_effect != 1)
            {
                gui_register_callback_menuitem_scroll(gui_fixed_icontext_list_menuitem_scroll_handler);
            }
        #endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */ 
        }
    }
    else
#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
    {
        gui_register_callback_menuitem_scroll(gui_dummy_scroll_handler_for_list_effects);
        GUI_current_fixed_icontext_list_menuitem_scroll = 0;
    }
#else /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */ 
    {
        GUI_current_fixed_icontext_list_menuitem_scroll = 0;
    }
#endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */ 
}


/*****************************************************************************
 * FUNCTION
 *  gui_fixed_icontext_list_menuitem_stop_scroll
 * DESCRIPTION
 *  Stop scrolling for the highlighted icontext list menu item.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gui_fixed_icontext_list_menuitem_stop_scroll(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (GUI_current_fixed_icontext_list_menuitem_scroll)
    {
        gui_cancel_timer(gui_fixed_icontext_list_menuitem_scroll_handler);
        GUI_current_fixed_icontext_list_menuitem_scroll = 0;
    }

#if  defined(__MMI_BASIC_UI_STYLE__) && defined(__MMI_UI_HINTS_IN_MENUITEM__)
    gui_two_line_scroller_stop();
#endif

#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
    gui_register_callback_menuitem_scroll(gui_dummy_scroll_handler_for_list_effects);
    gui_restore_current_list_effect();
#endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */ 
}


/*****************************************************************************
 * FUNCTION
 *  gui_fixed_icontext_list_menuitem_set_text_coordinates
 * DESCRIPTION
 *  Set the coordinate and dimension for a text column.
 * PARAMETERS
 *  m               [IN]        common icontext list menu item object
 *  text_column     [IN]        text column index
 *  x               [IN]        text x
 *  y               [IN]        text y
 *  width           [IN]        text width
 *  height          [IN]        text height
 * RETURNS
 *  void
 *****************************************************************************/
void gui_fixed_icontext_list_menuitem_set_text_coordinates(
        fixed_icontext_list_menuitem *m,
        S32 text_column,
        S32 x,
        S32 y,
        S32 width,
        S32 height)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (text_column >= m->n_text_columns)
    {
        return;
    }
    m->text_coordinates[text_column].x = x;
    m->text_coordinates[text_column].y = y;
    m->text_coordinates[text_column].width = width;
    m->text_coordinates[text_column].height = height;
    if (text_column == GUI_current_fixed_icontext_list_menuitem_column)
    {
        m->scroll_width = width;
    }
}


/*****************************************************************************
 * FUNCTION
 *  gui_fixed_icontext_list_menuitem_set_icon_coordinates
 * DESCRIPTION
 *  Set the coordinate and dimension for an icon column.
 * PARAMETERS
 *  m               [IN]        common icontext list menu item object
 *  icon_column     [IN]        icon column index
 *  x               [IN]        icon x
 *  y               [IN]        icon y
 *  width           [IN]        icon width
 *  height          [IN]        icon height
 * RETURNS
 *  void
 *****************************************************************************/
void gui_fixed_icontext_list_menuitem_set_icon_coordinates(
        fixed_icontext_list_menuitem *m,
        S32 icon_column,
        S32 x,
        S32 y,
        S32 width,
        S32 height)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (icon_column >= m->n_icon_columns)
    {
        return;
    }
    m->icon_coordinates[icon_column].x = x;
    m->icon_coordinates[icon_column].y = y;
    m->icon_coordinates[icon_column].width = width;
    m->icon_coordinates[icon_column].height = height;
}


/*****************************************************************************
 * FUNCTION
 *  gui_resize_fixed_icontext_list_menuitem
 * DESCRIPTION
 *  Resize a common icontext list menu item.
 * PARAMETERS
 *  m           [IN]        common icontext list menu item object
 *  width       [IN]        new width
 *  height      [IN]        new height
 * RETURNS
 *  void
 *****************************************************************************/
void gui_resize_fixed_icontext_list_menuitem(fixed_icontext_list_menuitem *m, S32 width, S32 height)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    m->width = width;
    m->height = height;
}


/*****************************************************************************
 * FUNCTION
 *  gui_get_fixed_icontext_list_menuitem_flag
 * DESCRIPTION
 *  get the flag of  icontext list menu item.
 * PARAMETERS
 *  item                    [IN]        private icontext list menu item object
 *  common_item_data        [IN]        common icontext list menu item object
 * RETURNS
 *  flag
 *****************************************************************************/
void gui_get_fixed_icontext_list_menuitem_flag(void *item, void *common_item_data, S32 index, U32* flags, U32* flags_ext)
{
   gui_get_fixed_menuitem_flag(item, common_item_data, index, flags,flags_ext, 0);
}

/*****************************************************************************
 * FUNCTION
 *  gui_show_fixed_icontext_list_menuitem
 * DESCRIPTION
 *  Show an icontext list menu item.
 * PARAMETERS
 *  item                    [IN]        private icontext list menu item object
 *  common_item_data        [IN]        common icontext list menu item object
 *  x                       [IN]        x
 *  y                       [IN]        y
 * RETURNS
 *  void
 *****************************************************************************/
void gui_show_fixed_icontext_list_menuitem(void *item, void *common_item_data, S32 x, S32 y)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x1, y1, x2, y2, menu_y1, menu_y2;
    S32 ix1, iy1, ix2, iy2;
    color text_color;
    UI_filled_area *f = NULL;
    fixed_icontext_list_menuitem *m = (fixed_icontext_list_menuitem*) common_item_data;
    fixed_icontext_list_menuitem_type *mi = (fixed_icontext_list_menuitem_type*) item;
    U32 flags, flags_ext;
    UI_string_type _text;
    PU8 _icon;
    U8 animation_flag = 0;
    U8 focussed_flag = 0;
    U8 disabled_flag = 0;
    U8 selected_flag = 0;
    S32 i;
#ifdef  __MMI_GUI_LIST_MENU_FULL_PACKAGE__
    color c;
#endif
    S32 sw, sh;
    U32 ret_flag_ext = 0;
#ifndef __MMI_MAINLCD_96X64__
    U32 ret_flag = 0;
    gdi_handle alpha_layer;
#endif /* __MMI_MAINLCD_96X64__ */
    gdi_handle old_alpha_layer = GDI_NULL_HANDLE;
    S32 icon_width, icon_height;
#ifndef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
#ifndef __MMI_UI_MENU_SLIM__
    S32 count = 0;
#endif/*__MMI_UI_MENU_SLIM__*/
#endif
    S32 clip_x1, clip_x2, clip_y1, clip_y2;
#if defined(__MMI_UI_LIST_SUPPORT_UNEQUAL_HEIGHT_ITEM__)
    S32 i_width, i_height;
#endif

#if  defined(__MMI_BASIC_UI_STYLE__) && defined(__MMI_UI_HINTS_IN_MENUITEM__)
    MMI_BOOL show_hint_in_menuitem = MMI_FALSE;
    UI_string_type curr_hint_string = NULL;
    S32 text_width = 0;
#endif  // defined(__MMI_BASIC_UI_STYLE__) && defined(__MMI_UI_HINTS_IN_MENUITEM__)
//unimportant issues
#ifndef __MMI_UI_MENU_SLIM__
    gdi_handle act_layer = GDI_NULL_HANDLE;
#endif
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

#ifdef  __MMI_GUI_LIST_MENU_FULL_PACKAGE__
    c = gui_color(0, 0, 0);
#endif
//get flags
#ifndef __MMI_MAINLCD_96X64__
   if (g_gui_list_get_menuitem_flags)
	{
		   if (MMI_fixed_list_menu.current_displayed_item != -1)
		   {
			   g_gui_list_get_menuitem_flags(MMI_fixed_list_menu.current_displayed_item, &ret_flag, &ret_flag_ext);
		   }
		   else
		   {
			   g_gui_list_get_menuitem_flags(MMI_fixed_list_menu.highlighted_item, &ret_flag, &ret_flag_ext);
		   }
   	}
   ret_flag = 0;
#endif /* __MMI_MAINLCD_96X64__ */
   gui_get_fixed_menuitem_flags_int(item, common_item_data, &flags, &flags_ext);
    if (flags & UI_MENUITEM_STATE_FOCUSSED)
    {
        GUI_current_fixed_icontext_list_menuitem_x = x;
        GUI_current_fixed_icontext_list_menuitem_y = y;
    }

    x1 = x;
    y1 = y;
    y2 = y1 + m->height - 1;
    x2 = x1 + m->width - 1;
//get menu region h
     gui_get_menu_region_V(m, &menu_y1, &menu_y2);

#if  defined(__MMI_BASIC_UI_STYLE__) && defined(__MMI_UI_HINTS_IN_MENUITEM__)
    show_hint_in_menuitem = gui_menuitem_has_hint((gui_common_menuitem_base_struct*) m, flags & UI_MENUITEM_STATE_FOCUSSED);
#endif  // defined(__MMI_BASIC_UI_STYLE__) && defined(__MMI_UI_HINTS_IN_MENUITEM__)

#if defined(__MMI_UI_LIST_SUPPORT_UNEQUAL_HEIGHT_ITEM__)
    if (flags_ext & UI_MENUITEM_EXT_INEQUAL_HEIGHT)
    {
        gui_measure_fixed_icontext_list_menuitem(item, common_item_data, &i_width, &i_height);
        y2 = y1 + i_height - 1;
    }
	//unimportant issues
	#ifndef __MMI_UI_MENU_SLIM__
	#else
	else
	#endif
#endif
    if ((flags & UI_MENUITEM_STATE_FOCUSSED) && 
        (m->ext_flags & UI_MENUITEM_SHOW_HIGHLIGHTED_HINT) &&
        (!(flags & UI_MENUITEM_DISABLE_HIGHLIGHT)))
    {
        focussed_flag = 1;
#if  defined(__MMI_BASIC_UI_STYLE__) && defined(__MMI_UI_HINTS_IN_MENUITEM__)
        if (show_hint_in_menuitem)
#endif  // defined(__MMI_BASIC_UI_STYLE__) && defined(__MMI_UI_HINTS_IN_MENUITEM__)
        {
#if defined(__MMI_UI_LIST_SUPPORT_UNEQUAL_HEIGHT_ITEM__)
            if (flags_ext & UI_MENUITEM_EXT_INEQUAL_HEIGHT)
            {
                y2 = y1 + (i_height + m->height) - 1;
            }
            else
#endif
            {
                y2 = y1 + (m->height << 1) - 1;
            }
            gui_show_two_line_icontext_list_menuitem(item, common_item_data, &f);
        }
#if  defined(__MMI_BASIC_UI_STYLE__) && defined(__MMI_UI_HINTS_IN_MENUITEM__)
        else
        {
            f = gui_list_get_focussed_filler((gui_common_menuitem_base_struct*) m);
        }
#endif  // defined(__MMI_BASIC_UI_STYLE__) && defined(__MMI_UI_HINTS_IN_MENUITEM__)
    }
    else if ((flags & UI_MENUITEM_STATE_FOCUSSED) && !(flags & UI_MENUITEM_DISABLE_HIGHLIGHT))
    {
        f = gui_list_get_focussed_filler((gui_common_menuitem_base_struct*) m);
        if (g_dm_data.s32CatId != MMI_CATEGORY414_ID)
        {
            fixed_single_line_menuitem_filled_area = *f;
        }
        focussed_flag = 1;
        if (flags & UI_MENUITEM_FOCUSSED_ANIMATE)
        {
            animation_flag = 1;
        }
    }
    else if (flags & UI_MENUITEM_STATE_DISABLED)
    {
        if (!(flags & UI_MENUITEM_DISABLE_BACKGROUND))
        {
            f = m->disabled_filler;
        }
        disabled_flag = 1;
    }
    else if (flags & UI_MENUITEM_STATE_SELECTED)
    {
        f = m->selected_filler;
        if (flags & UI_MENUITEM_SELECTED_ANIMATE)
        {
            animation_flag = 1;
        }
        selected_flag = 1;
    }
    else
    {
        if (!(flags & UI_MENUITEM_DISABLE_BACKGROUND))
        {
            f = m->normal_filler;
        }
    }

    /* cascading menu special case, disabled text color with a highlighted filler. */
    if ((flags & UI_MENUITEM_STATE_FOCUSSED) && (flags & UI_MENUITEM_STATE_DISABLED))
    {
        f = gui_list_get_focussed_filler((gui_common_menuitem_base_struct*) m);
        focussed_flag = 0;
        disabled_flag = 1;
    }

    gui_push_clip();
    
    clip_x1 = x1;
    clip_x2 = x2;
    clip_y1 = y1;
    clip_y2 = y2;

//unimportant issues
#ifndef __MMI_UI_MENU_SLIM__
    gdi_layer_get_active(&act_layer);
    if (MMI_current_menu_type == LIST_MENU && clip_y1 < m->parent_list->y && m->parent_list->act_layer_handle == act_layer)
    {
        clip_y1 = m->parent_list->y;
    }            
#endif
    if (y1 >= menu_y2)
    {
        clip_y1 = menu_y2;
        clip_y2 = menu_y2;
    }
    else if (y2 >= menu_y2)
    {
        clip_y2 = menu_y2;
    }
    
//unimportant issues
#ifndef __MMI_UI_MENU_SLIM__
    gui_set_clip(clip_x1, clip_y1, clip_x2, clip_y2);

    if (m->flags & UI_MENUITEM_DISABLE_HIGHLIGHT_DISPLAY)
    {
        f = NULL;
    }
#else
gui_set_clip_preset(clip_x1, clip_y1, clip_x2, clip_y2);
#endif

    if (f != NULL && (!(flags & UI_MENUITEM_HIGHLIGHT_SWITCH_ICON)) && !g_slide_effect->in_flatten)
    {
    #ifdef __MMI_SUPPORT_DUMP_SCREEN_STRING__
    #ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
        if (is_draw_next_frame_list_highlight_effect_value())
    #endif
        {
            mmi_frm_dss_set_menu_highlight(MMI_SCREEN_HIGHLIGHT_ICONTEXT_LIST);
        }
    #endif

        old_alpha_layer = gui_list_set_alpha_blending_layer();
        set_start_position_and_item_parameters_for_list_highlighter_effect(item, common_item_data, x1, y1);

    #if defined(__MMI_OP11_HOMESCREEN_0301__) || defined(__MMI_OP11_HOMESCREEN_0302__)
        if (ret_flag_ext & UI_MENUITEM_EXT_SHOW_DOWN_SHORT_SEPARATORLINE)
        {
            y2 --;
        }
    #endif  // defined(__MMI_OP11_HOMESCREEN_0301__) || defined(__MMI_OP11_HOMESCREEN_0302__)

        gui_swla_log_start("IFL");
#ifdef  __OP01_FWPBW__
        gui_draw_filled_area(x1 + m->text_coordinates[0].x, y1, x2, y2, f);
#else   // __OP01_FWPBW__
    #ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
        gui_draw_list_filled_area(x1, y1, x2, y2, f);
    #else /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */ 
#ifndef __MMI_UI_MENU_SLIM__
		if (gui_filled_area_is_animation(f))
        {
            gdi_image_get_frame_count(f->b, &count);
            if (gblock_list_animation_highlight)
            {   
                if (count >= 1)
                {
                    gdi_image_draw_frames(x1, y1, f->b, count - 1);
                }
                else
                {
                    gui_draw_filled_area(x1, y1, x2, y2, f);
                }
            }
            else
            {
                gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_TRANSPARENT);
//hujin
//#ifndef __MMI_UI_MENU_SLIM__
				if (count >= 1)
                {
                    gui_draw_animated_effect_filler(x1, y1, x2, y2, f);            
                }
                else
//#endif					
                {
                    gui_draw_filled_area(x1, y1, x2, y2, f);
                } 
            }           
        }            
        else
#endif
        {
            gui_draw_filled_area(x1, y1, x2, y2, f);
        }
    #endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */ 
#endif  //__OP01_FWPBW__
        gui_swla_log_stop("IFL");

    #if defined(__MMI_OP11_HOMESCREEN_0301__) || defined(__MMI_OP11_HOMESCREEN_0302__)
        if (ret_flag_ext & UI_MENUITEM_EXT_SHOW_DOWN_SHORT_SEPARATORLINE)
        {
            y2 ++;
        }
    #endif  // defined(__MMI_OP11_HOMESCREEN_0301__) || defined(__MMI_OP11_HOMESCREEN_0302__)

        gui_list_reset_alpha_blending_layer(old_alpha_layer);
    }

    if ((m->highlight_twoline_display_function != NULL) && (flags & UI_MENUITEM_STATE_FOCUSSED))
    {
        m->highlight_twoline_display_function(item, x1, y1, x2, y2);
        gui_pop_clip();
        return;
    }
#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
    /* To hide the text and icon of the menuitem up to the last frame for flash feel effect */
#ifdef  __MMI_UI_LIST_FLASH_HIGHLIGHT_EFFECTS__
    if (gblock_list_effect == 0)
    {
        if (gui_get_current_list_effect() == MMI_UI_LIST_HIGHLIGHT_EFFECT_FLASH_FEELING &&
            MMI_current_menu_type == LIST_MENU)
        {
            if (g_flash_feel_state != GUI_LIST_EFFECT_FLASH_FEELING_LAST_FRAME)
            {
                if (flags & UI_MENUITEM_STATE_FOCUSSED)
                {
                    flags |= UI_MENUITEM_DISABLE_TEXT_DISPLAY;
                }
            }
        }
    }
#endif  /* __MMI_UI_LIST_FLASH_HIGHLIGHT_EFFECTS__ */    
#endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */ 

    /* show checkbox, show it here to correspond to list effects since */
    if (m->ext_flags & UI_MENUITEM_EXT_SHOW_ICONTEXT_CHECKBOX)
    {
        gui_menuitem_icontext_list_show_checkbox(m, x1, y1);
    }

    old_alpha_layer = gui_list_set_alpha_blending_layer_ex(flags, MMI_TRUE);
    if (!(flags & UI_MENUITEM_DISABLE_ICON))
    {
    for (i = 0; i < m->n_icon_columns; i++)
    {
        /* For bi-degree main menu */
        /* selected item, should draw selected image */
#ifdef __MMI_BI_DEGREE_MAIN_MENU_STYLE__
        if (flags & UI_MENUITEM_HIGHLIGHT_SWITCH_ICON)
        {
            if (flags & UI_MENUITEM_STATE_FOCUSSED)
            {
                i++;
            }
            /* normal item, should clear previous drawn image */
            else
            {
            #ifdef __GDI_MEMORY_PROFILE_2__
                //gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_TRANSPARENT);
            #endif 
            }
            gdi_layer_flatten_with_clipping(dm_get_scr_bg_layer(), 0, 0, 0);
        }
#endif  // __MMI_BI_DEGREE_MAIN_MENU_STYLE__

        if (mi->item_icon_handles[i] != GDI_ERROR_HANDLE)
        {
            gdi_image_stop_animation(mi->item_icon_handles[i]);
            mi->item_icon_handles[i] = GDI_ERROR_HANDLE;
        }
        _icon = mi->item_icons[i];
        /* _icon_handle=mi->item_icon_handles[i]; */
        if (i == 0 && g_dm_data.s32CatId == MMI_CATEGORY_CASCADING_MENU_ID &&
            flags & UI_MENUITEM_STATE_FOCUSSED)
        {
            if (flags_ext & UI_MENUITEM_EXT_WITH_SUBMENU)
            {
                if (mmi_fe_get_r2l_state() && _icon == current_MMI_theme->cascade_menu_submenu_left_arrow_image)
                    _icon = current_MMI_theme->cascade_menu_submenu_highlight_left_arrow_image;
                else if (!mmi_fe_get_r2l_state() && _icon == current_MMI_theme->cascade_menu_submenu_right_arrow_image)
                    _icon = current_MMI_theme->cascade_menu_submenu_highlight_right_arrow_image;
            }
        }

    #ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
    #ifdef  __MMI_UI_LIST_FLASH_HIGHLIGHT_EFFECTS__
        /* To hide the icon of the menuitem up to the last frame for flash feel effect */
        if (gblock_list_effect == 0)
        {
            if (gui_get_current_list_effect() == MMI_UI_LIST_HIGHLIGHT_EFFECT_FLASH_FEELING &&
                MMI_current_menu_type == LIST_MENU)
            {
                if (g_flash_feel_state != GUI_LIST_EFFECT_FLASH_FEELING_LAST_FRAME)
                {
                    if (flags & UI_MENUITEM_STATE_FOCUSSED)
                    {
                        _icon = UI_NULL_IMAGE;
                    }
                }
            }
        }
    #endif  /* __MMI_UI_LIST_FLASH_HIGHLIGHT_EFFECTS__ */
    #endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */ 

        /* calculate the icon position */
        iy1 = m->icon_coordinates[i].y + y1;
        if (_icon != UI_NULL_IMAGE)
        {

            gui_measure_image(_icon, &icon_width, &icon_height);
            if (flags & UI_MENUITEM_CENTER_ICON_X)
            {
                m->icon_coordinates[i].x = (m->width >> 1) - (icon_width >> 1);
            }

            if (!(m->flags & MENU_MUTLIROW_ICON_LIST))
            {
                if (flags & UI_MENUITEM_CENTER_ICON_Y)
                {
                    if (m->height == MMI_MENUITEM_HEIGHT)
                        iy1 = m->icon_coordinates[i].y + y1 + (m->height >> 1) - (icon_height >> 1);
#if defined(__MMI_UI_LIST_SUPPORT_UNEQUAL_HEIGHT_ITEM__)
                    else if (flags_ext & UI_MENUITEM_EXT_INEQUAL_HEIGHT)
                        iy1 = m->icon_coordinates[i].y + y1 + (i_height >> 1) - (icon_height >> 1);
#endif
                    else
                        iy1 = m->icon_coordinates[i].y + y1 + (m->icon_coordinates[i].height >> 1) - (icon_height >> 1);
                }
            }
            if (mmi_fe_get_r2l_state())
            {
                ix1 = x2 - m->icon_coordinates[i].x - icon_width + 1;
            }
            else
            {
                ix1 = m->icon_coordinates[i].x + x1;
            }
            ix2 = ix1 + icon_width - 1;
            iy2 = iy1 + icon_height - 1;
        }
        else
        {            
            if (mmi_fe_get_r2l_state())
            {
                ix1 = x2 - m->icon_coordinates[i].x - m->icon_coordinates[i].width + 1;
            }
            else
            {
                ix1 = m->icon_coordinates[i].x + x1;
            }
            ix2 = ix1 + m->icon_coordinates[i].width - 1;
            iy2 = iy1 + m->icon_coordinates[i].height - 1;
        }

        if (ix2 > x2)
        {
            ix2 = x2;
        }
        if (iy2 > y2)
        {
            iy2 = y2;
        }

        gui_push_clip();

        clip_x1 = ix1;
        clip_y1 = iy1;
        clip_x2 = ix2;
        clip_y2 = iy2;

//unimportant issues
#ifndef __MMI_UI_MENU_SLIM__
        gdi_layer_get_active(&act_layer);
        if (MMI_current_menu_type == LIST_MENU && clip_y1 < m->parent_list->y && m->parent_list->act_layer_handle == act_layer)
        {
            clip_y1 = m->parent_list->y;
        }            
#endif
        if (iy1 >= menu_y2)
        {
            clip_y1 = menu_y2;
            clip_y2 = menu_y2;
        }
        else if (iy2 >= menu_y2)
        {
            clip_y2 = menu_y2;
        }
	//unimportant issues
	#ifndef __MMI_UI_MENU_SLIM__
        gui_set_clip(clip_x1, clip_y1, clip_x2, clip_y2);
    #else
	gui_set_clip_preset(clip_x1, clip_y1, clip_x2, clip_y2);
	#endif
        if (_icon != UI_NULL_IMAGE && iy1 < y2)
        {
            /* 
             * UI_MENUITEM_HIGHLIGHT_SWITCH_ICON is for bi-degree main menu only.
             */
            UI_filled_area         *anim_bkg_filler = NULL;

#ifdef __MMI_BI_DEGREE_MAIN_MENU_STYLE__
            if (flags & UI_MENUITEM_HIGHLIGHT_SWITCH_ICON)
            {                    
                if (flags & UI_MENUITEM_STATE_FOCUSSED)
                {
                    anim_bkg_filler = current_MMI_theme->main_menu_bidegree_tab_highlight_filler;
                }
                else
                {
                    anim_bkg_filler = current_MMI_theme->main_menu_bidegree_tab_background_filler;
                }                                    
            }
#endif  // __MMI_BI_DEGREE_MAIN_MENU_STYLE__
                    
            if (animation_flag)
            {
                gui_swla_log_start("ICO");
                gui_show_animation_with_background_filler(ix1, iy1, _icon, anim_bkg_filler, &(mi->item_icon_handles[i]));
                gui_swla_log_stop("ICO");
                
                m->flags |= UI_MENUITEM_STATE_ANIMATE;
            }
            else 
            {
#ifdef __MMI_BI_DEGREE_MAIN_MENU_STYLE__
                gdi_handle  active_layer, old_src_layer = GDI_NULL_HANDLE;

                if (flags & UI_MENUITEM_HIGHLIGHT_SWITCH_ICON)
                {
                    gui_draw_filled_area(ix1, iy1, ix2, iy2, anim_bkg_filler);

                    gdi_layer_get_active(&active_layer);
                    old_src_layer = gdi_set_alpha_blending_source_layer(active_layer);                    
                }
#endif  //  __MMI_BI_DEGREE_MAIN_MENU_STYLE__

                gui_swla_log_start("ICO");
                gdi_image_draw_frames(ix1, iy1, _icon, 0);
                gui_swla_log_stop("ICO");

#ifdef __MMI_BI_DEGREE_MAIN_MENU_STYLE__
                if (flags & UI_MENUITEM_HIGHLIGHT_SWITCH_ICON)
                {
                    gdi_set_alpha_blending_source_layer(old_src_layer);
                }
#endif  // __MMI_BI_DEGREE_MAIN_MENU_STYLE__
                
                if (m->flags & UI_MENUITEM_STATE_ANIMATE)
                {
                    m->flags &= ~UI_MENUITEM_STATE_ANIMATE;
                }
            }
        }

        gui_pop_clip();

#ifdef __MMI_BI_DEGREE_MAIN_MENU_STYLE__
        if (flags & UI_MENUITEM_HIGHLIGHT_SWITCH_ICON)
        {
            break;
        }
#endif  //  __MMI_BI_DEGREE_MAIN_MENU_STYLE__
    }
    }
    gui_list_reset_alpha_blending_layer(old_alpha_layer);

    gui_push_text_clip();

    clip_x1 = x1;
    clip_y1 = y1;
    clip_x2 = x2;
    clip_y2 = y2;

//unimportant issues
#ifndef __MMI_UI_MENU_SLIM__
    gdi_layer_get_active(&act_layer);
    if (MMI_current_menu_type == LIST_MENU && clip_y1 < m->parent_list->y && m->parent_list->act_layer_handle == act_layer)
    {
        clip_y1 = m->parent_list->y;
    }            
#endif
    if (y1 >= menu_y2)
    {
        clip_y1 = menu_y2;
        clip_y2 = menu_y2;
    }
    else if (y2 >= menu_y2)
    {
        clip_y2 = menu_y2;
    }
//unimportant issues
#ifndef __MMI_UI_MENU_SLIM__
    gui_set_clip(clip_x1, clip_y1, clip_x2, clip_y2);
#else  
gui_set_clip_preset(clip_x1, clip_y1, clip_x2, clip_y2);
#endif
    if (!(flags & UI_MENUITEM_DISABLE_TEXT_DISPLAY))
    {
    //hujin
    //unimportant issues
    #ifndef __MMI_UI_MENU_SLIM__
        S32 col1_iy1 = 0, col1_ascent = 0;
	#endif
#ifdef  __MMI_VECTOR_FONT_SUPPORT__
        old_alpha_layer = gui_list_set_alpha_blending_layer_ex(flags, MMI_TRUE);
#endif  // __MMI_VECTOR_FONT_SUPPORT__
        for (i = 0; i < m->n_text_columns; i++)
        {
            _text = mi->item_texts[i];
            if ((mi->flags & UI_MENUITEM_STATE_FOCUSSED) && 
                (MMI_current_menu_type == LIST_MENU) && 
                (!(flags & UI_MENUITEM_DISABLE_HIGHLIGHT)) &&
                (m->selected_fonts[i]))
            {
                gui_set_font(m->selected_fonts[i]);
            }
            else
            {
                gui_set_font(m->text_fonts[i]);
            }
            gui_measure_string(_text, &sw, &sh);
            if (flags & UI_MENUITEM_CENTER_TEXT_X)
            {
                m->text_coordinates[i].x = (m->width >> 1) - (sw >> 1);
                ix1 = m->text_coordinates[i].x + x1;
                ix2 = ix1 + m->text_coordinates[i].width - 1;
            }

            iy1 = m->text_coordinates[i].y + y1;
            iy2 = iy1 + m->text_coordinates[i].height - 1;
            
            if (m->flags & UI_MENUITEM_ICONTEXT_LIST_ALL_TEXT_VERTICAL_ALIGN_CENTER)
            {
                iy1 += (m->text_coordinates[i].height - sh) / 2;
            }
            else
            {
                if (!(m->flags & MENU_MUTLIROW_ICON_LIST))
                {
                    if (flags & UI_MENUITEM_CENTER_TEXT_Y)
                    {
                    //unimportant issues
                    #ifndef __MMI_UI_MENU_SLIM__
                        if ((i == 1) && (mi->flags & UI_MENUITEM_TEXT_COL1_IS_NUMBER))
                        {
                            /* special case for UI_MENUITEM_TEXT_COL1_IS_NUMBER) */
                            mmi_fe_get_string_info_param_struct query;
                            memset(&query, 0, sizeof(mmi_fe_get_string_info_param_struct));
                            query.String = (U8*)_text;
                            query.checkCompleteWord = MMI_FALSE;
                            query.enableTruncated = MMI_FALSE;
                            query.n =  mmi_ucs2strlen((const char*)_text);
                            query.w = 0;
                            mmi_fe_get_string_widthheight(&query);

                            iy1 = col1_iy1 + (col1_ascent - query.maxAscent);
                            iy2 = iy1 + m->text_coordinates[i].height - 1;
                        }
                        else
					#endif
							if (m->height == MMI_MENUITEM_HEIGHT)
                        {
                            iy1 = m->text_coordinates[i].y + y1 + (m->height >> 1) - (sh >> 1);
                            iy2 = iy1 + m->text_coordinates[i].height - 1;
                        }
#if defined(__MMI_UI_LIST_SUPPORT_UNEQUAL_HEIGHT_ITEM__)
                        else if (flags_ext & UI_MENUITEM_EXT_INEQUAL_HEIGHT)
                        {
                            iy1 = m->text_coordinates[i].y + y1 + (i_height >> 1) - (sh >> 1);
                            iy2 = iy1 + m->text_coordinates[i].height - 1;
                        }
#endif
                        else
                        {
                            iy1 = m->text_coordinates[i].y + y1 + (m->text_coordinates[i].height >> 1) - (sh >> 1);
                            iy2 = iy1 + sh - 1;
                        }
                    }
                }
            }
            
			if ((flags & UI_MENUITEM_DISABLE_ICON) &&(m->n_text_columns == 1))
			{
				ix1 = x1 + 2;
                ix2 = x2 - 2;
			}
            else
            {
                if (mmi_fe_get_r2l_state())
                {
                    ix1 = x2 - m->text_coordinates[i].x - m->text_coordinates[i].width + 1;
                    ix2 = ix1 + m->text_coordinates[i].width - 1;
                }
                else
                {
                    ix1 = m->text_coordinates[i].x + x1;
                    ix2 = ix1 + m->text_coordinates[i].width - 1;
                }
            }

            if (flags & UI_MENUITEM_STATE_FOCUSSED && f && f->flags & UI_FILLED_AREA_SINGLE_BORDER)
            {
                if (ix2 > x2 - 1)
                {
                    ix2 = x2 - 1;
                }
            }
            else
            {
                if (ix2 > x2)
                {
                    ix2 = x2;
                }
            }
            
            if (iy2 > y2)
            {
                iy2 = y2;
            }

#ifdef  __MMI_GUI_LIST_MENU_FULL_PACKAGE__    // none will use UI__MENUITEM_FILL_COL1, so colorangewgui_pop_up_dialog_background is useless 
            if ((i == 0) && (flags & UI_MENUITEM_FILL_COL1))
            {
                int j;

                if (y1 >= menu_y2)
                {
                    gui_set_clip((ix1 - x1), menu_y2, ix2, menu_y2);
                }
                else if (y2 >= menu_y2)
                {
                    gui_set_clip((ix1 - x1), y1, ix2, menu_y2);
                }
                else
                {
                    gui_set_clip((ix1 - x1), y1, ix2, y2);
                }

                for (j = 0; j < FIXED_ICONTEXT_LIST_MAX_TEXT_COLUMNS; j++)
                {
                    m->focussed_text_colors[j] = c;
                }
                gui_draw_filled_area((ix1 - x1), y1, ix2, y2, &colorangewgui_pop_up_dialog_background);
            }
            if ((i == 1) && (flags & UI_MENUITEM_FILL_COL2))
            {
                int j;

                
                if (y1 >= menu_y2)
                {
                    gui_set_clip((ix1 - x1), menu_y2, ix2, menu_y2);
                }
                else if (y2 >= menu_y2)
                {
                    gui_set_clip((ix1 - x1), y1, ix2, menu_y2);
                }
                else
                {
                    gui_set_clip((ix1 - x1), y1, ix2, y2);
                }

                for (j = 0; j < FIXED_ICONTEXT_LIST_MAX_TEXT_COLUMNS; j++)
                {
                    m->focussed_text_colors[j] = c;
                }
                gui_draw_filled_area((ix1 - x1), y1, ix2, y2, &colorangewgui_pop_up_dialog_background);
            }
#endif  // __MMI_GUI_LIST_MENU_FULL_PACKAGE__            
            if ( _text && mmi_ucs2strlen((CHAR *)_text) && iy1 < y2)
                {
                    if (disabled_flag)
                    {
                        if (flags_ext & UI_MENUITEM_EXT_DISABLED_NORMAL_TEXT)
                        {
                            text_color = m->normal_text_colors[i];
                        }
                        else
                        {
                            text_color = m->disabled_text_colors[i];
                        }
                    }
                    else if (focussed_flag)
                    {
                        text_color = m->focussed_text_colors[i];
                    }
                    else if (selected_flag)
                    {
                        text_color = m->selected_text_colors[i];
                    }
                    else
                    {
                        text_color = m->normal_text_colors[i];
                    }

#ifdef  __MMI_OP01_DCD__
                    if (mi->ext_flags & UI_MENUITEM_EXT_SHOW_DIFFERENT_COLOR)
					{						
						text_color = g_gui_list_text_color;						
					}
#endif  // __MMI_OP01_DCD__                    
                    
                    gui_push_clip();
                    if (!(flags & UI_MENUITEM_DISABLE_TEXT_CLIP))
                    {
                        clip_x1 = ix1;
                        clip_x2 = ix2;
                        clip_y1 = iy1;
                        clip_y2 = iy2;

//unimportant issues
#ifndef __MMI_UI_MENU_SLIM__
                        gdi_layer_get_active(&act_layer);
                        if (MMI_current_menu_type == LIST_MENU && clip_y1 < m->parent_list->y && m->parent_list->act_layer_handle == act_layer)
                        {
                            clip_y1 = m->parent_list->y;
                        }   
					#endif
                        if (iy1 >= menu_y2)
                        {
                            clip_y1 = menu_y2;
                            clip_y2 = menu_y2;
                        }
                        else if (iy2 >= menu_y2)
                        {
                            clip_y2 = menu_y2;
                        }
//hujin
//unimportant issues
#ifndef __MMI_UI_MENU_SLIM__
                        gui_set_clip(clip_x1, clip_y1, clip_x2, clip_y2);
#else
						gui_set_clip_preset(clip_x1, clip_y1, clip_x2, clip_y2);
#endif
                    }
                    gui_set_text_color(text_color);

                    /* Added specifically to right justify second column in case of two column display with numbers */
                    if ((i == 1) && 
                        (flags & UI_MENUITEM_RIGHT_JUSTIFY_COL2) && 
                        (sw <= m->text_coordinates[i].width))
                    {
                        if (mmi_fe_get_r2l_state())
                        {
                            gui_move_text_cursor(ix1 + sw, iy1);
                        }
                        else
                        {
                            gui_move_text_cursor(ix2 - sw, iy1);
                        }

                        gui_set_line_height(sh);
                        gui_print_text(_text);
                    }
                    else
                    {       
                        S32 temp_text_width = m->text_coordinates[i].width;
                        if ((flags & UI_MENUITEM_DISABLE_ICON) &&(m->n_text_columns == 1) && (i == 0))
                        {
                            temp_text_width = ix2 - ix1 + 1;
                        }
                        
                        if ((flags & UI_MENUITEM_STATE_FOCUSSED) &&
                            ((i == GUI_current_fixed_icontext_list_menuitem_column) ||
                            (m->flags & UI_MENUITEM_AUTO_CHOOSE_MARQUEE)))
                            /* Second Column Text Scroll Change For Multi Row List */
                        {
                            if (sw > temp_text_width)
                            {
                                if (mmi_fe_get_r2l_state())
                                {
                                    gui_move_text_cursor(ix2 + m->scroll_x, iy1);
                                }
                                else
                                {
                                    gui_move_text_cursor(ix1 + m->scroll_x, iy1);
                                }
                            }
                            else
                            {
                                if (mmi_fe_get_r2l_state())
                                {
                                    gui_move_text_cursor(ix2, iy1);
                                }
                                else
                                {
                                    gui_move_text_cursor(ix1, iy1);
                                }
                            }
                            gui_set_line_height(sh);

                            /* trucate too long number/name in call list. */
                            if (flags & UI_MENUITEM_TRUNCATE_CONTENT)
                            {
                                if (mmi_fe_get_r2l_state())
                                {
                                    gui_print_truncated_text(ix2, iy1, temp_text_width, _text);
                                }
                                else
                                {
                                    gui_print_truncated_text(ix1, iy1, temp_text_width, _text);
                                }
                            }
                            else
                            {
                                if ((flags & UI_MENUITEM_MARQUEE_SCROLL) &&
                                    (sw > temp_text_width) &&
                                    GUI_current_fixed_icontext_list_menuitem_scroll 
								     &&
                                    ((iy1 >= menu_y1 && iy1 + sh <= menu_y2) || !g_current_display_half_menuitem)
)
                                {
                                    gui_menuitem_redraw_scrolling_text(
                                        &(gui_current_scroll_text[i]),
                                        ix1,
                                        iy1,
                                        temp_text_width,
                                        sh + 1,
                                        &text_color,
                                        NULL
                                    );
                                 }
                                 else
                                 {
                                     gui_print_text(_text);
                                 }
                            }
                        }
                        else
                        {
                            if (flags & UI_MENUITEM_TRUNCATE_CONTENT)
                            {
                                gui_set_line_height(sh);
                                if (mmi_fe_get_r2l_state())
                                {
                                    gui_print_truncated_text(ix2, iy1, temp_text_width, _text);
                                }
                                else
                                {
                                    gui_print_truncated_text(ix1, iy1, temp_text_width, _text);
                                }
                            }
                            else
                            {
                                if (mmi_fe_get_r2l_state())
                                {
                                    gui_move_text_cursor(ix2, iy1);
                                }
                                else
                                {
                                    gui_move_text_cursor(ix1, iy1);
                                }
                                
                                gui_set_line_height(sh);
                                if ((i == 0) && (mi->flags & UI_MENUITEM_TEXT_COL1_IS_NUMBER))
                                {   /* special case for cateogry 89 "1." in Arabic */
                                //unimportant issues
                                #ifndef __MMI_UI_MENU_SLIM__
                                    mmi_fe_get_string_info_param_struct query;
                                    memset(&query, 0, sizeof(mmi_fe_get_string_info_param_struct));
                                    query.String = (U8*)_text;
                                    query.checkCompleteWord = MMI_FALSE;
                                    query.enableTruncated = MMI_FALSE;
                                    query.n =  mmi_ucs2strlen((const char*)_text);
                                    query.w = 0;
                                    mmi_fe_get_string_widthheight(&query);

                                    col1_ascent = query.maxAscent;
                                    col1_iy1 = iy1;
                                 #endif
                                    gui_print_text_by_direction(_text);
                                }
                                else
                                {
                                #ifdef __MMI_UI_LIST_TRUNCATE_ITEM__
                                    if (mmi_fe_get_r2l_state())
                                    {
                                        gui_print_truncated_text(ix2, iy1, temp_text_width, _text);
                                    }
                                    else
                                    {
                                        gui_print_truncated_text(ix1, iy1, temp_text_width, _text);
                                    }
                                #else /* __MMI_UI_LIST_TRUNCATE_ITEM__ */
                                    gui_print_text(_text);
                                #endif /* __MMI_UI_LIST_TRUNCATE_ITEM__ */
                                }                                
                            }
                        }
                    }
                    gui_pop_clip();

                }
            }
#ifdef  __MMI_VECTOR_FONT_SUPPORT__
            gui_list_reset_alpha_blending_layer(old_alpha_layer);
#endif
        }

    if (flags & UI_MENUITEM_DOTTED_UNDERLINE)
    {
        static const U8 dotted_line_bitvalues[] = {1, 1, 1, 1, 0, 0, 0};
        color underline_color = m->normal_text_colors[0];

        clip_x1 = x1;
        clip_x2 = x2;
        clip_y1 = y1;
        clip_y2 = y2;

        gui_push_clip();

//unimportant issues
#ifndef __MMI_UI_MENU_SLIM__
        gdi_layer_get_active(&act_layer);
        if (MMI_current_menu_type == LIST_MENU && clip_y1 < m->parent_list->y && m->parent_list->act_layer_handle == act_layer)
        {
            clip_y1 = m->parent_list->y;
        }            
#endif
        if (y1 >= menu_y2)
        {
            clip_y1 = menu_y2;
            clip_y2 = menu_y2;
        }
        else if (y2 >= menu_y2)
        {
            clip_y2 = menu_y2;
        }
		//unimportant issues
		#ifndef __MMI_UI_MENU_SLIM__
        gui_set_clip(clip_x1, clip_y1, clip_x2, clip_y2);
		#else		
        gui_set_clip_preset(clip_x1, clip_y1, clip_x2, clip_y2);
		#endif
        gdi_draw_line_style(
            x1,
            y2,
            x2,
            y2,
            gdi_act_color_from_rgb(255, underline_color.r, underline_color.g, underline_color.b),
            sizeof(dotted_line_bitvalues),
            dotted_line_bitvalues);
        gui_pop_clip();
    }

    // for slim, support display hint in icontext list menuitem
#if  defined(__MMI_BASIC_UI_STYLE__) && defined(__MMI_UI_HINTS_IN_MENUITEM__)
    if (show_hint_in_menuitem && (!(flags & UI_MENUITEM_DISABLE_HIGHLIGHT)))
    {
        curr_hint_string = m->parent_list->gui_get_current_pop_up_description_string();
        // display the hint in the second line
        clip_x1 = x1 + GUI_TWO_LINE_TEXT_ICON_GAP;
        clip_x2 = x2 - GUI_TWO_LINE_TEXT_ICON_GAP;

        text_width = clip_x2 - clip_x1 + 1;

        // use first text's color and font
        gui_set_font(m->text_fonts[0]);
        
        if (disabled_flag)
        {
            text_color = m->disabled_text_colors[0];
        }
        else if (focussed_flag)
        {
            text_color = m->focussed_text_colors[0];
        }
        else if (selected_flag)
        {
            text_color = m->selected_text_colors[0];
        }
        else
        {
            text_color = m->normal_text_colors[0];
        }
        gui_set_text_color(text_color);
        gui_measure_string(curr_hint_string, &sw, &sh);

#if defined(__MMI_UI_LIST_SUPPORT_UNEQUAL_HEIGHT_ITEM__)
    if (flags_ext & UI_MENUITEM_EXT_INEQUAL_HEIGHT)
        clip_y1 = y1 + i_height + ((m->height - sh)>>1);
    else
#endif
        clip_y1 = y1 + m->height + ((m->height - sh)>>1);
        clip_y2 = y2;

        if (mmi_fe_get_r2l_state())
        {
            gui_move_text_cursor(clip_x2, clip_y1);
        }
        else
        {
            gui_move_text_cursor(clip_x1, clip_y1);
        }

        gdi_layer_push_and_set_clip(clip_x1, clip_y1, clip_x2, clip_y2);
        if (flags & UI_MENUITEM_TRUNCATE_CONTENT)
        {
            gui_set_line_height(sh);
            if (mmi_fe_get_r2l_state())
            {
                gui_print_truncated_text(clip_x2, clip_y1, text_width, curr_hint_string);
            }
            else
            {
                gui_print_truncated_text(clip_x1, clip_y1, text_width, curr_hint_string);
            }
        }
        else
        {
            if ((flags & UI_MENUITEM_MARQUEE_SCROLL) &&(sw > text_width))
            {
                gui_create_scrolling_text(
                    &gui_two_line_scroll_text,
                    clip_x1,
                    clip_y1,
                    text_width,
                    clip_y2 - clip_y1 + 1,
                    (UI_string_type)curr_hint_string,
                    line_scrolling_text_timer_handler,
                    scrolling_text_draw_icontext_list_single_line_background,
                    text_color,
                    text_color);
                if (flags & UI_MENUITEM_TWO_DIRECTION_SCROLL)
                {
                    gui_current_scroll_text[0].flags = UI_SCROLLING_TEXT_TWO_DIRECTION_SCROLL;
                }
                gui_show_scrolling_text(&gui_two_line_scroll_text);
                
#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
                if (gui_get_current_list_effect() && gblock_list_effect != 1)
                {
                    gui_register_callback_menuitem_scroll(gui_fixed_icontext_list_menuitem_scroll_handler);
                }
#endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */ 
             }
             else
             {
                 gui_print_text(curr_hint_string);
             }
        }
        gdi_layer_pop_clip();
    }
#endif  // __MMI_BASIC_UI_STYLE__

    clip_x1 = x1;
    clip_x2 = x2;
    clip_y1 = y1;
    clip_y2 = y2;

//unimportant issues
#ifndef __MMI_UI_MENU_SLIM__
    gdi_layer_get_active(&act_layer);
    if (MMI_current_menu_type == LIST_MENU && clip_y1 < m->parent_list->y && m->parent_list->act_layer_handle == act_layer)
    {
        clip_y1 = m->parent_list->y;
    } 
#endif
    if (y2 >= menu_y2)
    {
        clip_y2 = menu_y2;
    }
//unimportant issues
#ifndef __MMI_UI_MENU_SLIM__
    gui_set_clip(clip_x1, clip_y1, clip_x2, clip_y2);
#else
gui_set_clip_preset(clip_x1, clip_y1, clip_x2, clip_y2);
#endif
    
    if (ret_flag_ext & UI_MENUITEM_EXT_SHOW_SEPARATORLINE || mi->ext_flags & UI_MENUITEM_EXT_SHOW_SEPARATORLINE)
    {
        gui_draw_horizontal_line(x1 + GUI_MENUITEM_TEXT_RIGHT_GAP, x2 - GUI_MENUITEM_TEXT_RIGHT_GAP, y1, *(current_MMI_theme->list_grid_line_color));//list_separator_color
    }
    else if (ret_flag_ext & UI_MENUITEM_EXT_SHOW_DOWN_SEPARATORLINE || mi->ext_flags & UI_MENUITEM_EXT_SHOW_DOWN_SEPARATORLINE)
    {
    #ifdef __MMI_MAINLCD_96X64__
        gui_draw_horizontal_line(x1, x2, y2, *(current_MMI_theme->list_grid_line_color));//list_separator_color
    #else /* __MMI_MAINLCD_96X64__ */
        alpha_layer = dm_get_scr_bg_layer();
        gdi_effect_alpha_blending_rect(
                            alpha_layer, 
                            x1, 
                            y2, 
                            x2, 
                            y2, 
                            current_MMI_theme->list_grid_line_alpha * 255 / 100,
                            current_MMI_theme->list_grid_line_color->r,
                            current_MMI_theme->list_grid_line_color->g,
                            current_MMI_theme->list_grid_line_color->b);
    #endif /* __MMI_MAINLCD_96X64__ */
    }
#if defined(__MMI_OP11_HOMESCREEN_0301__) || defined(__MMI_OP11_HOMESCREEN_0302__)
    else if (ret_flag_ext & UI_MENUITEM_EXT_SHOW_DOWN_SHORT_SEPARATORLINE || mi->ext_flags & UI_MENUITEM_EXT_SHOW_DOWN_SHORT_SEPARATORLINE)
    {
        gui_draw_horizontal_line(x1, x + m->text_coordinates[0].x, y2, *(current_MMI_theme->list_grid_line_color));//list_separator_color
    }
#endif  // defined(__MMI_OP11_HOMESCREEN_0301__) || defined(__MMI_OP11_HOMESCREEN_0302__)

    if (m->post_display_function)
    {
        gui_swla_log_start("PST");
        m->post_display_function(item, common_item_data, x, y);
        gui_swla_log_stop("PST");
    }
    gui_pop_text_clip();
    gui_pop_clip();

#if  !defined(__MMI_BASIC_UI_STYLE__) || !defined(__MMI_UI_HINTS_IN_MENUITEM__)
#if(UI_ENABLE_POP_UP_DESCRIPTIONS)
    if (m->parent_list && m->parent_list->gui_display_pop_up_description &&
        (flags & UI_MENUITEM_STATE_FOCUSSED) && !(m->ext_flags & UI_MENUITEM_EXT_SHOW_IN_MARQUEE))
    {
#if defined(__MMI_UI_LIST_SUPPORT_UNEQUAL_HEIGHT_ITEM__)
        if (flags_ext & UI_MENUITEM_EXT_INEQUAL_HEIGHT)
            m->parent_list->gui_display_pop_up_description(x, y, m->width, i_height);
        else
#endif
            m->parent_list->gui_display_pop_up_description(x, y, m->width, m->height);
    }
#endif /* (UI_ENABLE_POP_UP_DESCRIPTIONS) */ 
#endif
}


/*****************************************************************************
 * FUNCTION
 *  gui_show_two_line_icontext_list_menuitem
 * DESCRIPTION
 *  Show an two line style icontext list menu item.
 * PARAMETERS
 *  item                    [IN]        private icontext list menu item object
 *  common_item_data        [IN]        common icontext list menu item object
 *  x                       [IN]        x
 *  y                       [IN]        y
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_show_two_line_icontext_list_menuitem(void *item, void *common_item_data, UI_filled_area **f)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    fixed_icontext_list_menuitem *m = (fixed_icontext_list_menuitem*) common_item_data;
    fixed_icontext_list_menuitem_type *mi = (fixed_icontext_list_menuitem_type*) item;
    U32 flags;
    fixed_icontext_list_menuitem cm; /* common menuitem */

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    flags = mi->flags;
    flags |= m->flags;
    
    if (!(flags & UI_MENUITEM_DISABLE_BACKGROUND_ALWAYS))
    {
        /* verify two line menuitem highlight image dimension */
        cm = *m;
        cm.height *= 2;
        
        cm.focussed_filler = current_MMI_theme->menuitem_two_line_highlight_filler;
#ifdef __MMI_FTE_SUPPORT__
        cm.focussed_without_sc_filler = current_MMI_theme->menuitem_two_line_highlight_filler;
#else
        cm.focussed_without_sc_filler = current_MMI_theme->menuitem_two_line_highlight_filler;//menuitem_two_line_highlight_without_scroll_filler
#endif

#ifdef __MMI_UI_TRANSPARENT_EFFECT__
        /* This is to replace the UI_FILLED_AREA_TYPE_TRANSPARENT_COLOR flag and alpha value from the themecomponent.h */
        if ((cm.focussed_filler->flags & 0xFF) != UI_FILLED_AREA_TYPE_BITMAP &&
            (cm.focussed_filler->flags & 0xFF) != UI_FILLED_AREA_TYPE_IMAGE_RIGHT_ALIGN &&
            (cm.focussed_filler->flags & 0xFF) != UI_FILLED_AREA_TYPE_IMAGE_LEFT_ALIGN)
        {
            fixed_two_line_menuitem_transparent_filled_area = *(cm.focussed_filler);
            cm.focussed_filler = &fixed_two_line_menuitem_transparent_filled_area;
            fixed_two_line_menuitem_transparent_filled_area.flags |= UI_FILLED_AREA_TYPE_TRANSPARENT_COLOR;
            fixed_two_line_menuitem_transparent_filled_area.c.alpha = HIGHLIGHTER_COLOR_OPACITY_VALUE;
        }
#endif /* __MMI_UI_TRANSPARENT_EFFECT__ */ 
        *f = gui_list_get_focussed_filler((gui_common_menuitem_base_struct*) &cm);
    }           
    return;
}


/*****************************************************************************
 * FUNCTION
 *  gui_measure_fixed_icontext_list_menuitem
 * DESCRIPTION
 *  Measure an icontext list menu item for dimension.
 * PARAMETERS
 *  item                    [IN]        private icontext list menu item object
 *  common_item_data        [IN]        common icontext list menu item object
 *  width                   [OUT]       item width
 *  height                  [OUT]       item height
 * RETURNS
 *  void
 *****************************************************************************/
void gui_measure_fixed_icontext_list_menuitem(void *item, void *common_item_data, S32 *width, S32 *height)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    fixed_icontext_list_menuitem *t = (fixed_icontext_list_menuitem*) common_item_data;
#if defined(__MMI_UI_LIST_SUPPORT_UNEQUAL_HEIGHT_ITEM__)
    S32 index = 0;
#endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    *width = t->width;
    *height = t->height;

#if defined(__MMI_UI_LIST_SUPPORT_UNEQUAL_HEIGHT_ITEM__)
    if (t->ext_flags & UI_MENUITEM_EXT_INEQUAL_HEIGHT
        && MMI_fixed_list_menu.item_get_height_function)
    {
        if (MMI_fixed_list_menu.current_displayed_item == -1)
	    {
            index = MMI_fixed_list_menu.highlighted_item;
        }
        else
        {
            index = MMI_fixed_list_menu.current_displayed_item;
        }

        *height = MMI_fixed_list_menu.item_get_height_function(index);
    }
#endif

    if (MMI_fixed_list_menu.current_displayed_item == -1 && t->ext_flags & UI_MENUITEM_SHOW_HIGHLIGHTED_HINT)
    {
#if defined(__MMI_BASIC_UI_STYLE__) && defined(__MMI_UI_HINTS_IN_MENUITEM__)
        if (gui_menuitem_has_hint((gui_common_menuitem_base_struct*) t, 1))
#endif
        {
            *height += t->height;
        }
    }
}
/*****************************************************************************
 * FUNCTION
 *  gui_highlight_fixed_icontext_list_menuitem
 * DESCRIPTION
 *  Highlight an icontext list menu item (not visually).
 * PARAMETERS
 *  item                    [IN]        private icontext list menu item object
 *  common_item_data        [IN]        common icontext list menu item object 
 * RETURNS
 *  void
 *****************************************************************************/
void gui_highlight_fixed_icontext_list_menuitem(void *item, void *common_item_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    fixed_icontext_list_menuitem_type *t = (fixed_icontext_list_menuitem_type*) item;
    fixed_icontext_list_menuitem *m = (fixed_icontext_list_menuitem*) common_item_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    GUI_current_fixed_icontext_list_menuitem_common_data = m;
    GUI_current_fixed_icontext_list_menuitem_data = t;
    if (m->ext_flags & UI_MENUITEM_EXT_DISABLED_SCROLL)
    {
        gui_fixed_icontext_list_menuitem_stop_scroll();        
        GUI_current_fixed_icontext_list_menuitem_scroll = 0;
        m->scroll_x = 0;
    }
    else if (!(m->ext_flags & UI_MENUITEM_EXT_KEEP_SCROLLING))
    {        
        gui_fixed_icontext_list_menuitem_stop_scroll();
        gui_fixed_icontext_list_menuitem_start_scroll();
    }
    if (t->flags & UI_MENUITEM_DISABLE_HIGHLIGHT)
    {
        return;
    }
    t->flags |= UI_MENUITEM_STATE_FOCUSSED;
}


/*****************************************************************************
 * FUNCTION
 *  gui_remove_highlight_fixed_icontext_list_menuitem
 * DESCRIPTION
 *  Remove the highlight of an icontext list menu item (not visually).
 * PARAMETERS
 *  item                    [IN]        private icontext list menu item object
 *  common_item_data        [IN]        common icontext list menu item object   
 * RETURNS
 *  void
 *****************************************************************************/
void gui_remove_highlight_fixed_icontext_list_menuitem(void *item, void *common_item_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i;
    fixed_icontext_list_menuitem_type *t = (fixed_icontext_list_menuitem_type*) item;
    fixed_icontext_list_menuitem *m = (fixed_icontext_list_menuitem*) common_item_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_fixed_icontext_list_menuitem_stop_scroll();
    t->flags &= ~UI_MENUITEM_STATE_FOCUSSED;
    for (i = 0; i < m->n_icon_columns; i++)
    {
        if (t->item_icon_handles[i] != GDI_ERROR_HANDLE)
        {
            gdi_image_stop_animation(t->item_icon_handles[i]);
            t->item_icon_handles[i] = GDI_ERROR_HANDLE;
        }
    }
#ifdef __MMI_UI_HINT_TOGGLE_TRANSITION__
    gui_reset_pop_up_description_transition_ex(&wgui_pop_up_description);
#endif 
}


/*****************************************************************************
 *
 * TWOSTATE MENUITEM                                                             
 *                                                                           
 *
 *
 *****************************************************************************/

/*****************************************************************************
 * FUNCTION
 *  gui_set_fixed_twostate_menuitem_current_theme
 * DESCRIPTION
 *  Apply the current theme to a common two-state menu item.
 * PARAMETERS
 *  m           [IN]        common two-state menu item object
 * RETURNS
 *  void
 *****************************************************************************/
void gui_set_fixed_twostate_menuitem_current_theme(fixed_twostate_menuitem *m)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_set_fixed_twostate_menuitem_theme(m, current_fixed_twostate_menuitem_theme);
}


/*****************************************************************************
 * FUNCTION
 *  gui_set_fixed_twostate_menuitem_theme
 * DESCRIPTION
 *  Apply the given theme to a common two-state menu item.
 * PARAMETERS
 *  m           [IN]        common two-state menu item object
 *  t           [IN]        two-state menu item theme
 * RETURNS
 *  void
 *****************************************************************************/
void gui_set_fixed_twostate_menuitem_theme(fixed_twostate_menuitem *m, UI_fixed_twostate_menuitem_theme *t)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    m->disabled_filler = t->disabled_filler;
    m->disabled_text_color = t->disabled_text_color;
    m->flags |= t->flags;
    m->focussed_filler = t->focussed_filler;
    m->focussed_without_sc_filler = t->focussed_without_sc_filler;

#ifdef __MMI_UI_TRANSPARENT_EFFECT__
    if ( m->focussed_filler &&
        (m->focussed_filler->flags & 0xFF) != UI_FILLED_AREA_TYPE_BITMAP &&
        (m->focussed_filler->flags & 0xFF) != UI_FILLED_AREA_TYPE_IMAGE_RIGHT_ALIGN &&
        (m->focussed_filler->flags & 0xFF) != UI_FILLED_AREA_TYPE_IMAGE_LEFT_ALIGN)
    {
        fixed_twostate_menuitem_transparent_filled_area = *(m->focussed_filler);
        m->focussed_filler = &fixed_twostate_menuitem_transparent_filled_area;
        fixed_twostate_menuitem_transparent_filled_area.flags |= UI_FILLED_AREA_TYPE_TRANSPARENT_COLOR;
        fixed_twostate_menuitem_transparent_filled_area.c.alpha = HIGHLIGHTER_COLOR_OPACITY_VALUE;
    }
#endif /* __MMI_UI_TRANSPARENT_EFFECT__ */ 

    m->focussed_text_color = t->focussed_text_color;
    m->normal_filler = t->normal_filler;
    m->normal_text_color = t->normal_text_color;
    m->selected_filler = t->selected_filler;
    m->selected_text_color = t->selected_text_color;
    m->text_font = t->text_font;
}


/*****************************************************************************
 * FUNCTION
 *  gui_create_fixed_twostate_menuitem
 * DESCRIPTION
 *  Create a common two-state menu item.
 * PARAMETERS
 *  m               [IN]        common two-state menu item object
 *  width           [IN]        width
 *  height          [IN]        height
 *  ON_icon         [IN]        ON icon
 *  OFF_icon        [IN]        OFF icon
 * RETURNS
 *  void
 *****************************************************************************/
void gui_create_fixed_twostate_menuitem(fixed_twostate_menuitem *m, S32 width, S32 height, PU8 ON_icon, PU8 OFF_icon)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	memset(m, 0, sizeof(fixed_twostate_menuitem));
    m->width = width;
    m->height = height;
    gui_set_fixed_twostate_menuitem_current_theme(m);
    m->OFF_icon = OFF_icon;
    m->ON_icon = ON_icon;
    
    /* calculate the icon position*/
    if (m->OFF_icon != UI_NULL_IMAGE)
    {
        S32 icon_width, icon_height;

        gui_measure_image(m->OFF_icon, &icon_width, &icon_height);
        if (m->flags & UI_MENUITEM_CENTER_ICON_X)
        {
            m->icon_x = (m->width >> 1) - (icon_width >> 1);
        }
        if (m->flags & UI_MENUITEM_CENTER_ICON_Y)
        {
            m->icon_y = (m->height >> 1) - (icon_height >> 1);
        }
    }
    m->scroll_width = width;
}


/*****************************************************************************
 * FUNCTION
 *  gui_fixed_twostate_menuitem_set_text_position
 * DESCRIPTION
 *  Set the text position of a common two-state menu item.
 * PARAMETERS
 *  m           [IN]        common two-state menu item object
 *  x           [IN]        text x
 *  y           [IN]        text y
 * RETURNS
 *  void
 *****************************************************************************/
void gui_fixed_twostate_menuitem_set_text_position(fixed_twostate_menuitem *m, S32 x, S32 y)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_menuitem_set_text_position(m, x, y);
}


/*****************************************************************************
 * FUNCTION
 *  gui_fixed_twostate_menuitem_set_icon_position
 * DESCRIPTION
 *  Set the icon position of a common two-state menu item.
 * PARAMETERS
 *  m           [IN]        common two-state menu item object
 *  x           [IN]        icon x
 *  y           [IN]        icon y
 * RETURNS
 *  void
 *****************************************************************************/
void gui_fixed_twostate_menuitem_set_icon_position(fixed_twostate_menuitem *m, S32 x, S32 y)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_menuitem_set_icon_position(m, x, y);
}


/*****************************************************************************
 * FUNCTION
 *  gui_fixed_twostate_menuitem_set_icons
 * DESCRIPTION
 *  Set the ON/OFF icons of a common two-state menu item.
 * PARAMETERS
 *  m               [IN]        common two-state menu item object
 *  ON_icon         [IN]        ON icon
 *  OFF_icon        [IN]        OFF icon
 * RETURNS
 *  void
 *****************************************************************************/
void gui_fixed_twostate_menuitem_set_icons(fixed_twostate_menuitem *m, PU8 ON_icon, PU8 OFF_icon)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    m->OFF_icon = OFF_icon;
    m->ON_icon = ON_icon;
    
    /* calculate the icon position */
    if (m->OFF_icon != UI_NULL_IMAGE)
    {
        S32 icon_width, icon_height;

        gui_measure_image(m->OFF_icon, &icon_width, &icon_height);
        if (m->flags & UI_MENUITEM_CENTER_ICON_X)
        {
            m->icon_x = (m->width >> 1) - (icon_width >> 1);
        }
        if (m->flags & UI_MENUITEM_CENTER_ICON_Y)
        {
            m->icon_y = (m->height >> 1) - (icon_height >> 1);
        }
    }
    if (m->icon_x > m->text_x)
    {
        m->scroll_width = m->icon_x - m->text_x;
    }
    else
    {
        m->scroll_width = m->width - m->text_x;
    }
}


/*****************************************************************************
 * FUNCTION
 *  gui_resize_fixed_twostate_menuitem
 * DESCRIPTION
 *  Resize a common two-state menu item.
 * PARAMETERS
 *  m           [IN]        common two-state menu item object
 *  width       [IN]        new width
 *  height      [IN]        new height
 * RETURNS
 *  void
 *****************************************************************************/
void gui_resize_fixed_twostate_menuitem(fixed_twostate_menuitem *m, S32 width, S32 height)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_resize_fixed_icontext_menuitem((fixed_icontext_menuitem *)m, width, height);
}

/* Text scrolling related functions within the menu item */

fixed_twostate_menuitem *GUI_current_fixed_twostate_menuitem_common_data = NULL;
fixed_twostate_menuitem_type *GUI_current_fixed_twostate_menuitem_data = NULL;
U8 GUI_current_fixed_twostate_menuitem_scroll = 0;
S32 GUI_current_fixed_twostate_menuitem_x;
S32 GUI_current_fixed_twostate_menuitem_y;
//	S32 GUI_current_fixed_twostate_menuitem_scroll_counter = 0;


/*****************************************************************************
 * FUNCTION
 *  scrolling_text_draw_twostate_single_line_background
 * DESCRIPTION
 *  Draw background for the scrolling twostate single line menu item.
 * PARAMETERS
 *  x1          [IN]        x1
 *  y1          [IN]        y1
 *  x2          [IN]        x2
 *  y2          [IN]        y2
 * RETURNS
 *  void
 *****************************************************************************/
static void scrolling_text_draw_twostate_single_line_background(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    scrolling_text_draw_background_filler(
        GUI_current_fixed_twostate_menuitem_x,
        GUI_current_fixed_twostate_menuitem_y,
        GUI_current_fixed_twostate_menuitem_x + MMI_fixed_twostate_menuitem.width - 1,
        GUI_current_fixed_twostate_menuitem_y + MMI_fixed_twostate_menuitem.height - 1,
        &fixed_single_line_menuitem_filled_area,
        MMI_FALSE);
}


/*****************************************************************************
 * FUNCTION
 *  gui_fixed_twostate_menuitem_scroll_handler
 * DESCRIPTION
 *  Scroll handler of the highlighted two-state menu item.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gui_fixed_twostate_menuitem_scroll_handler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 flags = GUI_current_fixed_twostate_menuitem_common_data->flags;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
#ifdef  __MMI_UI_LIST_FLASH_HIGHLIGHT_EFFECTS__
    /* If the flash feeling list effect is running, wait for it to finish. */
    if ((gui_get_current_list_effect() == MMI_UI_LIST_HIGHLIGHT_EFFECT_FLASH_FEELING) &&
        (MMI_current_menu_type == LIST_MENU) &&
        (g_flash_feel_state != GUI_LIST_EFFECT_FLASH_FEELING_STOP))        
    {
        return;
    }
#endif  /* __MMI_UI_LIST_FLASH_HIGHLIGHT_EFFECTS__ */    
#endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */
#ifndef __MMI_UI_MENU_SLIM__
    gui_list_in_scroll = MMI_TRUE;
#endif

    flags |= GUI_current_fixed_twostate_menuitem_data->flags;
    gui_handle_scrolling_text(&gui_current_scroll_text[0]);
        /* 
         * WAP might display two-state fixed list as list box outside of content region.
         * We should disable scrolling text when it locates outside the content region, 
         * otherwise it will overlap with the title bar or softkey.
         */
        if (GUI_current_fixed_twostate_menuitem_y >= MMI_content_y &&
            (GUI_current_fixed_twostate_menuitem_y + GUI_current_fixed_twostate_menuitem_common_data->height - 1)
            < (MMI_content_y + MMI_content_height))
        {
            GUI_current_fixed_twostate_menuitem_common_data->ext_flags |= UI_MENUITEM_EXT_SHOW_IN_MARQUEE;

        #ifdef __MMI_UI_TRANSPARENT_EFFECT__
            if (!gui_is_current_transparency_with_multi_layer())
            {
                gui_fixed_twostate_menuitem_disable_transparent_effect(GUI_current_fixed_twostate_menuitem_common_data);        /* To hide text below scrolling text */
            }
        #endif /* __MMI_UI_TRANSPARENT_EFFECT__ */ 
            
        #ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
            ////////////////// MOVE FROM FUNCTION BEGINNING ///
            gui_reset_current_list_effect(); 
        #endif 

        #ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
            gui_restore_current_list_effect();
        #endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */


        #ifdef __MMI_UI_TRANSPARENT_EFFECT__
            gui_fixed_twostate_menuitem_enable_transparent_effect(GUI_current_fixed_twostate_menuitem_common_data);     /* To enable transparency */
        #endif 

            GUI_current_fixed_twostate_menuitem_common_data->ext_flags &= ~UI_MENUITEM_EXT_SHOW_IN_MARQUEE;
    }
#ifndef __MMI_UI_MENU_SLIM__		
    gui_list_in_scroll = MMI_FALSE;
#endif
}


/*****************************************************************************
 * FUNCTION
 *  gui_fixed_twostate_menuitem_start_scroll
 * DESCRIPTION
 *  Start scrolling for the highlighted two-state menu item.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gui_fixed_twostate_menuitem_start_scroll(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    fixed_twostate_menuitem_type *t = (fixed_twostate_menuitem_type*) GUI_current_fixed_twostate_menuitem_data;
    fixed_twostate_menuitem *m = (fixed_twostate_menuitem*) GUI_current_fixed_twostate_menuitem_common_data;
    U32 flags;
#ifdef __MMI_UI_LIST_HIGHLIGHT_BOLD__
    stFontAttribute highlight_font;
#endif /*__MMI_UI_LIST_HIGHLIGHT_BOLD*/


    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    t->flags |= UI_MENUITEM_STATE_FOCUSSED;
    flags = m->flags;
    flags |= t->flags;
    if (MMI_current_menu_type == LIST_MENU)
    {
        
      if(!gui_show_list_menu_check_scrollbar(&MMI_fixed_list_menu))
        {
            MMI_fixed_list_menu.item_resize_function(MMI_fixed_list_menu.width - 4, 0);
        }
        else
        {
#ifdef __MMI_FTE_SUPPORT__
            MMI_fixed_list_menu.item_resize_function(MMI_fixed_list_menu.width - GUI_MENUITEM_X1_GAP - GUI_MENUITEM_X2_GAP, 0);
#else
            MMI_fixed_list_menu.item_resize_function(MMI_fixed_list_menu.width - MMI_fixed_list_menu.vbar.width - GUI_MENUITEM_X1_GAP - GUI_MENUITEM_X2_GAP, 0);
#endif
        }
    }

    gui_list_menuitem_set_font((gui_common_menuitem_base_struct *) m, flags);

    m->text_width = gui_get_string_width(t->item_text);
    m->scroll_x = 0;

    if (m->text_width > m->scroll_width)
    {
        GUI_current_fixed_twostate_menuitem_scroll = 1;
    #ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
        if (gui_get_current_list_effect() && gblock_list_effect != 1)
        {
            gui_register_callback_menuitem_scroll(gui_fixed_twostate_menuitem_scroll_handler);
        }
    #endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */ 
        gui_create_scrolling_text(
            &gui_current_scroll_text[0],
            0,
            0,
            0,
            0,
            (UI_string_type)t->item_text,
            gui_fixed_twostate_menuitem_scroll_handler,
            scrolling_text_draw_twostate_single_line_background,
            MMI_fixed_twostate_menuitem.focussed_text_color,
            MMI_fixed_twostate_menuitem.focussed_text_color);
        if (flags & UI_MENUITEM_TWO_DIRECTION_SCROLL)
        {
            gui_current_scroll_text[0].flags = UI_SCROLLING_TEXT_TWO_DIRECTION_SCROLL;
        }
        gui_scrolling_text_start(&gui_current_scroll_text[0]);
    }
    else
#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
    {
        gui_register_callback_menuitem_scroll(gui_dummy_scroll_handler_for_list_effects);
        GUI_current_fixed_twostate_menuitem_scroll = 0;
    }
#else /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */ 
    {
        GUI_current_fixed_twostate_menuitem_scroll = 0;
    }
#endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */ 
}


/*****************************************************************************
 * FUNCTION
 *  gui_fixed_twostate_menuitem_stop_scroll
 * DESCRIPTION
 *  Stop scrolling for the highlighted two-state menu item.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gui_fixed_twostate_menuitem_stop_scroll(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
//    gui_cancel_timer(gui_fixed_twostate_menuitem_start_scroll);
    if (GUI_current_fixed_twostate_menuitem_scroll)
    {
        gui_cancel_timer(gui_fixed_twostate_menuitem_scroll_handler);
        GUI_current_fixed_twostate_menuitem_scroll = 0;
    }
#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
    gui_register_callback_menuitem_scroll(gui_dummy_scroll_handler_for_list_effects);
    gui_restore_current_list_effect();
#endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */ 
}


/*****************************************************************************
 * FUNCTION
 *  gui_get_fixed_twostate_menuitem_flag
 * DESCRIPTION
 *  get the flag of two-state menu item.
 * PARAMETERS
 *  item                    [IN]        private two-state menu item object
 *  common_item_data        [IN]        common two-state menu item object
 * RETURNS
 *  flag
 *****************************************************************************/
void gui_get_fixed_twostate_menuitem_flag(void *item, void *common_item_data, S32 index, U32* flags, U32* flags_ext)
{
  gui_get_fixed_menuitem_flag(item, common_item_data, index, flags,flags_ext, 1); 
}


/*****************************************************************************
 * FUNCTION
 *  gui_show_fixed_twostate_menuitem
 * DESCRIPTION
 *  Show a two-state menu item.
 * PARAMETERS
 *  item                    [IN]        private two-state menu item object
 *  common_item_data        [IN]        common two-state menu item object
 *  x                       [IN]        x
 *  y                       [IN]        y
 * RETURNS
 *  void
 *****************************************************************************/
void gui_show_fixed_twostate_menuitem(void *item, void *common_item_data, S32 x, S32 y)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x1, y1, x2, y2, menu_y1, menu_y2;
    S32 text_x, text_y;
    color text_color;
    UI_filled_area *f = NULL;
    fixed_twostate_menuitem *m = (fixed_twostate_menuitem*) common_item_data;
    fixed_twostate_menuitem_type *mi = (fixed_twostate_menuitem_type*) item;
    U32 flags, flags_ext;
//    U32 ret_flag = 0, ret_flag_ext = 0;
    UI_string_type _text;

    /* byte animation_flag=0; */
    S32 sw, sh;
    S32 icon_width, icon_height;

#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
    PU8 temp_on_icon = m->ON_icon;
    PU8 temp_off_icon = m->OFF_icon;
#endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */ 
    S32 text_width;
    gdi_handle old_alpha_layer=GDI_NULL_HANDLE;
#ifdef __MMI_UI_LIST_HIGHLIGHT_BOLD__
    stFontAttribute highlight_font;
#endif /*__MMI_UI_LIST_HIGHLIGHT_BOLD*/
    PU8 temp_icon = NULL;
    S32 scrolling_text_x;
//unimportant issues
#ifndef __MMI_UI_MENU_SLIM__
    S32 clip_y1;
    gdi_handle act_layer = GDI_NULL_HANDLE;
#endif
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    _text = mi->item_text;
    g_gui_menuitem_need_scroll = MMI_FALSE;

//get flags
   gui_get_fixed_menuitem_flags_int(item, common_item_data, &flags, &flags_ext);
    if (flags & UI_MENUITEM_STATE_FOCUSSED)
    {
        GUI_current_fixed_twostate_menuitem_x = x;
        GUI_current_fixed_twostate_menuitem_y = y;
    }

    /* calculate the text position based on font */
    gui_list_menuitem_set_font((gui_common_menuitem_base_struct *) m, flags);
    gui_measure_string(_text, &sw, &sh);
    if (flags & UI_MENUITEM_CENTER_TEXT_X)
    {
        m->text_x = (m->width >> 1) - (sw >> 1);
    }
    if (flags & UI_MENUITEM_CENTER_TEXT_Y)
    {
        m->text_y = (m->height >> 1) - (sh >> 1);
    }

    x1 = x;
    y1 = y;
    x2 = x1 + m->width - 1;
    y2 = y1 + m->height - 1;

//get menu region h
     gui_get_menu_region_V(m, &menu_y1, &menu_y2);

    if (g_current_display_half_menuitem)
    {
        menu_y2 -= 1;
    }

    if (mmi_fe_get_r2l_state())
    {
        text_x = x2 - m->text_x;
    }
    else
    {
        text_x = m->text_x;
    }

    text_y = m->text_y;

#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
#ifdef  __MMI_UI_LIST_FLASH_HIGHLIGHT_EFFECTS__
    /* To hide the text and icon of the menuitem up to the last frame for flash feel effect */
    if (gblock_list_effect == 0)
    {
        if (gui_get_current_list_effect() == MMI_UI_LIST_HIGHLIGHT_EFFECT_FLASH_FEELING &&
            MMI_current_menu_type == LIST_MENU)
        {
            if (g_flash_feel_state != GUI_LIST_EFFECT_FLASH_FEELING_LAST_FRAME)
            {
                if (flags & UI_MENUITEM_STATE_FOCUSSED)
                {
                    temp_on_icon = UI_NULL_IMAGE;
                    temp_off_icon = UI_NULL_IMAGE;
                    flags |= UI_MENUITEM_DISABLE_TEXT_DISPLAY;
                }
            }
        }
    }
#endif  /* __MMI_UI_LIST_FLASH_HIGHLIGHT_EFFECTS__ */    
#endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */ 

    if ((flags & UI_MENUITEM_STATE_FOCUSSED) && !(flags & UI_MENUITEM_DISABLE_HIGHLIGHT))
    {
        f = gui_list_get_focussed_filler((gui_common_menuitem_base_struct*) m);
        fixed_single_line_menuitem_filled_area = *f;
        text_color = m->focussed_text_color;
    }
    else if (flags & UI_MENUITEM_STATE_DISABLED)
    {
        if (!(flags & UI_MENUITEM_DISABLE_BACKGROUND))
        {
            f = m->disabled_filler;
        }
        text_color = m->focussed_text_color;
    }
    else if (flags & UI_MENUITEM_STATE_SELECTED)
    {
        if (!(flags & UI_MENUITEM_DISABLE_BACKGROUND))
        {
            f = m->selected_filler;
        }
#ifdef __MMI_SCREEN_ROTATE__
        if (mmi_frm_is_screen_width_height_swapped() && !current_MMI_theme->rotated_bkg_filler)
        {
            text_color = UI_COLOR_BLACK;
        }
        else
#endif  // __MMI_SCREEN_ROTATE__
        {
            text_color = m->normal_text_color;
        }
    }
    else
    {
        if (!(flags & UI_MENUITEM_DISABLE_BACKGROUND))
        {
            f = m->normal_filler;
        }
        
#ifdef __MMI_SCREEN_ROTATE__
        if (mmi_frm_is_screen_width_height_swapped() && !current_MMI_theme->rotated_bkg_filler)
        {
            text_color = UI_COLOR_BLACK;
        }
        else
#endif  // __MMI_SCREEN_ROTATE__
        {
            text_color = m->normal_text_color;
        }
    }
	//unimportant issues
	#ifndef __MMI_UI_MENU_SLIM__
    if (flags_ext & UI_MENUITEM_EXT_SHOW_DISABLED)
    {
        text_color = m->disabled_text_color;
    }
	#endif
    gui_push_clip();
//unimportant issues
#ifndef __MMI_UI_MENU_SLIM__
    clip_y1 = y1;

    gdi_layer_get_active(&act_layer);
    if (MMI_current_menu_type == LIST_MENU && clip_y1 < m->parent_list->y && m->parent_list->act_layer_handle == act_layer)
    {
        clip_y1 = m->parent_list->y;
        if (m->parent_list->normal_filler && m->parent_list->normal_filler->flags & UI_FILLED_AREA_SINGLE_BORDER)
        {
            clip_y1 += 1;
        }
    }
#endif
    if (y1 >= menu_y2)
    {
//unimportant issues
#ifndef __MMI_UI_MENU_SLIM__
        gui_set_clip(x1, menu_y2, x2 + 2, menu_y2);
#else
	    gui_set_clip_preset(x1, menu_y2, x2 + 2, menu_y2);
#endif
    }
    else if (y2 >= menu_y2)
    {
//unimportant issues
#ifndef __MMI_UI_MENU_SLIM__
        gui_set_clip(x1, clip_y1, x2 + 2, menu_y2);
#else
        
        gui_set_clip_preset(x1, y1, x2 + 2, menu_y2);
#endif
    }
    else
    {
//unimportant issues
#ifndef __MMI_UI_MENU_SLIM__
		gui_set_clip(x1, clip_y1, x2 + 2, y2 + 2);
#else      
        gui_set_clip_preset(x1, y1, x2 + 2, y2 + 2);
#endif
    }

    if (f != NULL && !g_slide_effect->in_flatten)
    {
 	#ifdef __MMI_SUPPORT_DUMP_SCREEN_STRING__
 	#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
        if (is_draw_next_frame_list_highlight_effect_value())
    #endif
        {
            mmi_frm_dss_set_menu_highlight(MMI_SCREEN_HIGHLIGHT_TWOSTATE_ITEM);
        }
    #endif
        old_alpha_layer = gui_list_set_alpha_blending_layer();
        set_start_position_and_item_parameters_for_list_highlighter_effect(item, common_item_data, x1, y1);

#ifdef  __OP01_FWPBW__
        gui_draw_filled_area(x1 + m->text_x, y1, x2, y2, f);
#else   // __OP01_FWPBW__
    #ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
        gui_draw_list_filled_area(x1, y1, x2, y2, f);
    #else /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */ 
	  #ifdef __MMI_MAINLCD_96X64__
        gui_menuitem_draw_list_filler(x1 + m->text_x, y1, x2, y2, f, MMI_TRUE, MMI_FALSE);
	  #else
        gui_menuitem_draw_list_filler(x1, y1, x2, y2, f, MMI_TRUE, MMI_FALSE);
	  #endif
    #endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */ 
#endif//  __OP01_FWPBW__
        gui_list_reset_alpha_blending_layer(old_alpha_layer);
    }

    old_alpha_layer = gui_list_set_alpha_blending_layer_ex(flags, MMI_TRUE);

    if (flags & UI_MENUITEM_STATE_SELECTED)
    {
#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
        /* To hide the ON icon of the menuitem up to the last frame for flash feel effect */
        if (temp_on_icon != UI_NULL_IMAGE)
        {
            temp_icon = temp_on_icon;
        }
#else /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */ 
        if (m->ON_icon != UI_NULL_IMAGE)
        {
            temp_icon = m->ON_icon;
        }
#endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */ 
    }
    else
    {
#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
        /* To hide the ON icon of the menuitem up to the last frame for flash feel effect */
        if (temp_off_icon != UI_NULL_IMAGE)
        {
            temp_icon = temp_off_icon;
        }
#else /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */ 
        if (m->OFF_icon != UI_NULL_IMAGE)
        {
            temp_icon = m->OFF_icon;
        }
#endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */ 
    }

    if (temp_icon)
    {
        gui_measure_image(temp_icon, &icon_width, &icon_height);
        if (m->flags & UI_MENUITEM_CENTER_ICON_X)
        {
            m->icon_x = (m->width >> 1) - (icon_width >> 1);
        }
        if (m->flags & UI_MENUITEM_CENTER_ICON_Y)
        {
            m->icon_y = (m->height >> 1) - (icon_height >> 1);
        }
        if (!mmi_fe_get_r2l_state())
        {
            gui_show_image(x1 + m->icon_x, y1 + m->icon_y, temp_icon);
        }
        else
        {
            /* R2L icons are right-aligned. */    
            gui_show_image(
                x2 - m->icon_x - icon_width + 1,
                y1 + m->icon_y,
                temp_icon);
        }
    }
    gui_pop_clip();

    gui_list_reset_alpha_blending_layer(old_alpha_layer);
    gui_push_clip();
    if (!(flags & UI_MENUITEM_DISABLE_TEXT_DISPLAY))
    {
#ifdef  __MMI_VECTOR_FONT_SUPPORT__
        old_alpha_layer = gui_list_set_alpha_blending_layer_ex(flags, MMI_TRUE);
#endif
        gui_push_text_clip();
//unimportant issues
#ifndef __MMI_UI_MENU_SLIM__
        if (m->icon_x > m->text_x)
        {
            if (y1 >= menu_y2)
            {
                gui_set_clip(x1, menu_y2, x2 - (m->width - m->icon_x), menu_y2);
            }
            else if (y2 >= menu_y2)
            {
                gui_set_clip(x1, clip_y1, x2 - (m->width - m->icon_x), menu_y2);
            }
            else
            {
                gui_set_clip(x1, clip_y1, x2 - (m->width - m->icon_x), y2);
            }
            text_width = x2 - (m->width - m->icon_x) - x1 + 1;
        }
        else
        {
            if (y1 >= menu_y2)
            {
                gui_set_text_clip(x1 + m->text_x, menu_y2, x2, menu_y2);
            }
            else if (y2 >= menu_y2)
            {
                gui_set_text_clip(x1 + m->text_x, clip_y1, x2, menu_y2);
            }
            else
            {
                gui_set_text_clip(x1 + m->text_x, clip_y1, x2, y2);
            }
            text_width = x2 - (x1 + m->text_x) + 1;
        }
//hujin
      //  if (r2lMMIFlag)
		if(mmi_fe_get_r2l_state())
        {
            if (y1 >= menu_y2)
            {
                gui_set_clip(x1, menu_y2, x2 - m->text_x, menu_y2);
            }
            else if (y2 >= menu_y2)
            {
                gui_set_clip(x1, clip_y1, x2 - m->text_x, menu_y2);
            }
            else
            {
                gui_set_clip(x1, clip_y1, x2 - m->text_x, y2);
            }
        }
#else
   
if (m->icon_x > m->text_x)
{
	if (y1 >= menu_y2)
	{
		gui_set_clip_preset(x1, menu_y2, x2 - (m->width - m->icon_x), menu_y2);
	}
	else if (y2 >= menu_y2)
	{
		gui_set_clip_preset(x1, y1, x2 - (m->width - m->icon_x), menu_y2);
	}
	else
	{
		gui_set_clip_preset(x1, y1, x2 - (m->width - m->icon_x), y2);
	}
	text_width = x2 - (m->width - m->icon_x) - x1 + 1;
}
else
{
	if (y1 >= menu_y2)
	{
		gui_set_text_clip_preset(x1 + m->text_x, menu_y2, x2, menu_y2);
	}
	else if (y2 >= menu_y2)
	{
		gui_set_text_clip_preset(x1 + m->text_x, y1, x2, menu_y2);
	}
	else
	{
		gui_set_text_clip_preset(x1 + m->text_x, y1, x2, y2);
	}
	text_width = x2 - (x1 + m->text_x) + 1;
}

//hujin
      //  if (r2lMMIFlag)
		if(mmi_fe_get_r2l_state())

{
	if (y1 >= menu_y2)
	{
		gui_set_clip_preset(x1, menu_y2, x2 - m->text_x, menu_y2);
	}
	else if (y2 >= menu_y2)
	{
		gui_set_clip_preset(x1, y1, x2 - m->text_x, menu_y2);
	}
	else
	{
		gui_set_clip_preset(x1, y1, x2 - m->text_x, y2);
	}
}
#endif
        gui_menuitem_adjust_text_clip_for_right_gap(m);

#ifdef __MMI_FTE_SUPPORT__    
        if (MMI_current_menu_type == LIST_MENU)
        {
            text_width -= GUI_MENUITEM_TEXT_RIGHT_GAP;
        }
#else
#ifdef __MMI_UI_LIST_SLIDE_EFFECT__
        if ((MMI_current_menu_type == LIST_MENU) && gui_menuitem_is_image_highlight(m))
        {
            text_width -= GUI_MENUITEM_TEXT_RIGHT_GAP;
        }
#endif/*__MMI_UI_LIST_SLIDE_EFFECT__*/
#endif/*__MMI_FTE_SUPPORT__*/
        if (mmi_fe_get_r2l_state())
        {
            gui_move_text_cursor(text_x, y1 + text_y);
        }
        else
        {
            gui_move_text_cursor(x1 + text_x, y1 + text_y);
        }

        if (f && (f->flags & UI_FILLED_AREA_BORDER))
        {
            text_width -= 1;
        }

        gui_set_text_color(text_color); /* set text clor */
        gui_set_line_height(sh);

        if ((sw > text_width) && !(flags & UI_MENUITEM_TRUNCATE_CONTENT))
        {
            if ((flags & UI_MENUITEM_MARQUEE_SCROLL) || (flags & UI_MENUITEM_TWO_DIRECTION_SCROLL))
            {
                g_gui_menuitem_need_scroll = MMI_TRUE;
            }
        }
        
#ifdef __MMI_UI_LIST_TRUNCATE_ITEM__
        if ((mi->flags & UI_MENUITEM_STATE_FOCUSSED) && (GUI_current_fixed_twostate_menuitem_scroll || g_gui_menuitem_need_scroll) &&
            ((y1 + text_y >= menu_y1 && y1 + text_y + sh <= menu_y2) || !g_current_display_half_menuitem))
        {
			if (mmi_fe_get_r2l_state())
            {
                scrolling_text_x = x1 + text_x - text_width + 2;
            }
            else
            {
                scrolling_text_x = x1 + text_x;
            }
            
            gui_menuitem_redraw_scrolling_text(
                &(gui_current_scroll_text[0]),
                scrolling_text_x,
                y1 + text_y,
                text_width,
                sh + 1,
                NULL,
                NULL
            );
        }
        else
        {
            if (mmi_fe_get_r2l_state())
            {
                gui_print_truncated_text(text_x, y1 + text_y, text_width, _text);
            }
            else
            {
                gui_print_truncated_text(x1 + text_x, y1 + text_y, text_width, _text);
            }
            
        }  
#else
        if ((mi->flags & UI_MENUITEM_STATE_FOCUSSED) && (GUI_current_fixed_twostate_menuitem_scroll || g_gui_menuitem_need_scroll) &&
            ((y1 + text_y >= menu_y1 && y1 + text_y + sh <= menu_y2) || !g_current_display_half_menuitem))
        {
            if (mmi_fe_get_r2l_state())
            {
                scrolling_text_x = text_x - text_width + 1;
            }
            else
            {
                scrolling_text_x = x1 + text_x;
            }
            
            gui_menuitem_redraw_scrolling_text(
                &(gui_current_scroll_text[0]),
                scrolling_text_x,
                y1 + text_y,
                text_width,
                sh + 1,
                NULL,
                NULL
            );
        }
        else
        {
            gui_print_text(_text);
        }   
#endif
        gui_pop_text_clip();
#ifdef  __MMI_VECTOR_FONT_SUPPORT__
        gui_list_reset_alpha_blending_layer(old_alpha_layer);
#endif
    }

    gui_pop_clip();

#if(UI_ENABLE_POP_UP_DESCRIPTIONS)
    if (m->parent_list && m->parent_list->gui_display_pop_up_description &&
        (flags & UI_MENUITEM_STATE_FOCUSSED) && !(m->ext_flags & UI_MENUITEM_EXT_SHOW_IN_MARQUEE))
    {
        m->parent_list->gui_display_pop_up_description(x, y, m->width, m->height);      /* display popp description */
    }
#endif /* (UI_ENABLE_POP_UP_DESCRIPTIONS) */ 
}


#ifdef __MMI_TOUCH_SCREEN__

/*****************************************************************************
 * FUNCTION
 *  gui_fixed_twostate_menuitem_translate_pen_event
 * DESCRIPTION
 *  Pen event handler of the two-state menu item.
 * PARAMETERS
 *  item                    [IN]        private two-state menu item
 *  common_item_data        [IN]        common two-state menu item
 *  item_x                  [IN]        item x1
 *  item_y                  [IN]        item y1
 *  pen_event               [IN]        pen event type
 *  x                       [IN]        pen x
 *  y                       [IN]        pen y
 *  menuitem_event          [OUT]       pen event result
 *  menuitem_param          [IN]        pen event parameter
 * RETURNS
 *  Return MMI_TRUE if the pen event is handled; otherwise, MMI_FALSE.  
 *****************************************************************************/
BOOL gui_fixed_twostate_menuitem_translate_pen_event(
        void *item,
        void *common_item_data,
        S32 item_x,
        S32 item_y,
        mmi_pen_event_type_enum pen_event,
        S16 x,
        S16 y,
        gui_list_pen_enum *menuitem_event,
        gui_pen_event_param_struct *menuitem_param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#ifndef __MMI_FTE_SUPPORT__
    
    BOOL ret = MMI_TRUE, pen_inside = MMI_FALSE;
    S32 iwidth, iheight;

    fixed_twostate_menuitem *m = (fixed_twostate_menuitem*) common_item_data;
#endif  // #ifndef  __MMI_FTE_SUPPORT__    

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(item);
#if defined(__MMI_FTE_SUPPORT__) || defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN)

    return MMI_FALSE;
#else

    *menuitem_event = GUI_LIST_PEN_NONE;
    GUI_PEN_EVENT_PARAM_SET_VOID(menuitem_param);

    if (m->OFF_icon != UI_NULL_IMAGE)
    {
        gui_measure_image(m->OFF_icon, &iwidth, &iheight);
    }
    else
    {
        iwidth = iheight = 0;
    }

    item_x += m->icon_x;
    item_y += m->icon_y;
    if (mmi_fe_get_r2l_state())
    {
        if (PEN_CHECK_BOUND(x, y, MMI_fixed_list_menu.width - m->icon_x- iwidth, item_y, iwidth, iheight))
        {
            pen_inside = MMI_TRUE;
        }
    }
    else
    {
        if (PEN_CHECK_BOUND(x, y, item_x, item_y, iwidth, iheight))
        {
            pen_inside = MMI_TRUE;
        }
    }

    if (pen_event == MMI_PEN_EVENT_DOWN)
    {
        if (!pen_inside)
        {
            /* The following pen events will not be directed to twostate menuitem */
            ret = MMI_FALSE;
        }
        else
        {
            *menuitem_event = GUI_LIST_PEN_DOWN_ON_STATE_BOX;
        }
    }
    else if (pen_event == MMI_PEN_EVENT_UP)
    {
        if (MMI_fixed_list_menu.pen_state.pen_down_state_box)
        {
            // for ssp pen up, doesn't handle the click cb function
            /* Outside of the image, it is not controlled by menuitem */
            if (pen_inside)
            {
                *menuitem_event = GUI_TWOSTATE_PEN_TOGGLE;
            }
        }
        else
        {
            *menuitem_event = GUI_TWOSTATE_PEN_TOGGLE;
        }
    }

    return ret;
#endif
}
#endif /* __MMI_TOUCH_SCREEN__ */ 


/*****************************************************************************
 * FUNCTION
 *  gui_measure_fixed_twostate_menuitem
 * DESCRIPTION
 *  Measure a two-state menu item for dimension.
 * PARAMETERS
 *  item                    [IN]        private two-state menu item object
 *  common_item_data        [IN]        common two-state menu item object
 *  width                   [OUT]       item width
 *  height                  [OUT]       item height
 * RETURNS
 *  void
 *****************************************************************************/
void gui_measure_fixed_twostate_menuitem(void *item, void *common_item_data, S32 *width, S32 *height)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    fixed_twostate_menuitem *t = (fixed_twostate_menuitem*) common_item_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(item);
    *width = t->width;
    *height = t->height;
}


/*****************************************************************************
 * FUNCTION
 *  gui_highlight_fixed_twostate_menuitem
 * DESCRIPTION
 *  Highlight a two-state menu item (not visually).
 * PARAMETERS
 *  item                    [IN]        private two-state menu item object
 *  common_item_data        [IN]        common two-state menu item object    
 * RETURNS
 *  void
 *****************************************************************************/
void gui_highlight_fixed_twostate_menuitem(void *item, void *common_item_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    fixed_twostate_menuitem_type *t = (fixed_twostate_menuitem_type*) item;
    fixed_twostate_menuitem *m = (fixed_twostate_menuitem*) common_item_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    GUI_current_fixed_twostate_menuitem_common_data = m;
    GUI_current_fixed_twostate_menuitem_data = t;
    if (m->ext_flags & UI_MENUITEM_EXT_DISABLED_SCROLL)
    {
        gui_fixed_twostate_menuitem_stop_scroll();
        GUI_current_fixed_twostate_menuitem_scroll = 0;
        m->scroll_x = 0;
    }
    else
    {
        gui_fixed_twostate_menuitem_stop_scroll();
        gui_fixed_twostate_menuitem_start_scroll();
    }
    
    if (t->flags & UI_MENUITEM_DISABLE_HIGHLIGHT)
    {
        return;
    }
    t->flags |= UI_MENUITEM_STATE_FOCUSSED;
#ifdef __IV_TTS__
	if(NPR_TTS_get_menu_read_enble())
	NPR_TTS_menu_read(t->item_text );
#endif	
}


/*****************************************************************************
 * FUNCTION
 *  gui_remove_highlight_fixed_twostate_menuitem
 * DESCRIPTION
 *  Remove the highlight of a two-state menu item (not visually).
 * PARAMETERS
 *  item                    [IN]        private two-state menu item object
 *  common_item_data        [IN]        common two-state menu item object  
 * RETURNS
 *  void
 *****************************************************************************/
void gui_remove_highlight_fixed_twostate_menuitem(void *item, void *common_item_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    fixed_twostate_menuitem_type *t = (fixed_twostate_menuitem_type*) item;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_fixed_twostate_menuitem_stop_scroll();
    UI_UNUSED_PARAMETER(common_item_data);
    t->flags &= ~UI_MENUITEM_STATE_FOCUSSED;
#ifdef __MMI_UI_HINT_TOGGLE_TRANSITION__
    gui_reset_pop_up_description_transition_ex(&wgui_pop_up_description);
#endif 
}


/*****************************************************************************
 * FUNCTION
 *  gui_block_list_animation_highlight
 * DESCRIPTION
 *  Block the list effect. Save and set the current effect to none.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gui_block_list_animation_highlight(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gblock_list_animation_highlight = 1;
}


/*****************************************************************************
 * FUNCTION
 *  gui_unblock_list_animation_highlight
 * DESCRIPTION
 *  Unblock the list effect. Set the current effect from the backup.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gui_unblock_list_animation_highlight(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gblock_list_animation_highlight = 0;
}

#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__

#define LIST_EFFECT_TYPE__(A) MMI_UI_LIST_HIGHLIGHT_EFFECT_##A
#define LIST_EFFECT_TYPE_(A)  LIST_EFFECT_TYPE__(A)
#define LIST_EFFECT_TYPE(A)      LIST_EFFECT_TYPE_(A)

static gui_list_effect_styles goriginal_list_effect = LIST_EFFECT_TYPE_(UI_LIST_EFFECT_TYPE);
static gui_list_effect_styles current_list_effect = LIST_EFFECT_TYPE_(UI_LIST_EFFECT_TYPE);
static gui_list_effect_styles backup_current_list_effect = LIST_EFFECT_TYPE_(UI_LIST_EFFECT_TYPE);

#if defined(__MMI_UI_LIST_FLASH_HIGHLIGHT_EFFECTS__)||defined(__MMI_UI_LIST_TRANSPARENCY_HIGHLIGHT_EFFECTS__)
static UI_filled_area backup_filler;
#endif

extern fixed_list_menu MMI_fixed_list_menu;
#ifdef __MMI_UI_LIST_SLIDE_EFFECT__
extern gdi_handle anim_handle;
#endif


/*****************************************************************************
 * FUNCTION
 *  gui_draw_list_highlight_effect_last_frame
 * DESCRIPTION
 *  Draw the last frame of list highlight effect.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gui_draw_list_highlight_effect_last_frame(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!ghighlight_item || !ghighlight_common_item_data)
    {
        MMI_DBG_ASSERT(0);
        return;
    }

    gui_lock_double_buffer();
    MMI_fixed_list_menu.item_display_function(ghighlight_item, ghighlight_common_item_data, gstartX1, gstartY1);
    gui_unlock_double_buffer();
    gui_BLT_double_buffer(xstart_effect, ystart_effect, xend_effect, yend_effect);
}


#ifdef __MMI_UI_LIST_ANIMATE_HIGHLIGHT_EFFECTS__
/*****************************************************************************
 * FUNCTION
 *  gui_draw_animated_highlight_filler
 * DESCRIPTION
 *  Draw the animated highlighter filler.
 * PARAMETERS
 *  x1      [IN]        x1
 *  y1      [IN]        y1
 *  x2      [IN]        x2
 *  y2      [IN]        y2
 *  f       [IN]        filler
 * RETURNS
 *  void
 *****************************************************************************/
void gui_draw_animated_highlight_filler(S32 x1, S32 y1, S32 x2, S32 y2, UI_filled_area *f)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 max_frame;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    xstart_effect = x1;
    ystart_effect = y1;
    xend_effect = x2;
    yend_effect = y2;

    /* get the number of frames in the animation */
    gdi_image_get_frame_count(get_image(IMG_LIST_HIGHLIGHTER), &max_frame);  

    gui_push_and_set_clip(x1, y1, x2, y2);

    if (list_highlight_effect_current_frame == max_frame)
    {   
        /* the last frame is already shown, go back to the first frame */
        gdi_image_draw_animation_single_frame(x1, y1, get_image(IMG_LIST_HIGHLIGHTER), 0);
        list_highlight_effect_current_frame++;
        gui_pop_clip();

        gui_draw_list_highlight_effect_last_frame();
        
        list_highlight_effect_current_frame = 0;
        
        #ifndef __MMI_UI_MENU_SLIM__
        /* prevent from drawing the menu item twice when it is already scrolling */
        gui_start_timer(UI_text_menuitem_scroll_time, gui_scroll_start_handler_for_list_effects);
		#endif
    }
    else if (list_highlight_effect_current_frame < max_frame)
    {   
        /* there are still frames to be shown, start the timer again to show the next frame */      
        gdi_image_draw_frames(x1, y1, get_image(IMG_LIST_HIGHLIGHTER), (S16) list_highlight_effect_current_frame);      /* Show frame by frame no. */
        list_highlight_effect_current_frame++;  /* Treat list_highlight_effect_current_frame as frame no. */
        gui_pop_clip();
        
        gui_start_timer(LIST_ANIMATION_HIGHLIGHTER_TIMER, gui_callback_highlighter_text_filler);
    }
    else
    {
        gui_pop_clip();
    }
}
#endif  /* __MMI_UI_LIST_ANIMATE_HIGHLIGHT_EFFECTS__ */


#ifdef  __MMI_UI_LIST_TRANSPARENCY_HIGHLIGHT_EFFECTS__
/*****************************************************************************
 * FUNCTION
 *  gui_draw_transparent_color_filler
 * DESCRIPTION
 *  Draw the transparent highlighter filler with increasing opacity.
 * PARAMETERS
 *  x1      [IN]        x1
 *  y1      [IN]        y1
 *  x2      [IN]        x2 
 *  y2      [IN]        y2
 *  f       [IN]        filler
 * RETURNS
 *  void
 *****************************************************************************/
void gui_draw_transparent_color_filler(S32 x1, S32 y1, S32 x2, S32 y2, UI_filled_area *f)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    xstart_effect = x1;
    ystart_effect = y1;
    xend_effect = x2;
    yend_effect = y2;

    if (list_highlight_effect_current_frame + TRANSPARENCY_START_OPACITY_VALUE == 0)
    {
        /* Last alpha value is reached. nothing more to do. */
        list_highlight_effect_current_frame = 0;

        #ifndef __MMI_UI_MENU_SLIM__
        /* prevent from drawing the menu item twice when it is already scrolling */
        gui_start_timer(UI_text_menuitem_scroll_time, gui_scroll_start_handler_for_list_effects);
		#endif
        
        return;
    }
    else
    {
        gui_push_and_set_clip(x1, y1, x2, y2);
        
        backup_filler = *f;
        if ((list_highlight_effect_current_frame + TRANSPARENCY_START_OPACITY_VALUE) > MAX_OPACITY_VALUE_FACTOR)        /* For start Transparency from some values greater then 0. */
        {
            /* To disable Transparent effect flag for flash feeling */
            if (backup_filler.flags & UI_FILLED_AREA_TYPE_TRANSPARENT_COLOR && (wgui_is_wallpaper_on_bottom() == MMI_FALSE))    /* 072505 Calvin modified */
            {
                backup_filler.flags &= ~UI_FILLED_AREA_TYPE_TRANSPARENT_COLOR;
            }
            gui_draw_filled_area(x1, y1, x2, y2, &backup_filler);
            list_highlight_effect_current_frame = -TRANSPARENCY_START_OPACITY_VALUE;
        }
        else
        {

            backup_filler.flags |= UI_FILLED_AREA_TYPE_TRANSPARENT_COLOR;
            backup_filler.c.alpha =
                (list_highlight_effect_current_frame + TRANSPARENCY_START_OPACITY_VALUE) * MAX_OPACITY_VALUE_FACTOR;

            gui_draw_filled_area(x1, y1, x2, y2, &backup_filler);
            list_highlight_effect_current_frame += JUMP_IN_HIGHLIGHTERS_EFFECTS_FRAME;
        }
        gui_start_timer(LIST_TRANSPARENT_HIGHLIGHTER_TIMER, gui_callback_highlighter_text_filler);
        gui_pop_clip();
    }
}
#endif  /* __MMI_UI_LIST_TRANSPARENCY_HIGHLIGHT_EFFECTS__ */


#ifdef  __MMI_UI_LIST_FLASH_HIGHLIGHT_EFFECTS__
/*****************************************************************************
 * FUNCTION
 *  gui_draw_flash_feeling_filler
 * DESCRIPTION
 *  Draw the flash feeling highlighter filler with increasing width
 * PARAMETERS
 *  x1      [IN]        x1
 *  y1      [IN]        y1
 *  x2      [IN]        x2 
 *  y2      [IN]        y2
 *  f       [IN]        filler
 * RETURNS
 *  void
 *****************************************************************************/
void gui_draw_flash_feeling_filler(S32 x1, S32 y1, S32 x2, S32 y2, UI_filled_area *f)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 f_count;    /* f_count is the gap of texts upper and below positions from the top and bottom of the highlighter and uses as the no of frames */

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    f_count = get_menu_item_height() >> 1;

    if (list_highlight_effect_current_frame > f_count)
    {
        list_highlight_effect_current_frame = 0;
        g_flash_feel_state = GUI_LIST_EFFECT_FLASH_FEELING_STOP;
       
       #ifndef __MMI_UI_MENU_SLIM__
        /* prevent from drawing the menu item twice when it is already scrolling */
        gui_start_timer(UI_text_menuitem_scroll_time, gui_scroll_start_handler_for_list_effects);
	   #endif
    }
    else if (list_highlight_effect_current_frame == f_count)
    {
        /* To achieve the original hilighter height */
        xstart_effect = x1;
        ystart_effect = y1;
        xend_effect = x2;
        yend_effect = y2;
        backup_filler = *f;
        /* To disable Transparent effect flag for flash feeling */
        if (backup_filler.flags & UI_FILLED_AREA_TYPE_TRANSPARENT_COLOR && (wgui_is_wallpaper_on_bottom() == MMI_FALSE))        /* 072505 Calvin modified */
        {
            backup_filler.flags &= ~UI_FILLED_AREA_TYPE_TRANSPARENT_COLOR;
        }
        gui_draw_filled_area(x1, y1, x2, y2, &backup_filler);
        list_highlight_effect_current_frame++;
        g_flash_feel_state = GUI_LIST_EFFECT_FLASH_FEELING_LAST_FRAME;
        gui_start_timer(LIST_FLASH_HIGHLIGHTER_TIMER, gui_callback_highlighter_text_filler);
    }
    else
    {
        xstart_effect = x1;
        ystart_effect = y1 + f_count - list_highlight_effect_current_frame;
        xend_effect = x2;
        yend_effect = y2 - f_count + list_highlight_effect_current_frame;
        gui_push_and_set_clip(x1, ystart_effect, x2, yend_effect);
        backup_filler = *f;
        /* To disable Transparent effect flag for flash feeling */
        if (backup_filler.flags & UI_FILLED_AREA_TYPE_TRANSPARENT_COLOR)
        {
            backup_filler.flags &= ~UI_FILLED_AREA_TYPE_TRANSPARENT_COLOR;
        }
        gui_draw_filled_area(x1, y1, x2, y2, &backup_filler);
        gui_pop_clip();
        list_highlight_effect_current_frame += JUMP_IN_HIGHLIGHTERS_EFFECTS_FRAME;
        if ((list_highlight_effect_current_frame) >= f_count)
        {
            list_highlight_effect_current_frame = f_count;  /* To handle counter if jump more then 1 in list_highlight_effect_current_frame */
        }

        g_flash_feel_state = GUI_LIST_EFFECT_FLASH_FEELING_RUNNING;

        /* To call filler repeatedly */
        gui_start_timer(LIST_FLASH_HIGHLIGHTER_TIMER, gui_callback_highlighter_text_filler);
    }
}
#endif  /* __MMI_UI_LIST_FLASH_HIGHLIGHT_EFFECTS__ */


/*****************************************************************************
 * FUNCTION
 *  gui_get_current_list_effect
 * DESCRIPTION
 *  Get the current list effect.
 * PARAMETERS
 *  void
 * RETURNS
 *  List effect type.
 *****************************************************************************/
S32 gui_get_current_list_effect(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return current_list_effect;
}


/*****************************************************************************
 * FUNCTION
 *  gui_set_current_list_effect
 * DESCRIPTION
 *  Set the current list effect.
 * PARAMETERS
 *  list_style      [IN]        list effect
 * RETURNS
 *  void
 *****************************************************************************/
void gui_set_current_list_effect(gui_list_effect_styles list_style)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    current_list_effect = list_style;
    backup_current_list_effect = current_list_effect;
}


/*****************************************************************************
 * FUNCTION
 *  gui_reset_current_list_effect
 * DESCRIPTION
 *  Reset the current list effect to none.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gui_reset_current_list_effect(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (current_list_effect != MMI_UI_LIST_HIGHLIGHT_EFFECT_NONE)
    {
        backup_current_list_effect = current_list_effect;
    }
    current_list_effect = MMI_UI_LIST_HIGHLIGHT_EFFECT_NONE;
}


/*****************************************************************************
 * FUNCTION
 *  gui_set_current_list_effect_to_default
 * DESCRIPTION
 *  Set the current list effect to default.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gui_set_current_list_effect_to_default(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    current_list_effect = goriginal_list_effect;
    backup_current_list_effect = goriginal_list_effect; /* restore as current list effect is also set to default */
}


/*****************************************************************************
 * FUNCTION
 *  gui_restore_current_list_effect
 * DESCRIPTION
 *  Restore the current list effect from the backup_current_list_effect.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gui_restore_current_list_effect(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (gblock_list_effect != 1)
    {
        current_list_effect = backup_current_list_effect;
    }
}


/*****************************************************************************
 * FUNCTION
 *  gui_block_list_effect
 * DESCRIPTION
 *  Block the list effect. Save and set the current effect to none.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gui_block_list_effect(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gblock_list_effect = 1;
    gui_reset_current_list_effect();
}


/*****************************************************************************
 * FUNCTION
 *  gui_unblock_list_effect
 * DESCRIPTION
 *  Unblock the list effect. Set the current effect from the backup.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gui_unblock_list_effect(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gblock_list_effect = 0;
    gui_restore_current_list_effect();
}


/*****************************************************************************
 * FUNCTION
 *  gui_draw_list_filled_area
 * DESCRIPTION
 *  Draw the list effect filler.
 * PARAMETERS
 *  x1      [IN]        x1
 *  y1      [IN]        y1
 *  x2      [IN]        x2
 *  y2      [IN]        y2
 *  f       [IN]        filler
 * RETURNS
 *  void
 *****************************************************************************/
void gui_draw_list_filled_area(S32 x1, S32 y1, S32 x2, S32 y2, UI_filled_area *f)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
   // S32 count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (gblock_list_effect == 1)
    {
        gui_reset_current_list_effect();    /* This is to block the effects in case of inline edit screens. */
    }
    switch (current_list_effect)
    {
        case MMI_UI_LIST_HIGHLIGHT_EFFECT_NONE:
		{
            /* Disable transparent effect if we do not have screen background layer. */
            gui_menuitem_draw_list_filler(
                x1, y1, x2, y2, f, 
                (MMI_BOOL)((gblock_list_effect!=0) ||(gblock_list_animation_highlight!=0)), 
                (MMI_BOOL)(gui_is_current_transparency_with_multi_layer()== 0));
            break;
		}

#ifdef  __MMI_UI_LIST_TRANSPARENCY_HIGHLIGHT_EFFECTS__
        case MMI_UI_LIST_HIGHLIGHT_EFFECT_TRANSPARENCY:
            /* For increasing opacity highlighter */
            gui_draw_transparent_color_filler(x1, y1, x2, y2, f);
            break;
#endif  /* __MMI_UI_LIST_TRANSPARENCY_HIGHLIGHT_EFFECTS__ */

#ifdef  __MMI_UI_LIST_FLASH_HIGHLIGHT_EFFECTS__
        case MMI_UI_LIST_HIGHLIGHT_EFFECT_FLASH_FEELING:
            /* For flash type of highlighter */
            gui_draw_flash_feeling_filler(x1, y1, x2, y2, f);
            break;
#endif  /* __MMI_UI_LIST_FLASH_HIGHLIGHT_EFFECTS__ */            

#ifdef  __MMI_UI_LIST_ANIMATE_HIGHLIGHT_EFFECTS__
        case MMI_UI_LIST_HIGHLIGHT_EFFECT_ANIMATION:
            /* For showing any animation as a gif file in place of highlighter */
            gui_draw_animated_highlight_filler(x1, y1, x2, y2, f);
            break;
#endif  /* __MMI_UI_LIST_ANIMATE_HIGHLIGHT_EFFECTS__ */            
            
        case MMI_UI_LIST_HIGHLIGHT_EFFECT_SLIDE:
            gui_menuitem_draw_list_filler(x1, y1, x2, y2, f, (MMI_BOOL)((gblock_list_effect!=0) || (gblock_list_animation_highlight!=0)), MMI_FALSE);
			#ifndef __MMI_UI_MENU_SLIM__
			/* start menu item scrolling */
            // TODO: SHOULD START SCROLLING WHEN THE SLIDING IS FINISHED
            
            gui_start_timer(UI_text_menuitem_scroll_time, gui_scroll_start_handler_for_list_effects);
			#endif
            break;
    }
}



/*****************************************************************************
 * FUNCTION
 *  gui_stop_list_highlight_effect
 * DESCRIPTION
 *  Stop timer for the list effect.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gui_stop_list_highlight_effect(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef  __MMI_UI_LIST_FLASH_HIGHLIGHT_EFFECTS__
    g_flash_feel_state = GUI_LIST_EFFECT_FLASH_FEELING_STOP;
#endif
    list_highlight_effect_current_frame = 0;
    list_highlight_effect_times = 0;
#ifdef __MMI_UI_LIST_SLIDE_EFFECT__
    if (anim_handle)
    {
        gdi_anim_stop(anim_handle);
        anim_handle = GDI_NULL_HANDLE;
    }
#endif
    gui_cancel_timer(gui_callback_highlighter_text_filler);
    gui_list_effect_slide_stop();
}


/*****************************************************************************
 * FUNCTION
 *  gui_register_callback_menuitem_scroll
 * DESCRIPTION
 *  Set the associated scroll handler for the list effect.
 * PARAMETERS
 *  f       [IN]        menu item scroll handler
 * RETURNS
 *  void
 *****************************************************************************/
void gui_register_callback_menuitem_scroll(void (*f)(void))
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_call_menuitem_scroll = f;
}




/*****************************************************************************
 * FUNCTION
 *  gui_dummy_scroll_handler_for_list_effects
 * DESCRIPTION
 *  Dummy scroll handler for the list effect.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gui_dummy_scroll_handler_for_list_effects(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* For the cases where text size is not suitable for scroll */
}


/*****************************************************************************
 * FUNCTION
 *  is_draw_next_frame_list_highlight_effect_value
 * DESCRIPTION
 *  Return the is_draw_next_frame_list_highlight_effect value.
 * PARAMETERS
 *  void
 * RETURNS
 *  0: the menu item is not drawed for the list effect. 1: yes.
 *****************************************************************************/
S32 is_draw_next_frame_list_highlight_effect_value(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return is_draw_next_frame_list_highlight_effect;
}

/*****************************************************************************
 * FUNCTION
 *  set_is_draw_next_frame_list_highlight_effect_value
 * DESCRIPTION
 *  Set the is_draw_next_frame_list_highlight_effect value.
 * PARAMETERS
 *  the menu item is not drawed for the list effect
 * RETURNS
 *  void
 *****************************************************************************/
void set_is_draw_next_frame_list_highlight_effect_value(MMI_BOOL draw_next_frame)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (draw_next_frame)
        is_draw_next_frame_list_highlight_effect = 1;
    else
        is_draw_next_frame_list_highlight_effect = 0;
}




#endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */ 

#if (defined __MMI_UI_TWO_LINE_MENUITEM_STYLES__ || defined __MMI_UI_HINTS_IN_MENUITEM__)

/*****************************************************************************
 * FUNCTION
 *  UI_dummy_set_current_two_line_menuitem_data
 * DESCRIPTION
 *  Dummy function to set the two-line menu item data.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void UI_dummy_set_current_two_line_menuitem_data(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return;
}


/*****************************************************************************
 * FUNCTION
 *  UI_dummy_reset_current_two_line_menuitem_data
 * DESCRIPTION
 *  Dummy function to reset the two-line menu item data
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void UI_dummy_reset_current_two_line_menuitem_data(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return;
}

#endif /* (defined __MMI_UI_TWO_LINE_MENUITEM_STYLES__ || defined __MMI_UI_HINTS_IN_MENUITEM__) */ 


#ifdef __MMI_UI_TWO_LINE_MENUITEM_STYLES__

/*****************************************************************************
 * FUNCTION
 *  UI_dummy_show_two_line_menuitem_part
 * DESCRIPTION
 *  Dummy function to show the two-line menu item part.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void UI_dummy_show_two_line_menuitem_part(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return;
}


/*****************************************************************************
 * FUNCTION
 *  UI_dummy_move_two_line_menuitem_part
 * DESCRIPTION
 *  Dummy function to move the two-line menu item part.
 * PARAMETERS
 *  x       [IN]        new x
 *  y       [IN]        new y
 * RETURNS
 *  void
 *****************************************************************************/
void UI_dummy_move_two_line_menuitem_part(S32 x, S32 y)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return;
}


/*****************************************************************************
 * FUNCTION
 *  UI_dummy_resize_two_line_menuitem_part
 * DESCRIPTION
 *  Dummy function to resize the two-line menu item part.
 * PARAMETERS
 *  x       [IN]        width
 *  y       [IN]        height
 * RETURNS
 *  void
 *****************************************************************************/
void UI_dummy_resize_two_line_menuitem_part(S32 x, S32 y)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return;
}


/*****************************************************************************
 * FUNCTION
 *  UI_dummy_get_two_line_menuitem_height
 * DESCRIPTION
 *  Dummy function to check whether the current menuitem is two line.
 * PARAMETERS
 *  void
 * RETURNS
 *  0: single line. 1: two line. 
 *****************************************************************************/
pBOOL UI_dummy_get_two_line_menuitem_height(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  UI_dummy_two_line_get_thumbnail_flags
 * DESCRIPTION
 *  Dummy function to return thumbnail flags.
 * PARAMETERS
 *  void
 * RETURNS
 *  Thumbnail flag.
 *****************************************************************************/
U8 UI_dummy_two_line_get_thumbnail_flags(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return 0;
}


/*----------------------------------------------------------------------------
The various callbakcs for two line menu item are defined below this line.
----------------------------------------------------------------------------*/
U8(*gui_two_line_get_thumbnail_flags) (void) = UI_dummy_two_line_get_thumbnail_flags;
void (*gui_reset_two_line) (void) = UI_dummy_function;
void (*gui_two_line_toggle_thumbnail_direction) (void) = UI_dummy_function;
void (*gui_set_current_two_line_menuitem_data) (void) = UI_dummy_set_current_two_line_menuitem_data;
#endif /* __MMI_UI_TWO_LINE_MENUITEM_STYLES__ */ 

#if (defined __MMI_UI_TWO_LINE_MENUITEM_STYLES__ || defined __MMI_UI_HINTS_IN_MENUITEM__)
void (*gui_reset_current_two_line_menuitem_data) (void) = UI_dummy_set_current_two_line_menuitem_data;
#endif 

#if defined __MMI_UI_TWO_LINE_MENUITEM_STYLES__
void (*gui_show_two_line_menuitem_part) (void) = UI_dummy_show_two_line_menuitem_part;
void (*gui_move_two_line_menuitem_part) (S32 x, S32 y) = UI_dummy_move_two_line_menuitem_part;
void (*gui_resize_two_line_menuitem_part) (S32 x, S32 y) = UI_dummy_resize_two_line_menuitem_part;

pBOOL(*gui_get_two_line_menuitem_height) (void) = UI_dummy_get_two_line_menuitem_height;
#endif /* defined __MMI_UI_TWO_LINE_MENUITEM_STYLES__ */ 

// TODO: modify function name

void gui_fixed_two_line_set_filler(UI_filled_area *filler, UI_filled_area *filler_without_sc)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if (defined __MMI_UI_TWO_LINE_MENUITEM_STYLES__ || defined __MMI_UI_HINTS_IN_MENUITEM__)
    fixed_two_line_menuitem_filler = filler;
    fixed_two_line_menuitem_without_sc_filler = filler_without_sc;
#endif    
}


#if (defined __MMI_UI_TWO_LINE_MENUITEM_STYLES__ || defined __MMI_UI_HINTS_IN_MENUITEM__)
extern wgui_get_display_style get_current_menu_item_displaystyle;

/*****************************************************************************
 * FUNCTION
 *  gui_show_two_line_background
 * DESCRIPTION
 *  Show the two line background (highlight filler).
 * PARAMETERS
 *  x1       [IN]   x coordinate of the top-left point
 *  y1       [IN]   y coordinate of the top-left point
 *  x2       [IN]   x coordinate of the bottom-right point
 *  y2       [IN]   y coordinate of the bottom-right point
 * RETURNS
 *  void
 *****************************************************************************/
void gui_show_two_line_background(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    UI_filled_area *highlight_filler;
    fixed_icontext_menuitem m;
    gdi_handle old_alpha_layer=GDI_NULL_HANDLE;
    S32 count;
    S32 current_x1, current_y1, current_x2, current_y2;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_UI_TRANSPARENT_EFFECT__ 
    if (!gui_is_current_transparency_with_multi_layer())
    {
        gui_fixed_icontext_disable_transparent_effect(&MMI_fixed_icontext_menuitem);    /* To hide text below scrolling text */
    }
#endif /* __MMI_UI_TRANSPARENT_EFFECT__ */ 

    /* verify two line menuitem highlight image dimension */
	m = MMI_fixed_icontext_menuitem;
	m.height *= 2;
#ifdef __MMI_UI_TWO_LINE_MENUITEM_IMG_SELECTOR__
    if (get_current_menu_item_displaystyle &&  
        get_current_menu_item_displaystyle(MMI_fixed_list_menu.highlighted_item)== TWO_LINE_MENUITEM_STYLE_DISPLAY_HORIZONTAL_SELECT)
    {
    #if !defined(__MMI_OP11_MENU_12MATRIX__)
        gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_TRANSPARENT);
        if ((MMI_fixed_list_menu.flags & UI_LIST_MENU_DISABLE_SCROLLBAR) ||
            ((MMI_fixed_list_menu.flags & UI_LIST_MENU_AUTO_DISABLE_SCROLLBAR) && 
            (MMI_fixed_list_menu.displayed_items >= MMI_fixed_list_menu.n_items)))
        {
            gdi_image_draw_resized(GUI_current_fixed_icontext_menuitem_x, GUI_current_fixed_icontext_menuitem_y, m.width, m.height, get_image(IMG_SELECTOR_FILLER));
        }
        else
        {
            gdi_image_draw(GUI_current_fixed_icontext_menuitem_x, GUI_current_fixed_icontext_menuitem_y, get_image(IMG_SELECTOR_FILLER));
        }
    #endif  /* !defined(__MMI_OP11_MENU_12MATRIX__) */
    }
#if !defined(__MMI_OP11_MENU_12MATRIX__)   
    else
#endif
#endif
    {
        if (fixed_two_line_menuitem_filler)
        {
            m.focussed_filler = fixed_two_line_menuitem_filler;
        }
        else
        {   
            m.focussed_filler = current_MMI_theme->menuitem_two_line_highlight_filler;
        }
        if (fixed_two_line_menuitem_without_sc_filler)
        {
            m.focussed_without_sc_filler = fixed_two_line_menuitem_without_sc_filler;
        }
        else
        {   
            m.focussed_without_sc_filler = current_MMI_theme->menuitem_two_line_highlight_filler;//menuitem_two_line_highlight_without_scroll_filler
        }
    
#ifdef __MMI_UI_TRANSPARENT_EFFECT__
    /* This is to replace the UI_FILLED_AREA_TYPE_TRANSPARENT_COLOR flag and alpha value from the themecomponent.h */
    if ( m.focussed_filler &&
        (m.focussed_filler->flags & 0xFF) != UI_FILLED_AREA_TYPE_BITMAP &&
        (m.focussed_filler->flags & 0xFF) != UI_FILLED_AREA_TYPE_IMAGE_RIGHT_ALIGN &&
        (m.focussed_filler->flags & 0xFF) != UI_FILLED_AREA_TYPE_IMAGE_LEFT_ALIGN)
    {
        fixed_two_line_menuitem_transparent_filled_area = *(m.focussed_filler);
        m.focussed_filler = &fixed_two_line_menuitem_transparent_filled_area;
        fixed_two_line_menuitem_transparent_filled_area.flags |= UI_FILLED_AREA_TYPE_TRANSPARENT_COLOR;
        fixed_two_line_menuitem_transparent_filled_area.c.alpha = HIGHLIGHTER_COLOR_OPACITY_VALUE;
    }
#endif /* __MMI_UI_TRANSPARENT_EFFECT__ */

    highlight_filler = gui_list_get_focussed_filler((gui_common_menuitem_base_struct*) &m);

    old_alpha_layer = gui_list_set_alpha_blending_layer();
    
 #ifndef __MMI_UI_MENU_SLIM__
    if (gui_filled_area_is_animation(highlight_filler))
    {
        gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_TRANSPARENT);
        if (list_highlight_effect_current_frame)
        {
            gdi_image_draw_frames(
                GUI_current_fixed_icontext_menuitem_x,
                GUI_current_fixed_icontext_menuitem_y,
                highlight_filler->b,
                list_highlight_effect_current_frame - 1);
        }
        else
        {   
            gdi_image_get_frame_count(highlight_filler->b, &count);
            if (count >= 1)
            {
                gdi_image_draw_frames(
                    GUI_current_fixed_icontext_menuitem_x,
                    GUI_current_fixed_icontext_menuitem_y,
                    highlight_filler->b,
                    count-1);
            }
            else
            {
                gui_draw_filled_area(
                    GUI_current_fixed_icontext_menuitem_x,
                    GUI_current_fixed_icontext_menuitem_y,
                    GUI_current_fixed_icontext_menuitem_x2,
                    y2,
                    highlight_filler);
            }                    
        }            
    }            
    else
#endif
    {
        gui_push_clip();
        gdi_layer_get_clip(&current_x1, &current_y1, &current_x2, &current_y2);
        if (current_x1 < GUI_current_fixed_icontext_menuitem_x )
        {
            current_x1 = GUI_current_fixed_icontext_menuitem_x;
        }
        
        if (current_y1 < GUI_current_fixed_icontext_menuitem_y)
        {
            current_y1 = GUI_current_fixed_icontext_menuitem_y;
        }
        
        if (current_x2 > GUI_current_fixed_icontext_menuitem_x2)
        {
            current_x2 = GUI_current_fixed_icontext_menuitem_x2;
        }
        
        if (current_y2 > y2)
        {
            current_y2 = y2;
        }
        
        gdi_layer_set_clip(current_x1, current_y1, current_x2, current_y2);
        gui_draw_filled_area(
            GUI_current_fixed_icontext_menuitem_x,
            GUI_current_fixed_icontext_menuitem_y,
            GUI_current_fixed_icontext_menuitem_x2,
            GUI_current_fixed_icontext_menuitem_y + m.height - 1,
            highlight_filler);
        gui_pop_clip();
    }

    gui_list_reset_alpha_blending_layer(old_alpha_layer);
    }
    
#ifdef __MMI_UI_TRANSPARENT_EFFECT__
    gui_fixed_icontext_enable_transparent_effect(&MMI_fixed_icontext_menuitem); /* To hide text below scrolling text */
#endif
}


/*****************************************************************************
 * FUNCTION
 *  line_scrolling_text_timer_handler
 * DESCRIPTION
 *  Scroll handler of the two line hint/select menu item.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void line_scrolling_text_timer_handler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_handle_scrolling_text(&gui_two_line_scroll_text);
}


/*****************************************************************************
 * FUNCTION
 *  two_line_menuitem_cleanup_function
 * DESCRIPTION
 *  Clean up function mainly to stop scrolling text on category exit.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void two_line_menuitem_cleanup_function(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_scrolling_text_stop(&gui_two_line_scroll_text);
    gui_reset_current_two_line_menuitem_data();
#ifdef __MMI_UI_TWO_LINE_MENUITEM_STYLES__
    gui_reset_two_line();
#endif 
}


/*****************************************************************************
 * FUNCTION
 *  gui_show_two_line_icontext_menuitem
 * DESCRIPTION
 *  Function to display an two line hint/select menuitem
 * PARAMETERS
 *  item                    [IN]        private two-line menu item object (icontext)
 *  common_item_data        [IN]        common two-line menu item object (icontext)
 *  x                       [IN]        x
 *  y                       [IN]        y
 * RETURNS
 *  void
 *****************************************************************************/
void gui_show_two_line_icontext_menuitem(void *item, void *common_item_data, S32 x, S32 y)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x1, y1, x2, y2, menu_y2, menu_y1;

    S32 text_x1 = 0;
    S32 text_x2 = 0;
    S32 text_y1 = 0;
    S32 text_y2 = 0;

    S32 icon_x = 0;
    S32 icon_y = 0;
    S32 icon_width = 0;
    S32 icon_height = 0;
    S32 sw = 0, sh = 0;
    U8 show_two_line_hints = 1;
#ifdef __MMI_UI_TWO_LINE_MENUITEM_STYLES__
    U8 thumbnail_flags = 0;
    S32 image_width = 0;
#endif
    U32 flags, flags_ext;
    U32 ret_flag = 0, ret_flag_ext = 0;
    UI_filled_area *f = NULL;
    fixed_icontext_menuitem *m = (fixed_icontext_menuitem*) common_item_data;
    fixed_icontext_menuitem_type *mi = (fixed_icontext_menuitem_type*) item;
    UI_string_type _text = NULL;

#ifdef __MMI_UI_HINTS_IN_MENUITEM__
    UI_string_type _hint_text = NULL;
#endif 
    PU8 _icon = NULL;

    fixed_icontext_menuitem cm; /* common menuitem */
    gdi_handle old_alpha_layer=GDI_NULL_HANDLE;
#ifndef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
    S32 count = 0;
#endif  
#ifdef __MMI_UI_LIST_HIGHLIGHT_BOLD
    stFontAttribute highlight_font;
#endif /*__MMI_UI_LIST_HIGHLIGHT_BOLD*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_add_cleanup_hook(two_line_menuitem_cleanup_function);//053006 2 line Calvin
	gui_get_fixed_menuitem_flags_int(item, common_item_data, &flags, &flags_ext);
    _text = mi->item_text;
    _icon = mi->item_icon;
    x1 = x;
    y1 = y;
    x2 = x1 + m->width - 1;
    y2 = y1 + (m->height << 1) - 1;
    gui_get_menu_region_V(m, &menu_y1,&menu_y2);
    gui_lock_double_buffer();

#if defined(__MMI_UI_HINTS_IN_MENUITEM__) && defined(__MMI_UI_TWO_LINE_MENUITEM_STYLES__)
    if (m->parent_list && m->parent_list->gui_get_current_pop_up_description_string &&
        ((_hint_text = m->parent_list->gui_get_current_pop_up_description_string()) == NULL ||
        (m->ext_flags & UI_MENUITEM_EXT_SHOW_TWO_LINE_SELECT)))
#elif defined (__MMI_UI_HINTS_IN_MENUITEM__)
    if ((_hint_text = m->parent_list->gui_get_current_pop_up_description_string()) == NULL)
#endif 
    {
        show_two_line_hints = 0;
    #ifdef __MMI_UI_TWO_LINE_MENUITEM_STYLES__
        thumbnail_flags = gui_two_line_get_thumbnail_flags();
    #endif 
    }

#ifdef __MMI_UI_TWO_LINE_MENUITEM_STYLES__
    if (mmi_fe_get_r2l_state() && thumbnail_flags)
    {
        gui_two_line_toggle_thumbnail_direction();
        thumbnail_flags = gui_two_line_get_thumbnail_flags();
    }
#endif /* __MMI_UI_TWO_LINE_MENUITEM_STYLES__ */ 

#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
    gui_reset_current_list_effect();
#endif 

    if (!(flags & UI_MENUITEM_DISABLE_BACKGROUND_ALWAYS) && (flags & UI_MENUITEM_STATE_FOCUSSED))
    {
        if (y1 >= menu_y2)
        {
            gui_push_and_set_clip(x1, menu_y2, x2, menu_y2);
        }
        else if (y2 >= menu_y2)
        {
            gui_push_and_set_clip(x1, y1, x2, menu_y2);
        }
        else
        {
            gui_push_and_set_clip(x1, y1, x2, y2);
        }

        /* verify two line menuitem highlight image dimension */
        cm = *m;
        cm.height *= 2;
#ifdef __MMI_UI_TWO_LINE_MENUITEM_IMG_SELECTOR__
        if (get_current_menu_item_displaystyle &&  
            get_current_menu_item_displaystyle(MMI_fixed_list_menu.highlighted_item)== TWO_LINE_MENUITEM_STYLE_DISPLAY_HORIZONTAL_SELECT)
        {
        #if !defined(__MMI_OP11_MENU_12MATRIX__)
            if ((MMI_fixed_list_menu.flags & UI_LIST_MENU_DISABLE_SCROLLBAR) ||
                ((MMI_fixed_list_menu.flags & UI_LIST_MENU_AUTO_DISABLE_SCROLLBAR) && 
                (MMI_fixed_list_menu.displayed_items >= MMI_fixed_list_menu.n_items)))
            {
                gdi_image_draw_resized(GUI_current_fixed_icontext_menuitem_x, GUI_current_fixed_icontext_menuitem_y, cm.width, cm.height, get_image(IMG_SELECTOR_FILLER));
            }
            else
            {
                gdi_image_draw(GUI_current_fixed_icontext_menuitem_x, GUI_current_fixed_icontext_menuitem_y, get_image(IMG_SELECTOR_FILLER));
            }
        #endif  /* !defined(__MMI_OP11_MENU_12MATRIX__) */
        }
#if !defined(__MMI_OP11_MENU_12MATRIX__)
        else
#endif
#endif  // __MMI_UI_TWO_LINE_MENUITEM_IMG_SELECTOR__
        {            
        if (fixed_two_line_menuitem_filler)
        {
            cm.focussed_filler = fixed_two_line_menuitem_filler;
        }
        else
        {   
            cm.focussed_filler = current_MMI_theme->menuitem_two_line_highlight_filler;
        }
        if (fixed_two_line_menuitem_without_sc_filler)
        {
            cm.focussed_without_sc_filler = fixed_two_line_menuitem_without_sc_filler;
        }
        else
        {   
            cm.focussed_without_sc_filler = current_MMI_theme->menuitem_two_line_highlight_filler;//menuitem_two_line_highlight_without_scroll_filler
        }
        

#ifdef __MMI_UI_TRANSPARENT_EFFECT__
        /* This is to replace the UI_FILLED_AREA_TYPE_TRANSPARENT_COLOR flag and alpha value from the themecomponent.h */
        if ((cm.focussed_filler->flags & 0xFF) != UI_FILLED_AREA_TYPE_BITMAP &&
            (cm.focussed_filler->flags & 0xFF) != UI_FILLED_AREA_TYPE_IMAGE_RIGHT_ALIGN &&
            (cm.focussed_filler->flags & 0xFF) != UI_FILLED_AREA_TYPE_IMAGE_LEFT_ALIGN)
        {
            fixed_two_line_menuitem_transparent_filled_area = *(cm.focussed_filler);
            cm.focussed_filler = &fixed_two_line_menuitem_transparent_filled_area;
            fixed_two_line_menuitem_transparent_filled_area.flags |= UI_FILLED_AREA_TYPE_TRANSPARENT_COLOR;
            fixed_two_line_menuitem_transparent_filled_area.c.alpha = HIGHLIGHTER_COLOR_OPACITY_VALUE;
        }
#endif /* __MMI_UI_TRANSPARENT_EFFECT__ */ 
        f = gui_list_get_focussed_filler((gui_common_menuitem_base_struct*) &cm);

        old_alpha_layer = gui_list_set_alpha_blending_layer();
        set_start_position_and_item_parameters_for_list_highlighter_effect(item, common_item_data, x1, y1);
    #ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
		/* Currently special list effect is not supported in two-line menu item */
        gui_draw_list_filled_area(x1, y1, x2, y2, f);
    #else
        gui_menuitem_draw_list_filler(x1, y1, x2, y2, f, MMI_TRUE, MMI_FALSE);
    #endif  // __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
        gui_list_reset_alpha_blending_layer(old_alpha_layer);
        }
        gui_pop_clip();
    }

#ifdef __MMI_FTE_SUPPORT__
    if (mmi_fe_get_r2l_state())
    {
        x1 += MMI_fixed_list_menu.vbar.width;
    }
    else
    {
        x2 -= MMI_fixed_list_menu.vbar.width;
    }
#endif
    if (!show_two_line_hints)
    {
    #ifdef __MMI_UI_TRANSPARENT_EFFECT__
        if (!gui_is_current_transparency_with_multi_layer())
        {
            gui_fixed_icontext_disable_transparent_effect(m);   /* To hide text below scrolling text */
        }
    #endif /* __MMI_UI_TRANSPARENT_EFFECT__ */ 
    }

    if (_icon != UI_NULL_IMAGE)
    {
        gui_measure_image(_icon, &icon_width, &icon_height);
    }
    else
    {
        icon_width = icon_height = 0;
    }

    /* scenario 0 - No Image, 1 - LEFT Image,  2 - RIGHT Image */
    if (show_two_line_hints
#ifdef __MMI_UI_TWO_LINE_MENUITEM_STYLES__
        || (thumbnail_flags == UI_TWO_LINE_MENUITEM_NO_THUMBNAIL)
#endif 
        )
    {
        if (mmi_fe_get_r2l_state())
        {
            /* Icon calculation */
            /* R2L icons are right-aligned. */
            icon_x = x2 - m->icon_x - icon_width + 1;
            icon_y = y1;
            /* Text calculation */
            text_x1 = x1;
            text_x2 = x2 - m->text_x;
            text_y1 = y1;
            text_y2 = text_y1 + ((y2 - y1) >> 1);
        }
        else
        {
            /* Icon calculation */
            icon_x = x1 + m->icon_x;
            icon_y = y1;
            /* Text calculation */
            text_x1 = x1 + m->text_x;
            text_x2 = x2;
            text_y1 = y1;
            text_y2 = text_y1 + ((y2 - y1) >> 1);
        }
        if ((flags & UI_MENUITEM_DISABLE_ICON) && (_icon == UI_NULL_IMAGE))
        {
            if (mmi_fe_get_r2l_state())
            {
                text_x2 = x2 - 2;
            }
            else
            {
                text_x1 = x1 + 2;
            }
        }
    }
#ifdef __MMI_UI_TWO_LINE_MENUITEM_STYLES__
    else if (thumbnail_flags & UI_TWO_LINE_MENUITEM_LEFT_ALIGN_THUMBNAIL)
    {
        image_width = (m->height << 1);

        icon_x = x2 - m->text_x + 2;
        icon_y = y1;

        text_x1 = x1 + image_width + 2;
        text_x2 = x2 - (m->text_x + GUI_TWO_LINE_TEXT_ICON_GAP);
        text_y1 = y1;
        text_y2 = text_y1 + ((y2 - y1) >> 1);

        if ((flags & UI_MENUITEM_DISABLE_ICON) && (_icon == UI_NULL_IMAGE))
        {
            text_x2 = x2 - GUI_TWO_LINE_TEXT_ICON_GAP;
        }
    }
    else if (thumbnail_flags & UI_TWO_LINE_MENUITEM_RIGHT_ALIGN_THUMBNAIL)
    {
        image_width = (m->height << 1);

        icon_x = x1 + m->icon_x;

        if ((flags & UI_MENUITEM_DISABLE_ICON) && (_icon == UI_NULL_IMAGE))
        {
            text_x1 = x1 + 2;
        }
        else
        {
            text_x1 = x1 + m->text_x;
        }

        icon_y = y1;

        text_x2 = x2 - image_width - 2;
        text_y1 = y1;
        text_y2 = text_y1 + ((y2 - y1) >> 1);
    }
#endif /* __MMI_UI_TWO_LINE_MENUITEM_STYLES__ */ 

#ifdef __MMI_FTE_SUPPORT__    
    /* adjust the text width for the text right gap */
    if (mmi_fe_get_r2l_state())
    {
        text_x1 += GUI_MENUITEM_TEXT_RIGHT_GAP;
    }
    else
    {
        text_x2 -= GUI_MENUITEM_TEXT_RIGHT_GAP;
    }
#else
    /* adjust the text width for the text right gap */
    //if (gui_menuitem_is_image_highlight(m))
    {
        if (mmi_fe_get_r2l_state())
        {
            text_x1 += GUI_MENUITEM_TEXT_RIGHT_GAP;
        }
        else
        {
            text_x2 -= GUI_MENUITEM_TEXT_RIGHT_GAP;
        }
    }
#endif

    /* draw text */
    if (_text != NULL && (!(flags & UI_MENUITEM_DISABLE_TEXT_DISPLAY)))
    {
        if (text_y1 >= menu_y2)
        {
            gui_push_and_set_clip(text_x1, menu_y2, text_x2, menu_y2);
        }
        else if (text_y2 >= menu_y2)
        {
            gui_push_and_set_clip(text_x1, text_y1, text_x2, menu_y2);
        }
        else
        {
            gui_push_and_set_clip(text_x1, text_y1, text_x2, text_y2);
        } 

        gui_list_menuitem_set_font((gui_common_menuitem_base_struct *) m, flags);
        gui_measure_string((UI_string_type)_text, &sw, &sh);
        text_y1 += (m->height >> 1) - (sh >> 1);    /* Center Vertically */
        if (flags & UI_MENUITEM_STATE_FOCUSSED)
        {
        #ifdef __MMI_SUPPORT_DUMP_SCREEN_STRING__
            mmi_frm_dss_set_menu_highlight(MMI_SCREEN_FOCUSED_TWO_LINE_ICONTEXT);
		#endif
            /* Use another scroll handler */
            gui_fixed_icontext_menuitem_stop_scroll();
            gui_set_text_color(MMI_fixed_icontext_menuitem.focussed_text_color);
        }
        else
        {
            gui_set_text_color(MMI_fixed_icontext_menuitem.normal_text_color);
        }

        if (sw < (text_x2 - text_x1 - 1) || (!(flags & UI_MENUITEM_STATE_FOCUSSED)))
        {
            if (mmi_fe_get_r2l_state())
            {
                gui_move_text_cursor(text_x2, text_y1);
            }
            else
            {
                gui_move_text_cursor(text_x1, text_y1);
            }
            gui_set_line_height(sh);
            if (sw >= (text_x2 - text_x1 - 1))
            {
                gui_print_truncated_text(text_x1, text_y1, text_x2 - text_x1 + 1, _text);
            }
            else
            {
                gui_print_text((UI_string_type) _text);
            }
        }
        else if (flags & UI_MENUITEM_TRUNCATE_CONTENT)
        {
            gui_print_truncated_text(text_x1, text_y1, text_x2 - text_x1 + 1, _text);
        }
        else
        {
            gui_create_scrolling_text(
                &gui_two_line_scroll_text,
                text_x1,
                text_y1,
                text_x2 - text_x1 + 1,
                sh + 1,
                (UI_string_type)_text,
                line_scrolling_text_timer_handler,
                scrolling_text_draw_two_line_background,
                MMI_fixed_icontext_menuitem.focussed_text_color,
                MMI_fixed_icontext_menuitem.focussed_text_color);
            gui_show_scrolling_text(&gui_two_line_scroll_text);
        }
        gui_pop_text_clip();
    }

    /* draw icon */
    if (_icon != UI_NULL_IMAGE)
    {
        gui_measure_image(_icon, &sw, &sh);
        icon_y += (m->height >> 1) - (sh >> 1); /* Center Vertically */
        if (icon_y >= menu_y2)
        {
            gui_push_and_set_clip(icon_x, menu_y2, icon_x + sw,  menu_y2);
        }
        else if (icon_y + sh >= menu_y2)
        {
            gui_push_and_set_clip(icon_x, icon_y, icon_x + sw,  menu_y2);
        }
        else
        {
            gui_push_and_set_clip(icon_x, icon_y, icon_x + sw, icon_y + sh);
        } 
        gdi_image_draw_animation_single_frame(icon_x, icon_y, (U8*)_icon, 0);
        gui_pop_clip();

        /* show check box to be corresponding to list effects, since list effects may set _icon as NULL */
        if (m->ext_flags & UI_MENUITEM_EXT_SHOW_ICONTEXT_CHECKBOX)
        {
            gui_menuitem_icontext_show_checkbox(m, x1, y1);
        }
    }

#ifdef __MMI_UI_HINTS_IN_MENUITEM__
    if (show_two_line_hints)
    {
    #ifdef __MMI_SUPPORT_DUMP_SCREEN_STRING__
        mmi_frm_dss_set_menu_highlight(MMI_SCREEN_HIGHLIGHT_TWO_LINE_HINTS);
	#endif
        gui_show_two_line_hint_part(text_x1, text_x2, y + m->height, y + 2*m->height - 1, _hint_text, flags);
        gui_unlock_double_buffer();
        return;
    }
#endif /* __MMI_UI_HINTS_IN_MENUITEM__ */ 

#ifdef __MMI_UI_TWO_LINE_MENUITEM_STYLES__
    {
        gui_move_two_line_menuitem_part(x1 + 2, y1 + m->height);
        gui_resize_two_line_menuitem_part(x2 - x1 - 4, m->height);
        gui_show_two_line_menuitem_part();
        gui_unlock_double_buffer();
        return;
    }
#endif /* __MMI_UI_TWO_LINE_MENUITEM_STYLES__ */ 
}


/*****************************************************************************
 * FUNCTION
 *  gui_two_line_scroller_stop
 * DESCRIPTION
 *  Stop the two-line scroll timer.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gui_two_line_scroller_stop(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_scrolling_text_stop(&gui_two_line_scroll_text);
}

#endif /* (defined __MMI_UI_TWO_LINE_MENUITEM_STYLES__ || defined __MMI_UI_HINTS_IN_MENUITEM__) */ 


/*****************************************************************************
 * FUNCTION
 *  gui_menuitem_checkbox_get_data
 * DESCRIPTION
 *  Get the checkbox object.
 * PARAMETERS
 *  checkbox       [OUT]    checkbox object
 *  m              [IN]     common menu item object
 *  x1             [IN]     x1
 *  y1             [IN]     y1
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_menuitem_checkbox_get_data(gui_menuitem_icontext_checkbox_struct *checkbox, gui_common_menuitem_base_struct *m, S32 x1, S32 y1)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 iwidth, iheight;
    PU8 checkbox_img;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /*
     * get checkbox image and dimension
     */
    if (m->parent_list->current_displayed_item == -1)
    {
        m->checkbox_get_image_callback(m->parent_list->highlighted_item, &checkbox_img);
    }
    else
    {
        m->checkbox_get_image_callback(m->parent_list->current_displayed_item, &checkbox_img);
    }
    gui_measure_image(checkbox_img, &iwidth, &iheight);
    
    checkbox->image = checkbox_img;
    checkbox->image_width = iwidth;
    checkbox->image_height = iheight;
    
    /* 
     * get checkbox x1 
     */
    if (mmi_fe_get_r2l_state())
    {        
        checkbox->x = x1 + m->width - 1 - iwidth - m->checkbox_x;
    }
    else
    {
        checkbox->x = x1 + m->checkbox_x;
    }

    /* 
     * get checkbox y1 
     */
    if (m->checkbox_y == 0)
    {   /* vertical center align */
        checkbox->y = y1 + (m->height - iheight) / 2;
    }    
    else
    {
        checkbox->y = y1 + m->checkbox_y;
    }
}


/*****************************************************************************
 * FUNCTION
 *  gui_menuitem_icontext_checkbox_get_data
 * DESCRIPTION
 *  Get the checkbox object.
 * PARAMETERS
 *  checkbox       [OUT]    checkbox object
 *  m              [IN]     common icontext menu item object
 *  x1             [IN]     x1
 *  y1             [IN]     y1
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_menuitem_icontext_checkbox_get_data(gui_menuitem_icontext_checkbox_struct *checkbox, fixed_icontext_menuitem *m, S32 x1, S32 y1)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_menuitem_checkbox_get_data(checkbox, (gui_common_menuitem_base_struct *) m, x1, y1);
}


/*****************************************************************************
 * FUNCTION
 *  gui_menuitem_icontext_checkbox_get_data
 * DESCRIPTION
 *  Get the checkbox object.
 * PARAMETERS
 *  checkbox       [OUT]    checkbox object
 *  m              [IN]     common icontext menu item object
 *  x1             [IN]     x1
 *  y1             [IN]     y1
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_menuitem_icontext_list_checkbox_get_data(gui_menuitem_icontext_checkbox_struct *checkbox, fixed_icontext_list_menuitem *m, S32 x1, S32 y1)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_menuitem_checkbox_get_data(checkbox, (gui_common_menuitem_base_struct *) m, x1, y1);
}


/*****************************************************************************
 * FUNCTION
 *  gui_menuitem_icontext_show_checkbox
 * DESCRIPTION
 *  Show the checkbox of icontext menu items.
 * PARAMETERS
 *  x1                    [IN]      x1
 *  y1                    [IN]      y1
 *  common_menuitem       [IN]      common icontext menu item object
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_menuitem_icontext_show_checkbox(fixed_icontext_menuitem *m, S32 x1, S32 y1)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gui_menuitem_icontext_checkbox_struct checkbox;
       
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_menuitem_icontext_checkbox_get_data(&checkbox, m, x1, y1);

    gdi_image_draw(checkbox.x, checkbox.y, checkbox.image);
}


/*****************************************************************************
 * FUNCTION
 *  gui_menuitem_icontext_show_checkbox
 * DESCRIPTION
 *  Show the checkbox of icontext menu items.
 * PARAMETERS
 *  x1                    [IN]      x1
 *  y1                    [IN]      y1
 *  common_menuitem       [IN]      common icontext menu item object
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_menuitem_icontext_list_show_checkbox(fixed_icontext_list_menuitem *m, S32 x1, S32 y1)
{    
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gui_menuitem_icontext_checkbox_struct checkbox;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_menuitem_icontext_list_checkbox_get_data(&checkbox, m, x1, y1);
    
    gdi_image_draw(checkbox.x, checkbox.y, checkbox.image);
}

#ifdef __MMI_UI_LIST_SLIDE_EFFECT__
/*****************************************************************************
 * FUNCTION
 *  gui_menuitem_is_image_highlight
 * DESCRIPTION
 *  Check if the highlight is image.
 * PARAMETERS
 *  common_item_data    [IN]    common menu item object
 * RETURNS
 *  0: without image highlight. 1: with image highlight.
 *****************************************************************************/
static S32 gui_menuitem_is_image_highlight(void *common_item_data)
{    
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gui_common_menuitem_base_struct *m = (gui_common_menuitem_base_struct*)common_item_data;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return (((m->focussed_filler->flags & 0xFF) == UI_FILLED_AREA_TYPE_BITMAP) ||
            ((m->focussed_filler->flags & 0xFF) == UI_FILLED_AREA_TYPE_IMAGE_RIGHT_ALIGN) ||
            ((m->focussed_filler->flags & 0xFF) == UI_FILLED_AREA_TYPE_IMAGE_LEFT_ALIGN) ||
            gui_list_effect_slide_is_enable());
}
#endif
//hujin
/*****************************************************************************
 * FUNCTION
 *  gui_get_fixed_menuitem_flag_int
 * DESCRIPTION
 *  get meuitem flags
 * PARAMETERS
 *  f               [IN]    highlight filler
 *  x1, y1, x2, y2    [IN]    the position of filler
 *  isAnimate  [IN]    whether block the animation when filler is animation
 *  noTran      [IN]    whether the filler support transparent color
 * RETURNS
 *  0: without image highlight. 1: with image highlight.
 *****************************************************************************/

static void gui_get_fixed_menuitem_flags_int(void *item, void *common_item_data, U32* flags, U32* flags_ext)
{
  //  fixed_icontext_menuitem *m = (fixed_icontext_menuitem*) common_item_data;
  //  fixed_icontext_menuitem_type *mi = (fixed_icontext_menuitem_type*) item;
  
  gui_common_menuitem*m = (gui_common_menuitem*) common_item_data;
  fixed_menuitem_type* mi = (fixed_menuitem_type*) item;
  U32 ret_flag = 0, ret_flag_ext = 0;
	
	*flags = mi->flags | m->flags;
    *flags_ext = m->ext_flags;

	if (g_gui_list_get_menuitem_flags)
    {
        if (MMI_fixed_list_menu.current_displayed_item != -1)
        {
            g_gui_list_get_menuitem_flags(MMI_fixed_list_menu.current_displayed_item, &ret_flag, &ret_flag_ext);
        }
        else
        {
            g_gui_list_get_menuitem_flags(MMI_fixed_list_menu.highlighted_item, &ret_flag, &ret_flag_ext);
        }

		*flags     |= ret_flag;
		*flags_ext |= ret_flag_ext;
    }

}

static void gui_get_menu_region_V(void * common_item_data,S32 * menu_y1,S32 * menu_y2)
{
     gui_common_menuitem*m = (gui_common_menuitem*) common_item_data;
	 
	  if ((MMI_current_menu_type == LIST_MENU) || (MMI_current_menu_type == PAGE_MENU))
	   {
		   *menu_y1 = m->parent_list->y;
		   *menu_y2 = m->parent_list->y + m->parent_list->height - 1;
	   }
#ifdef __MMI_BI_DEGREE_MAIN_MENU_STYLE__
	   else if(MMI_current_menu_type == LIST_MATRIX_MENU)
	   {
		   *menu_y1 = m->parent_matrix->y;
		   *menu_y2 = m->parent_matrix->y + m->parent_matrix->height - 1;
	   }
#endif /* __MMI_BI_DEGREE_MAIN_MENU_STYLE__ */ 
	   else
	   {
		   *menu_y1 = m->parent_matrix->y;
		   *menu_y2 = m->parent_matrix->y + m->parent_matrix->height - 1;
	   }

}

/*****************************************************************************
 * FUNCTION
 *  gui_menuitem_draw_list_filler
 * DESCRIPTION
 *  Draw list filler
 * PARAMETERS
 *  f               [IN]    highlight filler
 *  x1, y1, x2, y2    [IN]    the position of filler
 *  isAnimate  [IN]    whether block the animation when filler is animation
 *  noTran      [IN]    whether the filler support transparent color
 * RETURNS
 *  0: without image highlight. 1: with image highlight.
 *****************************************************************************/
static void gui_menuitem_draw_list_filler(
                S32 x1, S32 y1, S32 x2, S32 y2,
                UI_filled_area * f,
                MMI_BOOL isAnimate,
                MMI_BOOL noTran
                )
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#ifndef __MMI_UI_MENU_SLIM__	
    S32 count;
#endif
    UI_filled_area tf;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (f == NULL)
    {
        return;
    }

#ifndef __MMI_UI_MENU_SLIM__
    if (gui_filled_area_is_animation(f))
    {
        gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_TRANSPARENT);
        if (isAnimate)
        {
            gdi_image_get_frame_count(f->b, &count);
            if (count >= 1)
            {
                gui_draw_animated_effect_filler(x1, y1, x2, y2, f);            
            }
            else
            {
                gui_draw_filled_area(x1, y1, x2, y2, f);
            }
        }
        else
        {
            gui_draw_animated_effect_filler(x1, y1, x2, y2, f);            
        }
    }            
    else
#endif
    {
        tf = *f;
        
        if (noTran)
        {
            tf.flags &= ~UI_FILLED_AREA_TYPE_TRANSPARENT_COLOR;
        }
        gui_draw_filled_area(x1, y1, x2, y2, &tf);
    }
}


/*****************************************************************************
 * FUNCTION
 *  gui_menuitem_set_text_position
 * DESCRIPTION
 *  Draw list filler
 * PARAMETERS
 *  common_item_data       [IN]   list menu common item data
 *  x, y    [IN]    the text position
 * RETURNS
 *      None
 *****************************************************************************/
void gui_menuitem_set_text_position(void *common_item_data, S32 x, S32 y)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gui_common_menuitem_base_struct *m = (gui_common_menuitem_base_struct*)common_item_data;
       
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    m->text_x = x;
    m->text_y = y;
    if (m->icon_x > m->text_x)
    {
        m->scroll_width = m->icon_x - m->text_x;
    }
    else
    {
        m->scroll_width = m->width - m->text_x;
    }
}


/*****************************************************************************
 * FUNCTION
 *  gui_menuitem_set_icon_position
 * DESCRIPTION
 *  Draw list filler
 * PARAMETERS
 *  common_item_data       [IN]   list menu common item data
 *  x, y    [IN]    the icon position
 * RETURNS
 *      None
 *****************************************************************************/
static void gui_menuitem_set_icon_position(void *common_item_data, S32 x, S32 y)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gui_common_menuitem_base_struct *m = (gui_common_menuitem_base_struct*)common_item_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    m->icon_x = x;
    m->icon_y = y;
    if (m->icon_x > m->text_x)
    {
        m->scroll_width = m->icon_x - m->text_x;
    }
    else
    {
        m->scroll_width = m->width - m->text_x;
    }
}


#ifdef  __MMI_UI_HINTS_IN_MENUITEM__
/*****************************************************************************
 * FUNCTION
 *  gui_menuitem_has_hint
 * DESCRIPTION
 *  Check whether current menuitem has hint
 * PARAMETERS
 *  m     [IN]    common menu item object
 *  flags [IN]    the flags of menuitem
 *  hint_string  [OUT]   store the hint string
 * RETURNS
 *  0: without image highlight. 1: with image highlight.
 *****************************************************************************/
static MMI_BOOL gui_menuitem_has_hint(
    gui_common_menuitem_base_struct *m,
    U32 isFocused
    )
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL show_hint_in_menuitem = MMI_FALSE;
    UI_string_type curr_hint_string = NULL;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (m->parent_list && m->parent_list->gui_get_current_pop_up_description_string &&
        ((m->ext_flags & UI_MENUITEM_SHOW_ALL_HINTS) ||
        ((isFocused) && (m->ext_flags & UI_MENUITEM_SHOW_HIGHLIGHTED_HINT))))
    {
        curr_hint_string = m->parent_list->gui_get_current_pop_up_description_string();
        if (curr_hint_string && mmi_ucs2strlen((CHAR *)curr_hint_string))
        {
            show_hint_in_menuitem = MMI_TRUE;
        }
    }
    
    return show_hint_in_menuitem;
}
#endif  // __MMI_UI_HINTS_IN_MENUITEM__


/*****************************************************************************
 * FUNCTION
 *  gui_menuitem_adjust_text_clip_for_right_gap
 * DESCRIPTION
 *  Adjust the menu item text clip with image highlight by GUI_MENUITEM_TEXT_RIGHT_GAP.
 * PARAMETERS
 *  common_item_data    [IN]    common menu item object        
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_menuitem_adjust_text_clip_for_right_gap(void *common_item_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gui_common_menuitem_base_struct *m = (gui_common_menuitem_base_struct*)common_item_data;
    S32     text_clip_x1, text_clip_y1, text_clip_x2, text_clip_y2, menu_y2, menu_y1;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	gui_get_menu_region_V(m, &menu_y1, &menu_y2);
    gui_get_text_clip(&text_clip_x1, &text_clip_y1, &text_clip_x2, &text_clip_y2);
#ifdef __MMI_FTE_SUPPORT__
    if (MMI_current_menu_type == LIST_MENU)
    {
        if (mmi_fe_get_r2l_state())
        {
            text_clip_x1 += GUI_MENUITEM_TEXT_RIGHT_GAP;
        }
        else
        {
            text_clip_x2 -= GUI_MENUITEM_TEXT_RIGHT_GAP;
        }
    }   
#else    
#ifdef __MMI_UI_LIST_SLIDE_EFFECT__
    if ((MMI_current_menu_type == LIST_MENU) && gui_menuitem_is_image_highlight(m))
    {
        if (mmi_fe_get_r2l_state())
        {
            text_clip_x1 += GUI_MENUITEM_TEXT_RIGHT_GAP;
        }
        else
        {
            text_clip_x2 -= GUI_MENUITEM_TEXT_RIGHT_GAP;
        }
    }   
#endif/*__MMI_UI_LIST_SLIDE_EFFECT__*/
#endif
    if (text_clip_y1 >= menu_y2)
    {
        text_clip_y1 = menu_y2;
    }
    else if (text_clip_y2 >= menu_y2)
    {
        text_clip_y2 = menu_y2;
    }

    gui_set_text_clip(text_clip_x1, text_clip_y1, text_clip_x2, text_clip_y2);    
}

#ifndef __MMI_BASIC_UI_STYLE__
/*****************************************************************************
 * FUNCTION
 *  gui_animation_with_background_draw_before_cb
 * DESCRIPTION
 *  Animation with background draw before callback.
 * PARAMETERS
 *  result       [IN]   GDI image result code
 * RETURNS
 *  void
 *****************************************************************************/    
static void gui_animation_with_background_draw_before_cb(GDI_RESULT result)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gdi_handle  active_layer;
    S32         iw, ih;
    S32         clip_x1, clip_y1, clip_x2, clip_y2;
    S32         min_y, max_y;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
//	    if (anim_with_bkg_p->background_filler == NULL)
//	    {
//	        //return;
//	    }

    /* save source layer */
    //gdi_get_alpha_blending_source_layer(&anim_with_bkg_p->old_src_layer);
    
    gdi_layer_get_active(&active_layer);
    gdi_set_alpha_blending_source_layer(active_layer);

    /* bring the background layer to the active layer by flattening */    
    gdi_image_get_dimension(anim_with_bkg_p->animation, &iw, &ih);       
    clip_x1 = anim_with_bkg_p->x;
    clip_y1 = anim_with_bkg_p->y;
    clip_x2 = clip_x1 + iw - 1;
    clip_y2 = clip_y1 + ih - 1;    
#ifdef  GUI_MATRIX_MENU_SMOOTH_SCROLLING_BY_PEN
    if (gui_matrix_screen_smooth_scrolling_moved_by_pen())
    {
        min_y = clip_y1;
        max_y = clip_y2;
    }
    else
#endif  // GUI_MATRIX_MENU_SMOOTH_SCROLLING_BY_PEN
    {
        min_y = MMI_fixed_matrix_menu.y;
        max_y = MMI_fixed_matrix_menu.y + MMI_fixed_matrix_menu.height - 1;
    }
    if (clip_y1 < min_y)
    {
        clip_y1 = min_y;
    }
    if (clip_y2 > max_y)
    {
        clip_y2 = max_y;
    }
    gdi_layer_push_and_set_clip(clip_x1, clip_y1, clip_x2, clip_y2);
    /* for MAUI_02637906, gif will only draw the different between two frame */
    gdi_image_cache_reset();
    gdi_layer_flatten_with_clipping(anim_with_bkg_p->old_src_layer, 0, 0, 0);
    gdi_layer_pop_clip();

    /* draw the animation background filler */
    gui_draw_filled_area(clip_x1, clip_y1, clip_x2, clip_y2, anim_with_bkg_p->background_filler);
}
#endif

/*****************************************************************************
 * FUNCTION
 *  gui_animation_with_background_blt_before_cb
 * DESCRIPTION
 *  Animation with background before BLT callback.
 * PARAMETERS
 *  result       [IN]   GDI image result code
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_animation_with_background_blt_before_cb(GDI_RESULT result)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#ifdef  __MMI_BASIC_UI_STYLE__
    S32 iw, ih;
    S32 clip_x1, clip_y1, clip_x2, clip_y2;
#endif  // __MMI_BASIC_UI_STYLE__
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef  __MMI_BASIC_UI_STYLE__
    gdi_image_get_dimension(anim_with_bkg_p->animation, &iw, &ih);       
    clip_x1 = anim_with_bkg_p->x;
    clip_y1 = anim_with_bkg_p->y;
    clip_x2 = clip_x1 + iw - 1;
    clip_y2 = clip_y1 + ih - 1;    
    if (clip_y1 < MMI_fixed_matrix_menu.y)
    {
        clip_y1 = MMI_fixed_matrix_menu.y;
    }
    if (clip_y2 >= MMI_fixed_matrix_menu.y + MMI_fixed_matrix_menu.height)
    {
        clip_y2 = MMI_fixed_matrix_menu.y + MMI_fixed_matrix_menu.height - 1;
    }
    gdi_layer_push_and_set_clip(clip_x1, clip_y1, clip_x2, clip_y2);

    /* draw the animation background filler */
    gui_draw_filled_area(clip_x1, clip_y1, clip_x2, clip_y2, anim_with_bkg_p->background_filler);

    gdi_layer_pop_clip();
#endif  // __MMI_BASIC_UI_STYLE__
    if (anim_with_bkg_p->old_src_layer)
    {
        /* restore the ABM source layer gracefully */
        gdi_set_alpha_blending_source_layer(anim_with_bkg_p->old_src_layer);
    }
}


/*****************************************************************************
 * FUNCTION
 *  gui_show_animation_with_background_filler
 * DESCRIPTION
 *  Draw the animation with a given background filler.
 *  NOTE: Because of the gdi animation API limit, there can be only one animation 
 *  with background in play.
 * PARAMETERS
 *  x                           [IN]     x
 *  y                           [IN]     y
 *  animation                   [IN]     animation
 *  animation_background_filler [IN]     animation background filler
 *  animation_handle            [OUT]    animation handle
 * RETURNS
 *  void
 * REMAKE
 *  this function will only called by matrix main menu
 *****************************************************************************/
void gui_show_animation_with_background_filler(S32 x, S32 y, PU8 animation, UI_filled_area *animation_background_filler, gdi_handle *animation_handle)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32     frame_count;
    gdi_handle active_layer;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (animation == NULL)
    {
        return;
    }
    
    anim_with_bkg_p->x = x;
    anim_with_bkg_p->y = y;   
    anim_with_bkg_p->background_filler = animation_background_filler;
    anim_with_bkg_p->animation = animation;
    anim_with_bkg_p->image_type = animation[0];
#ifndef __MMI_BASIC_UI_STYLE__
    gdi_anim_set_draw_before_callback(gui_animation_with_background_draw_before_cb);
#endif
    gdi_anim_set_draw_after_callback(gui_animation_with_background_blt_before_cb);
    gdi_image_get_frame_count(animation, &frame_count);
    
    /* save source layer */
    gdi_get_alpha_blending_source_layer(&anim_with_bkg_p->old_src_layer);

#ifdef  GUI_MATRIX_MENU_SMOOTH_SCROLLING_BY_PEN
    if (gui_matrix_screen_smooth_scrolling_moved_by_pen())
    {
        gdi_layer_flatten_with_clipping(dm_get_layer_handle(0), dm_get_layer_handle(1), dm_get_layer_handle(2), dm_get_layer_handle(3));
    }
    else
#endif  /* GUI_MATRIX_MENU_SMOOTH_SCROLLING_BY_PEN */        
    {
        gdi_layer_flatten_with_clipping(dm_get_layer_handle(0), dm_get_layer_handle(1), dm_get_layer_handle(2), dm_get_layer_handle(3));
    }

    // For display animation icon on highlight background
    gdi_layer_get_active(&active_layer);
    gdi_push_and_set_alpha_blending_source_layer(active_layer);
    /* draw the animation */
    gdi_anim_set_count(gdi_anim_get_count(animation));
    gdi_anim_draw(
        x, 
        y,
        animation,   
        animation_handle);
    gdi_pop_and_restore_alpha_blending_source_layer();
    anim_with_bkg_p->animation_handler = *animation_handle;   
}

 
/*****************************************************************************
 * FUNCTION
 *  gui_show_animation_with_background_image
 * DESCRIPTION
 *  Draw the animation with a given background image.
 *  NOTE: Because of the gdi animation API limit, there can be only one animation 
 *  with background in play. 
 * PARAMETERS
 *  x                      [IN]     x
 *  y                      [IN]     y
 *  animation              [IN]     animation
 *  anim_bg_image          [IN]     animation background image
 *  animation_handle       [OUT]    animation handle
 * RETURNS
 *  void
 *****************************************************************************/
void gui_show_animation_with_background_image(S32 x, S32 y, PU8 animation, PU8 anim_bg_image, gdi_handle *animation_handle)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    static UI_filled_area background_filler;
    UI_filled_area  *f;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (anim_bg_image == NULL)
    {
        f = NULL;
    }
    else
    {
        background_filler.b = anim_bg_image;
        background_filler.flags = UI_FILLED_AREA_TYPE_BITMAP;
        f = &background_filler;
    }

    gui_show_animation_with_background_filler(x, y, animation, f, animation_handle);
}


/*****************************************************************************
 * FUNCTION
 *  gui_fixed_icontext_menuitem_get_text_dimension
 * DESCRIPTION
 *  Get width of the text.
 * PARAMETERS
 *  text              [IN]         text
 *  width             [OUT]        width
 *  height            [OUT]        height
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_fixed_icontext_menuitem_get_text_dimension(fixed_icontext_menuitem_type *mi, UI_string_type text, S32 *width, S32 *height)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#ifdef  __MMI_CAT203_SUPPORT__    
    fixed_icontext_menuitem *m = (fixed_icontext_menuitem*) GUI_current_fixed_icontext_menuitem_common_data;
#endif
    mmi_fe_get_string_info_param_struct query;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mi->text_width != 0 && mi->text_height != 0 &&!(mi->flags & UI_MENUITEM_STATE_FOCUSSED))
    {
        *width = mi->text_width;
        *height = mi->text_height;
        return;
    }
    memset(&query, 0, sizeof(mmi_fe_get_string_info_param_struct));
    query.String = (U8*)text;
    query.checkCompleteWord = MMI_FALSE;
    query.enableTruncated = MMI_FALSE;
    query.n =  mmi_ucs2strlen((const char*)text);
    query.w = 0;
    mmi_fe_get_string_widthheight(&query);
    *width = query.pWidth;
    *height = query.pHeight;
    mi->baseline = query.baseline;
#ifdef  __MMI_CAT203_SUPPORT__    
    if (g_gui_list_get_underline)
    {
        S32 *underline_array = NULL;
        S32 count = 0;    
        S32 i = 0, iwidth, iheight;
        U32 n, nlen;
        U8 underline, bold;
        stFontAttribute text_font;
        text_font = *m->text_font;
    
        underline = m->text_font->underline;
        bold = m->text_font->bold;
        underline_array = (S32*) applib_asm_alloc_anonymous(sizeof(S32) * MAX_SUB_MENU_SIZE);

        if (underline_array)
        {
            memset(underline_array, 0, sizeof(S32) * MAX_SUB_MENU_SIZE);
            if (MMI_fixed_list_menu.current_displayed_item == -1)
            {
                g_gui_list_get_underline(MMI_fixed_list_menu.highlighted_item, underline_array, &count);
            }
            else
            {
                g_gui_list_get_underline(MMI_fixed_list_menu.current_displayed_item, underline_array, &count);
            }
            if (count != 0)
            {
                *width = 0;
                nlen = mmi_ucs2strlen((const CHAR *)text);
                if(underline_array[0] != 0)
                {
                    n = underline_array[0];
                    gui_set_font(&text_font);
                    gui_measure_string_n(text, n, &iwidth, &iheight);
                    *width += iwidth;
                    text += n;
                    nlen -= n;
                }
            
                while(nlen > 0)
                {
                    n = underline_array[i + 1] - underline_array[i] + 1;
                
                    text_font.underline = 1;
                    text_font.bold = 1;
                    gui_set_font(&text_font);
                    gui_measure_string_n(text, n, &iwidth, &iheight);
                    *width += iwidth;
               
                    text += n;
                    nlen -= n;
                    if (underline_array[i + 2])
                    {
                        n = underline_array[i + 2] - underline_array[i + 1] - 1;
                        text_font.underline = underline;
                        text_font.bold = bold;
                        gui_set_font(&text_font);
                        gui_measure_string_n(text, n, &iwidth, &iheight);
                        *width += iwidth;             
                        text += n;
                        nlen -= n;
                    }
                    i = i + 2;
                    count --;
                    if (count == 0)
                    {
                        break;
                    }
                    if(underline_array[i] == 0 || i >= MAX_SUB_MENU_SIZE - 2)
                    {
                        break;
                    }
                }
                if (nlen)
                {
                    text_font.underline = underline;
                    text_font.bold = bold;
                    gui_set_font(&text_font);
                    gui_measure_string(text, &iwidth, &iheight);
                    *width += iwidth;
                }
            }

            applib_asm_free_anonymous(underline_array);
        }
    }
#endif  // __MMI_CAT203_SUPPORT__
    mi->text_width = *width;
    mi->text_height = *height;
}

#ifndef __MMI_UI_MENU_SLIM__
/*****************************************************************************
 * FUNCTION
 *  gui_filled_area_is_animation
 * DESCRIPTION
 *  Decide whether to show animation.
 * PARAMETERS
 *  f              [IN]         filler area
 * RETURNS
 *  void
 *****************************************************************************/
static MMI_BOOL gui_filled_area_is_animation(UI_filled_area *f)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (f && 
        f->flags & UI_FILLED_AREA_TYPE_BITMAP && 
        f->b &&
        (f->b[0] == GDI_IMAGE_TYPE_PNG_SEQUENCE ||
        f->b[0] == GDI_IMAGE_TYPE_ABM_SEQUENCE || 
        f->b[0] == GDI_IMAGE_TYPE_AB2_SEQUENCE || 
        f->b[0] == GDI_IMAGE_TYPE_PNG_SEQUENCE_FILE_OFFSET ||
        f->b[0] == GDI_IMAGE_TYPE_ABM_SEQUENCE_FILE_OFFSET || 
        f->b[0] == GDI_IMAGE_TYPE_AB2_SEQUENCE_FILE_OFFSET))
    {
        return MMI_TRUE;
    }
    return MMI_FALSE;
}
#endif

#ifndef __MMI_UI_MENU_SLIM__
/*****************************************************************************
 * FUNCTION
 *  gui_scroll_text_draw_animated_effect_filler
 * DESCRIPTION
 *  Draw the animated highlighter filler for scrolling text.
 * PARAMETERS
 *  x1      [IN]        x1
 *  y1      [IN]        y1
 *  x2      [IN]        x2
 *  y2      [IN]        y2
 *  f       [IN]        filler
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_scroll_text_draw_animated_effect_filler(S32 x1, S32 y1, S32 x2, S32 y2, UI_filled_area *f)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 max_frame, repeat_time;
    S32 current_anim_frame = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    xstart_effect = x1;
    ystart_effect = y1;
    xend_effect = x2;
    yend_effect = y2;

    /* get the number of frames in the animation */
    repeat_time = gdi_anim_get_count(f->b);
    gdi_image_get_frame_count(f->b, &max_frame);  

    if (list_highlight_effect_current_frame >= max_frame)
    {
        list_highlight_effect_current_frame = 0;
    }

    gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_TRANSPARENT);
    if (mmi_is_redrawing_bk_screens())
    {
        gdi_image_draw_animation_single_frame(x1, y1, f->b, (S16) max_frame - 1); 
    }
    else if (list_highlight_effect_current_frame == 0 && repeat_time == 1)
    {
        gdi_image_draw_animation_single_frame(x1, y1, f->b, (S16) max_frame - 1);      /* Show frame by frame no. */
    }
    else if (list_highlight_effect_current_frame == max_frame - 1 && repeat_time == 1)
    {   
        /* the last frame is already shown, go back to the first frame */
        //gdi_image_draw_animation_single_frame(x1, y1, f->b, 0);
        gdi_image_draw_frames(x1, y1, f->b, (S16) list_highlight_effect_current_frame);  
        //gui_draw_list_highlight_effect_last_frame();                
        list_highlight_effect_current_frame = 0;
#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__		
        list_highlight_effect_times = 1;
#endif
        /* prevent from drawing the menu item twice when it is already scrolling */
        //gui_start_timer(UI_text_menuitem_scroll_time, gui_scroll_start_handler_for_list_effects);
        
    }
#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
    else if (list_highlight_effect_current_frame <= max_frame && list_highlight_effect_times == 0)
#else
    else if (list_highlight_effect_current_frame <= max_frame)
#endif

    {  
#ifdef __MMI_UI_LIST_SLIDE_EFFECT__
        if (anim_handle)
        {
            current_anim_frame = gdi_anim_get_current_frame_number(anim_handle);
        }
        else
#endif /* __MMI_UI_LIST_SLIDE_EFFECT__ */
        {
            current_anim_frame = list_highlight_effect_current_frame;
        }
        
        if (current_anim_frame == 0)
        {
            current_anim_frame = max_frame - 1;
        }
        else
        {
            current_anim_frame--;
        }

        gdi_image_draw_frames(x1, y1, f->b, (S16) current_anim_frame);      /* Show frame by frame no. */    
    }
    else
    {
        gdi_image_draw_animation_single_frame(x1, y1, f->b, (S16) max_frame - 1);      /* Show frame by frame no. */
    }
}
#endif

/*****************************************************************************
* FUNCTION
*  UI_dummy_scrolling_text_draw_background
* DESCRIPTION
*  Dummy function of draw background of scrolling text
* PARAMETERS
*  x1           [IN]        Start x position
*  y1           [IN]        Start y position
*  x2           [IN]        End x position
*  y2           [IN]        End y position
* RETURNS
*  void
*****************************************************************************/
static void UI_dummy_scrolling_text_draw_background(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(x1);
    UI_UNUSED_PARAMETER(y1);
    UI_UNUSED_PARAMETER(x2);
    UI_UNUSED_PARAMETER(y2);
}


#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
/*****************************************************************************
* FUNCTION
*  gui_list_effect_is_blocked
* DESCRIPTION
*  Get whether list effect is blocked.
* PARAMETERS
*  void   
* RETURNS
*  S32
*  0    :    List effect is unblocked
*  1    :    List effect is blocked
*****************************************************************************/
S32 gui_list_effect_is_blocked(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return gblock_list_effect;
}
#endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */


