/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*****************************************************************************
 *
 * Filename:
 * ---------
 *   wgui_categories_idlescreen.c
 *
 * Project:
 * --------
 *   Maui_Software
 *
 * Description:
 * ------------
 * Idle Screen related categories.
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/
#include "MMI_features.h"
#include "CustThemesRes.h"
#include "wgui_softkeys.h"
#include "gui_font_size.h"
#include "IdleAppDef.h"
#include "IdleHomescreenGprot.h"
#include "DialerGprot.h"
#include "SettingGprots.h"
#include "PhoneSetup.h"
#include "gui_hardware_dependent.h"
#include "wgui_status_icon_bar.h"
#include "wgui_softkeys.h"
#ifdef __MMI_AUDIO_PLAYER__
/* dependent headers for AudioPlayerXXX.h" */
#include "Conversions.h"
#endif /* __MMI_AUDIO_PLAYER__ */


#ifdef __MMI_AUDIO_PLAYER__
#include "AudioPlayerType.h"
#endif /* __MMI_AUDIO_PLAYER__ */ 

#include "SATGProts.h"

#include "fs_type.h"

#if defined(__MMI_OP01_DCD__)
#include "DCDGprot.h"
#include "ui_dcd_porting.h"   /* for DCD idle screen */
#endif /* defined(__MMI_OP01_DCD__) */

#include "Drm_gprot.h"  /* DRM check */

#if defined(__MMI_CALENDAR_ON_IDLE_SCREEN__)
#include "CalendarGprot.h"
#endif /* defined(__MMI_CALENDAR_ON_IDLE_SCREEN__) */

#if defined(__MMI_DUAL_SIM_MASTER__)||defined(__KJX_FUN__)	//xb add 2017-07-18
// #include "MTPNP_AD_master_header.h"
// #include "MTPNP_PFAL_category_screen.h"
#include "ModeSwitchSrvGprot.h"
#endif	/* __MMI_DUAL_SIM_MASTER__ */

#ifdef __MMI_IDLE_SCREEN_ICON_SHORTCUT__
#include "wgui_icon_bar.h"
#endif /* __MMI_IDLE_SCREEN_ICON_SHORTCUT__ */

#include "lcd_if.h"

#include "IdleHomescreenGprot.h"
#ifdef __PLUTO_MMI_PACKAGE__
#include "UMGProt.h"
#endif

#include "IdleGprot.h"

#if defined(__MMI_OP11_HOMESCREEN_0301__) || defined(__MMI_OP11_HOMESCREEN_0302__)   
#include "HomeScreenOp11V32Gprot.h"     
#endif /* defined( __MMI_OP11_HOMESCREEN_0301__) || defined(__MMI_OP11_HOMESCREEN_0302__) */

/*RHR changes*/
#include "gdi_const.h"
#include "gdi_include.h"
#include "gdi_datatype.h"
#include "MMIDataType.h"
#include "gui_config.h"
#include "wgui_categories_idlescreen.h"
#include "gui_data_types.h"
#include "gui_windows.h"
#include "kal_general_types.h"
#include "gui_buttons.h"
#include "mmi_rp_app_uiframework_def.h"
#include "gui_effect_oem.h"
#include "gui.h"
#include "wgui.h"
#include "wgui_categories_util.h"
#include "gui_typedef.h"
#include "wgui_include.h"
#include "gui_themes.h"
#include "l4c_nw_cmd.h"
#include "mmi_rp_srv_status_icons_def.h"
#include "PixcomFontEngine.h"
#include "gui_switch.h"
#include "wgui_draw_manager.h"
#include "string.h"
#include "Unicodexdcl.h"
#ifndef __OPTR_NONE__
#include "operator_gui.h"
#endif
#include "wgui_categories_idlescreen_op.h"
#include "app_datetime.h"
#include "PhoneSetupResList.h"
#include "lcd_sw_inc.h"
#include "Gui_Setting.h"
#include "drm_def.h"
#include "fs_errcode.h"
#include "GlobalResDef.h"
#include "MessagesMiscell.h"
#include "kal_public_api.h"
#include "DebugInitDef_Int.h"
#include "CustDataRes.h"
#include "mmi_frm_input_gprot.h"
#include "wgui_touch_screen.h"
#include "mmi_frm_events_gprot.h"
#include "wgui_categories_enum.h"
#include "wgui_categories_list.h"
#include "drm_errcode.h"
#include "custom_mmi_default_value.h"
#include "mmi_rp_app_idle_def.h"
#include "IdleAppResDef.h"
#include "wgui_inputs.h"
#include "gui_inputs.h"
#include "ScrLockerGprot.h"
#include "WguiCategoryGprot.h"
#include "Gpiosrvgprot.h"
#if defined(__KJX_FUN__)
#include "Kjx_prin.h"
#include "mmi_rp_app_kjx_def.h"
#endif

/*RHR changes*/

#define  NORMAL_IDLE_SCREEN        0
#define  ANALOG_IDLE_SCREEN        1
#define  DIGITAL_IDLE_SCREEN       2

#define  NORMAL_SCREEN_SAVER       0
#define  ANALOG_SCREEN_SAVER       1
#define  DIGITAL_SCREEN_SAVER      2

#define  VIEW_WALLPAPER_CLOCK      1
#define  VIEW_SCREENSAVER_CLOCK    2
#define  PREVIEW_CLOCK             3

#define  min(a,b)    (((a) < (b)) ? (a) : (b))

#ifndef WIN32
extern MMI_BOOL srv_backlight_is_lcd_sleep(void);
#endif

GDI_HANDLE wgui_layer_1 = GDI_LAYER_EMPTY_HANDLE;
GDI_HANDLE wgui_base_layer = GDI_LAYER_EMPTY_HANDLE;

U8 idle_screen_type = NORMAL_IDLE_SCREEN;
/*
#ifdef __MMI_WALLPAPER_ON_BOTTOM__
static U8 gIsWallpaperChange = 0;
#endif 
*/
static S32 gis_on_idlescreen = 0;
#ifdef __MMI_SEARCH_WEB__
static scrolling_text g_search_tab_scroll_text;
#endif
#ifdef __DRM_SUPPORT__
static S32 consumer;
#endif

static wgui_cat033_reminder_area_info g_wgui_cat033_reminder[wgui_cat033_reminder_total] = {0};  /* reminder array */
#if defined(__MMI_SEARCH_WEB__)
static wgui_cat033_search_area_info g_wgui_cat033_search;
#endif
UI_string_type idle_screen_network_name = NULL;    /* idle screen netwrok name */
UI_string_type idle_screen_network_status = NULL;  /* idle screen network status */

scrolling_text extra_scrolling_text;    /* idle screen scrolling text */
scrolling_text *extra_scrolling_text_ptr = NULL;  /* idle screen scrolling text pointer */
S32 extra_text_x1 = -1;
S32 extra_text_y1 = -1;
S32 extra_text_x2 = -1;
S32 extra_text_y2 = -1;
static MMI_BOOL g_wgui_cat033_redraw_scrolling_text = MMI_TRUE;    /* record if need to redraw scrolling text */
#ifdef __MMI_UI_TECHNO_IDLESCREEN_BAR__
static MMI_BOOL g_wgui_cat033_techno_text_scroll = MMI_FALSE;      /* record if scroll network name & network status on techno bar */
#endif
static GDI_HANDLE g_wgui_cat033_text_abm_layer = GDI_NULL_HANDLE;  /* abm source layer for print text */
/* VIJAYAN*/
#ifdef __MMI_FANCY_SCREEN_LOCK__
typedef enum
{
    NETWORK1_NAME_TEXT_ON_IDLE,
    NETWORK2_NAME_TEXT_ON_IDLE,
    TECHNO_TEXT_TYPE_TOTAL
} wgui_cat030_text_type;

#define WGUI_CAT030_TECHNO_STRING_SPACE (1.4)
#define WGUI_CAT030_PAUSE_TIMER (5000)
#define WGUI_CAT030_VSCROLL_TIMER (500)

static MMI_BOOL g_wgui_cat030_redraw_scrolling_text = MMI_TRUE;    /* record if need to redraw scrolling text */
static S32 g_wgui_cat030_lock_network_scroll_count = 0;
static U8 g_wgui_cat030_current_text_type = NETWORK1_NAME_TEXT_ON_IDLE;
static U8 g_wgui_cat030_operator_on_fancy_lock_screen = 0;
#endif

S32 cat33_image_x;         /* x position of wallpaer */
S32 cat33_image_y;         /* y position of wallpaer */
S32 cat33_image_width;     /* image width of wallpaer */
S32 cat33_image_height;    /* image height of wallpaper */

S32 cat33_n_frames = 0;      /* total number frames of animation wallpaper */
S32 cat33_frame_number = 0;  /* current frame number of animation wallppaer */
S32 cat33_animation_delay = 1000;  /* the delay time to show next frame of animation wallpapaer */

U8 screen_saver_type = NORMAL_SCREEN_SAVER;   /* type of screen saver (normal, analog, digital) */
PU8 ScreenSaverName;

#ifdef __MMI_ANALOG_CLOCK__
void analog_clock_initialize(void);
#endif

void draw_wallpaper(void);


extern S32 MAIN_LCD_device_width;   /* Main lcd width */
extern S32 MAIN_LCD_device_height;  /* Main LCD height */

extern BOOL r2lMMIFlag;  /* R2L characters */

extern U16 on_idle_screen;

#if defined(ENABLE_ANIMATED_WALLPAPERS) && defined(__GDI_MEMORY_PROFILE_2__)
extern GDI_HANDLE animation_handle;
#endif 

extern MMI_ID_TYPE idle_screen_wallpaper_ID;       /* image id of wallpaper */
extern CHAR *idle_screen_wallpaper_name;             /* image name of wallpaper */
extern CHAR *idle_screen_wallpaper_name_original;
extern CHAR *idle_screen_screensaver_name;
extern CHAR *idle_screen_cache_name;
extern MMI_ID_TYPE idle_screen_cache_id;

extern S32 PhnsetScreenSaverBadFileCallBack(U16 StrID);
extern void PhnsetWallpaperBadFileCallBack(U16 imgID);

extern void dm_set_scr_bg_image_no_draw(U16 image_id, CHAR *file_name, S32 x, S32 y, U8 opacity);

extern U16 title_bg_id;

extern icontext_button MMI_softkeys[];

extern void leave_idle_screen(void);

#if defined(__MMI_TOUCH_IDLESCREEN_SHORTCUTS__)
extern void mmi_um_entry_main_message_menu(void);
#endif

#if defined (__MMI_TOUCH_SCREEN__) && defined (__MMI_TOUCH_IDLESCREEN_SHORTCUTS__)
extern void gui_touch_feedback_play(gui_touch_feedback_enum event_enum);
#endif

#if defined(__MMI_DUAL_SIM_MASTER__)||defined(__KJX_FUN__)
UI_string_type g_slave_idle_screen_line1text = NULL;
UI_string_type g_slave_idle_screen_line2text = NULL;
#endif /* __MMI_DUAL_SIM_MASTER__ */

#ifdef __MMI_UI_TECHNO_IDLESCREEN_BAR__
typedef enum
{
    NETWORK_NAME_TEXT_ON_IDLE,
    NETWORK_STATUS_TEXT_ON_IDLE,
    TECHNO_TEXT_TYPE_TOTAL
} wgui_cat033_techno_text_type;

#define WGUI_CAT033_TECHNO_STRING_SPACE (1.4)
#define WGUI_CAT033_PAUSE_TIMER (5000)
#define WGUI_CAT033_VSCROLL_TIMER (500)

MMI_ID_TYPE idlescreen_bar_id = IMG_TECHNO_ANALOG_CLOCK;
static U8 g_wgui_cat033_techno_current_text_type = NETWORK_NAME_TEXT_ON_IDLE;
static S32 g_wgui_cat033_techno_scroll_count = 0;

extern MMI_BOOL PhnsetGetShowDateTimeStatus(void);

#ifdef __MMI_DUAL_SIM_MASTER__
#define WGUI_CAT033_DUAL_SIM_DATE_HEIGHT (20)
#define WGUI_CAT033_DUAL_SIM_Y_GAP (2)
#endif /* __MMI_DUAL_SIM_MASTER__ */
#endif /* __MMI_UI_TECHNO_IDLESCREEN_BAR__ */ 


#if defined(__DUAL_SIM_IDLE_TEXT_AT_SAME_POSITION__) /* Dual SIM show at same position. */
typedef enum
{
    SIM1_TEXT_ON_IDLE,
    SIM2_TEXT_ON_IDLE
} wgui_cat033_dual_sim_text_type;
static U8 g_wgui_cat033_dual_sim_current_text_type = SIM1_TEXT_ON_IDLE;
#endif /* defined(__DUAL_SIM_IDLE_TEXT_AT_SAME_POSITION__) */


#if defined(__MMI_SCREEN_SWITCH_EFFECT__) && defined(__MMI_TOUCH_IDLESCREEN_SHORTCUTS__) && defined(__MMI_UI_TECHNO_IDLESCREEN_BAR__)
#if 0
/* under construction !*/
/* under construction !*/
#endif
#endif /* defined(__MMI_SCREEN_SWITCH_EFFECT__) && defined(__MMI_TOUCH_IDLESCREEN_SHORTCUTS__) && defined(__MMI_UI_TECHNO_IDLESCREEN_BAR__) */
#ifdef __MMI_MAINLCD_96X64__
    static scrolling_text g_network_names_scroll;
#endif

#if defined(__KJX_OLED_64_48_UI__)||defined(__KJX_FUN__)	//xb add 2016-09-01
#include "UcmSrvGprot.h"
#include "PowerOnChargerProt.h"
#include "PhoneBookResDef.h"
#include "TimerEvents.h"
#include "SimCtrlSrvGprot.h"
#include "Kjx_prin.h"
#include "kjx_gprs_format.h"

#define is_incomingcall() (srv_ucm_query_call_count(SRV_UCM_INCOMING_STATE, SRV_UCM_CALL_TYPE_ALL,NULL) > 0)
#define is_outgoingcall() (srv_ucm_query_call_count(SRV_UCM_OUTGOING_STATE, SRV_UCM_CALL_TYPE_ALL,NULL) > 0)
#define is_call() (srv_ucm_query_call_count(SRV_UCM_CALL_STATE_ALL, SRV_UCM_CALL_TYPE_ALL, NULL) > 0)
#define is_connectedcall() (srv_ucm_query_call_count(SRV_UCM_CALL_STATE_CONNECTED, SRV_UCM_CALL_TYPE_ALL, NULL) > 0)

#ifdef __KJX_WEATHER_SUPPORT__
#define IMG_WEATHER_MAX_NUM	33
#define IMG_WEATHER_TOP	"IMG_GLOBAL_KJX_WEATHER_BAOXUE"

typedef struct
{
	U8 img_name[50];
	U16 img_id;
}kjx_weather_image_struct;

static kjx_weather_image_struct kjx_weather_img[IMG_WEATHER_MAX_NUM] = {
						"BAOXUE",					IMG_GLOBAL_KJX_WEATHER_BAOXUE,
						"BAOYU",					IMG_GLOBAL_KJX_WEATHER_BAOYU,
						"BAOYUZHUANDABAOYU",		IMG_GLOBAL_KJX_WEATHER_BAOYUZHUANDABAOYU,
						"DABAOYU",					IMG_GLOBAL_KJX_WEATHER_DABAOYU,
						"DABAOYUZHUANTEDABAOYU",	IMG_GLOBAL_KJX_WEATHER_DABAOYUZHUANTEDABAOYU,
						"DAXUE",					IMG_GLOBAL_KJX_WEATHER_DAXUE,
						"DAXUEZHUANBAOXUE",			IMG_GLOBAL_KJX_WEATHER_DAXUEZHUANBAOXUE,
						"DAYU",						IMG_GLOBAL_KJX_WEATHER_DAYU,
						"DAYUZHUANBAOYU",			IMG_GLOBAL_KJX_WEATHER_DAYUZHUANBAOYU,
						"DONGYU",					IMG_GLOBAL_KJX_WEATHER_DONGYU,
						"DUOYUN",					IMG_GLOBAL_KJX_WEATHER_DUOYUN,
						"FUCHEN",					IMG_GLOBAL_KJX_WEATHER_FUCHEN,
						"LEIZHENYU",				IMG_GLOBAL_KJX_WEATHER_LEIZHENYU,
						"LEIZHENYUBANYOUBINGBAO",	IMG_GLOBAL_KJX_WEATHER_LEIZHENYUBANYOUBINGBAO,
						"MAI",						IMG_GLOBAL_KJX_WEATHER_MAI,
						"QIANGSHACHENBAO",			IMG_GLOBAL_KJX_WEATHER_QIANGSHACHENBAO,
						"QING",						IMG_GLOBAL_KJX_WEATHER_QING,
						"SHACHENBAO",				IMG_GLOBAL_KJX_WEATHER_SHACHENBAO,
						"TEDABAOYU",				IMG_GLOBAL_KJX_WEATHER_TEDABAOYU,
						"WU",						IMG_GLOBAL_KJX_WEATHER_WU,
						"XIAOXUE",					IMG_GLOBAL_KJX_WEATHER_XIAOXUE,
						"XIAOXUEZHUANZHONGXUE",		IMG_GLOBAL_KJX_WEATHER_XIAOXUEZHUANZHONGXUE,
						"XIAOYU",					IMG_GLOBAL_KJX_WEATHER_XIAOYU,
						"XIAOYUZHUANZHONGYU",		IMG_GLOBAL_KJX_WEATHER_XIAOYUZHUANZHONGYU,
						"YANGSHA",					IMG_GLOBAL_KJX_WEATHER_YANGSHA,
						"YIN",						IMG_GLOBAL_KJX_WEATHER_YIN,
						"YUJIAXUE",					IMG_GLOBAL_KJX_WEATHER_YUJIAXUE,
						"ZHENXUE",					IMG_GLOBAL_KJX_WEATHER_ZHENXUE,
						"ZHENYU",					IMG_GLOBAL_KJX_WEATHER_ZHENYU,
						"ZHONGXUE",					IMG_GLOBAL_KJX_WEATHER_ZHONGXUE,
						"ZHONGXUEZHUANDAXUE",		IMG_GLOBAL_KJX_WEATHER_ZHONGXUEZHUANDAXUE,
						"ZHONGYU",					IMG_GLOBAL_KJX_WEATHER_ZHONGYU,
						"ZHONGYUZHUANDAYU",			IMG_GLOBAL_KJX_WEATHER_ZHONGYUZHUANDAYU
					};
#endif

//#define KJX_IDLE_DEBUG

GDI_HANDLE idle_osd_layer;
GDI_HANDLE idle_skin_layer;

BOOL kjx_is_show_idlescreen = FALSE;

scrolling_text kjx_scrolling_text;
scrolling_text *kjx_scrolling_text_ptr=NULL;
UI_string_type kjx_scrolling_show[512] = {0};
char factory_test_show[] = {0xE5, 0x5D, 0x82, 0x53, 0x4B, 0x6D, 0xD5, 0x8B, 0x21, 0x6A, 0x0F, 0x5F, 0x00, 0x00};//工厂测试模式

extern U8 kjx_audio_status;//0 停止1 播放2暂停
extern int g_start_screen;
extern U16 kjx_call_index;
extern U32 kjx_audio_time;
extern U32 kjx_call_time;
extern BOOL kjx_is_listen;
extern BOOL steps_is_use;
extern BOOL heart_is_use;
extern BOOL kjx_sos_in_call;
extern BOOL kjx_sos_screen;
extern BOOL kjx_is_in_charge;
extern BOOL kjx_audio_is_playing;

extern U8 kjx_call_display[SRV_UCM_MAX_NUM_URI_LEN + 1];
extern U8 kjxImei[SRV_MAX_IMSI_LEN];

extern charbat_context_struct g_charbat_context;
#ifdef __KJX_WEATHER_SUPPORT__
extern kjx_weather_struct kjx_weather;
#endif

#if defined(__BOSCH_BMP280_PRESSURE__)
extern WCHAR Temp_show[128];
extern WCHAR Altitude_show[128];
#endif

#if defined(__KJX_DJ_SUPPORT__)
extern WCHAR dj_chanle_show[128];
#endif

#if defined(__KJX_FUN_STEPS__)
extern WCHAR Step_show[128];
extern WCHAR Calorie_show[128];
#endif

extern BOOL kjx_gps_is_on( void );
extern char Npr_Tts_is_playing(void);
extern int kjx_get_foctory_test_mode(void);

void kjx_redraw_text_background(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_push_clip();
    gui_set_clip(x1, y1, x2, y2);
	gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_BLACK); 
    gui_pop_clip();
}

void kjx_handle_text_scroll(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_handle_scrolling_text(&kjx_scrolling_text);
}

void kjx_show_scrolling_text(S32 x1, S32 y1, S32 x2, S32 y2, UI_string_type show_infor)
{
	/*----------------------------------------------------------------*/
	/* Local Variables												  */
	/*----------------------------------------------------------------*/
	S32 width = 0, height = 0;
	S32 x_offset = 0;
	S32 y_offset = 0;
	GDI_HANDLE wallpaper_layer;
	
	/*----------------------------------------------------------------*/
	/* Code Body													  */
	/*----------------------------------------------------------------*/
#ifdef KJX_IDLE_DEBUG	
#if defined(__KJX_LOG_OUTPUT__)
	LOGD("kjx_scrolling_text_ptr:%d", kjx_scrolling_text_ptr);
#endif
#endif
	/* stop previous scroll text */	
	if (kjx_scrolling_text_ptr != NULL)
	{
		gui_scrolling_text_stop(kjx_scrolling_text_ptr);
		kjx_scrolling_text_ptr = NULL;
	}

	kjx_scrolling_text_ptr = &kjx_scrolling_text;
		
    gui_create_scrolling_text(
			kjx_scrolling_text_ptr,
			x1,
			y1,
			x2-x1,
			y2-y1,
			show_infor,
			kjx_handle_text_scroll,
			kjx_redraw_text_background,
			*current_MMI_theme->idle_scr_network_extra_color,
			*current_MMI_theme->idle_scr_network_extra_border_color);

	kjx_scrolling_text_ptr->scroll_gap = 20;

	gui_change_scrolling_text(kjx_scrolling_text_ptr, show_infor);
	gui_show_scrolling_text(kjx_scrolling_text_ptr);
}

void kjx_set_key_handler(void)
{

	ClearKeyHandler(KEY_EXTRA_A, KEY_EVENT_UP);
	ClearKeyHandler(KEY_EXTRA_A, KEY_EVENT_DOWN);
	ClearKeyHandler(KEY_EXTRA_A, KEY_LONG_PRESS);

	ClearKeyHandler(KEY_EXTRA_B, KEY_EVENT_UP);
	ClearKeyHandler(KEY_EXTRA_B, KEY_EVENT_DOWN);
	ClearKeyHandler(KEY_EXTRA_B, KEY_LONG_PRESS);

	ClearKeyHandler(KEY_EXTRA_1, KEY_EVENT_UP);
	ClearKeyHandler(KEY_EXTRA_1, KEY_EVENT_DOWN);
	ClearKeyHandler(KEY_EXTRA_1, KEY_LONG_PRESS);
}

void mmi_phb_list_release_call(void)
{
	if (mmi_frm_group_is_present(GRP_ID_PHB_GROUP))
    {
        mmi_frm_group_close(GRP_ID_PHB_GROUP);
    }

	mmi_phb_launch_exit();
	mmi_frm_scrn_close_active_id();
}

void mmi_disp_with_call(void)
{
	gdi_handle mmi_base_layer;
	U16 img_id = 0;
	S32 img_w,img_h;
	S32 num_w,num_h;
	U32 gap_x = 0,gap_y = 4;
	S32 x,y;

	
	switch(kjx_call_index)
	{
	case 1:
		img_id = IMG_GLOBAL_KJX_SENDING;
		break;

	case 2:
		img_id = IMG_GLOBAL_KJX_CALLING;
		break;

	case 3:
		img_id = IMG_GLOBAL_KJX_CALL_END;
		break;

	case 4:
		img_id = IMG_GLOBAL_KJX_NO_NUMBER;
		break;

	case 5:
		img_id = IMG_GLOBAL_KJX_INCOMING_CALL;
		break;
	}

	if(img_id==0)
		return;

	gdi_layer_get_base_handle(&mmi_base_layer);

	gdi_layer_lock_frame_buffer();
	gdi_layer_push_and_set_active(mmi_base_layer);
	gdi_layer_clear(GDI_COLOR_BLACK);

	gui_measure_image(get_image(img_id),&img_w,&img_h);
	gdi_image_draw_id(0, 0,img_id);

	if(((kjx_call_index == 1) || (kjx_call_index == 5)) && (mmi_ucs2strlen(kjx_call_display)>0))
	{
		gui_measure_string((UI_string_type)kjx_call_display,&num_w,&num_h);
		gui_set_font(&MMI_small_font);
		gui_set_text_color(gui_color(255,255,255));
		gui_move_text_cursor(gap_x,img_h + gap_y);
		gui_print_text((UI_string_type)kjx_call_display);
	}

	gdi_layer_pop_and_restore_active();
	gdi_layer_unlock_frame_buffer();
	gdi_layer_blt(mmi_base_layer,0,0,0,0,0,UI_DEVICE_WIDTH,UI_DEVICE_HEIGHT);
}

void mmi_show_scrolling_infor(void)
{
	S32 x1, y1, x2, y2;
	S32 str_w, str_h;

	x1 = 0;
	y1 = 18;
	x2 = UI_DEVICE_WIDTH-1;
	y2 = y1+14;

	if(srv_shutdown_is_running())
	{
	#ifdef KJX_IDLE_DEBUG
	#if defined(__KJX_LOG_OUTPUT__)
		LOGD("shutdown_is_running return");
	#endif
	#endif
		return;
	}


	srv_backlight_turn_on(SRV_BACKLIGHT_SHORT_TIME);//xb add 20106-09-07 点亮屏幕

#if 1	//xb add 2017-07-18
	if(is_on_idlescreen()&&srv_bootup_is_launched())
	{
		//mmi_idle_display();
		idle_screen_show_network_details();
	}
#else
	gdi_layer_push_and_set_active(idle_osd_layer);
#if(UI_DOUBLE_BUFFER_SUPPORT)
	gui_lock_double_buffer();
#endif

	if(mmi_ucs2strlen((CHAR*)kjx_scrolling_show) <= 0)
	{
		if(kjx_get_foctory_test_mode() == 1)
		{
			char strtmp[50] = {0};

			if(g_start_screen > 0)
			{
				if (kjx_scrolling_text_ptr != NULL)
				{
					gui_scrolling_text_stop(kjx_scrolling_text_ptr);
					kjx_scrolling_text_ptr = NULL;
				}
				
				gdi_draw_solid_rect(0, 0, UI_DEVICE_WIDTH, UI_DEVICE_HEIGHT, GDI_COLOR_WHITE);

			#if(UI_DOUBLE_BUFFER_SUPPORT)
				gui_unlock_double_buffer();
				gui_BLT_double_buffer(0, 0, UI_DEVICE_WIDTH, UI_DEVICE_HEIGHT);
			#endif
				gdi_layer_pop_and_restore_active(); 

				return;
			}
			mmi_asc_to_ucs2((CHAR*)strtmp, (CHAR*)kjxImei);
			mmi_ucs2cpy((CHAR*)kjx_scrolling_show, (CHAR*)strtmp);
		}
		else
		{
			mmi_ucs2cpy((CHAR*)kjx_scrolling_show, (CHAR*)GetString(STR_KJX_IDLE_SHOW_TOUR));
		}
	}

	kjx_show_scrolling_text(x1, y1, x2, y2, (UI_string_type)kjx_scrolling_show);//景点名称		

    gdi_layer_push_and_set_clip(x1, y1, x2, y2);
    gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_BLACK);

    gui_scrolling_text_stop(&kjx_scrolling_text);

	gui_measure_string((UI_string_type)kjx_scrolling_show, &str_w, &str_h);
	if (str_w > (x2 -x1))
	{
		/* scrolling */
		gui_show_scrolling_text(&kjx_scrolling_text);
	}
	else
	{
		/* background */
		gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_BLACK);
	#ifdef __MMI_BIDI_ALG__
		if (r2lMMIFlag)
		{
			gui_move_text_cursor(x1 + (UI_DEVICE_WIDTH + str_w) / 2, (y1+y2-str_h)/2);
		}
		else
	#endif
		{
			gui_move_text_cursor(x1 + (UI_DEVICE_WIDTH - str_w) / 2, (y1+y2-str_h)/2);
		}
		gui_print_text((UI_string_type)kjx_scrolling_show);
	}

	gdi_layer_pop_clip();
	
#if(UI_DOUBLE_BUFFER_SUPPORT)
    gui_unlock_double_buffer();
    gui_BLT_double_buffer(x1, y1, x2, y2);
#endif
	gdi_layer_pop_and_restore_active();	
#endif
}

void mmi_redraw_idlescreen(void)
{
	U32 gap_x = 2,gap_y = 2;
	S32 x,y,str_w,str_h,img_w,img_h,dot_w,dot_h;
	U16 signal_img_id,bat_img_id,gps_status_img;
	static U16 dot_show = 0;
	U32 time_x = 0,time_y = 35;
	MYTIME curr_time;
	U8 idle_h0,idle_m0,idle_h1,idle_m1;
	extern U8 battery_percentage;

	return;//xb add 2017-07-18 不用在这里再显示时间了
	
	if(srv_shutdown_is_running())
	{
	#ifdef KJX_IDLE_DEBUG
	#if defined(__KJX_LOG_OUTPUT__)
		LOGD("shutdown_is_running return");
	#endif
	#endif
		return;
	}

#if(UI_DOUBLE_BUFFER_SUPPORT)
	gui_lock_double_buffer();
#endif 
#ifdef __GDI_MEMORY_PROFILE_2__
	gdi_push_and_set_alpha_blending_source_layer(idle_skin_layer);
#endif /* __GDI_MEMORY_PROFILE_2__ */ 

	if((kjx_get_foctory_test_mode() == 1) && (g_start_screen > 0))
	{
	#ifdef __GDI_MEMORY_PROFILE_2__
		gdi_pop_and_restore_alpha_blending_source_layer();
	#endif /* __GDI_MEMORY_PROFILE_2__ */ 

	#if(UI_DOUBLE_BUFFER_SUPPORT)
	    gui_unlock_double_buffer();
	    gui_BLT_double_buffer(0, 0, UI_DEVICE_WIDTH-1, UI_DEVICE_HEIGHT-1);
	#endif /* (UI_DOUBLE_BUFFER_SUPPORT) */ 		
	
		StartTimer(KJX_TIMER_ID_REDRAW_IDLESCREEN, 1000, mmi_redraw_idlescreen);

		return;
	}
	
	// 信号显示
	if(mmi_bootup_is_sim_valid())
	{
		switch(wgui_status_icon_bar_icons[STATUS_ICON_SIGNAL_STRENGTH].state)
		{
		case 0:
			signal_img_id = IMG_GLOBAL_KJX_SIGNAL2;
			break;
		case 1:
		case 2:
			signal_img_id = IMG_GLOBAL_KJX_SIGNAL3;
			break;
		case 3:
			signal_img_id = IMG_GLOBAL_KJX_SIGNAL4;
			break;
		case 4:
		case 5:
			signal_img_id = IMG_GLOBAL_KJX_SIGNAL5;
			break;

		default:
			signal_img_id = IMG_GLOBAL_KJX_SIGNAL3;
			break;
		}
	}
	else
	{
		signal_img_id = IMG_GLOBAL_KJX_NO_SIM;
	}
	
	gui_measure_image(get_image(signal_img_id),&img_w,&img_h);
	x = 2;
	y = gap_y;
	gdi_image_draw_id(x, y, signal_img_id);

	// GPS状态显示; GPRS状态显示
	if(mmi_bootup_is_sim_valid())
	{
	#if defined( __KJX_FUN_GPS__ )
		if(kjx_gps_is_on())
		{
			if(mmi_get_gps_status())
			{
				gps_status_img = IMG_GLOBAL_KJX_GPS_OK;
			}
			else
			{
				gps_status_img = IMG_GLOBAL_KJX_GPS_ON;
			}		
		}
		else
		{
			gps_status_img = IMG_GLOBAL_KJX_GPS_OFF;
		}
		
		gui_measure_image(get_image(gps_status_img),&img_w,&img_h);
		x += (gap_x+img_w);
		y = 2;
		gdi_image_draw_id(x, y, gps_status_img);
	#endif
		
		if(kjx_gprs_is_connect())
		{
			gps_status_img = IMG_GLOBAL_KJX_CONNECT;
			gui_measure_image(get_image(gps_status_img),&img_w,&img_h);
			x += (gap_x+img_w);
			gdi_image_draw_id(x, gap_y, gps_status_img);
		}
		else
		{
			if(kjx_gprs_is_connect_check())
				gps_status_img = IMG_GLOBAL_KJX_CONNECT_CHECK;
			else
				gps_status_img = IMG_GLOBAL_KJX_UNCONNECT;

			gui_measure_image(get_image(gps_status_img),&img_w,&img_h);
			x += (gap_x+img_w);
			gdi_image_draw_id(x, gap_y, gps_status_img);
		}

	}

	// 电量显示
	if (srv_charbat_is_charging())
	{ //充电状态

		bat_img_id = IMG_GLOBAL_KJX_BAT_ON_CHARGIMG;
		
		if(g_charbat_context.ChargingComplete == 1)
		{// 充满电状态
			bat_img_id = IMG_GLOBAL_KJX_BAT_ON_FULL;
		}
	}
	else if(mmi_gpio_is_charging_full())
	{	//充满电状态 
		bat_img_id = IMG_GLOBAL_KJX_BAT_ON_FULL;
	}
	else
	{
		if(1)//(battery_percentage == 0)
		{
			switch(wgui_status_icon_bar_icons[STATUS_ICON_BATTERY_STRENGTH].state)
			{
			case 0:
				bat_img_id = IMG_GLOBAL_KJX_BAT0;
				break;
			case 1:
				bat_img_id = IMG_GLOBAL_KJX_BAT1;
				break;
			case 2:
				bat_img_id = IMG_GLOBAL_KJX_BAT2;
				break;
			case 3:
				bat_img_id = IMG_GLOBAL_KJX_BAT3;
				break;
			case 4:
				bat_img_id = IMG_GLOBAL_KJX_BAT4;
				break;
			default:
				bat_img_id = IMG_GLOBAL_KJX_BAT0;
				break;
			}
		}
		else
		{
			if((battery_percentage>=80))
				bat_img_id = IMG_GLOBAL_KJX_BAT4;
			else if((battery_percentage>=50)&&(battery_percentage<80))
				bat_img_id = IMG_GLOBAL_KJX_BAT3;
			else if((battery_percentage>=30)&&(battery_percentage<50))
				bat_img_id = IMG_GLOBAL_KJX_BAT2;
			else if((battery_percentage>=10)&&(battery_percentage<30))
				bat_img_id = IMG_GLOBAL_KJX_BAT1;
			else if((battery_percentage<10))
				bat_img_id = IMG_GLOBAL_KJX_BAT0;
			else
				bat_img_id = IMG_GLOBAL_KJX_BAT0;
		}
	}

	gui_measure_image(get_image(bat_img_id),&img_w,&img_h);
	x = UI_DEVICE_WIDTH - img_w - 2;
	y = gap_y;
	gdi_image_draw_id(x, y, bat_img_id);

	gdi_draw_solid_rect(time_x, time_y, UI_DEVICE_WIDTH-1, UI_DEVICE_HEIGHT-1, GDI_COLOR_BLACK);
	gdi_layer_push_and_set_clip(time_x, time_y, UI_DEVICE_WIDTH-1, UI_DEVICE_HEIGHT-1);

	//通话状态及系统时间显示
	if(is_call())
	{
		if(is_incomingcall())
		{
			gui_measure_string((UI_string_type)GetString(STR_KJX_IDLE_INCOMING_CALL), &str_w, &str_h);
			gdi_draw_solid_rect(time_x, time_y, UI_DEVICE_WIDTH, UI_DEVICE_HEIGHT, GDI_COLOR_BLACK);
		#ifdef __MMI_BIDI_ALG__
			if (r2lMMIFlag)
			{
				gui_move_text_cursor(time_x + (UI_DEVICE_WIDTH + str_w) / 2, (time_y+UI_DEVICE_HEIGHT-str_h)/2);
			}
			else
		#endif
			{
				gui_move_text_cursor(time_x + (UI_DEVICE_WIDTH - str_w) / 2, (time_y+UI_DEVICE_HEIGHT-str_h)/2);
			}
			gui_print_text((UI_string_type)GetString(STR_KJX_IDLE_INCOMING_CALL));
		}
		else if(is_outgoingcall())
		{
			gui_measure_string((UI_string_type)GetString(STR_KJX_IDLE_OUTGOING_CALL), &str_w, &str_h);
			gdi_draw_solid_rect(time_x, time_y, UI_DEVICE_WIDTH, UI_DEVICE_HEIGHT, GDI_COLOR_BLACK);
		#ifdef __MMI_BIDI_ALG__
			if (r2lMMIFlag)
			{
				gui_move_text_cursor(time_x + (UI_DEVICE_WIDTH + str_w) / 2, (time_y+UI_DEVICE_HEIGHT-str_h)/2);
			}
			else
		#endif
			{
				gui_move_text_cursor(time_x + (UI_DEVICE_WIDTH - str_w) / 2, (time_y+UI_DEVICE_HEIGHT-str_h)/2);
			}
			gui_print_text((UI_string_type)GetString(STR_KJX_IDLE_OUTGOING_CALL));
		}
		else if(is_connectedcall())
		{
			gui_measure_string((UI_string_type)GetString(STR_KJX_IDLE_IN_CALLING), &str_w, &str_h);
			gdi_draw_solid_rect(time_x, time_y, UI_DEVICE_WIDTH, UI_DEVICE_HEIGHT, GDI_COLOR_BLACK);
		#ifdef __MMI_BIDI_ALG__
			if (r2lMMIFlag)
			{
				gui_move_text_cursor(time_x + (UI_DEVICE_WIDTH + str_w) / 2, (time_y+UI_DEVICE_HEIGHT-str_h)/2);
			}
			else
		#endif
			{
				gui_move_text_cursor(time_x + (UI_DEVICE_WIDTH - str_w) / 2, (time_y+UI_DEVICE_HEIGHT-str_h)/2);
			}
			gui_print_text((UI_string_type)GetString(STR_KJX_IDLE_IN_CALLING));
		}
	}
	else
	{
		DTGetRTCTime(&curr_time);
		idle_h0 = curr_time.nHour/10;
		idle_h1 = curr_time.nHour%10;
		idle_m0 = curr_time.nMin/10;
		idle_m1 = curr_time.nMin%10;

		gui_measure_image(get_image(IMG_GLOBAL_KJX_NUM_SMALL_0),&img_w,&img_h);
		gui_measure_image(get_image(IMG_GLOBAL_KJX_TWO_DOT),&dot_w,&dot_h);

		dot_show = !dot_show;
		x = (UI_DEVICE_WIDTH-((img_w+gap_x)*4+dot_w+2))/2;
		y = time_y+3;
		gdi_image_draw_id(x, y, IMG_GLOBAL_KJX_NUM_SMALL_0+idle_h0);
		x += img_w+gap_x;
		gdi_image_draw_id(x, y, IMG_GLOBAL_KJX_NUM_SMALL_0+idle_h1);
			
		x += img_w+gap_x+1;
		y = time_y+2;
		if(dot_show)
			gdi_image_draw_id(x, y, IMG_GLOBAL_KJX_TWO_DOT);
			
		x += img_w+gap_x+1;
		y = time_y+3;
		gdi_image_draw_id(x, y, IMG_GLOBAL_KJX_NUM_SMALL_0+idle_m0);
		x += img_w+gap_x;
		gdi_image_draw_id(x, y, IMG_GLOBAL_KJX_NUM_SMALL_0+idle_m1);	
	}

	gdi_layer_pop_clip();
	
#ifdef __GDI_MEMORY_PROFILE_2__
	gdi_pop_and_restore_alpha_blending_source_layer();
#endif /* __GDI_MEMORY_PROFILE_2__ */ 
#if(UI_DOUBLE_BUFFER_SUPPORT)
    gui_unlock_double_buffer();
    gui_BLT_double_buffer(time_x, time_y, UI_DEVICE_WIDTH-1, UI_DEVICE_HEIGHT-1);
#endif /* (UI_DOUBLE_BUFFER_SUPPORT) */ 		
	
	StartTimer(KJX_TIMER_ID_REDRAW_IDLESCREEN, 1000, mmi_redraw_idlescreen);
}

void mmi_exit_idlescreen(void)
{
#ifdef KJX_IDLE_DEBUG
#if defined(__KJX_LOG_OUTPUT__)
	LOGD("begin");
#endif
#endif

	if(kjx_is_show_idlescreen == TRUE)
	{
	#ifdef KJX_IDLE_DEBUG
	#if defined(__KJX_LOG_OUTPUT__)
		LOGD("idlescreen is exist!");
	#endif
	#endif
		kjx_is_show_idlescreen = FALSE;

		if(kjx_scrolling_text_ptr != NULL)
		{
			gui_scrolling_text_stop(kjx_scrolling_text_ptr);
			kjx_scrolling_text_ptr = NULL;
		}

		if(IsMyTimerExist(KJX_TIMER_ID_REDRAW_IDLESCREEN))
		{
			StopTimer(KJX_TIMER_ID_REDRAW_IDLESCREEN);
		}
	
	#ifdef __GDI_MEMORY_PROFILE_2__
		gdi_layer_flatten_to_base(idle_skin_layer, idle_osd_layer, 0, 0);
		gdi_layer_free(idle_skin_layer);
		gdi_layer_multi_layer_disable();
		
		/* restore blt layer as base layer only */
		gdi_layer_set_blt_layer(idle_osd_layer, 0, 0, 0);
	#endif /* __GDI_MEMORY_PROFILE_2__ */ 
	}
	else
	{
	#ifdef KJX_IDLE_DEBUG
	#if defined(__KJX_LOG_OUTPUT__)
		LOGD("idlescreen not exist!");
	#endif
	#endif
	}
}

void mmi_disp_idlescreen(void)
{
#ifdef KJX_IDLE_DEBUG
#if defined(__KJX_LOG_OUTPUT__)
	LOGD("begin");
#endif
#endif

	if(srv_shutdown_is_running())
	{
	#ifdef KJX_IDLE_DEBUG
	#if defined(__KJX_LOG_OUTPUT__)
		LOGD("shutdown_is_running return");
	#endif
	#endif
		return;
	}

#if 1
	mmi_idle_display();
#else
	kjx_is_show_idlescreen = TRUE;

#ifdef __GDI_MEMORY_PROFILE_2__
    gdi_layer_multi_layer_enable();

    /* get base layer as skin layer */
    gdi_layer_get_base_handle(&idle_osd_layer);
    gdi_layer_clear_background(GDI_COLOR_TRANSPARENT);
    gdi_layer_set_source_key(MMI_TRUE, GDI_COLOR_TRANSPARENT);
    gdi_layer_create(0, 0, UI_device_width, UI_device_height, &idle_skin_layer);
    gdi_layer_push_and_set_active(idle_skin_layer);
    gdi_layer_clear_background(GDI_COLOR_TRANSPARENT);
    gdi_layer_pop_and_restore_active();
    
    gdi_layer_set_blt_layer(idle_skin_layer, idle_osd_layer, 0, 0);
#endif/*__GDI_MEMORY_PROFILE_2__*/ 

#if(UI_DOUBLE_BUFFER_SUPPORT)
    gui_lock_double_buffer();
#endif 
	mmi_show_scrolling_infor();
	mmi_redraw_idlescreen();
#if(UI_DOUBLE_BUFFER_SUPPORT)
    gui_unlock_double_buffer();
    gui_BLT_double_buffer(0, 0, UI_device_width - 1, UI_device_height - 1);
#endif/*(UI_DOUBLE_BUFFER_SUPPORT)*/ 

	StartTimer(KJX_TIMER_ID_REDRAW_IDLESCREEN, 1000, mmi_redraw_idlescreen);

#endif
}

void mmi_show_idle_screen(void)
{
	S32 showTime = 0;
	static U16 showTotal = 0;

#ifdef KJX_IDLE_DEBUG
#if defined(__KJX_LOG_OUTPUT__)
	LOGD("begin");
#endif
#endif

	StopTimer(KJX_TIMER_ID_REDRAW_IDLESCREEN);

	if((kjx_sos_screen==TRUE)&&(kjx_call_index==4))
	{
		kjx_call_index = 0;
		kjx_sos_screen = FALSE;
		kjx_sos_in_call = FALSE;
	}

	if((kjx_call_index==3)||(kjx_call_index==4))
	{
		if(!showTotal)
		{
			showTotal++;
		}
		else
		{
			showTotal = 0;
			kjx_call_index = 0;
		}
	}

	if(kjx_call_index!=0)
	{
		showTime = 1000*2;
	}
	else
	{
		showTime = 1000;
	}

	if(kjx_call_index!=0 && kjx_is_on_work_time())
	{
		if(is_incomingcall())
		{
			if(mmi_frm_group_get_active_id() == GRP_ID_PHB_MAIN)
			{
			#if defined(__KJX_MMI_PHB__)
				mmi_phb_list_release_call();
			#endif
			}
		}
		if(kjx_is_outing_call() && kjx_is_listen)
		{
		#if defined(CUSTOMER_NAME_BDTS)
			kjx_bdts_set_call_mode(1);
		#elif defined(CUSTOMER_NAME_MEGE1)
			kjx_mege1_set_call_mode(1);
		#endif
			srv_speech_disable_hand_free();
		}

		if(kjx_check_callmode()==1 && is_incomingcall())
		{
			;
		}
		else
		{
			mmi_disp_with_call();
		}
		
		ClearKeyHandler(KEY_EXTRA_1, KEY_EVENT_UP);
	}
	else
	{
		if(mmi_frm_group_get_active_id() == GRP_ID_PHB_MAIN)
		{
			if(is_incomingcall())
			{
				mmi_phb_list_release_call();
				kjx_call_index = 5;
			}
			StartTimer(KJX_TIMER_ID_REDRAW_IDLESCREEN, 500, mmi_show_idle_screen);
			return;
		}

		if(kjx_is_outing_call() && (kjx_check_callmode()==0))
		{
			//if(kjx_is_listen)
			{
			#if defined(CUSTOMER_NAME_BDTS)
				kjx_bdts_set_call_mode(1);
			#elif defined(CUSTOMER_NAME_MEGE1)
				kjx_mege1_set_call_mode(1);
			#endif
				srv_speech_disable_hand_free();
			
				StartTimer(KJX_TIMER_ID_REDRAW_IDLESCREEN, showTime, mmi_show_idle_screen);
				return;
			}
		}

		kjx_reset_callmode();

		mmi_disp_idlescreen();

		if(!is_call())
		{
			kjx_set_key_handler();
		}
	}

	//StartTimer(KJX_TIMER_ID_REDRAW_IDLESCREEN, showTime, mmi_show_idle_screen);
}
#endif

S32 wgui_get_idle_screen_is_extra_text(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(wgui_cat033_get_extra_text())
    {
        return 1;
    }
    return 0;

    
}

/*****************************************************************************
 * FUNCTION
 *  is_on_idlescreen
 * DESCRIPTION
 *  Get is on idlescreen
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
S32 is_on_idlescreen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return gis_on_idlescreen;
}


/*****************************************************************************
 * FUNCTION
 *  set_on_idlescreen
 * DESCRIPTION
 *  is on idlescreen
 * PARAMETERS
 *  temp_on_idlescreen      [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void set_on_idlescreen(S32 temp_on_idlescreen)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gis_on_idlescreen = temp_on_idlescreen;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_set_text_abm_layer
 * DESCRIPTION
 *  set category33 text abm layer
 *  before print text, it should set abm source layer.
 * PARAMETERS
 *  abm_layer      [IN]        ABM source layer
  * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat033_set_text_abm_layer(GDI_HANDLE abm_layer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_wgui_cat033_text_abm_layer = abm_layer;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_reset_text_abm_layer
 * DESCRIPTION
 *  reset category33 abm layer
 * PARAMETERS
 *  void
  * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat033_reset_text_abm_layer(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_wgui_cat033_text_abm_layer = GDI_NULL_HANDLE;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_get_text_abm_layer
 * DESCRIPTION
 *  get category33 abm layer
 *  this function is used before printing text
 * PARAMETERS
 *  void
  * RETURNS
 *  GDI_HANDLE
 *****************************************************************************/
static GDI_HANDLE wgui_cat033_get_text_abm_layer(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    GDI_HANDLE handle;	

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_wgui_cat033_text_abm_layer != GDI_NULL_HANDLE)
    {
        handle = g_wgui_cat033_text_abm_layer;
    }
    else
    {
        gdi_layer_get_active(&handle);
    }
    return handle;	
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_draw_region_with_wallpaper
 * DESCRIPTION
 *  redraw a region by using the wallpaper
 * PARAMETERS
 *  x1      [IN]        Start x position
 *  y1      [IN]        Start y poistion
 *  x2      [IN]        End x position
 *  y2      [IN]        End y postion
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat033_draw_region_with_wallpaper(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#ifndef __GDI_MEMORY_PROFILE_2__
    PU8 idle_screen_wallpaper;
#endif 

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __GDI_MEMORY_PROFILE_2__
#ifdef __MMI_MAINLCD_96X64__
    gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_BLACK); 
#else
    gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_TRANSPARENT); 
#endif
#else /* __GDI_MEMORY_PROFILE_2__ */ 
    gui_draw_filled_area(0, 0, UI_device_width - 1, UI_device_height - 1, current_MMI_theme->general_background_filler);

    if (idle_screen_wallpaper_ID == 0)
    {
        S32 disp_height = UI_device_height, disp_width = UI_device_width;

    #ifndef __MMI_IDLE_FULL_SCREEN__
        disp_height = UI_device_height - MMI_status_bar_height - MMI_button_bar_height;
        disp_width = UI_device_width - 1;
    #endif /* __MMI_IDLE_FULL_SCREEN__ */ 

        if ((disp_width >= cat33_image_width) && (disp_height >= cat33_image_height)) /* image can be displayed entirely */
        {
            S32 offset_x = 0;
            S32 offset_y = 0;

            /* align preview window at the center of screen */
            offset_x = (disp_width - cat33_image_width) >> 1;
            offset_y = (disp_height - cat33_image_height) >> 1;

            gdi_image_draw_file(offset_x, offset_y, (CHAR *) idle_screen_wallpaper_name);
        }
        else    /* image is larger than screen size */
        {
            S32 resized_offset_x;
            S32 resized_offset_y;
            S32 resized_width;
            S32 resized_height;

            gdi_image_util_fit_bbox(
                disp_width,
                disp_height,
                cat33_image_width,
                cat33_image_height,
                &resized_offset_x,
                &resized_offset_y,
                &resized_width,
                &resized_height);

            gdi_image_draw_resized_file(
                resized_offset_x,
                resized_offset_y,
                resized_width,
                resized_height,
                (CHAR *) idle_screen_wallpaper_name);
        }
    }
    else
    {
        idle_screen_wallpaper = get_image(idle_screen_wallpaper_ID);
        if (cat33_n_frames > 1)
        {
            gui_show_animated_image_frame(
                cat33_image_x,
                cat33_image_y,
                idle_screen_wallpaper,
                (S16) cat33_frame_number);
        }
        else
        {
            if (mmi_phnset_check_themeid_wallpaper(idle_screen_wallpaper_ID))
            {
                gui_draw_filled_area(0, 0, UI_device_width, UI_device_height, current_MMI_theme->idle_bkg_filler);
            }
            else
            {
                gui_show_image(cat33_image_x, cat33_image_y, idle_screen_wallpaper);
            }
        }
    }
#endif /* __GDI_MEMORY_PROFILE_2__ */ 
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_draw_region_with_background_color
 * DESCRIPTION
 *  clear a region to background color
 * PARAMETERS
 *  x1       [IN]     start x position
 *  y1       [IN]     start y position
 *  x2       [IN]     end x position
 *  y2       [IN]     end y position
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat033_draw_region_with_background_color(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_push_clip();
    gdi_layer_set_clip(x1, y1, x2, y2);
#ifdef __GDI_MEMORY_PROFILE_2__
#ifdef __MMI_MAINLCD_96X64__
    gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_BLACK); 
#else
    gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_TRANSPARENT); 
#endif
#else /* __GDI_MEMORY_PROFILE_2__ */ 
    draw_wallpaper();
#endif /* __GDI_MEMORY_PROFILE_2__ */ 
    gdi_layer_pop_clip();
}

#ifdef __KJX_WEATHER_SUPPORT__
void kjx_redraw_weather_image(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    GDI_HANDLE wallpaper_layer;
	S32 x,y,img_width,img_height;
	S32 w_inset = 5;
	U16 i,img_1,img_2;
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	if(strlen(kjx_weather.DayPicName) > 0)
	{
		img_1 = 0;
		for(i=0;i<IMG_WEATHER_MAX_NUM;i++)
		{
			if(strcmp(kjx_weather.DayPicName, kjx_weather_img[i].img_name) == 0)
			{
				img_1 = kjx_weather_img[i].img_id;
				break;
			}
		}

		if(i == IMG_WEATHER_MAX_NUM || img_1 == 0)
		{
			return;
		}

	    wallpaper_layer = wgui_cat033_get_text_abm_layer();

		gdi_layer_push_clip();

		if(idle_screen_type != ANALOG_IDLE_SCREEN && idle_screen_type != DIGITAL_IDLE_SCREEN)
		{
			y = MMI_IDLE_SIM2_NETWORK_NAME_Y;
		}
		else
		{
			y = MMI_IDLE_SIM2_NETWORK_NAME_Y_WITH_CLOCK_BG;
		}

		/* get string information */
		gui_measure_image(get_image(IMG_GLOBAL_KJX_WEATHER_DUOYUN), &img_width, &img_height);

		/* clear background */
		gdi_layer_set_clip(0, y - 1, UI_device_width - w_inset - 1, y + img_height + 1);
	#ifdef __GDI_MEMORY_PROFILE_2__
		gdi_draw_solid_rect(0, y - 1, UI_device_width - w_inset - 1, y + img_height + 1, GDI_COLOR_TRANSPARENT);
	#else
		draw_wallpaper();
	#endif /* __GDI_MEMORY_PROFILE_2__ */

		if(strcmp(kjx_weather.DayPicName, kjx_weather.NightPicName)!=0)
		{
			img_2 = 0;
			for(i=0;i<IMG_WEATHER_MAX_NUM;i++)
			{
				if(strcmp(kjx_weather.NightPicName, kjx_weather_img[i].img_name) == 0)
				{
					img_2 = kjx_weather_img[i].img_id;
					break;
				}
			}

			if(i == IMG_WEATHER_MAX_NUM || img_2 == 0)
			{
				gdi_image_draw_blend2layers((UI_device_width - img_width)/2, y, get_image(img_1));
			}
			else
			{
				gdi_image_draw_blend2layers((UI_device_width - (2*img_width) - w_inset)/2, y, get_image(img_1));
				gdi_image_draw_blend2layers((UI_device_width + w_inset)/2, y, get_image(img_2));			
			}
		}
		else
		{
			gdi_image_draw_blend2layers((UI_device_width - img_width)/2, y, get_image(img_1));
		}

		/* set alpha blending layer */
		gdi_push_and_set_alpha_blending_source_layer(wallpaper_layer);

		gdi_pop_and_restore_alpha_blending_source_layer();
		gdi_layer_pop_clip();

		gui_BLT_double_buffer(0, y - 1, UI_device_width - w_inset - 1, y + img_height + 1);
	}
}

void kjx_redraw_weather_temp(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables												  */
	/*----------------------------------------------------------------*/
	S32 w_inset;
	S32 max_str_h;
	/*----------------------------------------------------------------*/
	/* Code Body													  */
	/*----------------------------------------------------------------*/
	if(idle_screen_type != ANALOG_IDLE_SCREEN && idle_screen_type != DIGITAL_IDLE_SCREEN)
	{
		S32 x = 0, y = 0, width = 0;
		UI_string_type network_status = g_slave_idle_screen_line2text;
		UI_font_type network_status_font;
		GDI_HANDLE wallpaper_layer;

		network_status_font = gui_font_get_type(GUI_FONT_SIZE_IDLE_NETWORK_STATUS);
		w_inset = MMI_IDLE_STRING_MARGIN_GAP;
		max_str_h = Get_CharDisplayHeightOfAllLangAndType(network_status_font->size);

		gdi_layer_push_clip();
		y = MMI_IDLE_SIM2_NETWORK_STATUS_Y+20;
		wallpaper_layer = dm_get_wallpaper_layer();
		/* clear background */
		gdi_layer_set_clip(0 , y - 1, UI_device_width - w_inset - 1, y + max_str_h + 1);
	#ifdef __GDI_MEMORY_PROFILE_2__
		gdi_draw_solid_rect(0, y - 1, UI_device_width - w_inset - 1, y + max_str_h + 1, GDI_COLOR_TRANSPARENT);
	#else
		draw_wallpaper();
	#endif/*__GDI_MEMORY_PROFILE_2__*/
	
		/* show slave network status */
		if (network_status != NULL)
		{
			/* set attribute */
			gui_set_font(network_status_font);
			gui_set_text_color(*current_MMI_theme->idle_scr_sim2_network_name_color);
			gui_set_text_border_color(*current_MMI_theme->idle_scr_sim2_network_name_border_color);
	
			/* set alpha blending layer */
			gdi_push_and_set_alpha_blending_source_layer(wallpaper_layer);

			width = gui_get_string_width(network_status) + 2;
			if (width <= (UI_device_width - (w_inset * 2)))
			{
				x = (r2lMMIFlag) ? ((UI_device_width >> 1) + (width >> 1)) : ((UI_device_width >> 1) - (width >> 1));
				x += (r2lMMIFlag) ? (-1) : (1); /* border text */
				y += 1; /* border text */
				gui_move_text_cursor(x, y);
				gui_print_bordered_text(network_status);
			}
			else
			{
				S32 w;

				x = (r2lMMIFlag) ? (UI_device_width - w_inset - 1) : (w_inset + 1);
				x += (r2lMMIFlag) ? (-1) : (1); /* border text */
				y += 1; /* border text */
				w = UI_device_width - (w_inset * 2) - 2/* border text */;
				gui_print_truncated_borderd_text(x, y, w, network_status);
			}
	
			gdi_pop_and_restore_alpha_blending_source_layer();
		}
		gdi_layer_pop_clip();

		gui_BLT_double_buffer(0 , y - 1, UI_device_width - w_inset - 1, y + max_str_h + 1);
	}
}
#endif

#if defined(__BOSCH_BMP280_PRESSURE__)
void Kjx_Show_Temperature_And_Altitude(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables												  */
	/*----------------------------------------------------------------*/
	S32 w_inset;
	S32 max_str_h;
	/*----------------------------------------------------------------*/
	/* Code Body													  */
	/*----------------------------------------------------------------*/
	if(idle_screen_type != ANALOG_IDLE_SCREEN && idle_screen_type != DIGITAL_IDLE_SCREEN)
	{
		S32 x = 0, y = 0, width = 0;
		UI_font_type network_status_font;
		GDI_HANDLE wallpaper_layer;

		network_status_font = gui_font_get_type(GUI_FONT_SIZE_IDLE_NETWORK_STATUS);
		w_inset = MMI_IDLE_STRING_MARGIN_GAP;
		max_str_h = Get_CharDisplayHeightOfAllLangAndType(network_status_font->size)+8;

		gdi_layer_push_clip();
		wallpaper_layer = dm_get_wallpaper_layer();
		/* clear background */
	
		y = 100;
		
		gdi_layer_set_clip(0 , y - 1, UI_device_width - w_inset - 1, y + max_str_h + 1 + 30);
	#ifdef __GDI_MEMORY_PROFILE_2__
		gdi_draw_solid_rect(0, y - 1, UI_device_width - w_inset - 1, y + max_str_h + 1 + 30, GDI_COLOR_TRANSPARENT);
	#else
		draw_wallpaper();
	#endif/*__GDI_MEMORY_PROFILE_2__*/

		/* show slave network status */
		/* set attribute */
		gui_set_font(network_status_font);
		gui_set_text_color(*current_MMI_theme->idle_scr_sim2_network_name_color);
		gui_set_text_border_color(*current_MMI_theme->idle_scr_sim2_network_name_border_color);

		/* set alpha blending layer */
		gdi_push_and_set_alpha_blending_source_layer(wallpaper_layer);

		//Temp
		width = gui_get_string_width((UI_string_type)Temp_show) + 2;
		if (width <= (UI_device_width - (w_inset * 2)))
		{
			x = (r2lMMIFlag) ? ((UI_device_width >> 1) + (width >> 1)) : ((UI_device_width >> 1) - (width >> 1));
			x += (r2lMMIFlag) ? (-1) : (1); /* border text */
			y += 1; /* border text */
			gui_move_text_cursor(x, y);
			gui_print_bordered_text((UI_string_type)Temp_show);
		}
		else
		{
			S32 w;

			x = (r2lMMIFlag) ? (UI_device_width - w_inset - 1) : (w_inset + 1);
			x += (r2lMMIFlag) ? (-1) : (1); /* border text */
			y += 1; /* border text */
			w = UI_device_width - (w_inset * 2) - 2/* border text */;
			gui_print_truncated_borderd_text(x, y, w, (UI_string_type)Temp_show);
		}

		//Altitude
		y += 30;
		width = gui_get_string_width((UI_string_type)Altitude_show) + 2;
		if (width <= (UI_device_width - (w_inset * 2)))
		{
			x = (r2lMMIFlag) ? ((UI_device_width >> 1) + (width >> 1)) : ((UI_device_width >> 1) - (width >> 1));
			x += (r2lMMIFlag) ? (-1) : (1); /* border text */
			y += 1; /* border text */
			gui_move_text_cursor(x, y);
			gui_print_bordered_text((UI_string_type)Altitude_show);
		}
		else
		{
			S32 w;

			x = (r2lMMIFlag) ? (UI_device_width - w_inset - 1) : (w_inset + 1);
			x += (r2lMMIFlag) ? (-1) : (1); /* border text */
			y += 1; /* border text */
			w = UI_device_width - (w_inset * 2) - 2/* border text */;
			gui_print_truncated_borderd_text(x, y, w, (UI_string_type)Altitude_show);
		}

		gdi_pop_and_restore_alpha_blending_source_layer();
		gdi_layer_pop_clip();

		gui_BLT_double_buffer(0 , y - 1, UI_device_width - w_inset - 1, y + max_str_h + 1 +30);
	}
}

void kjx_Show_Altitude(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 w_inset;
    S32 max_str_h;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(idle_screen_type != ANALOG_IDLE_SCREEN && idle_screen_type != DIGITAL_IDLE_SCREEN)
    {
        S32 x = 0, y = 0, width = 0;
        UI_string_type network_status = (UI_string_type)Altitude_show;
        UI_font_type network_status_font;
        GDI_HANDLE wallpaper_layer;

		network_status_font = gui_font_get_type(GUI_FONT_SIZE_IDLE_NETWORK_STATUS);
		w_inset = MMI_IDLE_STRING_MARGIN_GAP;
		max_str_h = Get_CharDisplayHeightOfAllLangAndType(network_status_font->size)+8;

		gdi_layer_push_clip();
		y = MMI_IDLE_SIM2_NETWORK_STATUS_Y;
		wallpaper_layer = dm_get_wallpaper_layer();
		/* clear background */

		y = 130;
	#if defined(__KJX_LOG_OUTPUT__)
		LOGD("y:%d", y);
	#endif
		
		gdi_layer_set_clip(0 , y - 1, UI_device_width - w_inset - 1, y + max_str_h + 1);
	#ifdef __GDI_MEMORY_PROFILE_2__
        gdi_draw_solid_rect(0, y - 1, UI_device_width - w_inset - 1, y + max_str_h + 1, GDI_COLOR_TRANSPARENT);
	#else
        draw_wallpaper();
	#endif/*__GDI_MEMORY_PROFILE_2__*/

        /* show slave network status */
        if (network_status != NULL)
        {
            /* set attribute */
            gui_set_font(network_status_font);
			gui_set_text_color(*current_MMI_theme->idle_scr_sim2_network_name_color);
			gui_set_text_border_color(*current_MMI_theme->idle_scr_sim2_network_name_border_color);
	
            /* set alpha blending layer */
            gdi_push_and_set_alpha_blending_source_layer(wallpaper_layer);

	        width = gui_get_string_width(network_status) + 2;
            if (width <= (UI_device_width - (w_inset * 2)))
            {
                x = (r2lMMIFlag) ? ((UI_device_width >> 1) + (width >> 1)) : ((UI_device_width >> 1) - (width >> 1));
                x += (r2lMMIFlag) ? (-1) : (1); /* border text */
                y += 1; /* border text */
                gui_move_text_cursor(x, y);
                gui_print_bordered_text(network_status);
            }
            else
            {
                S32 w;

                x = (r2lMMIFlag) ? (UI_device_width - w_inset - 1) : (w_inset + 1);
                x += (r2lMMIFlag) ? (-1) : (1); /* border text */
                y += 1; /* border text */
                w = UI_device_width - (w_inset * 2) - 2/* border text */;
                gui_print_truncated_borderd_text(x, y, w, network_status);
            }
	
            gdi_pop_and_restore_alpha_blending_source_layer();
        }
		gdi_layer_pop_clip();

		gui_BLT_double_buffer(0 , y - 1, UI_device_width - w_inset - 1, y + max_str_h + 1);
    }
}

void Kjx_Redraw_Temperature_Pressure(void)
{
#ifdef __KJX_WEATHER_SUPPORT__
	kjx_redraw_weather_image();
	kjx_redraw_weather_temp();
#else
	Kjx_Show_Temperature_And_Altitude();//温度
#endif
}
#endif

#if defined(__KJX_FUN_STEPS__)
void Kjx_Show_Step_And_Calorie(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables												  */
	/*----------------------------------------------------------------*/
	S32 w_inset;
	S32 max_str_h;
	/*----------------------------------------------------------------*/
	/* Code Body													  */
	/*----------------------------------------------------------------*/
	if(idle_screen_type != ANALOG_IDLE_SCREEN && idle_screen_type != DIGITAL_IDLE_SCREEN)
	{
		S32 x = 0, y = 0, width = 0;
		UI_font_type network_status_font;
		GDI_HANDLE wallpaper_layer;

		network_status_font = gui_font_get_type(GUI_FONT_SIZE_IDLE_NETWORK_STATUS);
		w_inset = MMI_IDLE_STRING_MARGIN_GAP;
		max_str_h = Get_CharDisplayHeightOfAllLangAndType(network_status_font->size)+8;

		gdi_layer_push_clip();
		wallpaper_layer = dm_get_wallpaper_layer();
		/* clear background */

		y = 160;
		
		gdi_layer_set_clip(0 , y - 1, UI_device_width - w_inset - 1, y + max_str_h + 1 + 30);
	#ifdef __GDI_MEMORY_PROFILE_2__
		gdi_draw_solid_rect(0, y - 1, UI_device_width - w_inset - 1, y + max_str_h + 1 + 30, GDI_COLOR_TRANSPARENT);
	#else
		draw_wallpaper();
	#endif/*__GDI_MEMORY_PROFILE_2__*/

		/* show slave network status */
		/* set attribute */
		gui_set_font(network_status_font);
		gui_set_text_color(*current_MMI_theme->idle_scr_sim2_network_name_color);
		gui_set_text_border_color(*current_MMI_theme->idle_scr_sim2_network_name_border_color);

		/* set alpha blending layer */
		gdi_push_and_set_alpha_blending_source_layer(wallpaper_layer);

		//Step
		width = gui_get_string_width((UI_string_type)Step_show) + 2;
		if (width <= (UI_device_width - (w_inset * 2)))
		{
			x = (r2lMMIFlag) ? ((UI_device_width >> 1) + (width >> 1)) : ((UI_device_width >> 1) - (width >> 1));
			x += (r2lMMIFlag) ? (-1) : (1); /* border text */
			y += 1; /* border text */
			gui_move_text_cursor(x, y);
			gui_print_bordered_text((UI_string_type)Step_show);
		}
		else
		{
			S32 w;

			x = (r2lMMIFlag) ? (UI_device_width - w_inset - 1) : (w_inset + 1);
			x += (r2lMMIFlag) ? (-1) : (1); /* border text */
			y += 1; /* border text */
			w = UI_device_width - (w_inset * 2) - 2/* border text */;
			gui_print_truncated_borderd_text(x, y, w, (UI_string_type)Step_show);
		}

		//Calorie
		y += 30;
		width = gui_get_string_width((UI_string_type)Calorie_show) + 2;
		if (width <= (UI_device_width - (w_inset * 2)))
		{
			x = (r2lMMIFlag) ? ((UI_device_width >> 1) + (width >> 1)) : ((UI_device_width >> 1) - (width >> 1));
			x += (r2lMMIFlag) ? (-1) : (1); /* border text */
			y += 1; /* border text */
			gui_move_text_cursor(x, y);
			gui_print_bordered_text((UI_string_type)Calorie_show);
		}
		else
		{
			S32 w;

			x = (r2lMMIFlag) ? (UI_device_width - w_inset - 1) : (w_inset + 1);
			x += (r2lMMIFlag) ? (-1) : (1); /* border text */
			y += 1; /* border text */
			w = UI_device_width - (w_inset * 2) - 2/* border text */;
			gui_print_truncated_borderd_text(x, y, w, (UI_string_type)Calorie_show);
		}

		gdi_pop_and_restore_alpha_blending_source_layer();
		gdi_layer_pop_clip();

		gui_BLT_double_buffer(0 , y - 1, UI_device_width - w_inset - 1, y + max_str_h + 1 +30);
	}
}

void Kjx_Show_Calorie(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables												  */
	/*----------------------------------------------------------------*/
	S32 w_inset;
	S32 max_str_h;
	/*----------------------------------------------------------------*/
	/* Code Body													  */
	/*----------------------------------------------------------------*/
	if (idle_screen_type != ANALOG_IDLE_SCREEN && idle_screen_type != DIGITAL_IDLE_SCREEN)
	{
		S32 x = 0, y = 0, width = 0;
		UI_string_type network_status = (UI_string_type)Calorie_show;
		UI_font_type network_status_font;
		GDI_HANDLE wallpaper_layer;

		network_status_font = gui_font_get_type(GUI_FONT_SIZE_IDLE_NETWORK_STATUS);
		w_inset = MMI_IDLE_STRING_MARGIN_GAP;
		max_str_h = Get_CharDisplayHeightOfAllLangAndType(network_status_font->size)+8;

		gdi_layer_push_clip();
		y = MMI_IDLE_SIM2_NETWORK_STATUS_Y;
		wallpaper_layer = dm_get_wallpaper_layer();
		/* clear background */

		y = 190;
		
	#if defined(__KJX_LOG_OUTPUT__)
		LOGD("y:%d", y);
	#endif
		
		gdi_layer_set_clip(0 , y - 1, UI_device_width - w_inset - 1, y + max_str_h + 1);
	#ifdef __GDI_MEMORY_PROFILE_2__
		gdi_draw_solid_rect(0, y - 1, UI_device_width - w_inset - 1, y + max_str_h + 1, GDI_COLOR_TRANSPARENT);
	#else
		draw_wallpaper();
	#endif/*__GDI_MEMORY_PROFILE_2__*/

		/* show slave network status */
		/* set attribute */
		gui_set_font(network_status_font);
		gui_set_text_color(*current_MMI_theme->idle_scr_sim2_network_name_color);
		gui_set_text_border_color(*current_MMI_theme->idle_scr_sim2_network_name_border_color);

		/* set alpha blending layer */
		gdi_push_and_set_alpha_blending_source_layer(wallpaper_layer);

		width = gui_get_string_width(network_status) + 2;
		if (width <= (UI_device_width - (w_inset * 2)))
		{
			x = (r2lMMIFlag) ? ((UI_device_width >> 1) + (width >> 1)) : ((UI_device_width >> 1) - (width >> 1));
			x += (r2lMMIFlag) ? (-1) : (1); /* border text */
			y += 1; /* border text */
			gui_move_text_cursor(x, y);
			gui_print_bordered_text(network_status);
		}
		else
		{
			S32 w;

			x = (r2lMMIFlag) ? (UI_device_width - w_inset - 1) : (w_inset + 1);
			x += (r2lMMIFlag) ? (-1) : (1); /* border text */
			y += 1; /* border text */
			w = UI_device_width - (w_inset * 2) - 2/* border text */;
			gui_print_truncated_borderd_text(x, y, w, network_status);
		}

		gdi_pop_and_restore_alpha_blending_source_layer();
		gdi_layer_pop_clip();

		gui_BLT_double_buffer(0 , y - 1, UI_device_width - w_inset - 1, y + max_str_h + 1);
	}
}

#endif

#ifdef __MMI_UI_TECHNO_IDLESCREEN_BAR__
/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_show_techno_border_string_right_align
 * DESCRIPTION
 *  show border string in right align of x, center align of y in techno bar region
 *  If the string widther than given region, the string will be truncated
 * PARAMETERS
 *  void
 * RETURNS
 *  S32 :  x1 position (left position of string)
 *****************************************************************************/
static S32 wgui_cat033_show_techno_border_string_right_align(UI_string_type string, S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 string_w = 0, string_h = 0, x_pos = 0, y_pos = 0;
    GDI_HANDLE wallpaper_layer;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wallpaper_layer = wgui_cat033_get_text_abm_layer();
    
    /* get string information */
    gui_measure_string(string, &string_w, &string_h);
    string_w += 2;  /* border text */
    string_h += 2;  /* border text */
    
    y_pos = y1 + ((y2 - y1 + 1) >> 1) - (string_h >> 1) - 1;

    /* set alpha blending layer */
    gdi_push_and_set_alpha_blending_source_layer(wallpaper_layer);

    
    if (string_w < x2 - x1 + 1) /* full display */
    {
        x_pos = (r2lMMIFlag) ? (x2) : (x2 - string_w + 1);
        x_pos += (r2lMMIFlag) ? (-1) : (1); /* border text */
        y_pos += 1; /* border text */
        gui_move_text_cursor(x_pos, y_pos);
        gui_print_bordered_text(string);
    }
    else
    {
        x_pos = (r2lMMIFlag) ? (x2) : (x1);
        x_pos += (r2lMMIFlag) ? (-1) : (1); /* border text */
        y_pos += 1; /* border text */
        gui_print_truncated_borderd_text(x_pos, y_pos, x2 - x1 - 1, string);
    }

    gdi_pop_and_restore_alpha_blending_source_layer();
    
    return ((r2lMMIFlag) ? (x_pos + 1) : (x_pos - 1));
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_draw_background_with_technobar
 * DESCRIPTION
 *  draw a region with technobar background
 * PARAMETERS
 *  x1      [IN]        Start x position
 *  y1      [IN]        Start y position
 *  x2      [IN]        End x position
 *  y2      [IN]        End y position
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat033_draw_region_with_technobar(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_push_clip();
    gdi_layer_set_clip(x1, y1, x2, y2);
#ifdef __GDI_MEMORY_PROFILE_2__
    gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_TRANSPARENT);
#endif /* __GDI_MEMORY_PROFILE_2__ */ 
    gui_show_image(0, MMI_status_bar_height, get_image(idlescreen_bar_id));
    gdi_layer_pop_clip();
}


static U32 wgui_cat033_techno_clock_date = WGUI_CLOCK_INVALID_INDEX;
/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_techno_init_date
 * DESCRIPTION
 *  init date on technobar
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat033_techno_init_date(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 width = 0, height = 0, x1 = 0, x2 = 0, y1 = 0, y2 = 0;
    UI_font_type text_font;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    text_font = gui_font_get_type(GUI_FONT_SIZE_IDLE_DATE);

    /* date */
    wgui_clock_create(
        &wgui_cat033_techno_clock_date,               /* local date */
        0, 0, 0, 0,                           /* will move & assign layer */
        GUI_CLOCK_MAINLCD_TYPE_DIGITAL_DATE);         /* display date and day */

    /* set date string attribute */
    wgui_clock_set_text_border_enable(wgui_cat033_techno_clock_date, MMI_TRUE);
    wgui_clock_set_date_text_border_color(wgui_cat033_techno_clock_date, *current_MMI_theme->idle_scr_date_border_color);
    wgui_clock_set_date_text_color(wgui_cat033_techno_clock_date, *current_MMI_theme->idle_scr_date_color);
    wgui_clock_set_date_text_font(wgui_cat033_techno_clock_date, text_font); 

    /* set date string clear function */
    wgui_clock_set_hide_function(wgui_cat033_techno_clock_date, wgui_cat033_draw_region_with_technobar);

    /* set date string position & size */
    wgui_clock_measure_date_text(wgui_cat033_techno_clock_date, &width, &height, text_font);

    /* calculate date max region */
    x1 = DIGITAL_BACKGROUND_X + DIGITAL_BACKGROUND_WIDTH;
    x2 = UI_device_width - MMI_SIGNAL_WIDTH;

#ifdef __MMI_DUAL_SIM_MASTER__
    y1 = MMI_status_bar_height + MMI_IDLESCREEN_BAR_HEIGHT - WGUI_CAT033_DUAL_SIM_DATE_HEIGHT;
    y2 = y1 + WGUI_CAT033_DUAL_SIM_DATE_HEIGHT - 1;
#else
    y1 = MMI_status_bar_height + (MMI_IDLESCREEN_BAR_HEIGHT >> 1) - 1;
    y2 = y1 + (MMI_IDLESCREEN_BAR_HEIGHT >> 1) - 1;
#endif /* __MMI_DUAL_SIM_MASTER__ */
        
    wgui_clock_move(wgui_cat033_techno_clock_date, x1, y1);
    wgui_clock_resize(wgui_cat033_techno_clock_date, x2 - x1 + 1, y2 - y1 + 1);

    wgui_clock_set_digital_align_type(wgui_cat033_techno_clock_date, GUI_CLOCK_DIGITAL_ALIGN_RIGHT);   
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_techno_text_change_processor
 * DESCRIPTION
 *  handle network name & network status scroll on the techno bar
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat033_techno_text_change_processor(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_wgui_cat033_techno_scroll_count += 1;

    g_wgui_cat033_techno_text_scroll = MMI_TRUE;     /* scroll text on techno bar */
    g_wgui_cat033_redraw_scrolling_text = MMI_FALSE; /* not redraw scrolling text */
    
    idle_screen_show_network_details();

    g_wgui_cat033_techno_text_scroll = MMI_FALSE;
    g_wgui_cat033_redraw_scrolling_text = MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_techno_set_text_and_date
 * DESCRIPTION
 *  Set text and date position and clear background
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat033_techno_set_text_and_date(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x1 = 0, y1 = 0, x2 = 0, y2 = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    /* text process: alternate string */
    if (g_wgui_cat033_techno_text_scroll == MMI_TRUE)
    {
        gui_cancel_timer(wgui_cat033_techno_text_change_processor);
        if (g_wgui_cat033_techno_scroll_count == 4) /* change text */
        {
            g_wgui_cat033_techno_scroll_count = 0;
            if (g_wgui_cat033_techno_current_text_type == NETWORK_STATUS_TEXT_ON_IDLE)
            {
                g_wgui_cat033_techno_current_text_type = NETWORK_NAME_TEXT_ON_IDLE;
                
            }
            else if (g_wgui_cat033_techno_current_text_type == NETWORK_NAME_TEXT_ON_IDLE)
            {
                g_wgui_cat033_techno_current_text_type = NETWORK_STATUS_TEXT_ON_IDLE;
            }
            gui_start_timer(WGUI_CAT033_PAUSE_TIMER, wgui_cat033_techno_text_change_processor);
        }
        else
        {
            gui_start_timer(WGUI_CAT033_VSCROLL_TIMER, wgui_cat033_techno_text_change_processor);
        }
    }

    /* clear text region */
    x1 = DIGITAL_BACKGROUND_X + DIGITAL_BACKGROUND_WIDTH;
    y1 = MMI_status_bar_height;
    x2 = UI_device_width - MMI_SIGNAL_WIDTH;

    {
#ifdef __MMI_DUAL_SIM_MASTER__
        S32 max_region_height = MMI_IDLESCREEN_BAR_HEIGHT - WGUI_CAT033_DUAL_SIM_DATE_HEIGHT - WGUI_CAT033_DUAL_SIM_Y_GAP;
#else
        S32 max_region_height = (MMI_IDLESCREEN_BAR_HEIGHT >> 1);
#endif /* __MMI_DUAL_SIM_MASTER__ */

        y2 = MMI_status_bar_height + max_region_height - 1;
    }

    gdi_layer_push_clip();
    gdi_layer_set_clip(x1, y1, x2, y2);
#ifdef __GDI_MEMORY_PROFILE_2__
    gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_TRANSPARENT);
#endif /* __GDI_MEMORY_PROFILE_2__ */
    if (PhnsetGetShowDateTimeStatus() == MMI_TRUE) /* show technobar image */
    {
        gui_show_image(0, MMI_status_bar_height, get_image(idlescreen_bar_id));
    }
    gdi_layer_pop_clip();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_show_techno_network_name
 * DESCRIPTION
 *  show network name on techno bar (if has network status, it will vertical scroll)
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
static MMI_BOOL wgui_cat033_show_techno_network_name(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 clip_x1 = 0, clip_y1 = 0, clip_x2 = 0, clip_y2 = 0, clip_height = 0;
    S32 count = 0, region_y1 = 0, region_y2 = 0;
    S32 string_max_h = 0, max_region_height = 0;
    MMI_BOOL is_display = MMI_FALSE;
    UI_string_type network_name = idle_screen_network_name;
    PU8 dual_sim_img = NULL;
    S32 img_width = 0, img_height = 0;
    UI_font_type network_name_font;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_DUAL_SIM_MASTER__
    max_region_height = ((MMI_IDLESCREEN_BAR_HEIGHT - WGUI_CAT033_DUAL_SIM_DATE_HEIGHT - (WGUI_CAT033_DUAL_SIM_Y_GAP << 1)) >> 1);
#else
    max_region_height = (MMI_IDLESCREEN_BAR_HEIGHT >> 1);
#endif /* __MMI_DUAL_SIM_MASTER__ */

    network_name_font = gui_font_get_type(GUI_FONT_SIZE_IDLE_NETWORK_NAME);

#if defined( __MMI_DUAL_SIM_MASTER__) && !defined(__MMI_WLAN_FEATURES__)
    if (!(srv_mode_switch_is_network_service_available() == MMI_FALSE 
          && srv_mode_switch_get_network_mode((mmi_sim_enum)MMI_SIM_ALL) == SRV_MODE_SWITCH_OFF))
    {
        dual_sim_img = get_image(WGUI_IMG_IDLE_SIM1);
        gui_measure_image(dual_sim_img, &img_width, &img_height);
        img_width += (MMI_IDLE_NETWORK_NAME_ICON_GAP * 2);
    }
#endif /* defined( __MMI_DUAL_SIM_MASTER__) && !defined(__MMI_WLAN_FEATURES__) */
    
    if (network_name != NULL)
    {
        is_display = MMI_TRUE;
        
        /* set attribute */
        gui_set_font(network_name_font);        
        gui_set_text_color(*current_MMI_theme->idle_scr_network_name_color);
        gui_set_text_border_color(*current_MMI_theme->idle_scr_network_name_border_color);
        
        string_max_h = Get_CharDisplayHeightOfAllLangAndType(network_name_font->size);
        count = g_wgui_cat033_techno_scroll_count; /* scroll count */
        
        /* calculate clip region */
        if ((S32)(string_max_h * WGUI_CAT033_TECHNO_STRING_SPACE) <= max_region_height)
        {
            clip_height = (S32)(string_max_h * WGUI_CAT033_TECHNO_STRING_SPACE);
            clip_x1 = DIGITAL_BACKGROUND_X + DIGITAL_BACKGROUND_WIDTH;
            clip_x2 = UI_device_width - MMI_SIGNAL_WIDTH;
            clip_y1 = MMI_status_bar_height + (max_region_height >> 1) - (clip_height >> 1);
            clip_y2 = clip_y1 + clip_height - 1;
        }
        else
        {
            clip_height = max_region_height;
            clip_x1 = DIGITAL_BACKGROUND_X + DIGITAL_BACKGROUND_WIDTH;
            clip_x2 = UI_device_width - MMI_SIGNAL_WIDTH;
            clip_y1 = MMI_status_bar_height;
            clip_y2 = clip_y1 + clip_height - 1;
        }

        gdi_layer_push_clip();
        gdi_layer_set_clip(clip_x1, clip_y1, clip_x2, clip_y2);
        
        if (idle_screen_network_status != NULL) /* have network status: vertical scroll */
        {
            /* calculate the position of network name string */
            if (g_wgui_cat033_techno_current_text_type == NETWORK_NAME_TEXT_ON_IDLE)
            {
                region_y2 = clip_y2 - count * (clip_height >> 2);
                region_y1 = region_y2 - clip_height + 1;
            }
            else if (g_wgui_cat033_techno_current_text_type == NETWORK_STATUS_TEXT_ON_IDLE)
            {
                region_y1 = clip_y2 - count * (clip_height >> 2) + 1;
                region_y2 = region_y1 + clip_height - 1;
            }
            
            if (dual_sim_img != NULL) /* dual sim show sim1 image */
            {
                S32 img_y =  region_y1 + ((region_y2 - region_y1 + 1) >> 1) - (img_height >> 1) - 1;

                if (r2lMMIFlag)
                {
                    wgui_cat033_show_techno_border_string_right_align(network_name, clip_x1, region_y1, clip_x2 - img_width, region_y2);
                    gdi_image_draw_blend2layers(clip_x2 - img_width + MMI_IDLE_NETWORK_NAME_ICON_GAP, img_y, dual_sim_img);
                }
                else
                {
                    if ((gui_get_string_width(network_name) + 2) >= clip_x2 - clip_x1 + 1 - img_width) /* too long: trancated string */
                    {
                        wgui_cat033_show_techno_border_string_right_align(network_name, clip_x1 + img_width, region_y1, clip_x2, region_y2);
                        gdi_image_draw_blend2layers(clip_x1 + MMI_IDLE_NETWORK_NAME_ICON_GAP, img_y, dual_sim_img);
                    }
                    else
                    {
                        S32 x;

                        x = wgui_cat033_show_techno_border_string_right_align(network_name, clip_x1 + img_width, region_y1, clip_x2, region_y2);
                        gdi_image_draw_blend2layers(x - img_width + MMI_IDLE_NETWORK_NAME_ICON_GAP, img_y, dual_sim_img);
                    }
                }
            }
            else /* no image */
            {
                wgui_cat033_show_techno_border_string_right_align(network_name, clip_x1, region_y1, clip_x2, region_y2);
            }
        }
        else /* no network status: static string */
        {
            region_y2 = clip_y2;
            region_y1 = clip_y1;

            if (dual_sim_img != NULL) /* dual sim show sim1 image */
            {
                S32 img_y =  region_y1 + ((region_y2 - region_y1 + 1) >> 1) - (img_height >> 1) - 1;

                if (r2lMMIFlag)
                {
                    wgui_cat033_show_techno_border_string_right_align(network_name, clip_x1, region_y1, clip_x2 - img_width, region_y2);
                    gdi_image_draw_blend2layers(clip_x2 - img_width + MMI_IDLE_NETWORK_NAME_ICON_GAP, img_y, dual_sim_img);
                }
                else
                {
                    if ((gui_get_string_width(network_name) + 2) >= clip_x2 - clip_x1 + 1 - img_width) /* too long: trancated string */
                    {
                        wgui_cat033_show_techno_border_string_right_align(network_name, clip_x1 + img_width, region_y1, clip_x2, region_y2);                        
                        gdi_image_draw_blend2layers(clip_x1 + MMI_IDLE_NETWORK_NAME_ICON_GAP, img_y, dual_sim_img);
                    }
                    else
                    {
                        S32 x;

                        x = wgui_cat033_show_techno_border_string_right_align(network_name, clip_x1 + img_width, region_y1, clip_x2, region_y2);
                        gdi_image_draw_blend2layers(x - img_width + MMI_IDLE_NETWORK_NAME_ICON_GAP, img_y, dual_sim_img);
                    }
                }
            }
            else
            {
                wgui_cat033_show_techno_border_string_right_align(network_name, clip_x1, clip_y1, clip_x2, clip_y2);
            }
        }
        gdi_layer_pop_clip();
    }
    return is_display;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_show_techno_network_status
 * DESCRIPTION
 *  show network status on techno bar (vertical scroll)
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
static MMI_BOOL wgui_cat033_show_techno_network_status(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 clip_x1 = 0, clip_y1 = 0, clip_x2 = 0, clip_y2 = 0, clip_height = 0;
    S32 count = 0, region_y1 = 0, region_y2 = 0;
    S32 string_max_h = 0, max_region_height = 0;
    MMI_BOOL is_display = MMI_FALSE;
    UI_string_type network_status = idle_screen_network_status;
    UI_font_type network_name_font, network_status_font;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_DUAL_SIM_MASTER__
    max_region_height = ((MMI_IDLESCREEN_BAR_HEIGHT - WGUI_CAT033_DUAL_SIM_DATE_HEIGHT - (WGUI_CAT033_DUAL_SIM_Y_GAP << 1)) >> 1);
#else
    max_region_height = (MMI_IDLESCREEN_BAR_HEIGHT >> 1);
#endif /* __MMI_DUAL_SIM_MASTER__ */

    /* get font */
    network_name_font = gui_font_get_type(GUI_FONT_SIZE_IDLE_NETWORK_NAME);
    network_status_font = gui_font_get_type(GUI_FONT_SIZE_IDLE_NETWORK_STATUS);
    
	if (idle_screen_type != ANALOG_IDLE_SCREEN && idle_screen_type != DIGITAL_IDLE_SCREEN && network_status != NULL)
	{
        is_display = MMI_TRUE;

        /* set attribute */
        gui_set_font(network_status_font);
        gui_set_text_color(*current_MMI_theme->idle_scr_network_status_color);
        gui_set_text_border_color(*current_MMI_theme->idle_scr_network_status_border_color);

        string_max_h = Get_CharDisplayHeightOfAllLangAndType(network_name_font->size);
        count = g_wgui_cat033_techno_scroll_count; /* scroll count */

        /* calculate clip region */
        if ((S32)(string_max_h * WGUI_CAT033_TECHNO_STRING_SPACE) <= max_region_height)
        {
            clip_height = (S32)(string_max_h * WGUI_CAT033_TECHNO_STRING_SPACE);
            clip_x1 = DIGITAL_BACKGROUND_X + DIGITAL_BACKGROUND_WIDTH;
            clip_x2 = UI_device_width - MMI_SIGNAL_WIDTH;  
            clip_y1 = MMI_status_bar_height + (max_region_height >> 1) - (clip_height >> 1);
            clip_y2 = clip_y1 + clip_height - 1;
        }
        else
        {
            clip_height = max_region_height;
            clip_x1 = DIGITAL_BACKGROUND_X + DIGITAL_BACKGROUND_WIDTH;
            clip_x2 = UI_device_width - MMI_SIGNAL_WIDTH;
            clip_y1 = MMI_status_bar_height;
            clip_y2 = clip_y1 + clip_height - 1;
        }

        /* calculate the position of network status string */
        if (g_wgui_cat033_techno_current_text_type == NETWORK_STATUS_TEXT_ON_IDLE)
        {
            region_y2 = clip_y2 - count * (clip_height >> 2) + 1;
            region_y1 = region_y2 - clip_height + 1;
        }
        else if (g_wgui_cat033_techno_current_text_type == NETWORK_NAME_TEXT_ON_IDLE)
        {
            region_y1 = clip_y2 - count * (clip_height >> 2) + 1;
            region_y2 = region_y1 + clip_height - 1;            
        }

        /* show network status string */
        gdi_layer_push_clip();
        gdi_layer_set_clip(clip_x1, clip_y1, clip_x2, clip_y2);
        wgui_cat033_show_techno_border_string_right_align(network_status, clip_x1, region_y1, clip_x2, region_y2);
        gdi_layer_pop_clip();
    }
	return is_display;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_show_techno_date
 * DESCRIPTION
 *  show date on techno bar
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat033_show_techno_date(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
   // S32 x1 = 0, y1 = 0, x2 = 0, y2 = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (PhnsetGetShowDateTimeStatus() == MMI_TRUE)
    {
        wgui_clock_show_clock(wgui_cat033_techno_clock_date);
    }        
}


#ifdef __MMI_DUAL_SIM_MASTER__
/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_show_techno_network_name2
 * DESCRIPTION
 *  show network name2 on techno bar (if has network status2, it will scroll)
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
static MMI_BOOL wgui_cat033_show_techno_network_name2(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 clip_x1 = 0, clip_y1 = 0, clip_x2 = 0, clip_y2 = 0, clip_height = 0;
    S32 count = 0, region_y1 = 0, region_y2 = 0;
    S32 string_max_h = 0, max_region_height = 0;    
    MMI_BOOL is_display = MMI_FALSE;
    UI_string_type network_name = g_slave_idle_screen_line1text;
    PU8 dual_sim_img = NULL;
    S32 img_width = 0, img_height = 0;
    UI_font_type network_name_font;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    max_region_height = ((MMI_IDLESCREEN_BAR_HEIGHT - WGUI_CAT033_DUAL_SIM_DATE_HEIGHT - (WGUI_CAT033_DUAL_SIM_Y_GAP << 1)) >> 1);
    network_name_font = gui_font_get_type(GUI_FONT_SIZE_IDLE_NETWORK_NAME);

#if !defined(__MMI_WLAN_FEATURES__)
    if (!(srv_mode_switch_is_network_service_available() == MMI_FALSE 
          && srv_mode_switch_get_network_mode((mmi_sim_enum)MMI_SIM_ALL) == SRV_MODE_SWITCH_OFF))
    {
        dual_sim_img = get_image(WGUI_IMG_IDLE_SIM2);
        gui_measure_image(dual_sim_img, &img_width, &img_height);
        img_width += (MMI_IDLE_NETWORK_NAME_ICON_GAP * 2);
    }
#endif

    if (network_name != NULL)
    {
        is_display = MMI_TRUE;

        /* set attribute */
        gui_set_font(network_name_font);        
        gui_set_text_color(*current_MMI_theme->idle_scr_sim2_network_name_color);
        gui_set_text_border_color(*current_MMI_theme->idle_scr_sim2_network_name_border_color);

        string_max_h = Get_CharDisplayHeightOfAllLangAndType(network_name_font->size);
        count = g_wgui_cat033_techno_scroll_count; /* scroll count */

        /* calculate clip region */
        if ((S32)(string_max_h * WGUI_CAT033_TECHNO_STRING_SPACE) <= max_region_height)
        {
            clip_height = (S32)(string_max_h * WGUI_CAT033_TECHNO_STRING_SPACE);
            clip_x1 = DIGITAL_BACKGROUND_X + DIGITAL_BACKGROUND_WIDTH;
            clip_x2 = UI_device_width - MMI_SIGNAL_WIDTH;
            clip_y1 = MMI_status_bar_height + max_region_height + (max_region_height >> 1) - (clip_height >> 1) + WGUI_CAT033_DUAL_SIM_Y_GAP;
            clip_y2 = clip_y1 + clip_height - 1;
        }
        else
        {
            clip_height = max_region_height;
            clip_x1 = DIGITAL_BACKGROUND_X + DIGITAL_BACKGROUND_WIDTH;
            clip_x2 = UI_device_width - MMI_SIGNAL_WIDTH;
            clip_y1 = MMI_status_bar_height + max_region_height + WGUI_CAT033_DUAL_SIM_Y_GAP;
            clip_y2 = clip_y1 + clip_height - 1;
        }

        gdi_layer_push_clip();
        gdi_layer_set_clip(clip_x1, clip_y1, clip_x2, clip_y2);

        if (g_slave_idle_screen_line2text != NULL) /* have network status2: scroll */
        {
            /* calculate the position of network name string */
            if (g_wgui_cat033_techno_current_text_type == NETWORK_NAME_TEXT_ON_IDLE)
            {
                region_y2 = clip_y2 - count * (clip_height >> 2);
                region_y1 = region_y2 - clip_height + 1;
            }
            else if (g_wgui_cat033_techno_current_text_type == NETWORK_STATUS_TEXT_ON_IDLE)
            {
                region_y1 = clip_y2 - count * (clip_height >> 2) + 1;
                region_y2 = region_y1 + clip_height - 1;
            }

            if (dual_sim_img != NULL) /* dual sim show sim1 image */
            {
                S32 img_y =  region_y1 + ((region_y2 - region_y1 + 1) >> 1) - (img_height >> 1) - 1;

                if (r2lMMIFlag)
                {
                    wgui_cat033_show_techno_border_string_right_align(network_name, clip_x1, region_y1, clip_x2 - img_width, region_y2);
                    gdi_image_draw_blend2layers(clip_x2 - img_width + MMI_IDLE_NETWORK_NAME_ICON_GAP, img_y, dual_sim_img);
                }
                else
                {
                    if ((gui_get_string_width(network_name) + 2) >= clip_x2 - clip_x1 + 1 - img_width) /* too long: trancated string */
                    {
                        wgui_cat033_show_techno_border_string_right_align(network_name, clip_x1 + img_width, region_y1, clip_x2, region_y2);
                        gdi_image_draw_blend2layers(clip_x1 + MMI_IDLE_NETWORK_NAME_ICON_GAP, img_y, dual_sim_img);
                    }
                    else
                    {
                        S32 x;

                        x = wgui_cat033_show_techno_border_string_right_align(network_name, clip_x1 + img_width, region_y1, clip_x2, region_y2);                        
                        gdi_image_draw_blend2layers(x - img_width + MMI_IDLE_NETWORK_NAME_ICON_GAP, img_y, dual_sim_img);
                    }
                }
            }
            else
            {
                wgui_cat033_show_techno_border_string_right_align(network_name, clip_x1, region_y1, clip_x2, region_y2);
            }
        }
        else /* no network status: static string */
        {
            region_y1 = clip_y1;
            region_y2 = clip_y2;

            if (dual_sim_img != NULL) /* dual sim show sim1 image */
            {
                S32 img_y =  region_y1 + ((region_y2 - region_y1 + 1) >> 1) - (img_height >> 1) - 1;

                if (r2lMMIFlag)
                {
                    wgui_cat033_show_techno_border_string_right_align(network_name, clip_x1, region_y1, clip_x2 - img_width, region_y2);
                    gdi_image_draw_blend2layers(clip_x2 - img_width + MMI_IDLE_NETWORK_NAME_ICON_GAP, img_y, dual_sim_img);
                }
                else
                {
                    if ((gui_get_string_width(network_name) + 2) >= clip_x2 - clip_x1 + 1 - img_width) /* too long: trancated string */
                    {
                        wgui_cat033_show_techno_border_string_right_align(network_name, clip_x1 + img_width, region_y1, clip_x2, region_y2);
                        gdi_image_draw_blend2layers(clip_x1 + MMI_IDLE_NETWORK_NAME_ICON_GAP, img_y, dual_sim_img);
                    }
                    else
                    {
                        S32 x;
                        x = wgui_cat033_show_techno_border_string_right_align(network_name, clip_x1 + img_width, region_y1, clip_x2, region_y2);
                        gdi_image_draw_blend2layers(x - img_width + MMI_IDLE_NETWORK_NAME_ICON_GAP, img_y, dual_sim_img);
                    }
                }
            }
            else
            {
                wgui_cat033_show_techno_border_string_right_align(network_name, clip_x1, clip_y1, clip_x2, clip_y2);
            }
        }
        gdi_layer_pop_clip();
    }
    return is_display;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_show_techno_network_status2
 * DESCRIPTION
 *  show network status2 on techno bar (vertical scroll)
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
static MMI_BOOL wgui_cat033_show_techno_network_status2(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 clip_x1 = 0, clip_y1 = 0, clip_x2 = 0, clip_y2 = 0, clip_height = 0;
    S32 count = 0, region_y1 = 0, region_y2 = 0;
    S32 string_max_h = 0, max_region_height = 0;
    MMI_BOOL is_display = MMI_FALSE;
    UI_string_type network_status = g_slave_idle_screen_line2text;
    UI_font_type network_name_font, network_status_font;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    max_region_height = ((MMI_IDLESCREEN_BAR_HEIGHT - WGUI_CAT033_DUAL_SIM_DATE_HEIGHT - (WGUI_CAT033_DUAL_SIM_Y_GAP << 1)) >> 1);

    /* get font */
    network_name_font = gui_font_get_type(GUI_FONT_SIZE_IDLE_NETWORK_NAME);    
    network_status_font = gui_font_get_type(GUI_FONT_SIZE_IDLE_NETWORK_STATUS);

    if (idle_screen_type != ANALOG_IDLE_SCREEN && 
        idle_screen_type != DIGITAL_IDLE_SCREEN && 
        network_status != NULL)
    {
        is_display = MMI_TRUE;

        /* set attribute */
        gui_set_font(network_status_font);
        gui_set_text_color(*current_MMI_theme->idle_scr_sim2_network_status_color);
        gui_set_text_border_color(*current_MMI_theme->idle_scr_sim2_network_status_border_color);

        string_max_h = Get_CharDisplayHeightOfAllLangAndType(network_name_font->size);
        count = g_wgui_cat033_techno_scroll_count; /* scroll count */

        /* calculate clip region */
        if ((S32)(string_max_h * WGUI_CAT033_TECHNO_STRING_SPACE) <= max_region_height)
        {
            clip_height = (S32)(string_max_h * WGUI_CAT033_TECHNO_STRING_SPACE);
            clip_x1 = DIGITAL_BACKGROUND_X + DIGITAL_BACKGROUND_WIDTH;
            clip_x2 = UI_device_width - MMI_SIGNAL_WIDTH;
            clip_y1 = MMI_status_bar_height + max_region_height + (max_region_height >> 1) - (clip_height >> 1);
            clip_y2 = clip_y1 + clip_height - 1;
        }
        else
        {
            clip_height = max_region_height;
            clip_x1 = DIGITAL_BACKGROUND_X + DIGITAL_BACKGROUND_WIDTH;
            clip_x2 = UI_device_width - MMI_SIGNAL_WIDTH;
            clip_y1 = MMI_status_bar_height + max_region_height + WGUI_CAT033_DUAL_SIM_Y_GAP;
            clip_y2 = clip_y1 + clip_height - 1;
        }

        /* calculate the position of network status string */
        if (g_wgui_cat033_techno_current_text_type == NETWORK_STATUS_TEXT_ON_IDLE)
        {
            region_y2 = clip_y2 - count * (clip_height >> 2) + 1;
            region_y1 = region_y2 - clip_height + 1;
        }
        else if (g_wgui_cat033_techno_current_text_type == NETWORK_NAME_TEXT_ON_IDLE)
        {
            region_y1 = clip_y2 - count * (clip_height >> 2) + 1;
            region_y2 = region_y1 + clip_height - 1;
        }

        /* show network status string */
        gdi_layer_push_clip();
        gdi_layer_set_clip(clip_x1, clip_y1, clip_x2, clip_y2);
        wgui_cat033_show_techno_border_string_right_align(network_status, clip_x1, region_y1, clip_x2, region_y2);
        gdi_layer_pop_clip();
    }
    return is_display;
}
#endif /* __MMI_DUAL_SIM_MASTER__ */


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_show_techo_date_and_static_network_name
 * DESCRIPTION
 *  show date and static network name on techno bar
 *  THIS FUNCTION IS ONLY FOR CALL CATEGORY, PLEASE DO NOT USE ARBITRARILY
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat033_show_techo_date_and_static_network_name(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    gdi_layer_lock_frame_buffer();

    /* stop vertical scroll because only network name */
    g_wgui_cat033_techno_text_scroll = MMI_FALSE;
    g_wgui_cat033_techno_current_text_type = NETWORK_NAME_TEXT_ON_IDLE;

    /* date */
    if (PhnsetGetShowDateTimeStatus() == MMI_TRUE)
    {
        wgui_cat033_techno_init_date();
    }
    wgui_cat033_techno_set_text_and_date();
    wgui_cat033_show_techno_date();    

    /* SIM 1 */
    wgui_cat033_show_techno_network_name();

    /* SIM 2 */    
#if defined(__MMI_DUAL_SIM_MASTER__)
    wgui_cat033_show_techno_network_name2();
#endif /* defined(__MMI_DUAL_SIM_MASTER__) */

    gdi_layer_unlock_frame_buffer();        
    gdi_lcd_repaint_all();
}


#else  /* __MMI_UI_TECHNO_IDLESCREEN_BAR__ */ 
/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_show_network_status
 * DESCRIPTION
 *  show network status (the seconde line) in idle screen
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
static MMI_BOOL wgui_cat033_show_network_status(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
    MMI_BOOL is_display = MMI_FALSE;    
#ifndef __OP01_FWPBW__
#if (MMI_IDLE_TEXT_ALIGN_TYPE == IDLE_TEXT_CENTER_ALIGN)                
    S32 width = 0;
#endif
#endif
    S32 x = 0, y = 0;
    UI_font_type network_name_font, network_status_font;
    GDI_HANDLE wallpaper_layer;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    /* get font */
    network_name_font = gui_font_get_type(GUI_FONT_SIZE_IDLE_NETWORK_NAME);
    network_status_font = gui_font_get_type(GUI_FONT_SIZE_IDLE_NETWORK_STATUS);
    wallpaper_layer = wgui_cat033_get_text_abm_layer();

	/* show network status */
	if (idle_screen_type != ANALOG_IDLE_SCREEN && idle_screen_type != DIGITAL_IDLE_SCREEN)
	{
		S32 w_inset = MMI_IDLE_STRING_MARGIN_GAP;
		S32 max_str_h = Get_CharDisplayHeightOfAllLangAndType(network_status_font->size)+10;
        S32 min_y = UI_device_height - 1, i = 0;

        is_display = MMI_TRUE;
        
        /* find min y of all reminders*/
        for (i = 0; i < wgui_cat033_reminder_total; i++)
        {
            if (g_wgui_cat033_reminder[i].state != cat33_reminder_area_state_deinit)
            {
                min_y = min(min_y, g_wgui_cat033_reminder[i].y);
            }
        }
		
		gui_set_font(network_status_font);
		gui_set_text_color(*current_MMI_theme->idle_scr_network_status_color);
		gui_set_text_border_color(*current_MMI_theme->idle_scr_network_status_border_color);

		if (min_y < UI_device_height - 1) /* have reminders */
		{
			y = MMI_IDLE_DETAILS_START_Y_WITH_REMINDER + 
				Get_CharDisplayHeightOfAllLangAndType(network_name_font->size) +
				MMI_IDLE_DETAILS_VGAP_WITH_REMINDER;
			if ((y + max_str_h - 1) >= min_y)
			{
				is_display = MMI_FALSE;
			}
		}
		else
		{
			y = MMI_IDLE_NETWORK_STATUS_Y;
		}

    #ifdef __OP01_FWPBW__
        // OP01 FWPBW needs to show SPN on the same line as operator name
        if (idle_screen_network_status != NULL)
        {
            is_display = MMI_TRUE;
            y = MMI_IDLE_NETWORK_NAME_Y;
        }
    #endif

		if (is_display == MMI_TRUE)
		{
		    S32 x1 = w_inset;
            S32 x2 = UI_device_width - w_inset;
		#ifdef __OP01_FWPBW__        
            // OP01 FWPBW needs to show SPN on the same line as operator name
            if (idle_screen_network_status != NULL)
            {
                x1 = MMI_IDLE_NETWORK_INFO_MARGIN_GAP + MMI_IDLE_NETWORK_NAME_AREA_WIDTH;
                x2 = UI_device_width - MMI_IDLE_NETWORK_INFO_MARGIN_GAP;
            }
        #endif
			/* clear background */
			gdi_layer_push_clip();
			gdi_layer_set_clip(x1, y, x2, y + 2*(max_str_h+2));
		#ifdef __GDI_MEMORY_PROFILE_2__
			gdi_draw_solid_rect(x1, y, x2, y + 2*(max_str_h+2), GDI_COLOR_TRANSPARENT);
		#else
			draw_wallpaper();
		#endif /* __GDI_MEMORY_PROFILE_2__ */
			
			if (idle_screen_network_status != NULL)
			{
			    /* set alpha blending layer */
			    gdi_push_and_set_alpha_blending_source_layer(wallpaper_layer);

            #ifndef __OP01_FWPBW__
              #if (MMI_IDLE_TEXT_ALIGN_TYPE == IDLE_TEXT_CENTER_ALIGN)				
                width = gui_get_string_width(idle_screen_network_status) + 2;
				if (width <= (UI_device_width - (w_inset * 2)))
				{
					x = (r2lMMIFlag) ? ((UI_device_width >> 1) + (width >> 1)) : ((UI_device_width >> 1) - (width >> 1));
					x += (r2lMMIFlag) ? (-1) : (1); /* border text */
					y += 1; /* border text */
					gui_move_text_cursor(x, y);
					gui_print_bordered_text(idle_screen_network_status);
				}
				else
				{
					S32 w;
					
					x = (r2lMMIFlag) ? (UI_device_width - w_inset - 1) : (w_inset + 1);
					x += (r2lMMIFlag) ? (-1) : (1); /* border text */
					y += 1; /* border text */
					w = UI_device_width - (w_inset * 2) - 2/* border text */;
					gui_print_truncated_borderd_text(x, y, w, idle_screen_network_status);
				}
			  #elif(MMI_IDLE_TEXT_ALIGN_TYPE == IDLE_TEXT_LEFT_ALIGN) /* (MMI_IDLE_TEXT_ALIGN_TYPE == IDLE_TEXT_CENTER_ALIGN) */
				{
					S32 w;
					
					x = (r2lMMIFlag) ? (UI_device_width - w_inset) : (w_inset/2);
					w = UI_device_width - w_inset - w_inset/2 - 2;
					x += (r2lMMIFlag) ? (-1) : (1); /* border text */
					y += 1; /* border text */
					gui_print_truncated_borderd_text(x, y, w, idle_screen_network_status);
				}
			  #else /* (MMI_IDLE_TEXT_ALIGN_TYPE == IDLE_TEXT_CENTER_ALIGN) */
				MMI_ASSERT(0);
			  #endif /* (MMI_IDLE_TEXT_ALIGN_TYPE == IDLE_TEXT_CENTER_ALIGN) */
            #else /* __OP01_FWPBW__ */
                if (width <= MMI_IDLE_NETWORK_STATUS_AREA_WIDTH)
                {
                    x = UI_device_width - MMI_IDLE_NETWORK_INFO_MARGIN_GAP - width;
                    gui_move_text_cursor(x, y);
                    gui_print_text(idle_screen_network_status);
                }
                else
                {
                    S32 w = MMI_IDLE_NETWORK_STATUS_AREA_WIDTH;
                    x = UI_device_width - MMI_IDLE_NETWORK_INFO_MARGIN_GAP - MMI_IDLE_NETWORK_STATUS_AREA_WIDTH;
                    gui_print_truncated_text(x, y, w, idle_screen_network_status);
                }
                //wgui_cat033_show_network_name();
            #endif /* __OP01_FWPBW__ */

			#if defined(__KJX_DJ_SUPPORT__)
				//xb add 2020-12-07 待机界面增加对讲频道显示
				if(g_kjx_nvram_struct.dj_infor.dj_chanle > 0)
				{
					color c_chanle = {128,0,0,100};
					
					gui_set_text_color(c_chanle);
					width = gui_get_string_width((UI_string_type)dj_chanle_show) + 2;
					if (width <= (UI_device_width - (w_inset * 2)))
					{
						x = (r2lMMIFlag) ? ((UI_device_width >> 1) + (width >> 1)) : ((UI_device_width >> 1) - (width >> 1));
						x += (r2lMMIFlag) ? (-1) : (1); /* border text */
						y += (max_str_h+1); /* border text */
						gui_move_text_cursor(x, y);
						gui_print_bordered_text((UI_string_type)dj_chanle_show);
					}
					else
					{
						S32 w;
			
						x = (r2lMMIFlag) ? (UI_device_width - w_inset - 1) : (w_inset + 1);
						x += (r2lMMIFlag) ? (-1) : (1); /* border text */
						y += (max_str_h+1); /* border text */
						w = UI_device_width - (w_inset * 2) - 2/* border text */;
						gui_print_truncated_borderd_text(x, y, w, (UI_string_type)dj_chanle_show);
					}
				}
			#endif/*__KJX_DJ_SUPPORT__*/

                gdi_pop_and_restore_alpha_blending_source_layer();
			}
		
			gdi_layer_pop_clip();
		}
	}
    return is_display;
}


#if defined(__MMI_DUAL_SIM_MASTER__)||defined(__KJX_FUN__)
/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_show_network_name2
 * DESCRIPTION
 *  show card2 network name on idle screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat033_show_network_name2(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    UI_string_type network_name = g_slave_idle_screen_line1text;
    UI_font_type network_name_font;
    GDI_HANDLE wallpaper_layer;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	
#if defined(__KJX_FUN__)	//xb add 2017-07-19 这个位置显示温度
#ifdef __KJX_WEATHER_SUPPORT__
	kjx_redraw_weather_image();
#elif defined(__BOSCH_BMP280_PRESSURE__)
	Kjx_Show_Temperature();
#endif
	return;
#endif

    network_name_font = gui_font_get_type(GUI_FONT_SIZE_IDLE_NETWORK_NAME);
    wallpaper_layer = wgui_cat033_get_text_abm_layer();
    
    if(network_name != NULL)
    {
	#if (MMI_IDLE_TEXT_ALIGN_TYPE == IDLE_TEXT_CENTER_ALIGN)
        S32 width = 0;
	#endif
        S32 x = 0, y = 0, img_width = 0, img_height = 0;
        S32 w_inset = MMI_IDLE_STRING_MARGIN_GAP;
        S32 max_str_h = Get_CharDisplayHeightOfAllLangAndType(network_name_font->size);
        U8 *img_src = NULL;

	#if !defined(__MMI_MAINLCD_96X64__)
        if (!(srv_mode_switch_is_network_service_available() == MMI_FALSE 
              && srv_mode_switch_get_network_mode((mmi_sim_enum)MMI_SIM_ALL) == SRV_MODE_SWITCH_OFF))
        {
            S32 w, h;
            img_src = get_image(WGUI_IMG_IDLE_SIM2);
            gui_measure_image(img_src, &w, &h);
            img_width = w + MMI_IDLE_NETWORK_NAME_ICON_GAP;
            img_height = h;
        }
	#endif

        gdi_layer_push_clip();

        /* set attribute */
        gui_set_font(network_name_font);
        gui_set_text_color(*current_MMI_theme->idle_scr_sim2_network_name_color);
        gui_set_text_border_color(*current_MMI_theme->idle_scr_sim2_network_name_border_color);

        if (idle_screen_type != ANALOG_IDLE_SCREEN && idle_screen_type != DIGITAL_IDLE_SCREEN)
        {
            y = MMI_IDLE_SIM2_NETWORK_NAME_Y;
        }
        else
        {
            y = MMI_IDLE_SIM2_NETWORK_NAME_Y_WITH_CLOCK_BG;
        }
	#if (MMI_IDLE_TEXT_ALIGN_TYPE == IDLE_TEXT_CENTER_ALIGN)
        /* get string information */
        width = gui_get_string_width(network_name) + 2;
	#endif
        /* clear background */
        gdi_layer_set_clip(0, y - 1, UI_device_width - w_inset - 1, y + max_str_h - 1);
	#ifdef __GDI_MEMORY_PROFILE_2__
        gdi_draw_solid_rect(0, y - 1, UI_device_width - w_inset - 1, y + max_str_h - 1, GDI_COLOR_TRANSPARENT);
	#else
        draw_wallpaper();
	#endif /* __GDI_MEMORY_PROFILE_2__ */

       /* set alpha blending layer */
       gdi_push_and_set_alpha_blending_source_layer(wallpaper_layer);

	#if (MMI_IDLE_TEXT_ALIGN_TYPE == IDLE_TEXT_CENTER_ALIGN)
        if (width <= (UI_device_width - (w_inset * 2) - img_width))
        {
            x = (r2lMMIFlag) ? ((UI_device_width >> 1) + ((width + img_width) >> 1)) : ((UI_device_width >> 1) - ((width + img_width) >> 1));
            x += (r2lMMIFlag) ? (-1) : (1); /* border text */
            x = (r2lMMIFlag) ? (x - img_width) : (x + img_width);
         //   y += 1; /* border text */
            gui_move_text_cursor(x, y + 1);
            gui_print_bordered_text(network_name);
        }
        else
        {
        
            S32 w = 0;
		#ifdef __MMI_MAINLCD_96X64__
      	  #ifdef __MMI_BIDI_ALG__
			if (!r2lMMIFlag)
			{
    	  #endif /* __MMI_BIDI_ALG__ */ 
    		#ifndef __MMI_ENHANCED_UI_LAYOUT__
	            if (width < UI_device_width - (2 * w_inset))
	            {
	                x = UI_device_width/2 - width/2;
	                if(x<w_inset)
	                    x = w_inset;
	            }
	            else
	            {
	                x = w_inset;
	            }
			#else
				x = w_inset;
			#endif
    	  #ifdef __MMI_BIDI_ALG__
			}
			else
			{
			#ifndef __MMI_ENHANCED_UI_LAYOUT__
	            if (width < UI_device_width - (2 * w_inset))
	            {
	                x = UI_device_width/2 + width/2;
	            }
	            else
	            {
	                x = UI_device_width - (2 * w_inset);
	            }
    		#else
				x = UI_device_width - (2 * w_inset);
			#endif
			}
    	  #endif /* __MMI_BIDI_ALG__ */
            w = UI_device_width - (w_inset * 2) - 2;
		#else
            x = (r2lMMIFlag) ? (UI_device_width - w_inset - 1) : (w_inset + 1);
            w = UI_device_width - (w_inset * 2) - 2;
		#endif
            x += (r2lMMIFlag) ? (-1) : (1); /* border text */
            x = (r2lMMIFlag) ? (x - img_width) : (x + img_width);
      		//y += 1; /* border text */
            gui_print_truncated_borderd_text(x, y + 1, w, idle_screen_network_name);
        }
	#elif(MMI_IDLE_TEXT_ALIGN_TYPE == IDLE_TEXT_LEFT_ALIGN) /* (MMI_IDLE_TEXT_ALIGN_TYPE == IDLE_TEXT_CENTER_ALIGN) */
        {
            S32 w;
            
            x = (r2lMMIFlag) ? (UI_device_width - img_width - w_inset - (w_inset >> 1)) : ((w_inset >> 1) + img_width);
            x += (r2lMMIFlag) ? (-1) : (1); /* border text */
			//y += 1; /* border text */
            w = UI_device_width - w_inset - (w_inset >> 1) - img_width - 2;
            gui_print_truncated_borderd_text(x, y + 1, w, network_name);
        }
	#else /* (MMI_IDLE_TEXT_ALIGN_TYPE == IDLE_TEXT_CENTER_ALIGN) */
        MMI_ASSERT(0);
	#endif /* (MMI_IDLE_TEXT_ALIGN_TYPE == IDLE_TEXT_CENTER_ALIGN) */
        
        gdi_pop_and_restore_alpha_blending_source_layer();
	#if !defined(__MMI_MAINLCD_96X64__)
        /*Draw SIM2 Image*/
        if (!(srv_mode_switch_is_network_service_available() == MMI_FALSE 
              && srv_mode_switch_get_network_mode((mmi_sim_enum)MMI_SIM_ALL) == SRV_MODE_SWITCH_OFF))
        {            
            x = (r2lMMIFlag) ? (x) : (x - img_width);
            y = y + ((max_str_h>>1) - (img_height>>1));
            //gdi_image_draw(x, y, img_src);
            gdi_image_draw_blend2layers(x, y, img_src);
        }
	#endif
        
        gdi_layer_pop_clip();
    }  
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_show_network_status2
 * DESCRIPTION
 *  show card2 network status on idle screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat033_show_network_status2(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 w_inset;
    S32 max_str_h;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	
#if defined(__KJX_FUN__)	//xb add 2017-07-19 这个位置显示海拔
#ifdef __KJX_WEATHER_SUPPORT__
	kjx_redraw_weather_temp();
#elif defined(__BOSCH_BMP280_PRESSURE__)
	//kjx_Show_Altitude();
#endif

#if defined(__KJX_FUN_STEPS__)
	//Kjx_Show_Step();
#endif
	return;
#endif

    if(idle_screen_type != ANALOG_IDLE_SCREEN && idle_screen_type != DIGITAL_IDLE_SCREEN)
    {
	#if (MMI_IDLE_TEXT_ALIGN_TYPE == IDLE_TEXT_CENTER_ALIGN)
        S32 width = 0;
	#endif
        S32 x = 0, y = 0;
        UI_string_type network_status = g_slave_idle_screen_line2text;
        UI_font_type network_status_font;
        GDI_HANDLE wallpaper_layer;

		network_status_font = gui_font_get_type(GUI_FONT_SIZE_IDLE_NETWORK_STATUS);
		w_inset = MMI_IDLE_STRING_MARGIN_GAP;
		max_str_h = Get_CharDisplayHeightOfAllLangAndType(network_status_font->size);

		gdi_layer_push_clip();
		y = MMI_IDLE_SIM2_NETWORK_STATUS_Y;
		wallpaper_layer = dm_get_wallpaper_layer();
		/* clear background */
		gdi_layer_set_clip(0 , y, UI_device_width - w_inset - 1, y + max_str_h);
	#ifdef __GDI_MEMORY_PROFILE_2__
		gdi_draw_solid_rect(0 , y, UI_device_width - w_inset - 1, y + max_str_h, GDI_COLOR_TRANSPARENT);
	#else
		draw_wallpaper();
	#endif /* __GDI_MEMORY_PROFILE_2__ */
	
        /* show slave network status */
        if (network_status != NULL)
        {
            /* set attribute */
            gui_set_font(network_status_font);
            gui_set_text_color(*current_MMI_theme->idle_scr_sim2_network_status_color);
            gui_set_text_border_color(*current_MMI_theme->idle_scr_sim2_network_status_border_color);
		
            /* set alpha blending layer */
            gdi_push_and_set_alpha_blending_source_layer(wallpaper_layer);

		#if (MMI_IDLE_TEXT_ALIGN_TYPE == IDLE_TEXT_CENTER_ALIGN)
            width = gui_get_string_width(network_status) + 2;
            if (width <= (UI_device_width - (w_inset * 2)))
            {
                x = (r2lMMIFlag) ? ((UI_device_width >> 1) + (width >> 1)) : ((UI_device_width >> 1) - (width >> 1));
                x += (r2lMMIFlag) ? (-1) : (1); /* border text */
                y += 1; /* border text */
                gui_move_text_cursor(x, y);
                gui_print_bordered_text(network_status);
            }
            else
            {
                S32 w;

                x = (r2lMMIFlag) ? (UI_device_width - w_inset - 1) : (w_inset + 1);
                x += (r2lMMIFlag) ? (-1) : (1); /* border text */
                y += 1; /* border text */
                w = UI_device_width - (w_inset * 2) - 2/* border text */;
                gui_print_truncated_borderd_text(x, y, w, network_status);
            }
		#elif (MMI_IDLE_TEXT_ALIGN_TYPE == IDLE_TEXT_LEFT_ALIGN)
            {
                S32 w;

                x = (r2lMMIFlag) ? (UI_device_width - w_inset) : (w_inset >> 1);
                x += (r2lMMIFlag) ? (-1) : (1); /* border text */
                y += 1; /* border text */
                w = UI_device_width - w_inset - (w_inset >> 1) - 2;
                gui_print_truncated_borderd_text(x, y, w, network_status);
            }
		#else /* (MMI_IDLE_TEXT_ALIGN_TYPE == IDLE_TEXT_CENTER_ALIGN) */
            MMI_ASSERT(0);
		#endif /* (MMI_IDLE_TEXT_ALIGN_TYPE == IDLE_TEXT_CENTER_ALIGN) */

            gdi_pop_and_restore_alpha_blending_source_layer();
        }
		gdi_layer_pop_clip();
    }
}
#endif /* defined(__MMI_DUAL_SIM_MASTER__) */
#endif  /* __MMI_UI_TECHNO_IDLESCREEN_BAR__ */

#if !defined(__MMI_UI_TECHNO_IDLESCREEN_BAR__)

#ifdef __MMI_MAINLCD_96X64__

/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_handle_extra_text_scroll
 * DESCRIPTION
 *  handle scrolling text of extra text of idle screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat033_handle_network_text_scroll(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_handle_scrolling_text(&g_network_names_scroll);
}

/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_redraw_extra_text_background
 * DESCRIPTION
 *  redraw the background of scrolling text area
 * PARAMETERS
 *  x1      [IN]        Start x position
 *  y1      [IN]        Start y poistion
 *  x2      [IN]        End x position
 *  y2      [IN]        End y postion
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat033_redraw_network_text_background(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_push_clip();
    gui_set_clip(x1, y1, x2, y2);
    wgui_cat033_draw_region_with_wallpaper(x1, y1, x2, y2);
    gui_pop_clip();
}

#endif

/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_show_network_name
 * DESCRIPTION
 *  show network name (the first line) on idle screen
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
static MMI_BOOL wgui_cat033_show_network_name(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL is_display = MMI_FALSE;
    UI_font_type network_name_font;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    network_name_font = gui_font_get_type(GUI_FONT_SIZE_IDLE_NETWORK_NAME);    
    
    if (idle_screen_network_name != NULL)
    {
	#ifndef __OP01_FWPBW__
	#if (MMI_IDLE_TEXT_ALIGN_TYPE == IDLE_TEXT_CENTER_ALIGN)
        S32 width = 0; 
	#endif
	#endif
        S32 x = 0, y = 0, img_width = 0, min_y = UI_device_height - 1, i = 0;
	#if defined(__MMI_DUAL_SIM_MASTER__)&&!defined(__MMI_MAINLCD_96X64__)
        S32 img_height = 0;
        U8 *img_src = NULL;
	#endif
        S32 w_inset = MMI_IDLE_STRING_MARGIN_GAP;
        S32 max_str_h = Get_CharDisplayHeightOfAllLangAndType(network_name_font->size);

        is_display = MMI_TRUE;

        /* find min y of all reminders*/
        for (i = 0; i < wgui_cat033_reminder_total; i++)
        {
            if (g_wgui_cat033_reminder[i].state != cat33_reminder_area_state_deinit)
            {
                min_y = min(min_y, g_wgui_cat033_reminder[i].y);
            }
        }
       	
        /* set attribute */
        gui_set_font(network_name_font);
        gui_set_text_color(*current_MMI_theme->idle_scr_network_name_color);
        gui_set_text_border_color(*current_MMI_theme->idle_scr_network_name_border_color);

        if (idle_screen_type == ANALOG_IDLE_SCREEN || idle_screen_type == DIGITAL_IDLE_SCREEN)
        {
            y = MMI_IDLE_NETWORK_NAME_Y_WITH_CLOCK_BG;
        }
        else if (min_y < UI_device_height - 1) /* have reminders */
        {
            y = MMI_IDLE_DETAILS_START_Y_WITH_REMINDER;
            if ((y + max_str_h - 1) >= min_y)
            {
                is_display = MMI_FALSE;
            }
        }
        else
        {
            y = MMI_IDLE_NETWORK_NAME_Y;
        }
		
        if (is_display == MMI_TRUE)
        {
            gdi_layer_push_clip();
        
            /* get string information */
            
		#ifndef __OP01_FWPBW__
		#if (MMI_IDLE_TEXT_ALIGN_TYPE == IDLE_TEXT_CENTER_ALIGN)
            width = gui_get_string_width(idle_screen_network_name) + 2 /* border */;
		#endif
		#endif
        #if defined (__OP01_FWPBW__) || defined (__MMI_MAINLCD_96X64__)
            w_inset = MMI_IDLE_NETWORK_INFO_MARGIN_GAP;
        #endif
        
            /* clear background */            
            gdi_layer_set_clip(0, y - 1, UI_device_width - w_inset - 1, y + max_str_h - 1);
		#ifdef __GDI_MEMORY_PROFILE_2__
		#ifdef __MMI_MAINLCD_96X64__
            gdi_draw_solid_rect(0, y - 1, UI_device_width - w_inset - 1, y + max_str_h - 1, GDI_COLOR_BLACK);
		#else
            gdi_draw_solid_rect(0, y - 1, UI_device_width - w_inset - 1, y + max_str_h - 1, GDI_COLOR_TRANSPARENT);
		#endif
		#else
            draw_wallpaper();
		#endif /* __GDI_MEMORY_PROFILE_2__ */
			
		#if defined(__MMI_DUAL_SIM_MASTER__) &&!defined(__MMI_MAINLCD_96X64__) 
			if (!(srv_mode_switch_is_network_service_available() == MMI_FALSE 
                  && srv_mode_switch_get_network_mode((mmi_sim_enum)MMI_SIM_ALL) == SRV_MODE_SWITCH_OFF))
			{
				S32 w, h;
				
				img_src = get_image(WGUI_IMG_IDLE_SIM1);
				gui_measure_image(img_src, &w, &h);
				img_width = w + MMI_IDLE_NETWORK_NAME_ICON_GAP;
                img_height = h;
			}
		#endif /* defined(__MMI_DUAL_SIM_MASTER__) &&!defined(__MMI_MAINLCD_96X64__)  */

        #ifndef __OP01_FWPBW__
        #if (MMI_IDLE_TEXT_ALIGN_TYPE == IDLE_TEXT_CENTER_ALIGN)
            if (width <= (UI_device_width - (w_inset * 2) - img_width))
            {
                x = (r2lMMIFlag) ? ((UI_device_width >> 1) + ((width + img_width) >> 1)) : ((UI_device_width >> 1) - ((width + img_width) >> 1));
                x = (r2lMMIFlag) ? (x - img_width) : (x + img_width);
                x += (r2lMMIFlag) ? (-1) : (1); /* border text */
              //  y += 1; /* border text */
                gui_move_text_cursor(x, y + 1);
                gui_print_bordered_text(idle_screen_network_name);
            }
            else
            {
                S32 w = 0;
			#ifdef __MMI_MAINLCD_96X64__
    
		    #ifdef __MMI_BIDI_ALG__
        		if (!r2lMMIFlag)
		        {
			#endif /* __MMI_BIDI_ALG__ */ 
			    #ifndef __MMI_ENHANCED_UI_LAYOUT__
	        	    if (width < UI_device_width - (2 * w_inset))
	            	{
		                x = UI_device_width/2 - width/2;
						if(x<w_inset)
							x = w_inset;
	    	        }
	        	    else
		            {
		                x = w_inset;
	    	        }
			    #else
	        		x = w_inset;
			    #endif
		    #ifdef __MMI_BIDI_ALG__
    	    	}
	    	    else
	    	    {
			    #ifndef __MMI_ENHANCED_UI_LAYOUT__
			        if (width < UI_device_width - (2 * w_inset))
		            {
    		            x = UI_device_width/2 + width/2;
		            }
		            else
		            {
			            x = UI_device_width - (2 * w_inset);
		            }
			    #else
		            x = UI_device_width - (2 * w_inset);
			    #endif
	        	}
		    #endif /* __MMI_BIDI_ALG__ */
                w = UI_device_width - (w_inset * 2) - 2;
		#else
                x = (r2lMMIFlag) ? (UI_device_width - w_inset - 1) : (w_inset + 1);
                w = UI_device_width - (w_inset * 2) - 2;
		#endif
                x += (r2lMMIFlag) ? (-1) : (1); /* border text */
                x = (r2lMMIFlag) ? (x - img_width) : (x + img_width);
          //      y += 1; /* border text */
                gui_print_truncated_borderd_text(x, y + 1, w, idle_screen_network_name);
            }
		#elif(MMI_IDLE_TEXT_ALIGN_TYPE == IDLE_TEXT_LEFT_ALIGN) /* (MMI_IDLE_TEXT_ALIGN_TYPE == IDLE_TEXT_CENTER_ALIGN) */
            {
                S32 w = 0;
				
			#ifndef __MMI_MAINLCD_96X64__
                x = (r2lMMIFlag) ? (UI_device_width - img_width - w_inset - w_inset/2) : (w_inset/2 + img_width);
                w = UI_device_width - w_inset - w_inset/2 - img_width - 2;
                gui_print_truncated_borderd_text(x + 1, y + 1, w, idle_screen_network_name);
			#else
                x = (r2lMMIFlag) ? (UI_device_width - img_width - w_inset) : (w_inset + img_width);
                w = UI_device_width - 2*w_inset - img_width;                
                gui_create_scrolling_text(
                    &g_network_names_scroll,
                    x, /* scrolling text reserve 4 pixels in x-coordinate, x have to move 2 pixels */
                    y + 1, /* scrolling text reserve 2 pixels in y-coordinate, y have to move 1 pixel */
                    w, /* scrolling text reserve 4 pixels in x-coordinate */
                    max_str_h - 2, /* scrolling text reserve 2 pixels in y-coordinate */
                    idle_screen_network_name,
                    wgui_cat033_handle_network_text_scroll,
                    wgui_cat033_redraw_network_text_background,
                    *current_MMI_theme->idle_scr_network_name_color,
                    *current_MMI_theme->idle_scr_network_name_border_color);
                g_network_names_scroll.scroll_gap = 20;
                g_network_names_scroll.flags |= UI_SCROLLING_TEXT_BORDERED_TEXT;
                gui_show_scrolling_text(&g_network_names_scroll);
			#endif
            }
		#else /* (MMI_IDLE_TEXT_ALIGN_TYPE == IDLE_TEXT_CENTER_ALIGN) */
            MMI_ASSERT(0);
		#endif /* (MMI_IDLE_TEXT_ALIGN_TYPE == IDLE_TEXT_CENTER_ALIGN) */
        #else /* __OP01_FWPBW__ */
            if (idle_screen_network_status != NULL)
            {
                S32 w = MMI_IDLE_NETWORK_NAME_AREA_WIDTH;
                x = MMI_IDLE_NETWORK_INFO_MARGIN_GAP;
                // Left allign because SPN needs to be shown on the right half side
                gui_print_truncated_text(x, y, w, idle_screen_network_name);
            }
            else
            {
                // Center allign
                S32 w = UI_device_width - (MMI_IDLE_NETWORK_INFO_MARGIN_GAP << 1);
                if (width <= w)
                {
                    x = (UI_device_width - width) >> 1;
                    gui_move_text_cursor(x, y);
                    gui_print_text(idle_screen_network_name);
                }
                else
                {
                    x = MMI_IDLE_NETWORK_INFO_MARGIN_GAP;
                    gui_print_truncated_text(x, y, w, idle_screen_network_name);
                }
            }
        #endif /* __OP01_FWPBW__ */			

		#if defined(__MMI_DUAL_SIM_MASTER__) &&!defined(__MMI_MAINLCD_96X64__)
			if (!(srv_mode_switch_is_network_service_available() == MMI_FALSE 
                  && srv_mode_switch_get_network_mode((mmi_sim_enum)MMI_SIM_ALL) == SRV_MODE_SWITCH_OFF))
			{
				/*Draw SIM1 Image*/
				x = (r2lMMIFlag) ? (x) : (x - img_width);
                y = y +((max_str_h>>1) - (img_height>>1));
				//gdi_image_draw(x, y, img_src);
				gdi_image_draw_blend2layers(x, y, img_src);
			}
		#endif /* defined(__MMI_DUAL_SIM_MASTER__) &&!defined(__MMI_MAINLCD_96X64__) */

            gdi_layer_pop_clip();
        }
    }
    return is_display;
}

#endif
/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_handle_extra_text_scroll
 * DESCRIPTION
 *  handle scrolling text of extra text of idle screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat033_handle_extra_text_scroll(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_handle_scrolling_text(&extra_scrolling_text);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_redraw_extra_text_background
 * DESCRIPTION
 *  redraw the background of scrolling text area
 * PARAMETERS
 *  x1      [IN]        Start x position
 *  y1      [IN]        Start y poistion
 *  x2      [IN]        End x position
 *  y2      [IN]        End y postion
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat033_redraw_extra_text_background(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_push_clip();
    gui_set_clip(x1, y1, x2, y2);
    wgui_cat033_draw_region_with_wallpaper(x1, y1, x2, y2);
    gui_pop_clip();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_reset_reminder_state
 * DESCRIPTION
 *  reset reminder state
 *  THIS FUNCTION IS ONLY FOR IDLE APP, PLEASE DO NOT USE ARBITRARILY
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat033_reset_reminder_state(void)
{    
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (i = 0; i < wgui_cat033_reminder_total; i++)
    {
        memset(&g_wgui_cat033_reminder[i], 0, sizeof(wgui_cat033_reminder_area_info));
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_get_number_of_informaiont_line
 * DESCRIPTION
 *  Caculate if show network status for phone setup (the second line in idlescreen)
 *  THIS FUNCTION IS ONLY FOR IDLE APP, PLEASE DO NOT USE ARBITRARILY
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
S32 wgui_cat033_get_number_of_informaiont_line(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    #ifndef __MMI_UI_TECHNO_IDLESCREEN_BAR__
    S32 y_end = 0, min_y = UI_device_height - 1, i = 0;
    #endif /* __MMI_UI_TECHNO_IDLESCREEN_BAR__ */
    S32 number_of_line = 0;
#if !defined(__MMI_UI_TECHNO_IDLESCREEN_BAR__)
    UI_font_type network_name_font, network_status_font;
#endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if !defined(__MMI_UI_TECHNO_IDLESCREEN_BAR__)
    network_name_font = gui_font_get_type(GUI_FONT_SIZE_IDLE_NETWORK_NAME);
    network_status_font = gui_font_get_type(GUI_FONT_SIZE_IDLE_NETWORK_STATUS);
#endif

#ifdef __MMI_UI_TECHNO_IDLESCREEN_BAR__
    /* if there have techno bar, 3 information lines will be displayed in idle screen */
    number_of_line = 3;
#else /* __MMI_UI_TECHNO_IDLESCREEN_BAR__ */
    /* find min y of all reminders */
    for (i = 0; i < wgui_cat033_reminder_total; i++)
    {
        if (g_wgui_cat033_reminder[i].init != NULL)
        {
            min_y = min(min_y, g_wgui_cat033_reminder[i].y);
        }
    }
    
    if (idle_screen_type == ANALOG_IDLE_SCREEN || idle_screen_type == DIGITAL_IDLE_SCREEN)
    {
        number_of_line = 1; /* only network name */
    }
    else if (min_y < UI_device_height - 1)
    {
        y_end = MMI_IDLE_DETAILS_START_Y_WITH_REMINDER + 
                Get_CharDisplayHeightOfAllLangAndType(network_name_font->size) - 1;

        if (y_end >= min_y) /* no network name */
        {
            number_of_line = 0;
        }
        else  /* have network name */
        {
            y_end += MMI_IDLE_DETAILS_VGAP_WITH_REMINDER + 
                     Get_CharDisplayHeightOfAllLangAndType(network_status_font->size) + 
                     MMI_IDLE_DETAILS_VGAP_WITH_REMINDER - 1;
            if (y_end >= min_y) 
            {
                number_of_line = 1;
            }
            else /* have network status */
            {
                y_end += MMI_IDLE_DETAILS_VGAP_WITH_REMINDER + 
                         Get_CharDisplayHeightOfAllLangAndType(network_status_font->size) + 
                         MMI_IDLE_DETAILS_VGAP_WITH_REMINDER - 1;
                if (y_end >= min_y)
                {
                    number_of_line = 2;
                }
                else /* have extra information */
                {
                    number_of_line = 3;
                }
            }
        }
    }
    else /* normal state: have network name, network status, extra information */
    {
        number_of_line = 3;
    }
#endif /* __MMI_UI_TECHNO_IDLESCREEN_BAR__ */

    return number_of_line;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_get_extra_text
 * DESCRIPTION
 *  get idle screen extra text
 *  1. CB display
 *  2. audio player
 *  3. FM radio
 *  4. SAT
 * PARAMETERS
 *  void
 * RETURNS
 *  UI_string_type  [OUT]   extra text
 *****************************************************************************/
UI_string_type wgui_cat033_get_extra_text(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#ifdef __MMI_CBS_SUPPORT__
#ifdef __MMI_MESSAGES_CB_DISPLAY_IN_IDLE__
    extern U8* mmi_cbs_get_idle_content(void);
#endif /* __MMI_MESSAGES_CB_DISPLAY_IN_IDLE__ */
#endif
#ifdef __MMI_AUDIO_PLAYER__
    extern audply_struct g_audply;
    extern BOOL mmi_audply_is_playing(void);
#endif /* __MMI_AUDIO_PLAYER__ */

#ifdef __MMI_MEDIA_PLAYER__
    extern MMI_BOOL mmi_medply_if_show_idle_string(void);
    extern UI_string_type mmi_medply_get_idle_string(void);
#endif

#ifdef __MMI_FM_RADIO__
    extern BOOL mmi_fmrdo_is_power_on(void);
#ifdef __MMI_FM_RADIO_RDS__
    extern BOOL mmi_fmrdo_rds_is_power_on(void);
    extern UI_string_type mmi_fmrdo_rds_get_rds_text(void);
#endif/*__MMI_FM_RADIO_RDS__*/
    extern UI_string_type mmi_fmrdo_get_channel_name_or_freq(void);
#endif /* __MMI_FM_RADIO__ */
#ifdef __A8BOX_SUPPORT__
    extern BOOL mmi_a8box_is_playing(void);
    extern UI_string_type mmi_a8box_get_song_name(void);
#endif

#if defined(__MMI_WLAN_FEATURES__)
    extern const U8 *mmi_netset_get_wlan_provider_name(void);
#endif

    UI_string_type extra_text = NULL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_CBS_SUPPORT__
#ifdef __MMI_MESSAGES_CB_DISPLAY_IN_IDLE__
    extra_text = (UI_string_type) mmi_cbs_get_idle_content();
    if (extra_text != NULL)
    {
        return extra_text;
    }
#endif /* __MMI_MESSAGES_CB_DISPLAY_IN_IDLE__ */
#endif

#if defined(__MMI_AUDIO_PLAYER__) && !defined(__MMI_VUI_HOMESCREEN_AUDIO_PLAYER__) && !defined(__MMI_VUI_SHELL_OP01_HOMESCREEN__)
    if (mmi_audply_is_playing())
    {
        return (UI_string_type) g_audply.title;
    }
#endif /* __MMI_AUDIO_PLAYER__ */

#if defined(__MMI_MEDIA_PLAYER__) && !defined(__MMI_VUI_HOMESCREEN_AUDIO_PLAYER__) && !defined(__MMI_VUI_SHELL_OP01_HOMESCREEN__)
    if (mmi_medply_if_show_idle_string())
    {
        return mmi_medply_get_idle_string();
    }
#endif

#if defined(__MMI_FM_RADIO__) && !defined(__MMI_VUI_HOMESCREEN_FM_RADIO__) && !defined(__MMI_VUI_SHELL_OP01_HOMESCREEN__)
    if (mmi_fmrdo_is_power_on())
    {
    #ifdef __MMI_FM_RADIO_RDS__
    #if !defined __COSMOS_MMI__
        if(mmi_fmrdo_rds_is_on())
        {
            return (UI_string_type) mmi_fmrdo_rds_get_rds_text();
        }
        else
    #endif
    #endif/*__MMI_FM_RADIO_RDS__*/
        {
        #if !defined __COSMOS_MMI__
            return (UI_string_type) mmi_fmrdo_get_channel_name_or_freq();
        #endif
        }
    }
#endif /* __MMI_FM_RADIO__ */

#ifdef __A8BOX_SUPPORT__
    if(mmi_a8box_is_playing())
    {
        return mmi_a8box_get_song_name();
    }
#endif

#ifdef __SAT__
    extra_text = (UI_string_type) GetSATIdleText();
    if (extra_text != NULL)
    {
        return extra_text;
    }
#endif /* __SAT__ */

#if defined(__MMI_WLAN_FEATURES__) && !defined(__MMI_VUI_SHELL_OP01_HOMESCREEN__)
	extra_text = (UI_string_type)mmi_netset_get_wlan_provider_name();
	if (extra_text && mmi_ucs2strlen((const CHAR *)extra_text) > 0)
	{
		return extra_text;
	}
#endif /* defined(__MMI_WLAN_FEATURES__) */

#if defined(__KJX_FUN__)	//xb add 2017-07-18
	if(mmi_ucs2strlen((CHAR*)kjx_scrolling_show) > 0)
	{
		return (UI_string_type)kjx_scrolling_show;
	}
#endif

    return NULL;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_show_bracket
 * DESCRIPTION
 *  show bracket of extra information line
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat033_show_bracket(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 bracket_width = 0, bracket_height = 0, x = 0, y = 0, start_y = 0, region_height = 0;
    S32 min_y = UI_device_height - 1, i = 0;
#if !defined(__MMI_UI_TECHNO_IDLESCREEN_BAR__)
    UI_font_type network_name_font;
#endif
    UI_font_type network_status_font;
    GDI_HANDLE wallpaper_layer;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* get font */   
#if !defined(__MMI_UI_TECHNO_IDLESCREEN_BAR__)
    network_name_font = gui_font_get_type(GUI_FONT_SIZE_IDLE_NETWORK_NAME);
#endif
    network_status_font = gui_font_get_type(GUI_FONT_SIZE_IDLE_NETWORK_STATUS);
    
    region_height = Get_CharDisplayHeightOfAllLangAndType(network_status_font->size) + 2;
    wallpaper_layer = wgui_cat033_get_text_abm_layer();

    /* find min y of all reminders */
    for (i = 0; i < wgui_cat033_reminder_total; i++)
    {
        if (g_wgui_cat033_reminder[i].state != cat33_reminder_area_state_deinit)
        {
            min_y = min(min_y, g_wgui_cat033_reminder[i].y);
        }
    }

#ifdef __MMI_UI_TECHNO_IDLESCREEN_BAR__
    #ifdef __MMI_TOUCH_IDLESCREEN_SHORTCUTS__
    if (MMI_TRUE)
    {
        start_y = UI_device_height - wgui_cat033_get_shortcut_max_height()- region_height - 1;
    }
    else
    #elif defined(__MMI_IDLE_SCREEN_ICON_SHORTCUT__)
    if (g_wgui_cat033_reminder[wgui_cat033_reminder_icon_shortcut_bar].state != cat33_reminder_area_state_deinit)
    {
		start_y = g_wgui_cat033_reminder[wgui_cat033_reminder_icon_shortcut_bar].y - region_height;
    }
    else
    #endif /* __MMI_TOUCH_IDLESCREEN_SHORTCUTS__ */
    {
        start_y = UI_device_height - MMI_BUTTON_BAR_HEIGHT - region_height - 1; 
    }
#else /* __MMI_UI_TECHNO_IDLESCREEN_BAR__ */
    if (min_y < UI_device_height - 1)
    {
        start_y = MMI_IDLE_DETAILS_START_Y_WITH_REMINDER +
            Get_CharDisplayHeightOfAllLangAndType(network_name_font->size) +
            MMI_IDLE_DETAILS_VGAP_WITH_REMINDER +
            Get_CharDisplayHeightOfAllLangAndType(network_status_font->size) +
            MMI_IDLE_DETAILS_VGAP_WITH_REMINDER
        #ifdef __MMI_DUAL_SIM_MASTER__
            + MMI_IDLE_DETAILS_VGAP_WITH_REMINDER +
            Get_CharDisplayHeightOfAllLangAndType(network_name_font->size) +
            MMI_IDLE_DETAILS_VGAP_WITH_REMINDER +
            Get_CharDisplayHeightOfAllLangAndType(network_status_font->size) +
            MMI_IDLE_DETAILS_VGAP_WITH_REMINDER
        #endif
                ;
    }
    else
    {
        start_y = MMI_IDLE_EXTRA_Y;
    }
#endif /* __MMI_UI_TECHNO_IDLESCREEN_BAR__ */

    /* set attribute */
    gui_set_text_color(*current_MMI_theme->idle_scr_network_extra_color);
    gui_set_text_border_color(*current_MMI_theme->idle_scr_network_extra_border_color);
    gui_set_font(network_status_font);

    /* set alpha blending layer */
    gdi_push_and_set_alpha_blending_source_layer(wallpaper_layer);

    /* print "[" */
    gui_measure_character((UI_character_type)'[', &bracket_width, &bracket_height);
    bracket_width += 2;  /* border text */
    bracket_height += 2; /* border text */
    x = (r2lMMIFlag) ? (MMI_IDLE_STRING_MARGIN_GAP + bracket_width - 1) : (MMI_IDLE_STRING_MARGIN_GAP);
    x += (r2lMMIFlag) ? (-1) : (1); /* border text */
    y = start_y + ((region_height - bracket_height) >> 1);   /* central y in refresh region */
    y += 1; /* border text */
    gui_move_text_cursor(x, y);
    gui_print_bordered_text(L"[");
            
    /* print "]" */
    gui_measure_character((UI_character_type)']', &bracket_width, &bracket_height);
    bracket_width += 2;  /* border text */
    bracket_height += 2; /* border text */
    x = (r2lMMIFlag) ? (UI_device_width - MMI_IDLE_STRING_MARGIN_GAP - 1) : (UI_device_width - MMI_IDLE_STRING_MARGIN_GAP - 1 - bracket_width + 1);
    x += (r2lMMIFlag) ? (-1) : (1); /* border text */
    y = start_y + ((region_height - bracket_height) >> 1);
    y += 1; /* border text */
    gui_move_text_cursor(x, y);
    gui_print_bordered_text(L"]");

    gdi_pop_and_restore_alpha_blending_source_layer();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_show_extra_information
 * DESCRIPTION
 *  show extra information (the third line) in idle screen
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
static MMI_BOOL wgui_cat033_show_extra_information(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL show_extra = MMI_FALSE;
    UI_string_type extra_text = NULL;
    S32 width = 0, height = 0, x = 0, y = 0, min_y = UI_device_height - 1, i = 0;
#ifndef __MMI_UI_TECHNO_IDLESCREEN_BAR__
    UI_font_type network_name_font;
#endif
    UI_font_type network_status_font;
    GDI_HANDLE wallpaper_layer;
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifndef __MMI_UI_TECHNO_IDLESCREEN_BAR__
    network_name_font = gui_font_get_type(GUI_FONT_SIZE_IDLE_NETWORK_NAME);
#endif
    network_status_font = gui_font_get_type(GUI_FONT_SIZE_IDLE_NETWORK_STATUS);
    wallpaper_layer = wgui_cat033_get_text_abm_layer();
    
    if (extra_scrolling_text_ptr != NULL) /* previous time has scrolling text */
    {
        UI_string_type text = wgui_cat033_get_extra_text();

        if (g_wgui_cat033_redraw_scrolling_text == MMI_FALSE 
            && (extra_scrolling_text_ptr->flags & UI_SCROLLING_TEXT_ENABLE_SCROLL)
            && text != NULL)
        {
            /* animation callback and have extra string -> redraw scrolling text */
            wgui_cat033_show_bracket();
            gdi_push_and_set_alpha_blending_source_layer(wallpaper_layer);
            gui_redraw_scrolling_text(extra_scrolling_text_ptr);
            gdi_pop_and_restore_alpha_blending_source_layer();
            return MMI_TRUE;
        }
        else
        {
            /* refresh to new string: stop previous text scrolling */
            gui_scrolling_text_stop(extra_scrolling_text_ptr);
            extra_scrolling_text_ptr = NULL;
        }        
    }
    
    /* find min y of all reminders */
    for (i = 0; i < wgui_cat033_reminder_total; i++)
    {
        if (g_wgui_cat033_reminder[i].state != cat33_reminder_area_state_deinit)
        {
            min_y = min(min_y, g_wgui_cat033_reminder[i].y);
        }
    }
	
    /* configure extra text */
    if (idle_screen_type == ANALOG_IDLE_SCREEN || idle_screen_type == DIGITAL_IDLE_SCREEN)
    {
        show_extra = MMI_FALSE;
        extra_scrolling_text_ptr = NULL;
    }
    else
    {
        MMI_BOOL is_display = MMI_TRUE;

	#ifndef __MMI_UI_TECHNO_IDLESCREEN_BAR__
        if (min_y < UI_device_height - 1)
        {
            y = MMI_IDLE_DETAILS_START_Y_WITH_REMINDER +
                Get_CharDisplayHeightOfAllLangAndType(network_name_font->size) +
                MMI_IDLE_DETAILS_VGAP_WITH_REMINDER +
                Get_CharDisplayHeightOfAllLangAndType(network_status_font->size) +
                MMI_IDLE_DETAILS_VGAP_WITH_REMINDER
        	#ifdef __MMI_DUAL_SIM_MASTER__
                + MMI_IDLE_DETAILS_VGAP_WITH_REMINDER +
                Get_CharDisplayHeightOfAllLangAndType(network_name_font->size) +
                MMI_IDLE_DETAILS_VGAP_WITH_REMINDER +
                Get_CharDisplayHeightOfAllLangAndType(network_status_font->size) +
                MMI_IDLE_DETAILS_VGAP_WITH_REMINDER
        	#endif
                ;
            if ((y + Get_CharDisplayHeightOfAllLangAndType(network_status_font->size) - 1) >= min_y)
            {
                is_display = MMI_FALSE;
            }
        }
	#endif /* __MMI_UI_TECHNO_IDLESCREEN_BAR__ */

        if (is_display == MMI_FALSE)
        {
            show_extra = MMI_FALSE;
            extra_scrolling_text_ptr = NULL;
        }
        else
        {
            extra_text = wgui_cat033_get_extra_text();			
            show_extra = (extra_text != NULL) ? (MMI_TRUE) : (MMI_FALSE);
            extra_scrolling_text_ptr = (show_extra == MMI_TRUE) ? (&extra_scrolling_text) : (NULL);
        }
    }
	
    /* show extra information */
    if (show_extra == MMI_TRUE && extra_scrolling_text_ptr != NULL)
    {
        S32 w_inset = MMI_IDLE_STRING_MARGIN_GAP;
        S32 bracket_width = 0, text_bracket_gap = 5;
		S32 extra_string_width = 0, extra_string_height = 0;

        gui_set_font(network_status_font);

        /* get extra string width & height */
        gui_measure_string(extra_text, &extra_string_width, &extra_string_height);
        height = Get_CharDisplayHeightOfAllLangAndType(network_status_font->size);
   
	#ifdef __MMI_UI_TECHNO_IDLESCREEN_BAR__
        /* set refresh region */        
      #ifdef __MMI_TOUCH_IDLESCREEN_SHORTCUTS__
        if (MMI_TRUE)
        {
            extra_text_x1 = w_inset;
            extra_text_y1 = UI_device_height - wgui_cat033_get_shortcut_max_height() - height - 1;
            extra_text_x2 = UI_device_width - w_inset - 1;
            extra_text_y2 = extra_text_y1 + height - 1;
        }
        else
      #elif defined(__MMI_IDLE_SCREEN_ICON_SHORTCUT__)
        if (g_wgui_cat033_reminder[wgui_cat033_reminder_icon_shortcut_bar].state != cat33_reminder_area_state_deinit)
        {
            extra_text_x1 = w_inset;
			extra_text_x2 = UI_device_width - w_inset - 1;
			extra_text_y2 = g_wgui_cat033_reminder[wgui_cat033_reminder_icon_shortcut_bar].y - 1;
            extra_text_y1 = extra_text_y2 - height + 1;
        }
        else
      #endif /* __MMI_TOUCH_IDLESCREEN_SHORTCUTS__ */
        {
            extra_text_x1 = w_inset;
            extra_text_y1 = UI_device_height - MMI_BUTTON_BAR_HEIGHT - height - 1;
            extra_text_x2 = UI_device_width - w_inset - 1;
            extra_text_y2 = extra_text_y1 + height - 1;
        }
	#else /* __MMI_UI_TECHNO_IDLESCREEN_BAR__ */

        /* set refresh region */
        if (min_y < UI_device_height - 1)
        {
            y = MMI_IDLE_DETAILS_START_Y_WITH_REMINDER +
                Get_CharDisplayHeightOfAllLangAndType(network_name_font->size) +
                MMI_IDLE_DETAILS_VGAP_WITH_REMINDER +
                Get_CharDisplayHeightOfAllLangAndType(network_status_font->size) +
                MMI_IDLE_DETAILS_VGAP_WITH_REMINDER
        	#ifdef __MMI_DUAL_SIM_MASTER__
                + MMI_IDLE_DETAILS_VGAP_WITH_REMINDER +
                Get_CharDisplayHeightOfAllLangAndType(network_name_font->size) +
                MMI_IDLE_DETAILS_VGAP_WITH_REMINDER +
                Get_CharDisplayHeightOfAllLangAndType(network_status_font->size) +
                MMI_IDLE_DETAILS_VGAP_WITH_REMINDER
        	#endif
                ;
        }
        else
        {
            y = MMI_IDLE_EXTRA_Y;
        }

	#if defined(__KJX_LOG_OUTPUT__)
		//LOGD("y:%d", y);
	#endif

        extra_text_x1 = w_inset;
        extra_text_y1 = y;
        extra_text_x2 = UI_device_width - w_inset - 1;
        extra_text_y2 = y + height - 1 + 8;

	#endif /* __MMI_UI_TECHNO_IDLESCREEN_BAR__ */        
		
        gdi_layer_push_clip();
	#ifdef __GDI_MEMORY_PROFILE_2__
        if (extra_text_x1 >= 0)
        {
            gdi_layer_set_clip(extra_text_x1, extra_text_y1, extra_text_x2, extra_text_y2);
        }
	#endif /* __GDI_MEMORY_PROFILE_2__ */
        gdi_layer_pop_clip();

        /* show bracket */
        wgui_cat033_show_bracket();

        /* show extra information */
        gui_set_text_color(*current_MMI_theme->idle_scr_network_extra_color);
        gui_set_text_border_color(*current_MMI_theme->idle_scr_network_extra_border_color);
        gdi_push_and_set_alpha_blending_source_layer(wallpaper_layer);        
        
		extra_string_width += 2;  /* border text */
		extra_string_height += 2; /* border text */

        bracket_width = gui_get_character_width('[') + 2; /* bracket width */
        if (extra_string_width <= (UI_device_width - ((w_inset + text_bracket_gap + 2/*bordered text*/*3/*"[","]",content*/) * 2)))
        {
            x = (r2lMMIFlag) ? ((UI_device_width >> 1) + (extra_string_width >> 1)) : ((UI_device_width >> 1) - (extra_string_width >> 1));
			x += (r2lMMIFlag) ? (-1) : (1); /* border text */
            y = extra_text_y1 + ((height - extra_string_height) >> 1);  /* central y in refesh region */
			y += 1; /* border text */
            gui_move_text_cursor(x, y);
            gui_print_bordered_text(extra_text);
        }
        else
        {
            x = w_inset + bracket_width + text_bracket_gap;
            y = extra_text_y1 + ((height - extra_string_height) >> 1); /* central y in refresh region */
            width = UI_device_width - x - (w_inset + gui_get_character_width(']') + 2 + text_bracket_gap);
            gui_create_scrolling_text(
				extra_scrolling_text_ptr,
				x + 2, /* scrolling text reserve 4 pixels in x-coordinate, x have to move 2 pixels */
				y + 1, /* scrolling text reserve 2 pixels in y-coordinate, y have to move 1 pixel */
				width - 4, /* scrolling text reserve 4 pixels in x-coordinate */
				extra_string_height - 2, /* scrolling text reserve 2 pixels in y-coordinate */
				extra_text,
				wgui_cat033_handle_extra_text_scroll,
				wgui_cat033_redraw_extra_text_background,
				*current_MMI_theme->idle_scr_network_extra_color,
				*current_MMI_theme->idle_scr_network_extra_border_color);
            extra_scrolling_text_ptr->scroll_gap = 20;
            extra_scrolling_text_ptr->flags |= UI_SCROLLING_TEXT_BORDERED_TEXT;
            gui_show_scrolling_text(extra_scrolling_text_ptr);
        }
        
        gdi_pop_and_restore_alpha_blending_source_layer();
    }
    else
    {
	/* for indicate no draw extra_text this time,
		* so no need to clean it next time */
        extra_text_x1 = -1;
    }

    return show_extra;
}


#if defined(__SAT__)
/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_show_SAT_icon
 * DESCRIPTION
 *  show SAT icon on idle screen
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
static MMI_BOOL wgui_cat033_show_SAT_icon(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8* SAT_icon = NULL;
    S32 x = 0, y = 0, width = 0, height = 0, i = 0, min_y = UI_device_height - 1;
    MMI_BOOL is_display = MMI_FALSE;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/	
    /* show SAT icon */
    /* the rule to display the SAT icon is a little complicated,
	* can be revised in the future */
	SAT_icon = GetSATIdleIcon();
	if (SAT_icon != NULL)
	{
		S32 display_x_offset, display_y_offset;
		S32 display_width, display_height;

        is_display = MMI_TRUE;

        /* find min y of all reminders*/
        for (i = 0; i < wgui_cat033_reminder_total; i++)
        {
            if (g_wgui_cat033_reminder[i].state != cat33_reminder_area_state_deinit)
            {
                min_y = min(min_y, g_wgui_cat033_reminder[i].y);
            }
        }
        
		gui_measure_image(SAT_icon, &width, &height);
		gdi_util_fit_box(
			GDI_UTIL_MODE_LONG_SIDE_FIT,
			26, 26, /* available display area, can be defined in wgui.h in the future */
			width, height,
			&display_x_offset, &display_y_offset,
			&display_width, &display_height);

#if defined(__MMI_UI_TECHNO_IDLESCREEN_BAR__)
        x = (UI_device_width >> 1) - (display_width >> 1);
        y = UI_device_height - MMI_BUTTON_BAR_HEIGHT - 26;
        is_display = MMI_TRUE;
#else /* defined(__MMI_UI_TECHNO_IDLESCREEN_BAR__) */
    #if defined(__MMI_MAINLCD_128X128__) || defined(__MMI_MAINLCD_128X160__)
		x = 1;  /* can be defined in wgui.h in the future */
		y = 22; /* can be defined in wgui.h in the future */
    #elif defined(__MMI_MAINLCD_176X220__) && !defined(__MMI_UI_TECHNO_IDLESCREEN_BAR__)
		x = 1;  /* can be defined in wgui.h in the future */
		y = 24; /* can be defined in wgui.h in the future */
    #else /* defined(__MMI_MAINLCD_176X220__) && !defined(__MMI_UI_TECHNO_IDLESCREEN_BAR__) */
		x = (UI_device_width >> 1) - (display_width >> 1);
		y = MMI_IDLE_SATICON_Y;
    #endif /* defined(__MMI_MAINLCD_176X220__) && !defined(__MMI_UI_TECHNO_IDLESCREEN_BAR__) */
		if (min_y < UI_device_height - 1) /* have reminder */
		{
			if ((y + display_height - 1) >= min_y)
			{
				is_display = MMI_FALSE;
			}
		}
#endif /* defined(__MMI_UI_TECHNO_IDLESCREEN_BAR__) */

		if (is_display == MMI_TRUE)
		{
			gui_push_clip();
			gui_set_clip(x, y, x + display_width, y + display_height);
			gdi_image_draw_resized(x, y, display_width, display_height, SAT_icon);
			gui_pop_clip();
		}
	}
    return is_display;
}
#endif /* defined(__SAT__) */

/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_show_details
 * DESCRIPTION
 *  show network name, network status, extra information, and SAT on idle screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat033_show_details(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();
        
    if (extra_text_x1 >= 0)
    {
        wgui_cat033_draw_region_with_background_color(extra_text_x1, extra_text_y1, extra_text_x2, extra_text_y2);
    }
    
#if defined(__MMI_DUAL_SIM_MASTER__)
	/* dual SIM */
 #if defined(__MMI_UI_TECHNO_IDLESCREEN_BAR__)
	wgui_cat033_techno_set_text_and_date();
	wgui_cat033_show_techno_network_name();
	wgui_cat033_show_techno_network_status();        
	wgui_cat033_show_techno_network_name2();
	wgui_cat033_show_techno_network_status2();
 #else  /* defined(__MMI_UI_TECHNO_IDLESCREEN_BAR__) */
  #if defined(__DUAL_SIM_IDLE_TEXT_AT_SAME_POSITION__) /* Dual SIM show at same position */
	if (g_wgui_cat033_dual_sim_current_text_type == SIM1_TEXT_ON_IDLE) /* Current is show SIM1 */
	{
		wgui_cat033_show_network_name();
		wgui_cat033_show_network_status();
	}
	else if (g_wgui_cat033_dual_sim_current_text_type == SIM2_TEXT_ON_IDLE) /* Current is show SIM2 */
	{
		wgui_cat033_show_network_name2();
		wgui_cat033_show_network_status2();
	}
  #else   
	wgui_cat033_show_network_name();
   #ifndef __MMI_MAINLCD_96X64__
	wgui_cat033_show_network_status();
	wgui_cat033_show_network_name2();
	wgui_cat033_show_network_status2();
   #endif
  #endif /* defined(__DUAL_SIM_IDLE_TEXT_AT_SAME_POSITION__) */
 #endif /* defined(__MMI_UI_TECHNO_IDLESCREEN_BAR__) */

#else /* defined(__MMI_DUAL_SIM_MASTER__) */

	/* single SIM */
 #if defined(__MMI_UI_TECHNO_IDLESCREEN_BAR__)
	wgui_cat033_techno_set_text_and_date();
	wgui_cat033_show_techno_network_name();
	wgui_cat033_show_techno_network_status();
 #else
  #if defined(__KJX_FUN__)	//xb add 2017-07-18
	wgui_cat033_show_network_status();//智慧北斗
   #if defined(__BOSCH_BMP280_PRESSURE__)
	Kjx_Show_Temperature_And_Altitude();
   #endif
   #if defined(__KJX_FUN_STEPS__)
	Kjx_Show_Step_And_Calorie();
   #endif
  #else 
	wgui_cat033_show_network_name();
   #ifndef __MMI_MAINLCD_96X64__
	wgui_cat033_show_network_status();
   #endif
  #endif
 #endif /* defined(__MMI_UI_TECHNO_IDLESCREEN_BAR__) */
#endif /* defined(__MMI_DUAL_SIM_MASTER__) */
    
    /* show extra information */
#if defined(__MMI_SEARCH_WEB__) && (defined(__MMI_MAINLCD_128X160__) || (defined(__MMI_MAINLCD_240X320__) || defined(__MMI_MAINLCD_320X240__))&&(defined(__MMI_CALENDAR_ON_IDLE_SCREEN__)))
    if(g_wgui_cat033_search.image == NULL && g_wgui_cat033_search.string == NULL)
#endif/*__MMI_SEARCH_WEB__ */
    {
        wgui_cat033_show_extra_information();
    }

#if defined(__SAT__)
    /* show SAT icon */
    wgui_cat033_show_SAT_icon();
#endif /* defined(__SAT__) */
    
    gdi_layer_unlock_frame_buffer();
    gdi_lcd_repaint_all();
}


/*****************************************************************************
 * FUNCTION
 *  idle_screen_show_network_details
 * DESCRIPTION
 *  show network name and network status on idle screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void idle_screen_show_network_details(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(__MMI_OP11_CAT433_SUPPORT__)
    if (mmi_hs_is_enable())
    {
        wgui_cat433_update_details();
    }
    else
#elif defined(__MMI_OP12_CAT533_SUPPORT__)
    if (mmi_tb_is_enable())
    {
        wgui_cat533_update_details();
    }
    else
#elif defined( __MMI_OP11_HOMESCREEN_0301__) || defined(__MMI_OP11_HOMESCREEN_0302__)   
    if (mmi_op11_hs32_is_enable())
    {
        mmi_idle_update_service_area();
    }
    else
#elif defined(__MMI_VUI_SHELL_APP__)
    if (MMI_TRUE)
    {
        mmi_idle_shell_update_idle_text();
    }
    else
#endif
    {
        wgui_cat033_show_details();
    }
}
#if defined(__MMI_SEARCH_WEB__)
static void gui_search_bar_timer_callback(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
     gui_handle_scrolling_text(&g_search_tab_scroll_text);
}

/*****************************************************************************
 * FUNCTION
 *  gui_search_background
 * DESCRIPTION
 *  draw hilight menuitem text, callback function for scrolling text
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
 static void gui_search_background(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_TRANSPARENT);
}

/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_search_show
 * DESCRIPTION
 *  for category 33 to show searching screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat033_search_show()
{
    S32 img_w = 0, img_h = 0;
    S32 string_w = 0, string_h = 0;
    S32 string_x = 0;
	gui_push_clip();
	gui_set_clip(g_wgui_cat033_search.x, g_wgui_cat033_search.y, g_wgui_cat033_search.x + g_wgui_cat033_search.w, g_wgui_cat033_search.y + g_wgui_cat033_search.h);
    gui_measure_image(g_wgui_cat033_search.image, &img_w, &img_h);
    gui_set_font(&MMI_medium_font);
    gui_measure_string((UI_string_type)g_wgui_cat033_search.string, &string_w, &string_h);
     #ifdef __MMI_BIDI_ALG__
	if(r2lMMIFlag)
	{
            string_x =  g_wgui_cat033_search.x - g_wgui_cat033_search.w + 1;
	    gui_show_transparent_image(string_x, g_wgui_cat033_search.y + ((g_wgui_cat033_search.h - img_h)>>1) , g_wgui_cat033_search.image, 0);  
        }
        else
     #endif
        {
           gui_show_transparent_image(g_wgui_cat033_search.x, g_wgui_cat033_search.y + ((g_wgui_cat033_search.h - img_h)>>1) , g_wgui_cat033_search.image, 0);  
           string_x = g_wgui_cat033_search.x + img_w + MMI_IDLE_STATIC_SEARCH_IMAGE_STRING_GAP; 
        } 
	gui_create_scrolling_text(
            &g_search_tab_scroll_text,
            string_x,
            g_wgui_cat033_search.y + ((g_wgui_cat033_search.h - string_h)>>1),
            UI_DEVICE_WIDTH - (MMI_status_bar_height<<1) - img_w - MMI_IDLE_STATIC_SEARCH_IMAGE_STRING_GAP, //g_wgui_cat033_search.w - img_w - MMI_IDLE_STATIC_SEARCH_IMAGE_STRING_GAP,
            string_h,
            (UI_string_type) g_wgui_cat033_search.string,
            gui_search_bar_timer_callback,
            gui_search_background,
            *current_MMI_theme->idle_scr_network_name_color,
            *current_MMI_theme->idle_scr_network_name_border_color
        );
	g_search_tab_scroll_text.text_font = MMI_medium_font;
    g_search_tab_scroll_text.flags |= UI_SCROLLING_TEXT_BORDERED_TEXT;
    gui_show_scrolling_text(&g_search_tab_scroll_text);
    gui_pop_clip();
}

/*****************************************************************************
 * FUNCTION
 *  idle_screen_enable_searching_screen
 * DESCRIPTION
 *  for category 33 to show searching screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
 void idle_screen_enable_search_bar(const U8 *image, const WCHAR* text, FuncPtr touch_handler)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 img_h = 0, img_w = 0;
    S32 string_w = 0, string_h = 0;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_wgui_cat033_search.y = MMI_IDLE_STATIC_SEARCH_START_Y;
    g_wgui_cat033_search.image = (U8 *)image;
    g_wgui_cat033_search.string = (U8 *)text;
    gui_measure_image(g_wgui_cat033_search.image, &img_w, &img_h);
    gui_set_font(&MMI_medium_font);
    gui_measure_string((UI_string_type)g_wgui_cat033_search.string, &string_w, &string_h);
    if(img_w + MMI_IDLE_STATIC_SEARCH_IMAGE_STRING_GAP + string_w <= UI_DEVICE_WIDTH - (MMI_status_bar_height<<1))
    {
        g_wgui_cat033_search.w = img_w + MMI_IDLE_STATIC_SEARCH_IMAGE_STRING_GAP + string_w;
    }
    else
    {
         g_wgui_cat033_search.w = UI_DEVICE_WIDTH - (MMI_status_bar_height<<1);
    }
    #ifdef __MMI_BIDI_ALG__
		if(r2lMMIFlag)
		{
			g_wgui_cat033_search.x = (UI_DEVICE_WIDTH + g_wgui_cat033_search.w)>>1;
		}
		else
	#endif
		{
    		g_wgui_cat033_search.x = (UI_DEVICE_WIDTH - g_wgui_cat033_search.w)>>1;
		}
    if(img_h >= string_h)
    {
        g_wgui_cat033_search.h = img_h;
    }
    else
    {
        g_wgui_cat033_search.h = string_h;
    }
#if defined(__MMI_TOUCH_SCREEN__) 
#ifdef __MMI_ICON_BAR_SUPPORT__
	g_wgui_cat033_search.pen_event_handler = wgui_icon_bar_translate_pen_event;
#endif
#endif
	g_wgui_cat033_search.handler = touch_handler;
}
#endif /*__MMI_SEARCH_WEB__*/

#if defined(__MMI_CALENDAR_ON_IDLE_SCREEN__)
/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_calendar_init
 * DESCRIPTION
 *  for category 33 to init calendar display
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat033_calendar_init(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    applib_time_struct max_time, min_time, current_time;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_wgui_cat033_reminder[wgui_cat033_reminder_calendar].state == cat33_reminder_area_state_deinit)
    {
        memset(&min_time, 0, sizeof(applib_time_struct));
        memset(&max_time, 0, sizeof(applib_time_struct));
        memset(&current_time, 0, sizeof(applib_time_struct));
        min_time.nYear = GUI_CALENDAR_DEFAULT_FIRST_NAVI_YEAR;
        min_time.nMonth = 1;
        min_time.nDay = 1;
        max_time.nYear = GUI_CALENDAR_DEFAULT_LAST_NAVI_YEAR;
        max_time.nMonth = 12;
        max_time.nDay = 31;
        applib_dt_get_date_time(&current_time);
        /* init calendar GUI component before init application's data */
        wgui_calendar_create(
            GUI_CALENDAR_TYPE_MONTH,
            max_time,
            min_time,
            current_time,
            0);
        wgui_calendar_set_flags_on(GUI_CALENDAR_DISABLE_PREV_NEXT_SWITCH);
        wgui_calendar_set_on_idle(MMI_TRUE);

        /* init calendar data of applicaion */
        mmi_clndr_create_calendar_on_idle();

        /* init successfully, set state */
        g_wgui_cat033_reminder[wgui_cat033_reminder_calendar].state = cat33_reminder_area_state_init;
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_calendar_deinit
 * DESCRIPTION
 *  for category 33 to de-init calendar display
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat033_calendar_deinit(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_wgui_cat033_reminder[wgui_cat033_reminder_calendar].state != cat33_reminder_area_state_deinit)
    {
        /* de-init calendar GUI component */
        wgui_calendar_close();

        /* de-init calendar data of application */
        mmi_clndr_exit_set_calendar_on_idle();

        /* de-init successfully, set state */
        g_wgui_cat033_reminder[wgui_cat033_reminder_calendar].state = cat33_reminder_area_state_deinit;
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_calendar_show
 * DESCRIPTION
 *  for category 33 to show calendar display
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat033_calendar_show(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* display calendar GUI component */
    if (g_wgui_cat033_reminder[wgui_cat033_reminder_calendar].state == cat33_reminder_area_state_init)
    {
        wgui_calendar_show();

        /* show successfully, set state */
        g_wgui_cat033_reminder[wgui_cat033_reminder_calendar].state = cat33_reminder_area_state_show;
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_calendar_redraw
 * DESCRIPTION
 *  for category 33 to redraw calendar display
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat033_calendar_redraw(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* redraw calendar GUI component */
    if (g_wgui_cat033_reminder[wgui_cat033_reminder_calendar].state == cat33_reminder_area_state_show)
    {
        wgui_calendar_idle_update();
    }
}


/*****************************************************************************
 * FUNCTION
 *  idle_screen_enable_calendar_display
 * DESCRIPTION
 *  for idle app to display calendar on idle screen category
 *  this function must be called before show category funcion
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void idle_screen_enable_calendar_display(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_wgui_cat033_reminder[wgui_cat033_reminder_calendar].init = wgui_cat033_calendar_init;
    g_wgui_cat033_reminder[wgui_cat033_reminder_calendar].show = wgui_cat033_calendar_show;
    g_wgui_cat033_reminder[wgui_cat033_reminder_calendar].redraw = wgui_cat033_calendar_redraw;
    g_wgui_cat033_reminder[wgui_cat033_reminder_calendar].deinit = wgui_cat033_calendar_deinit;
    g_wgui_cat033_reminder[wgui_cat033_reminder_calendar].x = MMI_IDLE_STATIC_CALENDAR_MONTH_FRAME_START_X;
    g_wgui_cat033_reminder[wgui_cat033_reminder_calendar].y = MMI_IDLE_STATIC_CALENDAR_MONTH_FRAME_START_Y;
    g_wgui_cat033_reminder[wgui_cat033_reminder_calendar].w = MMI_IDLE_STATIC_CALENDAR_MONTH_FRAME_START_WIDTH;
    g_wgui_cat033_reminder[wgui_cat033_reminder_calendar].h = MMI_IDLE_STATIC_CALENDAR_MONTH_FRAME_START_HEIGHT;
}
#endif /* defined(__MMI_CALENDAR_ON_IDLE_SCREEN__) */

#if defined(__MMI_OP01_DCD__)

typedef struct _wgui_cat033_dcd_data_struct
{
    GDI_HANDLE* dcd_layer;
    U8* dcd_mem;
    void* dcd_agent;
} wgui_cat033_dcd_data_struct;

static wgui_cat033_dcd_data_struct g_wgui_cat033_dcd_data = {0};
extern UI_dcd_theme *current_dcd_theme;


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_dcd_draw_background
 * DESCRIPTION
 *  for category 33 to draw dcd background
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat033_dcd_draw_background(void)
{
	/*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x1, y1, x2, y2;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    x1 = g_wgui_cat033_reminder[wgui_cat033_reminder_dcd].x;
    y1 = g_wgui_cat033_reminder[wgui_cat033_reminder_dcd].y;
    x2 = g_wgui_cat033_reminder[wgui_cat033_reminder_dcd].x + g_wgui_cat033_reminder[wgui_cat033_reminder_dcd].w - 1;
    y2 = g_wgui_cat033_reminder[wgui_cat033_reminder_dcd].y + g_wgui_cat033_reminder[wgui_cat033_reminder_dcd].h - 1;

	gui_push_clip();
	gui_set_clip(x1, y1, x2, y2);
	/* show DCD background */
	gui_draw_filled_area(x1, y1, x2, y2, current_dcd_theme->dcd_idle_bkg_filler);
	gui_pop_clip();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_dcd_redraw
 * DESCRIPTION
 *  for category 33 to redraw dcd 
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat033_dcd_redraw(void)
{
	/*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_wgui_cat033_reminder[wgui_cat033_reminder_dcd].state == cat33_reminder_area_state_show)
    {
		wgui_cat033_dcd_draw_background();
	}
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_dcd_init
 * DESCRIPTION
 *  for category 33 to init dcd display
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat033_dcd_init(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_wgui_cat033_reminder[wgui_cat033_reminder_dcd].state == cat33_reminder_area_state_deinit)
    {        
        /* init successfully, set state */
        g_wgui_cat033_reminder[wgui_cat033_reminder_dcd].state = cat33_reminder_area_state_init;
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_dcd_deinit
 * DESCRIPTION
 *  for category 33 to de-init dcd display
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat033_dcd_deinit(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_cat033_dcd_data_struct* ptr = NULL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_wgui_cat033_reminder[wgui_cat033_reminder_dcd].state != cat33_reminder_area_state_deinit)
    {
        ptr = (wgui_cat033_dcd_data_struct*)(g_wgui_cat033_reminder[wgui_cat033_reminder_dcd].data);

        mmi_dcd_exit_idlescreen();
        
        /* de-init DCD component */
        ui_dcd_deinit(); 

        /* free dcd layer */
        ptr->dcd_layer = NULL;
        
        /* free dcd memory */
        if (ptr->dcd_mem != NULL)
        {
            mmi_frm_scrmem_free(ptr->dcd_mem);
            ptr->dcd_mem = NULL;
        }        
        memset(ptr, 0, sizeof(wgui_cat033_dcd_data_struct));
               
        /* set state */
        g_wgui_cat033_reminder[wgui_cat033_reminder_dcd].state = cat33_reminder_area_state_deinit;
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_dcd_show
 * DESCRIPTION
 *  for category 33 to show dcd display
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat033_dcd_show(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_cat033_dcd_data_struct* ptr = NULL;
    S32 x, y, w, h;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_wgui_cat033_reminder[wgui_cat033_reminder_dcd].state == cat33_reminder_area_state_init)
    {            
        ptr = (wgui_cat033_dcd_data_struct*)(g_wgui_cat033_reminder[wgui_cat033_reminder_dcd].data);
        x = g_wgui_cat033_reminder[wgui_cat033_reminder_dcd].x;
        y = g_wgui_cat033_reminder[wgui_cat033_reminder_dcd].y;
        w = g_wgui_cat033_reminder[wgui_cat033_reminder_dcd].w;
        h = g_wgui_cat033_reminder[wgui_cat033_reminder_dcd].h;

        wgui_cat033_dcd_draw_background();

        /* init DCD layer: allocate memory */
        MMI_ASSERT(ptr->dcd_mem == NULL);
        ptr->dcd_mem = (U8*)mmi_frm_scrmem_alloc_framebuffer(SCRMEM_CAT33_POOL_SIZE);
        MMI_ASSERT(ptr->dcd_mem);
        
        /* create layer */
        MMI_ASSERT(ptr->dcd_layer == NULL);
        dm_create_layer_using_outside_memory(
                x, y, w, h, 
                &(ptr->dcd_layer), ptr->dcd_mem, 
                SCRMEM_CAT33_POOL_SIZE,
                DM_LAYER_TOP);
        MMI_ASSERT(ptr->dcd_layer);

        /* init layer */
        gdi_layer_push_and_set_active(*(ptr->dcd_layer));
        gdi_layer_set_source_key(TRUE, GDI_COLOR_TRANSPARENT);
        gdi_layer_clear(GDI_COLOR_TRANSPARENT);
        gdi_layer_pop_and_restore_active();

        /* init DCD component */
		ui_dcd_init(x, y, w, h, *(ptr->dcd_layer), ptr->dcd_agent);

        /* show DCD component */
        ui_dcd_show_start();        

        /* set state */
        g_wgui_cat033_reminder[wgui_cat033_reminder_dcd].state = cat33_reminder_area_state_show;
    }
}


#if defined(__MMI_TOUCH_SCREEN__)
/*****************************************************************************
 * FUNCTION
 *  idle_screen_set_dcd_pen_event_callback
 * DESCRIPTION
 *  for idle app to set pen event callback function
 * PARAMETERS
 *  agent   [IN]        DCD agent
 * RETURNS
 *  void
 *****************************************************************************/
void idle_screen_register_dcd_pen_handler(cat33_reminder_pen_handler pen_handler)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_wgui_cat033_reminder[wgui_cat033_reminder_dcd].pen_event_handler = pen_handler;
}
#endif /* defined(__MMI_TOUCH_SCREEN__)  */


/*****************************************************************************
 * FUNCTION
 *  idle_screen_enable_dcd_display
 * DESCRIPTION
 *  for idle app to display DCD on idle screen category
 *  this function must be called before show category funcion
 * PARAMETERS
 *  agent   [IN]        DCD agent
 * RETURNS
 *  void
 *****************************************************************************/
void idle_screen_enable_dcd_display(void* agent)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_cat033_dcd_data_struct* ptr = NULL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_wgui_cat033_reminder[wgui_cat033_reminder_dcd].init = wgui_cat033_dcd_init;
    g_wgui_cat033_reminder[wgui_cat033_reminder_dcd].show = wgui_cat033_dcd_show;
    g_wgui_cat033_reminder[wgui_cat033_reminder_dcd].redraw = wgui_cat033_dcd_redraw;
    g_wgui_cat033_reminder[wgui_cat033_reminder_dcd].deinit = wgui_cat033_dcd_deinit;
    g_wgui_cat033_reminder[wgui_cat033_reminder_dcd].x = 0;
    g_wgui_cat033_reminder[wgui_cat033_reminder_dcd].y = MMI_IDLE_DCD_START_Y;
    g_wgui_cat033_reminder[wgui_cat033_reminder_dcd].w = MAIN_LCD_DEVICE_WIDTH;
    g_wgui_cat033_reminder[wgui_cat033_reminder_dcd].h = MMI_IDLE_DCD_HEIGHT;
#if defined(__MMI_TOUCH_SCREEN__) 
    g_wgui_cat033_reminder[wgui_cat033_reminder_dcd].pen_event_handler = NULL;
#endif /* defined(__MMI_TOUCH_SCREEN__)  */

    g_wgui_cat033_reminder[wgui_cat033_reminder_dcd].data = &g_wgui_cat033_dcd_data;
    ptr = (wgui_cat033_dcd_data_struct*)(g_wgui_cat033_reminder[wgui_cat033_reminder_dcd].data);
    ptr->dcd_agent = agent;
}
#endif /* defined(__MMI_OP01_DCD__) */


#ifdef __MMI_IDLE_SCREEN_ICON_SHORTCUT__

typedef struct
{
    PU8* hint_array;
    PU8* pressed_icon_array;
    PU8* unpressed_icon_array;
    GUIIconbarItemCallback function_array;   /* icon_bar_item_callback will called when key/pen up */
    S32 number_of_item;        /* icon number */
} wgui_cat033_icon_shortcut_bar_data_struct;

static wgui_cat033_icon_shortcut_bar_data_struct g_wgui_cat033_icon_shortcut_bar_data = {0};

/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_icon_shortcut_bar_is_active
 * DESCRIPTION
 *  get if icon shortcut bar is active
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL wgui_cat033_icon_shortcut_bar_is_active(void)
{
	/*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_ICON_BAR_SUPPORT__ 	
    return (wgui_icon_bar_is_active());
#else
    return MMI_FALSE;
#endif
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_update_icon_shortcut_bar
 * DESCRIPTION
 *  update icon shorcut bar (callback function from icon bar component)
 * PARAMETERS
 *  start_index             [IN]       data start index
 *  number_of_items         [IN]       number of shorcut items 
 *  unpressed_icon_array    [IN/OUT]   unpressed icon array
 *  pressed_icon_array      [IN/OUT]   pressed icon array 
 *  hint_array              [IN/OUT]   hint array
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL wgui_cat033_icon_shortcut_bar_update(
                           U32 start_index, 
                           U32 number_of_items, 
                           U8** unpressed_icon_array,
                           U8** pressed_icon_array,
                           U8** content_icon_array,
                           U8** disabled_content_icon_array,
                           U8** hint_array)
{
	/*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 i = 0;    
    wgui_cat033_icon_shortcut_bar_data_struct* ptr = NULL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ptr = (wgui_cat033_icon_shortcut_bar_data_struct*)g_wgui_cat033_reminder[wgui_cat033_reminder_icon_shortcut_bar].data;
    
    for (i = 0; i < number_of_items; i++)
    {
        unpressed_icon_array[i] = (ptr->unpressed_icon_array)[i + start_index];
        pressed_icon_array[i] = (ptr->pressed_icon_array)[i + start_index];
        content_icon_array[i] = NULL;
        disabled_content_icon_array[i] = NULL;
        hint_array[i] = (ptr->hint_array)[i + start_index];
    }
    return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_icon_shortcut_bar_redraw
 * DESCRIPTION
 *  redraw icon shorcut bar in idle screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat033_icon_shortcut_bar_redraw(void)
{
	/*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_wgui_cat033_reminder[wgui_cat033_reminder_icon_shortcut_bar].state == cat33_reminder_area_state_show)
    {        
        wgui_icon_bar_show();
	}
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_icon_shortcut_bar_init
 * DESCRIPTION
 *  init icon shorcut bar in idle screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat033_icon_shortcut_bar_init(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x, y, w, h, count, i;
    wgui_cat033_icon_shortcut_bar_data_struct* ptr = NULL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_wgui_cat033_reminder[wgui_cat033_reminder_icon_shortcut_bar].state == cat33_reminder_area_state_deinit)
    {        
        ptr = (wgui_cat033_icon_shortcut_bar_data_struct*)g_wgui_cat033_reminder[wgui_cat033_reminder_icon_shortcut_bar].data;
    
        x = g_wgui_cat033_reminder[wgui_cat033_reminder_icon_shortcut_bar].x;
        y = g_wgui_cat033_reminder[wgui_cat033_reminder_icon_shortcut_bar].y;
        w = g_wgui_cat033_reminder[wgui_cat033_reminder_icon_shortcut_bar].w;
        h = g_wgui_cat033_reminder[wgui_cat033_reminder_icon_shortcut_bar].h;
        count = ptr->number_of_item;
        
        wgui_cat033_draw_region_with_background_color(x, y, x + w - 1, y + h - 1);
        wgui_icon_bar_create(x, y, w, h, count, MMI_FALSE, MMI_FALSE);
        wgui_icon_bar_move(x, y);
        wgui_icon_bar_resize(w, h);
        wgui_icon_bar_set_align(GUI_ICON_BAR_ALIGN_BY_CENTER);
        
        /* set items icon and hint */
        for (i = 0; i < count; i++)
        {
            wgui_icon_bar_set_item(
                    i,
                    (ptr->unpressed_icon_array)[i],
                    (ptr->pressed_icon_array)[i],
                    NULL,
                    NULL,
                    (ptr->hint_array)[i],
                    ptr->function_array);
        }
        
        /* set arrow icon */
        wgui_icon_bar_register_update_handler(wgui_cat033_icon_shortcut_bar_update);
        
        wgui_icon_bar_active();

        /* init successfully, set state */
        g_wgui_cat033_reminder[wgui_cat033_reminder_icon_shortcut_bar].state = cat33_reminder_area_state_init;
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_icon_shortcut_bar_deinit
 * DESCRIPTION
 *  deinit icon shorcut bar in idle screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat033_icon_shortcut_bar_deinit(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_wgui_cat033_reminder[wgui_cat033_reminder_icon_shortcut_bar].state != cat33_reminder_area_state_deinit)
    {
        wgui_icon_bar_close();
        
        /* set state */
        g_wgui_cat033_reminder[wgui_cat033_reminder_icon_shortcut_bar].state = cat33_reminder_area_state_deinit;
    }     
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_icon_shortcut_bar_show
 * DESCRIPTION
 *  show icon shorcut bar in idle screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat033_icon_shortcut_bar_show(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    GDI_HANDLE wallpaper_layer;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_wgui_cat033_reminder[wgui_cat033_reminder_icon_shortcut_bar].state == cat33_reminder_area_state_init)
    {
        wallpaper_layer = dm_get_wallpaper_layer();
        wgui_icon_bar_set_abm_layer(wallpaper_layer);    
        wgui_icon_bar_show();

        /* set state */
        g_wgui_cat033_reminder[wgui_cat033_reminder_icon_shortcut_bar].state = cat33_reminder_area_state_show;
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_icon_shortcut_bar_set_history
 * DESCRIPTION
 *  set icon shorcut bar history
 * PARAMETERS
 *  history_buffer       [IN]   history buffer
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat033_icon_shortcut_bar_set_history(void* history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_icon_bar_set_history((wgui_icon_bar_history_struct*)history_buffer);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_icon_shortcut_get_history
 * DESCRIPTION
 *  get icon shorcut bar history
 * PARAMETERS
 *  history_buffer       [IN]   history buffer
 * RETURNS
 *  U8*
 *****************************************************************************/
U8* wgui_cat033_icon_shortcut_bar_get_history(void* history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_icon_bar_get_history((wgui_icon_bar_history_struct*) history_buffer);
    return history_buffer;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_enable_icon_shortcut_bar_display
 * DESCRIPTION
 *  enalbe icon shortcut bar display in idle screen
 * PARAMETERS
 *  number_of_item       [IN]   number of shortcut item
 *  function_array       [IN]   shortcut item function
 *  hint_array           [IN]   hint of shortcut item
 *  pressed_icon_array   [IN]   pressed shorcut item icon array
 *  unpressed_icon_array [IN]   unpressed shorcut item icon array
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat033_enable_icon_shortcut_bar_display(
              S32 number_of_item, 
              GUIIconbarItemCallback function_array, 
              PU8* hint_array, 
              PU8* pressed_icon_array, 
              PU8* unpressed_icon_array)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_cat033_icon_shortcut_bar_data_struct* ptr = NULL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_wgui_cat033_reminder[wgui_cat033_reminder_icon_shortcut_bar].init = wgui_cat033_icon_shortcut_bar_init;
    g_wgui_cat033_reminder[wgui_cat033_reminder_icon_shortcut_bar].show = wgui_cat033_icon_shortcut_bar_show;
    g_wgui_cat033_reminder[wgui_cat033_reminder_icon_shortcut_bar].redraw = wgui_cat033_icon_shortcut_bar_redraw;
    g_wgui_cat033_reminder[wgui_cat033_reminder_icon_shortcut_bar].deinit = wgui_cat033_icon_shortcut_bar_deinit;
#ifdef __MMI_ICON_BAR_SUPPORT__ 	
    g_wgui_cat033_reminder[wgui_cat033_reminder_icon_shortcut_bar].get_history_size_function = wgui_icon_bar_get_history_size;
#else 
	g_wgui_cat033_reminder[wgui_cat033_reminder_icon_shortcut_bar].get_history_size_function = 0;  
#endif
    g_wgui_cat033_reminder[wgui_cat033_reminder_icon_shortcut_bar].get_history_function = wgui_cat033_icon_shortcut_bar_get_history;
    g_wgui_cat033_reminder[wgui_cat033_reminder_icon_shortcut_bar].set_history_function = wgui_cat033_icon_shortcut_bar_set_history;
    g_wgui_cat033_reminder[wgui_cat033_reminder_icon_shortcut_bar].x = 0;
    g_wgui_cat033_reminder[wgui_cat033_reminder_icon_shortcut_bar].y = UI_device_height - MMI_BUTTON_BAR_HEIGHT - WGUI_IDLE_SCREEN_ICON_SHORTCUT_HEIGHT;
    g_wgui_cat033_reminder[wgui_cat033_reminder_icon_shortcut_bar].w = UI_device_width;
    g_wgui_cat033_reminder[wgui_cat033_reminder_icon_shortcut_bar].h = WGUI_IDLE_SCREEN_ICON_SHORTCUT_HEIGHT;
#if defined(__MMI_TOUCH_SCREEN__) 
#ifdef __MMI_ICON_BAR_SUPPORT__
    g_wgui_cat033_reminder[wgui_cat033_reminder_icon_shortcut_bar].pen_event_handler = wgui_icon_bar_translate_pen_event;
#endif /*__MMI_ICON_BAR_SUPPORT__*/
#endif /* defined(__MMI_TOUCH_SCREEN__)  */

    g_wgui_cat033_reminder[wgui_cat033_reminder_icon_shortcut_bar].data = &g_wgui_cat033_icon_shortcut_bar_data;

    ptr = (wgui_cat033_icon_shortcut_bar_data_struct*)(g_wgui_cat033_reminder[wgui_cat033_reminder_icon_shortcut_bar].data);
    ptr->function_array = function_array;
    ptr->number_of_item = number_of_item;
    ptr->hint_array = hint_array;
    ptr->pressed_icon_array = pressed_icon_array;
    ptr->unpressed_icon_array = unpressed_icon_array;
}
#endif /* __MMI_IDLE_SCREEN_ICON_SHORTCUT__ */


/*****************************************************************************
 * FUNCTION
 *  dummy_dt_hide_function
 * DESCRIPTION
 *  dummy func of hide date
 * PARAMETERS
 *  x1      [IN]        Start x position
 *  y1      [IN]        Start y position
 *  x2      [IN]        End x position
 *  y2      [IN]        End y position
 * RETURNS
 *  void
 *****************************************************************************/
void dummy_dt_hide_function(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(x1);
    UI_UNUSED_PARAMETER(y1);
    UI_UNUSED_PARAMETER(x2);
    UI_UNUSED_PARAMETER(y2);
}


/*****************************************************************************
 * FUNCTION
 *  cat33_analog_clock_hide_dt_display
 * DESCRIPTION
 *  hide function of date display of analog clock
 * PARAMETERS
 *  x1      [IN]        Start x position
 *  y1      [IN]        Start y position
 *  x2      [IN]        End x position
 *  y2      [IN]        End y position
 * RETURNS
 *  void
 *****************************************************************************/
void cat33_analog_clock_hide_dt_display(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#ifndef __GDI_MEMORY_PROFILE_2__
    PU8 idle_screen_wallpaper = get_image(idle_screen_wallpaper_ID);
#endif 

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    x1 = 0;
    x2 = UI_device_width - 1;

#ifdef __MMI_UI_STATUS_BAR_AT_BOTTOM__
    /* for proper display of the status bar at analog clock */
    if (is_on_idlescreen())
    {
        y1 = 0;
        y2 = (UI_device_height - 1 - MMI_button_bar_height - MMI_status_bar_height - 4);
    }
    else
#endif /* __MMI_UI_STATUS_BAR_AT_BOTTOM__ */
    {
    #if defined(__MMI_OP01_DCD__) 
        if (!(MMI_TRUE == mmi_dcd_is_switch_on() && MMI_TRUE == mmi_dcd_is_idle_on()))
        {
    #endif    
        y1 = MMI_status_bar_height + MMI_STATUS_BAR_IDLE_Y;
        y2 = UI_device_height - MMI_button_bar_height - 1;
    #if defined(__MMI_OP01_DCD__) 
        }
    #endif     
    }

    gdi_layer_set_clip(x1, y1, x2, y2);
#ifdef __GDI_MEMORY_PROFILE_2__
    gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_TRANSPARENT); 
#else /* __GDI_MEMORY_PROFILE_2__ */ 
    if (idle_screen_wallpaper_ID == 0)
    {
        ASSERT(idle_screen_wallpaper_ID == 0);  /* analog clock idle screen should predefined image */
        gdi_image_draw_file(cat33_image_x, cat33_image_y, idle_screen_wallpaper_name);
    }
    else
    {
        if (cat33_n_frames > 1)
        {
            gui_show_animated_image_frame(
                cat33_image_x,
                cat33_image_y,
                idle_screen_wallpaper,
                (S16) cat33_frame_number);
        }
        else
        {
            if (mmi_phnset_check_themeid_wallpaper(idle_screen_wallpaper_ID))
            {
                gui_draw_filled_area(0, 0, UI_device_width, UI_device_height, current_MMI_theme->idle_bkg_filler);
            }
            else
            {
                gui_show_image(cat33_image_x, cat33_image_y, idle_screen_wallpaper);
            }
        }
    }
#endif /* __GDI_MEMORY_PROFILE_2__ */ 
#ifdef WGUI_STATUS_ICON_SHOW_V_BAR
    wgui_status_icon_bar_redraw(WGUI_STATUS_ICON_BAR_V_BAR);
#endif
    idle_screen_show_network_details();
}


/*****************************************************************************
 * FUNCTION
 *  cat33_digital_clock_hide_dt_display
 * DESCRIPTION
 *  hide function of date display of digital  clock
 * PARAMETERS
 *  x1      [IN]        Start x position
 *  y1      [IN]        Start y position
 *  x2      [IN]        End x position
 *  y2      [IN]        End y position
 * RETURNS
 *  void
 *****************************************************************************/
/* Assumes that the wallpaper displayed behind the digital clock is always full screen */
void cat33_digital_clock_hide_dt_display(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#ifndef __GDI_MEMORY_PROFILE_2__
    PU8 idle_screen_wallpaper = get_image(idle_screen_wallpaper_ID);
#endif 

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* To retain passing coordinates to the clip window */
    x1 = 0;
    x2 = UI_device_width - 1;

#ifdef __MMI_UI_STATUS_BAR_AT_BOTTOM__
    /* for proper display of the status bar at digital clock */
    if (is_on_idlescreen())
    {
        y1 = 0;
        y2 = (UI_device_height - 1 - MMI_button_bar_height - MMI_status_bar_height - 4);
    }
    else
#endif /* __MMI_UI_STATUS_BAR_AT_BOTTOM__ */ 
    {
    #if defined(__MMI_OP01_DCD__) 
        if (!(MMI_TRUE == mmi_dcd_is_switch_on() && MMI_TRUE == mmi_dcd_is_idle_on()))
        {
    #endif     
        y1 = MMI_status_bar_height + MMI_STATUS_BAR_IDLE_Y;
        /* change for idlescreen shortcuts as their height is greater
           than MMI_button_bar_height */
#ifdef __MMI_TOUCH_IDLESCREEN_SHORTCUTS__
        y2 = UI_device_height - wgui_cat033_get_shortcut_max_height() - 1;
#else 
        y2 = UI_device_height - MMI_button_bar_height - 1;
#endif /* __MMI_TOUCH_IDLESCREEN_SHORTCUTS__ */
    #if defined(__MMI_OP01_DCD__) 
        }
    #endif 
    }

    gdi_layer_push_clip();
    gdi_layer_set_clip(x1, y1, x2, y2);

#ifdef __GDI_MEMORY_PROFILE_2__
    gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_TRANSPARENT);
#else /* __GDI_MEMORY_PROFILE_2__ */  
    draw_wallpaper();
#endif /* __GDI_MEMORY_PROFILE_2__ */ 
#ifdef WGUI_STATUS_ICON_SHOW_V_BAR
    wgui_status_icon_bar_redraw(WGUI_STATUS_ICON_BAR_V_BAR);
#endif
    gdi_layer_pop_clip();

    idle_screen_show_network_details();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_hide_time_display
 * DESCRIPTION
 *  hide function of time display of analog/digital  clock
 * PARAMETERS
 *  x1      [IN]        Start x position
 *  y1      [IN]        Start y position
 *  x2      [IN]        End x position
 *  y2      [IN]        End y position
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat033_hide_time_display(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_push_clip();
    gdi_layer_set_clip(0, y1, MAIN_LCD_device_width - 1, y2);
    wgui_cat033_draw_region_with_wallpaper(x1, y1, x2, y2);
    #ifdef WGUI_STATUS_ICON_SHOW_V_BAR
        wgui_status_icon_bar_redraw(WGUI_STATUS_ICON_BAR_V_BAR); /* redraw horizontal status bar */
    #endif
    gdi_layer_pop_clip();
}


/*****************************************************************************
 * FUNCTION
 *  idle_screen_hide_status_icons_bar0
 * DESCRIPTION
 *  hide function of stats icon horizontal bar of idle screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void idle_screen_hide_status_icons_bar0(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x1, y1, x2, y2;
#ifndef __MMI_IDLE_FULL_SCREEN__
    UI_filled_area *f = current_MMI_theme->status_icon_bar_filler;
#endif 

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_push_clip();
    wgui_status_icon_bar_get_clip(WGUI_STATUS_ICON_BAR_H_BAR, &x1, &y1, &x2, &y2);
    gdi_layer_set_clip(x1, y1, x2, y2);
#ifdef __MMI_IDLE_FULL_SCREEN__
    #ifdef __GDI_MEMORY_PROFILE_2__
#ifdef __MMI_MAINLCD_96X64__
    gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_BLACK); 
#else
    gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_TRANSPARENT); 
#endif
    #else /* __GDI_MEMORY_PROFILE_2__ */ 
        draw_wallpaper();
    #endif /* __GDI_MEMORY_PROFILE_2__ */ 
#else /* __MMI_IDLE_FULL_SCREEN__ */ 
    gui_draw_filled_area(x1, y1, x2 -x1 + 1, y2 - y1 + 1, f);
#endif /* __MMI_IDLE_FULL_SCREEN__ */ 
    gdi_layer_pop_clip();
}

#ifdef WGUI_STATUS_ICON_SHOW_V_BAR
/*****************************************************************************
 * FUNCTION
 *  idle_screen_hide_status_icons_bar1
 * DESCRIPTION
 *  hide function of stats icon vertical  bar of idle screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void idle_screen_hide_status_icons_bar1(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x1, y1, x2, y2;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_status_icon_bar_get_clip(WGUI_STATUS_ICON_BAR_V_BAR, &x1, &y1, &x2, &y2);
#ifdef __MMI_UI_STATUS_BAR_AT_BOTTOM__
//    y1 = y1 + 4;    /* To restrict the clip area below from the time date area lines. */
#endif /* __MMI_UI_STATUS_BAR_AT_BOTTOM__ */

    wgui_cat033_draw_region_with_background_color(x1, y1, x2, y2);
}
#endif

/*****************************************************************************
 * FUNCTION
 *  SetIdleScreenWallpaper
 * DESCRIPTION
 *  Sets the Image to be used by the idle screen
 * PARAMETERS
 *  image_ID        [IN]        wallpaper image ID
 * RETURNS
 *  void
 *****************************************************************************/
void SetIdleScreenWallpaper(U16 image_ID)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    PU8 idle_screen_wallpaper;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifndef __MMI_UI_TECHNO_IDLESCREEN_BAR__    
#ifdef __MMI_ANALOG_CLOCK__
    if ((image_ID == IMG_ID_DISPCHAR_ANALOG_CLK))
    {
        idle_screen_type = ANALOG_IDLE_SCREEN;
        idle_screen_wallpaper_ID = IMG_ID_DISPCHAR_ANALOG_CLK;
    }
    else
#endif /* __MMI_ANALOG_CLOCK__ */ 

#ifdef __MMI_DIGITAL_CLOCK__
    if ((image_ID == IMG_ID_DISPCHAR_DIGITAL_CLK))
    {
        idle_screen_wallpaper_ID = IMG_ID_DISPCHAR_DIGITAL_CLK;
        idle_screen_type = DIGITAL_IDLE_SCREEN;
    }
    else
#endif /* __MMI_DIGITAL_CLOCK__ */ 
#endif /* !__MMI_UI_TECHNO_IDLESCREEN_BAR__ */
    {
        idle_screen_type = NORMAL_IDLE_SCREEN;
        idle_screen_wallpaper_ID = image_ID;
    }
    idle_screen_wallpaper = get_image(idle_screen_wallpaper_ID);
    gui_measure_image(idle_screen_wallpaper, &cat33_image_width, &cat33_image_height);
    cat33_n_frames = gui_image_n_frames(idle_screen_wallpaper);
    cat33_image_x = (UI_device_width - cat33_image_width) >> 1;
    cat33_image_y = (UI_device_height - cat33_image_height) >> 1;
}


/*****************************************************************************
 * FUNCTION
 *  SetIdleScreenNetworkName
 * DESCRIPTION
 *  Sets the network name to be displayed by the idle screen
 * PARAMETERS
 *  s       [IN]     network name string
 * RETURNS
 *  void
 *****************************************************************************/
void SetIdleScreenNetworkName(U8 *s)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	
    idle_screen_network_name = (UI_string_type) s;
}


/*****************************************************************************
 * FUNCTION
 *  SetIdleScreenNetworkStatus
 * DESCRIPTION
 *  Sets the network status to be displayed by the idle screen
 * PARAMETERS
 *  s       [IN]     status string
 * RETURNS
 *  void
 *****************************************************************************/
void SetIdleScreenNetworkStatus(U8 *s)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	
    idle_screen_network_status = (UI_string_type) s;
}


#if defined(__MMI_DUAL_SIM_MASTER__)||defined(__KJX_FUN__)	//xb add 2017-07-18
/*****************************************************************************
 * FUNCTION
 *  SetIdleScreenSlaveNetworkName
 * DESCRIPTION
 *  This function sets the slave network name.
 * PARAMETERS
 *  s               : [IN]              Network name
 * RETURNS
 *  void
 *****************************************************************************/
void SetIdleScreenSlaveNetworkName(U8 *s)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_slave_idle_screen_line1text = (UI_string_type) s;
}

/*****************************************************************************
 * FUNCTION
 *  SetIdleScreenSlaveNetworkStatus
 * DESCRIPTION
 *  This function sets the slave network status.
 * PARAMETERS
 *  s               : [IN]              Network status
 * RETURNS
 *  void
 *****************************************************************************/
void SetIdleScreenSlaveNetworkStatus(U8 *s)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_slave_idle_screen_line2text = (UI_string_type) s;
}
#endif /* defined(__MMI_DUAL_SIM_MASTER__) */


/*****************************************************************************
 * FUNCTION
 *  cat33_animation_processor
 * DESCRIPTION
 *  a function which shows frames of animated wallpaper
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void cat33_animation_processor(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    PU8 idle_screen_wallpaper = get_image(idle_screen_wallpaper_ID);

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    cat33_frame_number++;
    if (cat33_frame_number >= cat33_n_frames)
    {
        cat33_frame_number = 0;
    }
    gui_start_timer(cat33_animation_delay, cat33_animation_processor);

    gui_lock_double_buffer();

#ifndef __MMI_IDLE_FULL_SCREEN__
    gui_set_clip(0, MMI_status_bar_height, UI_device_width - 1, UI_device_height - MMI_button_bar_height);
#else /* __MMI_IDLE_FULL_SCREEN__ */ 
    gui_reset_clip();
#endif /* __MMI_IDLE_FULL_SCREEN__ */ 
    gui_draw_filled_area(0, 0, UI_device_width - 1, UI_device_height - 1, current_MMI_theme->general_background_filler);
    gui_show_animated_image_frame(cat33_image_x, cat33_image_y, idle_screen_wallpaper, (S16) cat33_frame_number);

#ifdef __MMI_UI_TECHNO_IDLESCREEN_BAR__
    if (PhnsetGetShowDateTimeStatus() == MMI_TRUE)
    {
        gui_show_image(0, MMI_status_bar_height, get_image(idlescreen_bar_id));//070306 Alpha layer
    }
#endif /* __MMI_UI_TECHNO_IDLESCREEN_BAR__ */ 
    show_main_LCD_dt_display();
#ifdef __MMI_IDLE_FULL_SCREEN__
    wgui_status_icon_bar_redraw(WGUI_STATUS_ICON_BAR_H_BAR);
#endif 
#ifdef WGUI_STATUS_ICON_SHOW_V_BAR
    wgui_status_icon_bar_redraw(WGUI_STATUS_ICON_BAR_V_BAR);
#endif
    idle_screen_show_network_details();

#ifdef __MMI_IDLE_FULL_SCREEN__
    if (cat33_image_height < UI_device_height)
    {
        show_softkey_background();
    }
    show_left_softkey();
    show_right_softkey();
#endif /* __MMI_IDLE_FULL_SCREEN__ */ 

    gui_unlock_double_buffer();
    gui_BLT_double_buffer(0, 0, UI_device_width - 1, UI_device_height - 1);
}


#ifdef __MMI_WALLPAPER_ON_BOTTOM__
/*****************************************************************************
 * FUNCTION
 *  wgui_set_wallpaper_change
 * DESCRIPTION
 *  Sets the Image to be used by the idle screen using ID
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_set_wallpaper_change(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
   // gIsWallpaperChange = 1;
}


/*****************************************************************************
 * FUNCTION
 *  SetListWallpaperID
 * DESCRIPTION
 *  set list wallpaper ID
 * PARAMETERS
 *  image_ID        [IN]        wallpaper ID
 * RETURNS
 *  void
 *****************************************************************************/
void SetListWallpaperID(U16 image_ID)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    PU8 idle_screen_wallpaper;
    S32 disp_height = UI_device_height, disp_width = UI_device_width;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    idle_screen_type = NORMAL_IDLE_SCREEN;
    idle_screen_wallpaper_ID = image_ID;
    
    idle_screen_wallpaper = get_image(idle_screen_wallpaper_ID);
    cat33_n_frames = gui_image_n_frames(idle_screen_wallpaper);
    gdi_image_get_dimension(idle_screen_wallpaper, &cat33_image_width, &cat33_image_height);
    cat33_image_x = (disp_width - cat33_image_width) >> 1;
    cat33_image_y = (disp_height - cat33_image_height) >> 1;
    
    idle_screen_cache_id = idle_screen_wallpaper_ID;
    idle_screen_cache_name = NULL;
}
#endif /* __MMI_WALLPAPER_ON_BOTTOM__ */ 


/*****************************************************************************
 * FUNCTION
 *  SetIdleScreenWallpaperID
 * DESCRIPTION
 *  set Idle screen wall paper ID
 * PARAMETERS
 *  image_ID        [IN]        wallpaper ID
 *  is_default      [IN]        Save the layer of wallpaper as fast format
 * RETURNS
 *  void
 *****************************************************************************/
void SetIdleScreenWallpaperID(U16 image_ID, MMI_BOOL is_default)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    PU8 idle_screen_wallpaper;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(is_default);

#ifdef __MMI_RESOURCE_ENFB_SUPPORT__ 
    if (idle_screen_wallpaper_ID != 0 && !mmi_phnset_check_themeid_wallpaper(idle_screen_wallpaper_ID))
    {
        mmi_frm_resmem_dereg_retain((U16)idle_screen_wallpaper_ID);
    }
#endif /* __MMI_RESOURCE_ENFB_SUPPORT__ */ 

#ifndef __MMI_UI_TECHNO_IDLESCREEN_BAR__
#ifdef __MMI_ANALOG_CLOCK__
    if ((image_ID == IMG_ID_DISPCHAR_ANALOG_CLK))
    {
        idle_screen_type = ANALOG_IDLE_SCREEN;
        /* __CUSTPACK_MULTIBIN Calvin BEGIN */
        idle_screen_wallpaper_ID = IMG_ID_DISPCHAR_ANALOG_CLK;
        /* __CUSTPACK_MULTIBIN Calvin END */
    }
    else
#endif /* __MMI_ANALOG_CLOCK__ */ 
#ifdef __MMI_DIGITAL_CLOCK__
    if ((image_ID == IMG_ID_DISPCHAR_DIGITAL_CLK))
    {
        idle_screen_wallpaper_ID = IMG_ID_DISPCHAR_DIGITAL_CLK;
        idle_screen_type = DIGITAL_IDLE_SCREEN;
    }
    else
#endif /* __MMI_DIGITAL_CLOCK__ */ 
#endif /* __MMI_UI_TECHNO_IDLESCREEN_BAR__ */
    {
        idle_screen_type = NORMAL_IDLE_SCREEN;
        idle_screen_wallpaper_ID = image_ID;
    }
    
    if (mmi_phnset_check_themeid_wallpaper(idle_screen_wallpaper_ID))
    {
        cat33_n_frames = 1;
        cat33_image_width = MAIN_LCD_DEVICE_WIDTH;
        cat33_image_height = MAIN_LCD_DEVICE_HEIGHT;
        cat33_image_x = 0;
        cat33_image_y = 0;
    }
    else
    {
#ifdef __MMI_RESOURCE_ENFB_SUPPORT__ 
        mmi_frm_resmem_reg_retain((U16)idle_screen_wallpaper_ID);
#endif
        
        idle_screen_wallpaper = get_image(idle_screen_wallpaper_ID);
        gdi_image_get_dimension(idle_screen_wallpaper, &cat33_image_width, &cat33_image_height);
        gdi_image_get_frame_count_id(idle_screen_wallpaper_ID, &cat33_n_frames);
        cat33_image_x = (UI_device_width - cat33_image_width) >> 1;
        cat33_image_y = (UI_device_height - cat33_image_height) >> 1;
    }

    #ifdef __MMI_WALLPAPER_ON_BOTTOM__
        idle_screen_cache_id = idle_screen_wallpaper_ID;
        idle_screen_cache_name = NULL;
    #endif /* __MMI_WALLPAPER_ON_BOTTOM__ */ 
}


/*****************************************************************************
 * FUNCTION
 *  SetIdleScreenWallpaperName
 * DESCRIPTION
 *  set idle screen wallpaper name
 * PARAMETERS
 *  name        [IN]        image file name
 * RETURNS
 *  void
 *****************************************************************************/
void SetIdleScreenWallpaperName(UI_string_type name)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 disp_height = UI_device_height, disp_width = UI_device_width;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_RESOURCE_ENFB_SUPPORT__ 
    if (idle_screen_wallpaper_ID != 0)
    {
        mmi_frm_resmem_dereg_retain((U16)idle_screen_wallpaper_ID);
    }
#endif /* __MMI_RESOURCE_ENFB_SUPPORT__ */ 
    idle_screen_wallpaper_ID = 0;
    idle_screen_type = NORMAL_IDLE_SCREEN;

#ifndef __MMI_IDLE_FULL_SCREEN__
    disp_height = UI_device_height - MMI_status_bar_height - MMI_button_bar_height;
    disp_width = UI_device_width - 1;
#endif /* __MMI_IDLE_FULL_SCREEN__ */ 

    gdi_image_get_dimension_file((CHAR*) name, &cat33_image_width, &cat33_image_height);
    cat33_image_x = (disp_width - cat33_image_width) >> 1;
    cat33_image_y = (disp_height - cat33_image_height) >> 1;

    gdi_image_get_frame_count_file((U8 *)name, &cat33_n_frames);

    mmi_ucs2cpy(idle_screen_wallpaper_name_original, (CHAR*) name);
    idle_screen_wallpaper_name = idle_screen_wallpaper_name_original;

}


#ifdef __DRM_SUPPORT__
/*****************************************************************************
 * FUNCTION
 *  mmi_scrsvr_drm_callback
 * DESCRIPTION
 *  Screen saver DRM consume callback
 * PARAMETERS
 *  point       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_wallpaper_drm_callback(S32 res, S32 id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    DRM_stop_consume(consumer);
    PhnsetWallpaperBadFileCallBack(0);
}
#endif /* __DRM_SUPPORT__ */

#ifdef __MMI_LAUNCHER_APP_LIST_VIDEO_WALLPAPER__
extern S32 is_vlw_file;
#endif

#ifdef __MMI_LAUNCHER_APP_LIST_INTERACTIVE_VIDEO_WALLPAPER__
extern S32 is_ivlw_file;
#endif

/*****************************************************************************
 * FUNCTION
 *  draw_wallpaper
 * DESCRIPTION
 *  Redraws the Idle screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void draw_wallpaper(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_ID_TYPE wallpaper_ID = idle_screen_wallpaper_ID;
    
    PU8 idle_screen_wallpaper = get_image(idle_screen_wallpaper_ID);

    /* Robin 1208 Display user define wallpaper */
    S32 disp_height = UI_device_height, disp_width = UI_device_width;

    GDI_RESULT ret = GDI_SUCCEED;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

#ifdef __MMI_LAUNCHER_APP_LIST_VIDEO_WALLPAPER__
    if(is_vlw_file == 1)
    {
        wallpaper_ID = IMG_ID_PHNSET_WP_START;
        idle_screen_wallpaper = get_image(wallpaper_ID);
    }
#endif

#ifdef __MMI_LAUNCHER_APP_LIST_INTERACTIVE_VIDEO_WALLPAPER__
    if(is_ivlw_file == 1)
    {
        wallpaper_ID = IMG_ID_PHNSET_WP_START;
        idle_screen_wallpaper = get_image(wallpaper_ID);
    }
#endif


#if defined(ENABLE_ANIMATED_WALLPAPERS) && defined(__GDI_MEMORY_PROFILE_2__)
    if (animation_handle != GDI_ERROR_HANDLE)
    {
        gdi_image_stop_animation(animation_handle);
        animation_handle = GDI_ERROR_HANDLE;
    }
#endif /* defined(ENABLE_ANIMATED_WALLPAPERS) && defined(__GDI_MEMORY_PROFILE_2__) */ 

#if defined(__MMI_OP12_CAT533_SUPPORT__)
    /* draw specific color designed by artist: RGB: 154,185,187 */
    gdi_draw_solid_rect(0, 0, UI_device_width - 1, UI_device_height - 1, gdi_act_color_from_rgb(255, 154, 185, 187));
#else
    gui_draw_filled_area(0, 0, UI_device_width - 1, UI_device_height - 1, current_MMI_theme->general_background_filler);
#endif /* defined(__MMI_OP12_CAT533_SUPPORT__) */

#ifndef __MMI_DM_BW_WITHOUT_WALLPAPER__
#ifndef __MMI_IDLE_FULL_SCREEN__
    /* Robin 1208 Display user define wallpaper */
    disp_height = UI_device_height - MMI_status_bar_height - MMI_button_bar_height;
    disp_width = UI_device_width - 1;
    gui_set_clip(0, MMI_status_bar_height, UI_device_width - 1, UI_device_height - MMI_button_bar_height);
#endif /* __MMI_IDLE_FULL_SCREEN__ */ 
    if (wallpaper_ID != 0)  /* image comes from resource */
    {
        gdi_image_get_dimension(idle_screen_wallpaper, &cat33_image_width, &cat33_image_height);
        cat33_image_x = (UI_device_width - cat33_image_width) >> 1;
        cat33_image_y = (UI_device_height - cat33_image_height) >> 1;  
        if (cat33_n_frames > 1)
#if defined(ENABLE_ANIMATED_WALLPAPERS) && defined(__GDI_MEMORY_PROFILE_2__)
            gdi_image_draw_animation_frames(
            cat33_image_x,
            cat33_image_y,
            idle_screen_wallpaper,
            &animation_handle,
            (S16) cat33_frame_number);
#else /* defined(ENABLE_ANIMATED_WALLPAPERS) && defined(__GDI_MEMORY_PROFILE_2__) */ 
        {
            gdi_image_draw_animation_single_frame(
                cat33_image_x,
                cat33_image_y,
                idle_screen_wallpaper,
                (S16) cat33_frame_number);
            cat33_animation_delay = gdi_image_get_animation_delay();
        }
#endif /* defined(ENABLE_ANIMATED_WALLPAPERS) && defined(__GDI_MEMORY_PROFILE_2__) */ 
        else
        {
            if (mmi_phnset_check_themeid_wallpaper(wallpaper_ID))
            {
                gui_draw_filled_area(0, 0, UI_device_width, UI_device_height, current_MMI_theme->idle_bkg_filler);
            }
            else
            {
                gdi_image_draw(cat33_image_x, cat33_image_y, idle_screen_wallpaper);
                
            }
        }
    }
    else
    {
        /* 102406 DRM check Start */
        FS_HANDLE handle = 0;
        kal_bool is_allowed = KAL_TRUE;

        if (idle_screen_wallpaper_name_original == NULL)
        {
            ret = GDI_IMAGE_ERR_INVALID_FILE;
        }
        else
        {
            handle = DRM_open_file((PU16) idle_screen_wallpaper_name_original, FS_READ_ONLY, DRM_PERMISSION_DISPLAY);
            if (handle >= FS_NO_ERROR)
            {
            #ifdef __DRM_SUPPORT__
                if (DRM_validate_forward_rule(handle, DRM_PERMISSION_DISPLAY))
                {
                    consumer = DRM_consume_rights(handle, DRM_PERMISSION_DISPLAY, mmi_wallpaper_drm_callback);
                    is_allowed = KAL_TRUE;
                }
                else
                {
                    is_allowed = KAL_FALSE;
                    ret = GDI_IMAGE_ERR_INVALID_FILE;
                }
            #endif /* __DRM_SUPPORT__ */ 

                DRM_close_file(handle);
            }
            else
            {
                ret = GDI_IMAGE_ERR_INVALID_FILE;
            }
            
         }
        
        if (ret != GDI_IMAGE_ERR_INVALID_FILE)
        {
            S32 offset_x = 0;
            S32 offset_y = 0;

            gdi_image_get_dimension_file(idle_screen_wallpaper_name, &cat33_image_width, &cat33_image_height);
            cat33_image_x = (disp_width - cat33_image_width) >> 1;
            cat33_image_y = (disp_height - cat33_image_height) >> 1;

            if ((disp_width >= cat33_image_width) && (disp_height >= cat33_image_height))       /* image can be displayed entirely */
            {
                /* align preview window at the center of screen */
                offset_x = (disp_width - cat33_image_width) >> 1;
                offset_y = (disp_height - cat33_image_height) >> 1;

            #if defined(ENABLE_ANIMATED_WALLPAPERS) && defined(__GDI_MEMORY_PROFILE_2__)
                ret = gdi_image_draw_animation_file(
                        offset_x,
                        offset_y,
                        (CHAR *) idle_screen_wallpaper_name,
                        &animation_handle);
            #else /* defined(ENABLE_ANIMATED_WALLPAPERS) && defined(__GDI_MEMORY_PROFILE_2__) */ 
                ret = gdi_image_draw_file(offset_x, offset_y, (CHAR *) idle_screen_wallpaper_name);
            #endif /* defined(ENABLE_ANIMATED_WALLPAPERS) && defined(__GDI_MEMORY_PROFILE_2__) */ 
            }
            else    /* image is larger than screen size */
            {
                S32 resized_offset_x;
                S32 resized_offset_y;
                S32 resized_width;
                S32 resized_height;

                gdi_image_util_fit_bbox(
                    disp_width,
                    disp_height,
                    cat33_image_width,
                    cat33_image_height,
                    &resized_offset_x,
                    &resized_offset_y,
                    &resized_width,
                    &resized_height);

                /* for images of other formats, try to set center alignment */
            #if defined(ENABLE_ANIMATED_WALLPAPERS) && defined(__GDI_MEMORY_PROFILE_2__)
                ret = gdi_image_draw_animation_resized_file(
                        resized_offset_x,
                        resized_offset_y,
                        resized_width,
                        resized_height,
                        (CHAR *) idle_screen_wallpaper_name,
                        &animation_handle);
                /* ret = gdi_image_draw_resized_file(resized_offset_x, resized_offset_y, resized_width, resized_height, (PS8)idle_screen_wallpaper_name); */
            #else /* defined(ENABLE_ANIMATED_WALLPAPERS) && defined(__GDI_MEMORY_PROFILE_2__) */ 
                ret = gdi_image_draw_resized_file(
                        resized_offset_x,
                        resized_offset_y,
                        resized_width,
                        resized_height,
                        (CHAR *) idle_screen_wallpaper_name);
            #endif /* defined(ENABLE_ANIMATED_WALLPAPERS) && defined(__GDI_MEMORY_PROFILE_2__) */ 
            }
        }

        if (ret < 0 && ret != GDI_GIF_ERR_OUT_OF_CLIP_REGION && ret != GDI_BMP_ERR_OUT_OF_CLIP_REGION)
        {
            if (is_allowed)
                PhnsetWallpaperBadFileCallBack(0);
            else
                PhnsetWallpaperBadFileCallBack(STR_GLOBAL_DRM_PROHIBITED);
            
            idle_screen_wallpaper = get_image(idle_screen_wallpaper_ID);
            cat33_n_frames = gui_image_n_frames(idle_screen_wallpaper);
            gdi_image_get_dimension(idle_screen_wallpaper, &cat33_image_width, &cat33_image_height);
            cat33_image_x = (disp_width - cat33_image_width) >> 1;
            cat33_image_y = (disp_height - cat33_image_height) >> 1;
            if (cat33_n_frames > 1)
        #if defined(ENABLE_ANIMATED_WALLPAPERS) && defined(__GDI_MEMORY_PROFILE_2__)
                gdi_image_draw_animation_frames(
                    cat33_image_x,
                    cat33_image_y,
                    idle_screen_wallpaper,
                    &animation_handle,
                    (S16) cat33_frame_number);
        #else /* defined(ENABLE_ANIMATED_WALLPAPERS) && defined(__GDI_MEMORY_PROFILE_2__) */ 
                gdi_image_draw_animation_single_frame(
                    cat33_image_x,
                    cat33_image_y,
                    idle_screen_wallpaper,
                    (S16) cat33_frame_number);
        #endif /* defined(ENABLE_ANIMATED_WALLPAPERS) && defined(__GDI_MEMORY_PROFILE_2__) */ 
            else
            {
                gdi_image_draw(cat33_image_x, cat33_image_y, idle_screen_wallpaper);
            }
        }
    }
    #endif
}


#if defined(__MMI_TOUCH_IDLESCREEN_SHORTCUTS__)
#define WGUI_CAT033_MAX_SHORTCUTS_NUM   4

typedef struct
{
    S32 x;
    S32 y;
    S32 width;
    S32 height;
    MMI_BOOL is_pressed;
    FuncPtr entryfn;
} wgui_cat033_shortcut_struct;

static wgui_cat033_shortcut_struct g_wgui_cat033_shortcut[WGUI_CAT033_MAX_SHORTCUTS_NUM];
static S32 g_wgui_cat033_highlighted_shortcut_item;
static MMI_BOOL g_wgui_cat033_highlight_changed;
static MMI_BOOL g_wgui_cat033_setup_shortcut = MMI_FALSE;

/* when press shortcut, these entry functions will be executed */
#ifndef __COSMOS_MMI_PACKAGE__
extern void mmi_phb_entry_main_menu(void);
extern void EntryScrMessagesMenuList(void);
extern void EntryMainMenuFromIdleScreen(void);
#endif /* __COSMOS_MMI_PACKAGE__ */

extern void gui_sse_save_wallpaper(void);


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_shortcut_get_mainmenu_area
 * DESCRIPTION
 *  get main menu area for SSE, PLEASE DO NOT USE ARBITRARILY
 * PARAMETERS
 *  x        [IN/OUT]     x position of main menu shortcut icon
 *  y        [IN/OUT]     y position of main menu shortcut icon
 *  w        [IN/OUT]     width of main menu shortcut icon
 *  h        [IN/OUT]     height of main menu shortcut icon
 * RETURNS
 *  MMI_BOOL
 * REMARKS
 *  This routine is dependent on Order of Image Id's of Shortcut Item Images.
 *  DON'T CHANGE THE ORDER OF SHORTCUT IMAGE SEQUENCE
 *****************************************************************************/
MMI_BOOL wgui_cat033_shortcut_get_mainmenu_area(S32* x, S32* y, S32* w, S32* h)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_wgui_cat033_setup_shortcut == MMI_TRUE)
    {
        *x = g_wgui_cat033_shortcut[0].x;
        *y = g_wgui_cat033_shortcut[0].y;
        *w = g_wgui_cat033_shortcut[0].width;
        *h = g_wgui_cat033_shortcut[0].height;
    }
    return g_wgui_cat033_setup_shortcut;    
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_shortcut_clear_mainmenu_area
 * DESCRIPTION
 *  clear main menu area for SSE, PLEASE DO NOT USE ARBITRARILY
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_BOOL
 * REMARKS
 *  This routine is dependent on Order of Image Id's of Shortcut Item Images.
 *  DON'T CHANGE THE ORDER OF SHORTCUT IMAGE SEQUENCE
 *****************************************************************************/
MMI_BOOL wgui_cat033_shortcut_clear_mainmenu_area(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x = 0, y = 0, w = 0, h = 0;
    MMI_BOOL ret = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ret = wgui_cat033_shortcut_get_mainmenu_area(&x, &y, &w, &h);
    if (ret == MMI_TRUE)
    {
        wgui_cat033_draw_region_with_background_color(x, y, x + w - 1, y + h - 1);
    }
    return ret;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_display_shortcut_item
 * DESCRIPTION
 *  display individual shortcut item on touch idle screen according pressed status
 * PARAMETERS
 *  index        [IN]     idle screen shortcut
 *  is_pressed   [IN]     if pressed shortcut
 * RETURNS
 *  void
 * REMARKS
 *  void
 *****************************************************************************/
static void wgui_cat033_display_shortcut_item(S32 shortcut_index, MMI_BOOL is_pressed)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x1, y1, x2, y2;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(shortcut_index >= 0 && shortcut_index < WGUI_CAT033_MAX_SHORTCUTS_NUM);
    MMI_ASSERT((is_pressed == MMI_FALSE) || (is_pressed == MMI_TRUE));

    /* set shortcut information */
    g_wgui_cat033_shortcut[shortcut_index].is_pressed = is_pressed;    
    x1 = g_wgui_cat033_shortcut[shortcut_index].x;
    y1 = g_wgui_cat033_shortcut[shortcut_index].y;
    x2 = g_wgui_cat033_shortcut[shortcut_index].x + g_wgui_cat033_shortcut[shortcut_index].width - 1;
    y2 = g_wgui_cat033_shortcut[shortcut_index].y + g_wgui_cat033_shortcut[shortcut_index].height - 1;
    
    gui_lock_double_buffer();
    gui_push_clip();
    gui_set_clip(x1, y1, x2, y2);

    /* clear background */
#ifdef __GDI_MEMORY_PROFILE_2__
    gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_TRANSPARENT);
#else /* __GDI_MEMORY_PROFILE_2__ */     
    draw_wallpaper();
#endif /* __GDI_MEMORY_PROFILE_2__ */ 

    /* show shortcut image */
    if (is_pressed == MMI_FALSE)
    {
        gui_show_image(x1, y1, (PU8) GetImage((U16) (IMG_IDLE_MAINMENU_SHORCUT + shortcut_index)));
    }
    else
    {
        gui_show_image(x1, y1, (PU8) GetImage((U16) (IMG_IDLE_MAINMENU_SHORCUT_PRESSED + shortcut_index)));
    }

    gui_pop_clip();
    gui_unlock_double_buffer();
    gui_BLT_double_buffer(x1, y1, x2, y2);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_display_shortcut
 * DESCRIPTION
 *  Draw touch screen shortcuts
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 * REMARKS
 *  This routine is dependent on Order of Image Id's of Shortcut Item Images.
 *  DON'T CHANGE THE ORDER OF IMAGE ID's
 *****************************************************************************/
static void wgui_cat033_display_shortcut(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i, max_height;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_lock_double_buffer();
    for (i = 0; i < WGUI_CAT033_MAX_SHORTCUTS_NUM; i++)
    {
        if (g_wgui_cat033_shortcut[i].is_pressed == MMI_TRUE)
        { 
            wgui_cat033_display_shortcut_item(i, MMI_TRUE);      
        }
        else
        {
            wgui_cat033_display_shortcut_item(i, MMI_FALSE);
        }
    }
    max_height = wgui_cat033_get_shortcut_max_height();
    gui_unlock_double_buffer();
    gui_BLT_double_buffer(0, UI_device_height - max_height, UI_device_width, UI_device_height);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_enter_mainmenu
 * DESCRIPTION
 *  enter mainmenu from touch shortcut of idle screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat033_enter_mainmenu(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* save wallpaper for SSE icon flip effect */
    gui_sse_save_wallpaper();
#ifndef __COSMOS_MMI_PACKAGE__

    EntryMainMenuFromIdleScreen();
#endif	
#if defined(__MMI_TOUCH_IDLESCREEN_SHORTCUTS__)
    /* override default main menu SSE effect */
    gui_sse_setup_scenario(GUI_SSE_SCENARIO_IDLE_SHORTCUT_TO_MAINMENU);
#endif /* defined(__MMI_TOUCH_IDLESCREEN_SHORTCUTS__) */
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_enter_um
 * DESCRIPTION
 *  enter UM from touch shortcut of idle screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat033_enter_um(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_sse_setup_scenario(GUI_SSE_SCENARIO_FROM_IDLE_SHORTCUT);
    mmi_um_entry_main_message_menu();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_enter_phb
 * DESCRIPTION
 *  enter PHB from touch shortcut of idle screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat033_enter_phb(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_sse_setup_scenario(GUI_SSE_SCENARIO_FROM_IDLE_SHORTCUT);
#ifndef __COSMOS_MMI_PACKAGE__
    mmi_phb_entry_main_menu();
#endif  /* __COSMOS_MMI_PACKAGE__*/
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_enter_dialer
 * DESCRIPTION
 *  enter dialer from touch shortcut of idle screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat033_enter_dialer(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_sse_setup_scenario(GUI_SSE_SCENARIO_FROM_IDLE_SHORTCUT);
    mmi_dialer_launch();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_setup_shortcut
 * DESCRIPTION
 *  Set up touch screen shortcuts
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 * REMARKS
 *  This routine is dependent on Order of Image Id's of Shortcut Item Images.
 *  DON'T CHANGE THE ORDER OF IMAGE ID's
 *****************************************************************************/
static void wgui_cat033_setup_shortcut(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 image_width[WGUI_CAT033_MAX_SHORTCUTS_NUM], image_height[WGUI_CAT033_MAX_SHORTCUTS_NUM];
    S32 i, total_width = 0, x, x_margin;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (i = 0; i < WGUI_CAT033_MAX_SHORTCUTS_NUM; i++)
    {
        gui_measure_image((PU8) GetImage((U16) (IMG_IDLE_MAINMENU_SHORCUT + i)), &image_width[i], &image_height[i]);
        total_width += image_width[i];
        g_wgui_cat033_shortcut[i].height = image_height[i];
        g_wgui_cat033_shortcut[i].width = image_width[i];
        g_wgui_cat033_shortcut[i].is_pressed = MMI_FALSE;
    }

    MMI_ASSERT(total_width >= 0 && total_width <= UI_device_width);

    g_wgui_cat033_shortcut[0].entryfn = wgui_cat033_enter_mainmenu;
    g_wgui_cat033_shortcut[1].entryfn = wgui_cat033_enter_um;
    g_wgui_cat033_shortcut[2].entryfn = wgui_cat033_enter_phb;
    g_wgui_cat033_shortcut[3].entryfn = wgui_cat033_enter_dialer;

    /* Margin between shortcut Images,Leave margin on front and back also */
    x_margin = (UI_device_width - total_width) / ((WGUI_CAT033_MAX_SHORTCUTS_NUM - 1) + 2);

    x = x_margin;

    for (i = 0; i < WGUI_CAT033_MAX_SHORTCUTS_NUM; i++)
    {
        g_wgui_cat033_shortcut[i].x = x;
        g_wgui_cat033_shortcut[i].y = UI_device_height - g_wgui_cat033_shortcut[i].height;
        x += g_wgui_cat033_shortcut[i].width + x_margin;
    }
    g_wgui_cat033_setup_shortcut = MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_get_shortcut_max_height
 * DESCRIPTION
 *  Get the maximum height of idlescreen shortcut
 * PARAMETERS
 *  void
 * RETURNS
 *  S32 max_height 
 *****************************************************************************/
S32 wgui_cat033_get_shortcut_max_height(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i, max_height;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* In case Image's are of different height, Find the maximum height image */
    max_height = g_wgui_cat033_shortcut[0].height;

    for (i = 0; i < WGUI_CAT033_MAX_SHORTCUTS_NUM; i++)
    {
        if (max_height < g_wgui_cat033_shortcut[i].height)
        {
            max_height = g_wgui_cat033_shortcut[i].height;
        }
    }
    return max_height;
}
#endif /* defined(__MMI_TOUCH_IDLESCREEN_SHORTCUTS__) */ 


#ifdef __MMI_TOUCH_SCREEN__
#ifdef __MMI_TOUCH_IDLESCREEN_SHORTCUTS__
/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_shortcut_translate_pen_position
 * DESCRIPTION
 *  This function finds index of shorcut item on which pen event came
 * PARAMETERS
 *  x           [IN]        Pen's x position
 *  y           [IN]        Pen's y position
 *  index       [OUT]       Index of selected item
 * RETURNS
 *  void
 * REMARKS
 *  void
 *****************************************************************************/
static void wgui_cat033_shortcut_translate_pen_position(S32 x, S32 y, S32 *index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    *index = -1;

    for (i = 0; i < WGUI_CAT033_MAX_SHORTCUTS_NUM; i++)
    {
        if (x >= g_wgui_cat033_shortcut[i].x && 
            x <= g_wgui_cat033_shortcut[i].x + g_wgui_cat033_shortcut[i].width &&
            y >= g_wgui_cat033_shortcut[i].y && 
            y <= g_wgui_cat033_shortcut[i].y + g_wgui_cat033_shortcut[i].height)
        {
            *index = i;
            break;
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_shortcut_pen_down_handler
 * DESCRIPTION
 *  pen down handler when there are touch shortcuts
 * PARAMETERS
 *  point       [IN]        pen position
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL wgui_cat033_shortcut_pen_down_handler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 pos_x = point.x, pos_y = point.y, y2;
    MMI_BOOL result = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    y2 = UI_device_height;  /* N CASE IDLE SCREEN SHORTCUTS ARE DISPLAYED, BUTTON BAR IS NOT DISPLAYED */

    if (pos_x > 0 && pos_x < UI_device_width - 1 && pos_y > MMI_content_y && pos_y < y2)
    {
        S32 index;
        wgui_cat033_shortcut_translate_pen_position(pos_x, pos_y, &index);
        if (index >= 0 && index < WGUI_CAT033_MAX_SHORTCUTS_NUM)
        {
            g_wgui_cat033_highlighted_shortcut_item = index;
            g_wgui_cat033_highlight_changed = MMI_FALSE;
	    gui_touch_feedback_play(GUI_TOUCH_FEEDBACK_DOWN_VIBRATE);
            wgui_cat033_display_shortcut_item(index, MMI_TRUE);
        }
        result = MMI_TRUE;
    }
    return result;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_shortcut_pen_up_handler
 * DESCRIPTION
 *  pen up handler when there are touch shortcuts
 * PARAMETERS
 *  point       [IN]        pen position
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL wgui_cat033_shortcut_pen_up_handler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 pos_x = point.x, pos_y = point.y, index;
    MMI_BOOL ret = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_cat033_shortcut_translate_pen_position(pos_x, pos_y, &index);
    if (index >= 0 && index < WGUI_CAT033_MAX_SHORTCUTS_NUM)
    {
        wgui_cat033_display_shortcut_item(index, MMI_FALSE);
        if (g_wgui_cat033_highlight_changed == MMI_FALSE)
        {
            if ((g_wgui_cat033_shortcut[index].entryfn) != NULL)
            {
                g_wgui_cat033_shortcut[index].entryfn();
            }
        }
    }
    ret = MMI_TRUE;
    
    return ret;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_shortcut_pen_move_handler
 * DESCRIPTION
 *  pen move handler when there are touch shortcuts
 * PARAMETERS
 *  point       [IN]       pen position 
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL wgui_cat033_shortcut_pen_move_handler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 pos_x = point.x, pos_y = point.y, index;
    MMI_BOOL ret = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_cat033_shortcut_translate_pen_position(pos_x, pos_y, &index);
    if (index != g_wgui_cat033_highlighted_shortcut_item)
    {
        g_wgui_cat033_highlight_changed = MMI_TRUE;
        /* Unpressed Image */
        wgui_cat033_display_shortcut_item(g_wgui_cat033_highlighted_shortcut_item, MMI_FALSE);
    }
    if (index >= 0 && index < WGUI_CAT033_MAX_SHORTCUTS_NUM)
    {
        g_wgui_cat033_highlighted_shortcut_item = index;
        /* Pressed Image */
        wgui_cat033_display_shortcut_item(index, MMI_TRUE);
    }
    ret = MMI_TRUE;

    return ret;
}
#endif /* __MMI_TOUCH_IDLESCREEN_SHORTCUTS__ */ 


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_pen_down_handler
 * DESCRIPTION
 *  pen down handler for category33
 * PARAMETERS
 *  point       [IN]        pen position
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL wgui_cat033_pen_down_handler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#ifndef __MMI_TOUCH_IDLESCREEN_SHORTCUTS__
    S32 pos_x = point.x, pos_y = point.y, y2;
#endif
    S32 i = 0;
    MMI_BOOL result = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    do
    {
        /* reminder */
        for (i = 0; i < wgui_cat033_reminder_total; i++)\
        {
            if (g_wgui_cat033_reminder[i].pen_event_handler != NULL)
            {
                result = g_wgui_cat033_reminder[i].pen_event_handler(point, MMI_PEN_EVENT_DOWN);
                if (result == MMI_TRUE)
                {
                    break;
                }
            }
        }
#if defined (__MMI_TOUCH_IDLESCREEN_SHORTCUTS__)
        /* shortcuts*/
        result = wgui_cat033_shortcut_pen_down_handler(point);
        if (result == MMI_TRUE);
        {
            break;
        }
#else /* defined (__MMI_TOUCH_IDLESCREEN_SHORTCUTS__) */
        /* no shortcuts */
        y2 = UI_device_height - 1 - MMI_button_bar_height;    
        if (pos_x > 0 && pos_x < UI_device_width - 1 && pos_y > MMI_content_y && pos_y < y2)
        {
            result = MMI_TRUE;
            break;
        }
#endif /* defined (__MMI_TOUCH_IDLESCREEN_SHORTCUTS__) */
    } while (0);
    
    return result;
}
#if defined(__MMI_SEARCH_WEB__)
/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_shortcut_translate_pen_position
 * DESCRIPTION
 *  This function finds index of shorcut item on which pen event came
 * PARAMETERS
 *  x           [IN]        Pen's x position
 *  y           [IN]        Pen's y position
 *  index       [OUT]       Index of selected item
 * RETURNS
 *  void
 * REMARKS
 *  void
 *****************************************************************************/
static void wgui_cat033_translate_pen_position2(S32 x, S32 y, MMI_BOOL *result)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    *result = MMI_FALSE;

        if (x >= g_wgui_cat033_search.x && 
            x <= g_wgui_cat033_search.x + g_wgui_cat033_search.w &&
            y >= g_wgui_cat033_search.y && 
            y <= g_wgui_cat033_search.y + g_wgui_cat033_search.h)
        {
            *result = MMI_TRUE;
        }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_pen_up_handler
 * DESCRIPTION
 *  pen up handler for category33
 * PARAMETERS
 *  point       [IN]        pen position
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL wgui_cat033_pen_up_handler2(mmi_pen_point_struct point)
{
	/*----------------------------------------------------------------*/
	/* Local Variables												  */
	/*----------------------------------------------------------------*/
	S32 pos_x = point.x, pos_y = point.y;
	MMI_BOOL result = MMI_FALSE;
	wgui_cat033_translate_pen_position2(pos_x, pos_y, &result);
	if((result == MMI_TRUE) && g_wgui_cat033_search.handler)
		{
			g_wgui_cat033_search.handler();
		}
	return result;		
}
#endif
/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_pen_long_tap_handler
 * DESCRIPTION
 *  pen long tap handler for category33
 * PARAMETERS
 *  point       [IN]        pen position
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL wgui_cat033_pen_long_tap_handler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#ifndef __MMI_TOUCH_IDLESCREEN_SHORTCUTS__
    S32 pos_x = point.x, pos_y = point.y;
#endif
    S32 i = 0;
    MMI_BOOL result = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifndef __MMI_TOUCH_IDLESCREEN_SHORTCUTS__
    if (mmi_scr_locker_is_locked() == MMI_FALSE && pos_x >= UI_device_width >> 2 &&
        pos_x <= UI_device_width - (UI_device_width << 2) && pos_y >= UI_device_height >> 2 &&
        pos_y <= UI_device_height - (MMI_button_bar_height >> 2))
    {
        result = MMI_TRUE;     
    }
#endif /* __MMI_TOUCH_IDLESCREEN_SHORTCUTS__ */
    do
    {
        /* reminder */
        for (i = 0; i < wgui_cat033_reminder_total; i++)
        {
            if (g_wgui_cat033_reminder[i].pen_event_handler != NULL)
            {
                result = g_wgui_cat033_reminder[i].pen_event_handler(point, MMI_PEN_EVENT_LONG_TAP);
                if (result == MMI_TRUE)
                {
                    break;
                }
            }
        }
    } while (0);
    
    return result;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_pen_repeat_handler
 * DESCRIPTION
 *  pen repeat handler for category33
 * PARAMETERS
 *  point       [IN]        pen position
 * RETURNS
 *  
 *****************************************************************************/
MMI_BOOL wgui_cat033_pen_repeat_handler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL result = MMI_FALSE;
    S32 i = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    result = MMI_TRUE;
    do
    {
        /* reminder */
        for (i = 0; i < wgui_cat033_reminder_total; i++)
        {
            if (g_wgui_cat033_reminder[i].pen_event_handler != NULL)
            {
                result = g_wgui_cat033_reminder[i].pen_event_handler(point, MMI_PEN_EVENT_REPEAT);
                if (result == MMI_TRUE)
                {
                    break;
                }
            }
        }
    } while (0);
    
    return result;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_pen_abort_handler
 * DESCRIPTION
 *  pen abort handler for category33
 * PARAMETERS
 *  point       [IN]        pen position
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL wgui_cat033_pen_abort_handler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL result = MMI_FALSE;
    S32 i = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    do
    {
        /* reminder */
        for (i = 0; i < wgui_cat033_reminder_total; i++)
        {
            if (g_wgui_cat033_reminder[i].pen_event_handler != NULL)
            {
                result = g_wgui_cat033_reminder[i].pen_event_handler(point, MMI_PEN_EVENT_ABORT);
                if (result == MMI_TRUE)
                {
                    break;
                }
            }
        }
    } while (0);
    
    return result;  
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_pen_up_handler
 * DESCRIPTION
 *  pen up handler for category33
 * PARAMETERS
 *  point       [IN]        pen position
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL wgui_cat033_pen_up_handler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL result = MMI_FALSE;
    S32 i = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    do
    {
        /* reminder */
        for (i = 0; i < wgui_cat033_reminder_total; i++)
        {
            if (g_wgui_cat033_reminder[i].pen_event_handler != NULL)
            {
                result = g_wgui_cat033_reminder[i].pen_event_handler(point, MMI_PEN_EVENT_UP);
                if (result == MMI_TRUE)
                {
                    break;
                }
            }
        }
#if defined (__MMI_SEARCH_WEB__)
        if(g_wgui_cat033_search.image != NULL || g_wgui_cat033_search.string != NULL)
        {
		    result = wgui_cat033_pen_up_handler2(point);
		    if(result == MMI_TRUE)
			{
				break;
			}
        }
#endif
#if defined (__MMI_TOUCH_IDLESCREEN_SHORTCUTS__)
        /* shortcuts */
        result = wgui_cat033_shortcut_pen_up_handler(point);
        if (result == MMI_TRUE);
        {
            break;
        }
#endif /* defined (__MMI_TOUCH_IDLESCREEN_SHORTCUTS__) */
    } while (0);
    
    return result;    
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_pen_move_handler
 * DESCRIPTION
 *  pen move handler for category33
 * PARAMETERS
 *  point       [IN]        pen position
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL wgui_cat033_pen_move_handler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL result = MMI_FALSE;
    S32 i = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    do
    {
        /* reminder */
        for (i = 0; i < wgui_cat033_reminder_total; i++)
        {
            if (g_wgui_cat033_reminder[i].pen_event_handler != NULL)
            {
                result = g_wgui_cat033_reminder[i].pen_event_handler(point, MMI_PEN_EVENT_MOVE);
                if (result == MMI_TRUE)
                {
                    break;
                }
            }
        }
#if defined (__MMI_TOUCH_IDLESCREEN_SHORTCUTS__)
        /* shortcuts */
        result = wgui_cat033_shortcut_pen_move_handler(point);
        if (result == MMI_TRUE);
        {
            break;
        }
#endif /* defined (__MMI_TOUCH_IDLESCREEN_SHORTCUTS__) */
    } while (0);
    
    return result; 
}
#endif /* __MMI_TOUCH_SCREEN__ */ 


#ifdef __MMI_UI_STATUS_BAR_AT_BOTTOM__
/*****************************************************************************
 * FUNCTION
 *  show_boundries_to_status_bar_at_bottom_idlescreen
 * DESCRIPTION
 *  redraw status bar
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void show_boundries_to_status_bar_at_bottom_idlescreen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    color c;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    c = gui_color(255, 255, 255);
    gui_draw_horizontal_line(0, UI_device_width - 1, UI_device_height - 1 - MMI_button_bar_height, c);
    gui_draw_horizontal_line(
        0,
        UI_device_width - 1,
        UI_device_height - 1 - MMI_button_bar_height - MMI_status_bar_height - 2,
        c);
    if (PhnsetGetShowDateTimeStatus() == MMI_TRUE)
    {
        gui_draw_horizontal_line(0, UI_device_width - 1, 0, c);
        
#ifdef __MMI_MAINLCD_128X128__
        gui_draw_horizontal_line(0, UI_device_width - 1, MMI_status_bar_height + 2, c);
#else 
        gui_draw_horizontal_line(0, UI_device_width - 1, MMI_status_bar_height, c);
#endif /* __MMI_MAINLCD_128X128__ */
	}
}
#endif /* __MMI_UI_STATUS_BAR_AT_BOTTOM__ */ 


/*****************************************************************************
 * FUNCTION
 *  mmi_cat33_get_cache_wallpaper_info
 * DESCRIPTION
 *  get cat33 cache wallpaper information, used after ShowCategory33Screen and before entering another new screen
 * PARAMETERS
 *  id                  [IN]    Current wallpaper id to determine whether to cache
 *  filename            [IN]    Current wallpaper filename to determine whether to cache
 *  wallpaper_layer     [OUT]   layer handle of wallpaper
 *  output_image_type   [OUT]   output image type (GDI image type)
 * RETURNS
 *  MMI_BOOL            whether to enable cache wallpaper mechanism
 *****************************************************************************/
MMI_BOOL mmi_cat33_get_cache_wallpaper_info (MMI_ID_TYPE id, CHAR * filename, GDI_HANDLE *wallpaper_layer, U16 *output_image_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gui_cache_image_type_enum cache_test = GUI_CACHE_IMAGE_NONE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
 //   *wallpaper_layer = dm_get_wallpaper_layer();
    
    cache_test = gui_image_query_cache_type(id, filename);

    switch(cache_test)
    {
        case GUI_CACHE_IMAGE_PBM:
            *output_image_type = GDI_IMAGE_TYPE_DEVICE_BMP_FILE;
            break;
            
        case GUI_CACHE_IMAGE_JPG:
            *output_image_type = GDI_IMAGE_TYPE_JPG_FILE;
            break;
            
        default:
            return MMI_FALSE;
    }

    return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_redraw
 * DESCRIPTION
 *  redraw category 33 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat033_redraw(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i = 0;
    GDI_HANDLE wallpaper_layer;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(__MMI_SWFLASH__) || defined(__MMI_AVATAR__)
    if (g_dm_data.s32CatId == MMI_CATEGORY34_ID)
    {
        wgui_cat033_set_text_abm_layer(GetSWFlashPlayerLayer());
    }
    else
#endif /* defined(__MMI_SWFLASH__) || defined(__MMI_AVATAR__) */
    {
        wgui_cat033_set_text_abm_layer(dm_get_wallpaper_layer());
    }

#ifndef __GDI_MEMORY_PROFILE_2__
    gui_cancel_timer(cat33_animation_processor);
#endif 

#ifdef __MMI_UI_TECHNO_IDLESCREEN_BAR__
    gui_push_clip();
    gui_set_clip(0, MMI_status_bar_height, UI_device_width - 1, MMI_status_bar_height + MMI_IDLESCREEN_BAR_HEIGHT - 1);
    if (PhnsetGetShowDateTimeStatus() == MMI_TRUE)
    {
        gui_show_image(0, MMI_status_bar_height, get_image(idlescreen_bar_id));
    }
    gui_pop_clip();
#endif /* __MMI_UI_TECHNO_IDLESCREEN_BAR__ */ 
// VIJAYAN
#ifdef __MMI_MAINLCD_96X64__
	if ((PhnsetGetShowDateTimeStatus()) && (!wgui_get_idle_screen_is_extra_text()))
#endif
	{
    #ifdef __GDI_MEMORY_PROFILE_2__
        update_mainlcd_dt_display();
    #else /* __GDI_MEMORY_PROFILE_2__ */
        show_main_LCD_dt_display();
    #endif /* __GDI_MEMORY_PROFILE_2__ */
	}
#ifndef __MMI_IDLE_FULL_SCREEN__
    idle_screen_hide_status_icons_bar0();
#endif /* __MMI_IDLE_FULL_SCREEN__ */
    in_idle_screen();

    wallpaper_layer = wgui_cat033_get_text_abm_layer();
    wgui_status_icon_bar_set_alpha_blend_layer(
        WGUI_STATUS_ICON_BAR_H_BAR, 
        wallpaper_layer);

    idle_screen_show_network_details();

    for (i = 0; i < wgui_cat033_reminder_total; i++)
    {
        if (g_wgui_cat033_reminder[i].show != NULL)    /* show */
        {
            g_wgui_cat033_reminder[i].show();
        }
    }

    on_idle_screen = 1;
    set_on_idlescreen(1);
    
#ifdef __MMI_UI_STATUS_BAR_AT_BOTTOM__
    show_boundries_to_status_bar_at_bottom_idlescreen();
#endif /* __MMI_UI_STATUS_BAR_AT_BOTTOM_ */

#if defined(__MMI_TOUCH_IDLESCREEN_SHORTCUTS__)
    wgui_cat033_display_shortcut();
#endif /* defined(__MMI_TOUCH_IDLESCREEN_SHORTCUTS__) */ 
#if defined(__MMI_SEARCH_WEB__)
    if(g_wgui_cat033_search.image != NULL || g_wgui_cat033_search.string != NULL)
    {
		wgui_cat033_search_show();
    }
#endif
    wgui_status_icon_bar_register_hide_callback(
        WGUI_STATUS_ICON_BAR_H_BAR, 
        idle_screen_hide_status_icons_bar0);
#if !defined(__MMI_MAINLCD_320X480__)
#ifdef WGUI_STATUS_ICON_SHOW_V_BAR
    wgui_status_icon_bar_register_hide_callback(
        WGUI_STATUS_ICON_BAR_V_BAR, 
        idle_screen_hide_status_icons_bar1);
#endif
#endif
    wgui_status_icon_bar_update();

#if defined(ENABLE_ANIMATED_WALLPAPERS)
#ifndef __GDI_MEMORY_PROFILE_2__
    if (cat33_n_frames > 1 && idle_screen_wallpaper_ID != 0)
    {
        gui_start_timer(cat33_animation_delay, cat33_animation_processor);
    }
#endif /* __GDI_MEMORY_PROFILE_2__ */ 
#endif /* (ENABLE_ANIMATED_WALLPAPERS) */ 
}


/*****************************************************************************
 * FUNCTION
 *  dm_category_33_controlled_area
 * DESCRIPTION
 *  This function is used to draw the category controlled area of idle screen
 * PARAMETERS
 *  coordinate      [IN/OUT]        Coordinates of category controlled area.
 * RETURNS
 *  void
 *****************************************************************************/
void dm_category_33_controlled_area(dm_coordinates *coordinate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    UI_UNUSED_PARAMETER(coordinate);
    wgui_cat033_redraw();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_hide_lsk
 * DESCRIPTION
 *  category 33 hide left softkey
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat033_hide_lsk(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_cat033_draw_region_with_background_color(
        MMI_softkeys[MMI_LEFT_SOFTKEY].x,
        MMI_softkeys[MMI_LEFT_SOFTKEY].y,
        MMI_softkeys[MMI_LEFT_SOFTKEY].x + MMI_softkeys[MMI_LEFT_SOFTKEY].width - 1,
        MMI_softkeys[MMI_LEFT_SOFTKEY].y + MMI_softkeys[MMI_LEFT_SOFTKEY].height - 1);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_hide_rsk
 * DESCRIPTION
 *  category 33 hide right softkey
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat033_hide_rsk(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_cat033_draw_region_with_background_color(
        MMI_softkeys[MMI_RIGHT_SOFTKEY].x,
        MMI_softkeys[MMI_RIGHT_SOFTKEY].y,
        MMI_softkeys[MMI_RIGHT_SOFTKEY].x + MMI_softkeys[MMI_RIGHT_SOFTKEY].width - 1,
        MMI_softkeys[MMI_RIGHT_SOFTKEY].y + MMI_softkeys[MMI_RIGHT_SOFTKEY].height - 1);
}
#ifndef __MMI_WGUI_DISABLE_CSK__
/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_hide_csk
 * DESCRIPTION
 *  category 33 hide center softkey
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat033_hide_csk(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_cat033_draw_region_with_background_color(
        MMI_softkeys[MMI_CENTER_SOFTKEY].x,
        MMI_softkeys[MMI_CENTER_SOFTKEY].y,
        MMI_softkeys[MMI_CENTER_SOFTKEY].x + MMI_softkeys[MMI_CENTER_SOFTKEY].width - 1,
        MMI_softkeys[MMI_CENTER_SOFTKEY].y + MMI_softkeys[MMI_CENTER_SOFTKEY].height - 1);
}

#endif
/*****************************************************************************
 * FUNCTION
 *  ShowCategory33Screen_ext_int
 * DESCRIPTION
 *  Displays the Idle screen
 * PARAMETERS
 *  left_softkey            [IN]        Left softkey label
 *  right_softkey           [IN]        Right softkey label
 *  history_buffer          [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory33Screen_ext_int(
        U16 left_softkey,
        U16 right_softkey,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#ifndef __MMI_UI_STATUS_BAR_AT_BOTTOM__
#ifdef WGUI_STATUS_ICON_SHOW_V_BAR
    S32 status_bar1_y1;
    S32 status_bar1_y2;
#endif
#endif /* __MMI_UI_STATUS_BAR_AT_BOTTOM__ */
    S32 i = 0, history_size = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(history_buffer);

    GDI_LOCK;
    gui_lock_double_buffer();

    on_idle_screen = 1;
    set_on_idlescreen(1);

#ifdef __MMI_TOUCH_IDLESCREEN_SHORTCUTS__
    g_wgui_cat033_setup_shortcut = MMI_FALSE;
#endif

#ifdef __MMI_OP12_CAT533_SUPPORT__
	wgui_set_wallpaper_on_bottom(MMI_TRUE);
#endif /* __MMI_OP12_CAT533_SUPPORT__ */

    /* init all reminder */
    for (i = 0; i < wgui_cat033_reminder_total; i++)
    {
        if (g_wgui_cat033_reminder[i].init != NULL)    
        {
            g_wgui_cat033_reminder[i].init();

            /* set reminder history */
            if (history_buffer != NULL && g_wgui_cat033_reminder[i].set_history_function != NULL)
            {
                g_wgui_cat033_reminder[i].set_history_function(history_buffer + history_size);
                history_size += g_wgui_cat033_reminder[i].get_history_size_function();
            }        
        }
    }

#if defined(__MMI_UI_TECHNO_IDLESCREEN_BAR__) 
    /* network name & network status on the same line */
    g_wgui_cat033_techno_current_text_type = NETWORK_NAME_TEXT_ON_IDLE;
    g_wgui_cat033_techno_scroll_count = 0;
    gui_start_timer(WGUI_CAT033_PAUSE_TIMER, wgui_cat033_techno_text_change_processor);
#endif /*defined(__MMI_UI_TECHNO_IDLESCREEN_BAR__)  */

#ifdef __MMI_IDLE_FULL_SCREEN__
  #if defined(__MMI_MAINLCD_128X128__) || defined(__MMI_MAINLCD_128X160__)
    disable_softkey_background();
    set_softkey_flags_on(UI_BUTTON_TEXT_WITH_BORDER, MMI_LEFT_SOFTKEY);
    set_softkey_flags_on(UI_BUTTON_TEXT_WITH_BORDER, MMI_RIGHT_SOFTKEY);
  #endif /* __MMI_MAINLCD_128X128__ || __MMI_MAINLCD_128X160__ */
#endif /* __MMI_IDLE_FULL_SCREEN__ */ 

    cat33_frame_number = 0;
    wgui_title_set_menu_shortcut_number(-1);

    /* No need to set the default handlers for Left and Right Softkeys in case of
       Idlescreen Shortcuts. So passing the value 0 for string ID and icon ID. */
#ifdef __MMI_TOUCH_IDLESCREEN_SHORTCUTS__
    change_left_softkey(0, 0);
    change_right_softkey(0, 0);
#else /* __MMI_TOUCH_IDLESCREEN_SHORTCUTS__ */ 
    change_left_softkey(left_softkey, 0);
    change_right_softkey(right_softkey, 0);
#endif /* __MMI_TOUCH_IDLESCREEN_SHORTCUTS__ */ 

#ifdef __MMI_FTE_SUPPORT__
	disable_softkey_background();
    set_softkey_flags_on(UI_BUTTON_TEXT_WITH_BORDER, MMI_LEFT_SOFTKEY);
    set_softkey_flags_on(UI_BUTTON_TEXT_WITH_BORDER, MMI_RIGHT_SOFTKEY);
#endif

    SetupCategoryKeyHandlers();

    /* No need to register the hide functions for Left and Right Sofkeys
       when Idle Screen Shortcuts are present.   */
#ifdef __MMI_TOUCH_IDLESCREEN_SHORTCUTS__
    if(MMI_FALSE)
#endif /* __MMI_TOUCH_IDLESCREEN_SHORTCUTS__ */
    {
#ifndef __MMI_OP12_CAT533_SUPPORT__
        {
            register_hide_left_softkey(wgui_cat033_hide_lsk);
            register_hide_right_softkey(wgui_cat033_hide_rsk);
        #ifndef __MMI_WGUI_DISABLE_CSK__
            register_hide_softkey(wgui_cat033_hide_csk, MMI_CENTER_SOFTKEY);
        #endif
        }
#endif /* __MMI_OP12_CAT533_SUPPORT__ */
    }

#ifdef __KJX_FUN__	//xb add 2017-07-18 屏蔽软按键显示
	change_softkey(0, 0, MMI_LEFT_SOFTKEY);
    change_softkey(0, 0, MMI_RIGHT_SOFTKEY);
	change_softkey(0, 0, MMI_CENTER_SOFTKEY);
#endif

    /* status bar 0 (horizontal status bar) */
    wgui_status_icon_bar_register_hide_callback(
        WGUI_STATUS_ICON_BAR_H_BAR,
        UI_dummy_function);
#ifdef __MMI_UI_STATUS_BAR_AT_BOTTOM__
    wgui_status_icon_bar_move(
        WGUI_STATUS_ICON_BAR_H_BAR, 
                0,
        UI_device_height - 1 - MMI_button_bar_height - MMI_status_bar_height);
#else /* __MMI_UI_STATUS_BAR_AT_BOTTOM__ */ 
    /* status bar 0 is y center aligned in status bar area (status bar area = idle_y + status_bar_h + idle_y) */
    wgui_status_icon_bar_move(
        WGUI_STATUS_ICON_BAR_H_BAR, 
        0, 
        MMI_STATUS_BAR_IDLE_Y);
#endif /* __MMI_UI_STATUS_BAR_AT_BOTTOM__ */ 
    wgui_status_icon_bar_set_display(WGUI_STATUS_ICON_BAR_H_BAR);

    


    /* status bar 1 (vertical status bar) */
#if !defined(__MMI_MAINLCD_320X480__)
#ifdef WGUI_STATUS_ICON_SHOW_V_BAR
    wgui_status_icon_bar_register_hide_callback(
        WGUI_STATUS_ICON_BAR_V_BAR, 
        UI_dummy_function);
#endif

#if defined(__MMI_UI_STATUS_BAR_AT_BOTTOM__)
#ifdef WGUI_STATUS_ICON_SHOW_V_BAR
    wgui_status_icon_bar_move(
        WGUI_STATUS_ICON_BAR_V_BAR,
        UI_device_width - MMI_IDLE_STRING_MARGIN_GAP,
        MMI_status_bar_height + STATUS_ICON_Y_GAP);
    wgui_status_icon_bar_resize(
        WGUI_STATUS_ICON_BAR_V_BAR, 
        MMI_IDLE_STRING_MARGIN_GAP, 
        UI_device_height - MMI_button_bar_height - (MMI_status_bar_height << 1) - (STATUS_ICON_Y_GAP << 1) - 1);
#endif
#else /* defined(__MMI_UI_STATUS_BAR_AT_BOTTOM__) */

    /* y1 of vertical status bar */
#ifdef WGUI_STATUS_ICON_SHOW_V_BAR
  #ifdef __MMI_UI_TECHNO_IDLESCREEN_BAR__

    if (PhnsetGetShowDateTimeStatus() == MMI_TRUE)
    {
        /* status bar 0 is y center aligned in status bar area (status bar area = idle_y + status_bar_h + idle_y) */
        status_bar1_y1 = MMI_STATUS_BAR_IDLE_Y + MMI_status_bar_height + MMI_STATUS_BAR_IDLE_Y + MMI_IDLESCREEN_BAR_HEIGHT;
    }
    else
    {
      #ifdef __MMI_DUAL_SIM_MASTER__
		S32 max_region_height = MMI_IDLESCREEN_BAR_HEIGHT - WGUI_CAT033_DUAL_SIM_DATE_HEIGHT;
      #else
        S32 max_region_height = (MMI_IDLESCREEN_BAR_HEIGHT >> 1);
      #endif /* __MMI_DUAL_SIM_MASTER__ */
      
        status_bar1_y1 = MMI_STATUS_BAR_IDLE_Y + MMI_status_bar_height + MMI_STATUS_BAR_IDLE_Y + max_region_height;
    }
  #else
    {
        /* status bar 0 is y center aligned in status bar area (status bar area = idle_y + status_bar_h + idle_y) */
        status_bar1_y1 = MMI_STATUS_BAR_IDLE_Y + MMI_status_bar_height + MMI_STATUS_BAR_IDLE_Y;
    }
  #endif /* __MMI_UI_TECHNO_IDLESCREEN_BAR__ */


    /* y2 of vertical status bar */
  #ifdef __MMI_TOUCH_IDLESCREEN_SHORTCUTS__
    if (MMI_TRUE)
    {
        status_bar1_y2 = UI_device_height - WGUI_TOUCH_IDLESCREEN_SHORTCUTS_HEIGHT - 2;
    }
    else
  #elif defined(__MMI_IDLE_SCREEN_ICON_SHORTCUT__)
    if (g_wgui_cat033_reminder[wgui_cat033_reminder_icon_shortcut_bar].state != cat33_reminder_area_state_deinit)
    {
        status_bar1_y2 = UI_device_height - MMI_BUTTON_BAR_HEIGHT - WGUI_IDLE_SCREEN_ICON_SHORTCUT_HEIGHT - 2;
    }
    else
  #elif defined(__MMI_OP01_DCD__)
    if (g_wgui_cat033_reminder[wgui_cat033_reminder_dcd].state != cat33_reminder_area_state_deinit)
    {
        status_bar1_y2 = UI_device_height - MMI_BUTTON_BAR_HEIGHT - MMI_IDLE_DCD_HEIGHT - 2;
    }
    else
  #endif /* __MMI_TOUCH_IDLESCREEN_SHORTCUTS__ */
    {
        status_bar1_y2 = UI_device_height - MMI_BUTTON_BAR_HEIGHT - 2;
    }
#endif
  #ifdef __MMI_KLG__
  #ifdef WGUI_STATUS_ICON_SHOW_V_BAR
  wgui_status_icon_bar_move(
    WGUI_STATUS_ICON_BAR_V_BAR,
    UI_device_width - MMI_IDLE_STRING_MARGIN_GAP, 
    status_bar1_y1);
  wgui_status_icon_bar_resize(
    WGUI_STATUS_ICON_BAR_V_BAR,
    MMI_IDLE_STRING_MARGIN_GAP,
    (UI_device_height >> 1) - status_bar1_y1 - 1);
  #endif
  #else /* __MMI_KLG__ */
  #ifdef WGUI_STATUS_ICON_SHOW_V_BAR
  wgui_status_icon_bar_move(
    WGUI_STATUS_ICON_BAR_V_BAR,
    UI_device_width - MMI_IDLE_STRING_MARGIN_GAP,
    status_bar1_y1);
  wgui_status_icon_bar_resize(
    WGUI_STATUS_ICON_BAR_V_BAR,
    MMI_IDLE_STRING_MARGIN_GAP, 
    status_bar1_y2 - status_bar1_y1 + 1);
  #endif
  #endif /* __MMI_KLG__ */

#endif /* !defined(__MMI_UI_STATUS_BAR_AT_BOTTOM__) */
    
#if !defined(__MMI_MAINLCD_128X64__)
#ifdef WGUI_STATUS_ICON_SHOW_V_BAR
    wgui_status_icon_bar_set_display(WGUI_STATUS_ICON_BAR_V_BAR);
#endif
#endif

#endif /* __MMI_MAINLCD_320X480__ */


#ifdef __MMI_TOUCH_IDLESCREEN_SHORTCUTS__
    /* clear the memory of touch_idle_shortcuts when the Flight Mode is ON. */
    if (MMI_TRUE)
    {
        wgui_cat033_setup_shortcut();
    }
    else
    {
        memset(g_wgui_cat033_shortcut, 0, sizeof(wgui_cat033_shortcut_struct) * WGUI_CAT033_MAX_SHORTCUTS_NUM);
    }
#endif /* __MMI_TOUCH_IDLESCREEN_SHORTCUTS__ */ 


    switch (idle_screen_type)
    {
        case NORMAL_IDLE_SCREEN:
#ifdef __MMI_UI_TECHNO_IDLESCREEN_BAR__
            set_main_LCD_dt_date_hide_function(wgui_cat033_draw_region_with_technobar);
            analog_clock_initialize();
            set_main_LCD_dt_time_hide_function(dummy_dt_hide_function);
            set_main_LCD_day_hide_function(wgui_cat033_draw_region_with_technobar);
#else /* __MMI_UI_TECHNO_IDLESCREEN_BAR__ */ 
            set_main_LCD_dt_date_hide_function(dummy_dt_hide_function);
            set_main_LCD_dt_time_hide_function(wgui_cat033_hide_time_display);
#endif /* __MMI_UI_TECHNO_IDLESCREEN_BAR__ */ 

#ifdef __MMI_UI_TECHNO_IDLESCREEN_BAR__
			set_dt_display(DT_IDLE_SCREEN_NO_DAY);
            if (PhnsetGetShowDateTimeStatus() == MMI_TRUE)
            {
                wgui_cat033_techno_init_date();
            }
#else /* __MMI_UI_TECHNO_IDLESCREEN_BAR__ */
    #if defined(__MMI_KLG__) || defined(__MMI_UI_STATUS_BAR_AT_BOTTOM__) || (defined(__MMI_MAINLCD_320X240__) && !defined(__MMI_UI_TECHNO_IDLESCREEN_BAR__)) || defined(__MMI_MAINLCD_96X64__)
            set_dt_display(DT_IDLE_SCREEN_2);
    #else /* defined(__MMI_KLG__) || defined(__MMI_UI_STATUS_BAR_AT_BOTTOM__) */ 
            set_dt_display(DT_IDLE_SCREEN);
    #endif /* defined(__MMI_KLG__) || defined(__MMI_UI_STATUS_BAR_AT_BOTTOM__) */ 
#endif /* __MMI_UI_TECHNO_IDLESCREEN_BAR__ */

            break;

#ifdef __MMI_ANALOG_CLOCK__
        case ANALOG_IDLE_SCREEN:
            analog_clock_initialize();
            set_main_LCD_dt_date_hide_function(dummy_dt_hide_function);
            set_main_LCD_dt_time_hide_function(cat33_analog_clock_hide_dt_display);
            set_dt_display(DT_ANALOG_CLOCK_SC);
            break;
#endif /* __MMI_ANALOG_CLOCK__ */ 

#ifdef __MMI_DIGITAL_CLOCK__
        case DIGITAL_IDLE_SCREEN:
            set_main_LCD_dt_date_hide_function(dummy_dt_hide_function);
            set_main_LCD_dt_time_hide_function(cat33_digital_clock_hide_dt_display);
            set_dt_display(DT_DIGITAL_CLOCK_SC1);
            break;
#endif /* __MMI_DIGITAL_CLOCK__ */ 
    }

    gui_unlock_double_buffer();


#if defined (__MMI_TOUCH_SCREEN__)
    wgui_register_category_screen_control_area_pen_handlers(wgui_cat033_pen_down_handler, MMI_PEN_EVENT_DOWN);
    wgui_register_category_screen_control_area_pen_handlers(wgui_cat033_pen_repeat_handler, MMI_PEN_EVENT_REPEAT);
    wgui_register_category_screen_control_area_pen_handlers(wgui_cat033_pen_long_tap_handler, MMI_PEN_EVENT_LONG_TAP);
    wgui_register_category_screen_control_area_pen_handlers(wgui_cat033_pen_up_handler, MMI_PEN_EVENT_UP);
    wgui_register_category_screen_control_area_pen_handlers(wgui_cat033_pen_abort_handler, MMI_PEN_EVENT_ABORT);
    wgui_register_category_screen_control_area_pen_handlers(wgui_cat033_pen_move_handler, MMI_PEN_EVENT_MOVE);
#endif /* (defined __MMI_TOUCH_SCREEN__) */ 
    gdi_layer_push_and_set_active(GDI_LAYER_MAIN_BASE_LAYER_HANDLE);
    gdi_layer_set_source_key(TRUE, GDI_COLOR_TRANSPARENT);
    gdi_layer_clear(GDI_COLOR_TRANSPARENT);
    gdi_layer_pop_and_restore_active();
    GDI_UNLOCK;

    /* register the custom SSE effect handler */
#if defined(__MMI_SCREEN_SWITCH_EFFECT__) && defined(__MMI_TOUCH_IDLESCREEN_SHORTCUTS__) && defined(__MMI_UI_TECHNO_IDLESCREEN_BAR__)    
   // gui_screen_switch_effect_register_custom_callback(wgui_category_sse_idle_custom_handler);
#endif
}


#ifdef __MMI_ALPHA_BLENDING__
/*****************************************************************************
 * FUNCTION
 *  cat33_redraw_alpha_images
 * DESCRIPTION
 *  Redraw alpha images when wallpaper animation updates
 *  1. draw shortcuts
 *  2. draw techno bar and date time
 *  3. draw reminder
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void cat33_redraw_alpha_images(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gdi_handle base_layer;
    S32 i = 0;
#ifdef __MMI_UI_TECHNO_IDLESCREEN_BAR__
    GDI_HANDLE wallpaper_layer;
#endif
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();
    gdi_layer_get_base_handle(&base_layer);
    gdi_layer_push_and_set_active(base_layer);

    // TODO: redraw only if images contain alpha
    
#ifdef __MMI_TOUCH_IDLESCREEN_SHORTCUTS__
    /* draw idle screen shortcuts */
    wgui_cat033_display_shortcut();
#endif /* __MMI_TOUCH_IDLESCREEN_SHORTCUTS__ */
/*
#if defined(__MMI_SEARCH_WEB__)
    if(g_wgui_cat033_search.image != NULL || g_wgui_cat033_search.string != NULL)
    {
    wgui_cat033_search_show();
    }
#endif
*/
#ifdef __MMI_UI_TECHNO_IDLESCREEN_BAR__
    /* draw techno idlescreen bar (including clock) */
    gui_push_clip();
    gui_set_clip(0, MMI_status_bar_height, UI_device_width - 1, MMI_status_bar_height + MMI_IDLESCREEN_BAR_HEIGHT - 1);
    if (PhnsetGetShowDateTimeStatus() == MMI_TRUE) /* no idlescreen bar when data and time is off */
    {
        gui_show_image(0, MMI_status_bar_height, get_image(idlescreen_bar_id));
    }
    gui_pop_clip();
    
    wallpaper_layer = wgui_cat033_get_text_abm_layer();
    wgui_status_icon_bar_set_alpha_blend_layer(
        WGUI_STATUS_ICON_BAR_H_BAR, 
        wallpaper_layer);
    wgui_status_icon_bar_update();

    /* draw date & time */
#ifdef __GDI_MEMORY_PROFILE_2__
    update_mainlcd_dt_display();
#else /* __GDI_MEMORY_PROFILE_2__ */
    show_main_LCD_dt_display();
#endif /* __GDI_MEMORY_PROFILE_2__ */
#endif /* __MMI_UI_TECHNO_IDLESCREEN_BAR__ */

    /* reminder */
    for (i = 0; i < wgui_cat033_reminder_total; i++)
    {
        if (g_wgui_cat033_reminder[i].redraw != NULL)
        {
            g_wgui_cat033_reminder[i].redraw();
        }
    }

#ifdef __MMI_OP12_CAT533_SUPPORT__
    show_softkey_background();
    redraw_left_softkey();
    redraw_right_softkey();
    redraw_center_softkey();
#endif /* __MMI_OP12_CAT533_SUPPORT__ */

    g_wgui_cat033_redraw_scrolling_text = MMI_FALSE;
    idle_screen_show_network_details();
    g_wgui_cat033_redraw_scrolling_text = MMI_TRUE;

    gdi_layer_pop_and_restore_active();
    gdi_layer_unlock_frame_buffer();
}

#endif /* __MMI_ALPHA_BLENDING__ */

#if defined(__DUAL_SIM_IDLE_TEXT_AT_SAME_POSITION__) /* Dual SIM show at same position. */
/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_dual_sim_text_change_processor
 * DESCRIPTION
 *  dual SIM show at same posotion
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat033_dual_sim_text_change_processor(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_wgui_cat033_dual_sim_current_text_type == SIM1_TEXT_ON_IDLE)
    {
        g_wgui_cat033_dual_sim_current_text_type = SIM2_TEXT_ON_IDLE;
    }
    else
    {
        g_wgui_cat033_dual_sim_current_text_type = SIM1_TEXT_ON_IDLE;
    }
    gui_start_timer(5000, wgui_cat033_dual_sim_text_change_processor);
    idle_screen_show_network_details();
}
#endif /* defined(__DUAL_SIM_IDLE_TEXT_AT_SAME_POSITION__) */


/*****************************************************************************
 * FUNCTION
 *  GetCategory33HistorySize
 * DESCRIPTION
 *  Gets the history buffer size of category 33
 * PARAMETERS
 *  void
 * RETURNS
 *  size in U8s of the history buffer
 *****************************************************************************/
S32 GetCategory33HistorySize(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 size = 0, i = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (i = 0; i < wgui_cat033_reminder_total; i++)
    {
        if (g_wgui_cat033_reminder[i].init != NULL && g_wgui_cat033_reminder[i].get_history_size_function != NULL)
        {
            size += (g_wgui_cat033_reminder[i].get_history_size_function());
        } 
    }
    return size;
}


/*****************************************************************************
 * FUNCTION
 *  GetCategory33History
 * DESCRIPTION
 *  Gets the history buffer of category33
 * PARAMETERS
 *  history_buffer      [OUT]        Is the buffer into which the history data is stored
 * RETURNS
 *  return history buffer
 *****************************************************************************/
U8 *GetCategory33History(U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i = 0, size = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (history_buffer != NULL)
    {
        for (i = 0; i < wgui_cat033_reminder_total; i++)
        {
            if (g_wgui_cat033_reminder[i].init != NULL && g_wgui_cat033_reminder[i].get_history_function != NULL)
            {
                g_wgui_cat033_reminder[i].get_history_function(history_buffer + size);
                size += g_wgui_cat033_reminder[i].get_history_size_function();
            }
        }
    }
    return (history_buffer);
}

#if defined(__GGT_TASK__)
#if defined(__OLED_BW_MMI__)
#include "wgui_status_icon_bar.h"
#include "PowerOnChargerProt.h"
#include "gpiosrvgprot.h"
#include "TimerEvents.h"
U8 is_ok = 0;
U8 sos_status = 0;
U8 sos_call_alert = 0;

#if defined(__MMI_MAINLCD_128X64__)
typedef enum
{
	MMI_EDOG_SCREEN_IDLE,
	MMI_EDOG_SCREEN_STRING,
	MMI_EDOG_SCREEN_SPEED,
	MMI_EDOG_SCREEN_OBD,
	MMI_EDOG_SCREEN_DISTANCE,
	MMI_EDOG_SCREEN_IMG,
	MMI_EDOG_SCREEN_END
}MMI_EGOD_SCR_ID;

scrolling_text	edog_string_info;
U8 scrolling_string[512];

U8 G_EDOG_SCREEN = MMI_EDOG_SCREEN_IDLE;
U16 edog_img_id = NULL;

void mmi_entry_edog_screen(void);
void mmi_edog_back_to_first_screen(void);
void mmi_edog_info_show(U8 *ucs_str,U8 *dist_ucs_str,U8 flag);
extern U8 wrt_gprs_is_soc_connect(void);

#endif /* __MMI_MAINLCD_128X64__ */

extern charbat_context_struct g_charbat_context;
extern void srv_backlight_to_sleep_mode(void);
extern void srv_backlight_turn_on(srv_backlight_timer_type_enum time_enum);
extern void srv_backlight_bw_timer_hdlr(void);
extern void mmi_frm_set_all_key_hdlr_null();
void mmi_idle_make_sos_call(void);
void mmi_show_idle_screen(void);
#if defined(__CITY_EASY_OBD__)
#include "city_obd_uart.h"
#endif /* __CITY_EASY_OBD__ */
#if defined(__GGT_TASK__)
#include "..\ggt\inc\ggt_host.h"
#include "Mmi_rp_app_ggt_def.h"
#include "us_timer.h"
extern S8 wrt_sys_get_cur_gps_status(void);
extern void city_easy_send_by_sos(void);
extern U8 wrt_sys_get_baojing_status(void);
#endif /* __GGT_TASK__ */
#if defined(__NPR_TTS__)
extern char Npr_Tts_is_playing(void);
extern int  Npr_Ttsplayer_playtextw(char* pszText,void (*end_call)(void*info));
extern void Npr_Tts_play_stop(void);
#endif

// baiwenlin 20130902  清除左软键事件
void mmi_idle_clear_lsk_handle(void)
{
	ClearKeyHandler(KEY_LSK,KEY_EVENT_DOWN);
	ClearKeyHandler(KEY_LSK,KEY_EVENT_UP);
	ClearKeyHandler(KEY_LSK,KEY_EVENT_LONG_PRESS);
}

void mmi_set_sos_status(U8 s)
{
	sos_status = s;
}
U8 mmi_get_sos_status(void)
{
	return sos_status;
}
// baiwenlin 20130913  SOS拨号是否被接听
void mmi_set_sos_call_alert(U8 s)
{
	sos_call_alert = s;
}
U8 mmi_get_sos_call_alert(void)
{
	return sos_call_alert;
}
void mmi_sos_null_and_goback_idlescreen(void)
{
	StopTimer(MMI_MAKE_SOS_EMPTY_TIMER);
	mmi_set_sos_status(0);
	mmi_show_idle_screen();
}
void mmi_show_sos_screen(void)
{
	gdi_handle mmi_base_layer;
	S32 str_w,str_h;
	S32 x,y;
	
#if defined(__MMI_MAINLCD_128X36__)
	gdi_layer_get_base_handle(&mmi_base_layer);

	gdi_layer_lock_frame_buffer();
	gdi_layer_push_and_set_active(mmi_base_layer);
	gdi_layer_clear(GDI_COLOR_BLACK);

	if(sos_status == 1)
	{
		gdi_image_draw_id(0, 0, IMG_GLOBAL_BW_SOS);
	}
	else 
	{
		gui_measure_string(get_string(STR_CITY_NO_SOS),&str_w,&str_h);
		x = (UI_device_width - str_w)/2;
		y = (UI_device_height - str_h)/2;
		gui_set_text_color(gui_color(255,255,255));
		gui_move_text_cursor(x,y);
		gui_print_text(get_string(STR_CITY_NO_SOS));
	}
	
	gdi_layer_pop_and_restore_active();
	gdi_layer_unlock_frame_buffer();
	gdi_layer_blt(mmi_base_layer,0,0,0,0,0,UI_DEVICE_WIDTH,UI_DEVICE_HEIGHT);

	if(sos_status != 1)
	{
		StartTimer(MMI_MAKE_SOS_EMPTY_TIMER,2000,mmi_sos_null_and_goback_idlescreen);
	}
#endif /* __MMI_MAINLCD_128X64__ */
}
U8 sos_call_count = 0;
void mmi_idle_stop_remake_sos_call(void)
{
	StopTimer(MMI_MAKE_SOS_CALL_TIMER);
}
void mmi_idle_start_remake_sos_call(void)
{
#if defined(CUSTOMER_NAME_B603)
	if(wrt_sys_get_baojing_status() == 1&& sos_call_count<2)
	{
		sos_call_count ++;
		mmi_idle_stop_remake_sos_call();
		StartTimer(MMI_MAKE_SOS_CALL_TIMER,3000,mmi_idle_make_sos_call);
	}
#endif /* CUSTOMER_NAME_B603 */
}

void mmi_idle_make_sos_call(void)
{
	S8 mynuber[] = {"13530354143"};
	U8 ucs_nuber[41];

	mmi_idle_stop_remake_sos_call();
/*	
	mmi_set_sos_status(1);
	mmi_set_sos_call_alert(0);
	memset(ucs_nuber,0,sizeof(ucs_nuber));
	mmi_asc_to_ucs2((S8*)ucs_nuber,(S8*)mynuber);
	MakeCall((S8*)ucs_nuber);
*/
	city_easy_send_by_sos();
	if(mmi_get_sos_status() != 0)
	{
		mmi_show_sos_screen();
		mmi_idle_clear_lsk_handle();
	}
}
kal_bool mmi_get_gps_status(void)
{
	S8 status = 0;
#if defined(__GGT_TASK__)
	status = wrt_sys_get_cur_gps_status();
	if(status == 'A')
		return KAL_TRUE;
#endif /* __GGT_TASK__ */
	return KAL_FALSE;
}

/*
void mmi_idle_redraw(void)
{
	gui_cancel_timer(mmi_idle_redraw);
	is_ok = 0;
}
*/


//#include "dcl_adc.h"
//extern kal_bool bmt_get_adc_channel_voltage(DCL_ADC_CHANNEL_TYPE_ENUM ch, kal_uint32 *voltage);


void mmi_disp_idlescreen(void)
{
	gdi_handle mmi_base_layer;
	MYTIME curr_time;
	kal_uint8 idle_h0,idle_m0,idle_h1,idle_m1;
	U32 start_x = 8,gap_x = 3,gap_y = 2;
	S32 img_w,img_h;
	S32 dot_w,dot_h;
	S32 gps_img_w,gps_img_h;
	S32 x,y;
	U16 signal_img_id = 0;
	U16 bat_img_id = 0;
	U16 gps_status_img = 0;
/*	
	U8 asc_str[10];
	U8 ucs2_str[20];
	U32 voltage;
	memset(asc_str,0,sizeof(asc_str));
	memset(ucs2_str,0,sizeof(ucs2_str));

	bmt_get_adc_channel_voltage(DCL_VBAT_ADC_CHANNEL, &voltage);
	sprintf(asc_str,"%d",voltage);
	mmi_asc_to_ucs2((S8*)ucs2_str,(S8*)asc_str);
*/

	//if(0 == is_ok)
	{
		//is_ok ++;
		GetDateTime(&curr_time);

		idle_h0 = curr_time.nHour/10;
		idle_h1 = curr_time.nHour%10;
		idle_m0 = curr_time.nMin/10;
		idle_m1 = curr_time.nMin%10;

		gui_measure_image(get_image(IMG_GLOBAL_BW_0),&img_w,&img_h);
		gui_measure_image(get_image(IMG_GLOBAL_BW_DOT),&dot_w,&dot_h);
		
		gdi_layer_get_base_handle(&mmi_base_layer);

		gdi_layer_lock_frame_buffer();
		gdi_layer_push_and_set_active(mmi_base_layer);
		gdi_layer_clear(GDI_COLOR_BLACK);
/*
		if(0)
		{
			gui_set_text_color(gui_color(255,255,255));
			gui_move_text_cursor(0,0);
			gui_print_text((UI_string_type)ucs2_str);
		}
		else
*/		
		{
		// baiwenlin 20130903  时间显示
		x = start_x;
		y = (UI_device_height - img_h)>>1;
		gdi_image_draw_id(x, y, IMG_GLOBAL_BW_0+idle_h0);
		x += img_w+gap_x;
		gdi_image_draw_id(x, y, IMG_GLOBAL_BW_0+idle_h1);
		
		x += img_w+gap_x;
		y = (UI_device_height - dot_h)>>1;
		gdi_image_draw_id(x, y, IMG_GLOBAL_BW_DOT);
		
		x += dot_w+gap_x;
		y = (UI_device_height - img_h)>>1;
		gdi_image_draw_id(x, y, IMG_GLOBAL_BW_0+idle_m0);
		x += img_w+gap_x;
		gdi_image_draw_id(x, y, IMG_GLOBAL_BW_0+idle_m1);

		// baiwenlin 20130903  信号显示
		if(mmi_bootup_is_sim_valid())
		{
			switch(wgui_status_icon_bar_icons[STATUS_ICON_SIGNAL_STRENGTH].state)
			{
			/*
				case 0:
					signal_img_id = IMG_GLOBAL_BW_NO_SIM_CARD;
					break;
				case 1:
					signal_img_id = IMG_GLOBAL_BW_SIGNAL1;
					break;
			*/		
				case 0:
				case 1:
				case 2:
					signal_img_id = IMG_GLOBAL_BW_SIGNAL2;
					break;
				case 3:
					signal_img_id = IMG_GLOBAL_BW_SIGNAL3;
					break;
				case 4:
				case 5:
					signal_img_id = IMG_GLOBAL_BW_SIGNAL4;
					break;
				default:
					signal_img_id = IMG_GLOBAL_BW_SIGNAL1;
					break;
			}
		}
		else
		{
			signal_img_id = IMG_GLOBAL_BW_NO_SIM_CARD;
		}
		gui_measure_image(get_image(signal_img_id),&img_w,&img_h);
		x = UI_DEVICE_WIDTH - img_w - gap_x;
		y = gap_y + 2;
		gdi_image_draw_id(x, y, signal_img_id);

		// baiwenlin 20130903  电量显示
		if (srv_charbat_is_charging())
		{// baiwenlin 20130831  充电状态
			bat_img_id = IMG_GLOBAL_BW_BAT_ON_CHARGIMG;
			if(1 == g_charbat_context.ChargingComplete)
			{// baiwenlin 20130831  充电满状态
				bat_img_id = IMG_GLOBAL_BW_BAT_ON_FULL;
			}
		}
		else
		{
			switch(wgui_status_icon_bar_icons[STATUS_ICON_BATTERY_STRENGTH].state)
			{
				case 0:
					bat_img_id = IMG_GLOBAL_BW_BAT1;
					break;
				case 1:
					bat_img_id = IMG_GLOBAL_BW_BAT2;
					break;
				case 2:
					bat_img_id = IMG_GLOBAL_BW_BAT3;
					break;
				case 3:
					bat_img_id = IMG_GLOBAL_BW_BAT4;
					break;
				default:
					bat_img_id = IMG_GLOBAL_BW_BAT1;
					break;
			}
		}
		gui_measure_image(get_image(bat_img_id),&img_w,&img_h);
		x = UI_DEVICE_WIDTH - img_w - gap_x;
		y = UI_DEVICE_HEIGHT - img_h - gap_y;
		gdi_image_draw_id(x, y, bat_img_id);

		// baiwenlin 20130903  GPS状态显示
		if(mmi_bootup_is_sim_valid())
		{
			if(mmi_get_gps_status())
			{
				gps_status_img = IMG_GLOBAL_BW_GPS_ON;
			}
			else
			{
				gps_status_img = IMG_GLOBAL_BW_GPS_OFF;
			}
			gui_measure_image(get_image(gps_status_img),&gps_img_w,&gps_img_h);
			x -= (gps_img_w + gap_x);
			y = gap_y;
			gdi_image_draw_id(x, y, gps_status_img);
		}
		}

		gdi_layer_pop_and_restore_active();

		gdi_layer_unlock_frame_buffer();

		gdi_layer_blt(mmi_base_layer,0,0,0,0,0,UI_DEVICE_WIDTH,UI_DEVICE_HEIGHT);
		
		//gui_start_timer(5000,mmi_idle_redraw);
	}

}
#if defined(__MMI_MAINLCD_128X64__)

U8 g_idle_sleep = 0;

extern BOOL is_infrared_screen;
extern kal_bool tts_play_status;
#if defined(__CITY_EASY_WEB_DOG__)
extern U8 g_is_shut_down;
extern U8 radar_power;
#endif /* __CITY_EASY_WEB_DOG__ */
void mmi_edog_set_screen_id(MMI_EGOD_SCR_ID edog_screen)
{
	G_EDOG_SCREEN = edog_screen;
}
void mmi_edog_draw_string_bg(S32 x1, S32 y1, S32 x2, S32 y2)
{
    gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_TRANSPARENT);
}
void mmi_edog_string_scroll_handle(void)
{
    gui_handle_scrolling_text(&edog_string_info);
}
void mmi_disp_edog_string_info(void)
{
	S32 str_w,str_h;
	S32 x_offset,y_offset;
	color text_n;
	color text_b;
	//U8 asc_str[]={" "};
	UI_string_type ucs_str;
	U8 tem_str[256];


	memset(scrolling_string,0,sizeof(scrolling_string));
	//memset(ucs_str,0,sizeof(ucs_str));
	ucs_str = get_string(STR_GGT_STRING_EDOG_TEST);
	//ucs_str = get_string(STR_GLOBAL_OK);
	//mmi_asc_to_ucs2((S8*)scrolling_string,(S8*)ucs_str);
	mmi_ucs2cpy((S8*)scrolling_string,(S8*)ucs_str);
	gui_measure_string((UI_string_type)scrolling_string,&str_w,&str_h);
	text_n = gui_color(255,255,255);
	text_b = gui_color(0,0,0);
	
	if(str_w > UI_device_width)
	{
		gui_create_scrolling_text(
		    &edog_string_info,
		    0,
		    UI_device_height - str_h -1,
		    UI_device_width,
		    str_h,
		    (UI_string_type)ucs_str,
		    mmi_edog_string_scroll_handle,
		    mmi_edog_draw_string_bg,
		    text_n,
		    text_b);
		edog_string_info.text_font = MMI_medium_font;
		gui_show_scrolling_text(&edog_string_info);

	}
	else
	{
		gui_set_text_color(text_n);
		gui_move_text_cursor(0,UI_device_height - str_h -1);
		gui_print_text((UI_string_type)scrolling_string);
	}
}
S32 edog_limit_speed = 0;
S32 edog_distance = 0;
void mmi_disp_edog_speed_info(void)
{
	S32 img_w,img_h;
	S32 img_w1,img_h1;
	U32 start_x = 1,gap_x = 1,gap_y = 2,sp_x = 5;
	S32 x,y;
	S32 curr_speed = edog_limit_speed;
	S32 limit_speed = edog_distance;
	S32 a,b,c,tem_data;
	S32 xs_x,xs_y;
	S32 km_y = 0;
	S32 km_x = 0;

	y = 18;
	x = 0;
	gui_measure_image(get_image(IMG_GLOBAL_BW_SPEED),&img_w,&img_h);
	gdi_image_draw_id(x, y, IMG_GLOBAL_BW_SPEED);

	a=curr_speed/100;
	tem_data = curr_speed%100;
	b = tem_data/10;
	c = tem_data%10;

	x += img_w+gap_x;
	if(a != 0)
	gdi_image_draw_id(x, y, IMG_GLOBAL_BW_L0+a);
	
	gui_measure_image(get_image(IMG_GLOBAL_BW_L0),&img_w,&img_h);
	x += img_w+gap_x;
	gdi_image_draw_id(x, y, IMG_GLOBAL_BW_L0+b);
	x += img_w+gap_x;
	gdi_image_draw_id(x, y, IMG_GLOBAL_BW_L0+c);

	gui_measure_image(get_image(IMG_GLOBAL_BW_DANWEI),&img_w1,&img_h1);
	km_y = y + img_h + gap_y;
	km_x = x - img_w1;
	gdi_image_draw_id(km_x, km_y, IMG_GLOBAL_BW_DANWEI);

	gui_measure_image(get_image(IMG_GLOBAL_BW_KUANG),&img_w,&img_h);

	xs_x = UI_device_width - img_w-1;
	xs_y = 16;
	gdi_image_draw_id(xs_x, xs_y, IMG_GLOBAL_BW_KUANG);
	
	gui_measure_image(get_image(IMG_GLOBAL_BW_DISTANCE),&img_w1,&img_h1);
	
	gdi_image_draw_id(xs_x+2, xs_y+(img_h - img_h1)/2, IMG_GLOBAL_BW_DISTANCE);
	
	a=limit_speed/100;
	tem_data = limit_speed%100;
	b = tem_data/10;
	c = tem_data%10;
	
	gui_measure_image(get_image(IMG_GLOBAL_BW_M0),&img_w,&img_h);
	xs_x += img_w1 + gap_x + 1;
	if(a != 0)
	gdi_image_draw_id(xs_x, xs_y+2, IMG_GLOBAL_BW_M0+a);
	xs_x += img_w + gap_x;
	gdi_image_draw_id(xs_x, xs_y+2, IMG_GLOBAL_BW_M0+b);
	xs_x += img_w + gap_x;
	gdi_image_draw_id(xs_x, xs_y+2, IMG_GLOBAL_BW_M0+c);
	
	gui_measure_image(get_image(IMG_GLOBAL_BW_METER),&img_w1,&img_h1);
	gui_measure_image(get_image(IMG_GLOBAL_BW_KUANG),&img_w,&img_h);
	gdi_image_draw_id(UI_device_width-img_w1-3, xs_y+img_h-img_h1 -3, IMG_GLOBAL_BW_METER);
	
}

void mmi_disp_edog_distance_info(void)
{
	S32 img_w,img_h;
	S32 img_w1,img_h1;
	U32 start_x = 1,gap_x = 1,gap_y = 2,sp_x = 5;
	S32 x,y;
	S32 curr_dist = edog_distance;
	S32 limit_speed = edog_limit_speed;
	S32 a,b,c,tem_data;
	S32 xs_x,xs_y;
	S32 km_y = 0;
	S32 km_x = 0;

	y = 0;
	x = 0;
	//gui_wline(x,y,UI_DEVICE_WIDTH,y,gui_color(255,255,255),1);
	gui_measure_image(get_image(IMG_GLOBAL_BW_DISTANCE_H),&img_w1,&img_h1);
	gdi_image_draw_id(x, y+5, IMG_GLOBAL_BW_DISTANCE_H);

	a=curr_dist/100;
	tem_data = curr_dist%100;
	b = tem_data/10;
	c = tem_data%10;

	x +=  img_w1+10;

	if(curr_dist == 0)
	{
		gui_measure_image(get_image(IMG_GLOBAL_BW_HCQ),&img_w,&img_h);
		gdi_image_draw_id(x+10, y+5, IMG_GLOBAL_BW_HCQ);
	}
	else
	{
		gui_measure_image(get_image(IMG_GLOBAL_BW_L0),&img_w,&img_h);
		
		if(a != 0)
		gdi_image_draw_id(x, y, IMG_GLOBAL_BW_L0+a);
		
		x += img_w+gap_x;
		gdi_image_draw_id(x, y, IMG_GLOBAL_BW_L0+b);
		x += img_w+gap_x;
		gdi_image_draw_id(x, y, IMG_GLOBAL_BW_L0+c);
		
		//gui_measure_image(get_image(IMG_GLOBAL_BW_METER),&img_w,&img_h);
		x += img_w+gap_x;
		gdi_image_draw_id(x, y+8, IMG_GLOBAL_BW_METER);
	}
	
/*
	gui_measure_image(get_image(IMG_GLOBAL_BW_DANWEI),&img_w1,&img_h1);
	km_y = y + img_h + gap_y;
	km_x = x - img_w1;
	gdi_image_draw_id(km_x, km_y, IMG_GLOBAL_BW_DANWEI);
*/
	//gui_measure_image(get_image(IMG_GLOBAL_BW_KUANG),&img_w,&img_h);

	xs_x = 0;
	xs_y = 32;
	//gdi_image_draw_id(xs_x, xs_y, IMG_GLOBAL_BW_KUANG);
	
	gui_measure_image(get_image(IMG_GLOBAL_BW_LIMIT_SPEED_H),&img_w1,&img_h1);
	
	gdi_image_draw_id(xs_x, xs_y, IMG_GLOBAL_BW_LIMIT_SPEED_H);
	
	a=limit_speed/100;
	tem_data = limit_speed%100;
	b = tem_data/10;
	c = tem_data%10;
	
	xs_x += img_w1 + 15;
	
	gui_measure_image(get_image(IMG_GLOBAL_BW_M0),&img_w,&img_h);
	if(a != 0)
	gdi_image_draw_id(xs_x, xs_y, IMG_GLOBAL_BW_M0+a);
	
	xs_x += img_w + gap_x;
	gdi_image_draw_id(xs_x, xs_y, IMG_GLOBAL_BW_M0+b);
	xs_x += img_w + gap_x;
	gdi_image_draw_id(xs_x, xs_y, IMG_GLOBAL_BW_M0+c);
	//xs_x += img_w+gap_x;
	gui_measure_image(get_image(IMG_GLOBAL_BW_KM_H),&img_w,&img_h);
	gdi_image_draw_id(UI_DEVICE_WIDTH - img_w, xs_y+6, IMG_GLOBAL_BW_KM_H);
		
}

void mmi_disp_edog_status_info(void)
{
	S32 img_w,img_h;
	U32 start_x = 1,gap_x = 1,gap_y = 2,sp_x = 5;
	S32 x,y;
	U16 signal_img_id = 0;
	U16 bat_img_id = 0;
	U16 gps_status_img = 0;
	S32 gps_img_w,gps_img_h;
	
// baiwenlin 20130903  电量显示
if (srv_charbat_is_charging())
{// baiwenlin 20130831  充电状态
	bat_img_id = IMG_GLOBAL_BW_BAT_ON_CHARGIMG;
	if(1 == g_charbat_context.ChargingComplete)
	{// baiwenlin 20130831  充电满状态
		bat_img_id = IMG_GLOBAL_BW_BAT_ON_FULL;
	}
}
else
{
	switch(wgui_status_icon_bar_icons[STATUS_ICON_BATTERY_STRENGTH].state)
	{
		case 0:
			bat_img_id = IMG_GLOBAL_BW_BAT1;
			break;
		case 1:
			bat_img_id = IMG_GLOBAL_BW_BAT2;
			break;
		case 2:
			bat_img_id = IMG_GLOBAL_BW_BAT3;
			break;
		case 3:
			bat_img_id = IMG_GLOBAL_BW_BAT4;
			break;
		default:
			bat_img_id = IMG_GLOBAL_BW_BAT1;
			break;
	}
}
gui_measure_image(get_image(bat_img_id),&img_w,&img_h);
x = UI_DEVICE_WIDTH - img_w - gap_x;
y = UI_device_height - img_h;
gdi_image_draw_id(x, y, bat_img_id);

// baiwenlin 20130903  信号显示
if(mmi_bootup_is_sim_valid())
{
	switch(wgui_status_icon_bar_icons[STATUS_ICON_SIGNAL_STRENGTH].state)
	{
		case 0:
			signal_img_id = IMG_GLOBAL_BW_NO_SIM_CARD;
			break;
		case 1:
			signal_img_id = IMG_GLOBAL_BW_SIGNAL1;
			break;
		case 2:
			signal_img_id = IMG_GLOBAL_BW_SIGNAL2;
			break;
		case 3:
			signal_img_id = IMG_GLOBAL_BW_SIGNAL3;
			break;
		case 4:
		case 5:
			signal_img_id = IMG_GLOBAL_BW_SIGNAL4;
			break;
		default:
			signal_img_id = IMG_GLOBAL_BW_SIGNAL1;
			break;
	}
}
else
{
	signal_img_id = IMG_GLOBAL_BW_NO_SIM_CARD;
}
gui_measure_image(get_image(signal_img_id),&img_w,&img_h);
x -=(img_w + gap_x);
gdi_image_draw_id(x, y, signal_img_id);


// baiwenlin 20130903  GPS状态显示
if(mmi_bootup_is_sim_valid())
{
	if(mmi_get_gps_status())
	{
		gps_status_img = IMG_GLOBAL_BW_GPS_ON;
	}
	else
	{
		gps_status_img = IMG_GLOBAL_BW_GPS_OFF;
	}
	gui_measure_image(get_image(gps_status_img),&gps_img_w,&gps_img_h);
	x -= (gps_img_w + gap_x);
	gdi_image_draw_id(x, y, gps_status_img);

	if(wrt_gprs_is_soc_connect() == 1)
	{
		gps_status_img = IMG_GLOBAL_BW_CONNECT;
		gui_measure_image(get_image(gps_status_img),&gps_img_w,&gps_img_h);
		x -= (gps_img_w + gap_x);
		gdi_image_draw_id(x, y+5, gps_status_img);
	}

	
}

	if(radar_power == 1)
	{
		gps_status_img = IMG_GLOBAL_BW_RADAR;
		gui_measure_image(get_image(gps_status_img),&gps_img_w,&gps_img_h);
		x -= (gps_img_w + gap_x);
		gdi_image_draw_id(x, UI_device_height - gps_img_h, gps_status_img);
	}
	//gui_wline(0,y+gps_img_h,UI_DEVICE_WIDTH,y+gps_img_h,gui_color(255,255,255),1);

	
}

void mmi_disp_edog_datetime_info(void)
{
	MYTIME curr_time;
	S32 img_w,img_h;
	S32 dot_w,dot_h;
	S32 fenhao_w,fenhao_h;
	kal_uint8 idle_h0,idle_m0,idle_h1,idle_m1;
	U32 start_x = 0,gap_x = 1,gap_y = 2,sp_x = 4,gap = 4;
	S32 x,y;
	U16 cur_year;
	kal_uint8 idle_d0,idle_mo0,idle_y0,idle_d1,idle_mo1,idle_y1;
	
	GetDateTime(&curr_time);
	idle_h0 = curr_time.nHour/10;
	idle_h1 = curr_time.nHour%10;
	idle_m0 = curr_time.nMin/10;
	idle_m1 = curr_time.nMin%10;
	idle_d0 = curr_time.nDay/10;
	idle_d1 = curr_time.nDay%10;
	idle_mo0 = curr_time.nMonth/10;
	idle_mo1 = curr_time.nMonth%10;
	cur_year = curr_time.nYear%100;
	idle_y0 = cur_year/10;
	idle_y1 = cur_year%10;

	x = start_x;
	gui_measure_image(get_image(IMG_GLOBAL_BW_0),&img_w,&img_h);
	gui_measure_image(get_image(IMG_GLOBAL_BW_DOT),&dot_w,&dot_h);
	gui_measure_image(get_image(IMG_GLOBAL_BW_FENHAO),&fenhao_w,&fenhao_h);
	y = UI_device_height - img_h;

	//year
	gdi_image_draw_id(x, y, IMG_GLOBAL_BW_0+2);
	x += img_w+gap_x;
	gdi_image_draw_id(x, y, IMG_GLOBAL_BW_0);	
	x += img_w+gap_x;
	gdi_image_draw_id(x, y, IMG_GLOBAL_BW_0+idle_y0);	
	x += img_w+gap_x;
	gdi_image_draw_id(x, y, IMG_GLOBAL_BW_0+idle_y1);	
	
	x += img_w;
	gdi_image_draw_id(x, y+img_h-dot_h, IMG_GLOBAL_BW_DOT);
	//month
	x += dot_w;
	gdi_image_draw_id(x, y, IMG_GLOBAL_BW_0+idle_mo0);
	x += img_w+gap_x;
	gdi_image_draw_id(x, y, IMG_GLOBAL_BW_0+idle_mo1);
	
	x += img_w;
	gdi_image_draw_id(x, y+img_h-dot_h, IMG_GLOBAL_BW_DOT);
	//day
	x += dot_w;
	gdi_image_draw_id(x, y, IMG_GLOBAL_BW_0+idle_d0);
	x += img_w+gap_x;
	gdi_image_draw_id(x, y, IMG_GLOBAL_BW_0+idle_d1);
	
	//if(G_EDOG_SCREEN == MMI_EDOG_SCREEN_IDLE)
		return;
	
	//hour
	x += img_w+sp_x+gap_x;
	gdi_image_draw_id(x, y, IMG_GLOBAL_BW_0+idle_h0);
	x += img_w+gap_x;
	gdi_image_draw_id(x, y, IMG_GLOBAL_BW_0+idle_h1);

	x += img_w;
	gdi_image_draw_id(x, y+img_h-fenhao_h, IMG_GLOBAL_BW_FENHAO);
	//min
	x += fenhao_w;
	gdi_image_draw_id(x, y, IMG_GLOBAL_BW_0+idle_m0);
	x += img_w+gap_x;
	gdi_image_draw_id(x, y, IMG_GLOBAL_BW_0+idle_m1);

}


void mmi_disp_edog_time_info(void)
{
	MYTIME curr_time;
	S32 img_w,img_h;
	S32 dot_w,dot_h;
	S32 fenhao_w,fenhao_h;
	kal_uint8 idle_h0,idle_m0,idle_h1,idle_m1;
	U32 start_x = 0,gap_x = 4,gap_y = 2,sp_x = 6,gap = 4;
	S32 x,y;
	U16 cur_year;
	kal_uint8 idle_d0,idle_mo0,idle_y0,idle_d1,idle_mo1,idle_y1;
	static U16 signShow=0,signEntry=0;
	static kal_uint32 curr_frc, latest_us;

       if(!signEntry)
       	{
       	    signEntry = 1;
           curr_frc = ust_get_current_time();
       	}
	   
       latest_us = ust_get_current_time();
	if(ust_get_duration(curr_frc, latest_us)>=1000)
	{
           curr_frc = ust_get_current_time();
           signShow = !signShow;
	}
	
	GetDateTime(&curr_time);
	idle_h0 = curr_time.nHour/10;
	idle_h1 = curr_time.nHour%10;
	idle_m0 = curr_time.nMin/10;
	idle_m1 = curr_time.nMin%10;

	gui_measure_image(get_image(IMG_GLOBAL_BW_L0),&img_w,&img_h);
	gui_measure_image(get_image(IMG_GLOBAL_BW_FENHAO_L),&dot_w,&dot_h);

	//hour
	y = (UI_device_height/2) - (img_h/2) - 10;
	x = (UI_device_width -4*img_w-dot_w - 4*gap_x)/2;
	gdi_image_draw_id(x, y, IMG_GLOBAL_BW_L0+idle_h0);
	x +=img_w+gap_x; 
	gdi_image_draw_id(x, y, IMG_GLOBAL_BW_L0+idle_h1);
 
	x +=img_w+gap_x; 
	if(signShow)
	{
            gdi_image_draw_id(x, y, IMG_GLOBAL_BW_FENHAO_L);
	}
	
	//min
	x +=dot_w+gap_x; 
	gdi_image_draw_id(x, y, IMG_GLOBAL_BW_L0+idle_m0);
	x +=img_w+gap_x; 
	gdi_image_draw_id(x, y, IMG_GLOBAL_BW_L0+idle_m1);
	
}

void mmi_disp_edog_idlescreen(void)
{
	gdi_handle mmi_base_layer;
	MYTIME curr_time;
	kal_uint8 idle_h0,idle_m0,idle_h1,idle_m1;
	U32 start_x = 8,gap_x = 3,gap_y = 2;
	S32 img_w,img_h;
	S32 dot_w,dot_h;
	S32 gps_img_w,gps_img_h;
	S32 x,y;
	U16 signal_img_id = 0;
	U16 bat_img_id = 0;
	U16 gps_status_img = 0;

	gdi_layer_get_base_handle(&mmi_base_layer);

	gdi_layer_lock_frame_buffer();
	gdi_layer_push_and_set_active(mmi_base_layer);
	gdi_layer_clear(GDI_COLOR_BLACK);
	//show time
	mmi_disp_edog_time_info();
	//show status
	mmi_disp_edog_status_info();
	//show date
	mmi_disp_edog_datetime_info();
	
	//show speed
	//mmi_disp_edog_speed_info();
	//show string
	//mmi_disp_edog_string_info();
	gdi_layer_pop_and_restore_active();
	gdi_layer_unlock_frame_buffer();

	gdi_layer_blt(mmi_base_layer,0,0,0,0,0,UI_DEVICE_WIDTH,UI_DEVICE_HEIGHT);
}

U16 w_test[]={0x4ECA,0x5929,0x5929,0x6C14,0x5F88,0x597D,0xFF0C,0x51FA,
0x95E8,0x4E0D,0x7528,0x5E26,0x4F1E,0x4ECA,0x5929,0x5929,0x6C14,0x5F88,0x597D,0xFF0C,0x51FA,
0x95E8,0x4E0D,0x7528,0x5E26,0x4F1E,0x4F1E,0x4ECA,0x5929,0x5929,0x6C14,0x5F88,0x597D,0xFF0C,0x51FA,
0x95E8,0x4E0D,0x7528,0x5E26,0x4F1E,0x00};

U8 show_buffer[512];
U8 num_buffer[128];
#define MMI_PAGE_STR_LEN_MAX 64
U8 page_buffer[MMI_PAGE_STR_LEN_MAX];
U8 buffer_page_index = 0;
U8 scroll_page_start = 0;
void mmi_disp_edog_weather(void)
{
	S32 buf_len = 0;
	U8 *buff_p = (PU8)show_buffer;

	if(MMI_EDOG_SCREEN_STRING != G_EDOG_SCREEN)
	{
		scroll_page_start = 0;
		StopTimer(GGT_TIMER_ID_SHOW_STR_BUFFER);
		return;
	}

	buf_len = mmi_ucs2strlen((PU8)buff_p);
	
	if(buf_len < (MMI_PAGE_STR_LEN_MAX/2))
	{
		ShowCategory7Screen(0, 0, 0, 0,STR_GLOBAL_BACK, IMG_GLOBAL_BACK, buff_p, NULL);
	}
	else
	{
		StopTimer(GGT_TIMER_ID_SHOW_STR_BUFFER);
		memset(page_buffer,0,sizeof(page_buffer));
		

		if(buffer_page_index*(MMI_PAGE_STR_LEN_MAX/2) < buf_len)
		{
			mmi_ucs2ncpy(page_buffer,buff_p+buffer_page_index*MMI_PAGE_STR_LEN_MAX,(MMI_PAGE_STR_LEN_MAX/2));
			scroll_page_start = 1;
			StartTimer(GGT_TIMER_ID_SHOW_STR_BUFFER,8000,mmi_disp_edog_weather);
			buffer_page_index ++;
		}
		else
		{
			mmi_ucs2ncpy((S8*)page_buffer,(S8*)buff_p+buffer_page_index*MMI_PAGE_STR_LEN_MAX,(buffer_page_index*(MMI_PAGE_STR_LEN_MAX/2) - buf_len));
			StopTimer(GGT_TIMER_ID_SHOW_STR_BUFFER);
			scroll_page_start = 0;
		}

		if(mmi_ucs2strlen((S8*)page_buffer) != NULL)
		{
			ShowCategory7Screen(0, 0, 0, 0,STR_GLOBAL_BACK, IMG_GLOBAL_BACK, (PU8)page_buffer, NULL);
		}
		else
		{
		}
	}

}

void mmi_disp_edog_number(void)
{
	gdi_handle mmi_base_layer;

	U32 start_x = 8,gap_x = 3,gap_y = 2,gap = 4;
	S32 img_w,img_h;
	S32 img_w1,img_h1;
	S32 x,y;
	S32 x1,y1;
	S32 curr_value;
	S32 a,b,c,tem_data;
	U8 valString[128];
	U8 *next_num = NULL;
	S32 dist_value = 0;
	
	memset(valString, 0x00, sizeof(valString));
	mmi_ucs2_to_asc((CHAR *)valString, (CHAR *)num_buffer);
	curr_value = atoi(valString);
/*	
	next_num = strstr((CHAR *)valString,",");
	edog_limit_speed = curr_value;
	
	edog_distance = 0;
	if(NULL != next_num)
	{
		next_num +=1;
		dist_value = atoi(next_num);
		edog_distance = dist_value;
	}
*/	

	gdi_layer_get_base_handle(&mmi_base_layer);

	gdi_layer_lock_frame_buffer();
	gdi_layer_push_and_set_active(mmi_base_layer);
	gdi_layer_clear(GDI_COLOR_BLACK);
	//show status
	mmi_disp_edog_status_info();
	//show datetime
	mmi_disp_edog_datetime_info();
	
#if (0)
	//show status
	mmi_disp_edog_status_info();
	//show datetime
	mmi_disp_edog_datetime_info();
	//show speed
	//mmi_disp_edog_speed_info();
	mmi_disp_edog_distance_info();
#else /*1*/
	a=curr_value/100;
	tem_data = curr_value%100;
	b = tem_data/10;
	c = tem_data%10;



	gui_measure_image(get_image(IMG_GLOBAL_BW_SPEED),&img_w1,&img_h1);
	x1 = 6;
	y = (UI_device_height - img_h1 -16)/2;
	gdi_image_draw_id(x, y, IMG_GLOBAL_BW_SPEED);
	
	gui_measure_image(get_image(IMG_GLOBAL_BW_L0),&img_w,&img_h);
	y = (UI_device_height - img_h -16)/2;
	
	if(a != 0)
	{
		x = (UI_device_width/2)-(img_w/2)-img_w-gap;
		gdi_image_draw_id(x, y, IMG_GLOBAL_BW_L0+a);

		x = (UI_device_width/2)-(img_w/2);
		gdi_image_draw_id(x, y, IMG_GLOBAL_BW_L0+b);

		x = (UI_device_width/2)+(img_w/2)+gap;
		gdi_image_draw_id(x, y, IMG_GLOBAL_BW_L0+c);
	}
	else
	{
		x = (UI_device_width/2)-img_w-gap;
		gdi_image_draw_id(x, y, IMG_GLOBAL_BW_L0+b);
		x = (UI_device_width/2)+2;
		gdi_image_draw_id(x, y, IMG_GLOBAL_BW_L0+c);
	}
#endif /* 1 */

	gdi_layer_pop_and_restore_active();
	gdi_layer_unlock_frame_buffer();

	gdi_layer_blt(mmi_base_layer,0,0,0,0,0,UI_DEVICE_WIDTH,UI_DEVICE_HEIGHT);
}

void mmi_disp_edog_distance(void)
{
	gdi_handle mmi_base_layer;

	U32 start_x = 8,gap_x = 3,gap_y = 2,gap = 4;
	S32 img_w,img_h;
	S32 x,y;
	S32 curr_value;
	S32 a,b,c,tem_data;
	U8 valString[128];
	U8 *next_num = NULL;
	S32 dist_value = 0;
	
	memset(valString, 0x00, sizeof(valString));
	mmi_ucs2_to_asc((CHAR *)valString, (CHAR *)num_buffer);
	curr_value = atoi(valString);
	
	next_num = strstr((CHAR *)valString,",");
	edog_limit_speed = curr_value;
	
	edog_distance = 0;
	if(NULL != next_num)
	{
		next_num +=1;
		dist_value = atoi(next_num);
		edog_distance = dist_value;
	}
	

	gdi_layer_get_base_handle(&mmi_base_layer);

	gdi_layer_lock_frame_buffer();
	gdi_layer_push_and_set_active(mmi_base_layer);
	gdi_layer_clear(GDI_COLOR_BLACK);
	
	//show status
	mmi_disp_edog_status_info();
	//show datetime
	mmi_disp_edog_datetime_info();
	//show speed
	//mmi_disp_edog_speed_info();
	mmi_disp_edog_distance_info();

	gdi_layer_pop_and_restore_active();
	gdi_layer_unlock_frame_buffer();

	gdi_layer_blt(mmi_base_layer,0,0,0,0,0,UI_DEVICE_WIDTH,UI_DEVICE_HEIGHT);
}

void mmi_disp_edog_img(void)
{
	gdi_handle mmi_base_layer;

	U32 start_x = 8,gap_x = 3,gap_y = 2,gap = 4;
	S32 img_w,img_h;
	S32 x,y;
	U16 img_id = edog_img_id;

	

	gdi_layer_get_base_handle(&mmi_base_layer);

	gdi_layer_lock_frame_buffer();
	gdi_layer_push_and_set_active(mmi_base_layer);
	gdi_layer_clear(GDI_COLOR_BLACK);
	
	//show status
	mmi_disp_edog_status_info();
	//show datetime
	mmi_disp_edog_datetime_info();
	

	gui_measure_image(get_image(img_id),&img_w,&img_h);

	x = (UI_device_width - img_w)/2;
	y = (UI_device_height- img_h)/2-10;

	gdi_image_draw_id(x,y,img_id);
	
	gdi_layer_pop_and_restore_active();
	gdi_layer_unlock_frame_buffer();

	gdi_layer_blt(mmi_base_layer,0,0,0,0,0,UI_DEVICE_WIDTH,UI_DEVICE_HEIGHT);
}
#if 1//defined(__CITY_EASY_OBD__)
U8 obd_info_index = 0xff;
#if defined(__CITY_EASY_OBD__)
city_obd_data g_obd_data[MAX_OBD_DATA_ID];
#endif /* __CITY_EASY_OBD__ */
U8 obd_value_count = 0;
void mmi_disp_edog_obd_info_prev(void)
{
	char a_str[]={0xa1,0x6c,0x9,0x67,0x4f,0x0,0x42,0x0,0x44,0x0,0x70,0x65,0x6e,0x63,0x0,0x0};//没有OBD数据
	
#if defined(__CITY_EASY_OBD__)
	if(obd_value_count == 0)
	{
		// baiwenlin 20131102  提示没有OBD数据
#if defined(__NPR_TTS__)
    if(tts_play_status)
    {
        Npr_Ttsplayer_playtextw(a_str,NULL);
    }
#endif /* __NPR_TTS__ */
		return;
	}
	if(obd_info_index == 0xff)
	{
		obd_info_index = 0;
	}
	else
	{
		obd_info_index -= 4;
		
		if(obd_info_index < 0)
		{
			obd_info_index = obd_value_count - obd_value_count%4;
		}
	
	}
#else /*__CITY_EASY_OBD__*/
	if(obd_info_index == 0)
	{
		obd_info_index = 3;
	}
	else if(obd_info_index == 3)
	{
		obd_info_index = 2;
	}
	else if(obd_info_index == 2)
	{
		obd_info_index = 1;
	}
	else
	{
		obd_info_index = 0;
	}
#endif /* __CITY_EASY_OBD__ */
	
	G_EDOG_SCREEN = MMI_EDOG_SCREEN_OBD;

	is_infrared_screen = TRUE;
	mmi_entry_edog_screen();
}
void mmi_disp_edog_obd_info_next(void)
{
	char a_str[]={0xa1,0x6c,0x9,0x67,0x4f,0x0,0x42,0x0,0x44,0x0,0x70,0x65,0x6e,0x63,0x0,0x0};//没有OBD数据
#if defined(__CITY_EASY_OBD__)
	if(obd_value_count == 0)
	{
		// baiwenlin 20131102  提示没有OBD数据
#if defined(__NPR_TTS__)
    if(tts_play_status)
    {
        Npr_Ttsplayer_playtextw(a_str,NULL);
    }
#endif /* __NPR_TTS__ */
		return;
	}
	if(obd_info_index == 0xff)
	{
		obd_info_index = 0;
	}
	else
	{
		obd_info_index += 4;

		if(obd_info_index > obd_value_count)
		{
			obd_info_index = 0;
		}
	}
#else /*__CITY_EASY_OBD__*/
	if(obd_info_index == 0)
	{
		obd_info_index = 1;
	}
	else if(obd_info_index == 1)
	{
		obd_info_index = 2;
	}
	else if(obd_info_index == 2)
	{
		obd_info_index = 3;
	}
	else
	{
		obd_info_index = 0;
	}
#endif /* __CITY_EASY_OBD__ */
	
	G_EDOG_SCREEN = MMI_EDOG_SCREEN_OBD;

	is_infrared_screen = TRUE;
	mmi_entry_edog_screen();

}

void mmi_disp_edog_OBD_info_switch(void)
{
#if defined(__CITY_EASY_OBD__)
	S32 i = 0;
	S32 data_count = 0;
	
	obd_value_count = 0;
	memset(&g_obd_data[MAX_OBD_DATA_ID],0,sizeof(g_obd_data[MAX_OBD_DATA_ID]));
	for(i= 0;i<MAX_OBD_DATA_ID;i++)
	{
		if(g_city_obd_data[i].status)
		{
			memcpy(&g_obd_data[obd_value_count],&g_city_obd_data[i],sizeof(city_obd_data));
		       if(((i>=0)&&(i<=39))||(i==64)||(i==66))
		       	{
		       	    g_obd_data[obd_value_count].value = 10;
		       	}
			obd_value_count++;
		}
	}
	
#endif /* __CITY_EASY_OBD__ */
}
void mmi_disp_edog_OBD_info(void)
{
	gdi_handle mmi_base_layer;

	U32 start_x = 8,gap_x = 3,gap_y = 2;
	S32 x=0,y=0;
	S32 str_w,str_h;
	U8 ucs_str[128];
	U8 asc_str[32];
	U8 tem_str[128];
	U8 tem1_str[64];
	U8 tts_str[512];
	S32 i = 0;
#if defined(__CITY_EASY_OBD__)
	
#else /*1*/
	U16 a_str[]={0x6C34,0x6E29,0xFF1A,0x0031,0x0030,0x0030,0x2103,0xFF1B,0x0000};//水温
	U16 b_str[]={0x6CB9,0x91CF,0xFF1A,0x0038,0x0030,0x004C,0xFF1B,0x0000};//油量
	U16 c_str[]={0x91CC,0x7A0B,0xFF1A,0x0038,0x0030,0x0030,0x006B,0x006D,0xFF1B,0x0000};//里程
	U16 d_str[]={0x7535,0x74F6,0x7535,0x538B,0xFF1A,0x0032,0x0034,0x0056,0xFF1B,0x0000};//电瓶电压
	U16 e_str[]={0x8F66,0x901F,0xFF1A,0x0038,0x0030,0x006B,0x006D,0x002F,0x0068,0xFF1B,0x0000};//车速
	U16 f_str[]={0x8F6C,0x901F,0xFF1A,0x0035,0x0036,0x0030,0x0030,0x0052,
0x0070,0x006D,0xFF1B,0x0000};//转速
	U16 g_str[]={0x7A7A,0x6C14,0x6D41,0x91CF,0xFF1A,0x0039,0x0067,0x002F,
0x0073,0xFF1B,0x0000};//空气流量
	U16 h_str[]={0x540E,0x5907,0x7BB1,0x72B6,0x6001,0xFF1A,0x5173,0xFF1B,0x0000};//后备箱状态

	U16 a1_str[]={0x5DE6,0x524D,0x95E8,0xFF1A,0x5173,0x95ED,0xFF1B,0x0000};//左前门：关闭；
	U16 a2_str[]={0x53F3,0x524D,0x95E8,0xFF1A,0x5173,0x95ED,0xFF1B,0x0000};//右前门：关闭；
	U16 a3_str[]={0x5DE6,0x540E,0x95E8,0xFF1A,0x5173,0x95ED,0xFF1B,0x0000};//左后门：关闭；
	U16 a4_str[]={0x53F3,0x540E,0x95E8,0xFF1A,0x5173,0x95ED,0xFF1B,0x0000};//右后门：关闭；

	U16 b1_str[]={0x5B89,0x5168,0x6C14,0x56CA,0xFF1A,0x6B63,0x5E38,0xFF1B,0x0000};//安全气囊：正常；
	U16 b2_str[]={0x4E3B,0x9A7E,0x9A76,0x4F4D,0x5B89,0x5168,0x5E26,0xFF1A,0x672A,0x6263,0xFF1B,0x0000};//主驾驶位安全带：未扣；
	U16 b3_str[]={0x526F,0x9A7E,0x9A76,0x4F4D,0x5B89,0x5168,0x5E26,0xFF1A,0x672A,0x6263,0xFF1B,0x0000};//副驾驶位安全带：未扣；
	U16 b4_str[]={0x96E8,0x5237,0x72B6,0x6001,0xFF1A,0x5173,0x95ED,0xFF1B,0x0000};//雨刷状态：关闭；
#endif /* 1 */

#if defined(__CITY_EASY_OBD__)
	if(obd_info_index>=obd_value_count)
	{
		return;
	}
#endif /* __CITY_EASY_OBD__ */

	gdi_layer_get_base_handle(&mmi_base_layer);

	gdi_layer_lock_frame_buffer();
	gdi_layer_push_and_set_active(mmi_base_layer);
	gdi_layer_clear(GDI_COLOR_BLACK);
	
	gui_set_text_color(gui_color(255,255,255));

#if defined(__CITY_EASY_OBD__)
	memset(tts_str,0,sizeof(tts_str));
	
	for(i=0;i<4;i++)
	{
		if((obd_info_index + i)<obd_value_count)
		{
			memset(ucs_str,0,sizeof(ucs_str));
			memset(asc_str,0,sizeof(asc_str));
			memset(tem_str,0,sizeof(tem_str));

		       if(g_obd_data[obd_info_index+i].value == 10)
		       {
			     mmi_ucs2cat((S8*)tem_str,(S8*)g_obd_data[obd_info_index+i].unit);
		       }
			else
		       {
                           sprintf(asc_str,":%.0f",g_obd_data[obd_info_index+i].value);
                           mmi_asc_to_ucs2((S8*)tem_str,(S8*)asc_str);
                           mmi_ucs2cat((S8*)tem_str,(S8*)g_obd_data[obd_info_index+i].unit);
                           sprintf(asc_str,"%s",";");
                           mmi_asc_to_ucs2((S8*)tem1_str,(S8*)asc_str);
                           mmi_ucs2cat((S8*)tem_str,(S8*)tem1_str);
			}
			
			mmi_ucs2cat((S8*)ucs_str,(S8*)g_obd_data[obd_info_index+i].name_string);
			mmi_ucs2cat((S8*)ucs_str,(S8*)tem_str);
			mmi_ucs2cat((S8*)tts_str,(S8*)ucs_str);
			
			gui_measure_string((UI_string_type)ucs_str,&str_w,&str_h);
			x = 0;
			y = i*str_h+gap_y*(i+1);
			gui_move_text_cursor(x,y);
			gui_print_text((UI_string_type)ucs_str);
		}
	}
#if defined(__NPR_TTS__)
    if(tts_play_status)
    {
        Npr_Ttsplayer_playtextw(tts_str,NULL);
    }
#endif /* __NPR_TTS__ */
		


#else /*1*/
	if(0 == obd_info_index)
	{
		memset(ucs_str,0,sizeof(ucs_str));
#if defined(__NPR_TTS__)
              if(tts_play_status)
              {
                  memset(tts_str,0,sizeof(tts_str));
                  mmi_ucs2cat((S8*)tts_str, (S8*)a_str);
                  mmi_ucs2cat((S8*)tts_str, (S8*)b_str);
                  mmi_ucs2cat((S8*)tts_str, (S8*)c_str);
                  mmi_ucs2cat((S8*)tts_str, (S8*)d_str);
                  Npr_Ttsplayer_playtextw(tts_str,NULL);
              }
#endif /* __NPR_TTS__ */
		
		memcpy(ucs_str,a_str,sizeof(a_str));
		gui_measure_string((UI_string_type)ucs_str,&str_w,&str_h);
		gui_move_text_cursor(x,y);
		gui_print_text((UI_string_type)ucs_str);
		
		memset(ucs_str,0,sizeof(ucs_str));
		memcpy(ucs_str,b_str,sizeof(b_str));
		x = 0;
		y += str_h+gap_y;
		gui_measure_string((UI_string_type)ucs_str,&str_w,&str_h);
		gui_move_text_cursor(x,y);
		gui_print_text((UI_string_type)ucs_str);
		
		memset(ucs_str,0,sizeof(ucs_str));
		memcpy(ucs_str,c_str,sizeof(c_str));
		x = 0;
		y += str_h+gap_y;
		gui_measure_string((UI_string_type)ucs_str,&str_w,&str_h);
		gui_move_text_cursor(x,y);
		gui_print_text((UI_string_type)ucs_str);
			
		memset(ucs_str,0,sizeof(ucs_str));
		memcpy(ucs_str,d_str,sizeof(d_str));
		x = 0;
		y += str_h+gap_y;
		gui_measure_string((UI_string_type)ucs_str,&str_w,&str_h);
		gui_move_text_cursor(x,y);
		gui_print_text((UI_string_type)ucs_str);

	}
	else if(1 == obd_info_index)
	{
		memset(ucs_str,0,sizeof(ucs_str));
#if defined(__NPR_TTS__)
              if(tts_play_status)
              {
                  memset(tts_str,0,sizeof(tts_str));
                  mmi_ucs2cat((S8*)tts_str, (S8*)e_str);
                  mmi_ucs2cat((S8*)tts_str, (S8*)f_str);
                  mmi_ucs2cat((S8*)tts_str, (S8*)g_str);
                  mmi_ucs2cat((S8*)tts_str, (S8*)h_str);
                  Npr_Ttsplayer_playtextw((S8*)tts_str,NULL);
              }
#endif /* __NPR_TTS__ */
		
		memcpy(ucs_str,e_str,sizeof(e_str));
		x = 0;
		y = gap_y;
		gui_measure_string((UI_string_type)ucs_str,&str_w,&str_h);
		gui_move_text_cursor(x,y);
		gui_print_text((UI_string_type)ucs_str);
		
		memset(ucs_str,0,sizeof(ucs_str));
		memcpy(ucs_str,f_str,sizeof(f_str));
		x = 0;
		y += str_h+gap_y;
		gui_measure_string((UI_string_type)ucs_str,&str_w,&str_h);
		gui_move_text_cursor(x,y);
		gui_print_text((UI_string_type)ucs_str);
		
		memset(ucs_str,0,sizeof(ucs_str));
		memcpy(ucs_str,g_str,sizeof(g_str));
		x = 0;
		y += str_h+gap_y;
		gui_measure_string((UI_string_type)ucs_str,&str_w,&str_h);
		gui_move_text_cursor(x,y);
		gui_print_text((UI_string_type)ucs_str);
			
		memset(ucs_str,0,sizeof(ucs_str));
		memcpy(ucs_str,h_str,sizeof(h_str));
		x = 0;
		y += str_h+gap_y;
		gui_measure_string((UI_string_type)ucs_str,&str_w,&str_h);
		gui_move_text_cursor(x,y);
		gui_print_text((UI_string_type)ucs_str);

	}
	else if(2 == obd_info_index)
	{
		memset(ucs_str,0,sizeof(ucs_str));
#if defined(__NPR_TTS__)
              if(tts_play_status)
              {
                  memset(tts_str,0,sizeof(tts_str));
                  mmi_ucs2cat((S8*)tts_str, (S8*)a1_str);
                  mmi_ucs2cat((S8*)tts_str, (S8*)a2_str);
                  mmi_ucs2cat((S8*)tts_str, (S8*)a3_str);
                  mmi_ucs2cat((S8*)tts_str, (S8*)a4_str);
                  Npr_Ttsplayer_playtextw((S8*)tts_str,NULL);
              }
#endif /* __NPR_TTS__ */
		
		memcpy(ucs_str,a1_str,sizeof(a1_str));
		x = 0;
		y = gap_y;
		gui_measure_string((UI_string_type)ucs_str,&str_w,&str_h);
		gui_move_text_cursor(x,y);
		gui_print_text((UI_string_type)ucs_str);
		
		memset(ucs_str,0,sizeof(ucs_str));
		memcpy(ucs_str,a2_str,sizeof(a2_str));
		x = 0;
		y += str_h+gap_y;
		gui_measure_string((UI_string_type)ucs_str,&str_w,&str_h);
		gui_move_text_cursor(x,y);
		gui_print_text((UI_string_type)ucs_str);
		
		memset(ucs_str,0,sizeof(ucs_str));
		memcpy(ucs_str,a3_str,sizeof(a3_str));
		x = 0;
		y += str_h+gap_y;
		gui_measure_string((UI_string_type)ucs_str,&str_w,&str_h);
		gui_move_text_cursor(x,y);
		gui_print_text((UI_string_type)ucs_str);
			
		memset(ucs_str,0,sizeof(ucs_str));
		memcpy(ucs_str,a4_str,sizeof(a4_str));
		x = 0;
		y += str_h+gap_y;
		gui_measure_string((UI_string_type)ucs_str,&str_w,&str_h);
		gui_move_text_cursor(x,y);
		gui_print_text((UI_string_type)ucs_str);
	}
	else if(3 == obd_info_index)
	{
		memset(ucs_str,0,sizeof(ucs_str));
#if defined(__NPR_TTS__)
              if(tts_play_status)
              {
                  memset(tts_str,0,sizeof(tts_str));
                  mmi_ucs2cat((S8*)tts_str, (S8*)b1_str);
                  mmi_ucs2cat((S8*)tts_str, (S8*)b2_str);
                  mmi_ucs2cat((S8*)tts_str, (S8*)b3_str);
                  mmi_ucs2cat((S8*)tts_str, (S8*)b4_str);
                  Npr_Ttsplayer_playtextw((S8*)tts_str,NULL);
              }
#endif /* __NPR_TTS__ */
		
		memcpy(ucs_str,b1_str,sizeof(b1_str));
		x = 0;
		y = gap_y;
		gui_measure_string((UI_string_type)ucs_str,&str_w,&str_h);
		gui_move_text_cursor(x,y);
		gui_print_text((UI_string_type)ucs_str);
		
		memset(ucs_str,0,sizeof(ucs_str));
		memcpy(ucs_str,b2_str,sizeof(b2_str));
		x = 0;
		y += str_h+gap_y;
		gui_measure_string((UI_string_type)ucs_str,&str_w,&str_h);
		gui_move_text_cursor(x,y);
		gui_print_text((UI_string_type)ucs_str);
		
		memset(ucs_str,0,sizeof(ucs_str));
		memcpy(ucs_str,b3_str,sizeof(b3_str));
		x = 0;
		y += str_h+gap_y;
		gui_measure_string((UI_string_type)ucs_str,&str_w,&str_h);
		gui_move_text_cursor(x,y);
		gui_print_text((UI_string_type)ucs_str);
			
		memset(ucs_str,0,sizeof(ucs_str));
		memcpy(ucs_str,b4_str,sizeof(b4_str));
		x = 0;
		y += str_h+gap_y;
		gui_measure_string((UI_string_type)ucs_str,&str_w,&str_h);
		gui_move_text_cursor(x,y);
		gui_print_text((UI_string_type)ucs_str);
	}
#endif /* 1 */

	gdi_layer_pop_and_restore_active();
	gdi_layer_unlock_frame_buffer();

	gdi_layer_blt(mmi_base_layer,0,0,0,0,0,UI_DEVICE_WIDTH,UI_DEVICE_HEIGHT);


	if(tts_play_status)
	{
	    tts_play_status = KAL_FALSE;
	}


}
#endif
void mmi_edog_img_show(U16 img_id)
{
	S32 len = 0;

	edog_img_id = img_id;
	if(edog_img_id == NULL)
	{
		G_EDOG_SCREEN = MMI_EDOG_SCREEN_IDLE;
	}
	else
	{
		G_EDOG_SCREEN = MMI_EDOG_SCREEN_IMG;
	}

	mmi_entry_edog_screen();

}
void mmi_start_timer_goto_idle_screen(void)
{
#if defined(__NPR_TTS__)
#if defined(__CITY_EASY_WEB_DOG__)
	if(1 == g_is_shut_down)
	{
		return;
	}
	
	if(mmi_get_gps_status())
	{
		return;
	}

#endif /* __CITY_EASY_WEB_DOG__ */
	StopTimer(MMI_GOBACK_IDLE_TIMER);
	if(G_EDOG_SCREEN != MMI_EDOG_SCREEN_IDLE && !Npr_Tts_is_playing())
	{
		StartTimer(MMI_GOBACK_IDLE_TIMER,1000,mmi_edog_back_to_first_screen);
	}
#endif /* __NPR_TTS__ */
}


void mmi_entry_edog_screen(void)
{
#if defined(__CITY_EASY_WEB_DOG__)
	if(1 == g_is_shut_down)
	{
		return;
	}
#endif /* __CITY_EASY_WEB_DOG__ */



    if(G_EDOG_SCREEN != MMI_EDOG_SCREEN_IDLE)
    {
	gui_scrolling_text_stop(&edog_string_info);
    }

	//bwl_dbg_print("mmi_entry_edog_screen G_EDOG_SCREEN = %d",G_EDOG_SCREEN);

	switch(G_EDOG_SCREEN)
	{
		case MMI_EDOG_SCREEN_IDLE:
			scroll_page_start = 0;
			mmi_disp_edog_idlescreen();
		break;
		
		case MMI_EDOG_SCREEN_STRING:
			if(scroll_page_start == 0)
			{
				mmi_disp_edog_weather();
			}
		break;
		
		case MMI_EDOG_SCREEN_SPEED:
			mmi_disp_edog_number();
		break;
			
		case MMI_EDOG_SCREEN_OBD:
		//#if defined(__CITY_EASY_OBD__)
			mmi_disp_edog_OBD_info();
		//#endif
		break;
		
		case MMI_EDOG_SCREEN_DISTANCE:
			mmi_disp_edog_distance();
		break;

		case MMI_EDOG_SCREEN_IMG:
			mmi_disp_edog_img();
		break;
		default:

		break;
	}
	
	mmi_start_timer_goto_idle_screen();
	    /* stop MMI sleep */
	if(g_idle_sleep == 1)
	{
		//srv_backlight_turn_on(SRV_BACKLIGHT_SHORT_TIME);
		//srv_backlight_turn_off();
		//srv_backlight_to_sleep_mode();
		srv_backlight_close();
		return;
	}
	else
	{
		srv_backlight_turn_on(SRV_BACKLIGHT_PERMANENT);
	}

}
void mmi_edog_info_show(U8 *ucs_str,U8 *dist_ucs_str,U8 flag)
{
	S32 len = 0;
	char dot_str[]={0x2c,0x00};

#if defined(__CITY_EASY_WEB_DOG__)
	if(1 == g_is_shut_down)
	{
		return;
	}
#endif /* __CITY_EASY_WEB_DOG__ */
	
	len = mmi_ucs2strlen(ucs_str);
	
	if(flag == MMI_EDOG_SCREEN_STRING)
	{
		memset(show_buffer,0,sizeof(show_buffer));
		if(len<sizeof(show_buffer))
		{
			mmi_ucs2cpy((S8*)show_buffer, (S8*)ucs_str);
		}
		else
		{
			mmi_ucs2ncpy(show_buffer,ucs_str,sizeof(show_buffer));
		}
	}
	else
	{
		memset(num_buffer,0,sizeof(num_buffer));
		mmi_ucs2cat((S8*)num_buffer, (S8*)ucs_str);
		if(NULL != dist_ucs_str)
		{
			mmi_ucs2cat((S8*)num_buffer, (S8*)dot_str);
			mmi_ucs2cat((S8*)num_buffer, (S8*)dist_ucs_str);
		}
	}
	G_EDOG_SCREEN = flag;

	mmi_entry_edog_screen();

}

void mmi_edog_back_to_first_screen(void)
{
#if defined(__CITY_EASY_WEB_DOG__)
	if(1 == g_is_shut_down)
	{
		return;
	}
#endif /* __CITY_EASY_WEB_DOG__ */

	G_EDOG_SCREEN = MMI_EDOG_SCREEN_IDLE;
	StopTimer(MMI_GOBACK_IDLE_TIMER);
	mmi_entry_edog_screen();
#if defined(__NPR_TTS__)
	Npr_Tts_play_stop();
#endif /* __NPR_TTS__ */
}

#endif /* __MMI_MAINLCD_128X64__ */


void mmi_show_idle_screen(void)
{
#if defined(__MMI_MAINLCD_128X64__)
#if defined(__CITY_EASY_WEB_DOG__)
	if(0 == g_is_shut_down)
#endif /* __CITY_EASY_WEB_DOG__ */
	{ 
		mmi_entry_edog_screen();
	}
#else /*__MMI_MAINLCD_128X36__*/
	if(sos_status != 0)
	{
		mmi_show_sos_screen();
	}
	else
	{
		mmi_disp_idlescreen();
	}
	mmi_idle_clear_lsk_handle();
	SetKeyHandler(mmi_idle_make_sos_call, KEY_LSK, KEY_EVENT_LONG_PRESS);
#endif /* __MMI_MAINLCD_128X36__ */
}
#endif /* __OLED_BW_MMI__ */
#endif



#if defined(__OLDMAN_STYLE__)
#include "PowerOnChargerProt.h"
#include "TimerEvents.h"
#include "mmi_rp_app_mainmenu_def.h"
#include "Conversions.h"
extern charbat_context_struct g_charbat_context;
#ifndef WIN32
extern void kjx_oldman_key_sos3(void);
#endif
extern void mmi_oldman_set_language(U8 langtype);
void mmi_disp_old_idlescreen(void);
void EntryScr_message(void);
void EntryScr_HeartRate(void);
#ifndef WIN32
extern void TimeISR();

extern float myHR; 
#endif

U8 g_oldman_idle_sleep = 0;


static const FLOAT g_gui_clock_old_sine_table[] = 
{
    (FLOAT) - 0.99999820, (FLOAT) - 0.99431727, (FLOAT) - 0.97773360, (FLOAT) - 0.95042917,
        (FLOAT) - 0.91270313,
        (FLOAT)-0.86496924, (FLOAT)-0.80775119, (FLOAT)-0.74167587,
    (FLOAT) - 0.66746803, (FLOAT) - 0.58594175, (FLOAT) - 0.49799022, (FLOAT) - 0.40457821,
        (FLOAT) - 0.30673042,
        (FLOAT)-0.20551889, (FLOAT)-0.10205382, (FLOAT)0.00000000,
    (FLOAT) 0.10457040, (FLOAT) 0.20799418, (FLOAT) 0.30913729, (FLOAT) 0.40689072, (FLOAT) 0.50018258,
        (FLOAT) 0.58798990,
        (FLOAT)0.66934994, (FLOAT)0.74337050,
    (FLOAT) 0.80923998, (FLOAT) 0.86623616, (FLOAT) 0.91373403, (FLOAT) 0.95121274, (FLOAT) 0.97826142,
        (FLOAT) 0.99458343,
        (FLOAT)0.99999980, (FLOAT)0.99445115,
    (FLOAT) 0.97799831, (FLOAT) 0.95082172, (FLOAT) 0.91321931, (FLOAT) 0.86560342, (FLOAT) 0.80849624,
        (FLOAT) 0.74252372,
        (FLOAT)0.66840956, (FLOAT)0.58696629,
    (FLOAT) 0.49908672, (FLOAT) 0.40573486, (FLOAT) 0.30793410, (FLOAT) 0.20675662, (FLOAT) 0.10331227,
        (FLOAT) - 0.00126490,
        (FLOAT)-0.10582843, (FLOAT)-0.20923132,
    (FLOAT) - 0.31033998, (FLOAT) - 0.40804598, (FLOAT) - 0.50127753, (FLOAT) - 0.58901256,
        (FLOAT) - 0.67028925,
        (FLOAT)-0.74421601, (FLOAT)-0.80998244, (FLOAT)-0.86686752,
    (FLOAT)-0.91424734, (FLOAT)-0.95160225, (FLOAT)-0.97852297, (FLOAT)-0.99471414,
};


static const FLOAT g_gui_clock_old_cosine_table[] = 
{
    (FLOAT) 0.00189735, (FLOAT) 0.10645731, (FLOAT) 0.20984996, (FLOAT) 0.31094114, (FLOAT) 0.40862330,
        (FLOAT) 0.50182489,
        (FLOAT)0.58952354, (FLOAT)0.67075845,
    (FLOAT) 0.74463846, (FLOAT) 0.81035318, (FLOAT) 0.86718264, (FLOAT) 0.91450340, (FLOAT) 0.95179643,
        (FLOAT) 0.97865315,
        (FLOAT)0.99477888, (FLOAT)1.00000000,
    (FLOAT) 0.99451749, (FLOAT) 0.97813006, (FLOAT) 0.95101742, (FLOAT) 0.91347684, (FLOAT) 0.86591997,
        (FLOAT) 0.80886827,
        (FLOAT)0.74294728, (FLOAT)0.66887989,
    (FLOAT) 0.58747821, (FLOAT) 0.49963478, (FLOAT) 0.40631283, (FLOAT) 0.30853576, (FLOAT) 0.20737548,
        (FLOAT) 0.10394131,
        (FLOAT)-0.00063245, (FLOAT)-0.10519940,
    (FLOAT) - 0.20861283, (FLOAT) - 0.30973870, (FLOAT) - 0.40746839, (FLOAT) - 0.50073018,
        (FLOAT) - 0.58850135,
        (FLOAT)-0.66981977, (FLOAT)-0.74379342, (FLOAT)-0.80961137,
    (FLOAT) - 0.86655204, (FLOAT) - 0.91399082, (FLOAT) - 0.95140769, (FLOAT) - 0.97839241,
        (FLOAT) - 0.99464897,
        (FLOAT)-0.99999920, (FLOAT)-0.99438440, (FLOAT)-0.97786617,
    (FLOAT) - 0.95062563, (FLOAT) - 0.91296138, (FLOAT) - 0.86528656, (FLOAT) - 0.80812388,
        (FLOAT) - 0.74209994,
        (FLOAT)-0.66793902, (FLOAT)-0.58645414, (FLOAT)-0.49853857,
    (FLOAT)-0.40515651, (FLOAT)-0.30733233, (FLOAT)-0.20613779, (FLOAT)-0.10268295,
};


void chinese_char_to_unicode(char *dest, int dest_size, char *src)
{

#ifdef mmi_chset_text_to_ucs2_str
	mmi_chset_text_to_ucs2_str((kal_uint8*)dest, dest_size, (kal_uint8*)src, GB2312_ENCODING_TYPE);
#else
	mmi_chset_convert(MMI_CHSET_GB18030, MMI_CHSET_UCS2, src, dest, dest_size);
#endif
}


/*******************************************************************************************************/
//提示
/*******************************************************************************************************/
void kjx_oldman_exit_push_string(void)
{
	srv_backlight_turn_off();
	DeleteScreenIfPresent(SCR_ID_KJX_SHOW_STRING);
}


void show_push_string(void)
{

	S16 zx1=0,zx2=UI_device_width,zy1=0,zy2=UI_device_height;
	S32 twidth, theight,string_w,string_h;
	S32 text_x ,text_y,string_x,string_y;
	char hrdata[40]={0};
	char hrtext[40]={0};
	char hrtext_buff[40]={0};
	char UcsBuffer[512];
	extern S8 kjxPlayTts[512];
	U16 string_row = 0,i=0,totle_len=0,row_len=0,last_len=0;
	char UcsShow[240+1];

	gui_push_clip();
	
	gui_set_clip(zx1, zy1,zx2,zy2);
	
	gdi_draw_solid_rect(0, 0,UI_device_width,UI_device_height, GDI_COLOR_WHITE);

	gdi_image_draw_id(0, 0, IMG_GLOBAL_PUSH);


	memset(hrdata, 0, sizeof(hrdata));

	memset(hrtext, 0, sizeof(hrtext));
	
	memset(hrtext_buff, 0, sizeof(hrtext_buff));

	strcpy(hrtext,"消息推送 ");

	chinese_char_to_unicode((unsigned char *)hrtext_buff,strlen(hrtext)*2+1, ( kal_uint8 *)hrtext);

	gui_set_font(&MMI_medium_font);
	gui_set_text_color(UI_COLOR_WHITE);
	gui_measure_string((UI_string_type)hrtext_buff, &twidth, &theight);
	
	//text_x = (UI_device_width - twidth) >> 1;
	//text_y = (UI_device_height - theight) >> 1;
	text_x = (UI_device_width - twidth) >> 1;
	text_y =  3;
	
	gui_move_text_cursor(text_x, text_y );
	gui_print_text((UI_string_type)hrtext_buff);

	memset(UcsBuffer,0,sizeof(UcsBuffer));
	mmi_chset_utf8_to_ucs2_string((kal_uint8 *)UcsBuffer, sizeof(kjxPlayTts),kjxPlayTts);

	gui_measure_string((UI_string_type)UcsBuffer, &string_w, &string_h);

	string_row = string_w/UI_device_width;
	
	totle_len=mmi_ucs2strlen((const CHAR *)UcsBuffer);

	row_len = totle_len/string_row;
 
	for(i=0;i<string_row+1;i++)
	{     
		memset(UcsShow,0,sizeof(UcsShow));
		mmi_ucs2ncpy((CHAR *)UcsShow, (const CHAR *)(UcsBuffer+(i*20)),20);
		//mmi_ucs2ncpy((CHAR *)UcsShow, (const CHAR *)(UcsBuffer+(i*row_len)),row_len);
			
		string_x = 0;
		if(i==0)
		{
			string_y =  text_y+theight+5;
		}
		else
		{
			string_y += (string_h+5);
		}
		   
		gui_move_text_cursor(string_x, string_y );
		gui_print_text((UI_string_type)UcsShow);
	}
	
	gui_pop_clip();
	
	gui_BLT_double_buffer(0, 0,UI_device_width,UI_device_height);
 		
}
 
void kjx_oldman_show_push_string(void)
{
	PS8 buffer;
	S32 bufferSize;
	char UcsBuffer[512];
	char* restring=NULL;
	char prin[50];
	extern S8 kjxPlayTts[512];

	char showstring[]={0x11,0x62,0xcd,0x64,0x11,0x62,0xcd,0x64,0xf9,0x66,0xcd,0x64,0xf9,0x66,0xcd,0x64,0xf9,0x51,0xfd,0x69,0x0,0x0};
 
	StopTimer(MMI_OLDMAN_LOCK_TIMER);
	//StopTimer(MMI_OLDMAN_HEARTRATE_SCREEN_TIMER);

	srv_backlight_turn_on(SRV_BACKLIGHT_PERMANENT);
	
	EntryNewScreen(SCR_ID_KJX_SHOW_STRING, kjx_oldman_exit_push_string, kjx_oldman_show_push_string, NULL);

	//restring=(char*)bkk_read_and_write_data(BKK_CARTOON_FOLDER,BKK_CARTOON_FILE,"<ZF>",NULL,"<FZ>",BKK_FILE_MODIFY_READ);

	mmi_chset_utf8_to_ucs2_string((kal_uint8 *)UcsBuffer, sizeof(kjxPlayTts),kjxPlayTts);
	buffer=(char*)&UcsBuffer;

	bufferSize	= mmi_ucs2strlen(buffer);
	//bufferSize	= mmi_ucs2strlen(showstring);
#ifdef KJX_IDLE_DEBUG
#if defined(__KJX_LOG_OUTPUT__)
	LOGD("bufferSize:%d", bufferSize);
#endif	
 #endif
	/*ShowCategory74Screen( STR_ID_SHOW_PUSH_STRING_TITLE, 0,
						 STR_GLOBAL_OK,IMG_GLOBAL_OK,
						 STR_GLOBAL_BACK,IMG_GLOBAL_BACK,
						 (PU8)buffer, bufferSize, NULL);*/

	show_push_string();

	ClearKeyHandler(KEY_LEFT_ARROW, KEY_EVENT_DOWN);
	ClearKeyHandler(KEY_LEFT_ARROW, KEY_LONG_PRESS);

	ClearKeyHandler(KEY_RIGHT_ARROW, KEY_EVENT_UP);
	ClearKeyHandler(KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
	ClearKeyHandler(KEY_RIGHT_ARROW, KEY_LONG_PRESS);

	ClearKeyHandler(KEY_UP_ARROW, KEY_EVENT_UP);
	ClearKeyHandler(KEY_UP_ARROW, KEY_EVENT_DOWN);
	ClearKeyHandler(KEY_UP_ARROW, KEY_LONG_PRESS);

	ClearKeyHandler(KEY_DOWN_ARROW, KEY_EVENT_UP);
	ClearKeyHandler(KEY_DOWN_ARROW, KEY_EVENT_DOWN);
	ClearKeyHandler(KEY_DOWN_ARROW, KEY_LONG_PRESS);

	SetKeyHandler(GoBackHistory, KEY_POWER, KEY_EVENT_UP);
	SetKeyHandler(GoBackHistory, KEY_LSK, KEY_EVENT_UP);
}

void send_hrdata_message(void)
{


}

void goto_idle_desk(void)
{

	StopTimer(MMI_OLDMAN_LOCK_TIMER);
	g_oldman_idle_sleep = 0;
	
	mmi_disp_old_idlescreen();
}


void mmi_disp_lock_idlescreen(void)
{
	gdi_handle mmi_base_layer;
	MYTIME curr_time;
	kal_uint8 idle_h0,idle_m0,idle_h1,idle_m1;
	U32 start_x = 8,gap_x = 3,gap_y = 2;
	S32 img_w,img_h;
	S32 dot_w,dot_h;
	S32 gps_img_w,gps_img_h;
	S32 x,y,min_x,min_y,hour_x,hour_y,radius_min = 80 , radius_hour = 50 , radius_sec = 100 , radius_add_sec = 20 , radius_add_min = 15 , radius_add_hour = 12 ;
	U16 signal_img_id = 0;
	U16 bat_img_id = 0;
	U16 gps_status_img = 0;
	S32 twidth, theight;
    FLOAT cosa, sina ;
	
    S32 h , h1 , m , m1 , s1;

	if(GetActiveScreenId()==SCR_ID_KJX_SHOW_STRING)
		return;
	
	mmi_oldman_set_language(1);

	DTGetRTCTime(&curr_time);

	idle_h0 = curr_time.nHour/10;
	idle_h1 = curr_time.nHour%10;
	idle_m0 = curr_time.nMin/10;
	idle_m1 = curr_time.nMin%10;

	gui_measure_image(get_image(IMG_GLOBAL_BW_0),&img_w,&img_h);
	gui_measure_image(get_image(IMG_GLOBAL_BW_DOT),&dot_w,&dot_h);
	
	gdi_layer_get_base_handle(&mmi_base_layer);

	gdi_layer_lock_frame_buffer();
	gdi_layer_push_and_set_active(mmi_base_layer);
	gdi_layer_clear(GDI_COLOR_TRANSPARENT);
	//draw_wallpaper();
	gdi_image_draw_id(0, 0, IMG_GLOBAL_ANALOG_CLOCK);

	h = curr_time.nHour;
	m = curr_time.nMin;

    sina = (FLOAT)g_gui_clock_old_sine_table[curr_time.nMin];
    cosa = (FLOAT)g_gui_clock_old_cosine_table[curr_time.nMin];
	min_y = (S32) (UI_device_width/2 + radius_min * sina);
	min_x = (S32) (UI_device_height/2 + radius_min * cosa);


	if(m%30 == 0)
	{
		gdi_draw_antialiasing_line(UI_device_width/2 -1, UI_device_height/2 , min_x -1, min_y  , gdi_act_color_from_rgb(255, 255, 255, 255));
		gdi_draw_antialiasing_line(UI_device_width/2, UI_device_height/2, min_x, min_y, gdi_act_color_from_rgb(255, 255, 255, 255));
		gdi_draw_antialiasing_line(UI_device_width/2 +1, UI_device_height/2 , min_x +1, min_y  , gdi_act_color_from_rgb(255, 255, 255, 255));
	
	}
	else
	{
		gdi_draw_antialiasing_line(UI_device_width/2, UI_device_height/2 - 1 , min_x, min_y  - 1 , gdi_act_color_from_rgb(255, 255, 255, 255));
		gdi_draw_antialiasing_line(UI_device_width/2, UI_device_height/2, min_x, min_y, gdi_act_color_from_rgb(255, 255, 255, 255));
		gdi_draw_antialiasing_line(UI_device_width/2, UI_device_height/2 + 1 , min_x, min_y  + 1 , gdi_act_color_from_rgb(255, 255, 255, 255));
	}


	m1 = curr_time.nMin;
	m1 = m1 + 30;
	if (m1 > 59)
    {
        m1 = m1 - 60;
    }
	sina = (FLOAT)g_gui_clock_old_sine_table[m1];
    cosa = (FLOAT)g_gui_clock_old_cosine_table[m1];
	min_y = (S32) (UI_device_width/2 + radius_add_min * sina);
	min_x = (S32) (UI_device_height/2 + radius_add_min * cosa);


	if(m%30 == 0)
	{
		gdi_draw_antialiasing_line(UI_device_width/2 -1, UI_device_height/2 , min_x -1, min_y  , gdi_act_color_from_rgb(255, 255, 255, 255));
		gdi_draw_antialiasing_line(UI_device_width/2, UI_device_height/2, min_x, min_y, gdi_act_color_from_rgb(255, 255, 255, 255));
		gdi_draw_antialiasing_line(UI_device_width/2 +1, UI_device_height/2 , min_x +1, min_y  , gdi_act_color_from_rgb(255, 255, 255, 255));
	
	}
	else
	{
		gdi_draw_antialiasing_line(UI_device_width/2, UI_device_height/2 - 1 , min_x, min_y  - 1 , gdi_act_color_from_rgb(255, 255, 255, 255));
		gdi_draw_antialiasing_line(UI_device_width/2, UI_device_height/2, min_x, min_y, gdi_act_color_from_rgb(255, 255, 255, 255));
		gdi_draw_antialiasing_line(UI_device_width/2, UI_device_height/2 + 1 , min_x, min_y  + 1 , gdi_act_color_from_rgb(255, 255, 255, 255));
	}



    h++;
    if (h > 12)
    {
        h -= 12;
    }
    h = (h - 1) * 5;
    h += m / 12;
	
    if (m >= 60)
    {
        m = 0;
    }
    if ((m % 12) == 0)
    {
        if (h >= 60)
        {
            h = 0;
        }
    }

    sina = (FLOAT)g_gui_clock_old_sine_table[h];
    cosa = (FLOAT)g_gui_clock_old_cosine_table[h];
	min_y = (S32) (UI_device_width/2 + radius_hour * sina);
	min_x = (S32) (UI_device_height/2 + radius_hour * cosa);

	if(h%6 == 0)
	{
		gdi_draw_antialiasing_line(UI_device_width/2 -2, UI_device_height/2 , min_x -2, min_y  , gdi_act_color_from_rgb(255, 255, 255, 255));
		gdi_draw_antialiasing_line(UI_device_width/2 -1, UI_device_height/2 , min_x -1, min_y  , gdi_act_color_from_rgb(255, 255, 255, 255));
		gdi_draw_antialiasing_line(UI_device_width/2, UI_device_height/2, min_x, min_y, gdi_act_color_from_rgb(255, 255, 255, 255));
		gdi_draw_antialiasing_line(UI_device_width/2 +1, UI_device_height/2 , min_x +1, min_y  , gdi_act_color_from_rgb(255, 255, 255, 255));
		gdi_draw_antialiasing_line(UI_device_width/2 +2, UI_device_height/2 , min_x +2, min_y  , gdi_act_color_from_rgb(255, 255, 255, 255));
	
	}
	else
	{
		gdi_draw_antialiasing_line(UI_device_width/2, UI_device_height/2 - 1 , min_x, min_y  - 1 , gdi_act_color_from_rgb(255, 255, 255, 255));
		gdi_draw_antialiasing_line(UI_device_width/2, UI_device_height/2 - 2 , min_x, min_y  - 2 , gdi_act_color_from_rgb(255, 255, 255, 255));
		gdi_draw_antialiasing_line(UI_device_width/2, UI_device_height/2, min_x, min_y, gdi_act_color_from_rgb(255, 255, 255, 255));
		gdi_draw_antialiasing_line(UI_device_width/2, UI_device_height/2 + 1 , min_x, min_y  + 1 , gdi_act_color_from_rgb(255, 255, 255, 255));
		gdi_draw_antialiasing_line(UI_device_width/2, UI_device_height/2 + 2 , min_x, min_y  + 2 , gdi_act_color_from_rgb(255, 255, 255, 255));

	}

	h1 = h;
	h1 = h1 + 30;
	if (h1 > 59)
    {
        h1 = h1 - 60;
    }
	sina = (FLOAT)g_gui_clock_old_sine_table[h1];
    cosa = (FLOAT)g_gui_clock_old_cosine_table[h1];
	min_y = (S32) (UI_device_width/2 + radius_add_hour * sina);
	min_x = (S32) (UI_device_height/2 + radius_add_hour * cosa);


	if(h%6 == 0)
	{
		gdi_draw_antialiasing_line(UI_device_width/2 -2, UI_device_height/2 , min_x -2, min_y  , gdi_act_color_from_rgb(255, 255, 255, 255));
		gdi_draw_antialiasing_line(UI_device_width/2 -1, UI_device_height/2 , min_x -1, min_y  , gdi_act_color_from_rgb(255, 255, 255, 255));
		gdi_draw_antialiasing_line(UI_device_width/2, UI_device_height/2, min_x, min_y, gdi_act_color_from_rgb(255, 255, 255, 255));
		gdi_draw_antialiasing_line(UI_device_width/2 +1, UI_device_height/2 , min_x +1, min_y  , gdi_act_color_from_rgb(255, 255, 255, 255));
		gdi_draw_antialiasing_line(UI_device_width/2 +2, UI_device_height/2 , min_x +2, min_y  , gdi_act_color_from_rgb(255, 255, 255, 255));
	
	}
	else
	{
		gdi_draw_antialiasing_line(UI_device_width/2, UI_device_height/2 - 1 , min_x, min_y  - 1 , gdi_act_color_from_rgb(255, 255, 255, 255));
		gdi_draw_antialiasing_line(UI_device_width/2, UI_device_height/2 - 2 , min_x, min_y  - 2 , gdi_act_color_from_rgb(255, 255, 255, 255));
		gdi_draw_antialiasing_line(UI_device_width/2, UI_device_height/2, min_x, min_y, gdi_act_color_from_rgb(255, 255, 255, 255));
		gdi_draw_antialiasing_line(UI_device_width/2, UI_device_height/2 + 1 , min_x, min_y  + 1 , gdi_act_color_from_rgb(255, 255, 255, 255));
		gdi_draw_antialiasing_line(UI_device_width/2, UI_device_height/2 + 2 , min_x, min_y  + 2 , gdi_act_color_from_rgb(255, 255, 255, 255));

	}

	
	sina = (FLOAT)g_gui_clock_old_sine_table[curr_time.nSec];
    cosa = (FLOAT)g_gui_clock_old_cosine_table[curr_time.nSec];
	min_y = (S32) (UI_device_width/2 + radius_sec * sina);
	min_x = (S32) (UI_device_height/2 + radius_sec * cosa);
    gdi_draw_antialiasing_line(UI_device_width/2, UI_device_height/2, min_x, min_y, gdi_act_color_from_rgb(255, 200, 0, 0));

	s1 = curr_time.nSec + 30;
	if (s1 > 59)
    {
        s1 = s1 - 60;
    }
	sina = (FLOAT)g_gui_clock_old_sine_table[s1];
    cosa = (FLOAT)g_gui_clock_old_cosine_table[s1];
	min_y = (S32) (UI_device_width/2 + radius_add_sec * sina);
	min_x = (S32) (UI_device_height/2 + radius_add_sec * cosa);
    gdi_draw_antialiasing_line(UI_device_width/2, UI_device_height/2, min_x, min_y, gdi_act_color_from_rgb(255, 200, 0, 0));


	


	gdi_layer_pop_and_restore_active();

	gdi_layer_unlock_frame_buffer();

	gdi_layer_blt(mmi_base_layer,0,0,0,0,0,UI_DEVICE_WIDTH,UI_DEVICE_HEIGHT);

    //gui_start_timer(1000, mmi_disp_lock_idlescreen);
	StopTimer(MMI_OLDMAN_LOCK_TIMER);
	StartTimer(MMI_OLDMAN_LOCK_TIMER , 800 ,mmi_disp_lock_idlescreen);
	
	//kal_prompt_trace(MOD_FUN_GPS,"mmi_disp_lock_idlescreen \r\n" );
	//gui_start_timer(5000,mmi_idle_redraw);
#if 1//ndef WIN32
		ClearKeyHandler(KEY_LEFT_ARROW, KEY_EVENT_UP);
		ClearKeyHandler(KEY_LEFT_ARROW, KEY_EVENT_DOWN);
		ClearKeyHandler(KEY_LEFT_ARROW, KEY_LONG_PRESS);
	
		ClearKeyHandler(KEY_RIGHT_ARROW, KEY_EVENT_UP);
		ClearKeyHandler(KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
		ClearKeyHandler(KEY_RIGHT_ARROW, KEY_LONG_PRESS);
	
		ClearKeyHandler(KEY_UP_ARROW, KEY_EVENT_UP);
		ClearKeyHandler(KEY_UP_ARROW, KEY_EVENT_DOWN);
		ClearKeyHandler(KEY_UP_ARROW, KEY_LONG_PRESS);
	
		ClearKeyHandler(KEY_DOWN_ARROW, KEY_EVENT_UP);
		ClearKeyHandler(KEY_DOWN_ARROW, KEY_EVENT_DOWN);
		ClearKeyHandler(KEY_DOWN_ARROW, KEY_LONG_PRESS);
	
		//SetKeyHandler(kjx_oldman_key_sos3, KEY_LEFT_ARROW, KEY_EVENT_UP);
		//SetKeyHandler(kjx_oldman_key_sos3, KEY_RIGHT_ARROW, KEY_EVENT_UP);
		//SetKeyHandler(kjx_oldman_key_sos3, KEY_UP_ARROW, KEY_EVENT_UP);
		//SetKeyHandler(kjx_oldman_key_sos3, KEY_DOWN_ARROW, KEY_EVENT_UP);
		
		SetKeyHandler(goto_idle_desk, KEY_POWER, KEY_EVENT_UP);
		SetKeyHandler(goto_idle_desk, KEY_LSK, KEY_EVENT_UP);
		
		//SetKeyHandler(EntryScr_message, KEY_LEFT_ARROW, KEY_EVENT_UP);
#endif
		//SetKeyHandler(mmi_disp_old_idlescreen, KEY_DOWN_ARROW, KEY_EVENT_UP);
}



void mmi_disp_old_idlescreen(void)
{
	gdi_handle mmi_base_layer;
	MYTIME curr_time;
	kal_uint8 idle_h0,idle_m0,idle_h1,idle_m1;
	U32 start_x = 8,gap_x = 9,gap_y = 2;
	S32 img_w,img_h;
	S32 dot_w,dot_h;
	S32 gps_img_w,gps_img_h;
	S32 x,y;
	U16 signal_img_id = 0;
	U16 bat_img_id = 0;
	U16 gps_status_img = 0;
    S32 twidth, theight;
	
/*	
	U8 asc_str[10];
	U8 ucs2_str[20];
	U32 voltage;
	memset(asc_str,0,sizeof(asc_str));
	memset(ucs2_str,0,sizeof(ucs2_str));

	bmt_get_adc_channel_voltage(DCL_VBAT_ADC_CHANNEL, &voltage);
	sprintf(asc_str,"%d",voltage);
	mmi_asc_to_ucs2((S8*)ucs2_str,(S8*)asc_str);
*/
	mmi_oldman_set_language(1);

	//if(0 == is_ok)
	{
		//is_ok ++;
		GetDateTime(&curr_time);

		idle_h0 = curr_time.nHour/10;
		idle_h1 = curr_time.nHour%10;
		idle_m0 = curr_time.nMin/10;
		idle_m1 = curr_time.nMin%10;

		gui_measure_image(get_image(IMG_GLOBAL_BW_0),&img_w,&img_h);
		gui_measure_image(get_image(IMG_GLOBAL_BW_DOT),&dot_w,&dot_h);
		
		gdi_layer_get_base_handle(&mmi_base_layer);

		gdi_layer_lock_frame_buffer();
		gdi_layer_push_and_set_active(mmi_base_layer);
		gdi_layer_clear(GDI_COLOR_TRANSPARENT);
		draw_wallpaper();

		{
		// baiwenlin 20130903  时间显示
		x = (UI_device_width - img_w*4 - dot_w - gap_x*4)/2;
		y = (UI_device_height - img_h)>>1;
		gdi_image_draw_id(x, y, IMG_GLOBAL_BW_0+idle_h0);
		x += img_w+gap_x;
		gdi_image_draw_id(x, y, IMG_GLOBAL_BW_0+idle_h1);
		
		x += img_w+gap_x;
		y = (UI_device_height - dot_h)>>1;
		gdi_image_draw_id(x, y, IMG_GLOBAL_BW_DOT);
		
		x += dot_w+gap_x;
		y = (UI_device_height - img_h)>>1;
		gdi_image_draw_id(x, y, IMG_GLOBAL_BW_0+idle_m0);
		x += img_w+gap_x;
		gdi_image_draw_id(x, y, IMG_GLOBAL_BW_0+idle_m1);

				
		gui_set_text_color(gui_color(255, 255, 255));

		switch(curr_time.DayIndex)
		{
			case 0:
				gui_measure_string((UI_string_type) get_string(STR_GLOBAL_SUNDAY), &twidth, &theight);
				gui_move_text_cursor((UI_device_width - twidth) /2, y + 69);
				gui_print_text((UI_string_type) get_string(STR_GLOBAL_SUNDAY));
				break;
			case 1:
				gui_measure_string((UI_string_type) get_string(STR_GLOBAL_MONDAY), &twidth, &theight);
				gui_move_text_cursor((UI_device_width - twidth) /2, y + 69);
				gui_print_text((UI_string_type) get_string(STR_GLOBAL_MONDAY));
				break;
			case 2:
				gui_measure_string((UI_string_type) get_string(STR_GLOBAL_TUESDAY), &twidth, &theight);
				gui_move_text_cursor((UI_device_width - twidth) /2, y + 69);
				gui_print_text((UI_string_type) get_string(STR_GLOBAL_TUESDAY));
				break;
			case 3:
				gui_measure_string((UI_string_type) get_string(STR_GLOBAL_WEDNESDAY), &twidth, &theight);
				gui_move_text_cursor((UI_device_width - twidth) /2, y + 69);
				gui_print_text((UI_string_type) get_string(STR_GLOBAL_WEDNESDAY));
				break;
			case 4:
				gui_measure_string((UI_string_type) get_string(STR_GLOBAL_THURSDAY), &twidth, &theight);
				gui_move_text_cursor((UI_device_width - twidth) /2, y + 69);
				gui_print_text((UI_string_type) get_string(STR_GLOBAL_THURSDAY));
				break;
			case 5:
				gui_measure_string((UI_string_type) get_string(STR_GLOBAL_FRIDAY), &twidth, &theight);
				gui_move_text_cursor((UI_device_width - twidth) /2, y + 69);
				gui_print_text((UI_string_type) get_string(STR_GLOBAL_FRIDAY));
				break;
			case 6:
				gui_measure_string((UI_string_type) get_string(STR_GLOBAL_SATURDAY), &twidth, &theight);
				gui_move_text_cursor((UI_device_width - twidth) /2, y + 69);
				gui_print_text((UI_string_type) get_string(STR_GLOBAL_SATURDAY));
				break;				
			default:

				break;
		}


		// baiwenlin 20130903  信号显示
		if(mmi_bootup_is_sim_valid())
		{
			switch(wgui_status_icon_bar_icons[STATUS_ICON_SIGNAL_STRENGTH].state)
			{
			/*
				case 0:
					signal_img_id = IMG_GLOBAL_BW_NO_SIM_CARD;
					break;
				case 1:
					signal_img_id = IMG_GLOBAL_BW_SIGNAL1;
					break;
			*/		
				case 0:
				case 1:
				case 2:
					signal_img_id = IMG_GLOBAL_BW_SIGNAL2;
					break;
				case 3:
					signal_img_id = IMG_GLOBAL_BW_SIGNAL3;
					break;
				case 4:
				case 5:
					signal_img_id = IMG_GLOBAL_BW_SIGNAL4;
					break;
				default:
					signal_img_id = IMG_GLOBAL_BW_SIGNAL1;
					break;
			}
		}
		else
		{
			signal_img_id = IMG_GLOBAL_BW_NO_SIM_CARD;
		}
		gui_measure_image(get_image(signal_img_id),&img_w,&img_h);
		x = 2;
		y = gap_y + 2;
		gdi_image_draw_id(x, y, signal_img_id);

		// baiwenlin 20130903  电量显示
		if (srv_charbat_is_charging())
		{// baiwenlin 20130831  充电状态
			bat_img_id = IMG_GLOBAL_BW_BAT_ON_CHARGIMG;
			if(1 == g_charbat_context.ChargingComplete)
			{// baiwenlin 20130831  充电满状态
				bat_img_id = IMG_GLOBAL_BW_BAT_ON_FULL;
			}
		}
		else
		{
			switch(wgui_status_icon_bar_icons[STATUS_ICON_BATTERY_STRENGTH].state)
			{
				case 0:
					bat_img_id = IMG_GLOBAL_BW_BAT1;
					break;
				case 1:
					bat_img_id = IMG_GLOBAL_BW_BAT2;
					break;
				case 2:
					bat_img_id = IMG_GLOBAL_BW_BAT3;
					break;
				case 3:
					bat_img_id = IMG_GLOBAL_BW_BAT4;
					break;
				default:
					bat_img_id = IMG_GLOBAL_BW_BAT1;
					break;
			}
		}
		gui_measure_image(get_image(bat_img_id),&img_w,&img_h);
		x = UI_DEVICE_WIDTH - img_w - gap_x;
		y = 2;
		gdi_image_draw_id(x, y, bat_img_id);

		// baiwenlin 20130903  GPS状态显示
		/*if(mmi_bootup_is_sim_valid())
		{
			if(mmi_get_gps_status())
			{
				gps_status_img = IMG_GLOBAL_BW_GPS_ON;
			}
			else
			{
				gps_status_img = IMG_GLOBAL_BW_GPS_OFF;
			}
			gui_measure_image(get_image(gps_status_img),&gps_img_w,&gps_img_h);
			x -= (gps_img_w + gap_x);
			y = gap_y;
			gdi_image_draw_id(x, y, gps_status_img);
		}*/
		}

		gdi_layer_pop_and_restore_active();

		gdi_layer_unlock_frame_buffer();

		gdi_layer_blt(mmi_base_layer,0,0,0,0,0,UI_DEVICE_WIDTH,UI_DEVICE_HEIGHT);
		
		//gui_start_timer(5000,mmi_idle_redraw);
	}

#if 1//ndef WIN32
    ClearKeyHandler(KEY_LEFT_ARROW, KEY_EVENT_UP);
    ClearKeyHandler(KEY_LEFT_ARROW, KEY_EVENT_DOWN);
    ClearKeyHandler(KEY_LEFT_ARROW, KEY_LONG_PRESS);

    ClearKeyHandler(KEY_RIGHT_ARROW, KEY_EVENT_UP);
    ClearKeyHandler(KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
    ClearKeyHandler(KEY_RIGHT_ARROW, KEY_LONG_PRESS);

    ClearKeyHandler(KEY_UP_ARROW, KEY_EVENT_UP);
    ClearKeyHandler(KEY_UP_ARROW, KEY_EVENT_DOWN);
    ClearKeyHandler(KEY_UP_ARROW, KEY_LONG_PRESS);

    ClearKeyHandler(KEY_DOWN_ARROW, KEY_EVENT_UP);
    ClearKeyHandler(KEY_DOWN_ARROW, KEY_EVENT_DOWN);
    ClearKeyHandler(KEY_DOWN_ARROW, KEY_LONG_PRESS);

	//SetKeyHandler(kjx_oldman_key_sos3, KEY_LEFT_ARROW, KEY_EVENT_UP);
	//SetKeyHandler(kjx_oldman_key_sos3, KEY_RIGHT_ARROW, KEY_EVENT_UP);
	//SetKeyHandler(kjx_oldman_key_sos3, KEY_UP_ARROW, KEY_EVENT_UP);
	//SetKeyHandler(kjx_oldman_key_sos3, KEY_DOWN_ARROW, KEY_EVENT_UP);
	
	SetKeyHandler(EntryScr_message, KEY_POWER, KEY_EVENT_UP);
	
	SetKeyHandler(EntryScr_message, KEY_LEFT_ARROW, KEY_EVENT_UP);
#endif


}


void show_HeartRate(void)
{

	S16 zx1=0,zx2=UI_device_width,zy1=0,zy2=UI_device_height;

    S32 twidth, theight;
	
    S32 text_x ,text_y;

	char hrdata[40]={0};

	char hrtext[40]={0};
	
	char hrtext_buff[40]={0};
	

	gui_push_clip();
	
	gui_set_clip(zx1, zy1,zx2,zy2);
	
	gdi_draw_solid_rect(0, 0,UI_device_width,UI_device_height, GDI_COLOR_WHITE);

	gdi_image_draw_id(0, 0, IMG_GLOBAL_RATE);

	memset(hrdata, 0, sizeof(hrdata));

	memset(hrtext, 0, sizeof(hrtext));
	
	memset(hrtext_buff, 0, sizeof(hrtext_buff));

	strcpy(hrtext,"心率: ");

#ifdef WIN32
	sprintf(hrdata,"%f",98);
#else
	sprintf(hrdata,"%f",myHR);
#endif

	strcat(hrtext,hrdata); 
	
	chinese_char_to_unicode((unsigned char *)hrtext_buff,strlen(hrtext)*2+1, ( kal_uint8 *)hrtext);

	gui_set_font(&MMI_medium_font);
	
	gui_set_text_color(UI_COLOR_WHITE);
	
	gui_measure_string((UI_string_type)hrtext_buff, &twidth, &theight);
	
    text_x = (UI_device_width - twidth) >> 1;
	
    text_y = (UI_device_height - theight) >> 1;
	
    gui_move_text_cursor(text_x, text_y - 35 );
	
	gui_print_text((UI_string_type)hrtext_buff);
			
	gui_pop_clip();
	
	gui_BLT_double_buffer(0, 0,UI_device_width,UI_device_height);
 	
	
}


void mmi_HeartRate_screen(mmi_scrn_essential_struct *data)
{
	/*----------------------------------------------------------------*/
	/* Local Variables 											   */
	/*----------------------------------------------------------------*/
	U16 nStrItemList[MAX_SUB_MENUS];	 /* Stores the strings id of submenus returned */
	U16 nNumofItem;					 /* Stores no of children in the submenu */
	U8 *guiBuffer; 			 /* Buffer holding history data */
	U16 SettingsSubmenuImageList[MAX_SUB_MENUS];
	S16 error;

	/*----------------------------------------------------------------*/
	/* Code Body													   */
	/*----------------------------------------------------------------*/

	if (!mmi_frm_scrn_enter(GRP_ID_IDLE_MAIN, SCR_ID_PHONE_0, NULL, mmi_HeartRate_screen, MMI_FRM_UNKNOW_SCRN))
	{
	return;
	}

	guiBuffer = mmi_frm_scrn_get_gui_buf(GRP_ID_PHNSET_MENU, SCR_ID_PHONE_0);
	nNumofItem = GetNumOfChild_Ext(MAIN_MENU_SETTINGS_MENUID);


	GetSequenceStringIds_Ext(MAIN_MENU_SETTINGS_MENUID, nStrItemList);

	GetSequenceImageIds_Ext(MAIN_MENU_SETTINGS_MENUID, SettingsSubmenuImageList);

	SetParentHandler(MAIN_MENU_SETTINGS_MENUID);

	RegisterHighlightHandler(ExecuteCurrHiliteHandler);

	show_HeartRate();

	SetKeyHandler(mmi_idle_display, KEY_POWER, KEY_EVENT_UP);

	SetKeyHandler(mmi_idle_display, KEY_LEFT_ARROW, KEY_EVENT_UP);

}

void EntryScr_HeartRate(void)
{

	StopTimer(MMI_OLDMAN_LOCK_TIMER);

	mmi_frm_group_enter(GRP_ID_IDLE_MAIN, MMI_FRM_NODE_SMART_CLOSE_FLAG);
	mmi_frm_scrn_first_enter(
	GRP_ID_IDLE_MAIN, 
	SCR_ID_PHONE_0,	  
	mmi_HeartRate_screen,
	NULL);
}



void show_message(void)
{

	S16 zx1=0,zx2=UI_device_width,zy1=0,zy2=UI_device_height;

    S32 twidth, theight;
	
    S32 text_x ,text_y;

	char hrdata[40]={0};

	char hrtext[40]={0};
	
	char hrtext_buff[40]={0};
	

	gui_push_clip();
	
	gui_set_clip(zx1, zy1,zx2,zy2);
	
	gdi_draw_solid_rect(0, 0,UI_device_width,UI_device_height, GDI_COLOR_WHITE);

	gdi_image_draw_id(0, 0, IMG_GLOBAL_MESSAGE);


	memset(hrdata, 0, sizeof(hrdata));

	memset(hrtext, 0, sizeof(hrtext));
	
	memset(hrtext_buff, 0, sizeof(hrtext_buff));

	strcpy(hrtext,"信息显示: ");

#ifdef WIN32
	sprintf(hrdata,"%f",98);
#else
	sprintf(hrdata,"%f",myHR);
#endif
	kal_prompt_trace(MOD_DRVKBD, "myHR2222222222 =  %s ",hrdata);			

	strcat(hrtext,hrdata); 
	
	chinese_char_to_unicode((unsigned char *)hrtext_buff,strlen(hrtext)*2+1, ( kal_uint8 *)hrtext);

	gui_set_font(&MMI_medium_font);
	
	gui_set_text_color(UI_COLOR_WHITE);
	
	gui_measure_string((UI_string_type)hrtext_buff, &twidth, &theight);
	
    text_x = (UI_device_width - twidth) >> 1;
	
    text_y = (UI_device_height - theight) >> 1;
	
    gui_move_text_cursor(text_x, text_y );
	
	gui_print_text((UI_string_type)hrtext_buff);
			
	gui_pop_clip();
	
	gui_BLT_double_buffer(0, 0,UI_device_width,UI_device_height);
 		
}


void mmi_message_screen(mmi_scrn_essential_struct *data)
{
	/*----------------------------------------------------------------*/
	/* Local Variables 											   */
	/*----------------------------------------------------------------*/
	U16 nStrItemList[MAX_SUB_MENUS];	 /* Stores the strings id of submenus returned */
	U16 nNumofItem;					 /* Stores no of children in the submenu */
	U8 *guiBuffer; 			 /* Buffer holding history data */
	U16 SettingsSubmenuImageList[MAX_SUB_MENUS];
	S16 error;

	/*----------------------------------------------------------------*/
	/* Code Body													   */
	/*----------------------------------------------------------------*/

	if (!mmi_frm_scrn_enter(GRP_ID_IDLE_MAIN, SCR_ID_PHONE_1, NULL, mmi_message_screen, MMI_FRM_UNKNOW_SCRN))
	{
	return;
	}

	guiBuffer = mmi_frm_scrn_get_gui_buf(GRP_ID_PHNSET_MENU, SCR_ID_PHONE_1);
	nNumofItem = GetNumOfChild_Ext(MAIN_MENU_SETTINGS_MENUID);


	GetSequenceStringIds_Ext(MAIN_MENU_SETTINGS_MENUID, nStrItemList);

	GetSequenceImageIds_Ext(MAIN_MENU_SETTINGS_MENUID, SettingsSubmenuImageList);

	SetParentHandler(MAIN_MENU_SETTINGS_MENUID);

	RegisterHighlightHandler(ExecuteCurrHiliteHandler);

	show_message();

	SetKeyHandler(EntryScr_HeartRate, KEY_POWER, KEY_EVENT_UP);
		
	SetKeyHandler(EntryScr_HeartRate, KEY_LEFT_ARROW, KEY_EVENT_UP);


}

void EntryScr_message(void)
{
	StopTimer(MMI_OLDMAN_LOCK_TIMER);

	StopTimer(MMI_OLDMAN_HEARTRATE_SCREEN_TIMER);

	mmi_frm_group_enter(GRP_ID_IDLE_MAIN, MMI_FRM_NODE_SMART_CLOSE_FLAG);
	mmi_frm_scrn_first_enter(
	GRP_ID_IDLE_MAIN, 
	SCR_ID_PHONE_1,	  
	mmi_message_screen,
	NULL);
}


void mmi_show_old_idle_screen(void)
{

#ifndef WIN32
	//TimeISR();
#endif
	
	StopTimer(MMI_OLDMAN_HEARTRATE_SCREEN_TIMER);

	if(g_oldman_idle_sleep == 1)
	{
		mmi_disp_lock_idlescreen();
	}
	else
	{
		StopTimer(MMI_OLDMAN_LOCK_TIMER);
		mmi_disp_old_idlescreen();
	}
}
#endif


/*****************************************************************************
 * FUNCTION
 *  ShowCategory33Screen
 * DESCRIPTION
 *  Show category 33 screen
 * PARAMETERS
 *  left_softkey            [IN]        Left softkey label
 *  left_softkey_icon       [IN]        Icon for the Left softkey
 *  right_softkey           [IN]        Right softkey label
 *  right_softkey_icon      [IN]        Icon for the right softkey
 *  history_buffer          [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory33Screen_int(
        U16 left_softkey,
        U16 right_softkey,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(__DUAL_SIM_IDLE_TEXT_AT_SAME_POSITION__) /* Dual SIM show at same position. */
    g_wgui_cat033_dual_sim_current_text_type = SIM1_TEXT_ON_IDLE;
    gui_start_timer(5000, wgui_cat033_dual_sim_text_change_processor);
#endif /* defined(__DUAL_SIM_IDLE_TEXT_AT_SAME_POSITION__) */

#ifdef __MMI_ALPHA_BLENDING__    
    dm_register_wallpaper_anim_update_callback(cat33_redraw_alpha_images);
#endif /* __MMI_ALPHA_BLENDING__ */

    ShowCategory33Screen_ext_int(
        left_softkey,
        right_softkey,
        history_buffer);
    
    GDI_LOCK;

    dm_register_category_controlled_callback(dm_category_33_controlled_area);
    
    ExitCategoryFunction = ExitCategory33Screen;
    dm_setup_category_functions(dm_redraw_category_screen, GetCategory33History, GetCategory33HistorySize);
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32CatId = MMI_CATEGORY33_ID;
#ifdef __MMI_MAINLCD_96X64__
    dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND;
#else
    dm_data.s32flags = 0;
#endif
#ifdef __MMI_TOUCH_IDLESCREEN_SHORTCUTS__
    if (MMI_TRUE)
    {
        dm_data.s32flags |= DM_NO_SOFTKEY;
    }
#endif /* __MMI_TOUCH_IDLESCREEN_SHORTCUTS__ */ 
    dm_setup_data(&dm_data);
    dm_redraw_category_screen();

    GDI_UNLOCK;
}


/*****************************************************************************
 * FUNCTION
 *  ExitCategory33Screen
 * DESCRIPTION
 *  Exits the Idle screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitCategory33Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(__DUAL_SIM_IDLE_TEXT_AT_SAME_POSITION__) /* Dual SIM show at same position. */
    gui_cancel_timer(wgui_cat033_dual_sim_text_change_processor);
#endif
#if defined(__MMI_UI_TECHNO_IDLESCREEN_BAR__) 
    gui_cancel_timer(wgui_cat033_techno_text_change_processor);
    g_wgui_cat033_techno_scroll_count = 0;
    if (PhnsetGetShowDateTimeStatus() == MMI_TRUE)
    {
        wgui_clock_close(wgui_cat033_techno_clock_date);
        wgui_cat033_techno_clock_date = WGUI_CLOCK_INVALID_INDEX;
    }
#endif /* defined(__MMI_UI_TECHNO_IDLESCREEN_BAR__) */

    leave_idle_screen();

    on_idle_screen = 0;
    set_on_idlescreen(0);

    /* reminder */
    for (i = 0; i < wgui_cat033_reminder_total; i++)
    {
        if (g_wgui_cat033_reminder[i].deinit != NULL)
        {
            g_wgui_cat033_reminder[i].deinit();
        }
        memset(&g_wgui_cat033_reminder[i], 0, sizeof(wgui_cat033_reminder_area_info));
    }
#if defined(__MMI_SEARCH_WEB__)
    gui_scrolling_text_stop(&g_search_tab_scroll_text);
    if(g_wgui_cat033_search.image != NULL || g_wgui_cat033_search.string != NULL)
    {
    memset(&g_wgui_cat033_search, 0, sizeof(wgui_cat033_search_area_info));
    }
#endif
    if (extra_scrolling_text_ptr)
    {
        gui_scrolling_text_stop(extra_scrolling_text_ptr);
        extra_scrolling_text_ptr = NULL;
    }

    extra_text_x1 = -1;
    extra_text_y1 = -1;
    extra_text_x2 = -1;
    extra_text_y2 = -1;

#ifdef __MMI_MAINLCD_96X64__
        gui_scrolling_text_stop(&g_network_names_scroll);
        memset(&g_network_names_scroll, 0, sizeof(g_network_names_scroll));
#endif
    gui_cancel_timer(cat33_animation_processor);
#if defined(ENABLE_ANIMATED_WALLPAPERS) && defined(__GDI_MEMORY_PROFILE_2__)
    if (animation_handle != GDI_ERROR_HANDLE)
    {
        gdi_image_stop_animation(animation_handle);
        animation_handle = GDI_ERROR_HANDLE;
    }
#endif /* defined(ENABLE_ANIMATED_WALLPAPERS) && defined(__GDI_MEMORY_PROFILE_2__) */ 

    /* reserve wallpaper layer content for multi-event screen */
    wgui_cat110_cache_status_bg(wgui_cat033_get_text_abm_layer());

    wgui_status_icon_bar_reset();

#if !defined(__MMI_MAINLCD_320X480__)
#ifdef WGUI_STATUS_ICON_SHOW_V_BAR
    wgui_status_icon_bar_register_hide_callback(
        WGUI_STATUS_ICON_BAR_V_BAR, 
        MMI_dummy_function);
#endif
#endif

    close_main_LCD_dt_display();
    reset_softkeys();
    enable_softkey_background();
#ifdef __MMI_UI_STATUS_BAR_AT_BOTTOM__
#if defined(__MMI_KLG__)
#ifdef WGUI_STATUS_ICON_SHOW_V_BAR
    wgui_status_icon_bar_move(
        WGUI_STATUS_ICON_BAR_V_BAR, 
        UI_device_width - 16,
        MMI_status_bar_height);
    wgui_status_icon_bar_resize(
        WGUI_STATUS_ICON_BAR_V_BAR,
        17,
        (UI_device_height >> 1) - MMI_status_bar_height + 1);
#endif
#else /* defined(__MMI_KLG__) */ 
#ifdef WGUI_STATUS_ICON_SHOW_V_BAR
    wgui_status_icon_bar_move(
        WGUI_STATUS_ICON_BAR_V_BAR, 
        UI_device_width - 16,
        MMI_status_bar_height);
    wgui_status_icon_bar_resize(
        WGUI_STATUS_ICON_BAR_V_BAR,
        17,
        UI_device_height - MMI_status_bar_height - MMI_softkey_height - 1);
#endif
#endif /* defined(__MMI_KLG__) */ 
#endif /* __MMI_UI_STATUS_BAR_AT_BOTTOM__ */ 
    wgui_status_icon_bar_move(
        WGUI_STATUS_ICON_BAR_H_BAR, 
        0, 
        0);
    wgui_cat033_reset_text_abm_layer();

    /* release DRM handler */
#ifdef __DRM_SUPPORT__
	if (consumer >= DRM_RESULT_OK)
	{
		DRM_stop_consume(consumer);
	}
#endif /* __DRM_SUPPORT__ */
#ifdef __MMI_IDLE_FULL_SCREEN__
  #if defined(__MMI_MAINLCD_128X128__) || defined(__MMI_MAINLCD_128X160__)
        set_softkey_flags_off(UI_BUTTON_TEXT_WITH_BORDER, MMI_LEFT_SOFTKEY);
        set_softkey_flags_off(UI_BUTTON_TEXT_WITH_BORDER, MMI_RIGHT_SOFTKEY);
  #endif /* __MMI_MAINLCD_128X128__ || __MMI_MAINLCD_128X160__ */
#endif /* __MMI_IDLE_FULL_SCREEN__ */ 
#ifdef __MMI_FTE_SUPPORT__
        set_softkey_flags_off(UI_BUTTON_TEXT_WITH_BORDER, MMI_LEFT_SOFTKEY);
        set_softkey_flags_off(UI_BUTTON_TEXT_WITH_BORDER, MMI_RIGHT_SOFTKEY);
#endif
}


extern gdi_handle animation_handle;
/*****************************************************************************
 * FUNCTION
 *  wgui_cat106_redraw
 * DESCRIPTION
 *  redraw category106 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat106_redraw(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 SScallbackID, n_frames = 0;    
    S32 img_width = 0, img_height = 0;
    S32 offset_x = 0, offset_y = 0;
    PU8 image;    
    U16 img_type;
    color c = gui_color(0, 0, 0);
    GDI_RESULT ret;
    gdi_handle handle;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    c.alpha = 100;

    gui_lock_double_buffer();
    gui_reset_clip();
    clear_screen();
    gui_fill_rectangle(0, 0, UI_device_width - 1, UI_device_height - 1, c);
    if (ScreenSaverName == NULL) /* from resource */
    {
        wgui_show_animation();
    }
    else /* from file */
    {
        gdi_image_gif_get_frame_count_file((CHAR*) ScreenSaverName, &n_frames);
        gdi_image_get_dimension_file((CHAR*) ScreenSaverName, &img_width, &img_height);

        if (n_frames > 1)
        {
            ret = gdi_image_draw_animation_file(
                    (UI_device_width - img_width) >> 1,
                    (UI_device_height - img_height) >> 1,
                    (CHAR*) ScreenSaverName,
                    &handle);
        }
        else
        {
            /* The orignal implementation seems just to fill whole screen */
            if ((UI_device_width >= img_width) && (UI_device_height >= img_height))
            {
                /* align in the center */
                offset_x = (UI_device_width - img_width) >> 1;
                offset_y = (UI_device_height - img_height) >> 1;
                ret = gdi_image_draw_file(offset_x, offset_y, (CHAR *) ScreenSaverName);
            }
            else
            {
                img_type = gdi_image_get_type_from_file((CHAR *) ScreenSaverName);
                
                if (img_type == GDI_IMAGE_TYPE_JPG_FILE)
                {
                
                    S32 resized_offset_x;
                    S32 resized_offset_y;
                    S32 resized_width;
                    S32 resized_height;
                    
                    gdi_image_util_fit_bbox(
                        UI_device_width,
                        UI_device_height,
                        img_width,
                        img_height,
                        &resized_offset_x,
                        &resized_offset_y,
                        &resized_width,
                        &resized_height);
                    
                    ret = gdi_image_draw_resized_file(
                            resized_offset_x,
                            resized_offset_y,
                            resized_width,
                            resized_height,
                            (CHAR *) ScreenSaverName);
                }
                else
                {
                    ret = gdi_image_draw_file(offset_x, offset_y, (CHAR *) ScreenSaverName);
                }
            }
        }

        if (ret < 0 && ret != GDI_GIF_ERR_OUT_OF_CLIP_REGION && ret != GDI_BMP_ERR_OUT_OF_CLIP_REGION)
        {
            SScallbackID = PhnsetScreenSaverBadFileCallBack(0);
            image = (PU8)GetImage((U32)SScallbackID);
            gui_measure_image(image, &img_width, &img_height);

            /* align in center */
            gdi_image_draw_animation(
                (UI_device_width - img_width) >> 1,
                (UI_device_height - img_height) >> 1,
                image,
                &animation_handle);
        }
    }
    gui_unlock_double_buffer();
    gui_BLT_double_buffer(0, 0, UI_device_width - 1, UI_device_height - 1);
}


/*****************************************************************************
 * FUNCTION
 *  ExitCategory106Screen
 * DESCRIPTION
 *  Exit category106 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitCategory106Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (animation_handle != GDI_ERROR_HANDLE)
    {
        gdi_image_stop_animation(animation_handle);
    }
}


/*****************************************************************************
 * FUNCTION
 *  ShowCategory106Screen
 * DESCRIPTION
 *  Show category106 screen (an animated icon)
 * PARAMETERS
 *  icon_screensaver        [IN]        screen saver image ID
 *  filename                [IN]        screen saver image file path
 *  history_buffer          [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory106Screen(U16 icon_screensaver, U8 *filename, U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(history_buffer);

    entry_full_screen();
    gui_lock_double_buffer();
    clear_category_screen_key_handlers();
    screen_saver_type = NORMAL_SCREEN_SAVER;
    if (icon_screensaver != 0) /* from resource */
    {
        wgui_set_animation((UI_device_width >> 1), (UI_device_height >> 1), icon_screensaver);
        ScreenSaverName = NULL;
    }
    else /* from file */
    {
        ScreenSaverName = filename;
    }

    gui_unlock_double_buffer();
    ExitCategoryFunction = ExitCategory106Screen;
    dm_setup_category_functions(wgui_cat106_redraw, dummy_get_history, dummy_get_history_size);
    wgui_cat106_redraw();
}


#ifdef __MMI_LCD_PARTIAL_ON__

#if defined(__MMI_MAINLCD_128X128__) || defined (__MMI_MAINLCD_128X160__)
#define WGUI_CAT161_X_GAP    (2)
#else 
#define WGUI_CAT161_X_GAP    (3)
#endif /* defined(__MMI_MAINLCD_128X128__) || defined (__MMI_MAINLCD_128X160__) */

static UI_time g_wgui_cat161_time;
static S32 g_wgui_cat161_last_y_offset;

extern stFontAttribute wgui_dialer_box_f1;

/*****************************************************************************
 * FUNCTION
 *  Category161ChangeTime
 * DESCRIPTION
 *  change the time of category161 screen
 * PARAMETERS
 *  t       [IN]        Time
 * RETURNS
 *  void
 *****************************************************************************/
void Category161ChangeTime(UI_time *t)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_wgui_cat161_time = *t;
}


/*****************************************************************************
 * FUNCTION
 *  RedrawCategory161Screen
 * DESCRIPTION
 *  Redraw category161 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void RedrawCategory161Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    color c;
    S32 twidth, theight;
    S32 y_round, partial_on_height = UI_LCD_PARTIAL_ON_HEIGHT;
    S32 x1, x2, y1, y2, y2_last = 0;
    S32 text_x;
    S32 icon_width, icon_height;
    int icon_index, num_icon_displayed;
    U8 timestr[64];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_lock_double_buffer();

#if defined(BLACK_BACKLIGHT)
    c.r = c.g = c.b = 0;
#elif defined(BLUE_BACKLIGHT)
    c.r = c.g = 0;
    c.b = 255;
#elif defined(WHITE_BACKLIGHT)
    c.r = c.g = c.b = 255;
#else 
    c.r = c.g = c.b = 255;
#endif /* defined(BLACK_BACKLIGHT) */

    c.alpha = 100;

#ifndef WIN32
    if(!srv_backlight_is_lcd_sleep())
    {
    y_round = lcd_partial_display_align_line(MAIN_LCD);
    if (y_round > 1 && (partial_on_height % y_round) != 0)
    {
        partial_on_height += (y_round - (partial_on_height % y_round));
    }
    }
#endif /* WIN32 */ 
    y_round = UI_device_height / partial_on_height;

    x1 = 0;
    y1 = (g_wgui_cat161_time.nMin % y_round) * partial_on_height;
    x2 = UI_device_width - 1;
    y2 = y1 + partial_on_height - 1;
    if (g_wgui_cat161_last_y_offset >= 0 && g_wgui_cat161_last_y_offset != y1)
    {
        y2_last = g_wgui_cat161_last_y_offset + partial_on_height - 1;
    }

    /* Dialing font has only english characters */
    time_string(&g_wgui_cat161_time, (UI_string_type) timestr, DT_IDLE_SCREEN_ENGLISH_ONLY);

    gui_push_clip();
    gui_push_text_clip();

    gui_set_clip(0, 0, UI_device_width - 1, UI_device_height - 1);
    gui_set_text_clip(0, 0, UI_device_width - 1, UI_device_height - 1);

    if (g_wgui_cat161_last_y_offset >= 0 && g_wgui_cat161_last_y_offset != y1)
    {
        gui_fill_rectangle(x1, g_wgui_cat161_last_y_offset, x2, y2_last, c); /* last time region */
    }
    gui_fill_rectangle(x1, y1, x2, y2, c); /* new region */

#if defined(__MMI_MAINLCD_128X128__) || defined (__MMI_MAINLCD_128X160__)
    gui_set_font(&MMI_large_font);
#else /* defined(__MMI_MAINLCD_128X128__) || defined (__MMI_MAINLCD_128X160__) */
    gui_set_font(&wgui_dialer_box_f1);
#endif /* defined(__MMI_MAINLCD_128X128__) || defined (__MMI_MAINLCD_128X160__) */

    gui_measure_string((UI_string_type) timestr, &twidth, &theight);
    text_x = (UI_device_width - twidth) >> 1;
    wgui_status_icon_bar_arrange_partial();
    if (wgui_status_icon_bar_partial_display_icon_number > 0)
    {
        gui_measure_image(get_image(wgui_status_icon_bar_get_icon_image_id(0)), &icon_width, &icon_height);
        if ((WGUI_CAT161_X_GAP + (icon_width + WGUI_CAT161_X_GAP) * wgui_status_icon_bar_partial_display_icon_number)
            * 2 + twidth > UI_device_width)
        {
            /* Do not center the text */
            num_icon_displayed = (UI_device_width - twidth - (WGUI_CAT161_X_GAP * 2)) / (icon_width + WGUI_CAT161_X_GAP);
            if (num_icon_displayed > wgui_status_icon_bar_partial_display_icon_number)
            {
                num_icon_displayed = wgui_status_icon_bar_partial_display_icon_number;
            }
            text_x = WGUI_CAT161_X_GAP + (icon_width + WGUI_CAT161_X_GAP) * num_icon_displayed;
        }
        else
        {
            text_x = (UI_device_width - twidth) >> 1;
            num_icon_displayed = wgui_status_icon_bar_partial_display_icon_number;
        }

        for (icon_index = 0; icon_index < num_icon_displayed; icon_index++)
        {
            if (icon_height > partial_on_height)
            {
                break;  /* Abnormal case */
            }

            gui_show_transparent_image(
                WGUI_CAT161_X_GAP + (WGUI_CAT161_X_GAP + icon_width) * icon_index,
                y1 + ((partial_on_height - icon_height) >> 1),
                get_image(wgui_status_icon_bar_get_icon_image_id(wgui_status_icon_bar_partial_list_display[icon_index])),
                0);
        }
    }

#if defined(BLACK_BACKLIGHT)
    gui_set_text_color(gui_color(255, 255, 255));
#else
    gui_set_text_color(gui_color(0, 0, 0));
#endif /* defined(BLACK_BACKLIGHT) */

    if (r2lMMIFlag)
    {
        gui_move_text_cursor((text_x + twidth - 1), y1 + ((partial_on_height - theight) >> 1));
    }
    else
    {
        gui_move_text_cursor(text_x, y1 + ((partial_on_height - theight) >> 1));
    }
    gui_print_text((UI_string_type) timestr);
    gui_set_font(&MMI_medium_font);

    gui_pop_text_clip();
    gui_pop_clip();

    gui_unlock_double_buffer();

    /* Try to reduce the BLT region in order to save computation power */
    if (g_wgui_cat161_last_y_offset == -1) /* First time */
    {
        gui_BLT_double_buffer(0, 0, UI_device_width - 1, UI_device_height - 1);
    }
    else
    {
        if (g_wgui_cat161_last_y_offset != y1)
        {
            gui_BLT_double_buffer(x1, g_wgui_cat161_last_y_offset, x2, y2_last);
        }
        gui_BLT_double_buffer(x1, y1, x2, y2);
    }
    g_wgui_cat161_last_y_offset = y1;

#ifndef WIN32
    lcd_partial_on(MAIN_LCD, y1, y2);
#endif 
}


/*****************************************************************************
 * FUNCTION
 *  ExitCategory161Screen
 * DESCRIPTION
 *  Exit category161 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitCategory161Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifndef WIN32
    lcd_partial_off(MAIN_LCD);
#endif 
    /* Because partial display is text on white background,
       it looks weird if new popup comes and we don't clear background here. */
#if defined(BLACK_BACKLIGHT)
    gdi_layer_clear(GDI_COLOR_BLACK);
#elif defined(BLUE_BACKLIGHT)
    gdi_layer_clear(GDI_COLOR_BLUE);
#elif defined(WHITE_BACKLIGHT)
    gdi_layer_clear(GDI_COLOR_WHITE);
#else
    gdi_layer_clear(GDI_COLOR_WHITE);
#endif /* defined(BLACK_BACKLIGHT) */

    leave_full_screen();
}


/*****************************************************************************
 * FUNCTION
 *  ShowCategory161Screen
 * DESCRIPTION
 *  Show category161 screen (time screen saver)
 * PARAMETERS
 *  t       [IN]        Time
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory161Screen(UI_time *t)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    color c;

    g_wgui_cat161_time = *t;
    g_wgui_cat161_last_y_offset = -1;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(BLACK_BACKLIGHT)
    c.r = c.g = c.b = 0;
#elif defined(BLUE_BACKLIGHT)
    c.r = c.g = 0;
    c.b = 255;
#elif defined(WHITE_BACKLIGHT)
    c.r = c.g = c.b = 255;
#else 
    c.r = c.g = c.b = 255;
#endif  /* defined(BLACK_BACKLIGHT) */

    c.alpha = 100;

    entry_full_screen();

    gui_lock_double_buffer();
    gui_push_clip();
    gui_set_clip(0, 0, UI_device_width - 1, UI_device_height - 1);
    
    /* Delay filling white until RedrawCategory161Screen. We do not redraw the whole screen for each update. */
    gui_fill_rectangle(0, 0, UI_device_width - 1, UI_device_height - 1, c);

    gui_pop_clip();
    gui_unlock_double_buffer();

    ExitCategoryFunction = ExitCategory161Screen;
    dm_setup_category_functions(RedrawCategory161Screen, dummy_get_history, dummy_get_history_size);

    RedrawCategory161Screen();
}
#endif /* __MMI_LCD_PARTIAL_ON__ */ 


#ifdef __MMI_UI_ANIMATED_TITLE_EFFECT__
/*****************************************************************************
 * FUNCTION
 *  show_network_detail_on_animated_highlighter_on_idlescreen
 * DESCRIPTION
 *  Handle title text on idlescreen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void show_network_detail_on_animated_highlighter_on_idlescreen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    idle_screen_show_network_details();
}

#endif /* __MMI_UI_ANIMATED_TITLE_EFFECT__ */ 


#if defined(__MMI_SCREEN_SWITCH_EFFECT__) && defined(__MMI_TOUCH_IDLESCREEN_SHORTCUTS__) && defined(__MMI_UI_TECHNO_IDLESCREEN_BAR__)
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
        #ifdef __GDI_MEMORY_PROFILE_2__
/* under construction !*/
        #else /* __GDI_MEMORY_PROFILE_2__ */
/* under construction !*/
        #endif /* __GDI_MEMORY_PROFILE_2__ */
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
#endif /* defined(__MMI_SCREEN_SWITCH_EFFECT__) && defined(__MMI_TOUCH_IDLESCREEN_SHORTCUTS__) && defined(__MMI_UI_TECHNO_IDLESCREEN_BAR__) */


#if defined(__MMI_FANCY_SCREEN_LOCK__)

#define WGUI_CAT30_PLAY_BUTTON_BAR_SEQ (200)

#define WGUI_CAT30_LONG_PRESS_SIMULATION_INTERVAL (300)

static U32 wgui_cat30_clock_time = WGUI_CLOCK_INVALID_INDEX;
static U32 wgui_cat30_clock_date = WGUI_CLOCK_INVALID_INDEX;
static U32 wgui_cat30_clock_day = WGUI_CLOCK_INVALID_INDEX;

/*Icon Text Info coordinates macros */
#define WGUI_CAT30_ICON_TEXT_V_GAP (2)
#define WGUI_CAT30_ICON_H_MARGIN   (10)    
#define WGUI_CAT30_MAX_ICON_WIDTH  (20)
#define WGUI_CAT30_MIN_ICON_TEXT_H_GAP (2)


typedef struct _wgui_cat30_cntx_struct
{
    S32 date_time_bar_y;
    FuncPtr callback_to_app; 
    U16* unlock_bar_str;
    U16 *text_info1;
    PU8 icon_info1; 
    U16 *text_info2;
    PU8 icon_info2; 
    U16 *text_info3;
    PU8 icon_info3;
    U16 unlock_bar_image_index;
} wgui_cat30_cntx_struct;


wgui_cat30_cntx_struct wgui_cat30_cntx_obj;
static MMI_BOOL g_wgui_cat30_is_normal_exit = MMI_FALSE;


/*****************************************************************************
 * FUNCTION
 *  wgui_cat30_set_line_info 
 * DESCRIPTION
 *  Its sets the icon and text information for the lines
 * PARAMETERS
 *  index           [IN]    index of the line
 *  info_str        [IN]    information string
 *  info_img        [IN]    information image
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat30_set_line_info(S32 index, U16 * info_str, PU8 info_img)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch(index)
    {
        case WGUI_CAT30_ICON_TEXT_INFO1:
        {
            wgui_cat30_cntx_obj.text_info1 = info_str;
            wgui_cat30_cntx_obj.icon_info1 = info_img;
            break;
        }
        case WGUI_CAT30_ICON_TEXT_INFO2:
        {
            wgui_cat30_cntx_obj.text_info2 = info_str;
            wgui_cat30_cntx_obj.icon_info2 = info_img;
            break;
        }
        case WGUI_CAT30_ICON_TEXT_INFO3:
        {
            wgui_cat30_cntx_obj.text_info3 = info_str;
            wgui_cat30_cntx_obj.icon_info3 = info_img;
            break;
        }
        default:
            MMI_ASSERT(0);
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat30_draw_string 
 * DESCRIPTION
 *  Draw border text in given region
 *  If the string width is longer than giver region, it will show trancated text.
 * PARAMETERS
 *  string    :[IN]    string
 *  x1        :[IN]    start x
 *  y1        :[IN]    start y
 *  x2        :[IN]    end x
 *  y2        :[IN]    end y
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat30_draw_string(UI_string_type string, S32 x1, S32 y1, S32 x2, S32 y2, color text_color, color border_color)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 string_w = 0, string_h = 0, w = 0, x = 0, y = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (string != NULL)
    {     
        gui_set_font(&MMI_medium_font);
        gui_set_text_border_color(border_color);
        gui_set_text_color(text_color);

        gui_measure_string(string, &string_w, &string_h);
        string_w += 2; /* border text */
        string_h += 2; /* border text */       
        
        gdi_layer_push_clip();
        gdi_layer_set_clip(x1, y1, x2, y2);
        gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_TRANSPARENT);


        y = y1 + ((y2 - y1 + 1) >> 1) - (string_h >> 1) + 1 /* border text */;
        x = (r2lMMIFlag) ? (x2) : (x1);
        x += (r2lMMIFlag) ? (-1) : (1); 
        if (string_w < x2 - x1 + 1)
        {
            gui_move_text_cursor(x, y);
            gui_print_bordered_text(string);
        }
        else
        {
            w = x2 - x1 + 1;
            gui_print_truncated_borderd_text(x, y, w, string);
        }
        gdi_layer_pop_clip();
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat30_draw_image
 * DESCRIPTION
 *  Draw image in the given position with vertically center alignment
  * PARAMETERS
 *  image     :[IN]    image
 *  x1        :[IN]    start x
 *  y1        :[IN]    start y
 *  h         :[IN]    height
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat30_draw_image(U8* image, S32 x1, S32 y1, S32 h)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 img_w = 0, img_h = 0;
    S32 y;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_measure_image(image, &img_w, &img_h);
    y = y1 + ((h - img_h) >> 1);
    gui_show_image(x1, y, image);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat30_draw_details 
 * DESCRIPTION
 *  Draw the displayed details of category30,
 *  It draw the icon txt information  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat30_draw_details(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 str_x, str_y, str_h;
    S32 bk_image_w1 = 0, bk_image_h1 = 0;
    PU8 bk_image1 = NULL;
    PU8 bk_image2 = NULL;
    S32 bk_image_w2 = 0, bk_image_h2 = 0;
    S32 text_offset = 0;
    GDI_HANDLE wallpaper_layer = dm_get_wallpaper_layer();


    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    bk_image1 = get_image(IMG_KEYPAD_LOCK_UNLOCK_BAR_BG);
    gui_measure_image(bk_image1, &bk_image_w1, &bk_image_h1);
    bk_image2 = get_image(IMG_KEYPAD_LOCK_UNLOCK_TIME_BAR_BG);
    gui_measure_image(bk_image2, &bk_image_w2, &bk_image_h2);

    gdi_layer_lock_frame_buffer();
    gdi_layer_push_and_set_active(GDI_LAYER_MAIN_BASE_LAYER_HANDLE);
    gdi_layer_push_clip();
    gdi_layer_set_clip(
              0, 
              MMI_STATUS_BAR_HEIGHT + bk_image_h2,
              MAIN_LCD_DEVICE_WIDTH - 1,
              MAIN_LCD_DEVICE_HEIGHT - bk_image_h1 - 1);


    gdi_push_and_set_alpha_blending_source_layer(wallpaper_layer);
    /* clear all */
    gdi_draw_solid_rect(
              0, 
              MMI_STATUS_BAR_HEIGHT + bk_image_h2,
              MAIN_LCD_DEVICE_WIDTH - 1,
              MAIN_LCD_DEVICE_HEIGHT - bk_image_h1 - 1,
              GDI_COLOR_TRANSPARENT);
    str_x = WGUI_CAT30_ICON_H_MARGIN + WGUI_CAT30_MAX_ICON_WIDTH + WGUI_CAT30_MIN_ICON_TEXT_H_GAP;
    str_h = Get_CharDisplayHeightOfAllLangAndType(MMI_medium_font.size);
    str_y = MMI_STATUS_BAR_HEIGHT + bk_image_h2 + WGUI_CAT30_ICON_TEXT_V_GAP;
	/* draw info 1 */
	if (wgui_cat30_cntx_obj.text_info1 != NULL)
	{
        wgui_cat30_draw_image(wgui_cat30_cntx_obj.icon_info1, WGUI_CAT30_ICON_H_MARGIN, str_y, str_h);
        wgui_cat30_draw_string(
                      wgui_cat30_cntx_obj.text_info1, 
                      str_x,
                      str_y,
                      UI_device_width - WGUI_CAT30_ICON_H_MARGIN - 1,
                      str_y + str_h - 1,
					  gui_color(255, 255, 255),
					  gui_color(0, 0, 0));
        str_y += (str_h + WGUI_CAT30_ICON_TEXT_V_GAP);
	}

    /* draw info 2 */
    if (wgui_cat30_cntx_obj.text_info2 != NULL)
    {
        wgui_cat30_draw_image(wgui_cat30_cntx_obj.icon_info2, WGUI_CAT30_ICON_H_MARGIN, str_y, str_h);   
        wgui_cat30_draw_string(
                      wgui_cat30_cntx_obj.text_info2, 
                      str_x,
                      str_y,
                      UI_device_width - WGUI_CAT30_ICON_H_MARGIN - 1,
                      str_y + str_h - 1,
					  gui_color(255, 255, 255),
					  gui_color(0, 0, 0));
        str_y += (str_h + WGUI_CAT30_ICON_TEXT_V_GAP);

    }
    /* draw info 3 */
    if (wgui_cat30_cntx_obj.text_info3 != NULL)
    {
        wgui_cat30_draw_image(wgui_cat30_cntx_obj.icon_info3, WGUI_CAT30_ICON_H_MARGIN, str_y, str_h);   
        wgui_cat30_draw_string(
                      wgui_cat30_cntx_obj.text_info3, 
                      str_x,
                      str_y,
                      UI_device_width - WGUI_CAT30_ICON_H_MARGIN - 1,
                      str_y + str_h - 1,
					  gui_color(255, 255, 255),
					  gui_color(0, 0, 0));
    }
    gdi_pop_and_restore_alpha_blending_source_layer();
    gdi_layer_pop_clip();
    gdi_layer_pop_and_restore_active();
    gdi_layer_unlock_frame_buffer();
    gdi_layer_blt_previous(0, 0, UI_device_width - 1, UI_device_height - 1);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat30_hide_date_time_bar 
 * DESCRIPTION
 *  Hide function for category 30 date time bar
 * PARAMETERS
 *  x1      : [IN] 
 *  y1      : [IN]
 *  x2      : [IN]
 *  y2      : [IN]
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat30_hide_date_time_bar(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 bk_image_w = 0, bk_image_h = 0;
    S32 bk_image_y;
    PU8 bk_image =NULL;
    S32 text_offset = 0;
    GDI_HANDLE wallpaper_layer = dm_get_wallpaper_layer();

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    bk_image = get_image(IMG_KEYPAD_LOCK_UNLOCK_TIME_BAR_BG);
    gui_measure_image(bk_image, &bk_image_w, &bk_image_h);
    bk_image_y = wgui_cat30_cntx_obj.date_time_bar_y;
    gui_push_clip();
    gui_set_clip(x1, y1, x2, y2);
    gdi_push_and_set_alpha_blending_source_layer(wallpaper_layer);
    gui_show_image(0, bk_image_y, bk_image); 
    gdi_pop_and_restore_alpha_blending_source_layer();
    gui_pop_clip();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat30_init_date_time_bar 
 * DESCRIPTION
 *  Init date time bar 
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat30_init_date_time_bar(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 time_x = 0, time_y = 0;
    S32 time_width = 0, time_height = 0;
    S32 date_x = 0, date_y = 0;
    S32 date_width = 0, date_height = 0;
    S32 day_x = 0, day_y = 0;
    S32 day_width = 0, day_height = 0; 
    PU8 bk_image = NULL;
    S32 bk_image_w = 0, bk_image_h = 0;
    S32 height_offset = 0;
    S32 width_offset = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    bk_image = get_image(IMG_KEYPAD_LOCK_UNLOCK_TIME_BAR_BG);
    gui_measure_image(bk_image, &bk_image_w, &bk_image_h);
    /* Time */
    wgui_clock_create(
        &wgui_cat30_clock_time,         
        0, 0, 0, 0,                             
        GUI_CLOCK_MAINLCD_TYPE_DIGITAL_TIME_IMAGE);   
    //wgui_clock_set_text_border_enable(wgui_cat30_clock_time, MMI_TRUE);
    //wgui_clock_set_time_text_border_color(wgui_cat30_clock_time, gui_color(0, 0, 0));
    //wgui_clock_set_time_text_color(wgui_cat30_clock_time, gui_color(255, 255, 255));
    //wgui_clock_set_time_text_font(wgui_cat30_clock_time, &MMI_large_font);
    wgui_clock_set_hide_function(wgui_cat30_clock_time, wgui_cat30_hide_date_time_bar);
    wgui_clock_measure_digital_clock(wgui_cat30_clock_time, &time_width, &time_height);
    //wgui_clock_measure_time_text(wgui_cat30_clock_time, &time_width, &time_height, &MMI_large_font);
    wgui_clock_resize(wgui_cat30_clock_time, time_width, time_height);
    wgui_clock_set_digital_align_type(wgui_cat30_clock_time, GUI_CLOCK_DIGITAL_ALIGN_CENTER);
    wgui_clock_set_abm_layer(wgui_cat30_clock_time, GDI_LAYER_MAIN_BASE_LAYER_HANDLE);

    /* Date */
    wgui_clock_create(
        &wgui_cat30_clock_date,          
        0, 0, 0, 0,                             
        GUI_CLOCK_MAINLCD_TYPE_DIGITAL_DATE);  
    wgui_clock_set_text_border_enable(wgui_cat30_clock_date, MMI_TRUE);
    wgui_clock_set_date_text_border_color(wgui_cat30_clock_date, gui_color(0, 0, 0));
    wgui_clock_set_date_text_color(wgui_cat30_clock_date, gui_color(255, 255, 255));
    wgui_clock_set_date_text_font(wgui_cat30_clock_date, &MMI_medium_font);
    wgui_clock_set_hide_function(wgui_cat30_clock_date, wgui_cat30_hide_date_time_bar);
    wgui_clock_measure_date_text(wgui_cat30_clock_date, &date_width, &date_height, &MMI_medium_font);
    wgui_clock_resize(wgui_cat30_clock_date, date_width, date_height);
    wgui_clock_set_digital_align_type(wgui_cat30_clock_date, GUI_CLOCK_DIGITAL_ALIGN_CENTER);

    /* Day */
    wgui_clock_create(
        &wgui_cat30_clock_day,          
        0, 0, 0, 0,                             
        GUI_CLOCK_MAINLCD_TYPE_DIGITAL_DAY);  
    wgui_clock_set_text_border_enable(wgui_cat30_clock_day, MMI_TRUE);
    wgui_clock_set_date_text_border_color(wgui_cat30_clock_day, gui_color(0, 0, 0));
    wgui_clock_set_date_text_color(wgui_cat30_clock_day, gui_color(255, 255, 255));
    wgui_clock_set_date_text_font(wgui_cat30_clock_day, &MMI_medium_font);
    wgui_clock_set_hide_function(wgui_cat30_clock_day, wgui_cat30_hide_date_time_bar);
    wgui_clock_measure_date_text(wgui_cat30_clock_day, &day_width, &day_height, &MMI_medium_font);
    wgui_clock_resize(wgui_cat30_clock_day, day_width, day_height);
    wgui_clock_set_digital_align_type(wgui_cat30_clock_day, GUI_CLOCK_DIGITAL_ALIGN_CENTER);

    height_offset = bk_image_h - time_height - date_height;
    height_offset /= 3;
    time_y = MMI_STATUS_BAR_HEIGHT + height_offset;
    day_y = date_y = time_y + time_height + height_offset;
    time_x = ((UI_device_width - time_width)>>1);
    width_offset = UI_device_width - date_width - day_width;  
    width_offset /= 3;
    date_x = width_offset;
    day_x = date_x + width_offset + date_width;

    wgui_clock_move(wgui_cat30_clock_time, time_x, time_y);
    wgui_clock_move(wgui_cat30_clock_date, date_x, date_y);
    wgui_clock_move(wgui_cat30_clock_day, day_x, day_y);

    wgui_cat30_cntx_obj.date_time_bar_y = MMI_STATUS_BAR_HEIGHT;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat30_move_and_draw_date_time_bar 
 * DESCRIPTION
 *  It is to used by the SSE to show the expand effect
 * PARAMETERS
 *  x              : [IN] x coordinate for the date time bar
 *  y              : [IN] y coordinate for the date time bar
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat30_move_and_draw_date_time_bar(S32 x, S32 y)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 time_x = 0, time_y = 0;
    S32 time_width = 0, time_height = 0;
    S32 date_x = 0, date_y = 0;
    S32 date_width = 0, date_height = 0;
    S32 day_x = 0, day_y = 0;
    S32 day_width = 0, day_height = 0; 
    PU8 bk_image = NULL;
    S32 bk_image_w = 0, bk_image_h = 0;
    S32 height_offset = 0;
    S32 width_offset = 0;
    GDI_HANDLE wallpaper_layer = dm_get_wallpaper_layer();

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(x);
    close_status_icons();
    bk_image = get_image(IMG_KEYPAD_LOCK_UNLOCK_TIME_BAR_BG);
    gui_measure_image(bk_image, &bk_image_w, &bk_image_h);
    gdi_layer_lock_frame_buffer();
    gdi_layer_push_and_set_active(GDI_LAYER_MAIN_BASE_LAYER_HANDLE);
    gdi_layer_push_clip();
    gdi_layer_set_clip(
              0, 
              (y < MMI_STATUS_BAR_HEIGHT) ? (MMI_STATUS_BAR_HEIGHT) : (y),
              MAIN_LCD_DEVICE_WIDTH - 1,
              MMI_STATUS_BAR_HEIGHT +  bk_image_h - 1);

#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif

    /* Time */
    //wgui_clock_measure_time_text(wgui_cat30_clock_time, &time_width, &time_height, &MMI_large_font);
    wgui_clock_measure_digital_clock(wgui_cat30_clock_time, &time_width, &time_height);
    /* Date */
    wgui_clock_measure_date_text(wgui_cat30_clock_date, &date_width, &date_height, &MMI_medium_font);
    /* Day */
    wgui_clock_measure_date_text(wgui_cat30_clock_day, &day_width, &day_height, &MMI_medium_font);

    height_offset = bk_image_h - time_height - date_height;
    height_offset /= 3;
    time_y = y + height_offset;
    day_y = date_y = time_y + time_height + height_offset;
    time_x = ((UI_device_width - time_width)>>1);
    width_offset = UI_device_width - date_width - day_width;  
    width_offset /= 3;
    date_x = width_offset;
    day_x = date_x + width_offset + date_width;


    wgui_clock_move(wgui_cat30_clock_time, time_x, time_y);
    wgui_clock_move(wgui_cat30_clock_date, date_x, date_y);
    wgui_clock_move(wgui_cat30_clock_day, day_x, day_y);

    wgui_cat30_cntx_obj.date_time_bar_y = y;

    gdi_push_and_set_alpha_blending_source_layer(wallpaper_layer);
    gui_show_image(0, y, bk_image); 
      /* display date time */
    wgui_clock_show_main_lcd();
    gdi_pop_and_restore_alpha_blending_source_layer();
    gdi_layer_pop_clip();
    gdi_layer_pop_and_restore_active();
    gdi_layer_unlock_frame_buffer();
    //gdi_layer_blt_previous(0, 0, UI_device_width - 1, UI_device_height - 1);
}

/* VIJAYAN*/

#if defined( __MMI_DUAL_SIM_MASTER__)  
static void wgui_cat030_lock_text_change_processor(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_wgui_cat030_lock_network_scroll_count += 1;

    g_wgui_cat030_redraw_scrolling_text = MMI_FALSE; /* not redraw scrolling text */
    
    idle_screen_show_lock_details();

    g_wgui_cat030_redraw_scrolling_text = MMI_TRUE;
}

static void wgui_cat030_lock_set_network_info(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x1 = 0, y1 = 0, x2 = 0, y2 = 0;
    S32 max_region_height = 26;//WGUI_CAT033_DUAL_SIM_DATE_HEIGHT;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    /* text process: alternate string */
        if (g_wgui_cat030_lock_network_scroll_count == 4) /* change text */
        {
            g_wgui_cat030_lock_network_scroll_count = 0;            
            if (g_wgui_cat030_current_text_type == NETWORK2_NAME_TEXT_ON_IDLE)
            {
                g_wgui_cat030_current_text_type = NETWORK1_NAME_TEXT_ON_IDLE;    
            }
            else if (g_wgui_cat030_current_text_type == NETWORK1_NAME_TEXT_ON_IDLE)
            {
                g_wgui_cat030_current_text_type = NETWORK2_NAME_TEXT_ON_IDLE;
            }
            gui_start_timer(WGUI_CAT030_PAUSE_TIMER, wgui_cat030_lock_text_change_processor);
        }
        else
        {
            gui_start_timer(WGUI_CAT030_VSCROLL_TIMER, wgui_cat030_lock_text_change_processor);
        }

    /* clear text region */
    x1 = 0;
    y1 = MMI_status_bar_height + 10;
    x2 = UI_device_width - 1;
    
    y2 = y1 + max_region_height - 1;

    gdi_layer_push_clip();
    gdi_layer_set_clip(x1, y1, x2, y2);
    gui_show_image(0, MMI_status_bar_height, get_image(IMG_KEYPAD_LOCK_UNLOCK_TIME_BAR_BG));
    gdi_layer_pop_clip();
}

static MMI_BOOL wgui_cat030_show_network_name2()
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 clip_x1 = 0, clip_y1 = 0, clip_x2 = 0, clip_y2 = 0, clip_height = 0;
    S32 count = 0, region_y1 = 0, region_y2 = 0;
    S32 string_max_h = 0;// max_region_height = 0;
    MMI_BOOL is_display = MMI_FALSE;
    UI_string_type network_name = g_slave_idle_screen_line1text;
    PU8 dual_sim_img = NULL;
    S32 img_width = 0, img_height = 0;
    UI_font_type network_name_font;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
   	//max_region_height = WGUI_CAT030_FANCY_NETWORK_HEIGHT;//WGUI_CAT033_DUAL_SIM_DATE_HEIGHT;    
    network_name_font = gui_font_get_type(GUI_FONT_SIZE_IDLE_NETWORK_NAME);
#if !defined(__MMI_WLAN_FEATURES__)&&!defined(__KJX_FUN__)
    if (!(srv_mode_switch_is_network_service_available() == MMI_FALSE 
          && srv_mode_switch_get_network_mode(MMI_SIM_ALL) == SRV_MODE_SWITCH_OFF))
    {
        dual_sim_img = get_image(WGUI_IMG_IDLE_SIM2);
        gui_measure_image(dual_sim_img, &img_width, &img_height);
        img_width += (MMI_IDLE_NETWORK_NAME_ICON_GAP * 2);
    }
#endif
    if (network_name != NULL)
    {
        is_display = MMI_TRUE;
        
        /* set attribute */
        gui_set_font(network_name_font);        
        gui_set_text_color(*current_MMI_theme->idle_scr_network_name_color);
        gui_set_text_border_color(*current_MMI_theme->idle_scr_network_name_border_color);
        
        string_max_h = Get_CharDisplayHeightOfAllLangAndType(network_name_font->size);
        count = g_wgui_cat030_lock_network_scroll_count; /* scroll count */
        clip_height = string_max_h + 2;
        clip_x1 = 0;
        clip_x2 = UI_device_width - 1;
        clip_y1 = wgui_cat30_cntx_obj.date_time_bar_y + 10;
        clip_y2 = clip_y1 + clip_height - 1;

        gdi_layer_push_clip();
        gdi_layer_set_clip(clip_x1, clip_y1, clip_x2, clip_y2);
        /* calculate the position of network name string */
        if (idle_screen_network_name != NULL) /* have network status: vertical scroll */
        {
            if (g_wgui_cat030_current_text_type == NETWORK2_NAME_TEXT_ON_IDLE)
            {
                region_y2 = clip_y2 - count * (clip_height >> 2) + 1;
                region_y1 = region_y2 - clip_height + 1;
            }
            else if (g_wgui_cat030_current_text_type == NETWORK1_NAME_TEXT_ON_IDLE)
            {
                region_y1 = clip_y2 - count * (clip_height >> 2) + 1;
                region_y2 = region_y1 + clip_height - 1;            
            }
            
            if (dual_sim_img != NULL) /* dual sim show sim1 image */
            {
                S32 img_y =  region_y1 + ((region_y2 - region_y1 + 1) >> 1) - (img_height >> 1) - 1;

                if (r2lMMIFlag)
                {
                    wgui_cat030_show_techno_border_string_center_align(network_name, clip_x1, region_y1, clip_x2 - img_width, region_y2);
                    gdi_image_draw_blend2layers(clip_x2 - img_width + MMI_IDLE_NETWORK_NAME_ICON_GAP, img_y, dual_sim_img);
                }
                else
                {
                    if ((gui_get_string_width(network_name) + 2) >= clip_x2 - clip_x1 + 1 - img_width) /* too long: trancated string */
                    {
                        wgui_cat030_show_techno_border_string_center_align(network_name, clip_x1 + img_width, region_y1, clip_x2, region_y2);
                        gdi_image_draw_blend2layers(clip_x1 + MMI_IDLE_NETWORK_NAME_ICON_GAP, img_y, dual_sim_img);
                    }
                    else
                    {
                        S32 x;

                        x = wgui_cat030_show_techno_border_string_center_align(network_name, clip_x1 + img_width, region_y1, clip_x2, region_y2);
                        gdi_image_draw_blend2layers(x - img_width + MMI_IDLE_NETWORK_NAME_ICON_GAP, img_y, dual_sim_img);
                    }
                }
            }
            else /* no image */
            {
                wgui_cat030_show_techno_border_string_center_align(network_name, clip_x1, region_y1, clip_x2, region_y2);
            }
        }
        else
        {
            wgui_cat030_show_techno_border_string_center_align(network_name, clip_x1, clip_y1, clip_x2, clip_y2);
        }
        gdi_layer_pop_clip();
    }
    return is_display;
}
#endif

static S32 wgui_cat030_show_techno_border_string_center_align(UI_string_type string, S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 string_w = 0, string_h = 0, x_pos = 0, y_pos = 0;
    GDI_HANDLE wallpaper_layer;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wallpaper_layer = wgui_cat033_get_text_abm_layer();
    
    /* get string information */
    gui_measure_string(string, &string_w, &string_h);
    string_w += 2;  /* border text */
    string_h += 2;  /* border text */
    
    y_pos = y1 + ((y2 - y1 + 1) >> 1) - (string_h >> 1) - 1;

    /* set alpha blending layer */
    gdi_push_and_set_alpha_blending_source_layer(wallpaper_layer);

    
    if (string_w < x2 - x1 + 1) /* full display */
    {
        x_pos = (r2lMMIFlag) ? x2 - (((x2 - x1)>>1) - (string_w>>1)) :  x1 + (((x2 - x1)>>1) - (string_w>>1));
        x_pos += (r2lMMIFlag) ? (-1) : (1); /* border text */
        y_pos += 1; /* border text */
        gui_move_text_cursor(x_pos, y_pos);
        gui_print_bordered_text(string);
    }
    else
    {
        x_pos = (r2lMMIFlag) ? (x2) : (x1);
        x_pos += (r2lMMIFlag) ? (-1) : (1); /* border text */
        y_pos += 1; /* border text */
        gui_print_truncated_borderd_text(x_pos, y_pos, x2 - x1 - 1, string);
    }

    gdi_pop_and_restore_alpha_blending_source_layer();
    
    return ((r2lMMIFlag) ? (x_pos + 1) : (x_pos - 1));
}

static MMI_BOOL wgui_cat030_show_network_name()
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 clip_x1 = 0, clip_y1 = 0, clip_x2 = 0, clip_y2 = 0, clip_height = 0;
    S32 count = 0, region_y1 = 0, region_y2 = 0;
    S32 string_max_h = 0;// max_region_height = 0;
    MMI_BOOL is_display = MMI_FALSE;
    UI_string_type network_name = idle_screen_network_name;
    PU8 dual_sim_img = NULL;
    S32 img_width = 0, img_height = 0;
    UI_font_type network_name_font;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
  	//max_region_height = WGUI_CAT030_FANCY_NETWORK_HEIGHT;    
    network_name_font = gui_font_get_type(GUI_FONT_SIZE_IDLE_NETWORK_NAME);
#if defined( __MMI_DUAL_SIM_MASTER__)
    if (!(srv_mode_switch_is_network_service_available() == MMI_FALSE 
          && srv_mode_switch_get_network_mode(MMI_SIM_ALL) == SRV_MODE_SWITCH_OFF))
    {
        dual_sim_img = get_image(WGUI_IMG_IDLE_SIM1);
        gui_measure_image(dual_sim_img, &img_width, &img_height);
        img_width += (MMI_IDLE_NETWORK_NAME_ICON_GAP * 2);
    }
#endif /* defined( __MMI_DUAL_SIM_MASTER__) */
    if (network_name != NULL)
    {
        is_display = MMI_TRUE;
        
        /* set attribute */
        gui_set_font(network_name_font);        
        gui_set_text_color(*current_MMI_theme->idle_scr_network_name_color);
        gui_set_text_border_color(*current_MMI_theme->idle_scr_network_name_border_color);
        
        string_max_h = Get_CharDisplayHeightOfAllLangAndType(network_name_font->size);
        count = g_wgui_cat030_lock_network_scroll_count; /* scroll count */
        clip_height = string_max_h + 2;
        clip_x1 = 0;
        clip_x2 = UI_device_width - 1;
        clip_y1 = wgui_cat30_cntx_obj.date_time_bar_y + 10;
        clip_y2 = clip_y1 + clip_height - 1;

        gdi_layer_push_clip();
        gdi_layer_set_clip(clip_x1, clip_y1, clip_x2, clip_y2);
	#if defined( __MMI_DUAL_SIM_MASTER__)            
        if (g_slave_idle_screen_line1text != NULL) /* have network status: vertical scroll */
        {
            /* calculate the position of network name string */
            if (g_wgui_cat030_current_text_type == NETWORK1_NAME_TEXT_ON_IDLE)
            {
                region_y2 = clip_y2 - count * (clip_height >> 2);
                region_y1 = region_y2 - clip_height + 1;
            }
            else if (g_wgui_cat030_current_text_type == NETWORK2_NAME_TEXT_ON_IDLE)
            {
                region_y1 = clip_y2 - count * (clip_height >> 2) + 1;
                region_y2 = region_y1 + clip_height - 1;
            }
            
            if (dual_sim_img != NULL) /* dual sim show sim1 image */
            {
                S32 img_y =  region_y1 + ((region_y2 - region_y1 + 1) >> 1) - (img_height >> 1) - 1;

                if (r2lMMIFlag)
                {
                    wgui_cat030_show_techno_border_string_center_align(network_name, clip_x1, region_y1, clip_x2 - img_width, region_y2);
                    gdi_image_draw_blend2layers(clip_x2 - img_width + MMI_IDLE_NETWORK_NAME_ICON_GAP, img_y, dual_sim_img);
                }
                else
                {
                    if ((gui_get_string_width(network_name) + 2) >= clip_x2 - clip_x1 + 1 - img_width) /* too long: trancated string */
                    {
                        wgui_cat030_show_techno_border_string_center_align(network_name, clip_x1 + img_width, region_y1, clip_x2, region_y2);
                        gdi_image_draw_blend2layers(clip_x1 + MMI_IDLE_NETWORK_NAME_ICON_GAP, img_y, dual_sim_img);
                    }
                    else
                    {
                        S32 x;

                        x = wgui_cat030_show_techno_border_string_center_align(network_name, clip_x1 + img_width, region_y1, clip_x2, region_y2);
                        gdi_image_draw_blend2layers(x - img_width + MMI_IDLE_NETWORK_NAME_ICON_GAP, img_y, dual_sim_img);
                    }
                }
            }
            else /* no image */
            {
                wgui_cat030_show_techno_border_string_center_align(network_name, clip_x1, region_y1, clip_x2, region_y2);
            }
        }
        else
	#endif
        {
            wgui_cat030_show_techno_border_string_center_align(network_name, clip_x1, clip_y1, clip_x2, clip_y2);                
        }
        
        gdi_layer_pop_clip();
    }
    return is_display;
}


void idle_screen_show_lock_details()
{
#if defined( __MMI_DUAL_SIM_MASTER__)  
	wgui_cat030_lock_set_network_info();
#endif
	wgui_cat030_show_network_name();
#if defined( __MMI_DUAL_SIM_MASTER__)
	wgui_cat030_show_network_name2();
#endif
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat30_draw_date_time_bar 
 * DESCRIPTION
 *  It is to used to simply draw the date time bar at the initial position
 * PARAMETERS
 *  void         
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat30_draw_date_time_bar(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    PU8 bk_image = NULL;
    S32 bk_image_w = 0, bk_image_h = 0;
    S32 height_offset = 0;
    S32 width_offset = 0;
    GDI_HANDLE wallpaper_layer = dm_get_wallpaper_layer();

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    bk_image = get_image(IMG_KEYPAD_LOCK_UNLOCK_TIME_BAR_BG);
    gui_measure_image(bk_image, &bk_image_w, &bk_image_h);
    gdi_layer_lock_frame_buffer();
    gdi_layer_push_and_set_active(GDI_LAYER_MAIN_BASE_LAYER_HANDLE);
    gdi_layer_push_clip();
    gdi_layer_set_clip(
              0, 
              MMI_STATUS_BAR_HEIGHT,
              MAIN_LCD_DEVICE_WIDTH - 1,
              MMI_STATUS_BAR_HEIGHT +  bk_image_h - 1);
    gdi_push_and_set_alpha_blending_source_layer(wallpaper_layer);
    /* clear all */
    gdi_draw_solid_rect(
              0, 
              MMI_STATUS_BAR_HEIGHT,
              MAIN_LCD_DEVICE_WIDTH - 1,
              MMI_STATUS_BAR_HEIGHT +  bk_image_h - 1,
              GDI_COLOR_TRANSPARENT);
    
    #if !defined(__FTE_NON_SLIM_RES__)
        gdi_image_draw_resized_id(0, MMI_STATUS_BAR_HEIGHT, MAIN_LCD_DEVICE_WIDTH, bk_image_h, IMG_KEYPAD_LOCK_UNLOCK_TIME_BAR_BG);
    #else
        gui_show_image(0, MMI_STATUS_BAR_HEIGHT, bk_image);   
    #endif
    /*VIJAYAN*/
    if(g_wgui_cat030_operator_on_fancy_lock_screen == 1)
    {
        idle_screen_show_lock_details();
    }
      /* display date time */
    wgui_clock_show_main_lcd();
    gdi_pop_and_restore_alpha_blending_source_layer();

    gdi_layer_pop_clip();
    gdi_layer_pop_and_restore_active();
    gdi_layer_unlock_frame_buffer();
    gdi_layer_blt_previous(0, 0, UI_device_width - 1, UI_device_height - 1);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat30_move_and_draw_unlock_bar 
 * DESCRIPTION
 *  It is to used by the SSE to show the expand effect
 * PARAMETERS
 *  x              : [IN] x coordinate for the unlock bar
 *  y              : [IN] y coordinate for the unlock bar
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat30_move_and_draw_unlock_bar(S32 x, S32 y)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    PU8 bk_image = NULL;
    S32 bk_image_w = 0, bk_image_h = 0;
    S32 height_offset = 0;
    S32 width_offset = 0;
    S32 button_x = 0, button_y = 0;
    S32 button_width = 0, button_height = 0; 
    PU8 button_image = NULL;
    S32 string_w = 0, string_h = 0;
    S32 string_x = 0, string_y = 0;
    S32 ml_x, ml_y;
    S32 ml_width, ml_height;
    S32 actual_width = 0, actual_height = 0;
    GDI_HANDLE wallpaper_layer = dm_get_wallpaper_layer();
    GDI_HANDLE active_layer;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_get_active(&active_layer);

    UI_UNUSED_PARAMETER(x);
    bk_image = get_image(IMG_KEYPAD_LOCK_UNLOCK_BAR_BG);
    button_image = get_image((U16)(IMG_KEYPAD_LOCK_UNLOCK_BUTTON5));
    gui_measure_image(bk_image, &bk_image_w, &bk_image_h);
    gui_measure_image(button_image, &button_width, &button_height);
    gdi_layer_lock_frame_buffer();
    gdi_layer_push_and_set_active(GDI_LAYER_MAIN_BASE_LAYER_HANDLE);
    gdi_layer_push_clip();
    gdi_layer_set_clip(
              0, 
              (y > (MAIN_LCD_DEVICE_HEIGHT - bk_image_h)) ? (y) : (MAIN_LCD_DEVICE_HEIGHT - bk_image_h),
              MAIN_LCD_DEVICE_WIDTH - 1,
              MAIN_LCD_DEVICE_HEIGHT - 1);
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif

    gdi_push_and_set_alpha_blending_source_layer(wallpaper_layer);
    
    #if !defined(__FTE_NON_SLIM_RES__)
        gdi_image_draw_resized_id(0, y, MAIN_LCD_DEVICE_WIDTH, bk_image_h, IMG_KEYPAD_LOCK_UNLOCK_BAR_BG);    
    #else
        gui_show_image(0, y, bk_image);
    #endif
    gdi_pop_and_restore_alpha_blending_source_layer();

    height_offset = ((bk_image_h - button_height)>>1);
    button_y = y + height_offset;
    width_offset = WGUI_CAT30_ICON_H_MARGIN;
    if (r2lMMIFlag)
    {
        button_x = UI_device_width - width_offset - button_width;
    }
    else
    {
        button_x = width_offset;  

    }

    gdi_push_and_set_alpha_blending_source_layer(active_layer);
    if(wgui_cat30_cntx_obj.unlock_bar_image_index <= 0)
    {
        gui_show_image(button_x,button_y, get_image((U16)(IMG_KEYPAD_LOCK_UNLOCK_BUTTON0)));    
    }
    else
    {
        gui_draw_image_with_alpha_transparent(button_image, button_x ,button_y, 255*(wgui_cat30_cntx_obj.unlock_bar_image_index)/5);
    }
    gdi_pop_and_restore_alpha_blending_source_layer();

    gdi_push_and_set_alpha_blending_source_layer(wallpaper_layer);

    ml_y = y + (WGUI_CAT30_ICON_TEXT_V_GAP * 3);
    ml_height = bk_image_h - (3 * WGUI_CAT30_ICON_TEXT_V_GAP); 
    ml_width = UI_device_width - button_width - (2* WGUI_CAT30_ICON_H_MARGIN) + 1;
    if (r2lMMIFlag)
    {
        ml_x = ((WGUI_CAT30_ICON_H_MARGIN)>>1);

    }
    else
    {
        ml_x = (button_x + button_width + ((WGUI_CAT30_ICON_H_MARGIN)>>1));
    }

    move_multiline_inputbox(ml_x, ml_y);
    resize_multiline_inputbox_fit(
        ml_width,
        ml_height,
        &actual_width,
        &actual_height);
    if(actual_height > ml_height)
    {
        wgui_inputs_ml_resize(actual_width, ml_height);
    }
    show_multiline_inputbox();

    gdi_pop_and_restore_alpha_blending_source_layer();

    gdi_layer_pop_clip();
    gdi_layer_pop_and_restore_active();
    gdi_layer_unlock_frame_buffer();
    gdi_layer_blt_previous(0, 0, UI_device_width - 1, UI_device_height - 1);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat30_draw_ctrl_area 
 * DESCRIPTION
 *
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat30_draw_ctrl_area(dm_coordinates *coordinate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    PU8 unlock_bg_image = NULL;
    S32 width, height;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(coordinate);
    unlock_bg_image = get_image(IMG_KEYPAD_LOCK_UNLOCK_BAR_BG);
    gui_measure_image(unlock_bg_image, &width, &height);
    wgui_cat30_draw_date_time_bar();
    wgui_cat30_move_and_draw_unlock_bar(0, UI_device_height - height);
    wgui_cat30_draw_details();
    //show_status_icons();
    wgui_status_icon_bar_update();
    wgui_status_icon_bar_register_hide_callback(
        WGUI_STATUS_ICON_BAR_H_BAR, 
        idle_screen_hide_status_icons_bar0);

}



/*****************************************************************************
 * FUNCTION
 *  wgui_cat30_update_details 
 * DESCRIPTION
 *
 *  This API is for application to update the icon, text info etc.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat30_update_details(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();
    /* draw details */
    wgui_cat30_draw_details();
    gdi_layer_unlock_frame_buffer();
    gdi_lcd_repaint_all();
}


#ifdef __MMI_ALPHA_BLENDING__
/*****************************************************************************
 * FUNCTION
 *  cat33_redraw_alpha_images
 * DESCRIPTION
 *  Redraw alpha images when wallpaper animation updates
 *  1. draw shortcuts
 *  2. draw techno bar and date time
 *  3. draw reminder
 * PARAMETERS
 *  void
 * RETURNS
 *  void    
 *****************************************************************************/
void wgui_cat30_redraw_alpha_images(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gdi_handle base_layer;
    PU8 unlock_bg_image = NULL;
    S32 width, height;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();
    gdi_layer_get_base_handle(&base_layer);
    gdi_layer_push_and_set_active(base_layer);
    wgui_cat30_draw_date_time_bar();
    unlock_bg_image = get_image(IMG_KEYPAD_LOCK_UNLOCK_BAR_BG);
    gui_measure_image(unlock_bg_image, &width, &height);
    wgui_cat30_move_and_draw_unlock_bar(0, UI_device_height - height);
    wgui_cat30_update_details();
    gdi_layer_pop_and_restore_active();
    gdi_layer_unlock_frame_buffer();
}

#endif /* __MMI_ALPHA_BLENDING__ */

/*****************************************************************************
 * FUNCTION
 *  wgui_cat30_play_button_image_seq_and_exec_callback
 * DESCRIPTION
 *  It plays the button image sequence and executes the call back.
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
static void wgui_cat30_play_button_image_seq_and_exec_callback(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    PU8 unlock_bg_image = NULL;
    S32 width, height;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    unlock_bg_image = get_image(IMG_KEYPAD_LOCK_UNLOCK_BAR_BG);
    gui_measure_image(unlock_bg_image, &width, &height);
    if(wgui_cat30_cntx_obj.unlock_bar_image_index < 5)
    {
        wgui_cat30_cntx_obj.unlock_bar_image_index++;
        wgui_cat30_move_and_draw_unlock_bar(0, UI_device_height - height);
        gui_start_timer(WGUI_CAT30_PLAY_BUTTON_BAR_SEQ, wgui_cat30_play_button_image_seq_and_exec_callback);
    }
    else
    {
        gui_cancel_timer(wgui_cat30_play_button_image_seq_and_exec_callback);
        g_wgui_cat30_is_normal_exit = MMI_TRUE;
        wgui_cat30_cntx_obj.callback_to_app();
        g_wgui_cat30_is_normal_exit = MMI_FALSE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat30_pen_long_tap_handler
 * DESCRIPTION
 *  pen long tap handler for category30
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat30_long_press_simulation(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_cat30_play_button_image_seq_and_exec_callback();
}


static MMI_BOOL wgui_cat30_pen_down_handler(mmi_pen_point_struct point)
{
        /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 pos_x = point.x, pos_y = point.y;
    S32 button_x = 0, button_y = 0;
    S32 button_width = 0, button_height = 0; 
    PU8 button_image = NULL;
    PU8 bk_image = NULL;
    S32 bk_image_w = 0, bk_image_h = 0;
    S32 height_offset = 0;
    S32 width_offset = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    bk_image = get_image(IMG_KEYPAD_LOCK_UNLOCK_BAR_BG);
    button_image = get_image((U16)(IMG_KEYPAD_LOCK_UNLOCK_BUTTON0));
    gui_measure_image(bk_image, &bk_image_w, &bk_image_h);
    gui_measure_image(button_image, &button_width, &button_height);
    height_offset = ((bk_image_h - button_height)>>1);
    button_y = UI_device_height - bk_image_h  + height_offset;
    width_offset = WGUI_CAT30_ICON_H_MARGIN;
    if(r2lMMIFlag)
    {
        button_x = UI_device_width - width_offset - button_width;
    }
    else
    {
        button_x = width_offset;  

    }
    if((pos_x >= button_x) && (pos_y >= button_y) && (pos_x <= (button_x + button_width - 1)) && (pos_y <= (button_y + button_height - 1)) )
    {
        gui_start_timer(WGUI_CAT30_LONG_PRESS_SIMULATION_INTERVAL, wgui_cat30_long_press_simulation);
        return MMI_TRUE; 
    }
    else
    {
        return MMI_FALSE;
    }
}

void wgui_cat30_key_down_handler(void)
{
    gui_start_timer(WGUI_CAT30_LONG_PRESS_SIMULATION_INTERVAL, wgui_cat30_long_press_simulation);
}

void wgui_cat30_key_up_handler(void)
{
    gui_cancel_timer(wgui_cat30_long_press_simulation);
}

static MMI_BOOL wgui_cat30_pen_up_handler(mmi_pen_point_struct point)
{
    gui_cancel_timer(wgui_cat30_long_press_simulation);
    return MMI_FALSE;
}

/*****************************************************************************
 * FUNCTION
 *  wgui_category_sse_popup_effect_draw_frame
 * DESCRIPTION
 *  category 30 leaving SSE draw frame callback handler
 * PARAMETERS
 *  effect_type               [IN]  effect type
 *  current_frame_index       [IN]  current frame index
 *  total_frame_num           [IN]  total frame num
 * RETURNS
 *  MMI_FALSE if to stop the effect; otherwise, MMI_TRUE.
 *****************************************************************************/
static MMI_BOOL wgui_cat30_sse_leaving_effect_draw_frame(
                    gui_screen_switch_effect_type_enum effect_type,
                    S32 current_frame_index,
                    S32 total_frame_num)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 img_w, img_h;
    S32 h1, h2, h;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();

    /* clear the content area in 1st frame */
    if (current_frame_index == 0)
    {
        gdi_draw_solid_rect(0, MMI_status_bar_height, UI_device_width - 1, UI_device_height - 1, GDI_COLOR_TRANSPARENT);
    }

    /* clear time bar */
    gui_measure_image(get_image(IMG_KEYPAD_LOCK_UNLOCK_TIME_BAR_BG), &img_w, &img_h);
    h1 = img_h * (total_frame_num + 1 - current_frame_index) / (total_frame_num);
    gdi_draw_solid_rect(0, MMI_status_bar_height, UI_device_width - 1, MMI_status_bar_height + h1 - 1, GDI_COLOR_TRANSPARENT);

    /* draw time bar */
    if (current_frame_index != total_frame_num - 1) /* do not draw the last frame */
    {
        h = img_h * (current_frame_index + 1) / (total_frame_num);
        wgui_cat30_move_and_draw_date_time_bar(0, MMI_status_bar_height - h);
    }

    /* clear unlock bar */
    gui_measure_image(get_image(IMG_KEYPAD_LOCK_UNLOCK_BAR_BG), &img_w, &img_h);
    h2 = img_h * (total_frame_num - current_frame_index) / (total_frame_num);
    gdi_draw_solid_rect(0, UI_device_height - h2, UI_device_width - 1, UI_device_height - 1, GDI_COLOR_TRANSPARENT);

    /* draw unlock bar */
    if (current_frame_index != total_frame_num - 1) /* do not draw the last frame */
    {
        h = img_h * (total_frame_num - current_frame_index - 1) / (total_frame_num);
        wgui_cat30_move_and_draw_unlock_bar(0, UI_device_height - h);
    }

    gdi_layer_unlock_frame_buffer();

    /* clear blt region */
    gdi_lcd_freeze(TRUE);
    gdi_layer_blt_previous(0, 0, 0, 0);
    gdi_lcd_freeze(FALSE);

    /* blt update region */
    if (current_frame_index == 0)
    {
        gdi_layer_blt_previous(0, MMI_status_bar_height, UI_device_width - 1, UI_device_height - 1);
    }
    else
    {
        gdi_layer_blt_previous(0, MMI_status_bar_height, UI_device_width - 1, MMI_status_bar_height + h1 - 1);
        gdi_layer_blt_previous(0, UI_device_height - h2, UI_device_width - 1, UI_device_height - 1);
    }

    return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat30_sse_custom_handler
 * DESCRIPTION
 *  SSE handler for leaving effect
 * PARAMETERS
 *  stage_type  [IN] type
 *  param       [IN] parameters
 * RETURNS
 *  gui_screen_switch_effect_custom_return_code_enum
 *****************************************************************************/
static gui_screen_switch_effect_custom_return_code_enum wgui_cat30_sse_custom_handler(
                    gui_screen_switch_effect_stage_enum stage_type,
                    gui_screen_switch_effect_custom_param_struct *param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    #define WGUI_CAT30_SSE_LEAVING_FRAMES   4

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (stage_type)
    {
        case GUI_SSE_STAGE_EXIT:
            if (g_wgui_cat30_is_normal_exit)
            {
                /* setup SSE */
                gui_screen_switch_effect_register_owner_draw_frame_callback(wgui_cat30_sse_leaving_effect_draw_frame);
                gui_screen_switch_effect_setup_effect(GUI_SCREEN_SWITCH_EEFECT_OWNER_DRAW1, WGUI_CAT30_SSE_LEAVING_FRAMES, GUI_SCREEN_SWITCH_EFFECT_TIMER_UNIT);
                gui_screen_switch_effect_run_effect(GUI_SCREEN_SWITCH_EEFECT_OWNER_DRAW1);
            }
            break;
    }

    return GUI_SSE_CUSTOM_RETURN_CODE_DEFAULT;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat30_exit 
 * DESCRIPTION
 *
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat30_exit(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    close_status_icons();
    memset(&wgui_cat30_cntx_obj, 0, sizeof(wgui_cat30_cntx_obj));
    /* close date time component */
    wgui_clock_close(wgui_cat30_clock_date);
    wgui_clock_close(wgui_cat30_clock_time);
    wgui_clock_close(wgui_cat30_clock_day);
    wgui_cat30_clock_date = WGUI_CLOCK_INVALID_INDEX;
    wgui_cat30_clock_time = WGUI_CLOCK_INVALID_INDEX;
    wgui_cat30_clock_day = WGUI_CLOCK_INVALID_INDEX;
    gui_cancel_timer(wgui_cat30_play_button_image_seq_and_exec_callback);
    gui_cancel_timer(wgui_cat30_long_press_simulation);
    on_idle_screen = 0;
    reset_multiline_inputbox();
    /* VIJAYAN*/
    if(g_wgui_cat030_operator_on_fancy_lock_screen == 1)
    {
#if defined( __MMI_DUAL_SIM_MASTER__)  
        gui_cancel_timer(wgui_cat030_lock_text_change_processor);
#endif
		g_wgui_cat030_lock_network_scroll_count = 0;
        g_wgui_cat030_operator_on_fancy_lock_screen = 0;
    }
    
}

/*****************************************************************************
 * FUNCTION
 *  wgui_cat31_show
 * DESCRIPTION
 *  Show category 31 screen
 * PARAMETERS
 *  phone_unlock_str            [IN]      phone unlock string
 *  callback_to_app             [IN]        callback to APP on long press
 *  history_buffer              [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/

void wgui_cat31_show(UI_string_type phone_unlock_str,
                     FuncPtr callback_to_app,
                     U8 flag,
                     U8 *history_buffer)
{
    g_wgui_cat030_operator_on_fancy_lock_screen = flag;
    wgui_cat30_show(phone_unlock_str,
                    callback_to_app,
                    history_buffer);
}
/*****************************************************************************
 * FUNCTION
 *  wgui_cat30_show
 * DESCRIPTION
 *  Show category 30 screen
 * PARAMETERS
 *  phone_unlock_str            [IN]      phone unlock string
 *  callback_to_app             [IN]        callback to APP on long press
 *  history_buffer              [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat30_show(UI_string_type phone_unlock_str,
                     FuncPtr callback_to_app,
                     U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;
    S32 l;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(__MMI_SCREEN_SWITCH_EFFECT__)
    gui_screen_switch_effect_register_custom_callback(wgui_cat30_sse_custom_handler);
#endif /* defined(__MMI_SCREEN_SWITCH_EFFECT__) */

    on_idle_screen = 1;
    gdi_layer_lock_frame_buffer();
#ifdef __MMI_ALPHA_BLENDING__    
    dm_register_wallpaper_anim_update_callback(wgui_cat30_redraw_alpha_images);
#endif /* __MMI_ALPHA_BLENDING__ */
    change_left_softkey(0, 0);
    change_right_softkey(0, 0);
    SetupCategoryKeyHandlers();
    wgui_status_icon_bar_register_hide_callback(
        WGUI_STATUS_ICON_BAR_H_BAR,
        UI_dummy_function);
    wgui_status_icon_bar_move(
        WGUI_STATUS_ICON_BAR_H_BAR, 0, 0);
    wgui_status_icon_bar_set_display(WGUI_STATUS_ICON_BAR_H_BAR);
    /* create date-time bar */
    wgui_cat30_init_date_time_bar();
    wgui_cat30_cntx_obj.unlock_bar_image_index = 0;
    wgui_cat30_cntx_obj.callback_to_app = callback_to_app;
    wgui_cat30_cntx_obj.unlock_bar_str = phone_unlock_str;
    l = gui_strlen(wgui_cat30_cntx_obj.unlock_bar_str);
    create_multiline_inputbox_set_buffer(wgui_cat30_cntx_obj.unlock_bar_str, l, l, 0);
	MMI_multiline_inputbox.normal_text_color = gui_color(255, 255, 255);
    MMI_multiline_inputbox.text_font = &MMI_medium_font;
    MMI_multiline_inputbox.border_color = gui_color(0, 0, 0);
    MMI_multiline_inputbox.flags |= UI_MULTI_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW
        | UI_MULTI_LINE_INPUT_BOX_DISABLE_BACKGROUND
        | UI_MULTI_LINE_INPUT_BOX_DISABLE_SCROLLBAR | UI_MULTI_LINE_INPUT_BOX_VIEW_MODE;
    MMI_multiline_inputbox.ext_flags |= (GUI_MULTI_LINE_INPUT_BOX_USE_BORDER_FONT | GUI_MULTI_LINE_INPUT_BOX_SINGLE_BORDER);
	MMI_multiline_inputbox.text_x = 0;
    MMI_multiline_inputbox.text_y = 0;
    #if defined (__MMI_TOUCH_SCREEN__)
    wgui_register_category_screen_control_area_pen_handlers(wgui_cat30_pen_down_handler, MMI_PEN_EVENT_DOWN);
    wgui_register_category_screen_control_area_pen_handlers(wgui_cat30_pen_up_handler, MMI_PEN_EVENT_UP);
    #endif /* (defined __MMI_TOUCH_SCREEN__) */ 
    gdi_layer_unlock_frame_buffer();
    ExitCategoryFunction = wgui_cat30_exit;
    dm_setup_category_functions(dm_redraw_category_screen, dummy_get_history, dummy_get_history_size);
    dm_register_category_controlled_callback(wgui_cat30_draw_ctrl_area);
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32CatId = MMI_CATEGORY30_ID;
    dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND;
    dm_setup_data(&dm_data);
    dm_redraw_category_screen();
}

#endif /*defined (__MMI_FANCY_SCREEN_LOCK__)*/

