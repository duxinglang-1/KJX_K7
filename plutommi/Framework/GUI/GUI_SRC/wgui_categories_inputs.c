/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*****************************************************************************
 *
 * Filename:
 * ---------
 *   wgui_categories_inputs.c
 *
 * Project:
 * --------
 *   Maui_Software
 *
 * Description:
 * ------------
 * Input/Editor related categoreis.
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/

/***************************************************************************** 
 * Include 
 *****************************************************************************/
#include "MMI_features.h"
#include "gui_inputs.h"
#include "wgui_categories_inputs.h"

#ifdef __MMI_INDIC_ALG__
#include "IndicEngineGprot.h"
#endif 

#if defined(__MMI_SMART_MESSAGE_MO__) && !defined(__MMI_MESSAGES_EMS__)
#include "SmsGuiInterfaceType.h"
#include "MessagesResourceData.h"
#endif /* defined(__MMI_SMART_MESSAGE_MO__) && !defined(__MMI_MESSAGES_EMS__) */ 

#include "wgui_ems.h"
#include "app_str.h"

#ifdef __MMI_TOUCH_SCREEN__
#include "wgui_virtual_keyboard.h"
#endif
#include "Wgui_softkeys.h"

#include "gui_touch_feedback.h"

#include "Gdi_include.h"
#include "Lcd_if.h"

//RHR
    #include "wgui_inputs.h"
    #include "MMIDataType.h"
    #include "kal_general_types.h"
    #include "ImeGprot.h"
    #include "gui_data_types.h"
    #include "gui_ems.h"
    #include "ems.h"
    #include "wgui_categories_text_viewer.h"
    #include "gui_config.h"
    #include "gui.h"
    #include "wgui_categories_util.h"
    #include "wgui_include.h"
    #include "gui_typedef.h"
    #include "wgui_draw_manager.h"
    #include "wgui.h"
    #include "wgui_categories_enum.h"
    #include "wgui_categories_inputs.h"
    #include "gui_title.h"
    #include "wgui_title.h"
    #include "gui_themes.h"
    #include "gui_switch.h"
    #include "lcd_sw_inc.h"
    #include "Gui_Setting.h"
    #include "CustThemesRes.h"
    #include "mmi_frm_history_gprot.h"
    #include "GlobalConstants.h"
    #include "mmi_frm_events_gprot.h"
    #include "PixcomFontEngine.h"
    #include "kal_public_api.h"
    #include "DebugInitDef_Int.h"
    #include "gui_theme_struct.h"
    #include "MMI_features_switch.h"
    #include "MMI_features_type.h"
    #include "gdi_datatype.h"
    #include "mmi_frm_input_gprot.h"
    #include "TimerEvents.h"
    #include "mmi_frm_timer_gprot.h"
    #include "GlobalResDef.h"
    #include "string.h"
    #include "Unicodexdcl.h"
    #include "gui_scrollbars.h"
    #include "mmi_frm_gestures_gprot.h"
    #include "mmi_clipboard_gprot.h"
    #include "gui_buttons.h"
    #include "mmi_rp_app_uiframework_def.h"
    #include "app_mem.h"
    #include "stdio.h"
    #include "FontRes.h"
    #include "CustDataRes.h"
    #include "mmi_frm_mem_gprot.h"
    #include "wgui_categories_list.h"
    #include "gui_virtual_keyboard.h"
    #include "gdi_const.h"
    #include "gui_inputs_internal.h" /*fix warning: UI_draw_horizontal_line*/
    #include "mmi_rp_srv_editor_def.h"
    #include "Gui_effect_oem.h"

/***************************************************************************** 
* Typedef 
*****************************************************************************/
#ifdef UI_EMS_SUPPORT
#ifdef __MMI_MSG_EDITOR_WITH_RECIPIENT__
typedef struct _wgui_cat28_history_cntx
{
    wgui_cat28_region_id_enum highlight_state;
    S32 highlight_index;
    S32 recipients_num;
    MMI_BOOL need_to_set_sl_ime;
    mmi_imc_history sl_ime;
    MMI_BOOL need_to_set_ml_ime;
    mmi_imc_history ml_ime;
} wgui_cat28_history_cntx;
#endif /* __MMI_MSG_EDITOR_WITH_RECIPIENT__ */
#endif /* UI_EMS_SUPPORT */

/***************************************************************************** 
 * Global Variable
 *****************************************************************************/
mmi_editor_handler_struct g_mmi_editor_hanler;

#ifdef __MMI_SMALL_EDIT_SCREEN__
BOOL g_small_editor_category_present = FALSE;
extern U16 title_bg_id;
#endif 

U8 cat_215_text_length;
U8 cat_215_1_bytes_char_num;
U8 cat_215_2_bytes_char_num;
U8 cat_215_3_bytes_char_num;
MMI_BOOL g_cat_cat_editor_disable_new_line_symbol = MMI_FALSE;

#if defined(__MMI_WCSS_INPUT_FORMAT_SUPPORT__)
MMI_BOOL is_fisrt_entry_WCSS_editor = MMI_TRUE;
#endif 

/* EMS category */
#ifdef UI_EMS_SUPPORT
#ifdef __MMI_INDIC_ALG__
U32 add_template_ems_flag=0;
#endif /* __MMI_INDIC_ALG__ */
U8 category28_RSK_label_clear = 0;
extern UI_EMS_input_box MMI_EMS_inputbox;
extern U8 EMS_inputbox_has_changed;
extern PU8 wgui_EMS_inputbox_information_icon;
extern EMSTextFormat wgui_EMS_text_format;
extern S32 wgui_EMS_inputbox_information_bar_height;
extern U8 EMS_inputbox_alignment_added_flag;
extern EMSALIGNMENT EMS_inputbox_alignment;

#if((UI_ENABLE_FRAME_SKIPPING) && (ENABLE_EMS_INPUTBOX_FRAME_SKIPPING))
extern S32 wgui_EMS_inputbox_frame_counter;
#endif 
extern void (*EMS_inputbox_input_callback) (void);
#endif /* UI_EMS_SUPPORT */

#ifdef __WGUI_CAT_SLIDE_CONTROLS_SUPPORT__
extern wgui_cat_slide_control_cntx *g_wgui_cat_slide_control_ptr;
#endif /* __WGUI_CAT_SLIDE_CONTROLS_SUPPORT__ */

/***************************************************************************** 
 * Local Variable
 *****************************************************************************/
#if !defined(GUI_EDITOR_SHOW_TITLE)
static S32 g_title_in_header = 0;
#endif /* !defined(GUI_EDITOR_SHOW_TITLE) */

#if defined (__MMI_WALLPAPER_ON_BOTTOM__)
static U8 editor_scr_bg_opacity;
#endif /* defined (__MMI_WALLPAPER_ON_BOTTOM__) */ 

void (*g_wgui_cat111_draw_information_bar_func)(void) = NULL;
#ifdef __J2ME__
static MMI_BOOL g_wgui_cat2002_is_active_editor = MMI_TRUE;
static MMI_BOOL g_wgui_cat2002_is_large_icon_appeared = MMI_FALSE;
static MMI_BOOL g_wgui_cat2002_is_cursor_stopped = MMI_FALSE;
static MMI_BOOL g_wgui_cat2002_ui_change_flag = MMI_TRUE;
static MMI_BOOL g_wgui_cat2002_is_in_java = MMI_FALSE;
#endif /* __J2ME__ */

#ifdef UI_EMS_SUPPORT
static UI_string_type category28_RSK_label_string;
static PU8 category28_RSK_label_icon;
static void (*category28_RSK_function) (void) = NULL;
#ifdef __MMI_MSG_EDITOR_WITH_RECIPIENT__
static wgui_cat28_context_struct g_wgui_cat28_cntx;
static MMI_BOOL g_wgui_cat28_add_recipients_in_BG = MMI_FALSE;
#endif /* __MMI_MSG_EDITOR_WITH_RECIPIENT__ */
#endif /* UI_EMS_SUPPORT */

/* for category5 and category74*/
CHAR* g_wgui_cat_ml_header_img = NULL;
CHAR* g_wgui_cat_ml_footer_img = NULL;
PU8 g_wgui_cat_ml_header_img_res = NULL;
PU8 g_wgui_cat_ml_footer_img_res = NULL;
gdi_image_cache_bmp_struct g_wgui_cat_ml_header_img_cache = {0};
S32 g_wgui_cat_ml_header_img_cache_buffer_size = 0;
MMI_BOOL g_wgui_cat_ml_header_img_is_cached = MMI_FALSE;
gdi_handle g_wgui_cat_ml_image_handle = 0xFFFF;
extern S32 wgui_cat_ml_get_resized_image_height(CHAR* image_file, S32 max_w, S32 max_h);
gdi_handle g_wgui_cat_ml_image_cache_layer;


/***************************************************************************** 
 * Global Function
 *****************************************************************************/
 /* for category171 */
extern void setup_scrolling_title(void);
extern void close_scrolling_title(void);

/* for category28 */
#ifdef UI_EMS_SUPPORT
extern void register_EMS_inputbox_input_callback(void (*f) (void));
extern S32 gui_EMS_input_box_highlight_cursor_number(UI_EMS_input_box *b, S32 numOfChar);
extern void MoveCursorToPosition(EMSData *data, EMSPosition *dst);
#endif /* UI_EMS_SUPPORT */


/***************************************************************************** 
 * Local Function
 *****************************************************************************/
#ifdef UI_EMS_SUPPORT
#ifdef __MMI_MSG_EDITOR_WITH_RECIPIENT__
static void wgui_cat28_sl_empty_callback(void);
static void wgui_cat28_sl_change_callback(void);
static S32 wgui_cat28_translate_header_pen_event(S32 x, S32 y);
static MMI_BOOL wgui_cat28_ime_pre_vk_handler(S32 x, S32 y);
#endif /* __MMI_MSG_EDITOR_WITH_RECIPIENT__ */
#endif /* UI_EMS_SUPPORT */

#ifdef __J2ME__
static U32 wgui_cat2002_ime_msg_callback(void * input_box_handle, mmi_imc_message_struct_p msg_ptr);
#ifdef __MMI_FTE_SUPPORT__
static void wgui_cat2002_ctrl_area_callback(dm_coordinates *coordinate);
#endif
#endif /* __J2ME__ */


///TODO: Should be remove, sync with APP
/*****************************************************************************
 * FUNCTION
 *  wgui_set_e_dictionary_test_clear_inputbox_buffer_funcptr
 * DESCRIPTION
 *  A function pointer which tests if need to clear
 *  multi-line inputbox buffer
 * PARAMETERS
 *  FuncPtr     [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_set_e_dictionary_test_clear_inputbox_buffer_funcptr(pBOOL(*FuncPtr) (void))
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(FuncPtr);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_inputs_category_set_rsk_func
 * DESCRIPTION
 *  set editor category RSK.
 * PARAMETERS
 *  f       [IN]        RSK function.
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_inputs_category_set_rsk_func(void (*f) (void))
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_inputbox_RSK_function = f;
    wgui_singleline_inputbox_RSK_function = f;
}


/*****************************************************************************
 * FUNCTION
 *  AppendCategory5String
 * DESCRIPTION
 *  Function to append a string to category 5 screen
 * PARAMETERS
 *  f       [IN]        
 *  k       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void AppendCategory5String(U32 input_type, U8 *buffer, S32 buffer_size, U8 *s, U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_inputs_ml_append_string(input_type,buffer,buffer_size,s,history_buffer,MMI_CATEGORY5_ID,NULL);
}


/* For detail description, please refer to wgui_categories_inputs.h */
void ShowCategory5Screen(
        U16 title,
        U16 title_icon,
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        U32 input_type,
        U8 *buffer,
        S32 buffer_size,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 input_ext_type = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_cat_cat_editor_disable_new_line_symbol == MMI_TRUE)
    {
        input_ext_type = INPUT_TYPE_EXT_NO_SHOW_NEW_LINE_SYMBOL;
    }
    /* Begin AP input mode set */
    ShowCategory5Screen_ext(
        title,
        title_icon,
        left_softkey,
        left_softkey_icon,
        right_softkey,
        right_softkey_icon,
        input_type,
        buffer,
        buffer_size,
        history_buffer,
        input_ext_type,
        NULL);
    /* End AP input mode set */
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat5_set_title_in_header
 * DESCRIPTION
 *  set title in header style 
 * PARAMETERS
 *  b_set     [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat5_set_title_in_header(S32 b_set)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if !defined(GUI_EDITOR_SHOW_TITLE)
    g_title_in_header = b_set;
#endif /* !defined(GUI_EDITOR_SHOW_TITLE) */
}


#if !defined(GUI_EDITOR_SHOW_TITLE)
/*****************************************************************************
 * FUNCTION
 *  title_in_header_callback
 * DESCRIPTION
 *  redraw header 
 * PARAMETERS
 *  yoffset     [IN]        offset Y
 *  clip_x1     [IN]        start x
 *  clip_y1     [IN]        start y
 *  clip_x2     [IN]        end x
 *  clip_y2     [IN]        end y
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat5_title_in_header_callback(MMI_BOOL is_draw, S32 yy, S32 height, S32 x1, S32 y1, S32 x2, S32 y2)
{
    S32 header_y2;

    if (!is_draw)
    {
        wgui_title_unset_style(GUI_TITLE_STYLE_SCROLLING);
        return;
    }
    
    header_y2 = yy + height - 1;
    
    gui_push_clip();
    gui_set_clip(x1, y1, x2, header_y2>y2 ? y2 : header_y2);

    wgui_title_create();
    wgui_title_move(x1, yy);
    if (MMI_title_height > 0)
    {
        wgui_title_resize(x2 - x1 + 1, MMI_title_height);
    }
    else
    {
        wgui_title_resize(x2 - x1 + 1, MMI_MENUITEM_HEIGHT);
    }

#ifdef __MMI_FTE_SUPPORT__
    wgui_title_set_style(GUI_TITLE_STYLE_NORMAL);
#else
    if (g_dm_data.s32CatId == MMI_CATEGORY171_ID)
    {
        wgui_title_set_style(GUI_TITLE_STYLE_SCROLLING);
    }
    else
    {
#if defined(__MMI_MAINLCD_96X64__)
        wgui_title_set_style(GUI_TITLE_STYLE_NORMAL);
#else /*__MMI_MAINLCD_96X64__*/
        wgui_title_set_style(GUI_TITLE_STYLE_LEFTALIGN);
#endif  
    }
#endif
#ifdef MMI_SHOW_STATUS_ICON_IN_TITLE
    wgui_status_icon_bar_enable_integrated(MMI_FALSE);
#endif
    wgui_title_set_no_icon_shct(MMI_FALSE);

    wgui_title_change(0, 0, (U8 *)MMI_title_string, WGUI_TITLE_CHANGE_ICON | WGUI_TITLE_CHANGE_ICON2 | WGUI_TITLE_CHANGE_TEXT);
    wgui_title_show(GUI_TITLE_PART_ALL);
    gui_pop_clip();
}
#endif /* !defined(GUI_EDITOR_SHOW_TITLE) */

#ifdef __MMI_CATEGORY5_IMGAGE_SUPPORT__

/*****************************************************************************
 * FUNCTION
 *  wgui_cat_ml_setup_image
 * DESCRIPTION
 *  set the header image and footer image in multiline editor
 * PARAMETERS
 *  header_img     [IN]  header image        
 *  footer_img     [IN]  footer image
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat_ml_setup_image(CHAR* header_img, CHAR* footer_img)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_wgui_cat_ml_header_img = header_img;
    g_wgui_cat_ml_footer_img = footer_img;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat_ml_setup_cache_buffer
 * DESCRIPTION
 *  setup the cache buffer from app
 * PARAMETERS
 *  cache_buf          [IN]       
 *  cache_buf_size     [IN] 
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat_ml_setup_cache_buffer(U8* cache_buf, S32 cache_buf_size)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_wgui_cat_ml_header_img_cache.buf_ptr = cache_buf;
    g_wgui_cat_ml_header_img_cache_buffer_size = cache_buf_size;
    g_wgui_cat_ml_header_img_is_cached = MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat_ml_disable_cache_buffer
 * DESCRIPTION
 *  set the header image and footer image in multiline editor
 * PARAMETERS
 *  header_img     [IN]  header image        
 *  footer_img     [IN]  footer image
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat_ml_disable_cache_buffer(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_wgui_cat_ml_header_img_is_cached = MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat_ml_enable_cache_buffer
 * DESCRIPTION
 *  set the header image and footer image in multiline editor
 * PARAMETERS
 *  header_img     [IN]  header image        
 *  footer_img     [IN]  footer image
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat_ml_enable_cache_buffer(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_wgui_cat_ml_header_img_cache.buf_ptr && (g_wgui_cat_ml_header_img_cache.width > 0) && (g_wgui_cat_ml_header_img_cache.height > 0))
    {
        g_wgui_cat_ml_header_img_is_cached = MMI_TRUE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat_ml_reset_cache_buffer
 * DESCRIPTION
 *  reset the cache buffer from app
 * PARAMETERS
 *  void 
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat_ml_reset_cache_buffer(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_wgui_cat_ml_header_img_cache.buf_ptr = NULL;
    g_wgui_cat_ml_header_img_cache.width = 0;
    g_wgui_cat_ml_header_img_cache.height = 0;
    g_wgui_cat_ml_header_img_cache_buffer_size = 0;
    g_wgui_cat_ml_header_img_is_cached = MMI_FALSE;
}



/*****************************************************************************
 * FUNCTION
 *  wgui_cat_ml_setup_image_res
 * DESCRIPTION
 *  set the header image and footer image in multiline editor
 * PARAMETERS
 *  header_img     [IN]  header image        
 *  footer_img     [IN]  footer image
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat_ml_setup_image_res(PU8 header_img, PU8 footer_img)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_wgui_cat_ml_header_img_res = header_img;
    g_wgui_cat_ml_footer_img_res = footer_img;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat_ml_image_decode_done_callback
 * DESCRIPTION
 *  decode done callback function called by gdi
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat_ml_image_decode_done_callback(GDI_RESULT result, gdi_handle handle)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL is_cached = MMI_FALSE;
    S32 resize_h;
    MMI_BOOL need_to_redraw_ml = MMI_TRUE;
#if defined(__MMI_VIRTUAL_KEYBOARD__) && !defined(__MMI_UI_VIRTUAL_KEYBOARD_DEFAULT_VERSION_1__)
extern gui_virtual_keyboard_struct g_wgui_virtual_keyboard;
#endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (handle != g_wgui_cat_ml_image_handle)
    {
        return;
    }

    g_wgui_cat_ml_image_handle = 0xFFFF;

    gdi_layer_free(g_wgui_cat_ml_image_cache_layer);

    if (result == GDI_SUCCEED)
    {
        is_cached = MMI_TRUE;
    }

    g_wgui_cat_ml_header_img_is_cached = is_cached;
    if (is_cached == MMI_FALSE)
    {
        g_wgui_cat_ml_header_img = NULL;
        g_wgui_cat_ml_header_img_cache.width = 0;
        g_wgui_cat_ml_header_img_cache.height = 0;
    }

    /* redraw mulitiline */
    resize_h = wgui_cat_ml_get_resized_image_height(g_wgui_cat_ml_header_img, WGUI_CAT_TEXT_VIEWER_IMAGE_MAX_WIDTH, WGUI_CAT_TEXT_VIEWER_IMAGE_MAX_HEIGHT);
    if (resize_h < WGUI_CAT_TEXT_VIEWER_IMAGE_MIN_HEIGHT)
    {
        resize_h = WGUI_CAT_TEXT_VIEWER_IMAGE_MIN_HEIGHT;
    }
    MMI_multiline_inputbox.header_height = resize_h + WGUI_CAT_TEXT_VIEWER_IMAGE_BOTTOM_MARGIN;

#if defined(__MMI_VIRTUAL_KEYBOARD__) && !defined(__MMI_UI_VIRTUAL_KEYBOARD_DEFAULT_VERSION_1__)
    need_to_redraw_ml = !g_wgui_virtual_keyboard.key_down_accepted;
#endif

#if defined(__MMI_CLIPBOARD__)
    if (mmi_imc_is_clipboard_state())
    {
        need_to_redraw_ml = MMI_FALSE;
    }
#endif

    if (mmi_imc_is_ime_state())
    {
        need_to_redraw_ml = MMI_FALSE;
    }

    if (need_to_redraw_ml)
    {
        wgui_inputs_ml_show();
    }
    MMI_multiline_inputbox.ext_flags &= ~GUI_MULTI_LINE_INPUT_BOX_DISABLE_CLIPBOARD;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat_ml_load_image_file_to_buffer
 * DESCRIPTION
 *  load image file to cache buffer
 * PARAMETERS
 *  img_width     [IN]      
 *  img_height    [IN]
 *  buf_ptr       [OUT]
 *  buf_size      [IN]
 *  image_file    [IN]
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
static MMI_BOOL wgui_cat_ml_load_image_file_to_buffer(S32 img_width, S32 img_height, U8 *buf_ptr, S32 buf_size, CHAR* image_file)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	MMI_BOOL ret = MMI_TRUE;
    gdi_handle old_act_layer;
    gdi_handle old_alpha_blending_source_layer;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* If not enough memory in buffer than layer creation will assert */
    memset((void*)buf_ptr, 0, buf_size);
    if (gdi_layer_create_using_outside_memory
        (0, 0, img_width, img_height, &g_wgui_cat_ml_image_cache_layer, buf_ptr, buf_size) != GDI_LAYER_SUCCEED)
    {
        return MMI_FALSE;
    }

    gdi_layer_get_active(&old_act_layer);
    gdi_layer_push_and_set_active(g_wgui_cat_ml_image_cache_layer);
    old_alpha_blending_source_layer = gdi_set_alpha_blending_source_layer(old_act_layer);
    gdi_layer_set_source_key(TRUE, GDI_COLOR_TRANSPARENT);
    gdi_layer_set_clip(0, 0, img_width - 1, img_height - 1);
    gdi_layer_set_position(0, 0);
    gdi_draw_solid_rect(0, 0, img_width - 1, img_height - 1, GDI_COLOR_WHITE);

    gdi_nb_set_done_callback(wgui_cat_ml_image_decode_done_callback);
    g_wgui_cat_ml_image_handle = gdi_image_nb_draw_resized_file(0, 0, img_width, img_height, (S8*) image_file);

    gdi_layer_pop_and_restore_active();
    gdi_set_alpha_blending_source_layer(old_alpha_blending_source_layer);
    return ret;

}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat_ml_timer_callback
 * DESCRIPTION
 *  non-sync draw image from file manager
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat_ml_timer_callback(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 real_w, real_h, resize_x, resize_y, resize_w, resize_h;
    MMI_BOOL is_cached; 
    MMI_BOOL need_to_redraw_ml = MMI_TRUE;
#if defined(__MMI_VIRTUAL_KEYBOARD__) && !defined(__MMI_UI_VIRTUAL_KEYBOARD_DEFAULT_VERSION_1__)
extern gui_virtual_keyboard_struct g_wgui_virtual_keyboard;
#endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_wgui_cat_ml_header_img == NULL)
    {
        return;
    }

    gdi_image_get_dimension_file(g_wgui_cat_ml_header_img, &real_w, &real_h);
    
    resize_w = real_w;
    resize_h = real_h;
    if ((real_w > WGUI_CAT_TEXT_VIEWER_IMAGE_MAX_WIDTH) || (real_h > WGUI_CAT_TEXT_VIEWER_IMAGE_MAX_HEIGHT))
    {
        gdi_image_util_fit_bbox(
            WGUI_CAT_TEXT_VIEWER_IMAGE_MAX_WIDTH,
            WGUI_CAT_TEXT_VIEWER_IMAGE_MAX_HEIGHT,
            real_w,
            real_h,
            &resize_x,
            &resize_y,
            &resize_w,
            &resize_h);
    }
        
    if (g_wgui_cat_ml_header_img_cache.buf_ptr != NULL)
    {

        MMI_ASSERT(g_wgui_cat_ml_header_img_cache_buffer_size >= (resize_w * resize_h * GUI_EFFECT_LAYER_BYTE_PER_PIXEL));
        MMI_ASSERT(resize_w > 0 && resize_h > 0);

        is_cached = wgui_cat_ml_load_image_file_to_buffer(
                        resize_w, 
                        resize_h, 
                        g_wgui_cat_ml_header_img_cache.buf_ptr,
                        g_wgui_cat_ml_header_img_cache_buffer_size,
                        g_wgui_cat_ml_header_img);
        
        //g_wgui_cat_ml_header_img_is_cached = is_cached;
        if (is_cached)
        {
            g_wgui_cat_ml_header_img_cache.width= resize_w;
            g_wgui_cat_ml_header_img_cache.height = resize_h;

            /*
            if (resize_h < WGUI_CAT_TEXT_VIEWER_IMAGE_MIN_HEIGHT)
            {
                resize_h = WGUI_CAT_TEXT_VIEWER_IMAGE_MIN_HEIGHT;
            }
            MMI_multiline_inputbox.header_height = resize_h + WGUI_CAT_TEXT_VIEWER_IMAGE_BOTTOM_MARGIN;
            */
        }
        else
        {
            g_wgui_cat_ml_header_img_cache.width= 0;
            g_wgui_cat_ml_header_img_cache.height = 0;
            g_wgui_cat_ml_header_img_res = NULL;
        }
    }
    else
    {
        g_wgui_cat_ml_header_img_res = NULL;
        
        /* redraw mulitiline */
        if (resize_h < WGUI_CAT_TEXT_VIEWER_IMAGE_MIN_HEIGHT)
        {
            resize_h = WGUI_CAT_TEXT_VIEWER_IMAGE_MIN_HEIGHT;
        }
        MMI_multiline_inputbox.header_height = resize_h + WGUI_CAT_TEXT_VIEWER_IMAGE_BOTTOM_MARGIN;

#if defined(__MMI_VIRTUAL_KEYBOARD__) && !defined(__MMI_UI_VIRTUAL_KEYBOARD_DEFAULT_VERSION_1__)
        need_to_redraw_ml = !g_wgui_virtual_keyboard.key_down_accepted;
#endif

#if defined(__MMI_CLIPBOARD__)
        if (mmi_imc_is_clipboard_state())
        {
            need_to_redraw_ml = MMI_FALSE;
        }
#endif

        if (mmi_imc_is_ime_state())
        {
            need_to_redraw_ml = MMI_FALSE;
        }

        if (need_to_redraw_ml)
        {
            wgui_inputs_ml_show();
        }
        MMI_multiline_inputbox.ext_flags &= ~GUI_MULTI_LINE_INPUT_BOX_DISABLE_CLIPBOARD;
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat_ml_draw_image
 * DESCRIPTION
 *  draw the editor header image and footer image.
 * PARAMETERS
 *  wgui_editor_image_enum     [IN]        image type
 *  is_draw                    [IN]        if it is legal to draw
 *  yoffset                    [IN]        offset Y
 *  clip_x1                    [IN]        start X
 *  clip_y1                    [IN]        start Y
 *  clip_x2                    [IN]        end X
 *  clip_y2                    [IN]        end Y
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat_ml_draw_image(
        wgui_editor_image_enum image_type,
        MMI_BOOL is_draw, 
        S32 yoffset, 
        S32 height, 
        S32 clip_x1, 
        S32 clip_y1, 
        S32 clip_x2, 
        S32 clip_y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 draw_x, draw_y, draw_width = 0, draw_height = 0;
    S32 resize_x = 0, resize_y = 0, image_width = 0, image_height = 0;
    CHAR* img = NULL;
    PU8 img_res = NULL;
    GDI_HANDLE act_layer = GDI_NULL_HANDLE;
    S32 i, j;
    U16 *cached_buffer;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (is_draw == MMI_FALSE)
    {
        return;
    }
 
    gdi_layer_push_clip();
    gdi_layer_set_clip(clip_x1, clip_y1, clip_x2, clip_y2);

    if (image_type == MMI_EDITOR_FOOTER_IMAGE)
    {
        img = g_wgui_cat_ml_footer_img;
        img_res = g_wgui_cat_ml_footer_img_res;
    }
    else if (image_type == MMI_EDITOR_HEADER_IMAGE)
    {
        img = g_wgui_cat_ml_header_img;
        img_res = g_wgui_cat_ml_header_img_res;
    }

    /* get the image size */
    if (g_wgui_cat_ml_header_img_is_cached)
    {
        image_width = g_wgui_cat_ml_header_img_cache.width;
        image_height = g_wgui_cat_ml_header_img_cache.height;
    }
    else if (img_res)
    {
        gdi_image_get_dimension(img_res, &image_width, &image_height);
    }
    else if (img)
    {
        gdi_image_get_dimension_file(img, &image_width, &image_height);
    }

    /* set the area for draw image */
    draw_x = WGUI_CAT_TEXT_VIEWER_LEFT_MARGIN;
    draw_y = yoffset;
    
    if ((image_width <= WGUI_CAT_TEXT_VIEWER_IMAGE_MAX_WIDTH) && (image_height <= (height - WGUI_CAT_TEXT_VIEWER_IMAGE_BOTTOM_MARGIN)))
    {
        draw_x += ((WGUI_CAT_TEXT_VIEWER_IMAGE_MAX_WIDTH - image_width) >> 1);
        draw_y += (((height - WGUI_CAT_TEXT_VIEWER_IMAGE_BOTTOM_MARGIN) - image_height) >> 1);
        draw_width = image_width;
        draw_height = image_height;
    }
    else
    {
        MMI_ASSERT(g_wgui_cat_ml_header_img_is_cached == MMI_FALSE);
        gdi_image_util_fit_bbox(
            WGUI_CAT_TEXT_VIEWER_IMAGE_MAX_WIDTH,
            height - WGUI_CAT_TEXT_VIEWER_IMAGE_BOTTOM_MARGIN,
            image_width,
            image_height,
            &resize_x,
            &resize_y,
            &draw_width,
            &draw_height);
    }
    
    /* Draw iamge */
    gdi_layer_get_active(&act_layer);
    if (act_layer != GDI_NULL_HANDLE)
    {
        gdi_push_and_set_alpha_blending_source_layer(act_layer);
    }

    if (g_wgui_cat_ml_header_img_is_cached)
    {
        MMI_ASSERT(g_wgui_cat_ml_header_img_cache.buf_ptr != NULL && image_width > 0 && image_height > 0);
        cached_buffer = (U16*) g_wgui_cat_ml_header_img_cache.buf_ptr;

        for (i = 0; i <= (image_height - 1); i++)
        {
            for (j = 0; j <= (image_width - 1); j++)
            {
                if (((draw_y + i) >= MMI_multiline_inputbox.y + 1) && ((draw_y + i) < MMI_multiline_inputbox.y + MMI_multiline_inputbox.height - 1))
                {
                    GDI_SET_BUFFER_PIXEL2(draw_x + j, draw_y + i, cached_buffer[i * image_width + j]);
                }
            }
        }
    }
    else if (img_res)
    {
        gdi_image_draw_resized(draw_x + resize_x, draw_y + resize_y, draw_width, draw_height, img_res);
        
        /* non-sync display file manager image */
        if (img != NULL && g_wgui_cat_ml_image_handle == 0xFFFF)
        {
            gui_start_timer(400, wgui_cat_ml_timer_callback);
        }
    }
    else if (img)
    {
        if ( GDI_SUCCEED != gdi_image_draw_resized_file(draw_x + resize_x, draw_y + resize_y, draw_width, draw_height, img))
        {
            gui_fill_rectangle(draw_x + resize_x, draw_y + resize_y, draw_x + resize_x + draw_width - 1, draw_y + resize_y + draw_height - 1, MMI_multiline_inputbox.normal_filler->c);
            if (img_res)
            {
                gdi_image_get_dimension(img_res, &image_width, &image_height);
                draw_x = WGUI_CAT_TEXT_VIEWER_LEFT_MARGIN;
                draw_y = yoffset;
                
                if ((image_width <= WGUI_CAT_TEXT_VIEWER_IMAGE_MAX_WIDTH) && (image_height <= (height - WGUI_CAT_TEXT_VIEWER_IMAGE_BOTTOM_MARGIN)))
                {
                    draw_x += ((WGUI_CAT_TEXT_VIEWER_IMAGE_MAX_WIDTH - image_width) >> 1);
                    draw_y += (((height - WGUI_CAT_TEXT_VIEWER_IMAGE_BOTTOM_MARGIN) - image_height) >> 1);
                    draw_width = image_width;
                    draw_height = image_height;
                    resize_x = 0;
                    resize_y = 0;
                }
                else
                {
                    gdi_image_util_fit_bbox(
                        WGUI_CAT_TEXT_VIEWER_IMAGE_MAX_WIDTH,
                        height - WGUI_CAT_TEXT_VIEWER_IMAGE_BOTTOM_MARGIN,
                        image_width,
                        image_height,
                        &resize_x,
                        &resize_y,
                        &draw_width,
                        &draw_height);
                }
                gdi_image_draw_resized(draw_x + resize_x, draw_y + resize_y, draw_width, draw_height, img_res);
            }
        }
        else
        {
            if (g_wgui_cat_ml_header_img_cache.buf_ptr != NULL && g_wgui_cat_ml_header_img_is_cached == MMI_FALSE && g_wgui_cat_ml_image_handle == 0xFFFF)
            {
                gui_start_timer(400, wgui_cat_ml_timer_callback);
            }
        }
    }

    if (act_layer != GDI_NULL_HANDLE)
    {
        gdi_pop_and_restore_alpha_blending_source_layer();
    }

    gdi_layer_pop_clip();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat_ml_header_img_show
 * DESCRIPTION
 *  draw the editor header image.
 * PARAMETERS
 *  is_draw     [IN]        if it is legal to draw
 *  yoffset     [IN]        offset Y
 *  clip_x1     [IN]        start X
 *  clip_y1     [IN]        start Y
 *  clip_x2     [IN]        end X
 *  clip_y2     [IN]        end Y
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat_ml_header_img_show(MMI_BOOL is_draw, S32 yoffset, S32 height, S32 clip_x1, S32 clip_y1, S32 clip_x2, S32 clip_y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT((g_wgui_cat_ml_header_img != NULL) || (g_wgui_cat_ml_header_img_res != NULL) || ((g_wgui_cat_ml_header_img_cache.buf_ptr) && (g_wgui_cat_ml_header_img_is_cached)));
    wgui_cat_ml_draw_image(MMI_EDITOR_HEADER_IMAGE, is_draw, yoffset, height, clip_x1, clip_y1, clip_x2, clip_y2);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat_ml_footer_img_show
 * DESCRIPTION
 *  draw the editor footer image.
 * PARAMETERS
 *  is_draw     [IN]        if it is legal to draw
 *  yoffset     [IN]        offset Y
 *  clip_x1     [IN]        start X
 *  clip_y1     [IN]        start Y
 *  clip_x2     [IN]        end X
 *  clip_y2     [IN]        end Y
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat_ml_footer_img_show(MMI_BOOL is_draw, S32 yoffset, S32 height, S32 clip_x1, S32 clip_y1, S32 clip_x2, S32 clip_y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT((g_wgui_cat_ml_footer_img != NULL) || (g_wgui_cat_ml_footer_img_res != NULL));
    wgui_cat_ml_draw_image(MMI_EDITOR_FOOTER_IMAGE, is_draw, yoffset, height, clip_x1, clip_y1, clip_x2, clip_y2);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat_ml_get_resized_image_height
 * DESCRIPTION
 *  get the header/footer image height after resized.
 * PARAMETERS
 *  image_file     [IN]        image file name
 *  max_w          [IN]        max image width
 *  max_h          [IN]        max image height
 * RETURNS
 *  S32    the resized height
 *****************************************************************************/
S32 wgui_cat_ml_get_resized_image_height(CHAR* image_file, S32 max_w, S32 max_h)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 real_w = 0, real_h = 0;
    S32 resize_x, resize_y, resize_w = 0, resize_h = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_image_get_dimension_file(image_file, &real_w, &real_h);

    resize_w = real_w;
    resize_h = real_h;
    if ((real_w > max_w) || (real_h > max_h))
    {
        gdi_image_util_fit_bbox(
            max_w,
            max_h,
            real_w,
            real_h,
            &resize_x,
            &resize_y,
            &resize_w,
            &resize_h);
    }
    return resize_h;

}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat_ml_get_resized_image_height_res
 * DESCRIPTION
 *  get the header/footer image height after resized.
 * PARAMETERS
 *  image_file     [IN]        image file name
 *  max_w          [IN]        max image width
 *  max_h          [IN]        max image height
 * RETURNS
 *  S32    the resized height
 *****************************************************************************/
S32 wgui_cat_ml_get_resized_image_height_res(PU8 image_res, S32 max_w, S32 max_h)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 real_w = 0, real_h = 0;
    S32 resize_x, resize_y, resize_w = 0, resize_h = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_image_get_dimension(image_res, &real_w, &real_h);

    resize_w = real_w;
    resize_h = real_h;
    if ((real_w > max_w) || (real_h > max_h))
    {
        gdi_image_util_fit_bbox(
            max_w,
            max_h,
            real_w,
            real_h,
            &resize_x,
            &resize_y,
            &resize_w,
            &resize_h);
    }
    return resize_h;

}
#else/* __MMI_CATEGORY5_IMGAGE_SUPPORT__ */
void wgui_cat_ml_timer_callback(void)
{
    
}
void wgui_cat_ml_setup_image(CHAR* header_img, CHAR* footer_img)
{
    
}
void wgui_cat_ml_setup_image_res(PU8 header_img, PU8 footer_img)
{
    
}    
void wgui_cat_ml_footer_img_show(MMI_BOOL is_draw, S32 yoffset, S32 height, S32 clip_x1, S32 clip_y1, S32 clip_x2, S32 clip_y2)
{
    
}
S32 wgui_cat_ml_get_resized_image_height(CHAR* image_file, S32 max_w, S32 max_h)
{
    return 0;
}    
S32 wgui_cat_ml_get_resized_image_height_res(PU8 image_res, S32 max_w, S32 max_h)
{
    return 0;
}        
void wgui_cat_ml_header_img_show(MMI_BOOL is_draw, S32 yoffset, S32 height, S32 clip_x1, S32 clip_y1, S32 clip_x2, S32 clip_y2)
{
    
}


#endif /* __MMI_CATEGORY5_IMGAGE_SUPPORT__ */


/*****************************************************************************
 * FUNCTION
 *  wgui_cat_ml_inputbox_show_internal
 * DESCRIPTION
 *  show the normal multiline inputbox category.
 * PARAMETERS
 * title :                   [IN] (TITLE) String ID of title.
 * title_icon :              [IN] (N/A) Image ID of title icon.
 * left_softkey :            [IN] (LSK) String ID of left softkey.
 * right_softkey :           [IN] (RSK) String ID of right softkey.
 * input_type :              [IN] (N/A) Allowable input type for this inputbox.
 *                                    Please refer to mmi_imm_input_type_enum(ImeGprot.h) for detail.
 * buffer :                  [IN] (N/A) Buffer for the input box.
 * buffer_size :             [IN] (N/A) Size of the buffer.
 * history_buffer :          [IN] (N/A) History buffer. 
 * input_ext_type :          [IN] (N/A) Special flags for application.  
 * required_input_mode_set : [IN] (N/A) The input mode list.  
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat_ml_inputbox_show_internal(
        UI_string_type title,
        PU8 title_icon,
        UI_string_type left_softkey,
        UI_string_type right_softkey,
        U8 *ticker_text,
        U32 input_type,
        U8 *buffer,
        S32 buffer_size,
        U8 *history_buffer,
        S16 input_ext_type,
        mmi_imm_input_mode_enum *required_input_mode_set,
        MMI_BOOL is_active_editor,
        MMI_BOOL force_title,
        S32 cat_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 dm_data_flag;
    S32 header_height = 0;
    S32 inputbox_x = 0;
    S32 inputbox_y = (MMI_title_y + MMI_title_height);
    S32 inputbox_width = MMI_content_width;
#if defined(__COSMOS_MMI_PACKAGE__)
    color c = gui_color(255,255,255);
#endif

    S32 inputbox_height = MMI_content_height;
    S32 resize_h = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/  
#if(UI_DOUBLE_BUFFER_SUPPORT)
    gui_lock_double_buffer();
#endif 

    /* set the editor active flag */
#ifdef __J2ME__
    g_wgui_cat2002_is_active_editor = is_active_editor;
#endif /* __J2ME__ */

    wgui_title_set_menu_shortcut_number(-1);
    wgui_title_disable_menu_shortcut_display(MMI_TRUE);
    dm_add_title(title, title_icon); 
    dm_add_softkey_str(left_softkey, right_softkey);

#if !defined(GUI_EDITOR_SHOW_TITLE)
    if (g_title_in_header)
    {
        header_height = MMI_title_height;
    }
#endif /* !defined(GUI_EDITOR_SHOW_TITLE) */
    if(MMI_CATEGORY171_ID == cat_id)
    {
        /* for T9 */
        inputbox_height = MMI_content_height - 12;

#if defined(__MMI_MAINLCD_128X64__)
#if !defined(GUI_EDITOR_SHOW_TITLE)
        header_height = MMI_MENUITEM_HEIGHT;
#endif /* GUI_EDITOR_SHOW_TITLE */
#endif /* (__MMI_MAINLCD_128X64__) */

    }

#ifdef __J2ME__
    if(g_wgui_cat2002_is_in_java == MMI_TRUE)
    {
        wgui_inputs_ml_setup_ext2(
            inputbox_x,
            inputbox_y,
            inputbox_width,
            inputbox_height,
            buffer,
            buffer_size,
            cat_id,
            right_softkey,
            NULL,
            input_type,
            history_buffer,
            required_input_mode_set,
        #ifdef __MMI_FTE_SUPPORT__        
            0,
        #else
            1,
        #endif
            0,
            0,
            0,
            (S16)header_height,
            0,
            NULL,
            wgui_cat2002_ime_msg_callback,
            MMI_TRUE);
    }
    else
#endif /* __J2ME__ */
    {
        wgui_inputs_ml_setup_ext(
            inputbox_x,
            inputbox_y,
            inputbox_width,
            inputbox_height,
            buffer,
            buffer_size,
            cat_id,
            right_softkey,
            NULL,
            input_type,
            history_buffer,
            required_input_mode_set,
        #ifdef __MMI_FTE_SUPPORT__        
            0,
        #else
            1,
        #endif
            0,
            0,
            0,
            (S16)header_height,
            0,
            NULL);
    }
    
    wgui_inputs_ml_set_common_style(MMI_TRUE, MMI_TRUE);

#if !defined(GUI_EDITOR_SHOW_TITLE)
    if (g_title_in_header)
    {
        MMI_multiline_inputbox.header_callback = wgui_cat5_title_in_header_callback;
    }
#endif /* !defined(GUI_EDITOR_SHOW_TITLE) */

    if(MMI_CATEGORY171_ID == cat_id)
    {

#if defined(__MMI_MAINLCD_128X64__)
#if !defined(GUI_EDITOR_SHOW_TITLE)
        MMI_multiline_inputbox.header_callback = wgui_cat5_title_in_header_callback;
#endif /* GUI_EDITOR_SHOW_TITLE */
#endif /* (__MMI_MAINLCD_128X64__) */

        wgui_inputs_ml_set_common_style(MMI_FALSE, MMI_TRUE);

        /* W05.41 Do not Clear Key Pound Function because it is used in some input method */
        setup_scrolling_title();

    }
#ifdef __MMI_CATEGORY5_IMGAGE_SUPPORT__
    if ((MMI_CATEGORY5_ID == cat_id) && (g_wgui_cat_ml_header_img_cache.buf_ptr) && (g_wgui_cat_ml_header_img_is_cached))
    {
        if (g_wgui_cat_ml_header_img_cache.height < WGUI_CAT_TEXT_VIEWER_IMAGE_MIN_HEIGHT)
        {
            MMI_multiline_inputbox.header_height = WGUI_CAT_TEXT_VIEWER_IMAGE_MIN_HEIGHT + WGUI_CAT_TEXT_VIEWER_IMAGE_BOTTOM_MARGIN;
        }
        else
        {
            MMI_multiline_inputbox.header_height = g_wgui_cat_ml_header_img_cache.height + WGUI_CAT_TEXT_VIEWER_IMAGE_BOTTOM_MARGIN;
        }
        MMI_multiline_inputbox.header_callback = wgui_cat_ml_header_img_show;
    }
    else if ((MMI_CATEGORY5_ID == cat_id) && (g_wgui_cat_ml_header_img_res != NULL))
    {
        resize_h = wgui_cat_ml_get_resized_image_height_res(g_wgui_cat_ml_header_img_res, WGUI_CAT_TEXT_VIEWER_IMAGE_MAX_WIDTH, WGUI_CAT_TEXT_VIEWER_IMAGE_MAX_HEIGHT);
        if (resize_h < WGUI_CAT_TEXT_VIEWER_IMAGE_MIN_HEIGHT)
        {
            resize_h = WGUI_CAT_TEXT_VIEWER_IMAGE_MIN_HEIGHT;
        }
        MMI_multiline_inputbox.header_height = resize_h + WGUI_CAT_TEXT_VIEWER_IMAGE_BOTTOM_MARGIN;
        MMI_multiline_inputbox.header_callback = wgui_cat_ml_header_img_show;
        if (g_wgui_cat_ml_header_img != NULL)
        {
            MMI_multiline_inputbox.ext_flags |= GUI_MULTI_LINE_INPUT_BOX_DISABLE_CLIPBOARD;
        }
    }
    else if ((MMI_CATEGORY5_ID == cat_id) && (g_wgui_cat_ml_header_img != NULL))
    {
        resize_h = wgui_cat_ml_get_resized_image_height(g_wgui_cat_ml_header_img, WGUI_CAT_TEXT_VIEWER_IMAGE_MAX_WIDTH, WGUI_CAT_TEXT_VIEWER_IMAGE_MAX_HEIGHT);
        if (resize_h < WGUI_CAT_TEXT_VIEWER_IMAGE_MIN_HEIGHT)
        {
            resize_h = WGUI_CAT_TEXT_VIEWER_IMAGE_MIN_HEIGHT;
        }
        MMI_multiline_inputbox.header_height = resize_h + WGUI_CAT_TEXT_VIEWER_IMAGE_BOTTOM_MARGIN;
        MMI_multiline_inputbox.header_callback = wgui_cat_ml_header_img_show;
    }

    if ((MMI_CATEGORY5_ID == cat_id) && (g_wgui_cat_ml_footer_img != NULL))
    {
        resize_h = wgui_cat_ml_get_resized_image_height(g_wgui_cat_ml_footer_img, WGUI_CAT_TEXT_VIEWER_IMAGE_MAX_WIDTH, WGUI_CAT_TEXT_VIEWER_IMAGE_MAX_HEIGHT);
        if (resize_h < WGUI_CAT_TEXT_VIEWER_IMAGE_MIN_HEIGHT)
        {
            resize_h = WGUI_CAT_TEXT_VIEWER_IMAGE_MIN_HEIGHT;
        }
        MMI_multiline_inputbox.footer_height = resize_h + WGUI_CAT_TEXT_VIEWER_IMAGE_BOTTOM_MARGIN;
        MMI_multiline_inputbox.footer_callback = wgui_cat_ml_footer_img_show;
    }
    else if ((MMI_CATEGORY5_ID == cat_id) && (g_wgui_cat_ml_footer_img_res != NULL))
    {
        resize_h = wgui_cat_ml_get_resized_image_height_res(g_wgui_cat_ml_footer_img_res, WGUI_CAT_TEXT_VIEWER_IMAGE_MAX_WIDTH, WGUI_CAT_TEXT_VIEWER_IMAGE_MAX_HEIGHT);
        if (resize_h < WGUI_CAT_TEXT_VIEWER_IMAGE_MIN_HEIGHT)
        {
            resize_h = WGUI_CAT_TEXT_VIEWER_IMAGE_MIN_HEIGHT;
        }
        MMI_multiline_inputbox.footer_height = resize_h + WGUI_CAT_TEXT_VIEWER_IMAGE_BOTTOM_MARGIN;
        MMI_multiline_inputbox.footer_callback = wgui_cat_ml_footer_img_show;
    }
#endif /* __MMI_CATEGORY5_IMGAGE_SUPPORT__ */ 

    if (input_ext_type != 0)
    {
        MMI_current_input_ext_type = input_ext_type;
    }
    if (((input_type & INPUT_TYPE_MASK) == IMM_INPUT_TYPE_NUMERIC_PASSWORD) ||
        ((input_type & INPUT_TYPE_MASK) == IMM_INPUT_TYPE_ALPHANUMERIC_PASSWORD) ||
        ((input_type & INPUT_TYPE_MASK) == IMM_INPUT_TYPE_SAT_NUMERIC_PASSWORD) ||
        ((input_type & INPUT_TYPE_MASK) == IMM_INPUT_TYPE_SIGNED_DECIMAL_NUMERIC_PASSWORD) ||
        ((input_type & INPUT_TYPE_MASK) == IMM_INPUT_TYPE_SIGNED_NUMERIC_PASSWORD))
    {
        MMI_current_input_ext_type |= INPUT_TYPE_EXT_NO_SHOW_NEW_LINE_SYMBOL;
    }
    
    wgui_inputs_ml_handle_input_ext_type(input_type);

#ifdef __J2ME__
    /* if the editor is read-only, then inactivate it */
    if (g_wgui_cat2002_is_active_editor == MMI_FALSE)
    {
        /* set current status is actived editor */
        g_wgui_cat2002_is_active_editor = MMI_TRUE;

        wgui_cat2002_inactivate_editor(
            left_softkey, 
            NULL, 
            right_softkey,
            NULL,
            (UI_string_type)buffer,
            buffer_size);
        set_multiline_inputbox_category_history(cat_id, history_buffer);
    }
#endif /* __J2ME__ */

#ifdef __MMI_WALLPAPER_ON_BOTTOM__
    dm_get_scr_bg_opacity(&editor_scr_bg_opacity);
    dm_set_scr_bg_opacity((U8)(current_MMI_theme->bg_opacity_low));
#endif /* __MMI_WALLPAPER_ON_BOTTOM__ */

#if(UI_DOUBLE_BUFFER_SUPPORT)
    gui_unlock_double_buffer();
#endif
    
    dm_data_flag = DM_CLEAR_SCREEN_BACKGROUND | DM_SHOW_VKPAD;
#if !defined(GUI_EDITOR_SHOW_TITLE)
    if ((cat_id != MMI_CAT2002_ID) && (cat_id != MMI_CAT2002_NO_TICKER_ID) && (!force_title))
    {
        dm_data_flag |= DM_NO_TITLE;
    }
#endif /* !defined(GUI_EDITOR_SHOW_TITLE) */

#if defined(__MMI_MAINLCD_96X64__)
    dm_data_flag |= DM_NO_TITLE;
#endif /*__MMI_MAINLCD_96X64__*/
#ifdef __J2ME__
#ifdef __MMI_FTE_SUPPORT__
    if((cat_id == MMI_CAT2002_ID) && (ticker_text != NULL))
    {
        dm_register_category_controlled_callback(wgui_cat2002_ctrl_area_callback);
    }
#endif /* __MMI_FTE_SUPPORT__ */
#endif /* __J2ME__ */
    if(MMI_CATEGORY171_ID == cat_id)
    {
#if defined(__MMI_MAINLCD_128X64__)
         dm_data_flag = DM_CLEAR_SCREEN_BACKGROUND | DM_NO_TITLE | DM_SHOW_VKPAD;
#else /* __MMI_MAINLCD_128X64__ */
         dm_data_flag = DM_CLEAR_SCREEN_BACKGROUND | DM_SCROLL_TITLE | DM_SHOW_VKPAD;
#endif /* __MMI_MAINLCD_128X64__ */

    }

    wgui_cat_setup_category_default_history(cat_id, dm_data_flag, ExitCategory5Screen);
    dm_register_vkpad_callback(mmi_imc_redraw_screen_by_state);
    dm_redraw_category_screen();
}


/* For detail description, please refer to wgui_categories_inputs.h */
void ShowCategory5Screen_ext2_int(
        UI_string_type title,
        PU8 title_icon,
        UI_string_type left_softkey,
        UI_string_type right_softkey,
        U32 input_type,
        U8 *buffer,
        S32 buffer_size,
        U8 *history_buffer,
        S16 input_ext_type,
        mmi_imm_input_mode_enum *required_input_mode_set)
{
    wgui_cat_ml_inputbox_show_internal(
            title,
            title_icon,
            left_softkey,
            right_softkey,
            NULL,
            input_type,
            buffer,
            buffer_size,
            history_buffer,
            input_ext_type,
            required_input_mode_set,
            MMI_TRUE,
            MMI_FALSE,
            MMI_CATEGORY5_ID);
}


/* For detail description, please refer to wgui_categories_inputs.h */
void ShowCategory5Screen_ext_int(
        U16 title,
        U16 title_icon,
        U16 left_softkey,
        U16 right_softkey,
        U32 input_type,
        U8 *buffer,
        S32 buffer_size,
        U8 *history_buffer,
        S16 input_ext_type,
        mmi_imm_input_mode_enum *required_input_mode_set)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(__MMI_SMALL_EDIT_SCREEN__) 
    if (whether_no_small_screen())
    {
        ShowCategory100Screen_int(
            title,
            title_icon,
            left_softkey,
            right_softkey,
            input_type,
            buffer,
            buffer_size,
            history_buffer,
            input_ext_type,
            required_input_mode_set);
    }
    else
#endif /* defined(__MMI_SMALL_EDIT_SCREEN__) */ 
    {
        wgui_cat_ml_inputbox_show_internal(
            get_string(title),
            get_image(title_icon),
            get_string(left_softkey),
            get_string(right_softkey),
            NULL,
            input_type,
            buffer,
            buffer_size,
            history_buffer,
            input_ext_type,
            required_input_mode_set,
            MMI_TRUE,
            MMI_FALSE,
            MMI_CATEGORY5_ID);
    }
}


#ifdef __J2ME__
#if defined(__MMI_VIRTUAL_KEYBOARD__)
/*****************************************************************************
* FUNCTION
*  wgui_cat2002_large_icon_appear_callback
* DESCRIPTION
*  virtual keypad large icon appear.
* PARAMETERS
*  x1        [IN]   unused.
*  y1        [IN]   unused.
*  x2        [IN]   unused.
*  y2        [IN]   unused.
* RETURNS
*  void
*****************************************************************************/
static MMI_BOOL wgui_cat2002_large_icon_appear_callback(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    //MMI_BOOL ret = MMI_TRUE;    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_wgui_cat2002_is_cursor_stopped = UI_inputbox_stop_cursor(x1, y1, x2, y2);
    g_wgui_cat2002_is_large_icon_appeared = MMI_TRUE;

    return MMI_TRUE;
}


/*****************************************************************************
* FUNCTION
*  wgui_cat2002_large_icon_disappear_callback
* DESCRIPTION
*  virtual keypad large icon disappear.
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void wgui_cat2002_large_icon_disappear_callback(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_wgui_cat2002_is_cursor_stopped == MMI_TRUE)
    {
        UI_inputbox_start_cursor();
        g_wgui_cat2002_is_cursor_stopped = MMI_FALSE;
    }
    g_wgui_cat2002_is_large_icon_appeared = MMI_FALSE;
}
#endif


/*****************************************************************************
 * FUNCTION
 *  wgui_category_clear_region_with_black_color
 * DESCRIPTION
 *  clear the given region with black color
 * PARAMETERS
 *  x1    [IN]    start x
 *  y1    [IN]    start y
 *  x2    [IN]    end x
 *  y2    [IN[    end y 
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_category_clear_region_with_black_color(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_coordinates ticker_coordinates;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_FTE_SUPPORT__
    dm_get_control_coordinates_from_category(
        -1,
        MMI_CAT2002_ID,
        DM_CATEGORY_CONTROLLED_AREA,
        -1,
        &ticker_coordinates);
#else
    dm_get_control_coordinates_from_category(
        -1,
        MMI_CAT2002_ID,
        DM_SCROLL_TEXT,
        -1,
        &ticker_coordinates);
#endif /* __MMI_FTE_SUPPORT__ */

    gui_push_clip();
    gui_set_clip(
        (S32)ticker_coordinates.s16X,
        (S32)ticker_coordinates.s16Y,
        (S32)ticker_coordinates.s16X + (S32)ticker_coordinates.s16Width,
        (S32)ticker_coordinates.s16Y + (S32)ticker_coordinates.s16Height - 1);
    gdi_draw_solid_rect(
        (S32)ticker_coordinates.s16X,
        (S32)ticker_coordinates.s16Y,
        (S32)ticker_coordinates.s16X + (S32)ticker_coordinates.s16Width,
        (S32)ticker_coordinates.s16Y + (S32)ticker_coordinates.s16Height - 1, 
        GDI_COLOR_BLACK);
    gui_pop_clip();
}


/* For detail description, please refer to wgui_categories_inputs.h */
void wgui_cat2002_show_int(
        UI_string_type title,
        PU8 title_icon,
        UI_string_type left_softkey,
        UI_string_type right_softkey,     
        U8 *ticker_text,
        U8 *buffer,
        S32 buffer_size,
        U32 input_type,
        mmi_imm_input_mode_enum *required_input_mode_set,
        MMI_BOOL is_active_editor,
        S16 input_ext_type,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 cat_id;
#if defined(__COSMOS_MMI_PACKAGE__)
    color c = gui_color(255,255,255);
#endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/  
    g_wgui_cat2002_is_in_java = MMI_TRUE;
    g_wgui_cat2002_ui_change_flag = MMI_TRUE;

    if (ticker_text != NULL)
    {
        cat_id = MMI_CAT2002_ID;
    }
    else
    {
#if !defined(GUI_EDITOR_SHOW_TITLE) 
        cat_id = MMI_CAT2002_NO_TICKER_ID; 
#else  /* (__MMI_MAINLCD_320X240__) */  
        cat_id = MMI_CATEGORY5_ID; 
#endif /* (__MMI_MAINLCD_320X240__) */
    }

    /* if ticker_text == NULL, we also need to add at here, because it may be add at run time */
    gui_set_font(&MMI_medium_font);
    dm_add_scroll_text_ext(
            (UI_string_type) ticker_text, 
            MMI_COMMON_CONTENT_X,
            MMI_COMMON_CONTENT_Y + WGUI_CAT2002_TICKER_GAP_Y,
            MMI_COMMON_CONTENT_WIDTH,
            WGUI_CAT2002_TICKER_HEIGHT - WGUI_CAT2002_TICKER_GAP_Y,
            NULL,
#ifdef __MMI_WALLPAPER_ON_BOTTOM__
    #ifdef __MMI_FTE_SUPPORT__
            wgui_category_clear_region_with_black_color,
    #else
            wgui_category_clear_region_with_transparent_color,
    #endif
#else
            NULL,
#endif/* __MMI_WALLPAPER_ON_BOTTOM__ */
#if defined(__COSMOS_MMI_PACKAGE__)
            c,
            c,
#else
            *current_MMI_theme->list_normal_text_color,
            *current_MMI_theme->list_normal_text_color,
#endif
            MMI_TRUE);

    wgui_cat_ml_inputbox_show_internal(
        title,
        title_icon,
        left_softkey,
        right_softkey,
        ticker_text,
        input_type,
        buffer,
        buffer_size,
        history_buffer,
        input_ext_type,
        required_input_mode_set,
        is_active_editor,
        MMI_TRUE,
        cat_id);

#if defined(__MMI_VIRTUAL_KEYBOARD__)
    wgui_virtual_keyboard_register_hide_cursor_callback(wgui_cat2002_large_icon_appear_callback);
    wgui_virtual_keyboard_register_blink_cursor_callback(wgui_cat2002_large_icon_disappear_callback);
#endif
}


#ifdef __MMI_FTE_SUPPORT__
/*****************************************************************************
 * FUNCTION
 *  wgui_cat2002_ctrl_area_callback
 * DESCRIPTION
 *  control area callback for category2002
 * PARAMETERS
 *  coordinate    [IN]   control area coordinate
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat2002_ctrl_area_callback(dm_coordinates *coordinate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/        

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_category_clear_region_with_black_color(
        coordinate->s16X, 
        coordinate->s16Y, 
        coordinate->s16X + coordinate->s16Width,
        coordinate->s16Y + coordinate->s16Height);
}
#endif

/* For detail description, please refer to wgui_categories_inputs.h */
void wgui_cat2002_change_text(UI_string_type new_string, S32 buffer_size, MMI_BOOL is_reset_y)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 l;
    S32 old_text_offset;
    U32 ml_flags;
    U32 ml_ext_flags;
        
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();
        
#ifdef __MMI_TOUCH_SCREEN__
    gui_multi_line_input_box_scroll_timer_hdlr();
#endif
    
    ml_flags = MMI_multiline_inputbox.flags;
    ml_ext_flags = MMI_multiline_inputbox.ext_flags;
    
    l = gui_strlen((UI_string_type) new_string);
    old_text_offset = MMI_multiline_inputbox.text_offset_y;

    gui_create_multi_line_input_box_set_buffer(
        &MMI_multiline_inputbox,
        MMI_multiline_inputbox.x,
        MMI_multiline_inputbox.y,
        MMI_multiline_inputbox.width,
        MMI_multiline_inputbox.height,
        (UI_string_type) new_string,
        buffer_size * 2,
        (l + 1) * 2,
        l);
        
#ifdef __MMI_TOUCH_SCREEN__
    /* if buffer chenged, clear the cursor position */
    g_wgui_inputs_ml_pen_down_cursor_p = NULL;
#endif /* __MMI_TOUCH_SCREEN__ */

    if (is_reset_y == MMI_FALSE)
    {
        MMI_multiline_inputbox.text_offset_y = old_text_offset;
    }
    
    MMI_multiline_inputbox.flags = ml_flags;
    MMI_multiline_inputbox.ext_flags = ml_ext_flags;

    if (g_wgui_cat2002_is_active_editor == MMI_FALSE)
    {
        MMI_multiline_inputbox.flags |= (UI_MULTI_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW | UI_MULTI_LINE_INPUT_BOX_VIEW_MODE);
    }
#ifdef __MMI_WALLPAPER_ON_BOTTOM__ 
    MMI_multiline_inputbox.flags |= UI_MULTI_LINE_INPUT_BOX_TRANSPARENT_BACKGROUND;
#endif

    if (g_wgui_cat2002_is_active_editor)
    {
        wgui_inputs_ml_set_RSK();
        MMI_multiline_inputbox.flags &= ~UI_MULTI_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW;
        MMI_multiline_inputbox.flags &= ~UI_MULTI_LINE_INPUT_BOX_VIEW_MODE;
        MMI_multiline_inputbox.ext_flags &= ~GUI_MULTI_LINE_INPUT_BOX_DISABLE_FORCE_CURSOR_APPEAR;
    }
    else
    {
        wgui_inputs_ml_show();
    }

    if (!mmi_imc_is_ime_state() && (g_wgui_cat2002_is_large_icon_appeared == MMI_FALSE))
    {
        mmi_imc_redraw_screen_by_state();
    }
    else
    {
        if (g_wgui_cat2002_is_large_icon_appeared == MMI_FALSE)
        {
            mmi_imc_reset_ime_state();
        }    
        else
        {
            wgui_inputs_ml_show_no_draw();
        }
    }    

    gdi_layer_unlock_frame_buffer();

    gdi_layer_blt_previous(0, 0, MAIN_LCD_DEVICE_WIDTH, MAIN_LCD_DEVICE_HEIGHT);
} 


/*****************************************************************************
* FUNCTION
*  wgui_cat2002_is_vk_state
* DESCRIPTION
*  virtual keypad is using or not.
* PARAMETERS
*  void
* RETURNS
*  MMI_BOOL  
*****************************************************************************/
MMI_BOOL wgui_cat2002_is_vk_state(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return MMI_FALSE;
}


/* For detail description, please refer to wgui_categories_inputs.h */
void wgui_cat2002_change_title(UI_string_type title_string, U16 title_icon)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_wgui_cat2002_ui_change_flag == MMI_FALSE || g_wgui_cat2002_is_large_icon_appeared == MMI_TRUE)
    {
        return;
    }
    wgui_title_change(title_icon, 0, (U8*) title_string, WGUI_TITLE_CHANGE_ICON|WGUI_TITLE_CHANGE_TEXT);
    wgui_title_show(GUI_TITLE_PART_ALL);
}


/* For detail description, please refer to wgui_categories_inputs.h */
void wgui_cat2002_change_ticker(UI_string_type ticker_string, MMI_BOOL resize_editor)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_coordinates ml_inputs_coordinates;
    dm_coordinates ticker_coordinates;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_wgui_cat2002_ui_change_flag == MMI_FALSE || g_wgui_cat2002_is_large_icon_appeared == MMI_TRUE)
    {
        return;
    }

    gdi_layer_lock_frame_buffer();
    
#ifdef __MMI_WALLPAPER_ON_BOTTOM__
#ifdef __MMI_FTE_SUPPORT__
    dm_get_control_coordinates_from_category(
        -1,
        MMI_CAT2002_ID,
        DM_CATEGORY_CONTROLLED_AREA,
        -1,
        &ticker_coordinates);
#else
    dm_get_control_coordinates_from_category(
        -1,
        MMI_CAT2002_ID,
        DM_SCROLL_TEXT,
        -1,
        &ticker_coordinates);
#endif /* __MMI_FTE_SUPPORT__ */
#endif/* __MMI_WALLPAPER_ON_BOTTOM__ */

    /* change the scroll text string */
    dm_change_scroll_text(0, ticker_string);
    if(ticker_string == NULL)
    {
#ifdef __MMI_WALLPAPER_ON_BOTTOM__
#ifdef __MMI_FTE_SUPPORT__
        dm_register_category_controlled_callback(NULL);
        wgui_category_clear_region_with_black_color(
            (S32)ticker_coordinates.s16X,
            (S32)ticker_coordinates.s16Y,
            (S32)ticker_coordinates.s16X + (S32)ticker_coordinates.s16Width,
            (S32)ticker_coordinates.s16Y + (S32)ticker_coordinates.s16Height);
#else
        wgui_category_clear_region_with_transparent_color(
            (S32)ticker_coordinates.s16X,
            (S32)ticker_coordinates.s16Y,
            (S32)ticker_coordinates.s16X + (S32)ticker_coordinates.s16Width,
            (S32)ticker_coordinates.s16Y + (S32)ticker_coordinates.s16Height);
#endif /* __MMI_FTE_SUPPORT__ */

        if (resize_editor == MMI_FALSE)
        {
            /* redraw multiline inputbox */
            //wgui_inputs_ml_show();
            wgui_inputs_ml_show_with_information_bar();
        }

#endif/* __MMI_WALLPAPER_ON_BOTTOM__ */
    }
    else
    {
#ifdef __MMI_FTE_SUPPORT__
        dm_register_category_controlled_callback(wgui_cat2002_ctrl_area_callback);
        wgui_category_clear_region_with_black_color(
            (S32)ticker_coordinates.s16X,
            (S32)ticker_coordinates.s16Y,
            (S32)ticker_coordinates.s16X + (S32)ticker_coordinates.s16Width,
            (S32)ticker_coordinates.s16Y + (S32)ticker_coordinates.s16Height - 1);
#else
        wgui_category_clear_region_with_transparent_color(
            (S32)ticker_coordinates.s16X,
            (S32)ticker_coordinates.s16Y,
            (S32)ticker_coordinates.s16X + (S32)ticker_coordinates.s16Width,
            (S32)ticker_coordinates.s16Y + (S32)ticker_coordinates.s16Height - 1);
#endif /* __MMI_FTE_SUPPORT__ */
        dm_restart_scroll_text(0);
    } 
    

    if (resize_editor)
    {
        /* if no ticker, the editor area should be moved up and enlarged */
        if(ticker_string == NULL)
        {
            dm_get_control_coordinates_from_category(
                -1,
                MMI_CATEGORY5_ID,
                DM_MULTILINE_INPUTBOX1,
                -1,
                &ml_inputs_coordinates);
#if !defined(GUI_EDITOR_SHOW_TITLE) 
            /* Java always show title */
            ml_inputs_coordinates.s16Y += MMI_title_height;
            ml_inputs_coordinates.s16Height -= MMI_title_height;
            g_dm_data.s32CatId = MMI_CAT2002_NO_TICKER_ID; /* Todo: revise to invoke api */
#else
            g_dm_data.s32CatId = MMI_CATEGORY5_ID;
#endif /* defined(__MMI_MAINLCD_320X240__) */
        }
        else
        {
            dm_get_control_coordinates_from_category(
                -1,
                MMI_CAT2002_ID,
                DM_MULTILINE_INPUTBOX1,
                -1,
                &ml_inputs_coordinates);
            g_dm_data.s32CatId = MMI_CAT2002_ID;
        }

        if (g_wgui_cat2002_is_active_editor)
        {
            /* move and resize multiline inputbox */
            wgui_inputs_ml_move((S32) ml_inputs_coordinates.s16X,(S32) ml_inputs_coordinates.s16Y + INFORMATION_BAR_HEIGHT);
            wgui_inputs_ml_resize((S32) ml_inputs_coordinates.s16Width,(S32) ml_inputs_coordinates.s16Height - INFORMATION_BAR_HEIGHT);

            /* move information bar */
            wgui_inputs_setup_input_information(
                wgui_inputbox_information_bar_x,
                ml_inputs_coordinates.s16Y,
                wgui_inputbox_information_bar_width,
                wgui_inputbox_information_bar_height);
            
            /* redraw multiline inputbox, virtual keypad and info-bar */
            mmi_imc_redraw_screen_by_state();
#ifndef __MMI_FTE_SUPPORT__
            wgui_inputs_ml_redraw_input_information_bar();
#endif
        }
        else
        {
            /* move and resize multiline inputbox */
            wgui_inputs_ml_move((S32) ml_inputs_coordinates.s16X,(S32) ml_inputs_coordinates.s16Y);
            wgui_inputs_ml_resize((S32) ml_inputs_coordinates.s16Width,(S32) ml_inputs_coordinates.s16Height);

            /* redraw multiline inputbox */
            wgui_inputs_ml_show();
        }
    }
    gdi_layer_unlock_frame_buffer();
    gdi_layer_blt_previous(0, 0, MAIN_LCD_DEVICE_WIDTH, MAIN_LCD_DEVICE_HEIGHT);
}


/* For detail description, please refer to wgui_categories_inputs.h */
void wgui_cat2002_activate_editor(
        UI_string_type left_softkey,
        PU8 left_softkey_icon,
        UI_string_type right_softkey,
        PU8 right_softkey_icon,  
        U8 *buffer, 
        S32 buffer_size,
        U32 input_type,
        mmi_imm_input_mode_enum *required_input_mode_set)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 l;
    S32 inputbox_x, inputbox_y, inputbox_width, inputbox_height;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_wgui_cat2002_is_active_editor == MMI_TRUE)
    {
        return;
    }
    else
    {
        gdi_layer_lock_frame_buffer();
        
        dm_add_softkey_str(left_softkey, right_softkey);

        /* resize the multiline inputbox */
        inputbox_x = MMI_multiline_inputbox.x;
        inputbox_y = MMI_multiline_inputbox.y;
        inputbox_width = MMI_multiline_inputbox.width;
        inputbox_height = UI_device_height - inputbox_y - MMI_SOFTKEY_HEIGHT;

        /* close the read-only multiline inputbox */
        wgui_inputs_ml_reset();

        /* setup the read only multiline inputbox */
        l = gui_strlen((UI_string_type) buffer);
        wgui_inputs_ml_create_set_buffer((UI_string_type) buffer, buffer_size, l, 0);

        wgui_inputs_ml_setup_ext2(
            inputbox_x,
            inputbox_y,
            inputbox_width,
            inputbox_height,
            buffer,
            buffer_size,
            MMI_CATEGORY5_ID,
            right_softkey,
            right_softkey_icon,
            input_type,
            NULL,
            required_input_mode_set,
        #ifdef __MMI_FTE_SUPPORT__        
            0,
        #else
            1,
        #endif
            0,
            0,
            0,
            0,
            0,
            NULL,
            wgui_cat2002_ime_msg_callback,
            MMI_TRUE);

#ifdef __MMI_WALLPAPER_ON_BOTTOM__ 
        MMI_multiline_inputbox.flags |= UI_MULTI_LINE_INPUT_BOX_TRANSPARENT_BACKGROUND;
#endif 

        /* set the flag to editable inputbox */
        g_wgui_cat2002_is_active_editor = MMI_TRUE;

        /* redraw multiline inputbox, virtual keypad and info-bar */
        mmi_imc_redraw_screen_by_state();
#ifndef __MMI_FTE_SUPPORT__
        wgui_inputs_ml_redraw_input_information_bar();
#endif
        gdi_layer_unlock_frame_buffer();
        gdi_layer_blt_previous(0, 0, MAIN_LCD_DEVICE_WIDTH, MAIN_LCD_DEVICE_HEIGHT);
    }
}


/* For detail description, please refer to wgui_categories_inputs.h */
void wgui_cat2002_inactivate_editor(
        UI_string_type left_softkey,
        PU8 left_softkey_icon,
        UI_string_type right_softkey,
        PU8 right_softkey_icon, 
        UI_string_type buffer, 
        S32 buffer_size)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 l;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_wgui_cat2002_is_active_editor == MMI_FALSE)
    {
        return;
    }
    else
    {
        gdi_layer_lock_frame_buffer();
        
        /* setup softkey */
        dm_add_softkey_str(left_softkey, right_softkey);

        /* resize the multiline inputbox */
        MMI_multiline_inputbox_y = MMI_multiline_inputbox.y - INFORMATION_BAR_HEIGHT;
        MMI_multiline_inputbox_height = UI_device_height - MMI_multiline_inputbox_y - MMI_SOFTKEY_HEIGHT;

        /* close the editable multiline inputbox */
        wgui_inputs_ml_close();

        /* setup the read only multiline inputbox */
        l = gui_strlen((UI_string_type) buffer);
        wgui_inputs_ml_create_set_buffer((UI_string_type) buffer, buffer_size, l, 0);

		/* set key handler */
		set_right_softkey_function(NULL, KEY_EVENT_LONG_PRESS);
        wgui_inputs_ml_register_viewer_keys();

        MMI_multiline_inputbox.flags |= (UI_MULTI_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW | UI_MULTI_LINE_INPUT_BOX_VIEW_MODE);
        #ifdef __MMI_WALLPAPER_ON_BOTTOM__ 
        MMI_multiline_inputbox.flags |= UI_MULTI_LINE_INPUT_BOX_TRANSPARENT_BACKGROUND;
        #endif 

        /* set the flag to Read-only inputbox */
        g_wgui_cat2002_is_active_editor = MMI_FALSE;

        /* redraw multiline inputbox and softkey */
        wgui_inputs_ml_show();
        redraw_softkey(MMI_LEFT_SOFTKEY);
        redraw_softkey(MMI_RIGHT_SOFTKEY);
        redraw_softkey(MMI_CENTER_SOFTKEY);
        
        gdi_layer_unlock_frame_buffer();
        gdi_layer_blt_previous(0, 0, MAIN_LCD_DEVICE_WIDTH, MAIN_LCD_DEVICE_HEIGHT);
    }
}


/* For detail description, please refer to wgui_categories_inputs.h */
S32 wgui_cat2002_get_cursor_index(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_wgui_cat2002_is_active_editor == MMI_FALSE)
    {
        return WGUI_CAT2002_INPUTBOX_NO_CURSOR;
    }
    else
    {
        return wgui_inputs_ml_get_cursor_index();
    }
}


/* For detail description, please refer to wgui_categories_inputs.h */
void wgui_cat2002_change_input_type(U32 input_type, mmi_imm_input_mode_enum *input_mode_array)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (input_type & IMM_INPUT_TYPE_EXT_PASSWORD)
    {
        wgui_inputs_ml_set_mask(1);
    }
    else
    {
        wgui_inputs_ml_set_mask(0);
    }

    if (g_wgui_cat2002_is_active_editor == MMI_FALSE)
    {
        return;
    }
    else
    {
        mmi_imm_set_required_mode_list(input_type & INPUT_TYPE_MASK, input_mode_array, IMM_INPUT_MODE_NONE);
        mmi_imc_connect((void *)&g_mmi_editor_hanler, mmi_input_box_msg_call_back_multiline);
        wgui_inputs_ml_set_decimal_flag(input_type);
        mmi_imc_redraw_screen_by_state();
#ifndef __MMI_FTE_SUPPORT__
        wgui_inputs_ml_redraw_input_information_bar();
#endif
    }
}


/* For detail description, please refer to wgui_categories_inputs.h */
void wgui_cat2002_stop_scroll_text(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    dm_stop_scroll_text(0);
}


#if (defined (__MMI_VIRTUAL_KEYBOARD__)) && (!defined(GUI_EDITOR_SHOW_TITLE))
#define WGUI_CAT2002_EDITOR_MIN_HEIGHT (Get_CharDisplayHeightOfAllLangAndType(MMI_medium_font.size) + 2)
static MMI_BOOL g_cat2002_has_ticker = MMI_TRUE;
/*****************************************************************************
 * FUNCTION
 *  wgui_cat2002_adjust_ticker_and_editor
 * DESCRIPTION
 *  if the height of the multiline inputbox is too small, the ticker shoule be hide.
 * PARAMETERS
 *  imui_x :                [IN] (N/A) X-axis of the input mode ui.
 *  imui_y :                [IN] (N/A) Y-axis of the input mode ui.
 *  imui_w :                [IN] (N/A) Width of the input mode ui.
 *  imui_h :                [IN] (N/A) Height of the input mode ui.
 * RETURNS
 *  U32
 *****************************************************************************/
static void wgui_cat2002_adjust_ticker_and_editor(S32 imui_x, S32 imui_y, S32 imui_w, S32 imui_h)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_coordinates ml_inputs_coordinates;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if ( imui_y < MMI_status_bar_height + wgui_inputbox_information_bar_height + MMI_SINGLELINE_INPUTBOX_HEIGHT + WGUI_CAT2002_EDITOR_MIN_HEIGHT)
    {
        /* hide ticker and move up inputbox */
        if (dm_stop_scroll_text(0) == MMI_TRUE)
        {
            g_cat2002_has_ticker = MMI_FALSE;
            gdi_layer_lock_frame_buffer();

            /* move and resize multiline inputbox */
            wgui_inputs_ml_move(MMI_COMMON_CONTENT_X, MMI_COMMON_CONTENT_Y + INFORMATION_BAR_HEIGHT);
            wgui_inputs_ml_resize(MMI_COMMON_CONTENT_WIDTH, imui_y - MMI_COMMON_CONTENT_Y - INFORMATION_BAR_HEIGHT);
            
            /* move information bar */
            wgui_inputs_setup_input_information(
                wgui_inputbox_information_bar_x,
                MMI_COMMON_CONTENT_Y,
                wgui_inputbox_information_bar_width,
                wgui_inputbox_information_bar_height);
            
            /* redraw multiline inputbox, virtual keypad and info-bar */
            wgui_inputs_ml_show();
            wgui_inputs_ml_redraw_input_information_bar();
            
            gdi_layer_unlock_frame_buffer();
            gdi_layer_blt_previous(0, 0, MAIN_LCD_DEVICE_WIDTH, MAIN_LCD_DEVICE_HEIGHT);
        }
    }
    else
    {
        /* show ticker and move down inputbox */
        if (g_cat2002_has_ticker == MMI_FALSE)
        {
            if (dm_restart_scroll_text(0) == MMI_TRUE)
            {
                g_cat2002_has_ticker = MMI_TRUE;
                gdi_layer_lock_frame_buffer();
                dm_get_control_coordinates_from_category(
                    -1,
                    MMI_CAT2002_ID,
                    DM_MULTILINE_INPUTBOX1,
                    -1,
                    &ml_inputs_coordinates);

                /* move and resize multiline inputbox */
                wgui_inputs_ml_move((S32) ml_inputs_coordinates.s16X,(S32) ml_inputs_coordinates.s16Y + INFORMATION_BAR_HEIGHT);
                wgui_inputs_ml_resize((S32) ml_inputs_coordinates.s16Width,(S32) ml_inputs_coordinates.s16Height - imui_h - INFORMATION_BAR_HEIGHT);

                /* move information bar */
                wgui_inputs_setup_input_information(
                    wgui_inputbox_information_bar_x,
                    ml_inputs_coordinates.s16Y,
                    wgui_inputbox_information_bar_width,
                    wgui_inputbox_information_bar_height);
            
                /* redraw multiline inputbox, virtual keypad and info-bar */
                wgui_inputs_ml_show();
                wgui_inputs_ml_redraw_input_information_bar();

                gdi_layer_unlock_frame_buffer();
                gdi_layer_blt_previous(0, 0, MAIN_LCD_DEVICE_WIDTH, MAIN_LCD_DEVICE_HEIGHT);
            }
        }
    }
}
#endif /* (__MMI_MAINLCD_320X240__) && (__MMI_VIRTUAL_KEYBOARD__) */

/*****************************************************************************
 * FUNCTION
 *  wgui_cat2002_ime_msg_callback
 * DESCRIPTION
 *  ime callback function
 * PARAMETERS
 *  input_box_handle :      [IN] (N/A) inputbox handle
 *  msg_ptr :               [IN] (N/A) imui size info
 * RETURNS
 *  U32
 *****************************************************************************/
static U32 wgui_cat2002_ime_msg_callback(void * input_box_handle, mmi_imc_message_struct_p msg_ptr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    multi_line_input_box * editor_ptr;
    U32 lresult = 0;
#if (defined (__MMI_VIRTUAL_KEYBOARD__)) && (!defined(GUI_EDITOR_SHOW_TITLE))
    mmi_imc_rect_p imui_rect_p;
#endif
    S32 imui;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    editor_ptr = (multi_line_input_box *)((mmi_editor_handler_struct *)input_box_handle)->input_box_handler;
    MMI_ASSERT(editor_ptr == &MMI_multiline_inputbox);
    
    switch (msg_ptr->message_id)
    {
#if (defined (__MMI_VIRTUAL_KEYBOARD__)) && (!defined(GUI_EDITOR_SHOW_TITLE))
        case MMI_IMC_MESSAGE_IMUI_RECTANGLE_IS_UPDATED:
            imui_rect_p = (mmi_imc_rect_p)(msg_ptr->param_0);
            wgui_cat2002_adjust_ticker_and_editor(imui_rect_p->x, imui_rect_p->y, imui_rect_p->width, imui_rect_p->height);
            lresult = MMI_TRUE;
            break;
#endif

        case MMI_IMC_MESSAGE_FLOATING_UI_APPEAR_INDICATION:
            g_wgui_cat2002_ui_change_flag = MMI_FALSE;
            mmi_input_box_msg_call_back_multiline(input_box_handle, msg_ptr);      
            break;
            
        case MMI_IMC_MESSAGE_REDRAW:
            imui = (S32)(msg_ptr->param_0);
            if (imui == 1)
            {
                g_wgui_cat2002_ui_change_flag = MMI_TRUE;
            }
            mmi_input_box_msg_call_back_multiline(input_box_handle, msg_ptr);
#if (defined (__MMI_VIRTUAL_KEYBOARD__)) && (!defined(GUI_EDITOR_SHOW_TITLE))
            if (g_cat2002_has_ticker == MMI_FALSE)
            {
                dm_stop_scroll_text(0);
            }
#endif
            break;

#if defined(__MMI_VIRTUAL_KEYBOARD__)
        case MMI_IMC_MESSAGE_GET_STOP_CURSOR_CALLBACK_FUNCPTR:
            lresult = (U32)wgui_cat2002_large_icon_appear_callback;
            break;

        case MMI_IMC_MESSAGE_GET_START_CURSOR_CALLBACK_FUNCPTR:
            lresult = (U32)wgui_cat2002_large_icon_disappear_callback;
            break;
#endif

        default:
            lresult = mmi_input_box_msg_call_back_multiline(input_box_handle, msg_ptr);
            break;
    }
    return lresult;
}
#endif /* __J2ME__ */


/*****************************************************************************
 * FUNCTION
 *  ExitCategory5Screen
 * DESCRIPTION
 *  Exits the category5 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitCategory5Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* only for category 171 */
    close_scrolling_title();
#ifdef __J2ME__
    if(g_wgui_cat2002_is_active_editor)
    {
        wgui_inputs_ml_close();
    }
    else
    {
        wgui_inputs_ml_reset();
        g_wgui_cat2002_is_active_editor = MMI_TRUE;
    }
    
    /* stop scroll text */
    dm_stop_scroll_text(0);

    /* changed when activate/inactivate editor */
    MMI_multiline_inputbox_y = MMI_MULTILINE_INPUTBOX_Y;
    MMI_multiline_inputbox_height = UI_DEVICE_HEIGHT;
    g_wgui_cat2002_is_in_java = MMI_FALSE;
#else /* __J2ME__ */
    wgui_inputs_ml_close();
#endif /* __J2ME__ */

#ifdef __MMI_WALLPAPER_ON_BOTTOM__
    dm_set_scr_bg_opacity(editor_scr_bg_opacity);
#endif /* __MMI_WALLPAPER_ON_BOTTOM__ */ 

#if !defined(GUI_EDITOR_SHOW_TITLE)
    g_title_in_header = 0;
#endif /* !defined(GUI_EDITOR_SHOW_TITLE) */
    wgui_cat_ml_setup_image(NULL, NULL);
    wgui_cat_ml_setup_image_res(NULL, NULL);

    g_wgui_cat_ml_image_handle = 0xFFFF;
    gui_cancel_timer(wgui_cat_ml_timer_callback);
}


/*****************************************************************************
 * FUNCTION
 *  GetCategory5History
 * DESCRIPTION
 *  Gets the history buffer for category5 screen
 * PARAMETERS
 *  history_buffer      [IN]        Is the buffer into which the history data is stored (pre-allocated)
 * RETURNS
 *  Pointer to the history buffer
 *****************************************************************************/
U8 *GetCategory5History(U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_inputs_ml_get_category_history(MMI_CATEGORY5_ID, history_buffer);
    return (history_buffer);
}

#ifdef __MMI_SMALL_EDIT_SCREEN__
/* For detail description, please refer to wgui_categories_inputs.h */
void ShowCategory100Screen_int(
        U16 title,
        U16 title_icon,
        U16 left_softkey,
        U16 right_softkey,
        U32 input_type,
        U8 *buffer,
        S32 buffer_size,
        U8 *history_buffer,
        S16 input_ext_type,
        mmi_imm_input_mode_enum *required_input_mode_set)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    color c = *current_MMI_theme->editor_small_screen_border_color;
    UI_filled_area *title_filler;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    title_filler = current_window_title_theme->active_filler;
    current_window_title_theme->active_filler = current_MMI_theme->small_screen_title_filler;
    gui_title_set_theme(&g_wgui_title_bar, current_window_title_theme);

    MMI_multiline_inputbox_x = MMI_SMALL_SCREEN_X_OFFSET;
    MMI_multiline_inputbox_y = MMI_title_y + 2 * MMI_title_height + MMI_SMALL_SCREEN_Y_OFFSET;
    MMI_multiline_inputbox_width = MMI_content_width - 2 * MMI_SMALL_SCREEN_X_OFFSET;
    MMI_multiline_inputbox_height = MMI_content_height - 2 * (MMI_SMALL_SCREEN_Y_OFFSET) - MMI_title_height + 1;
    MMI_multitap_x = MMI_SMALL_SCREEN_X_OFFSET + 1;
    MMI_multitap_y -= (MMI_SMALL_SCREEN_Y_OFFSET + 1);
	
    MMI_multitap_width = UI_DEVICE_WIDTH - 2 * (MMI_SMALL_SCREEN_X_OFFSET + 1); /* The border width is 1 */
    g_small_editor_category_present = TRUE;

#ifdef MMI_SHOW_STATUS_ICON_IN_TITLE
    wgui_status_icon_bar_enable_integrated(MMI_FALSE);
#endif
    set_small_screen();
    wgui_small_editor_information_flag = 1;
    gui_add_cleanup_hook(disable_resized_small_screen);

    wgui_status_icon_bar_reset_display(WGUI_STATUS_ICON_BAR_H_BAR);/* early status icon */

#if(UI_DOUBLE_BUFFER_SUPPORT)
    gui_lock_double_buffer();
#endif 

    wgui_title_set_menu_shortcut_number(-1);
    wgui_title_disable_menu_shortcut_display(MMI_TRUE);
    dm_add_softkey_id(left_softkey, right_softkey);

    MMI_title_string = (UI_string_type) get_string(title);

#ifdef GUI_COMMON_USE_THICK_TITLE
    MMI_title_icon = NULL;
#else
    MMI_title_icon = (PU8) get_image(title_icon); 
#endif

    wgui_inputs_ml_setup_ext(
        MMI_multiline_inputbox_x,
        MMI_multiline_inputbox_y,
        MMI_multiline_inputbox_width,
        MMI_multiline_inputbox_height,
        buffer,
        buffer_size,
        MMI_CATEGORY100_ID,
        get_string(right_softkey),
        NULL,
        input_type,
        history_buffer,
        required_input_mode_set,
    #ifdef __MMI_FTE_SUPPORT__        
        0,
    #else
        1,
    #endif
        0,
        0,
        0,
        0,
        0,
        NULL);
    
    if (input_ext_type != 0)
    {
        MMI_current_input_ext_type = input_ext_type;
    }
    if (((input_type & INPUT_TYPE_MASK) == IMM_INPUT_TYPE_NUMERIC_PASSWORD) ||
        ((input_type & INPUT_TYPE_MASK) == IMM_INPUT_TYPE_ALPHANUMERIC_PASSWORD) ||
        ((input_type & INPUT_TYPE_MASK) == IMM_INPUT_TYPE_SAT_NUMERIC_PASSWORD) ||
        ((input_type & INPUT_TYPE_MASK) == IMM_INPUT_TYPE_SIGNED_DECIMAL_NUMERIC_PASSWORD) ||
        ((input_type & INPUT_TYPE_MASK) == IMM_INPUT_TYPE_SIGNED_NUMERIC_PASSWORD))
    {
        MMI_current_input_ext_type |= INPUT_TYPE_EXT_NO_SHOW_NEW_LINE_SYMBOL;
    }

    gui_unlock_double_buffer();

    /* To fix title issue */
    gOnFullScreen = MMI_LEAVE_BG_ON_BOTTOM_SCREEN;
    
    dm_register_category_controlled_callback(mmi_imc_redraw_screen_by_state);
    dm_add_rectangle(c, DM_RECTANGLE_FILL_GRAYSCALE);
    dm_add_rectangle(c, 0);
    wgui_cat_setup_category_default_history(MMI_CATEGORY100_ID, DM_NO_POPUP_BACKGROUND, ExitCategory100Screen);

    dm_redraw_category_screen();

    current_window_title_theme->active_filler = title_filler;
    gui_title_set_theme(&g_wgui_title_bar, current_window_title_theme);
}


/*****************************************************************************
 * FUNCTION
 *  ExitCategory100Screen
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitCategory100Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_multiline_inputbox_x = MMI_MULTILINE_INPUTBOX_X;
    MMI_multiline_inputbox_y = MMI_MULTILINE_INPUTBOX_Y;
    MMI_multiline_inputbox_height = UI_DEVICE_HEIGHT;
    MMI_multiline_inputbox_width = UI_DEVICE_WIDTH;
    wgui_small_editor_information_flag = 0;
    MMI_multitap_x = MMI_MULTITAP_X;
    MMI_multitap_y = (UI_device_height - MMI_BUTTON_BAR_HEIGHT - MMI_multitap_height);/* MMI_MULTITAP_Y*/;
    MMI_multitap_width = UI_device_width - 4;

    g_small_editor_category_present = FALSE;

    reset_small_screen();

#if (__MMI_UI_FADE_EFFECT_STYLE__ == MMI_UI_FADE_EFFECT_STYLE_DARKEN)
    {
        S32 x1 = MMI_SMALL_SCREEN_X_OFFSET;
        S32 y1 = MMI_COMMON_TITLE_Y + MMI_COMMON_TITLE_HEIGHT + MMI_SMALL_SCREEN_Y_OFFSET;
        S32 x2 = MMI_COMMON_CONTENT_WIDTH - MMI_SMALL_SCREEN_X_OFFSET;
        S32 y2 = MMI_COMMON_TITLE_Y + MMI_COMMON_TITLE_HEIGHT + MMI_COMMON_CONTENT_HEIGHT - MMI_SMALL_SCREEN_Y_OFFSET;
        gdi_handle ative_layer;
        
        gdi_layer_set_clip(x1, y1, x2, y2);
        gdi_layer_get_active(&ative_layer);
        gdi_layer_flatten_with_clipping(ative_layer, 0, 0, 0);
        gdi_draw_darken_rect(x1, y1, x2, y2, 75);
    }
#endif

    title_bg_id = 0;

    wgui_inputs_ml_close();
}
#endif /* __MMI_SMALL_EDIT_SCREEN__ */ 


/* For detail description, please refer to wgui_categories_inputs.h */
void ShowCategory171Screen_int(
        U8 *left_softkey,
        U8 *right_softkey,
        U8 *message,
        PU8 message_icon,
        U32 input_type,
        U8 *buffer,
        S32 buffer_size,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_cat_ml_inputbox_show_internal(
            (UI_string_type)message,
            message_icon,
            (UI_string_type)left_softkey,
            (UI_string_type)right_softkey,
            NULL,
            input_type,
            buffer,
            buffer_size,
            history_buffer,
            0,
            NULL,
            MMI_TRUE,
            MMI_FALSE,
            MMI_CATEGORY171_ID);
#if 0    
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#if(UI_DOUBLE_BUFFER_SUPPORT)
/* under construction !*/
#endif 
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #ifdef __MMI_FTE_SUPPORT__        
/* under construction !*/
    #else
/* under construction !*/
    #endif
/* under construction !*/
#if defined(__MMI_MAINLCD_128X64__)
#if !defined(GUI_EDITOR_SHOW_TITLE)
/* under construction !*/
/* under construction !*/
#endif /* GUI_EDITOR_SHOW_TITLE */
#endif /* (__MMI_MAINLCD_128X64__) */
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#ifdef __MMI_WALLPAPER_ON_BOTTOM__
/* under construction !*/
/* under construction !*/
#endif /* __MMI_WALLPAPER_ON_BOTTOM__ */ 
/* under construction !*/
#if(UI_DOUBLE_BUFFER_SUPPORT)
/* under construction !*/
#endif 
/* under construction !*/
#if defined(__MMI_MAINLCD_128X64__)
/* under construction !*/
#else /* __MMI_MAINLCD_128X64__ */
/* under construction !*/
#endif /* __MMI_MAINLCD_128X64__ */
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif    
}


#if defined(__MMI_WCSS_INPUT_FORMAT_SUPPORT__)
U8 *cat115buffer;

/* Return The Input Mode Respect To The Input Method Passed By User. */
mmi_imm_input_mode_enum wgui_wcss_alphabetic_uppercase_method[] = {IMM_INPUT_MODE_MULTITAP_UPPERCASE_ABC_NO_NUMERIC, IMM_INPUT_MODE_NONE};
mmi_imm_input_mode_enum wgui_wcss_alphabetic_lowercase_method[] = {IMM_INPUT_MODE_MULTITAP_LOWERCASE_ABC_NO_NUMERIC, IMM_INPUT_MODE_NONE};

/*****************************************************************************
 * FUNCTION
 *  WCSS_check_input_method
 * DESCRIPTION
 *  
 * PARAMETERS
 *  s       [?]     
 * RETURNS
 *  
 *****************************************************************************/
static U32 WCSS_check_input_method(U8 *s, mmi_imm_input_mode_enum **input_mode_array)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (s[0] & 0x1F)
    {
        case IMM_INPUT_MODE_MULTITAP_UPPERCASE_ABC_NO_NUMERIC:
            *input_mode_array = wgui_wcss_alphabetic_uppercase_method;
            return (IMM_INPUT_TYPE_USER_SPECIFIC | IMM_INPUT_TYPE_EXT_ENGLISH_UPPERCASE);
        case IMM_INPUT_MODE_MULTITAP_LOWERCASE_ABC_NO_NUMERIC:
            *input_mode_array = wgui_wcss_alphabetic_lowercase_method;
            return IMM_INPUT_TYPE_USER_SPECIFIC;
        case IMM_INPUT_MODE_MULTITAP_UPPERCASE_ABC:
            return IMM_INPUT_TYPE_ENGLISH_SENTENCE_UPPERCASE;
        case IMM_INPUT_MODE_MULTITAP_LOWERCASE_ABC:
            return IMM_INPUT_TYPE_ENGLISH_SENTENCE_LOWERCASE;
        case IMM_INPUT_MODE_123:
            return IMM_INPUT_TYPE_NUMERIC;
        case IMM_INPUT_MODE_123_SYMBOLS:
            return IMM_INPUT_TYPE_NUMERIC_SYMBOL;
        default:
            return IMM_INPUT_TYPE_SENTENCE;
    }
    
}


///TODO: Should be replaced by wgui_inputs_category_set_rsk_func(..), sync with app.
/*****************************************************************************
 * FUNCTION
 *  SetCategory115RightSoftkeyFunction
 * DESCRIPTION
 *  
 * PARAMETERS
 *  f       [IN]        
 *  k       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void SetCategory115RightSoftkeyFunction(void (*f) (void), MMI_key_event_type k)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    SetCategory5RightSoftkeyFunction(f, k);
}


/*****************************************************************************
 * FUNCTION
 *  ExitCategory115Screen
 * DESCRIPTION
 *  Exits the category5 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitCategory115Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Reference: ExitCategory5Screen() */
    wgui_inputs_ml_close();
    clear_key_input_handler();  /* Key input handler was registered before */

    if (cat115buffer != NULL)
    {
        gui_free(cat115buffer);
        cat115buffer = NULL;
    }
}


/*****************************************************************************
 * FUNCTION
 *  ShowCategory115Screen_ext
 * DESCRIPTION
 *  Displays the category115 screen (WCSS editor)
 * PARAMETERS
 *  title                   [IN]        Title for the screen
 *  title_icon              [IN]        Icon shown with the title
 *  left_softkey            [IN]        Left softkey label
 *  left_softkey_icon       [IN]        Icon for the left softkey
 *  right_softkey           [IN]        Right softkey label
 *  right_softkey_icon      [IN]        Icon for the right softkey
 *  buffer                  [IN]        Buffer the input box should use.
 *  buffer_size             [IN]        UCS2 character count including '\0'
 *  input_format            [IN]        WAP input-format
 *  input_required          [IN]        Unused
 *  input_type              [IN]        input type
 *  history_buffer          [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/
/*
 * Note: We do not handle Chinese input in ShowCategory115Screen to simplify the design.
 * * "*m" and "*M" is already handled in WAP. and "nnn*M" will only allow three digits, and 
 * * any number of western characters.
 */
void ShowCategory115Screen_ext_int(
        U16 title,
        U16 title_icon,
        U16 left_softkey,
        U16 right_softkey,
        U8 *buffer,
        S32 buffer_size,
        U8 *input_format,
        U8 input_required,
        U32 input_type,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    /* Reference: ShowCategory5Screen() */
    S32 inputbox_height = MMI_content_height;

    S8 input_format_status = 0;
    S32 format_length;
	mmi_imm_input_mode_enum *input_method_array = NULL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_setup_common_layout();
    
    if (buffer_size > CAT115_MAXSIZE)   /* Maximum input char = CAT115_MAXSIZE - 1 */
    {
        buffer_size = CAT115_MAXSIZE;
    }

    format_length = get_category_115_format_buffer_length(input_format, buffer_size);

    if (format_length == -1)
    {
        /* Use as normat category 5. */
        input_format_status = (S8) (-1);
    }
    else if (format_length == 0)
    {
        /* Leave buffer_size unchanged */
    }
    else if (format_length < buffer_size)
    {
        /* Set the buffer length to the upper bound derived from input format */
        buffer_size = format_length + 1;
    }
    else if (format_length >= buffer_size)
    {
        /* Act as Category 5 */
        input_format_status = (S8) (-1);
    }
    if (input_format_status != (S8)(-1))
    {
        /* Allocate fixed size of control buffer bucket because the size is controlled by
           external web pages; otherwise, it might exhaust some kind of control buffer */
        cat115buffer = gui_malloc(CAT115_MAXSIZE);
        if (gui_parse_WCSS_string
            ((U8*) input_format, (U8*) buffer, (U8*) cat115buffer, (S16) buffer_size,
             (U8) ((history_buffer || buffer[0] || buffer[1]) ? 1 : 0)) != 0)
        {
            input_format_status = (S8) (-1);    /* In this case the editor will works as normal text editor. */
        }
    }

    if (input_format_status != (S8)(-1))
    {
        extern void gui_reset_WCSS_cursor_position(void);

        /* Use INPUT_TYPE_OVERRIDE_DEFAULT to prevent overriden by default input method, which might be chinese input method (unsupported) */
        if ((input_type & INPUT_TYPE_MASK) != IMM_INPUT_TYPE_NUMERIC_PASSWORD && 
            (input_type & INPUT_TYPE_MASK) != IMM_INPUT_TYPE_ALPHANUMERIC_PASSWORD)
        {
            input_type = WCSS_check_input_method(cat115buffer, &input_method_array) /*| INPUT_TYPE_OVERRIDE_DEFAULT*/;
        }

        is_fisrt_entry_WCSS_editor = MMI_TRUE;
        gui_reset_WCSS_cursor_position();
    }

#if(UI_DOUBLE_BUFFER_SUPPORT)
    gui_lock_double_buffer();
#endif 

    wgui_title_set_menu_shortcut_number(-1);
    wgui_title_disable_menu_shortcut_display(MMI_TRUE);
    
    dm_add_title_id(title, title_icon);
    dm_add_softkey_id(left_softkey, right_softkey);

    wgui_inputs_ml_setup_ext(
        0,
        (MMI_title_y + MMI_title_height),
        MMI_content_width,
        inputbox_height,
        buffer,
        buffer_size,
        MMI_CATEGORY5_ID,
        get_string(right_softkey),
        NULL,
        input_type,
        history_buffer,
        input_method_array,
    #ifdef __MMI_FTE_SUPPORT__        
        0,
    #else
        1,
    #endif
        0,
        0,
        0,
        0,
        0,
        NULL);
    
    wgui_inputs_ml_set_common_style(MMI_TRUE, MMI_TRUE);

    MMI_current_input_ext_type |= INPUT_TYPE_EXT_NO_SHOW_NEW_LINE_SYMBOL;

    if (input_format_status != (S8)(-1))
    {
        /* Disable word-wrapping for WCSS editor */
        wgui_inputs_ml_set_style((UI_MULTI_LINE_INPUT_BOX_OVERWRITE_MODE |
                                  UI_MULTI_LINE_WCSS_INPUT_BOX_ENABLE |
                                  UI_MULTI_LINE_INPUT_BOX_DISABLE_WRAPPING_BY_WORD),
                                  0);
    }

#if(UI_DOUBLE_BUFFER_SUPPORT)
    gui_unlock_double_buffer();
#endif 

    if (input_format_status != (S8)(-1) && history_buffer == NULL)
    {
        /* We hope to edit from the beginning even with default input values, 
           and we just configured the input format for the first character */
        wgui_inputs_ml_move_cursor_to_start();
    }

#if !defined(GUI_EDITOR_SHOW_TITLE)
    wgui_cat_setup_category_default_history(MMI_CATEGORY5_ID, DM_CLEAR_SCREEN_BACKGROUND | DM_SHOW_VKPAD | DM_NO_TITLE, ExitCategory115Screen);
#else
    wgui_cat_setup_category_default_history(MMI_CATEGORY5_ID, DM_CLEAR_SCREEN_BACKGROUND | DM_SHOW_VKPAD, ExitCategory115Screen);
#endif /* !defined(GUI_EDITOR_SHOW_TITLE) */

    dm_register_vkpad_callback(mmi_imc_redraw_screen_by_state);
    dm_redraw_category_screen();

}


/* For detail description, please refer to wgui_categories_inputs.h */
void ShowCategory115ScreenEx_int(
        U16 title,
        U16 title_icon,
        U16 left_softkey,
        U16 right_softkey,
        U8 *buffer,
        S32 buffer_size,
        S16 *predefined_pos,
        void (*cursor_move_callback)(S32 cursor_offset),
        MMI_BOOL (*change_event_handler)(gui_multi_line_input_box_change_event_enum event,U16 c),
        U32 input_type,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                                                         */
    /*----------------------------------------------------------------*/
    S32 inputbox_height = MMI_content_height;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (buffer_size > CAT115_MAXSIZE)   /* Maximum input char = CAT115_MAXSIZE - 1 */
    {
        buffer_size = CAT115_MAXSIZE;
    }

#if(UI_DOUBLE_BUFFER_SUPPORT)
    gui_lock_double_buffer();
#endif 

    wgui_title_set_menu_shortcut_number(-1);
    wgui_title_disable_menu_shortcut_display(MMI_TRUE);

    dm_add_title_id(title, title_icon);
    dm_add_softkey_id(left_softkey, right_softkey);

    wgui_inputs_ml_setup(
        0,
        (MMI_title_y + MMI_title_height),
        MMI_content_width,
        inputbox_height,
        buffer,
        buffer_size,
        MMI_CATEGORY5_ID,
        get_string(right_softkey),
        NULL,
        input_type,
        history_buffer,
    #ifdef __MMI_FTE_SUPPORT__        
        0
    #else
        1
    #endif
        );
    MMI_current_input_ext_type |= INPUT_TYPE_EXT_NO_SHOW_NEW_LINE_SYMBOL;

    wgui_inputs_ml_set_common_style(MMI_TRUE, MMI_TRUE);

    if (predefined_pos != NULL)
    {
        /* Disable word-wrapping for WCSS editor */
        wgui_inputs_ml_set_style((UI_MULTI_LINE_INPUT_BOX_OVERWRITE_MODE |
                                  UI_MULTI_LINE_INPUT_BOX_DISABLE_WRAPPING_BY_WORD),
                                  0);
        wgui_inputs_ml_set_predefine_pos_info(predefined_pos, cursor_move_callback, change_event_handler);
    }

    if (history_buffer == NULL)
    {
        /* We hope to edit from the beginning even with default input values, 
           and we just configured the input format for the first character */
        wgui_inputs_ml_move_cursor_to_start();
    }

#if(UI_DOUBLE_BUFFER_SUPPORT)
    gui_unlock_double_buffer();
#endif 

#if !defined(GUI_EDITOR_SHOW_TITLE)
    wgui_cat_setup_category_default_history(MMI_CATEGORY5_ID, DM_CLEAR_SCREEN_BACKGROUND | DM_SHOW_VKPAD | DM_NO_TITLE, ExitCategory115Screen);
#else
    wgui_cat_setup_category_default_history(MMI_CATEGORY5_ID, DM_CLEAR_SCREEN_BACKGROUND | DM_SHOW_VKPAD, ExitCategory115Screen);
#endif /* !defined(GUI_EDITOR_SHOW_TITLE) */

    dm_register_vkpad_callback(mmi_imc_redraw_screen_by_state);
    dm_redraw_category_screen();
}
#endif /* defined(__MMI_WCSS_INPUT_FORMAT_SUPPORT__) */ 


#if defined(__MMI_SMART_MESSAGE_MO__) && !defined(__MMI_MESSAGES_EMS__)
/*****************************************************************************
 * FUNCTION
 *  mmi_nsm2_get_remaining_len
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
S32 mmi_nsm2_get_remaining_len(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_nsm_msg_context.UCS2_count > 0)
    {
        if (g_nsm_msg_context.is_picmsg == TRUE)
        {
            /* 64 */
            g_nsm_msg_context.remaining_length = (MAX_PICMSG_UCS2_DCS_TEXT_LEN) + 1;
        }
        else
        {
            /* 306 */
            g_nsm_msg_context.remaining_length = (UCS2_DCS_ALLOCATED_LENGTH) + 1;
        }
    }
    else    /* No UCS Character */
    {
        if (g_nsm_msg_context.is_picmsg == TRUE)
        {
            /* 128 */
            g_nsm_msg_context.remaining_length = (MAX_PICMSG_DEFAULT_DCS_TEXT_LEN) + 1;
        }
        else
        {
            /* 612 */
            g_nsm_msg_context.remaining_length = (DEFAULT_DCS_ALLOCATED_LENGTH) + 1;
        }
    }

    return (g_nsm_msg_context.remaining_length * 2);
}
#endif /* defined(__MMI_SMART_MESSAGE_MO__) && !defined(__MMI_MESSAGES_EMS__) */ 


#ifdef UI_EMS_SUPPORT
/*****************************************************************************
 * FUNCTION
 *  SetCategory28RightSoftkeyFunction
 * DESCRIPTION
 *  
 * PARAMETERS
 *  f       [IN]        
 *  k       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void SetCategory28RightSoftkeyFunction(void (*f) (void), MMI_key_event_type k)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(k);
    category28_RSK_function = f;
#ifdef __MMI_MSG_EDITOR_WITH_RECIPIENT__
    wgui_singleline_inputbox_RSK_function = f;
#endif /* __MMI_MSG_EDITOR_WITH_RECIPIENT__ */
}


/*****************************************************************************
 * FUNCTION
 *  handle_category28_right_softkey_down
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void handle_category28_right_softkey_down(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if(UI_DISABLE_EMS_INPUT_BOX)
    if (!wgui_inputs_ml_is_empty())
    {
        wgui_inputs_ml_delete_character();
    }
    else    
#else /* (UI_DISABLE_EMS_INPUT_BOX) */ 
    if (!gui_EMS_inputbox_empty(&MMI_EMS_inputbox))
    {
        EMS_inputbox_backspace();
    }
    else    
#endif /* (UI_DISABLE_EMS_INPUT_BOX) */ 
    {
        UI_editor_play_tone_cannot_change(); 
    }
}


/*****************************************************************************
 * FUNCTION
 *  handle_category28_right_softkey_up
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void handle_category28_right_softkey_up(void)
{
#if(UI_DISABLE_EMS_INPUT_BOX)
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if ((wgui_inputs_ml_is_empty()) && (!category28_RSK_label_clear))
    {
        if (category28_RSK_function != NULL)
        {
            category28_RSK_function();
        }
    }
#else /* (UI_DISABLE_EMS_INPUT_BOX) */ 
    if (category28_RSK_function != NULL)
    {
        category28_RSK_function();
    }
#endif /* (UI_DISABLE_EMS_INPUT_BOX) */ 
}


/*****************************************************************************
 * FUNCTION
 *  register_category28_handle_right_softkey_up
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void register_category28_handle_right_softkey_up(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    set_right_softkey_function(handle_category28_right_softkey_up, KEY_EVENT_UP);
}



/*****************************************************************************
 * FUNCTION
 *  handle_category28_right_softkey_long_press
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void handle_category28_right_softkey_long_press(void)
{
#if(UI_DISABLE_EMS_INPUT_BOX)
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_wgui_inputs_repeat_count = 0;
    if (mmi_frm_kbd_is_key_supported(KEY_CLEAR))
    {
        SetKeyHandler(wgui_inputs_ml_handle_right_softkey_repeat, KEY_CLEAR, KEY_REPEAT);
    }
    else
    {
        set_right_softkey_function(wgui_inputs_ml_handle_right_softkey_touch_repeat, KEY_REPEAT);
        SetKeyHandler(wgui_inputs_ml_handle_right_softkey_repeat, KEY_RSK, KEY_REPEAT);
    }    

#else /* (UI_DISABLE_EMS_INPUT_BOX) */

    g_wgui_inputs_repeat_count = 0;
    if (mmi_frm_kbd_is_key_supported(KEY_CLEAR))
    {
        SetKeyHandler(wgui_inputs_EMS_handle_right_softkey_repeat, KEY_CLEAR, KEY_REPEAT);
    }
    else
    {
        set_right_softkey_function(wgui_inputs_EMS_handle_right_softkey_touch_repeat, KEY_REPEAT);
        SetKeyHandler(wgui_inputs_EMS_handle_right_softkey_repeat, KEY_RSK, KEY_REPEAT);
    }

#endif /* (UI_DISABLE_EMS_INPUT_BOX) */ 
}


/*****************************************************************************
 * FUNCTION
 *  handle_category28_input_no_show_counter
 * DESCRIPTION
 *  handle input but not show the counter
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void handle_category28_input_no_show_counter(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EMS_inputbox_has_changed = 1;
#if(UI_DISABLE_EMS_INPUT_BOX)
    if (!wgui_inputs_ml_is_empty())
    {
        if (mmi_frm_kbd_is_key_supported(KEY_CLEAR) == MMI_FALSE)
        {
            if (category28_RSK_label_clear == 0)
            {
                set_right_softkey_label((UI_string_type) get_string(STR_GLOBAL_CLEAR));
                set_right_softkey_icon(NULL);
                redraw_right_softkey();
                category28_RSK_label_clear = 1;
                set_right_softkey_function(UI_dummy_function, KEY_EVENT_UP);
            }
        }
    }
    else
    {
        if (mmi_frm_kbd_is_key_supported(KEY_CLEAR) == MMI_FALSE)
        {
            if (category28_RSK_label_clear == 1)
            {
                set_right_softkey_label(category28_RSK_label_string);
                set_right_softkey_icon(category28_RSK_label_icon);
                redraw_right_softkey();
                category28_RSK_label_clear = 0;
                set_right_softkey_function(register_category28_handle_right_softkey_up, KEY_EVENT_DOWN);
            }
        }
    }
#else /* (UI_DISABLE_EMS_INPUT_BOX) */ 
    if (MMI_EMS_inputbox.data == NULL)
    {
        return;
    }
    if (!gui_EMS_inputbox_empty(&MMI_EMS_inputbox))
    {
        if (mmi_frm_kbd_is_key_supported(KEY_CLEAR) == MMI_TRUE)
        {
            if (category28_RSK_label_clear == 0)
            {
                category28_RSK_label_clear = 1;
                SetKeyHandler(handle_category28_right_softkey_down, KEY_CLEAR, KEY_EVENT_DOWN);
                SetKeyHandler(handle_category28_right_softkey_down, KEY_CLEAR, KEY_REPEAT);
                SetKeyHandler(UI_dummy_function, KEY_CLEAR, KEY_EVENT_UP);
                SetKeyHandler(handle_category28_right_softkey_long_press, KEY_CLEAR, KEY_LONG_PRESS);
            }
        }
        else
        {
            if (category28_RSK_label_clear == 0)
            {
                set_right_softkey_label((UI_string_type) get_string(STR_GLOBAL_CLEAR));
                set_right_softkey_icon(NULL);
                redraw_right_softkey();
                category28_RSK_label_clear = 1;
                set_right_softkey_function(handle_category28_right_softkey_down, KEY_EVENT_DOWN);
                set_right_softkey_function(handle_category28_right_softkey_long_press, KEY_LONG_PRESS);
                set_right_softkey_function(NULL, KEY_EVENT_UP);
            }
        }

    }
    else
    {
        if (mmi_frm_kbd_is_key_supported(KEY_CLEAR) == MMI_TRUE)
        {
            if (category28_RSK_label_clear == 1)
            {
                category28_RSK_label_clear = 0;
                SetKeyHandler(handle_category28_right_softkey_down, KEY_CLEAR, KEY_EVENT_DOWN);
                SetKeyHandler(UI_dummy_function, KEY_CLEAR, KEY_REPEAT);
                SetKeyHandler(UI_dummy_function, KEY_CLEAR, KEY_EVENT_UP);
                SetKeyHandler(UI_dummy_function, KEY_CLEAR, KEY_LONG_PRESS);
            }
        }
        else
        {
            if (category28_RSK_label_clear == 1)
            {
                set_right_softkey_label(category28_RSK_label_string);
                set_right_softkey_icon(category28_RSK_label_icon);
                redraw_right_softkey();
                category28_RSK_label_clear = 0;
                set_right_softkey_function(register_category28_handle_right_softkey_up, KEY_EVENT_DOWN);
            }
            else
            {
                set_right_softkey_label(category28_RSK_label_string);
                set_right_softkey_icon(category28_RSK_label_icon);
                redraw_right_softkey();
            }
        }
    }

#ifdef __OP01_FWPBW__
    wgui_inputs_show_current_input_method_timer_handler();
#endif

#endif /* (UI_DISABLE_EMS_INPUT_BOX) */ 
}


/*****************************************************************************
 * FUNCTION
 *  handle_category28_input
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void handle_category28_input(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    handle_category28_input_no_show_counter();
#ifdef __OP01_FWPBW__
    wgui_EMS_redraw_remaining_characters_display();
#endif
}


/*****************************************************************************
 * FUNCTION
 *  cat28_virtual_keypad_callback
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void cat28_virtual_keypad_callback(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(__MMI_TOUCH_SCREEN__)
    mmi_imc_redraw_screen_by_state();
#endif 
}


/*****************************************************************************
 * FUNCTION
 *  category28callback
 * DESCRIPTION
 *  
 * PARAMETERS
 *  coordinate      [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void category28callback(dm_coordinates *coordinate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (RedrawSpellingOrCandidateBoxesFunction)
    {
        RedrawSpellingOrCandidateBoxesFunction();
    }
}


/*****************************************************************************
 * FUNCTION
 *  AppendCategory28String
 * DESCRIPTION
 *  
 * PARAMETERS
 *  input_type          [IN]        
 *  data                [?]         
 *  s                   [?]         
 *  history_buffer      [?]         
 * RETURNS
 *  
 *****************************************************************************/
U8 AppendCategory28String(U32 input_type, EMSData *data, U8 *s, U8 *history_buffer)
{
#if(!UI_DISABLE_EMS_INPUT_BOX)
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 success = 1;
#ifdef __MMI_MENUTREE_2__
    S32 j = 0;
#endif 
    S32 box_height;
    U8 h;
    mmi_imc_history temp_ime_history;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

#ifdef __MMI_INDIC_ALG__
    add_template_ems_flag=1;
#endif /* __MMI_INDIC_ALG__ */


#if(UI_DOUBLE_BUFFER_SUPPORT)
    gui_lock_double_buffer();
#endif 

#ifdef __MMI_MSG_EDITOR_WITH_RECIPIENT__
    /* move cursor to the end */
    if (history_buffer)
    {
        wgui_cat28_history_cntx *h;
        S32 ems_size ,sl_size;

        ems_size = sizeof(EMS_inputbox_category_history);
        ems_size = (ems_size + 3) / 4;
        ems_size *= 4;

        sl_size = sizeof(singleline_inputbox_category_history);
        sl_size = (sl_size + 3) / 4;
        sl_size *= 4;
        
        h = (wgui_cat28_history_cntx*)(history_buffer + ems_size + sl_size);
        
        if (h->highlight_state == WGUI_CAT28_RECIPIENTS)
        {
            wgui_inputs_EMS_move_cursor(WGUI_INPUTS_CURSOR_POS_END);
        }
    }
#endif /* __MMI_MSG_EDITOR_WITH_RECIPIENT__ */

    //l = gui_strlen((UI_string_type) s);
    box_height = MMI_content_height - MMI_multitap_height - 10;
    gui_create_EMS_input_box(&MMI_EMS_inputbox, 0, (MMI_title_y + MMI_title_height) + 12, UI_device_width, box_height);
    gui_set_EMS_input_box_data(&MMI_EMS_inputbox, data);

    memcpy(&temp_ime_history, &(((EMS_inputbox_category_history*)history_buffer)->ime_history), sizeof(mmi_imc_history));

#ifdef __ATV_SMS_SUPPORT__
    if(dm_is_fixed_layer_mode_enabled())
    {
        h = set_EMS_inputbox_category_history(MMI_CAT9006_ID, history_buffer);
    }
    else
#endif
    {
        h = set_EMS_inputbox_category_history(MMI_CATEGORY28_ID, history_buffer);
    }

    if (h)
    {
        gui_EMS_input_box_locate_cursor(&MMI_EMS_inputbox);
    #ifdef __MMI_MESSAGES_EMS__
        gui_EMS_input_box_set_text_format_object(&MMI_EMS_inputbox, &wgui_EMS_text_format);
    #endif 
    }
    MMI_EMS_inputbox.flags |= UI_EMS_INPUT_BOX_DISABLE_DRAW;
    gui_show_EMS_input_box(&MMI_EMS_inputbox);
    MMI_EMS_inputbox.flags &= ~UI_EMS_INPUT_BOX_DISABLE_DRAW;

    if (gui_EMS_input_box_add_whole_string(&MMI_EMS_inputbox, s, &MMI_EMS_inputbox.text_format) != EMS_OK)
    {
        success = 0;
    }
    

#ifdef __MMI_INDIC_ALG__
	/*This function call is to reset the offset of the objects after the  */
    /*the template has been added                                         */      
    gui_EMS_post_template_addition_adjustment(&MMI_EMS_inputbox);
	gui_EMS_input_box_locate_cursor(&MMI_EMS_inputbox);
    add_template_ems_flag=0;
#endif /* __MMI_INDIC_ALG__ */

#ifdef __ATV_SMS_SUPPORT__
    if(dm_is_fixed_layer_mode_enabled())
    {
        get_EMS_inputbox_category_history(MMI_CAT9006_ID, history_buffer);
    }
    else
#endif
    {
        get_EMS_inputbox_category_history(MMI_CATEGORY28_ID, history_buffer);
    }

#if defined(__MMI_IME_AUTO_CAPITALIZATION__)
    temp_ime_history.skip_auto_cap_first_filter = MMI_TRUE;
#endif

    memcpy(&(((EMS_inputbox_category_history*)history_buffer)->ime_history), &temp_ime_history, sizeof(mmi_imc_history));

#ifdef __MMI_MSG_EDITOR_WITH_RECIPIENT__
    /* move highlight to editor */
    if (history_buffer)
    {
        wgui_cat28_history_cntx *h;
        S32 ems_size ,sl_size;

        ems_size = sizeof(EMS_inputbox_category_history);
        ems_size = (ems_size + 3) / 4;
        ems_size *= 4;

        sl_size = sizeof(singleline_inputbox_category_history);
        sl_size = (sl_size + 3) / 4;
        sl_size *= 4;
        
        h = (wgui_cat28_history_cntx*)(history_buffer + ems_size + sl_size);
        h->highlight_state = WGUI_CAT28_EDITOR;
        h->highlight_index = -1;
    }

    g_wgui_cat28_add_recipients_in_BG = MMI_TRUE;
    g_wgui_cat28_cntx.highlight_state = WGUI_CAT28_EDITOR;
    g_wgui_cat28_cntx.highlight_index = -1;

#endif /* __MMI_MSG_EDITOR_WITH_RECIPIENT__ */

#if(UI_DOUBLE_BUFFER_SUPPORT)
    gui_unlock_double_buffer();
#endif 
    if (success)
    {
        return (1);
    }
    else
    {
        return (0);
    }
#else /* (!UI_DISABLE_EMS_INPUT_BOX) */ 
    UI_UNUSED_PARAMETER(input_type);
    UI_UNUSED_PARAMETER(data);
    UI_UNUSED_PARAMETER(s);
    UI_UNUSED_PARAMETER(history_buffer);
    return (0);
#endif /* (!UI_DISABLE_EMS_INPUT_BOX) */ 
}


#ifdef __MMI_MSG_EDITOR_WITH_RECIPIENT__
/*****************************************************************************
 * FUNCTION
 *  wgui_cat28_highlight_to_content
 * DESCRIPTION
 *  adjust the highlight in background.
 * PARAMETERS
 *  history_buffer      [IN/OUT]     
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat28_highlight_to_content(U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* move highlight to editor */
    if (history_buffer)
    {
        wgui_cat28_history_cntx *h;
        S32 ems_size ,sl_size;

        ems_size = sizeof(EMS_inputbox_category_history);
        ems_size = (ems_size + 3) / 4;
        ems_size *= 4;

        sl_size = sizeof(singleline_inputbox_category_history);
        sl_size = (sl_size + 3) / 4;
        sl_size *= 4;
        
        h = (wgui_cat28_history_cntx*)(history_buffer + ems_size + sl_size);

        if (h->highlight_state == WGUI_CAT28_RECIPIENTS)
        {
            wgui_inputs_EMS_move_cursor(WGUI_INPUTS_CURSOR_POS_END);
        }

        h->highlight_state = WGUI_CAT28_EDITOR;
        h->highlight_index = -1;
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat28_get_recipients_num
 * DESCRIPTION
 *  get the recipients number.
 * PARAMETERS
 *  void
 * RETURNS
 *  S32   return the recipients number.
 *****************************************************************************/
S32 wgui_cat28_get_recipients_num(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i = 0;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (i = 0; ((i < g_wgui_cat28_cntx.max_recipients_num) && (g_wgui_cat28_cntx.recipient[i].is_valid == MMI_TRUE)); i++);
    return i;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat28_get_highlight_index
 * DESCRIPTION
 *  get the highlight recipients index.
 * PARAMETERS
 *  void
 * RETURNS
 *  S32   return the recipients number.
 *****************************************************************************/
S32 wgui_cat28_get_highlight_index(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i = 0;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (i = 0; (i < g_wgui_cat28_cntx.max_recipients_num); i++)
    {
        if ((g_wgui_cat28_cntx.recipient[i].is_valid == MMI_TRUE) && (g_wgui_cat28_cntx.recipient[i].editor_flags & WGUI_CAT28_HIGHLIGHT_RECIPIENT))
        {
            return i;
        }
    }
    return -1;
}

/* For detail description, please refer to wgui_categories_inputs.h */
void wgui_cat28_initialize_recipients(
        wgui_cat28_recipients_struct recipient[],
        S32 max_recipients_num,
        S32 buffer_size,
        U32 input_type,
        wgui_cat28_recipients_label_struct *label,
        wgui_cat28_region_id_enum highlight_state,
        wgui_cat28_highlight_handler highlight_handler,
        wgui_cat28_add_recipient_handler add_recipient_handler,
        wgui_cat28_remove_recipient_handler remove_recipient_handler)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i = 0;
    MMI_BOOL has_invalid = MMI_FALSE;
    S32 lab_w = 0, lab_h = 0;
    S32 highlight_index;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT((max_recipients_num > 0) && (max_recipients_num <= WGUI_CAT28_RECIPIENTS_MAX_NUM));
    MMI_ASSERT(label != NULL);
    MMI_ASSERT(recipient != NULL);

    highlight_index = g_wgui_cat28_cntx.highlight_index;
    memset(&g_wgui_cat28_cntx, 0, sizeof(wgui_cat28_context_struct));
    g_wgui_cat28_cntx.highlight_index = highlight_index;
    
    /* setup recipients information */
    //memcpy(&g_wgui_cat28_cntx.recipient, recipient, (sizeof(wgui_cat28_recipients_struct) * max_recipients_num));
    g_wgui_cat28_cntx.recipient = recipient;

    /* check the buffer */
    for (i = 0; i < max_recipients_num; i++)
    {
        if (g_wgui_cat28_cntx.recipient[i].is_valid == MMI_FALSE)
        {
            has_invalid = MMI_TRUE;
        }
        else
        {
            if (has_invalid == MMI_TRUE)
            {
                MMI_ASSERT(0);
            }
        }
    }

    /* setup label */
    memcpy(&g_wgui_cat28_cntx.recipients_label, label, sizeof(wgui_cat28_recipients_label_struct));
    gui_measure_image(g_wgui_cat28_cntx.recipients_label.label_normal_image, &lab_w, &lab_h);
    g_wgui_cat28_cntx.max_label_width = lab_w;
    //MMI_ASSERT(lab_h < WGUI_CAT28_INLINE_SL_HEIGHT);

    g_wgui_cat28_cntx.inline_recipients = MMI_TRUE;
    g_wgui_cat28_cntx.max_recipients_num = max_recipients_num;
    g_wgui_cat28_cntx.recipient_buffer_size = buffer_size;
    g_wgui_cat28_cntx.recipient_input_type = input_type;
    g_wgui_cat28_cntx.highlight_state = highlight_state;
    g_wgui_cat28_cntx.highlight_handler = highlight_handler;
    g_wgui_cat28_cntx.add_recipient_handler = add_recipient_handler;
    g_wgui_cat28_cntx.remove_recipient_handler = remove_recipient_handler;
    g_wgui_cat28_cntx.is_pressed_label = MMI_FALSE;

    if (highlight_state == WGUI_CAT28_RECIPIENTS)
    {
        if (g_wgui_cat28_cntx.highlight_index < 0)
        {
            g_wgui_cat28_cntx.highlight_index = 0;
        }
    }
    else if (highlight_state == WGUI_CAT28_EDITOR)
    {
        g_wgui_cat28_cntx.highlight_index = -1;
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat28_insert_new_recipient
 * DESCRIPTION
 *  Add a new recipient.
 * PARAMETERS
 *  index :                        [IN] (N/A) the position of the new recipient.
 *  new_recipient :                [IN] (N/A) new recipient name or number.
 *  editor_flags  :                [IN] (N/A) flags.
 *  need_to_highlight :            [IN] (N/A) set highlight or not.
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL wgui_cat28_insert_new_recipient(S32 index, UI_buffer_type new_recipient, U32 editor_flags, MMI_BOOL need_to_highlight)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_wgui_cat28_cntx.max_recipients_num == wgui_cat28_get_recipients_num())
    {
        return MMI_FALSE;
    }

    /* set flag for add recipients in PHB */
    g_wgui_cat28_add_recipients_in_BG = MMI_TRUE;

    /* get the last index */
    for (i = 0; ((i < g_wgui_cat28_cntx.max_recipients_num) && (g_wgui_cat28_cntx.recipient[i].is_valid == MMI_TRUE)); i++);

    /* check the index */
    MMI_ASSERT((index >= 0) && (index <= i));

    if ((g_wgui_cat28_cntx.recipient[index].input_buf[0] == 0) &&
        (g_wgui_cat28_cntx.recipient[index].input_buf[1] == 0))
    {
        g_wgui_cat28_cntx.recipient[index].is_valid = MMI_TRUE;
        g_wgui_cat28_cntx.recipient[index].editor_flags = editor_flags;

        if (new_recipient != NULL)
        {
            gui_strcpy((UI_string_type)g_wgui_cat28_cntx.recipient[index].input_buf, (UI_string_type)new_recipient);
        }

        if (need_to_highlight)
        {
            if (g_dm_data.s32CatId == MMI_CATEGORY28_ID)
            {
                gui_lock_double_buffer();
                wgui_cat28_set_highlight_state_and_index(WGUI_CAT28_RECIPIENTS, index);
                gui_unlock_double_buffer();
            }
            else
            {
                g_wgui_cat28_cntx.highlight_state = WGUI_CAT28_RECIPIENTS;
                g_wgui_cat28_cntx.highlight_index = index;
            }
        }
    }
    else
    {
        g_wgui_cat28_cntx.recipient[i].is_valid = MMI_TRUE;

        /* move the recipients */
        for (; i > index; i--)
        {
            g_wgui_cat28_cntx.recipient[i].editor_flags = g_wgui_cat28_cntx.recipient[i - 1].editor_flags;
            gui_memcpy(g_wgui_cat28_cntx.recipient[i].input_buf, g_wgui_cat28_cntx.recipient[i - 1].input_buf, (g_wgui_cat28_cntx.recipient_buffer_size * ENCODING_LENGTH));
        }

        /* add new recipient */
        g_wgui_cat28_cntx.recipient[i].editor_flags = editor_flags;
        if (new_recipient == NULL)
        {
            g_wgui_cat28_cntx.recipient[i].input_buf[0] = 0;
            g_wgui_cat28_cntx.recipient[i].input_buf[1] = 0;
        }
        else
        {
            //gui_memcpy(g_wgui_cat28_cntx.recipient[i].input_buf, new_recipient, g_wgui_cat28_cntx.recipient_buffer_size);
            gui_strcpy((UI_string_type)g_wgui_cat28_cntx.recipient[i].input_buf, (UI_string_type)new_recipient);
        }

        if (need_to_highlight)
        {
            gui_lock_double_buffer();

            if (g_dm_data.s32CatId == MMI_CATEGORY28_ID)
            {
                wgui_cat28_set_highlight_state_and_index(WGUI_CAT28_RECIPIENTS, index);
            }
            else
            {
                g_wgui_cat28_cntx.highlight_state = WGUI_CAT28_RECIPIENTS;
                g_wgui_cat28_cntx.highlight_index = index;
            }

            gui_unlock_double_buffer();
        }
    }
   
    /* callback to app */
    if (g_wgui_cat28_cntx.add_recipient_handler != NULL)
    {
        g_wgui_cat28_cntx.add_recipient_handler(i); 
    }

    return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat28_add_new_recipient
 * DESCRIPTION
 *  Add a new recipient.
 * PARAMETERS
 *  new_recipient :                [IN] (N/A) new recipient name or number.
 *  editor_flags  :                [IN] (N/A) flags.
 *  need_to_highlight :            [IN] (N/A) set highlight or not.
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL wgui_cat28_add_new_recipient(UI_buffer_type new_recipient, U32 editor_flags, MMI_BOOL need_to_highlight)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 index = wgui_cat28_get_recipients_num();
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(index > 0);
    if ((g_wgui_cat28_cntx.highlight_index >= 0) && (g_wgui_cat28_cntx.highlight_index < index))
    {
        if ((g_wgui_cat28_cntx.recipient[g_wgui_cat28_cntx.highlight_index].input_buf[0] == 0) &&
            (g_wgui_cat28_cntx.recipient[g_wgui_cat28_cntx.highlight_index].input_buf[1] == 0))
        {
            index = g_wgui_cat28_cntx.highlight_index;
        }
    }
    else
    {
        if ((g_wgui_cat28_cntx.recipient[index - 1].input_buf[0] == 0) &&
            (g_wgui_cat28_cntx.recipient[index - 1].input_buf[1] == 0))
        {
            index = index - 1;
        }
    }
    
    return wgui_cat28_insert_new_recipient(index, new_recipient, editor_flags, need_to_highlight);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat28_set_phb_recipient
 * DESCRIPTION
 *  Set a recipient is from PHB, and add the ";" if necessary.
 * PARAMETERS
 *  buffer_index :                 [IN] (N/A) new recipient name or number.
 *  editor_flags  :                [IN] (N/A) flags.
 *  phb_recipient_name :           [IN] (N/A) set highlight or not.
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL wgui_cat28_set_phb_recipient(S32 buffer_index, U32 editor_flags, UI_buffer_type phb_recipient_name)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 recipients_num = wgui_cat28_get_recipients_num();
    S32 ret = 1;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(recipients_num > 0);
    if (buffer_index >= recipients_num)
    {
        /* the buffer is invaild */
        return MMI_FALSE;
    }

    g_wgui_cat28_cntx.recipient[buffer_index].editor_flags = editor_flags;
    
    if (editor_flags & WGUI_CAT28_WRAPPING_DELETE_RECIPIENT)
    {
        ret = gui_strcmp((UI_string_type)g_wgui_cat28_cntx.recipient[buffer_index].input_buf, (UI_string_type)phb_recipient_name);
    }
    
    if (ret == 0)
    {
        gui_strcat((UI_string_type) g_wgui_cat28_cntx.recipient[buffer_index].input_buf, L";");
        g_wgui_cat28_add_recipients_in_BG = MMI_TRUE;
        return MMI_TRUE;
    }
    return MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat28_get_highlight_state
 * DESCRIPTION
 *  get current highlight state.
 * PARAMETERS
 *  region_id             [OUT]   the highlighted region id.
 *  recipient_index       [OUT]   the recipient index, if highlighted is not no recipinets area, return -1
 * RETURNS
 *  wgui_uce_region_id_enum     return the highlight state.
 *****************************************************************************/
void wgui_cat28_get_highlight_state(wgui_cat28_region_id_enum *region_id, S32 *recipient_index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    *region_id = g_wgui_cat28_cntx.highlight_state;
    *recipient_index = g_wgui_cat28_cntx.highlight_index;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat28_sl_RSK_handler
 * DESCRIPTION
 *  Set the singleline editor RSK function.
 * PARAMETERS
 *  
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat28_sl_RSK_handler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (wgui_cat28_get_recipients_num() > 1)
    {
        wgui_cat28_remove_recipient(g_wgui_cat28_cntx.highlight_index);
    }
    else
    {
        if (category28_RSK_function)
        {
            category28_RSK_function();
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat28_register_recipient_change_callback
 * DESCRIPTION
 *  If single line editor text changed, we will callback to app if necessary.
 * PARAMETERS
 *  func:           [IN] (N/A) the change callback function.     
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat28_register_recipient_change_callback(wgui_cat28_recipient_changed_handler func)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_wgui_cat28_cntx.recipient_change_callback = func;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat28_remove_recipient
 * DESCRIPTION
 *  Remove a new recipient.
 * PARAMETERS
 *  index :                [IN] (N/A) the new recipient index.
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL wgui_cat28_remove_recipient(S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* at least there is one recipient */
    if (wgui_cat28_get_recipients_num() == 1)
    {
        MMI_ASSERT(index == 0);
        g_wgui_cat28_cntx.recipient[index].editor_flags = 0;
        if (g_wgui_cat28_cntx.highlight_state == WGUI_CAT28_RECIPIENTS)
        {
            gui_single_line_input_box_delete_all(&MMI_singleline_inputbox);
        }
        else
        {
            g_wgui_cat28_cntx.recipient[index].input_buf[0] = 0;
            g_wgui_cat28_cntx.recipient[index].input_buf[1] = 0;
        }
        return MMI_FALSE;
    }
    
    MMI_ASSERT((index >= 0) && (index < wgui_cat28_get_recipients_num()));

    /* set flag for add recipients in PHB */
    g_wgui_cat28_add_recipients_in_BG = MMI_TRUE;

    /* sorting */
    for (i = (index + 1); ((i < g_wgui_cat28_cntx.max_recipients_num) && (g_wgui_cat28_cntx.recipient[i].is_valid == MMI_TRUE)); i++)
    {
        g_wgui_cat28_cntx.recipient[i - 1].editor_flags = g_wgui_cat28_cntx.recipient[i].editor_flags;
        gui_memcpy(g_wgui_cat28_cntx.recipient[i - 1].input_buf, g_wgui_cat28_cntx.recipient[i].input_buf, (g_wgui_cat28_cntx.recipient_buffer_size * ENCODING_LENGTH));
    }

    g_wgui_cat28_cntx.recipient[i - 1].is_valid = MMI_FALSE;

    /* set highlight */
    if (index != 0)
    {
        if (g_dm_data.s32CatId == MMI_CATEGORY28_ID)
        {
            wgui_cat28_set_highlight_state_and_index(WGUI_CAT28_RECIPIENTS, (index - 1));
        }
        else
        {
            g_wgui_cat28_cntx.highlight_state = WGUI_CAT28_RECIPIENTS;
            g_wgui_cat28_cntx.highlight_index = index - 1;
        }
    }
    else
    {
        if (g_dm_data.s32CatId == MMI_CATEGORY28_ID)
        {
            gdi_layer_lock_frame_buffer();
            gdi_layer_push_clip();
            gdi_layer_set_clip(
                MMI_content_x, 
                MMI_content_y, 
                MMI_content_x + MMI_content_width - 1, 
                MMI_content_y + MMI_content_height - 1);
            wgui_cat28_set_highlight_state_and_index(WGUI_CAT28_RECIPIENTS, index);
            gdi_layer_pop_clip();
            gdi_layer_unlock_frame_buffer();
        }
        else
        {
            g_wgui_cat28_cntx.highlight_state = WGUI_CAT28_RECIPIENTS;
            g_wgui_cat28_cntx.highlight_index = index;
        }
    }
    
    if (g_wgui_cat28_cntx.remove_recipient_handler != NULL)
    {
        g_wgui_cat28_cntx.remove_recipient_handler(index); 
    }

    return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat28_adjust_with_vk
 * DESCRIPTION
 *  Adjust the EMS inputbox height, 
 *  and move the text offset for keep singleline editor visible.
 * PARAMETERS
 *  imui_x :                [IN] (N/A) X-axis of the input mode ui.
 *  imui_y :                [IN] (N/A) Y-axis of the input mode ui.
 *  imui_w :                [IN] (N/A) Width of the input mode ui.
 *  imui_h :                [IN] (N/A) Height of the input mode ui.
 * RETURNS
 *  U32
 *****************************************************************************/
static void wgui_cat28_adjust_with_vk(S32 imui_x, S32 imui_y, S32 imui_w, S32 imui_h)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 old_text_offset_y;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /*
    x = g_wgui_uce_cntx.max_label_width + CAT280_HMARGIN - 1;
    y = MMI_singleline_inputbox.y - MMI_multiline_inputbox.text_offset_y - MMI_multiline_inputbox.y;
    w = MMI_content_width - g_wgui_uce_cntx.max_label_width - (CAT280_HMARGIN << 1);
    h = WGUI_CAT28_INLINE_SL_HEIGHT;
    gap = (CAT280_VMARGIN >> 1);
    */

    gui_lock_double_buffer();
    
    /* adjust the text offset by category */
    old_text_offset_y = MMI_EMS_inputbox.display_y;
    resize_EMS_inputbox(MMI_EMS_inputbox.width, (imui_y - MMI_EMS_inputbox.y));
    MMI_EMS_inputbox.display_y = old_text_offset_y;   

    /* adjust text_offset_y */
    if ((MMI_EMS_inputbox.height - MMI_EMS_inputbox.display_y) > (MMI_EMS_inputbox.display_height + MMI_EMS_inputbox.header_height))
    {
        MMI_EMS_inputbox.display_y = MMI_EMS_inputbox.height - (MMI_EMS_inputbox.display_height + MMI_EMS_inputbox.header_height);
    }
    if ((MMI_EMS_inputbox.display_height + MMI_EMS_inputbox.header_height) <= MMI_EMS_inputbox.height)
    {
        MMI_EMS_inputbox.display_y = 0;
    }

    MMI_EMS_inputbox.display_y -= wgui_inputs_EMS_is_area_visible(
            WGUI_CAT28_HEADER_GAP_X + g_wgui_cat28_cntx.max_label_width + WGUI_CAT28_HEADER_GAP_X, 
            WGUI_CAT28_HEADER_GAP_Y + (WGUI_CAT28_INLINE_SL_HEIGHT * g_wgui_cat28_cntx.highlight_index), 
            MMI_content_width - g_wgui_cat28_cntx.max_label_width - (WGUI_CAT28_HEADER_GAP_X << 1) - MMI_EMS_inputbox.vbar.width,
            WGUI_CAT28_INLINE_SL_HEIGHT, 
            (WGUI_CAT28_HEADER_GAP_Y >> 1));

    /*
    wgui_cat280_editor_scroll_down(wgui_inputs_ml_is_area_visible(x, y, w, h, gap));
    if ((MMI_multiline_inputbox.height - MMI_multiline_inputbox.text_offset_y) > MMI_multiline_inputbox.text_height)
    {
        MMI_multiline_inputbox.text_offset_y = MMI_multiline_inputbox.height - MMI_multiline_inputbox.text_height;
    }

    MMI_multiline_inputbox.ext_flags |= GUI_MULTI_LINE_INPUT_BOX_DISABLE_FORCE_CURSOR_APPEAR;
    */
    gui_unlock_double_buffer();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat28_sl_RSK_up_handler
 * DESCRIPTION
 *  single line eidtor RSK up handler
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat28_sl_RSK_up_handler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_inputs_sl_set_RSK();
    set_right_softkey_function(UI_dummy_function, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat28_editor_msg_callback
 * DESCRIPTION
 *  Eidtor/IME callback function
 *  
 * PARAMETERS
 *  input_box_handle    [IN]  inputbox handle
 *  msg_ptr             [IN]  message type
 * RETURNS
 *  void
 *****************************************************************************/
static U32 wgui_cat28_editor_msg_callback(void * input_box_handle, mmi_imc_message_struct_p msg_ptr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_imc_rect_p imui_rect_p;
#if defined(__MMI_TOUCH_SCREEN__)
    gui_multi_line_input_box_pen_enum input_box_event;
#endif /* __MMI_TOUCH_SCREEN__ */
    U32 lresult = 0;
    S32 old_text_offset;
    static MMI_BOOL is_pen_down_sl = MMI_FALSE;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (msg_ptr->message_id == MMI_IMC_MESSAGE_SET_KEY)
    {
        /* UNK and DNK always handled by EMS editor */
        register_EMS_inputbox_keys();
        gdi_layer_lock_frame_buffer();
        
        if (g_wgui_cat28_cntx.highlight_state == WGUI_CAT28_RECIPIENTS)
        {
            //single_line_input_box * editor_ptr;
            //editor_ptr = (single_line_input_box *)((mmi_editor_handler_struct *)input_box_handle)->input_box_handler;

            if (!(MMI_softkeys[MMI_RIGHT_SOFTKEY].flags & UI_BUTTON_STATE_CLICKED))
            {
                wgui_inputs_sl_set_RSK();
            }
            else
            {
                set_right_softkey_function(wgui_cat28_sl_RSK_up_handler, KEY_EVENT_UP);
            }

            //wgui_inputs_sl_register_keys();
        }
        else
        {
            wgui_set_EMS_inputbox_RSK();
        }
        gdi_layer_unlock_frame_buffer();
        return 0;
    }

    /* default callback */
    if ((g_wgui_cat28_cntx.highlight_state == WGUI_CAT28_EDITOR))
    {
        UI_EMS_input_box * editor_ptr;
        editor_ptr = (UI_EMS_input_box *)((mmi_editor_handler_struct *)input_box_handle)->input_box_handler;
        if (editor_ptr == &MMI_EMS_inputbox)
        {
            lresult =  mmi_input_box_msg_call_back_ems(input_box_handle, msg_ptr);

#ifndef __MMI_FTE_SUPPORT__
            if ((msg_ptr->message_id == MMI_IMC_MESSAGE_PEN_EVENT) && 
                (g_wgui_cat28_cntx.highlight_state == WGUI_CAT28_RECIPIENTS) &&
                (g_dm_data.s32CatId == MMI_CATEGORY28_ID))
            {
                //wgui_inputs_sl_redraw_information_bar();
                wgui_EMS_redraw_input_information_bar();
            }
#endif
#ifdef __MMI_TOUCH_SCREEN__
            if ((msg_ptr->message_id == MMI_IMC_MESSAGE_PEN_EVENT) &&
                ((((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->mmi_pen_event == MMI_PEN_EVENT_MOVE)||
                (((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->mmi_pen_event == MMI_PEN_EVENT_REPEAT)))
            {
                S32 temp_pen_region;

                temp_pen_region = wgui_cat28_translate_header_pen_event(
                    ((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos.x,
                    ((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos.y - (MMI_EMS_inputbox.y + MMI_EMS_inputbox.display_y));
                if (temp_pen_region != WGUI_CAT28_PEN_ON_LABEL)
                {
                    if (g_wgui_cat28_cntx.is_pressed_label == MMI_TRUE)
                    {
                        g_wgui_cat28_cntx.is_pressed_label = MMI_FALSE;
                        redraw_EMS_inputbox();
                    }
                }
            }
#endif /* __MMI_TOUCH_SCREEN__ */
        }
        
        return lresult;
    }
    else
    {
#ifdef __MMI_TOUCH_SCREEN__
        /* pen on single editor */
        if ((msg_ptr->message_id != MMI_IMC_MESSAGE_PEN_EVENT) ||
            (PEN_CHECK_BOUND(
                ((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos.x,
                ((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos.y, 
                MMI_singleline_inputbox.x, 
                MMI_singleline_inputbox.y, 
                MMI_singleline_inputbox.width, 
                MMI_singleline_inputbox.height) &&
             PEN_CHECK_BOUND(
                ((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos.x,
                ((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos.y, 
                MMI_EMS_inputbox.x, 
                MMI_EMS_inputbox.y, 
                MMI_EMS_inputbox.width, 
                MMI_EMS_inputbox.height)))
#endif /* __MMI_TOUCH_SCREEN__ */
        {
            single_line_input_box * editor_ptr;
            editor_ptr = (single_line_input_box *)((mmi_editor_handler_struct *)input_box_handle)->input_box_handler;
            if (editor_ptr == &MMI_singleline_inputbox)
            {
                switch (msg_ptr->message_id)
                {
                    case MMI_IMC_MESSAGE_RESIZE:
                    case MMI_IMC_MESSAGE_MOVE:
                        break;
                            
                    case MMI_IMC_MESSAGE_IMUI_RECTANGLE_IS_UPDATED:
                        imui_rect_p = (mmi_imc_rect_p)(msg_ptr->param_0);
                        wgui_cat28_adjust_with_vk(imui_rect_p->x, imui_rect_p->y, imui_rect_p->width, imui_rect_p->height);
                        break;
        
                    case MMI_IMC_MESSAGE_REDRAW: 
                        /* adjust the offset */
                        if ((MMI_EMS_inputbox.height - MMI_EMS_inputbox.display_y) > (MMI_EMS_inputbox.display_height + MMI_EMS_inputbox.header_height))
                        {
                            MMI_EMS_inputbox.display_y = MMI_EMS_inputbox.height - (MMI_EMS_inputbox.display_height + MMI_EMS_inputbox.header_height);
                        }
                        if ((MMI_EMS_inputbox.display_height + MMI_EMS_inputbox.header_height) <= MMI_EMS_inputbox.height)
                        {
                            MMI_EMS_inputbox.display_y = 0;
                        }

                        MMI_EMS_inputbox.display_y -= wgui_inputs_EMS_is_area_visible(
                                WGUI_CAT28_HEADER_GAP_X + g_wgui_cat28_cntx.max_label_width + WGUI_CAT28_HEADER_GAP_X, 
                                WGUI_CAT28_HEADER_GAP_Y + (WGUI_CAT28_INLINE_SL_HEIGHT * g_wgui_cat28_cntx.highlight_index), 
                                MMI_content_width - g_wgui_cat28_cntx.max_label_width - (WGUI_CAT28_HEADER_GAP_X << 1) - MMI_EMS_inputbox.vbar.width,
                                WGUI_CAT28_INLINE_SL_HEIGHT, 
                                (WGUI_CAT28_HEADER_GAP_Y >> 1));

                        if (msg_ptr->param_0 == 1)
                        {
                            dm_imui_window_hide();
                        }
                        else
                        {
                            gui_show_EMS_input_box(&MMI_EMS_inputbox);
                        }

                        if (!(g_dm_data.s32flags & DM_NO_TITLE))
                        {
                            draw_title();
                        }

                        #ifndef __MMI_FTE_SUPPORT__
                        if (g_wgui_cat28_cntx.highlight_state == WGUI_CAT28_EDITOR)
                        {
                            wgui_EMS_redraw_input_information_bar();
                        }
                        else if (g_wgui_cat28_cntx.highlight_state == WGUI_CAT28_RECIPIENTS)
                        {
                            //wgui_inputs_sl_redraw_information_bar();
                            wgui_EMS_redraw_input_information_bar();
                        }
                        #endif

                        break;

                    case MMI_IMC_MESSAGE_CHECK_INFO_BAR_ENABL:
                        lresult = MMI_TRUE;
                        break;

#ifdef __MMI_TOUCH_SCREEN__
                    case MMI_IMC_MESSAGE_PEN_EVENT:
                            if (((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->mmi_pen_event == MMI_PEN_EVENT_DOWN)
                            {
                                /* adjust the offset */
                                old_text_offset = MMI_EMS_inputbox.display_y;
                                MMI_EMS_inputbox.display_y -= wgui_inputs_EMS_is_area_visible(
                                        WGUI_CAT28_HEADER_GAP_X + g_wgui_cat28_cntx.max_label_width + WGUI_CAT28_HEADER_GAP_X, 
                                        WGUI_CAT28_HEADER_GAP_Y + (WGUI_CAT28_INLINE_SL_HEIGHT * g_wgui_cat28_cntx.highlight_index), 
                                        MMI_content_width - g_wgui_cat28_cntx.max_label_width - (WGUI_CAT28_HEADER_GAP_X << 1) - MMI_EMS_inputbox.vbar.width,
                                        WGUI_CAT28_INLINE_SL_HEIGHT, 
                                        (WGUI_CAT28_HEADER_GAP_Y >> 1));

                                if ((old_text_offset != MMI_EMS_inputbox.display_y) || 
                                    (g_wgui_cat28_cntx.is_pressed_label == MMI_TRUE))
                                {
                                    g_wgui_cat28_cntx.is_pressed_label = MMI_FALSE;
                                    redraw_EMS_inputbox();
                                }
                            }

                            if (((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->mmi_pen_event == MMI_PEN_EVENT_DOWN)
                            {
                                is_pen_down_sl = MMI_TRUE;
                            }

                            if (is_pen_down_sl == MMI_TRUE)
                            {
                                lresult = mmi_input_box_msg_call_back_singleline(input_box_handle, msg_ptr);
                            }
                            else
                            {
                                lresult = gui_EMS_input_box_translate_pen_event(
                                                &MMI_EMS_inputbox,
                                                ((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->mmi_pen_event,
                                                ((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos.x,
                                                ((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos.y,
                                                &input_box_event);
                            }

                            if ((((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->mmi_pen_event == MMI_PEN_EVENT_UP) ||
                                (((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->mmi_pen_event == MMI_PEN_EVENT_ABORT))
                            {
                                is_pen_down_sl = MMI_FALSE;
                            }
                            break;

                    case MMI_IMC_MESSAGE_DRAW_INFORMATION_BAR:
                            wgui_EMS_redraw_input_information_bar();
                            break;

#endif /* __MMI_TOUCH_SCREEN__ */

                    default:
                        lresult = mmi_input_box_msg_call_back_singleline(input_box_handle, msg_ptr);
                }
            }
        }
        
#ifdef __MMI_TOUCH_SCREEN__
        else
        {
            ////(multi_line_input_box *)((mmi_editor_handler_struct *)input_box_handle)->input_box_handler = &MMI_multiline_inputbox;
            ////lresult =  mmi_input_box_msg_call_back_multiline(input_box_handle, msg_ptr);
            if ((((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->mmi_pen_event == MMI_PEN_EVENT_MOVE)||
                (((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->mmi_pen_event == MMI_PEN_EVENT_REPEAT))
            {
                S32 temp_pen_region;

                temp_pen_region = wgui_cat28_translate_header_pen_event(
                    ((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos.x,
                    ((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos.y - (MMI_EMS_inputbox.y + MMI_EMS_inputbox.display_y));
                if (temp_pen_region != WGUI_CAT28_PEN_ON_LABEL)
                {
                    if (g_wgui_cat28_cntx.is_pressed_label == MMI_TRUE)
                    {
                        g_wgui_cat28_cntx.is_pressed_label = MMI_FALSE;
                        redraw_EMS_inputbox();
                    }
                }
            }
            if ((((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->mmi_pen_event == MMI_PEN_EVENT_DOWN))
            {
                wgui_cat28_ime_pre_vk_handler(
                    ((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos.x,
                    ((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos.y);
            }
            lresult = gui_EMS_input_box_translate_pen_event(
                        &MMI_EMS_inputbox,
                        ((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->mmi_pen_event,
                        ((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos.x,
                        ((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos.y,
                        &input_box_event);
        }
#endif /* __MMI_TOUCH_SCREEN__ */

        return lresult;
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat28_sl_empty_callback
 * DESCRIPTION
 *  if singleline editor is empty, we need to change RSK
 * PARAMETERS
 *
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat28_sl_empty_callback(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* if the old highlight recipient is empty, we need to remove it */
    if (wgui_cat28_get_recipients_num() != 1)
    {
        if (mmi_imc_is_spell_word_state() == MMI_FALSE)
        {
            wgui_cat28_remove_recipient(g_wgui_cat28_cntx.highlight_index);
        }
    }
    else
    {
        g_wgui_cat28_cntx.recipient[g_wgui_cat28_cntx.highlight_index].editor_flags &= ~WGUI_CAT28_WRAPPING_DELETE_RECIPIENT;
        MMI_singleline_inputbox.ext_flags &= ~GUI_SINGLE_LINE_INPUT_BOX_RECIPIENT_MODE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat28_sl_change_event_callback
 * DESCRIPTION
 *  handler the ";" behaviors.
 * PARAMETERS
 *  event       [IN]        Action performed on insert, delete character or delete all
 *  C           [IN]        Character to insert or delete
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
static MMI_BOOL wgui_cat28_sl_change_event_callback(gui_multi_line_input_box_change_event_enum event, U16 C)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL result = MMI_TRUE;
    S32 i;
    S32 semicolon_offset = -1;
    UI_character_type current_character;
    UI_buffer_type text_p;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (event)
    {
        case GUI_MULTI_LINE_INPUT_BOX_INSERT_CHAR:
            /* if cannot create a new recipient, user cannot inputs ";" */
            if (wgui_cat28_get_recipients_num() == g_wgui_cat28_cntx.max_recipients_num)
            {
                for (i = 0; ((MMI_singleline_inputbox.text[i] != 0) || (MMI_singleline_inputbox.text[i + 1] != 0)); i += 2)
                {
                    /* if there is a ";" */
                    UI_buffer_type text_p;
                    UI_character_type current_character;
                    text_p = MMI_singleline_inputbox.text + i;
                    UI_STRING_GET_NEXT_CHARACTER(text_p, current_character);
                    if (UI_TEST_SEMICOLON_CHAR(current_character))
                    {
                        semicolon_offset = i;
                        break;
                    }
                }

                if (semicolon_offset != -1) /* there is a ";" */
                {
                    if (MMI_singleline_inputbox.current_text_p > MMI_singleline_inputbox.text + semicolon_offset)
                    {
                        S32 old_text_offset;

                        /* adjust text_offset_y */
                        old_text_offset = MMI_EMS_inputbox.display_y;
                        MMI_EMS_inputbox.display_y -= wgui_inputs_EMS_is_area_visible(
                                WGUI_CAT28_HEADER_GAP_X + g_wgui_cat28_cntx.max_label_width + WGUI_CAT28_HEADER_GAP_X, 
                                WGUI_CAT28_HEADER_GAP_Y + (WGUI_CAT28_INLINE_SL_HEIGHT * g_wgui_cat28_cntx.highlight_index), 
                                MMI_content_width - g_wgui_cat28_cntx.max_label_width - (WGUI_CAT28_HEADER_GAP_X << 1) - MMI_EMS_inputbox.vbar.width,
                                WGUI_CAT28_INLINE_SL_HEIGHT, 
                                (WGUI_CAT28_HEADER_GAP_Y >> 1));
                        if (old_text_offset != MMI_EMS_inputbox.display_y)
                        {
                            redraw_EMS_inputbox();
                        }
                        UI_editor_play_tone_cannot_insert();    /* play error tone */
                        return MMI_FALSE;
                    }
                }

                if (UI_TEST_SEMICOLON_CHAR(C) == MMI_TRUE)
                {
                    S32 old_text_offset;

                    /* adjust text_offset_y */
                    old_text_offset = MMI_EMS_inputbox.display_y;
                    MMI_EMS_inputbox.display_y -= wgui_inputs_EMS_is_area_visible(
                            WGUI_CAT28_HEADER_GAP_X + g_wgui_cat28_cntx.max_label_width + WGUI_CAT28_HEADER_GAP_X, 
                            WGUI_CAT28_HEADER_GAP_Y + (WGUI_CAT28_INLINE_SL_HEIGHT * g_wgui_cat28_cntx.highlight_index), 
                            MMI_content_width - g_wgui_cat28_cntx.max_label_width - (WGUI_CAT28_HEADER_GAP_X << 1) - MMI_EMS_inputbox.vbar.width,
                            WGUI_CAT28_INLINE_SL_HEIGHT, 
                            (WGUI_CAT28_HEADER_GAP_Y >> 1));
                    if (old_text_offset != MMI_EMS_inputbox.display_y)
                    {
                        redraw_EMS_inputbox();
                    }
                    UI_editor_play_tone_cannot_insert();    /* play error tone */
                    return MMI_FALSE;
                }
            }

            if (UI_TEST_SEMICOLON_CHAR(C)) /* ";" */
            {
                if (MMI_singleline_inputbox.text_length == MMI_singleline_inputbox.available_length - ENCODING_LENGTH)
                {
                    for (i = MMI_singleline_inputbox.text_length; ((&MMI_singleline_inputbox.text[i] > MMI_singleline_inputbox.current_text_p) && (i >= ENCODING_LENGTH)); i--)
                    {
                        MMI_singleline_inputbox.text[i] = MMI_singleline_inputbox.text[i - ENCODING_LENGTH];
                    }
                    
                    /* if inputs ";" after a ";", the second one should be create a new line */
                    text_p = (MMI_singleline_inputbox.current_text_p - ENCODING_LENGTH);
                    UI_STRING_GET_NEXT_CHARACTER(text_p, current_character);
                    if (UI_TEST_SEMICOLON_CHAR(current_character))
                    {
                        g_wgui_cat28_cntx.current_inputs = C;
                    }
                    else
                    {
                        if (C == 0x003b)
                        {
                            MMI_singleline_inputbox.current_text_p[0] = 0x3b;
                            MMI_singleline_inputbox.current_text_p[1] = 0x00;
                        }
                        else if (C == 0xff1b)
                        {
                            MMI_singleline_inputbox.current_text_p[0] = 0x1b;
                            MMI_singleline_inputbox.current_text_p[1] = 0xff;
                        }

                        MMI_singleline_inputbox.current_text_p += ENCODING_LENGTH;
                    }

                    wgui_cat28_sl_change_callback();
                    result = MMI_FALSE;
                }
                else if (MMI_singleline_inputbox.text_length == MMI_singleline_inputbox.available_length)
                {
                    MMI_BOOL play_tone = MMI_TRUE;
                    for (i = (MMI_singleline_inputbox.current_text_p - (MMI_singleline_inputbox.text)); i >= ENCODING_LENGTH; i -= ENCODING_LENGTH)   
                    {
                        /* if there is a ";" */
                        UI_buffer_type text_p;
                        UI_character_type current_character;
                        text_p = MMI_singleline_inputbox.text + i - ENCODING_LENGTH;
                        UI_STRING_GET_NEXT_CHARACTER(text_p, current_character);
                        if (UI_TEST_SEMICOLON_CHAR(current_character))
                        {
                            play_tone = MMI_FALSE;
                            break;
                        }
                    }

                    if (play_tone)
                    {
                        if (UI_TEST_SEMICOLON_CHAR(C))
                        {
                            MMI_BOOL ret;
                            UI_string_type old_cursor_text_p = (UI_string_type)MMI_singleline_inputbox.current_text_p;

                            ret = wgui_cat28_insert_new_recipient(
                                (g_wgui_cat28_cntx.highlight_index + 1), 
                                MMI_singleline_inputbox.current_text_p, 
                                WGUI_CAT28_DEFAULT_FLAGS, 
                                MMI_TRUE);

                            if (ret == MMI_TRUE)
                            {
                                old_cursor_text_p[0] = C;
                                old_cursor_text_p[1] = 0;
                                gui_show_EMS_input_box(&MMI_EMS_inputbox);
                                result = MMI_FALSE;
                                wgui_inputs_set_break_insert(MMI_FALSE);
                            }
                            else
                            {
                                UI_editor_play_tone_cannot_insert();    /* play error tone */
                                g_wgui_cat28_cntx.current_inputs = C;
                                wgui_cat28_sl_change_callback();
                                result = MMI_FALSE;
                            }
                        }
                        else
                        {
                            UI_editor_play_tone_cannot_insert();    /* play error tone */
                            g_wgui_cat28_cntx.current_inputs = C;
                            wgui_cat28_sl_change_callback();
                            result = MMI_FALSE;
                        }
                    }
                    else
                    {
                        g_wgui_cat28_cntx.current_inputs = C;
                        wgui_cat28_sl_change_callback();
                        result = MMI_FALSE;
                    }
                }
                else
                {
                    UI_buffer_type text_p;
                    UI_character_type current_character;
                    text_p = MMI_singleline_inputbox.current_text_p - ENCODING_LENGTH;
                    UI_STRING_GET_NEXT_CHARACTER(text_p, current_character);

                    if (UI_TEST_SEMICOLON_CHAR(current_character))
                    {
                        g_wgui_cat28_cntx.current_inputs = C;
                        wgui_cat28_sl_change_callback();
                        result = MMI_FALSE;
                    }
                }
            }
            else if (MMI_singleline_inputbox.text_length == (MMI_singleline_inputbox.available_length - ENCODING_LENGTH))
            {
                UI_buffer_type text_p;
                UI_character_type current_character;
                text_p = MMI_singleline_inputbox.text + MMI_singleline_inputbox.text_length - 2 * ENCODING_LENGTH;
                UI_STRING_GET_NEXT_CHARACTER(text_p, current_character);
                if (UI_TEST_SEMICOLON_CHAR(current_character))
                {
                    result = MMI_TRUE;
                }
                else
                {
                    UI_editor_play_tone_cannot_insert();    /* play error tone */
                    result = MMI_FALSE;
                }
            }
            else if (MMI_singleline_inputbox.text_length == MMI_singleline_inputbox.available_length)
            {
                MMI_BOOL play_tone = MMI_TRUE;
                for (i = (MMI_singleline_inputbox.current_text_p - (MMI_singleline_inputbox.text)); i >= ENCODING_LENGTH; i -= ENCODING_LENGTH)   
                {
                    /* if there is a ";" */
                    UI_buffer_type text_p;
                    UI_character_type current_character;
                    text_p = MMI_singleline_inputbox.text + i - ENCODING_LENGTH;
                    UI_STRING_GET_NEXT_CHARACTER(text_p, current_character);
                    if (UI_TEST_SEMICOLON_CHAR(current_character))
                    {
                        play_tone = MMI_FALSE;
                        break;
                    }
                }

                if (play_tone)
                {
                    UI_editor_play_tone_cannot_insert();    /* play error tone */
                }

                g_wgui_cat28_cntx.current_inputs = C;
                wgui_cat28_sl_change_callback();
                result = MMI_FALSE;
            }

            break;
            
        case GUI_MULTI_LINE_INPUT_BOX_DELETE_CHAR:

            break;
            
        case GUI_MULTI_LINE_INPUT_BOX_DELETEALL:

            break;
        case GUI_MULTI_LINE_INPUT_BOX_INSERT_STRING:

            break;
    }
    
    return result;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat28_sl_change_callback
 * DESCRIPTION
 *  If there is ";" in recipient, we will add a new recipient.
 * PARAMETERS
 *  new_recipient :                [IN] (N/A) new recipient name or number.
 *  flags         :                [IN] (N/A) flags.
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat28_sl_change_callback(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i =0;
    MMI_BOOL ret;
    S32 old_highlight_index;
    S32 old_text_offset;
    MMI_BOOL is_create_new_recipient = MMI_FALSE;
    MMI_BOOL cursor_in_middle = MMI_TRUE;
    U8 current_inputs[4] = {0};
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* if no changed, we cannot remove the recipient */
    wgui_inputs_register_empty_func(wgui_cat28_sl_empty_callback);

    /* adjust text_offset_y */
    old_text_offset = MMI_EMS_inputbox.display_y;
    MMI_EMS_inputbox.display_y -= wgui_inputs_EMS_is_area_visible(
            WGUI_CAT28_HEADER_GAP_X + g_wgui_cat28_cntx.max_label_width + WGUI_CAT28_HEADER_GAP_X, 
            WGUI_CAT28_HEADER_GAP_Y + (WGUI_CAT28_INLINE_SL_HEIGHT * g_wgui_cat28_cntx.highlight_index), 
            MMI_content_width - g_wgui_cat28_cntx.max_label_width - (WGUI_CAT28_HEADER_GAP_X << 1) - MMI_EMS_inputbox.vbar.width,
            WGUI_CAT28_INLINE_SL_HEIGHT, 
            (WGUI_CAT28_HEADER_GAP_Y >> 1));

    if (old_text_offset != MMI_EMS_inputbox.display_y)
    {
        redraw_EMS_inputbox();
    }

    /* clear the flags */
    g_wgui_cat28_cntx.recipient[g_wgui_cat28_cntx.highlight_index].editor_flags &= ~WGUI_CAT28_HIGHLIGHT_RECIPIENT;
    old_highlight_index = g_wgui_cat28_cntx.highlight_index;

    if ((MMI_singleline_inputbox.current_text_p[0] == 0) && (MMI_singleline_inputbox.current_text_p[1] == 0))
    {
        cursor_in_middle = MMI_FALSE;
    }

    for (i = (MMI_singleline_inputbox.current_text_p - (&MMI_singleline_inputbox.text[i])); i >= ENCODING_LENGTH; i -= ENCODING_LENGTH)   
    {
        /* if there is a ";" */
        UI_buffer_type text_p;
        UI_character_type current_character;
        text_p = MMI_singleline_inputbox.text + i - ENCODING_LENGTH;
        UI_STRING_GET_NEXT_CHARACTER(text_p, current_character);
        if (UI_TEST_SEMICOLON_CHAR(current_character))
        {
            if (g_wgui_cat28_cntx.current_inputs == 0)
            {
                ret = wgui_cat28_insert_new_recipient((g_wgui_cat28_cntx.highlight_index + 1), &MMI_singleline_inputbox.text[i], WGUI_CAT28_DEFAULT_FLAGS, MMI_TRUE);
                mmi_imc_skip_first_cursor_movement_event(MMI_FALSE);
            }
            else
            {
                current_inputs[0] = (g_wgui_cat28_cntx.current_inputs & 0x00FF);
                current_inputs[1] = ((g_wgui_cat28_cntx.current_inputs & 0xFF00) >> 8);
                ret = wgui_cat28_insert_new_recipient((g_wgui_cat28_cntx.highlight_index + 1), current_inputs, WGUI_CAT28_DEFAULT_FLAGS, MMI_TRUE);
            }

            if (ret == MMI_TRUE)
            {
                gdi_layer_lock_frame_buffer();
                mmi_imc_reset_ime_state();
                gdi_layer_unlock_frame_buffer();
                g_wgui_cat28_cntx.recipient[old_highlight_index].input_buf[i] = 0;
                g_wgui_cat28_cntx.recipient[old_highlight_index].input_buf[i + 1] = 0;
                redraw_EMS_inputbox();
                is_create_new_recipient = MMI_TRUE;
                wgui_inputs_set_break_insert(MMI_FALSE);
            }
            else
            {
                /* delete the char */
                /* call app callback */
            }
            break;
        }
    }
    
    g_wgui_cat28_cntx.current_inputs = 0;

    /* callback to app */
    if ((is_create_new_recipient == MMI_FALSE) ||
        (cursor_in_middle == MMI_TRUE))
    {
        if (g_wgui_cat28_cntx.recipient_change_callback != NULL) 
        {
            g_wgui_cat28_cntx.recipient_change_callback(old_highlight_index);
        }
    }
    return;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat28_draw_sl_background
 * DESCRIPTION
 *  Draw the singleline editor background.
 * PARAMETERS
 *  x1      [IN]        start X
 *  y1      [IN]        start Y
 *  x2      [IN]        end X
 *  y2      [IN]        end Y
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat28_draw_sl_background(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 prev_x1, prev_y1, prev_x2, prev_y2;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_push_clip();
    gui_set_clip_preset(x1, y1, x2, y2);

    gdi_layer_get_clip(&prev_x1, &prev_y1, &prev_x2, &prev_y2);
    if (prev_y1 < prev_y2)
    {
        gui_fill_rectangle(x1, y1, x2, y2, MMI_EMS_inputbox.normal_filler->c);
    }
    gui_pop_clip();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat28_set_highlight_state_and_index
 * DESCRIPTION
 *  set highlight state and index.
 * PARAMETERS
 *  state   [IN]  highlight state
 *  index   [IN]  highlight index
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat28_set_highlight_state_and_index(wgui_cat28_region_id_enum state, S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    UI_buffer_type inputs_buffer;
    S32 inputs_buffer_size;
    U32 inputs_type;
    S32 old_highlight_index;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (state == WGUI_CAT28_RECIPIENTS)
    {
        MMI_ASSERT((index >= 0) &&(index < g_wgui_cat28_cntx.max_recipients_num));  
        //wgui_inputs_EMS_move_cursor(WGUI_INPUTS_CURSOR_POS_END);
        MMI_EMS_inputbox.flags |= UI_EMS_INPUT_BOX_DISABLE_CURSOR_DRAW;
        wgui_inputs_set_current_input_box_type(EDITOR_SINGLE_LINE_INPU_BOX);
    }
    else if (state == WGUI_CAT28_EDITOR)
    {
        if (index != -1)
        {
            MMI_ASSERT(0);
        }
        //MMI_EMS_inputbox.flags &= ~UI_EMS_INPUT_BOX_DISABLE_CURSOR_DRAW;
        wgui_inputs_EMS_enable();
        wgui_inputs_set_current_input_box_type(EDITOR_EMS_INPUT_BOX);
    }
    else 
    {
        /* undefined state */
         MMI_ASSERT(0);
    }

    /* get the ime history */
    if (mmi_imc_is_connected())
    {
        if (g_wgui_cat28_cntx.highlight_state == WGUI_CAT28_EDITOR)
        {
            mmi_imc_get_input_method_history(&g_wgui_cat28_cntx.ml_ime);
            g_wgui_cat28_cntx.need_to_set_ml_ime = MMI_TRUE;
        }
        else if (g_wgui_cat28_cntx.highlight_state == WGUI_CAT28_RECIPIENTS)
        {
            mmi_imc_get_input_method_history(&g_wgui_cat28_cntx.sl_ime);
            g_wgui_cat28_cntx.need_to_set_sl_ime = MMI_TRUE;
        }
    }

    old_highlight_index = g_wgui_cat28_cntx.highlight_index;
    g_wgui_cat28_cntx.highlight_state = state;
    g_wgui_cat28_cntx.highlight_index= index;

    /* clear old highlight flag */
    if (old_highlight_index != g_wgui_cat28_cntx.highlight_index)
    {
        g_wgui_cat28_cntx.recipient[old_highlight_index].editor_flags &= ~WGUI_CAT28_HIGHLIGHT_RECIPIENT;
    }
    
    if (g_wgui_cat28_cntx.highlight_state == WGUI_CAT28_EDITOR)
    {
        wgui_inputs_disconnect();

#if !defined(__MMI_MAINLCD_240X320__) && !defined(__MMI_FTE_SUPPORT__)
        wgui_inputbox_information_flag = MMI_TRUE;
#endif

        /* set ime */
#ifdef __MMI_FTE_SUPPORT__
        if (g_wgui_cat28_cntx.need_to_set_ml_ime || g_wgui_cat28_cntx.ml_ime.is_vk_on)
#else /* __MMI_FTE_SUPPORT__ */
        if (g_wgui_cat28_cntx.need_to_set_ml_ime)
#endif /* __MMI_FTE_SUPPORT__ */
        {
#if defined(__MMI_IME_AUTO_CAPITALIZATION__)
            if (g_wgui_cat28_add_recipients_in_BG)
            {
                g_wgui_cat28_cntx.ml_ime.skip_auto_cap_first_filter = MMI_TRUE;
            }
#endif
            mmi_imc_set_input_method_history(&g_wgui_cat28_cntx.ml_ime);
        }
        
        wgui_inputs_connect(
            g_wgui_cat28_cntx.ml_input_type,
            NULL,
            IMM_INPUT_MODE_NONE,
            MMI_EDITOR_EMS_INPUT_BOX,
            MMI_EDITOR_NORMAL_INPUT_BOX,
            &MMI_EMS_inputbox,
            wgui_cat28_editor_msg_callback);

        /* enable new line symbol */
        MMI_current_input_ext_type &= ~INPUT_TYPE_EXT_NO_SHOW_NEW_LINE_SYMBOL;

        /* adjust text_offset_y */
        MMI_EMS_inputbox.display_y -= wgui_inputs_EMS_is_area_visible(
            WGUI_CAT28_HEADER_GAP_X << 1, 
            MMI_EMS_inputbox.header_height, 
            MMI_content_width - (WGUI_CAT28_HEADER_GAP_X << 1) - MMI_EMS_inputbox.vbar.width,
            WGUI_CAT28_INLINE_SL_HEIGHT, 
            (WGUI_CAT28_HEADER_GAP_Y >> 1));

        /* set vk state */
        wgui_EMS_redraw_input_information_bar();
        mmi_imc_redraw_screen_by_state();
        
    }
    else if (g_wgui_cat28_cntx.highlight_state == WGUI_CAT28_RECIPIENTS)
    {
        inputs_buffer = g_wgui_cat28_cntx.recipient[g_wgui_cat28_cntx.highlight_index].input_buf;
        inputs_buffer_size = g_wgui_cat28_cntx.recipient_buffer_size; // - ENCODING_LENGTH;
        inputs_type = g_wgui_cat28_cntx.recipient_input_type;
        
        mmi_imc_set_fixed_input_box();
        wgui_inputs_sl_disable_up_down_key_register(MMI_TRUE);
        
        /* change callback and empty callback */
        MMI_singleline_inputbox.change_callback = wgui_cat28_sl_change_callback;
        wgui_inputs_register_empty_func(NULL);

        /* singleline inputbox */
        wgui_inputs_disconnect();

        /* set default input mode */
        if ((g_wgui_cat28_cntx.sl_history == NULL) && (g_wgui_cat28_cntx.need_to_set_sl_ime == MMI_FALSE))
        {
            mmi_imm_set_app_desired_input_mode(IMM_INPUT_MODE_123_SYMBOLS);
        }

        /* set ime */
        if (g_wgui_cat28_cntx.need_to_set_sl_ime)
        {
            singleline_inputbox_category_history *sl_h = (singleline_inputbox_category_history*) g_wgui_cat28_cntx.sl_history;
            mmi_imc_set_input_method_history(&g_wgui_cat28_cntx.sl_ime);
            if (g_wgui_cat28_cntx.sl_history != NULL)
            {
                gui_memcpy(&(sl_h->ime_history), &g_wgui_cat28_cntx.sl_ime, sizeof(mmi_imc_history));
            }
        }

        gdi_layer_lock_frame_buffer();

        wgui_inputs_sl_setup_ext(
            MMI_content_x + g_wgui_cat28_cntx.max_label_width,
            MMI_content_y + WGUI_CAT28_HEADER_GAP_Y,
            MMI_content_width - g_wgui_cat28_cntx.max_label_width - (WGUI_CAT28_HEADER_GAP_X << 1) - MMI_EMS_inputbox.vbar.width,
            WGUI_CAT28_INLINE_SL_HEIGHT,
            inputs_buffer,
            inputs_buffer_size,
            MMI_CATEGORY28_ID,
            get_string(g_wgui_cat28_cntx.right_softkey),
            get_image(g_wgui_cat28_cntx.right_softkey_icon),
            inputs_type,
            g_wgui_cat28_cntx.sl_history,
            0,
            wgui_cat28_editor_msg_callback);

        gdi_layer_unlock_frame_buffer();

        /* set the RSK function */
        wgui_singleline_inputbox_RSK_function = category28_RSK_function;
        
        /* change callback */
        MMI_singleline_inputbox.change_callback = wgui_cat28_sl_change_callback;
        
        /* call the function while the text change (insert/ delete/ delete all) */
        wgui_inputs_sl_register_change_event_handler(wgui_cat28_sl_change_event_callback);

        /* set the singleline background */
        gui_inputs_register_redraw_background_filler(wgui_cat28_draw_sl_background);

        /* set flag */
        if (g_wgui_cat28_cntx.recipient[g_wgui_cat28_cntx.highlight_index].editor_flags & WGUI_CAT28_HIGHLIGHT_RECIPIENT)
        {
            MMI_singleline_inputbox.flags |= UI_SINGLE_LINE_INPUT_BOX_WORD_HIGHLIGHT | UI_SINGLE_LINE_INPUT_BOX_AUTO_CLEAR_HIGHLIGHT_MODE;
            MMI_singleline_inputbox.highlight_start_position = inputs_buffer;
            MMI_singleline_inputbox.highlight_end_position = inputs_buffer + (inputs_buffer_size * ENCODING_LENGTH);
            g_wgui_cat28_cntx.recipient[g_wgui_cat28_cntx.highlight_index].editor_flags &= ~WGUI_CAT28_HIGHLIGHT_RECIPIENT;
            wgui_inputs_sl_move_cursor(WGUI_INPUTS_CURSOR_POS_END);
        }
        if (g_wgui_cat28_cntx.recipient[g_wgui_cat28_cntx.highlight_index].editor_flags & WGUI_CAT28_WRAPPING_DELETE_RECIPIENT)
        {
            MMI_singleline_inputbox.ext_flags |= GUI_SINGLE_LINE_INPUT_BOX_RECIPIENT_MODE;
        }
        MMI_singleline_inputbox.flags |= UI_SINGLE_LINE_INPUT_BOX_USE_PRESET_CLIPPING;
        MMI_singleline_inputbox.ext_flags |= GUI_SINGLE_LINE_INPUT_BOX_RECIPIENT_SEMICOLON_MODE;
        
        /* disable new line symbol */
        MMI_current_input_ext_type |= INPUT_TYPE_EXT_NO_SHOW_NEW_LINE_SYMBOL;

        /* clear singleline history */
        g_wgui_cat28_cntx.sl_history = NULL;

        /* adjust text_offset_y */
        if ((MMI_EMS_inputbox.height - MMI_EMS_inputbox.display_y) > (MMI_EMS_inputbox.display_height + MMI_EMS_inputbox.header_height))
        {
            MMI_EMS_inputbox.display_y = MMI_EMS_inputbox.height - (MMI_EMS_inputbox.display_height + MMI_EMS_inputbox.header_height);
        }
        if ((MMI_EMS_inputbox.display_height + MMI_EMS_inputbox.header_height) <= MMI_EMS_inputbox.height)
        {
            MMI_EMS_inputbox.display_y = 0;
        }

        MMI_EMS_inputbox.display_y -= wgui_inputs_EMS_is_area_visible(
            WGUI_CAT28_HEADER_GAP_X + g_wgui_cat28_cntx.max_label_width + WGUI_CAT28_HEADER_GAP_X, 
            WGUI_CAT28_HEADER_GAP_Y + (WGUI_CAT28_INLINE_SL_HEIGHT * g_wgui_cat28_cntx.highlight_index), 
            MMI_content_width - g_wgui_cat28_cntx.max_label_width - (WGUI_CAT28_HEADER_GAP_X << 1) - MMI_EMS_inputbox.vbar.width,
            WGUI_CAT28_INLINE_SL_HEIGHT, 
            (WGUI_CAT28_HEADER_GAP_Y >> 1));

        /* set vk state */
#ifndef __MMI_FTE_SUPPORT__
        //wgui_inputs_sl_redraw_information_bar();
        wgui_EMS_redraw_input_information_bar();
#endif
        mmi_imc_redraw_screen_by_state();
    }
    
    if (g_wgui_cat28_cntx.highlight_handler!= NULL)
    {
        g_wgui_cat28_cntx.highlight_handler(old_highlight_index, index, MMI_FALSE); 
    }

    /* if the old highlight recipient is empty, we need to remove it 
    if ((wgui_cat28_get_recipients_num() != 1) &&
        (g_wgui_cat28_cntx.recipient[old_highlight_index].input_buf[0] == 0) && 
        (g_wgui_cat28_cntx.recipient[old_highlight_index].input_buf[1] == 0))
    {
        wgui_cat28_remove_recipient(old_highlight_index);
    }*/
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat28_draw_recipient_text
 * DESCRIPTION
 *  draw string
 * PARAMETERS
 *  string       [IN]        string to draw
 *  x            [IN]        string region x
 *  y            [IN]        string region y
 *  w            [IN]        string region width
 *  color        [IN]        string color
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat28_draw_recipient_text(UI_string_type string, S32 x, S32 y, S32 w, color c)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_set_text_color(c);
    gui_set_font(&MMI_medium_font);
    
    if (mmi_fe_get_r2l_state())
    {
        gui_print_truncated_text(x + w - 1, y, w, string);
    }
    else
    {
        gui_print_truncated_text(x, y, w, string);
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat28_draw_editor_header
 * DESCRIPTION
 *  draw the recipients.
 * PARAMETERS
 *  yoffset     [IN]        Offset Y
 *  clip_x1     [IN]        Start X
 *  clip_y1     [IN]        Start Y
 *  clip_x2     [IN]        End X
 *  clip_y2     [IN]        End Y
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat28_draw_editor_header(S32 clip_x1, S32 clip_y1, S32 clip_x2, S32 clip_y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 draw_x = 0, draw_y = 0, draw_width = 0, draw_height = 0;
    S32 lab_w, lab_h, string_w, string_h = WGUI_CAT28_INLINE_SL_HEIGHT - (WGUI_CAT28_HEADER_GAP_Y << 1);
    U8 str[10];
    S32 str_w, str_h;
    //color text_col = gui_color(255, 255, 255);
    color text_col = *current_MMI_theme->editor_recipient_button_text_color;
    GDI_HANDLE act_layer = GDI_NULL_HANDLE;
    S32 i = 0, recipients_num;
    UI_string_type recipient_string;
    stFontAttribute *f = &MMI_medium_font;
    color string_color = *current_MMI_theme->inputbox_normal_text_color;
    PU8 lab_image;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* draw label */
    gdi_layer_get_active(&act_layer);
    if (act_layer != GDI_NULL_HANDLE)
    {
        gdi_push_and_set_alpha_blending_source_layer(act_layer);
    }

    if (g_wgui_cat28_cntx.is_pressed_label == MMI_TRUE)
    {
        lab_image = g_wgui_cat28_cntx.recipients_label.label_pressed_image;
    }
    else
    {
        lab_image = g_wgui_cat28_cntx.recipients_label.label_normal_image;
    }

    gui_measure_image(lab_image, &lab_w, &lab_h);
    draw_x = clip_x1 + WGUI_CAT28_HEADER_GAP_X;
    draw_y = clip_y1 + WGUI_CAT28_HEADER_GAP_Y + ((WGUI_CAT28_INLINE_SL_HEIGHT - lab_h) >> 1) + 1;
    
    if(((draw_y + lab_h) > MMI_EMS_inputbox.y) && (draw_y < (MMI_EMS_inputbox.y + MMI_EMS_inputbox.height))) 
    {
        gdi_image_draw(draw_x, draw_y, lab_image);
    }

#ifdef __MMI_FTE_SUPPORT__
    /* draw label text */
    mmi_asc_to_ucs2((PS8)str, (PS8) "TO");

    gui_set_font(f);
    gui_measure_string((UI_string_type)str, &str_w, &str_h);
    if (mmi_fe_get_r2l_state())
    {
        gui_move_text_cursor(draw_x + ((lab_w - str_w) >> 1) + str_w, draw_y + ((lab_h - str_h) >> 1) + 1);
    }
    else
    {
        gui_move_text_cursor(draw_x + ((lab_w - str_w) >> 1), draw_y + ((lab_h - str_h) >> 1) + 1);
    }
    gui_set_text_color(text_col);
    gui_print_text((UI_string_type) str);
#endif /* __MMI_FTE_SUPPORT__ */

    if (act_layer != GDI_NULL_HANDLE)
    {
        gdi_pop_and_restore_alpha_blending_source_layer();
    }

    /* draw recipients */
    draw_x = clip_x1 + WGUI_CAT28_HEADER_GAP_X + g_wgui_cat28_cntx.max_label_width + WGUI_CAT28_HEADER_GAP_X;
    draw_y = clip_y1 + WGUI_CAT28_HEADER_GAP_Y;
    draw_width = clip_x2 - draw_x;
    draw_height = WGUI_CAT28_INLINE_SL_HEIGHT;
    recipients_num = wgui_cat28_get_recipients_num();

    for (i = 0; i < recipients_num; i++)
    {
        MMI_ASSERT(g_wgui_cat28_cntx.recipient[i].is_valid == MMI_TRUE);

        if ((g_wgui_cat28_cntx.highlight_state == WGUI_CAT28_RECIPIENTS) && 
            (g_wgui_cat28_cntx.highlight_index == i))
        {
#ifdef __MMI_FTE_SUPPORT__
            wgui_inputs_sl_move(draw_x, draw_y);
            wgui_inputs_sl_resize(draw_width, draw_height); 
#else
            wgui_inputs_sl_move(draw_x, (draw_y + WGUI_CAT28_HEADER_GAP_Y + 1));
            wgui_inputs_sl_resize(draw_width, (draw_height - ((WGUI_CAT28_HEADER_GAP_Y + 1) << 1))); 
#endif
            wgui_inputs_sl_show();
        }
        else
        {
            if(((draw_y + draw_height) > MMI_EMS_inputbox.y) && (draw_y < (MMI_EMS_inputbox.y + MMI_EMS_inputbox.height))) 
            {
                recipient_string = (UI_string_type) g_wgui_cat28_cntx.recipient[i].input_buf;
                if (recipient_string != NULL)
                {
                    gui_set_font(f);
                    gui_measure_string(recipient_string, &string_w ,&string_h);
                    MMI_ASSERT(string_h <= WGUI_CAT28_INLINE_SL_HEIGHT);
                    if (string_h == 0)
                    {
                        string_h = WGUI_CAT28_INLINE_SL_TEXT_DEFAULT_HEIGHT;
                    }

                    wgui_cat28_draw_recipient_text(
                        recipient_string,
                        draw_x,
                        draw_y + ((WGUI_CAT28_INLINE_SL_HEIGHT - string_h) >> 1),
                        draw_width,
                        string_color);
                }

                /* draw base line */
                UI_draw_horizontal_line(
                    draw_x  - 1,
                    MMI_EMS_inputbox.width - 2,
                    draw_y + ((WGUI_CAT28_INLINE_SL_HEIGHT - string_h) >> 1) + string_h + 1,
                    *(current_MMI_theme->inputbox_base_line_color));
            }
        }
        
        draw_y += WGUI_CAT28_INLINE_SL_HEIGHT;
    }
}


S32 wgui_cat28_get_recipients_height(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 recipients_height = 0;
    S32 valid_recipient_num;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* if no recipients, header_height = 0 */
    if (g_wgui_cat28_cntx.inline_recipients == MMI_FALSE)
    {
        return 0;
    }
    
    /* header border */
    recipients_height = (WGUI_CAT28_HEADER_GAP_Y << 1);

    /* get recipients number */
    valid_recipient_num = wgui_cat28_get_recipients_num();
    recipients_height += (valid_recipient_num*WGUI_CAT28_INLINE_SL_HEIGHT);

    return recipients_height;    
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat28_translate_header_pen_event
 * DESCRIPTION
 *  get editor header and footer height
 * PARAMETERS
 *  x       [IN]
 *  y       [IN]
 * RETURNS
 *  S32      the index of recipient
 *****************************************************************************/
static S32 wgui_cat28_translate_header_pen_event(S32 x, S32 y)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 header_h = 0;
    S32 recipient_index = WGUI_CAT28_PEN_ON_EMPTY;
    S32 recipient_num;
    S32 lab_w = 0, lab_h = 0;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/   
    /* recipients area*/
    gui_measure_image(g_wgui_cat28_cntx.recipients_label.label_normal_image, &lab_w, &lab_h);
    if ((x > (MMI_content_x + WGUI_CAT28_HEADER_GAP_X)) && (x < (MMI_content_x + WGUI_CAT28_HEADER_GAP_X + lab_w)))
    {
        if ((y > (WGUI_CAT28_HEADER_GAP_Y + ((WGUI_CAT28_INLINE_SL_HEIGHT - lab_h) >> 1))) && 
            (y < (WGUI_CAT28_HEADER_GAP_Y + lab_h + ((WGUI_CAT28_INLINE_SL_HEIGHT - lab_h) >> 1))))
        {
            recipient_index = WGUI_CAT28_PEN_ON_LABEL;
        }
    }
    else
    {
        recipient_num = wgui_cat28_get_recipients_num();
        if (recipient_num > 0)
        {
            header_h = (WGUI_CAT28_HEADER_GAP_Y << 1) + (WGUI_CAT28_INLINE_SL_HEIGHT * recipient_num);
            
            if ((x <= (MMI_singleline_inputbox.x + MMI_singleline_inputbox.width)) &&
                (x >= MMI_singleline_inputbox.x))
            {
                if ((header_h - WGUI_CAT28_HEADER_GAP_Y) <= y)
                {
                    recipient_index = recipient_num - 1;
                }
                else if (y <= WGUI_CAT28_HEADER_GAP_Y)
                {
                    recipient_index = 0;
                }
                else
                {
                    recipient_index = (y - WGUI_CAT28_HEADER_GAP_Y) / WGUI_CAT28_INLINE_SL_HEIGHT;
                }
            }
            else
            {
                recipient_index = WGUI_CAT28_PEN_ON_EMPTY;
            }
        }
    }
    return recipient_index;
}


static MMI_BOOL EMS_recipient_pen_callback(gui_input_box_area_enum area_type, mmi_pen_event_type_enum pen_event, S32 x, S32 y)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 index = 0;
    static S32 pen_down_index = WGUI_CAT28_PEN_ON_EMPTY;
    MMI_BOOL ret = MMI_TRUE;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* check the position */
    MMI_ASSERT ((y >= 0) && (x >= 0) && (x < UI_device_width));
    
    gdi_layer_lock_frame_buffer();
    
    if (g_wgui_cat28_cntx.inline_recipients == MMI_TRUE)
    {
        if (pen_event == MMI_PEN_EVENT_DOWN)
        {
            if (area_type == GUI_INPUT_BOX_AREA_HEADER)
            {
                /* get the pen down recipient */
                pen_down_index = wgui_cat28_translate_header_pen_event(x, y);
                if (pen_down_index == WGUI_CAT28_PEN_ON_LABEL)
                {
                    g_wgui_cat28_cntx.is_pressed_label = MMI_TRUE;
                    gui_show_EMS_input_box(&MMI_EMS_inputbox);
                }
            }
            else
            {
                pen_down_index = WGUI_CAT28_PEN_ON_TEXT;
            }
        }
        else if (pen_event == MMI_PEN_EVENT_UP)
        {
            if (area_type == GUI_INPUT_BOX_AREA_HEADER)
            {
                /* get the pen down recipient */
                index = wgui_cat28_translate_header_pen_event(x, y);
                if (index == pen_down_index)
                {
                    if (index == WGUI_CAT28_PEN_ON_LABEL)
                    {
                        /* app's callback */
                        if ((g_wgui_cat28_cntx.recipients_label.label_callback != NULL) && (g_wgui_cat28_cntx.is_pressed_label == MMI_TRUE))
                        {
                            g_wgui_cat28_cntx.recipients_label.label_callback();
                            g_wgui_cat28_cntx.is_pressed_label = MMI_FALSE;
                            ret = MMI_FALSE;
                        }
                    }
                    else if (index == WGUI_CAT28_PEN_ON_EMPTY)
                    {
                        ret = MMI_FALSE;
                    }
                    else if (index == WGUI_CAT28_PEN_ON_TEXT)
                    {
                        ret = MMI_FALSE;
                    }
                    else
                    {
#ifdef __MMI_FTE_SUPPORT__
                        g_wgui_cat28_cntx.sl_ime.is_vk_on = MMI_TRUE;
#endif
                        wgui_cat28_set_highlight_state_and_index(WGUI_CAT28_RECIPIENTS, index);
                        mmi_imc_redraw_screen_by_state();
                    }
                }
            }
            else  /* pen up on text */
            {
                /* move highlight to text */
                if ((g_wgui_cat28_cntx.highlight_state != WGUI_CAT28_EDITOR) && (pen_down_index == WGUI_CAT28_PEN_ON_TEXT))
                {
#ifdef __MMI_FTE_SUPPORT__
                    g_wgui_cat28_cntx.ml_ime.is_vk_on = MMI_TRUE;
#endif
                    wgui_cat28_set_highlight_state_and_index(WGUI_CAT28_EDITOR, -1);
                    mmi_imc_redraw_screen_by_state();
                }
            }

            if (g_wgui_cat28_cntx.is_pressed_label == MMI_TRUE)
            {
                g_wgui_cat28_cntx.is_pressed_label = MMI_FALSE;
                redraw_EMS_inputbox();
            }
        }
    }

    gdi_layer_unlock_frame_buffer();
    gdi_lcd_repaint_all();
    
    return ret;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat28_highlight_on_recipients_key_handler
 * DESCRIPTION
 *  highlight on recipients key handler
 * PARAMETERS
 *  key_code   [IN]  key code
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
static MMI_BOOL wgui_cat28_highlight_on_recipients_key_handler(S16 key_code)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL result = MMI_TRUE;
    S32 highlight_index;
    S32 old_text_offset_y;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/       
    switch (key_code)
    {
        case KEY_DOWN_ARROW:
            gdi_layer_lock_frame_buffer();

            /* highlight on the lase recipient */
            if ( g_wgui_cat28_cntx.highlight_index == (wgui_cat28_get_recipients_num() - 1))
            {
                wgui_cat28_set_highlight_state_and_index(WGUI_CAT28_EDITOR, -1);
            }
            else
            {
                highlight_index = g_wgui_cat28_cntx.highlight_index + 1;
                wgui_cat28_set_highlight_state_and_index(WGUI_CAT28_RECIPIENTS, highlight_index);
            }

            redraw_EMS_inputbox();
#ifndef __MMI_FTE_SUPPORT__
            if (g_wgui_cat28_cntx.highlight_state == WGUI_CAT28_EDITOR)
            {
                wgui_EMS_redraw_input_information_bar();
            }
            else if (g_wgui_cat28_cntx.highlight_state == WGUI_CAT28_RECIPIENTS)
            {
                //wgui_inputs_sl_redraw_information_bar();
                wgui_EMS_redraw_input_information_bar();
            }
#endif

            gdi_layer_unlock_frame_buffer();
            gdi_lcd_repaint_all();
            break;
 
        case KEY_UP_ARROW: 
            gdi_layer_lock_frame_buffer();

            if (g_wgui_cat28_cntx.highlight_index != 0)
            {
                highlight_index = g_wgui_cat28_cntx.highlight_index - 1;
                wgui_cat28_set_highlight_state_and_index(WGUI_CAT28_RECIPIENTS, highlight_index);
            }

            redraw_EMS_inputbox();
#ifndef __MMI_FTE_SUPPORT__
            if (g_wgui_cat28_cntx.highlight_state == WGUI_CAT28_EDITOR)
            {
                wgui_EMS_redraw_input_information_bar();
            }
            else if (g_wgui_cat28_cntx.highlight_state == WGUI_CAT28_RECIPIENTS)
            {
                //wgui_inputs_sl_redraw_information_bar();
                wgui_EMS_redraw_input_information_bar();
            }
#endif
            gdi_layer_unlock_frame_buffer();
            gdi_lcd_repaint_all();
            break;

        case KEY_RIGHT_ARROW:
            old_text_offset_y = MMI_EMS_inputbox.display_y;

            /* adjust text_offset_y */
            if ((MMI_EMS_inputbox.height - MMI_EMS_inputbox.display_y) > (MMI_EMS_inputbox.display_height + MMI_EMS_inputbox.header_height))
            {
                MMI_EMS_inputbox.display_y = MMI_EMS_inputbox.height - (MMI_EMS_inputbox.display_height + MMI_EMS_inputbox.header_height);
            }
            if ((MMI_EMS_inputbox.display_height + MMI_EMS_inputbox.header_height) <= MMI_EMS_inputbox.height)
            {
                MMI_EMS_inputbox.display_y = 0;
            }
            MMI_EMS_inputbox.display_y -= wgui_inputs_EMS_is_area_visible(
                    WGUI_CAT28_HEADER_GAP_X + g_wgui_cat28_cntx.max_label_width + WGUI_CAT28_HEADER_GAP_X, 
                    WGUI_CAT28_HEADER_GAP_Y + (WGUI_CAT28_INLINE_SL_HEIGHT * g_wgui_cat28_cntx.highlight_index), 
                    MMI_content_width - g_wgui_cat28_cntx.max_label_width - (WGUI_CAT28_HEADER_GAP_X << 1) - MMI_EMS_inputbox.vbar.width,
                    WGUI_CAT28_INLINE_SL_HEIGHT, 
                    (WGUI_CAT28_HEADER_GAP_Y >> 1));

            if (MMI_EMS_inputbox.display_y != old_text_offset_y)
            {
                redraw_EMS_inputbox();
            }

            wgui_inputs_sl_next_character();
            break;
            
        case KEY_LEFT_ARROW:
            old_text_offset_y = MMI_EMS_inputbox.display_y;

            /* adjust text_offset_y */
            if ((MMI_EMS_inputbox.height - MMI_EMS_inputbox.display_y) > (MMI_EMS_inputbox.display_height + MMI_EMS_inputbox.header_height))
            {
                MMI_EMS_inputbox.display_y = MMI_EMS_inputbox.height - (MMI_EMS_inputbox.display_height + MMI_EMS_inputbox.header_height);
            }
            if ((MMI_EMS_inputbox.display_height + MMI_EMS_inputbox.header_height) <= MMI_EMS_inputbox.height)
            {
                MMI_EMS_inputbox.display_y = 0;
            }
            MMI_EMS_inputbox.display_y -= wgui_inputs_EMS_is_area_visible(
                    WGUI_CAT28_HEADER_GAP_X + g_wgui_cat28_cntx.max_label_width + WGUI_CAT28_HEADER_GAP_X, 
                    WGUI_CAT28_HEADER_GAP_Y + (WGUI_CAT28_INLINE_SL_HEIGHT * g_wgui_cat28_cntx.highlight_index), 
                    MMI_content_width - g_wgui_cat28_cntx.max_label_width - (WGUI_CAT28_HEADER_GAP_X << 1) - MMI_EMS_inputbox.vbar.width,
                    WGUI_CAT28_INLINE_SL_HEIGHT, 
                    (WGUI_CAT28_HEADER_GAP_Y >> 1));

            if (MMI_EMS_inputbox.display_y != old_text_offset_y)
            {
                redraw_EMS_inputbox();
            }

            wgui_inputs_sl_previous_character(); 
            break;

        default:
            result = MMI_FALSE;
            break;
    }
    return result;
}

extern MMI_BOOL gui_ems_test_first_line(UI_EMS_input_box *b);
/*****************************************************************************
 * FUNCTION
 *  wgui_cat28_highlight_on_editor_key_handler
 * DESCRIPTION
 *  highlight on editor key handler
 * PARAMETERS
 *  key_code   [IN]  key code
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
static MMI_BOOL wgui_cat28_highlight_on_editor_key_handler(S16 key_code)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL result = MMI_FALSE;
    S32 highlight_index;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    switch (key_code)
    {
        case KEY_UP_ARROW:       
            if (gui_ems_test_first_line(&MMI_EMS_inputbox))  /* cursor at first line */
            {                              
                gdi_layer_lock_frame_buffer();
                        
                highlight_index = (wgui_cat28_get_recipients_num() - 1);
                wgui_cat28_set_highlight_state_and_index(WGUI_CAT28_RECIPIENTS, highlight_index);
                wgui_inputs_EMS_disable();
                
				redraw_EMS_inputbox();
#ifndef __MMI_FTE_SUPPORT__
                //wgui_inputs_sl_redraw_information_bar();
                wgui_EMS_redraw_input_information_bar();
#endif
                gdi_layer_unlock_frame_buffer();
                gdi_lcd_repaint_all();
                result = MMI_TRUE;
            }
            break;

        default:
            break;
    }
    return result;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat28_editor_pre_key_hdlr
 * DESCRIPTION
 *  EMS inputbox pre key handler
 * PARAMETERS
 *  key_code  [IN]  key code
 * RETURNS
 *  MMI_BOOL  return true, editor will not do anything
 *****************************************************************************/
static MMI_BOOL wgui_cat28_editor_pre_key_hdlr(S16 key_code)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL result = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!mmi_imc_is_ime_state() && (g_wgui_cat28_cntx.inline_recipients == MMI_TRUE))
    {
        switch(g_wgui_cat28_cntx.highlight_state)
        {
            case WGUI_CAT28_RECIPIENTS:     /* highlight on recipients */
                result = wgui_cat28_highlight_on_recipients_key_handler(key_code);
                break;
            case WGUI_CAT28_EDITOR:        /* highlight on editor */
                result = wgui_cat28_highlight_on_editor_key_handler(key_code);
                break;
            default:
                ASSERT(0);
                break;
        }
    }
    return result;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat28_editor_scrollbar_hdlr
 * DESCRIPTION
 *  EMS inputbox pre key handler, 
 *  we need to adjust the highlight recipient based on scroll bar
 * PARAMETERS
 *  offset  [IN]  scroll bar offset.
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat28_editor_scrollbar_hdlr(S32 offset)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 sl_offset;
    S32 i, recipients_num;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    recipients_num = wgui_cat28_get_recipients_num();

    if (g_wgui_cat28_cntx.highlight_state != WGUI_CAT28_RECIPIENTS)
    {
        if ((MMI_EMS_inputbox.height - MMI_EMS_inputbox.display_y - WGUI_CAT28_INLINE_SL_HEIGHT) < MMI_EMS_inputbox.header_height)
        {
            S32 old_text_offset_y;

            old_text_offset_y = MMI_EMS_inputbox.display_y;
            wgui_cat28_set_highlight_state_and_index(WGUI_CAT28_RECIPIENTS, (recipients_num - 1));
            MMI_EMS_inputbox.display_y = old_text_offset_y;
        }
        else 
        {
            return;
        }
    }

    /* get the current singleline editor position */
    sl_offset = wgui_inputs_EMS_is_area_visible(
                    WGUI_CAT28_HEADER_GAP_X + g_wgui_cat28_cntx.max_label_width + WGUI_CAT28_HEADER_GAP_X, 
                    WGUI_CAT28_HEADER_GAP_Y + (WGUI_CAT28_INLINE_SL_HEIGHT * g_wgui_cat28_cntx.highlight_index), 
                    MMI_content_width - g_wgui_cat28_cntx.max_label_width - (WGUI_CAT28_HEADER_GAP_X << 1) - MMI_EMS_inputbox.vbar.width,
                    WGUI_CAT28_INLINE_SL_HEIGHT, 
                    (WGUI_CAT28_HEADER_GAP_Y >> 1));

    /* visible */
    if (sl_offset == 0)
    {
        return;
    }
    
    /* highlight need to move down */
    if (sl_offset < 0)
    {
        for (i = g_wgui_cat28_cntx.highlight_index + 1; i < recipients_num; i++) 
        {
            sl_offset = wgui_inputs_EMS_is_area_visible(
                            WGUI_CAT28_HEADER_GAP_X + g_wgui_cat28_cntx.max_label_width + WGUI_CAT28_HEADER_GAP_X, 
                            WGUI_CAT28_HEADER_GAP_Y + (WGUI_CAT28_INLINE_SL_HEIGHT * i), 
                            MMI_content_width - g_wgui_cat28_cntx.max_label_width - (WGUI_CAT28_HEADER_GAP_X << 1) - MMI_EMS_inputbox.vbar.width,
                            WGUI_CAT28_INLINE_SL_HEIGHT, 
                            (WGUI_CAT28_HEADER_GAP_Y >> 1));

            if (sl_offset == 0)
            {
                wgui_cat28_set_highlight_state_and_index(WGUI_CAT28_RECIPIENTS, i);
                return;
            }
        }

        if (sl_offset < 0)
        {
            wgui_cat28_set_highlight_state_and_index(WGUI_CAT28_EDITOR, -1);
            return;
        }
    }

    /* highlight need to move up */
    if (sl_offset > 0)
    {
        for (i = g_wgui_cat28_cntx.highlight_index - 1; i >= 0; i--) 
        {
            sl_offset = wgui_inputs_EMS_is_area_visible(
                            WGUI_CAT28_HEADER_GAP_X + g_wgui_cat28_cntx.max_label_width + WGUI_CAT28_HEADER_GAP_X, 
                            WGUI_CAT28_HEADER_GAP_Y + (WGUI_CAT28_INLINE_SL_HEIGHT * i), 
                            MMI_content_width - g_wgui_cat28_cntx.max_label_width - (WGUI_CAT28_HEADER_GAP_X << 1) - MMI_EMS_inputbox.vbar.width,
                            WGUI_CAT28_INLINE_SL_HEIGHT, 
                            (WGUI_CAT28_HEADER_GAP_Y >> 1));

            if (sl_offset == 0)
            {
                wgui_cat28_set_highlight_state_and_index(WGUI_CAT28_RECIPIENTS, i);
                return;
            }
        }

        if (sl_offset > 0)
        {
            MMI_ASSERT(0);
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  GetCategory28History
 * DESCRIPTION
 *  return pointer to GUI buffer
 * PARAMETERS
 *  history_buffer      [IN]     History buffer
 * RETURNS
 *  pointer to history buffer
 *****************************************************************************/
extern U8 *GetCategory28History(U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_cat28_history_cntx *h;
    S32 ems_size ,sl_size;
    wgui_cat28_region_id_enum region_id;
    S32 recipient_index;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    get_EMS_inputbox_category_history(MMI_CATEGORY28_ID, history_buffer);
    ems_size = sizeof(EMS_inputbox_category_history);
    ems_size = (ems_size + 3) / 4;
    ems_size *= 4;

    wgui_inputs_sl_get_category_history(MMI_CATEGORY28_ID, (history_buffer + ems_size));
    sl_size = sizeof(singleline_inputbox_category_history);
    sl_size = (sl_size + 3) / 4;
    sl_size *= 4;
    
    h = (wgui_cat28_history_cntx*)(history_buffer + ems_size + sl_size);
    wgui_cat28_get_highlight_state(&region_id, &recipient_index);
    h->highlight_state = region_id;
    h->highlight_index = recipient_index;
    h->recipients_num = wgui_cat28_get_recipients_num();
    
    /* set the ime history */
    if (g_wgui_cat28_cntx.highlight_state == WGUI_CAT28_EDITOR)
    {
        mmi_imc_get_input_method_history(&g_wgui_cat28_cntx.ml_ime);
        g_wgui_cat28_cntx.need_to_set_ml_ime = MMI_TRUE;
    }
    else if (g_wgui_cat28_cntx.highlight_state == WGUI_CAT28_RECIPIENTS)
    {
        mmi_imc_get_input_method_history(&g_wgui_cat28_cntx.sl_ime);
        g_wgui_cat28_cntx.need_to_set_sl_ime = MMI_TRUE;
    }

    h->need_to_set_ml_ime = g_wgui_cat28_cntx.need_to_set_ml_ime;
    h->need_to_set_sl_ime = g_wgui_cat28_cntx.need_to_set_sl_ime;
    gui_memcpy(&(h->ml_ime), &g_wgui_cat28_cntx.ml_ime, sizeof(mmi_imc_history));
    gui_memcpy(&(h->sl_ime), &g_wgui_cat28_cntx.sl_ime, sizeof(mmi_imc_history));
    
    return history_buffer;
}


/*****************************************************************************
 * FUNCTION
 *  GetCategory28HistorySize
 * DESCRIPTION
 *  Get history size
 * PARAMETERS
 *  void
 * RETURNS
 *  S32 Category 28 History Size
 *****************************************************************************/
extern S32 GetCategory28HistorySize(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return (((sizeof(EMS_inputbox_category_history) + 3) / 4) * 4 + ((sizeof(singleline_inputbox_category_history) + 3) / 4) * 4 + sizeof(wgui_cat28_history_cntx));
}
#endif /* __MMI_MSG_EDITOR_WITH_RECIPIENT__ */


#ifdef __MMI_MSG_EDITOR_WITH_RECIPIENT__
/*****************************************************************************
 * FUNCTION
 *  wgui_cat28_key_proc
 * DESCRIPTION
 *  Create a new recipient editor before IME handler.
 * PARAMETERS
 * RETURNS
 *  void
 *****************************************************************************/
static mmi_ret wgui_cat28_key_proc(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_frm_key_evt_struct *key_evt = (mmi_frm_key_evt_struct *)evt;
    U8 key_code = key_evt->key_code;
    S32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if ((key_evt->evt_id == EVT_ID_PRE_KEY) && (key_evt->key_type == KEY_EVENT_DOWN) &&
        //(!(MMI_singleline_inputbox.flags & UI_SINGLE_LINE_INPUT_BOX_WORD_HIGHLIGHT)) &&
        (!(MMI_singleline_inputbox.flags & UI_SINGLE_LINE_INPUT_BOX_AUTO_CLEAR_HIGHLIGHT_MODE)))
    {
        if (mmi_imc_key_is_current_symbol_key(key_code))
        {
            if (g_wgui_cat28_cntx.highlight_state == WGUI_CAT28_RECIPIENTS)
            {
                if ((MMI_singleline_inputbox.ext_flags & GUI_SINGLE_LINE_INPUT_BOX_RECIPIENT_MODE) &&
                    (MMI_singleline_inputbox.current_text_p != (MMI_singleline_inputbox.last_position_p - ENCODING_LENGTH)))
                {
                    wgui_inputs_sl_move_cursor(WGUI_INPUTS_CURSOR_POS_END);
                }

                for (i = (MMI_singleline_inputbox.current_text_p - (MMI_singleline_inputbox.text)); i >= ENCODING_LENGTH; i -= ENCODING_LENGTH)   
                {
                    i -= ENCODING_LENGTH;
                    /* if there is a ";" */
                    if (((MMI_singleline_inputbox.text[i] == 0x3b) && (MMI_singleline_inputbox.text[i + 1] == 0)) ||
                        ((MMI_singleline_inputbox.text[i] == 0x1b) && (MMI_singleline_inputbox.text[i + 1] == 0xff)))
                    {
                        gdi_layer_lock_frame_buffer();

                        wgui_cat28_insert_new_recipient((g_wgui_cat28_cntx.highlight_index + 1), &MMI_singleline_inputbox.text[i + 2], WGUI_CAT28_DEFAULT_FLAGS, MMI_TRUE);
                        
                        set_right_softkey_label((UI_string_type) get_string(STR_GLOBAL_CLEAR));
                        set_right_softkey_icon(NULL);
                        redraw_right_softkey();

                        gdi_layer_unlock_frame_buffer();

                        break;
                    }
                }
            }
        }
    }
    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat28_ime_pre_vk_handler
 * DESCRIPTION
 *  Create a new recipient editor before IME handler.
 * PARAMETERS
 * RETURNS
 *  void
 *****************************************************************************/
static MMI_BOOL wgui_cat28_ime_pre_vk_handler(S32 x, S32 y)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    //mmi_frm_key_evt_struct *key_evt = (mmi_frm_key_evt_struct *)evt;
    //U8 key_code = key_evt->key_code;
    S32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_UI_VIRTUAL_KEYBOARD_DEFAULT_VERSION_2__
    if (!(MMI_singleline_inputbox.flags & UI_SINGLE_LINE_INPUT_BOX_AUTO_CLEAR_HIGHLIGHT_MODE))
    {
        /* check the (x, y) is on VK */
        if (/*(MMI_TRUE == mmi_imui_is_pen_on_vk(x, y)) &&*/ (MMI_TRUE == wgui_virtual_keyboard_Check_alphanumeric_vk_0_to_9_key(x, y)))
        {
            if (g_wgui_cat28_cntx.highlight_state == WGUI_CAT28_RECIPIENTS)
            {
                if ((MMI_singleline_inputbox.ext_flags & GUI_SINGLE_LINE_INPUT_BOX_RECIPIENT_MODE) &&
                    (MMI_singleline_inputbox.current_text_p != (MMI_singleline_inputbox.last_position_p - ENCODING_LENGTH)))
                {
                    wgui_inputs_sl_move_cursor(WGUI_INPUTS_CURSOR_POS_END);
                }

                for (i = (MMI_singleline_inputbox.current_text_p - (MMI_singleline_inputbox.text)); i >= ENCODING_LENGTH; i -= ENCODING_LENGTH)   
                {
                    i -= ENCODING_LENGTH;
                    /* if there is a ";" */
                    if (((MMI_singleline_inputbox.text[i] == 0x3b) && (MMI_singleline_inputbox.text[i + 1] == 0)) ||
                        ((MMI_singleline_inputbox.text[i] == 0x1b) && (MMI_singleline_inputbox.text[i + 1] == 0xff)))
                    {
                        gdi_layer_lock_frame_buffer();

                        wgui_cat28_insert_new_recipient((g_wgui_cat28_cntx.highlight_index + 1), &MMI_singleline_inputbox.text[i + 2], WGUI_CAT28_DEFAULT_FLAGS, MMI_TRUE);
                        
                        set_right_softkey_label((UI_string_type) get_string(STR_GLOBAL_CLEAR));
                        set_right_softkey_icon(NULL);
                        redraw_right_softkey();

                        gdi_layer_unlock_frame_buffer();

                        break;
                    }
                }
            }
        }
    }
#endif /* __MMI_UI_VIRTUAL_KEYBOARD_DEFAULT_VERSION_2__ */
    return MMI_FALSE;
}


/* For detail description, please refer to wgui_categories_inputs.h */
void ShowCategory28Screen(
        U16 title,
        U16 title_icon,
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        EMSData *data,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#if defined __MMI_LANG_HINDI__ && defined __MMI_BIDI_ALG__
    U16 unicode = 0;
    U16 clFill = 0;
#endif /*__MMI_BIDI_ALG__ */

    S32 ems_size = 0, sl_size = 0;
    wgui_cat28_history_cntx *cat_history = NULL;
    S32 highlight_text_index;

#if(UI_DISABLE_EMS_INPUT_BOX)
    S32 length;
    S32 i, j, h, fh;

    //UI_UNUSED_PARAMETER(history_buffer);
#else /* (UI_DISABLE_EMS_INPUT_BOX) */ 
    U8 h;
    S32 box_height;
#endif /* (UI_DISABLE_EMS_INPUT_BOX) */ 

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();
    gui_setup_common_layout();
    wgui_inputs_set_current_input_box_type(EDITOR_EMS_INPUT_BOX);

#ifndef __MMI_FTE_SUPPORT__
    wgui_inputbox_information_flag = 1;
    wgui_inputbox_information_bar_height = INFORMATION_BAR_HEIGHT;
    wgui_EMS_setup_input_information(
        0,
        (MMI_title_y + MMI_title_height),
        UI_device_width,
        wgui_inputbox_information_bar_height);
    wgui_inputs_setup_input_information(
        0,
        (MMI_title_y + MMI_title_height),
        UI_device_width,
        wgui_inputbox_information_bar_height);
#endif

    wgui_title_set_menu_shortcut_number(-1);
    change_left_softkey(left_softkey, left_softkey_icon);
    change_right_softkey(right_softkey, right_softkey_icon);
    SetupCategoryKeyHandlers();

    MMI_title_string = (UI_string_type) get_string(title);
    MMI_title_icon = (PU8) get_image(title_icon);

    g_wgui_cat28_cntx.ml_input_type = IMM_INPUT_TYPE_SENTENCE;
    g_wgui_cat28_cntx.right_softkey = right_softkey;
    g_wgui_cat28_cntx.right_softkey_icon = right_softkey_icon;

    /* Recipient header support */
    if (g_wgui_cat28_cntx.inline_recipients == MMI_TRUE)
    {
        MMI_CAT_SET_KEY_PROC(wgui_cat28_key_proc, NULL);

        if (history_buffer != NULL)
        {
            sl_size = sizeof(singleline_inputbox_category_history);
            sl_size = (sl_size + 3) / 4;
            sl_size *= 4;

            ems_size = sizeof(EMS_inputbox_category_history);
            ems_size = (ems_size + 3) / 4;
            ems_size *= 4;

            cat_history = (wgui_cat28_history_cntx*)(history_buffer + ems_size + sl_size);
                
            g_wgui_cat28_cntx.need_to_set_ml_ime = cat_history->need_to_set_ml_ime;
            g_wgui_cat28_cntx.need_to_set_sl_ime = cat_history->need_to_set_sl_ime;
            gui_memcpy(&g_wgui_cat28_cntx.ml_ime, &(cat_history->ml_ime), sizeof(mmi_imc_history));
            gui_memcpy(&g_wgui_cat28_cntx.sl_ime, &(cat_history->sl_ime), sizeof(mmi_imc_history));
        }
    }
  
#if(UI_DISABLE_EMS_INPUT_BOX)
    length = (data->textBufferSize >> 1);
    if (length == 0)
    {
        UI_string_type s = (UI_string_type) "EMS Data not initialized";
        S32 l = gui_strlen((UI_string_type) s);

        temp_EMS_buffer = (UI_string_type) gui_malloc(l * sizeof(UI_character_type));
        gui_strcpy((UI_string_type) temp_EMS_buffer, (UI_string_type) s);
        length = l + 1;
        i = j = l;
    }
    else
    {
        temp_EMS_buffer = (UI_string_type) gui_malloc(length * sizeof(UI_character_type));
        i = j = 0;
        while (j < data->textLength)
        {
            if ((data->textBuffer[j] == '\0') && (data->textBuffer[j + 1] == '\0'))
            {
                temp_EMS_buffer[i] = '\0';
                break;
            }
            else
            {
                temp_EMS_buffer[i] = data->textBuffer[j + 1];
            }
            i++;
            j += 2;
        }
    }
    temp_EMS_data = data;
    wgui_inputs_ml_create_set_buffer(temp_EMS_buffer, length, i, 0);
    wgui_inputs_ml_register_keys();
    h = MMI_content_height - MMI_multitap_height - 8;
    gui_set_font(MMI_multiline_inputbox.text_font);
    fh = gui_get_character_height();
    h = ((h / fh) * fh) + 8;
    wgui_inputs_ml_resize(WGUI_INPUTS_STYLE_DEFAULT, h);
    wgui_inputs_ml_set_mask(0);

    //set_right_softkey_function(handle_category28_right_softkey_down, KEY_EVENT_DOWN);
    //set_right_softkey_function(handle_category28_right_softkey_long_press, KEY_LONG_PRESS);
    wgui_inputs_ml_register_input_callback(handle_category28_input);
    category28_RSK_label_icon = get_image(right_softkey_icon);
    category28_RSK_label_string = get_string(right_softkey);
    handle_category28_input();
    if (wgui_inputs_ml_is_empty())
    {
        set_right_softkey_function(handle_category28_right_softkey_up, KEY_EVENT_UP);
    }

#ifdef __MMI_WALLPAPER_ON_BOTTOM__
    MMI_EMS_inputbox.flags |= UI_EMS_INPUT_BOX_TRANSPARENT_BACKGROUND;
    dm_get_scr_bg_opacity(&editor_scr_bg_opacity);
    dm_set_scr_bg_opacity((U8)(current_MMI_theme->bg_opacity_low));
#endif /* __MMI_WALLPAPER_ON_BOTTOM__ */ 

#else /* (UI_DISABLE_EMS_INPUT_BOX) */ 

#if((UI_ENABLE_FRAME_SKIPPING) && (ENABLE_EMS_INPUTBOX_FRAME_SKIPPING))
    wgui_EMS_inputbox_frame_counter = 0;
#endif 

#ifdef __MMI_MESSAGES_EMS__
    initialize_EMS_objects();
#endif 

    box_height = MMI_content_height - 13;

    register_EMS_inputbox_input_callback(UI_dummy_function);

    gui_create_EMS_input_box(
        &MMI_EMS_inputbox,
        0,
        (MMI_title_y + MMI_title_height) + wgui_EMS_inputbox_information_bar_height,
        UI_device_width,
        box_height);
    gui_set_EMS_input_box_data(&MMI_EMS_inputbox, data);
    h = set_EMS_inputbox_category_history(MMI_CATEGORY28_ID, history_buffer);
    if (h)
    {   /* Current alignment is not saved in history, so test it using a flag   */
        if (EMS_inputbox_alignment_added_flag)
        {
            wgui_EMS_text_format.Alignment = EMS_inputbox_alignment;
            MMI_EMS_inputbox.text_format.Alignment = EMS_inputbox_alignment;
            EMS_inputbox_alignment_added_flag = 0;
        }
    #ifdef __MMI_MESSAGES_EMS__
        gui_EMS_input_box_set_text_format_object(&MMI_EMS_inputbox, &wgui_EMS_text_format);
    #endif 
    }
    else
    {
        gui_EMS_input_box_set_text_format_cursor_position(&MMI_EMS_inputbox);
        wgui_EMS_text_format = MMI_EMS_inputbox.text_format;
    }

    /* Comment this line because this function will make the display_y change due to the inputbox size is not correct when show
       it will be resized in DM for VK */
    /* gui_EMS_input_box_locate_cursor(&MMI_EMS_inputbox);*/ 
    /* Switch IME by long press # */

    register_EMS_inputbox_keys();
    wgui_inputs_ems_register_pre_key_handler(wgui_cat28_editor_pre_key_hdlr);
    gui_inputs_set_pen_scrollbar_cb(wgui_cat28_editor_scrollbar_hdlr);
    //set_right_softkey_function(handle_category28_right_softkey_down, KEY_EVENT_DOWN);
    //set_right_softkey_function(handle_category28_right_softkey_long_press, KEY_LONG_PRESS);

#ifdef __MMI_WALLPAPER_ON_BOTTOM__
    MMI_EMS_inputbox.flags |= UI_EMS_INPUT_BOX_TRANSPARENT_BACKGROUND;
    dm_get_scr_bg_opacity(&editor_scr_bg_opacity);
    dm_set_scr_bg_opacity((U8)(current_MMI_theme->bg_opacity_low));
#endif /* __MMI_WALLPAPER_ON_BOTTOM__ */ 

    wgui_EMS_inputbox_information_icon = NULL;

    category28_RSK_label_icon = get_image(right_softkey_icon);
    category28_RSK_label_string = get_string(right_softkey);

#if(EMS_USE_INTERNAL_MENU)
    SetKeyHandler(EntryEMSMainMenu, KEY_SEND, KEY_EVENT_UP);
#endif 

    if (h)
    {
        if (g_wgui_cat28_cntx.inline_recipients == MMI_FALSE)
        {
            mmi_imc_set_input_method_history(&(((EMS_inputbox_category_history*)history_buffer)->ime_history));
        }
    }

    /* Recipient header support */
    if (g_wgui_cat28_cntx.inline_recipients == MMI_TRUE)
    {
        MMI_EMS_inputbox.flags |= UI_EMS_INPUT_BOX_DISPLAY_HEADER;
        MMI_EMS_inputbox.display_header = wgui_cat28_draw_editor_header;
        MMI_EMS_inputbox.measure_header = wgui_cat28_get_recipients_height;
        MMI_EMS_inputbox.pen_control_area_callback = EMS_recipient_pen_callback;

        /* auto add a new one */
        if (wgui_cat28_get_recipients_num() == 0)
        {
            wgui_cat28_insert_new_recipient(0, NULL, WGUI_CAT28_DEFAULT_FLAGS, MMI_TRUE);
        }
        /*
        wgui_inputs_sl_setup(
            0,
            0,
            MMI_content_width - g_wgui_cat28_cntx.max_label_width - (WGUI_CAT28_HEADER_GAP_X << 1) - MMI_EMS_inputbox.vbar.width,
            WGUI_CAT28_INLINE_SL_HEIGHT,
            g_wgui_cat28_cntx.recipient[0].input_buf,
            g_wgui_cat28_cntx.recipient_buffer_size,
            MMI_CATEGORY28_ID,
            get_string(right_softkey),
            get_image(right_softkey_icon),
            g_wgui_cat28_cntx.recipient_input_type,
            history_buffer + ems_size,
            0);
            */

        highlight_text_index = wgui_cat28_get_highlight_index();

        if ((history_buffer != NULL) && (g_wgui_cat28_add_recipients_in_BG == MMI_FALSE) && (highlight_text_index < 0))
        {
            if (cat_history->highlight_state == WGUI_CAT28_RECIPIENTS)
            {
                g_wgui_cat28_cntx.sl_history = (history_buffer + ems_size);
            }
            else
            {
                g_wgui_cat28_cntx.sl_history = NULL;
            }
            wgui_cat28_set_highlight_state_and_index(cat_history->highlight_state, cat_history->highlight_index);
        }
        else
        {
            /* if the recipient text is highlighted, we should move cursor to the end, 
               but should not to clear the history buffer, because we need to resume the IME state */
            if ((history_buffer != NULL) && 
                (g_wgui_cat28_add_recipients_in_BG == MMI_FALSE) && 
                (g_wgui_cat28_cntx.highlight_state == WGUI_CAT28_RECIPIENTS))
            {
                g_wgui_cat28_cntx.sl_history = (history_buffer + ems_size);
            }
            else
            {
                g_wgui_cat28_cntx.sl_history = NULL;
            }
            
            if ((g_wgui_cat28_cntx.highlight_state == WGUI_CAT28_EDITOR) && (highlight_text_index < 0))
            {
                wgui_cat28_set_highlight_state_and_index(WGUI_CAT28_EDITOR, -1);
            }
            else
            {
                if (highlight_text_index < 0)
                {
                    wgui_cat28_set_highlight_state_and_index(WGUI_CAT28_RECIPIENTS, g_wgui_cat28_cntx.highlight_index);
                }
                else
                {
                    if (cat_history->highlight_index != highlight_text_index)
                    {
                        g_wgui_cat28_cntx.sl_history = NULL;
                    }
                    wgui_cat28_set_highlight_state_and_index(WGUI_CAT28_RECIPIENTS, highlight_text_index);
                }
                
                /* adjust text_offset_y */
                MMI_EMS_inputbox.display_y -= wgui_inputs_EMS_is_area_visible(
                    WGUI_CAT28_HEADER_GAP_X + g_wgui_cat28_cntx.max_label_width + WGUI_CAT28_HEADER_GAP_X, 
                    WGUI_CAT28_HEADER_GAP_Y + (WGUI_CAT28_INLINE_SL_HEIGHT * g_wgui_cat28_cntx.highlight_index), 
                    MMI_content_width - g_wgui_cat28_cntx.max_label_width - (WGUI_CAT28_HEADER_GAP_X << 1) - MMI_EMS_inputbox.vbar.width,
                    WGUI_CAT28_INLINE_SL_HEIGHT, 
                    (WGUI_CAT28_HEADER_GAP_Y >> 1));
            }
        }
    }

#endif /* (UI_DISABLE_EMS_INPUT_BOX) */ 

    wgui_set_EMS_inputbox_RSK();

    gui_unlock_double_buffer();

    dm_register_category_controlled_callback(category28callback);
#if !defined(GUI_EDITOR_SHOW_TITLE)
    wgui_cat_setup_category(
        MMI_CATEGORY28_ID, 
        DM_CLEAR_SCREEN_BACKGROUND | DM_SHOW_VKPAD | DM_NO_TITLE, 
        ExitCategory28Screen, 
        GetCategory28History, 
        GetCategory28HistorySize);
#else /* !defined(GUI_EDITOR_SHOW_TITLE) */
    wgui_cat_setup_category(
        MMI_CATEGORY28_ID, 
        DM_CLEAR_SCREEN_BACKGROUND | DM_SHOW_VKPAD, 
        ExitCategory28Screen, 
        GetCategory28History, 
        GetCategory28HistorySize);
#endif /* !defined(GUI_EDITOR_SHOW_TITLE) */
    dm_register_vkpad_callback(cat28_virtual_keypad_callback);

    dm_redraw_category_screen();
}
#else /* __MMI_MSG_EDITOR_WITH_RECIPIENT__ */
/* For detail description, please refer to wgui_categories_inputs.h */
void ShowCategory28Screen(
        U16 title,
        U16 title_icon,
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        EMSData *data,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#if defined __MMI_LANG_HINDI__ && defined __MMI_BIDI_ALG__
    U16 unicode = 0;
    U16 clFill = 0;
#endif /*__MMI_BIDI_ALG__ */

#if(UI_DISABLE_EMS_INPUT_BOX)
    S32 length;
    S32 i, j, h, fh;

    UI_UNUSED_PARAMETER(history_buffer);
#else /* (UI_DISABLE_EMS_INPUT_BOX) */ 
    U8 h;
    S32 box_height;
#endif /* (UI_DISABLE_EMS_INPUT_BOX) */ 

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();
    gui_setup_common_layout();
    wgui_inputs_set_current_input_box_type(EDITOR_EMS_INPUT_BOX);

#if !defined(__MMI_FTE_SUPPORT__) && !defined(__OP01_FWPBW__)
    wgui_inputbox_information_flag = 1;
    wgui_inputbox_information_bar_height = INFORMATION_BAR_HEIGHT;
    wgui_EMS_setup_input_information(
        0,
        (MMI_title_y + MMI_title_height),
        UI_device_width,
        wgui_inputbox_information_bar_height);
#endif

    wgui_title_set_menu_shortcut_number(-1);
    change_left_softkey(left_softkey, left_softkey_icon);
    change_right_softkey(right_softkey, right_softkey_icon);
    SetupCategoryKeyHandlers();

    MMI_title_string = (UI_string_type) get_string(title);
    MMI_title_icon = (PU8) get_image(title_icon);

#if(UI_DISABLE_EMS_INPUT_BOX)
    length = (data->textBufferSize >> 1);
    if (length == 0)
    {
        UI_string_type s = (UI_string_type) "EMS Data not initialized";
        S32 l = gui_strlen((UI_string_type) s);

        temp_EMS_buffer = (UI_string_type) gui_malloc(l * sizeof(UI_character_type));
        gui_strcpy((UI_string_type) temp_EMS_buffer, (UI_string_type) s);
        length = l + 1;
        i = j = l;
    }
    else
    {
        temp_EMS_buffer = (UI_string_type) gui_malloc(length * sizeof(UI_character_type));
        i = j = 0;
        while (j < data->textLength)
        {
            if ((data->textBuffer[j] == '\0') && (data->textBuffer[j + 1] == '\0'))
            {
                temp_EMS_buffer[i] = '\0';
                break;
            }
            else
            {
                temp_EMS_buffer[i] = data->textBuffer[j + 1];
            }
            i++;
            j += 2;
        }
    }
    temp_EMS_data = data;
    wgui_inputs_ml_create_set_buffer(temp_EMS_buffer, length, i, 0);
    wgui_inputs_ml_register_keys();
    h = MMI_content_height - MMI_multitap_height - 8;
    gui_set_font(MMI_multiline_inputbox.text_font);
    fh = gui_get_character_height();
    h = ((h / fh) * fh) + 8;
    wgui_inputs_ml_resize(WGUI_INPUTS_STYLE_DEFAULT, h);
    wgui_inputs_ml_set_mask(0);

    //set_right_softkey_function(handle_category28_right_softkey_down, KEY_EVENT_DOWN);
    //set_right_softkey_function(handle_category28_right_softkey_long_press, KEY_LONG_PRESS);
    wgui_inputs_ml_register_input_callback(handle_category28_input);
    category28_RSK_label_icon = get_image(right_softkey_icon);
    category28_RSK_label_string = get_string(right_softkey);
    handle_category28_input();
    if (wgui_inputs_ml_is_empty())
    {
        set_right_softkey_function(handle_category28_right_softkey_up, KEY_EVENT_UP);
    }

#ifdef __MMI_WALLPAPER_ON_BOTTOM__
    MMI_EMS_inputbox.flags |= UI_EMS_INPUT_BOX_TRANSPARENT_BACKGROUND;
    dm_get_scr_bg_opacity(&editor_scr_bg_opacity);
    dm_set_scr_bg_opacity((U8)(current_MMI_theme->bg_opacity_low));
#endif /* __MMI_WALLPAPER_ON_BOTTOM__ */ 

#else /* (UI_DISABLE_EMS_INPUT_BOX) */ 

#if((UI_ENABLE_FRAME_SKIPPING) && (ENABLE_EMS_INPUTBOX_FRAME_SKIPPING))
    wgui_EMS_inputbox_frame_counter = 0;
#endif 

#ifdef __MMI_MESSAGES_EMS__
    initialize_EMS_objects();
#endif 

    box_height = MMI_content_height - 13;
    register_EMS_inputbox_input_callback(UI_dummy_function);

    gui_create_EMS_input_box(
        &MMI_EMS_inputbox,
        0,
        (MMI_title_y + MMI_title_height) + wgui_EMS_inputbox_information_bar_height,
        UI_device_width,
        box_height);
    gui_set_EMS_input_box_data(&MMI_EMS_inputbox, data);
    h = set_EMS_inputbox_category_history(MMI_CATEGORY28_ID, history_buffer);
    if (h)
    {   /* Current alignment is not saved in history, so test it using a flag   */
        if (EMS_inputbox_alignment_added_flag)
        {
            wgui_EMS_text_format.Alignment = EMS_inputbox_alignment;
            MMI_EMS_inputbox.text_format.Alignment = EMS_inputbox_alignment;
            EMS_inputbox_alignment_added_flag = 0;
        }
    #ifdef __MMI_MESSAGES_EMS__
        gui_EMS_input_box_set_text_format_object(&MMI_EMS_inputbox, &wgui_EMS_text_format);
    #endif 
    }
    else
    {
        gui_EMS_input_box_set_text_format_cursor_position(&MMI_EMS_inputbox);
        wgui_EMS_text_format = MMI_EMS_inputbox.text_format;
    }

    /* Comment this line because this function will make the display_y change due to the inputbox size is not correct when show
       it will be resized in DM for VK */
    /* gui_EMS_input_box_locate_cursor(&MMI_EMS_inputbox);*/ 
    /* Switch IME by long press # */

    register_EMS_inputbox_keys();
    //set_right_softkey_function(handle_category28_right_softkey_down, KEY_EVENT_DOWN);
    //set_right_softkey_function(handle_category28_right_softkey_long_press, KEY_LONG_PRESS);

#ifdef __MMI_WALLPAPER_ON_BOTTOM__
    MMI_EMS_inputbox.flags |= UI_EMS_INPUT_BOX_TRANSPARENT_BACKGROUND;
    dm_get_scr_bg_opacity(&editor_scr_bg_opacity);
    dm_set_scr_bg_opacity((U8)(current_MMI_theme->bg_opacity_low));
#endif /* __MMI_WALLPAPER_ON_BOTTOM__ */ 

    wgui_EMS_inputbox_information_icon = NULL;

    category28_RSK_label_icon = get_image(right_softkey_icon);
    category28_RSK_label_string = get_string(right_softkey);

#if(EMS_USE_INTERNAL_MENU)
    SetKeyHandler(EntryEMSMainMenu, KEY_SEND, KEY_EVENT_UP);
#endif 

    if (h)
    {
        mmi_imc_set_input_method_history(&(((EMS_inputbox_category_history*)history_buffer)->ime_history));
    }

    mmi_imm_set_required_mode_list(IMM_INPUT_TYPE_SENTENCE, NULL, IMM_INPUT_MODE_NONE);
    g_mmi_editor_hanler.input_box_type = MMI_EDITOR_EMS_INPUT_BOX;
    g_mmi_editor_hanler.input_box_sub_type = MMI_EDITOR_NORMAL_INPUT_BOX;
    g_mmi_editor_hanler.input_box_handler = &MMI_EMS_inputbox;
    mmi_imc_connect((void *)&g_mmi_editor_hanler, mmi_input_box_msg_call_back_ems);
    
#endif /* (UI_DISABLE_EMS_INPUT_BOX) */ 

    wgui_set_EMS_inputbox_RSK();

    gui_unlock_double_buffer();

    dm_register_category_controlled_callback(category28callback);
#if !defined(GUI_EDITOR_SHOW_TITLE)
        wgui_cat_setup_category_default_history(
            MMI_CATEGORY28_ID, 
            DM_CLEAR_SCREEN_BACKGROUND | DM_SHOW_VKPAD | DM_NO_TITLE, 
            ExitCategory28Screen);
#else /* !defined(GUI_EDITOR_SHOW_TITLE) */
        wgui_cat_setup_category_default_history(
            MMI_CATEGORY28_ID, 
            DM_CLEAR_SCREEN_BACKGROUND | DM_SHOW_VKPAD, 
            ExitCategory28Screen);
#endif /* !defined(GUI_EDITOR_SHOW_TITLE) */

    dm_register_vkpad_callback(cat28_virtual_keypad_callback);

    dm_redraw_category_screen();
    
}
#endif /* __MMI_MSG_EDITOR_WITH_RECIPIENT__ */

/*****************************************************************************
 * FUNCTION
 *  mmi_input_box_msg_call_back_ems
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
U32 mmi_input_box_msg_call_back_ems(void * input_box_handle, mmi_imc_message_struct_p msg_ptr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#if defined(__MMI_TOUCH_SCREEN__)
    gui_EMS_input_box_pen_enum EMS_input_box_event = GUI_EMS_INPUT_BOX_PEN_NONE;
	static EMSPosition    pen_down_current_position;
	static MMI_BOOL position_reserved = MMI_FALSE;
#endif 
    UI_EMS_input_box * editor_ptr;
    MMI_BOOL ret = MMI_FALSE;
    S32 i, str_len, total_len = 0;
    U32 lresult = 0;
    UI_string_type temp_str;
    UI_character_type ch;    
    U32 old_show_action_flag;
#ifdef __MMI_CLIPBOARD__
    EMSPosition cut_cursor_p,temp_position;
    U32 cursor_move_old_flags;
    U8 pre_obj;
    UI_character_type c;
    EMSObject *obj;
    U32 highlight_count = 0;
#endif /* __MMI_CLIPBOARD__ */
    
#ifdef __UI_EMS_HIGHLIGHT_LIST_SUPPORT__
    static MMI_BOOL pen_down_clipboard_state = MMI_FALSE;
#endif /* __UI_EMS_HIGHLIGHT_LIST_SUPPORT__ */
    static MMI_BOOL enable_editor_show = MMI_TRUE;

#ifdef __MMI_EDITOR_SSP_SUPPORT__
    MMI_BOOL is_ssp = MMI_FALSE;
#endif /* __MMI_EDITOR_SSP_SUPPORT__ */

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    editor_ptr = (UI_EMS_input_box *)((mmi_editor_handler_struct *)input_box_handle)->input_box_handler;
    
    MMI_ASSERT(editor_ptr == &MMI_EMS_inputbox);

    switch (msg_ptr->message_id)
    {
    case MMI_IMC_MESSAGE_INSERT_CHAR:
#ifdef __MMI_EDITOR_SSP_SUPPORT__
        {
            mmi_pen_point_struct point = {0, 0};
        
            if (gui_input_box_ssp_is_scrolling())
            {
                gui_input_box_ssp_pen_translate(point, MMI_PEN_EVENT_ABORT);
                gui_EMS_input_box_locate_cursor(&MMI_EMS_inputbox);
            }
        }
#endif        
        lresult = EMS_inputbox_direct_input((UI_character_type)msg_ptr->param_0);

            break;
        
    case MMI_IMC_MESSAGE_INSERT_STRING:
        
#ifdef __MMI_EDITOR_SSP_SUPPORT__
        {
            mmi_pen_point_struct point = {0, 0};
            
            if (gui_input_box_ssp_is_scrolling())
            {
                gui_input_box_ssp_pen_translate(point, MMI_PEN_EVENT_ABORT);
                gui_EMS_input_box_locate_cursor(&MMI_EMS_inputbox);
            }
        }
#endif 
        temp_str = (UI_string_type)msg_ptr->param_0;
        
        str_len = (S32)mmi_ucs2strlen((const S8 *)temp_str);

        old_show_action_flag = editor_ptr->show_action_flag;
                
        editor_ptr->show_action_flag = 0;
        
        for (i = 0; i < str_len; i++)
        {
            /* TODO: Insert successfully? */
            if (EMS_inputbox_direct_input_no_draw((UI_character_type)temp_str[i]))
            {
                total_len ++;
            }
            else
            {
                break;
            }
        }
        
        editor_ptr->show_action_flag = old_show_action_flag;
		
		gui_EMS_input_box_locate_cursor(editor_ptr);
        
#ifdef GUI_INPUT_BOX_CACHE_SUPPORT
        if (str_len > 10)
        {
            gui_emsc_all_line_update();
        }
#endif
        if (enable_editor_show)
        {
            redraw_EMS_inputbox();
        }
        EMS_inputbox_input_callback();
        
        lresult = total_len;
        
            break;
        case MMI_IMC_MESSAGE_INSERT_STRING_NO_DRAW:

            temp_str = (UI_string_type)msg_ptr->param_0;

            str_len = (S32)mmi_ucs2strlen((const S8 *)temp_str);

            for (i = 0; i < str_len; i++)
            {
                /* TODO: Insert successfully? */
                if (EMS_inputbox_direct_input_no_draw((UI_character_type)temp_str[i]))
                {
                    total_len ++;
                }
                else
                {
                    break;
                }
            }
            EMS_inputbox_input_callback();

            lresult = total_len;
            break;
        
	case MMI_IMC_MESSAGE_REPLACE_HIGHLIGHT_STRING:

		old_show_action_flag = editor_ptr->show_action_flag;
		
        editor_ptr->show_action_flag = 0;

		for (i = 0; i < msg_ptr->param_0; i ++)
        {
            EMS_inputbox_backspace_no_draw();
        }

		temp_str = (UI_string_type)msg_ptr->param_1;
        
        str_len = (S32)mmi_ucs2strlen((const S8 *)temp_str);
		
        for (i = 0; i < str_len; i++)
        {
            /* TODO: Insert successfully? */
            if (EMS_inputbox_direct_input_no_draw((UI_character_type)temp_str[i]))
            {
                total_len ++;
            }
            else
            {
                break;
            }
        }

		if (total_len)
		{
            gui_EMS_input_box_highlight_cursor_number(editor_ptr, (S32)total_len);
		}

        else
        {
            /* if no character gets inserted , no character will be highlighted*/
            editor_ptr->flags &= ~UI_EMS_INPUT_BOX_WORD_HIGHLIGHT;
            memset(&editor_ptr->highlight_start_position, 0, sizeof(EMSPosition));
            memset(&editor_ptr->highlight_end_position, 0, sizeof(EMSPosition));
        }

		editor_ptr->show_action_flag = old_show_action_flag;
		
		gui_EMS_input_box_locate_cursor(editor_ptr);
        
        if (enable_editor_show)
        {
            redraw_EMS_inputbox();
        }

        EMS_inputbox_input_callback();
        
        lresult = total_len;

		break;
        
    case MMI_IMC_MESSAGE_INSERT_PAIRED_SYMBOLS:
        temp_str = (UI_string_type)msg_ptr->param_0;
        
        str_len = (S32)mmi_ucs2strlen((const S8 *)temp_str);
        
        old_show_action_flag = editor_ptr->show_action_flag;
        
        editor_ptr->show_action_flag = 0;
        
        for (i = 0; i < str_len; i++)
        {
            /* TODO: Insert successfully? */
            if (EMS_inputbox_direct_input_no_draw((UI_character_type)temp_str[i]))
            {
                total_len ++;
            }
            else
            {
                break;
            }
        }
        
        editor_ptr->show_action_flag = old_show_action_flag;
        
        gui_EMS_input_box_locate_cursor(editor_ptr);
        
        if (enable_editor_show)
        {
            redraw_EMS_inputbox();
        }

        EMS_inputbox_input_callback();

        if (total_len == str_len)
        {
            EMS_inputbox_previous();
            lresult = MMI_TRUE;
        }
        else
        {
            lresult = MMI_FALSE;
        }    
        
        break;
    
	case MMI_IMC_MESSAGE_GET_HIGHLIGHT_WORD:
        if (editor_ptr->flags & UI_EMS_INPUT_BOX_WORD_HIGHLIGHT)
        {
            *((UI_buffer_type *)(msg_ptr->param_0)) = MMI_EMS_inputbox.data->textBuffer + MMI_EMS_inputbox.highlight_start_position.OffsetToText;
            *((UI_buffer_type *)(msg_ptr->param_1)) = MMI_EMS_inputbox.data->textBuffer + MMI_EMS_inputbox.highlight_end_position.OffsetToText;
            lresult = (U32)((MMI_EMS_inputbox.highlight_end_position.OffsetToText - MMI_EMS_inputbox.highlight_start_position.OffsetToText) / ENCODING_LENGTH);
        }
        else
        {
            *((UI_buffer_type *)(msg_ptr->param_0)) = 0;
            *((UI_buffer_type *)(msg_ptr->param_1)) = 0;
            lresult = 0;
        }
        break;
		
    case MMI_IMC_MESSAGE_MOVE_CURSOR_TO_HIGHLIGHT_START:
        if (MMI_EMS_inputbox.flags & UI_EMS_INPUT_BOX_WORD_HIGHLIGHT)
        {
            EMSPosition temp_position;
            U8 ret;
            UI_character_type c;
            EMSObject *obj;

            memcpy(&temp_position, &MMI_EMS_inputbox.highlight_start_position, sizeof(EMSPosition));
            
            MoveCursorToPosition(MMI_EMS_inputbox.data, &temp_position);

        #ifdef GUI_INPUT_BOX_CACHE_SUPPORT
            gui_emsc_all_line_update();
        #endif

            gui_EMS_input_box_locate_cursor(&MMI_EMS_inputbox);

            gui_show_EMS_input_box(&MMI_EMS_inputbox);

            while (!TestFirstPosition(MMI_EMS_inputbox.data, &MMI_EMS_inputbox.data->CurrentPosition)) /* Go to the end of the previous word */
			{
				memcpy(&temp_position, &MMI_EMS_inputbox.data->CurrentPosition, sizeof(EMSPosition));

				ret = gui_EMS_input_box_get_previous_object(MMI_EMS_inputbox.data, &temp_position, &c, &obj);
				
				if (ret == 2 && obj->Type == EMS_TYPE_TEXT_FORMAT)
				{
					ret = gui_EMS_input_box_get_previous_object(MMI_EMS_inputbox.data, &temp_position, &c, &obj);
				}
				
				if (ret == 2 || ret == 0)
				{
					break;
				}	
				else if (c == 0x20) 
				{
                    gui_EMS_input_box_previous(&MMI_EMS_inputbox);
				}
				else
				{
					break;
				}
			}
            
            gui_EMS_input_box_set_text_format_cursor_position(&MMI_EMS_inputbox);

            wgui_EMS_text_format = MMI_EMS_inputbox.text_format;
            
            lresult = 1;
        }
        break;
        
    case MMI_IMC_MESSAGE_DELETE_STRING:
        old_show_action_flag = MMI_EMS_inputbox.show_action_flag;
        MMI_EMS_inputbox.show_action_flag = 0;

        for (i = 0; i < msg_ptr->param_0; i ++)
        {
            EMS_inputbox_backspace_no_draw();
        }
        
        MMI_EMS_inputbox.show_action_flag = old_show_action_flag;
        gui_EMS_input_box_locate_cursor(&MMI_EMS_inputbox);
        
        if (!msg_ptr->param_1)
        {
            if (enable_editor_show)
            {
                redraw_EMS_inputbox();
            }
        }
        
        EMS_inputbox_input_callback();
            break;
        
    case MMI_IMC_MESSAGE_GET_TEXT_LENGTH:
        lresult = (U32)(editor_ptr->data->textLength / ENCODING_LENGTH);
        break;
        
    case MMI_IMC_MESSAGE_CHANGE_TO_INITIAL:
            break;
        
    case MMI_IMC_MESSAGE_INSERT_MULTITAP_CHAR:
        ch = (UI_character_type)msg_ptr->param_0;
        lresult = EMS_inputbox_multitap_input_no_draw(ch);
        if (enable_editor_show)
        {
            redraw_EMS_inputbox();
        }

        if(lresult == MMI_TRUE) lresult = 1;
            break;

	case MMI_IMC_MESSAGE_INSERT_MULTITAP_STRING:
        temp_str = (UI_string_type)msg_ptr->param_0;
        /* Insert the string in editor */
        lresult = EMS_inputbox_multitap_input_string((PU8)temp_str);
	        break;

    case MMI_IMC_MESSAGE_RESET_MULTITAP_STATE:
        EMS_inputbox_multitap_input_complete_no_draw();
        if (enable_editor_show)
        {
            redraw_EMS_inputbox();
        }
        gui_ems_input_box_stop_input(editor_ptr);
            break;

    case MMI_IMC_MESSAGE_DELETE_CHAR:
        {
            U16 keyCode, keyType;
            mmi_frm_get_key_info(&keyCode, &keyType);
            if (keyType == KEY_REPEAT)
            {
                wgui_inputs_fast_del_nav_handler(WGUI_INPUTS_OPER_FAST_DEL, WGUI_INPUTS_EDITOR_EMS, WGUI_INPUTS_KPD_REPEAT_PERIOD);
            }
            else
            {
                for (i = 0; i < msg_ptr->param_0; i++)
                {
                    EMS_inputbox_backspace_no_draw();
                }
                if (enable_editor_show)
                {
                    redraw_EMS_inputbox();
                }
                EMS_inputbox_input_callback();
            }
            break;
        }
    case MMI_IMC_MESSAGE_CLEAR_ALL:
    #ifdef __MMI_TOUCH_SCREEN__
        wgui_inputs_fast_del_pen_handler(WGUI_INPUTS_OPER_FAST_DEL, WGUI_INPUTS_EDITOR_EMS, MMI_PEN_EVENT_LONG_TAP);
    #else
        wgui_inputs_fast_del_nav_reset_repeat_count();
    #endif
        break;

    case MMI_IMC_MESSAGE_BACKSPACE_KEY_EVENT:
    #ifdef __MMI_TOUCH_SCREEN__
        wgui_inputs_fast_del_pen_handler(WGUI_INPUTS_OPER_FAST_DEL, WGUI_INPUTS_EDITOR_EMS, (mmi_pen_event_type_enum)msg_ptr->param_0);
    #endif
        break;
        
    case MMI_IMC_MESSAGE_GET_CURSOR_RECT:
        ((mmi_imc_rect_p)msg_ptr->param_0)->x = UI_cursor_x1;
        ((mmi_imc_rect_p)msg_ptr->param_0)->y = UI_cursor_y1;
        ((mmi_imc_rect_p)msg_ptr->param_0)->width = UI_cursor_x2 - UI_cursor_x1 + 1;
        ((mmi_imc_rect_p)msg_ptr->param_0)->height = UI_cursor_y2 - UI_cursor_y1 + 1;
        lresult = MMI_TRUE;
        break;

    case MMI_IMC_MESSAGE_MOVE_CURSOR:
        switch (msg_ptr->param_0)
        {
            case MMI_IMC_EDITOR_CURSOR_UP:
                for (i = 0; i <(S32)msg_ptr->param_1; i ++)
                {
                    EMS_inputbox_previous_line();
                }
            break;
            case MMI_IMC_EDITOR_CURSOR_DOWN:
                for (i = 0; i <(S32)msg_ptr->param_1; i ++)
                {
                    EMS_inputbox_next_line();
                }
            break;
            case MMI_IMC_EDITOR_CURSOR_LEFT:
                for (i = 0; i <(S32)msg_ptr->param_1; i ++)
                {
                    EMS_inputbox_previous();
                }
            break;
            case MMI_IMC_EDITOR_CURSOR_RIGHT:
                for (i = 0; i <(S32)msg_ptr->param_1; i ++)
                {
                    EMS_inputbox_next();
                }
            break;
        }
        break;
    	case MMI_IMC_MESSAGE_IS_THERE_CURSOR:
        if (editor_ptr->flags & UI_EMS_INPUT_BOX_VIEW_MODE)
        {
            lresult = MMI_FALSE;
        }
        else
        {
            lresult = MMI_TRUE;
        }
            break;
    case MMI_IMC_MESSAGE_HILIGHT_BFCURSOR:
        gui_EMS_input_box_highlight_cursor_number(editor_ptr, (S32)msg_ptr->param_0);
        if (enable_editor_show)
        {
            redraw_EMS_inputbox();
        }
            break;
    case MMI_IMC_MESSAGE_CLEAR_HILIGHT:
        editor_ptr->flags &= ~UI_EMS_INPUT_BOX_WORD_HIGHLIGHT;
        memset(&editor_ptr->highlight_start_position, 0, sizeof(EMSPosition));
        memset(&editor_ptr->highlight_end_position, 0, sizeof(EMSPosition));
            break;
    case MMI_IMC_MESSAGE_GET_INPUT_BOX_RECT:
        ((mmi_imc_rect_p)msg_ptr->param_0)->x = editor_ptr->x;
        ((mmi_imc_rect_p)msg_ptr->param_0)->y = editor_ptr->y;
        ((mmi_imc_rect_p)msg_ptr->param_0)->width = editor_ptr->width;
        ((mmi_imc_rect_p)msg_ptr->param_0)->height = editor_ptr->height;
            break;
       
    case MMI_IMC_MESSAGE_RESIZE:
    #ifdef __MMI_CLIPBOARD__
        /* DONOT resize editor for EMS viewer screen because of the tool bar icon and softkey bar */
        if (((mmi_editor_handler_struct *)input_box_handle)->input_box_sub_type != MMI_EDITOR_INPUT_BOX_READ_ONLY)
    #endif
        {
            if (msg_ptr->param_0 != MMI_EMS_inputbox.width || msg_ptr->param_1 != MMI_EMS_inputbox.height)
                resize_EMS_inputbox((S32)msg_ptr->param_0, (S32)msg_ptr->param_1);
        }
        break;
    case MMI_IMC_MESSAGE_REDRAW:

#ifdef __MMI_EDITOR_SSP_SUPPORT__
        {
            mmi_pen_point_struct point = {0, 0};
            
            if (gui_input_box_ssp_is_scrolling())
            {
                gui_input_box_ssp_pen_translate(point, MMI_PEN_EVENT_ABORT);
            }

            gui_EMS_input_box_locate_cursor(&MMI_EMS_inputbox);
        }
#endif

        if (enable_editor_show)
        {
            if (msg_ptr->param_0 == 1)
            {
                dm_imui_window_hide();
            }
            else
            {
                gui_EMS_input_box_locate_cursor(editor_ptr);
                redraw_EMS_inputbox();
            }
        }
        break;

    case MMI_IMC_MESSAGE_FLOATING_UI_APPEAR_INDICATION:
        dm_imui_window_display();
        break;
        
    case MMI_IMC_MESSAGE_CONFIG_EDITOR_SHOW:
        enable_editor_show = (MMI_BOOL)msg_ptr->param_0;
        break;

    case MMI_IMC_MESSAGE_DRAW_INFORMATION_BAR:

        wgui_EMS_redraw_input_information_bar();
		
        break;
    case MMI_IMC_MESSAGE_STOP_SMART_ALPHABETIC:
        gui_ems_input_box_stop_input(editor_ptr);
        break;
    case MMI_IMC_MESSAGE_START_SMART_ALPHABETIC:
        gui_ems_input_box_start_input(editor_ptr);
        break;
    case MMI_IMC_MESSAGE_UPDATE_SOFTKEY:
        break;
    case MMI_IMC_MESSAGE_KEY_EVENT:
        break;
    case MMI_IMC_MESSAGE_MODE_CHANGED:
        break;
#if defined(__MMI_TOUCH_SCREEN__)

    case MMI_IMC_MESSAGE_GET_HANDWRITING_RECT:
        if (mmi_fe_get_r2l_state())
        {
            ((mmi_imc_rect_p)msg_ptr->param_0)->x = editor_ptr->x + editor_ptr->vbar.width;
        }
        else
        {
            ((mmi_imc_rect_p)msg_ptr->param_0)->x = editor_ptr->x;
        }
        
        ((mmi_imc_rect_p)msg_ptr->param_0)->y = editor_ptr->y;
        ((mmi_imc_rect_p)msg_ptr->param_0)->width = editor_ptr->width - editor_ptr->vbar.width;
        ((mmi_imc_rect_p)msg_ptr->param_0)->height = editor_ptr->height;
        break;
        
    case MMI_IMC_MESSAGE_PEN_EVENT:

#ifdef __MMI_EDITOR_SSP_SUPPORT__
        is_ssp = gui_input_box_ssp_is_scrolling();
#endif /* __MMI_EDITOR_SSP_SUPPORT__ */

        ret = (MMI_BOOL)gui_EMS_input_box_translate_pen_event(
                        editor_ptr,
                        ((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->mmi_pen_event,
                        ((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos.x,
                        ((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos.y,
                        &EMS_input_box_event);
        if (ret)
        {
            EMSPosition backup_cursor = editor_ptr->data->CurrentPosition;
            ((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->editor_pen_event = (mmi_imc_editor_pen_event_enum)EMS_input_box_event;

            if (GUI_EMS_INPUT_BOX_PEN_SCROLL_BAR != EMS_input_box_event 
                && ((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->mmi_pen_event == MMI_PEN_EVENT_DOWN)
            {
                if (!(editor_ptr->flags & UI_EMS_INPUT_BOX_VIEW_MODE))
                {
                    EMSTextFormat text_format;
                    U32 is_disabled_drawing = (editor_ptr->flags & UI_EMS_INPUT_BOX_DISABLE_DRAW);

                    text_format = editor_ptr->text_format;

                    if (!is_disabled_drawing)
                    {
                        editor_ptr->flags |= UI_EMS_INPUT_BOX_DISABLE_DRAW;
                    }

                    gui_show_EMS_input_box_ext(editor_ptr, 
                                               ((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos.x, 
                                               ((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos.y);

                    if (!is_disabled_drawing)
                    {
                        editor_ptr->flags &= ~UI_EMS_INPUT_BOX_DISABLE_DRAW;
                    }

                    pen_down_current_position = editor_ptr->data->CurrentPosition;

                    /* Only reserve the position when pos changed */
                    if (pen_down_current_position.OffsetToText != backup_cursor.OffsetToText ||
                        pen_down_current_position.Object != backup_cursor.Object)
                    {
                        position_reserved = MMI_TRUE;
                    }
                    else
                    {
                        /* Reset format if position not change */
                        editor_ptr->text_format = text_format;
                    }

                    MoveCursorToPosition(editor_ptr->data, &backup_cursor);
                }
            #ifdef __UI_EMS_HIGHLIGHT_LIST_SUPPORT__    
                else
                {
                    if (mmi_imc_is_clipboard_state())
                    {
                        pen_down_clipboard_state = MMI_TRUE;
                    }
                    else
                    {
                        pen_down_clipboard_state = MMI_FALSE;
                    }
                }
            #endif /* __UI_EMS_HIGHLIGHT_LIST_SUPPORT__ */
                if (EMS_input_box_event == GUI_EMS_INPUT_BOX_PEN_CONTROL_AREA)
                {
                    *((U32 *)msg_ptr->param_1) = 0;
                }
                else
                {
                    *((U32 *)msg_ptr->param_1) = 1;
                }
            }
            else if (GUI_EMS_INPUT_BOX_PEN_SCROLL_BAR != EMS_input_box_event 
                     && ((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->mmi_pen_event == MMI_PEN_EVENT_UP)
            {
                if ((!(editor_ptr->flags & UI_EMS_INPUT_BOX_VIEW_MODE)) && (!(editor_ptr->flags & UI_EMS_INPUT_BOX_DISABLE_CURSOR_DRAW)))
                {
                    if (position_reserved)
                    {
                        MoveCursorToPosition(editor_ptr->data, &pen_down_current_position);
                        gui_EMS_input_box_set_text_format_cursor_position(editor_ptr);
                        position_reserved = MMI_FALSE;
                        gui_EMS_input_box_locate_cursor(editor_ptr);
                        wgui_EMS_set_text_format(editor_ptr->text_format);
                        redraw_EMS_inputbox();
                    } 
                    msg_ptr->param_1 = 1;
                }
#ifdef __MMI_EDITOR_SSP_SUPPORT__
                else if(!is_ssp)
#else
                else
#endif
                {

                #ifdef __UI_EMS_HIGHLIGHT_LIST_SUPPORT__
                    /* Highlight object only when hilite list is null. */
                    if (MMI_EMS_inputbox.hilite_str_number != 0)
                    {
                        if (!mmi_imc_is_clipboard_state() && !pen_down_clipboard_state)
                        {
                            gui_show_EMS_input_box_ext(&MMI_EMS_inputbox,
                                ((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos.x,
                                ((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos.y);
                            gui_EMS_input_box_locate_cursor(&MMI_EMS_inputbox);
                            if (gui_EMS_input_box_is_pen_down_in_hilite(&MMI_EMS_inputbox))
					        {
                                gui_EMS_input_box_go_to_hilite(&MMI_EMS_inputbox,MMI_EMS_inputbox.current_hilite_idx);
                                redraw_EMS_inputbox();
                                MMI_EMS_inputbox.hilite_click_cb(MMI_EMS_inputbox.current_hilite_idx);
                            }
                        }
                    }
                    else
                #endif /* __UI_EMS_HIGHLIGHT_LIST_SUPPORT__ */
                    {
                        /* if disable cursor draw, we should not to locate cursor */
                        if (!(editor_ptr->flags & UI_EMS_INPUT_BOX_DISABLE_CURSOR_DRAW))    
                        {
                        #ifdef __MMI_MESSAGES_EMS__
                            EMS_cancel_object_focus(); 
                        #endif
                            gui_show_EMS_input_box_ext(&MMI_EMS_inputbox,
                                ((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos.x,
                                ((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos.y);
                            gui_EMS_input_box_locate_cursor(&MMI_EMS_inputbox);
                            redraw_EMS_inputbox();
                        }
                    }
                }
            }
            else if (((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->mmi_pen_event == MMI_PEN_EVENT_MOVE)
            {
            	position_reserved = MMI_FALSE;
            }
#ifdef __MMI_CLIPBOARD__
            else if (GUI_EMS_INPUT_BOX_PEN_SCROLL_BAR != EMS_input_box_event 
					 && ((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->mmi_pen_event == MMI_PEN_EVENT_LONG_TAP)
            {
                *((U32 *)msg_ptr->param_1) = 1;
            }
#endif /* __MMI_CLIPBOARD__ */
        }
        else
        {
            position_reserved = MMI_FALSE;
        }
        
        lresult = ret;
        
        break;
        
    case MMI_IMC_MESSAGE_GET_HANDWRITING_STYLE:
        
    #if defined(__MMI_HANDWRITING_MULTI_BLOCK__)
        lresult = MMI_IMC_PEN_HANDWRITING_STYLE_MULTI_BLOCK;
    #else
        lresult = MMI_IMC_PEN_HANDWRITING_STYLE_FULL_SCREEN;
    #endif

        break;
#endif
    case MMI_IMC_MESSAGE_INSERT_NEW_LINE:
        EMS_inputbox_insert_new_line();
        if (enable_editor_show)
        {
            redraw_EMS_inputbox();
        }
        break;
    case MMI_IMC_MESSAGE_GET_TEXT:
        temp_str = (UI_string_type)msg_ptr->param_1;
        for (i = 0; i <msg_ptr->param_0; i ++)
        {
            if (!gui_EMS_input_box_get_previous_character((UI_EMS_input_box *)editor_ptr, &temp_str[i]))
            {
                break;
            }
        }
        lresult = i;
        break;
    case MMI_IMC_MESSAGE_IS_EDITOR_EMPTY:
        lresult = gui_EMS_inputbox_empty((UI_EMS_input_box *)editor_ptr);
        break;
    case MMI_IMC_MESSAGE_GET_PREVIOUS_CHAR:
        lresult = gui_EMS_input_box_get_previous_character(editor_ptr, (UI_character_type *)msg_ptr->param_0);
        break;
        
    case MMI_IMC_MESSAGE_SET_MASK:
    case MMI_IMC_MESSAGE_DECIAML_CHECK:
    case MMI_IMC_MESSAGE_DECIMAL_INPUT:
    case MMI_IMC_MESSAGE_INSERT_DECIMAL_SYMBOL:    
        ASSERT(0);
        break;

    case MMI_IMC_MESSAGE_IS_EDITOR_IN_REPLACE_MODE:
    case MMI_IMC_MESSAGE_CHECK_MULTITAP_STATE:
        if (editor_ptr->flags & UI_EMS_INPUT_BOX_STATE_MULTITAP)
            lresult = MMI_TRUE;
        break;
    case MMI_IMC_MESSAGE_INSERT_SPACE:
        EMS_inputbox_direct_input((UI_character_type)(0x20));
        break;        
    case MMI_IMC_MESSAGE_SET_KEY:
        if (!(editor_ptr->flags & UI_EMS_INPUT_BOX_VIEW_MODE))
        {
            register_EMS_inputbox_keys();
        #ifdef __OP01_FWPBW__
            if (msg_ptr->param_0 == 1)
            {
                wgui_set_EMS_inputbox_RSK_no_show_counter();
            }
            else
        #endif
            {
                wgui_set_EMS_inputbox_RSK();
            }
        }
        else
        {
            register_EMS_inputbox_viewer_keys();
        }

        break;
    case MMI_IMC_MESSAGE_CHECK_CSK_ENABLE:
        if (!(editor_ptr->flags & UI_EMS_INPUT_BOX_VIEW_MODE))
        {
            lresult = MMI_TRUE;
        }
        else
        {
            lresult = MMI_FALSE; 
        }
        break;
    case MMI_IMC_MESSAGE_CHECK_INFO_BAR_ENABL:
        lresult = MMI_TRUE;
        break;
    case MMI_IMC_MESSAGE_GET_TEXT_PTR_BEFORE_CANDIDATE:
        
        if (editor_ptr->flags & UI_EMS_INPUT_BOX_STATE_MULTITAP)
        {
            *((U8 **)(msg_ptr->param_1)) = (U8 *)(editor_ptr->data->textBuffer 
                                                      + editor_ptr->data->CurrentPosition.OffsetToText - 2);
        }
        else if (editor_ptr->flags & UI_EMS_INPUT_BOX_WORD_HIGHLIGHT)
        {
            *((U8 **)(msg_ptr->param_1)) = (U8 *)(editor_ptr->data->textBuffer 
                                                      + editor_ptr->highlight_start_position.OffsetToText);
        }
        else
        {
            *((U8 **)(msg_ptr->param_1)) = (U8 *)(editor_ptr->data->textBuffer 
                                                      + editor_ptr->data->CurrentPosition.OffsetToText);
        }

        *((U8 **)(msg_ptr->param_0)) = (U8 *)editor_ptr->data->textBuffer;
        break;
        
    case MMI_IMC_MESSAGE_GET_TEXT_PTR_BEFORE_CURSOR:
        *((U8 **)(msg_ptr->param_1)) = (U8 *)(editor_ptr->data->textBuffer 
                                                      + editor_ptr->data->CurrentPosition.OffsetToText);

        *((U8 **)(msg_ptr->param_0)) = (U8 *)editor_ptr->data->textBuffer;
        break;
        
    case MMI_IMC_MESSAGE_GET_STRING_BEFORE_CANDIDATE:
        /* if editor is in multitap state. */
        ///TODO: extend the function to get prevoious n character.
        if (editor_ptr->flags & UI_EMS_INPUT_BOX_STATE_MULTITAP)
        {
            UI_string_type buf = (UI_string_type)msg_ptr->param_1;
			EMSPosition backup_cursor = editor_ptr->data->CurrentPosition;

            i = 0;
            
			MoveCursorToPosition(editor_ptr->data, &editor_ptr->input_start_position);
            while (msg_ptr->param_0)
            {
                if (gui_EMS_input_box_get_previous_character(editor_ptr, (UI_character_type*)&buf[i]))
                {
                    msg_ptr->param_0 --;
                    i ++;
                    //gui_EMS_input_box_previous(editor_ptr);
					editor_ptr->data->CurrentPosition.OffsetToText -= ENCODING_LENGTH;
                }
                else
                {
                    break;
                }
            }
            MoveCursorToPosition(editor_ptr->data, &backup_cursor);
            return i;
        }
        else if ((editor_ptr->flags & UI_EMS_INPUT_BOX_WORD_HIGHLIGHT)
			        &&(editor_ptr->flags & UI_EMS_INPUT_BOX_INPUT_METHOD_MODE))
        {
            UI_string_type buf = (UI_string_type)msg_ptr->param_1;
            U16 backup_cursor_p = (U16)editor_ptr->data->CurrentPosition.OffsetToText;
            /* move cursor to the begining of the highlight */
            editor_ptr->data->CurrentPosition.OffsetToText = editor_ptr->highlight_start_position.OffsetToText;
            i = 0;
            while (msg_ptr->param_0)
            {
                if (gui_EMS_input_box_get_previous_character(editor_ptr, (UI_character_type *)&buf[i]))
                {
                    msg_ptr->param_0 --;
                    i ++;
                    //gui_EMS_input_box_previous(editor_ptr);
					editor_ptr->data->CurrentPosition.OffsetToText -= ENCODING_LENGTH;
                }
                else
                {
                    break;
                }
            }
            /* restore cursor to the begining of the highlight */
            editor_ptr->data->CurrentPosition.OffsetToText = (kal_uint16)backup_cursor_p;
            return i;
        }
        else
        {
            UI_string_type buf = (UI_string_type)msg_ptr->param_1;
            U16 backup_cursor_p = (U16)editor_ptr->data->CurrentPosition.OffsetToText;
            i = 0;
            while (msg_ptr->param_0)
            {
                if (gui_EMS_input_box_get_previous_character(editor_ptr, (UI_character_type *)&buf[i]))
                {
                    msg_ptr->param_0 --;
                    i ++;
                   // gui_EMS_input_box_previous(editor_ptr);
					editor_ptr->data->CurrentPosition.OffsetToText -= ENCODING_LENGTH;
                }
                else
                {
                    break;
                }
            }
            editor_ptr->data->CurrentPosition.OffsetToText = (kal_uint16)backup_cursor_p;
            return i;
        }
        break;
    case MMI_IMC_MESSAGE_SET_MULTITAP_STATE:
        editor_ptr->flags |= UI_EMS_INPUT_BOX_STATE_MULTITAP;
        break;
    case MMI_IMC_MESSAGE_WCSS_CHECK:
        lresult = MMI_FALSE;
        break;

    case MMI_IMC_MESSAGE_GET_EDITOR_SCROLL_BAR_WIDTH:
        lresult = (U32)editor_ptr->vbar.width;
        break;

#ifdef __MMI_CLIPBOARD__ 

#if defined(__MMI_TOUCH_SCREEN__)
    case MMI_IMC_MESSAGE_CLIPBOARD_LOCATE_CURSOR_P_BY_POS:
        ret = (MMI_BOOL)gui_EMS_input_box_translate_pen_event(
                            editor_ptr,
                            ((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->mmi_pen_event,
                            ((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos.x,
                            ((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos.y,
                            &EMS_input_box_event);
        if (ret)
        {
            ((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->editor_pen_event = (mmi_imc_editor_pen_event_enum)EMS_input_box_event;
			if (GUI_EMS_INPUT_BOX_PEN_SCROLL_BAR != EMS_input_box_event)
			{
				gui_show_EMS_input_box_ext(editor_ptr, 
                                           ((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos.x, 
                                           ((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos.y);
                if (((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->mmi_pen_event == MMI_PEN_EVENT_LONG_TAP)
                {
                    ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_1)->ems_start_p = editor_ptr->data->CurrentPosition;
                    gui_EMS_input_box_locate_cursor(&MMI_EMS_inputbox);
                }
                else if ((((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->mmi_pen_event == MMI_PEN_EVENT_MOVE) ||
                    (((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->mmi_pen_event == MMI_PEN_EVENT_UP))
                {
                    ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_1)->ems_end_p = editor_ptr->data->CurrentPosition;
                    /* Caculate the highlight text length */
                    ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_1)->highlight_text_length =
                        (((mmi_imc_clipboard_data_struct_p)msg_ptr->param_1)->ems_end_p.OffsetToText -
                        ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_1)->ems_start_p.OffsetToText) / ENCODING_LENGTH;
                }
			}

            if ((((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->mmi_pen_event != MMI_PEN_EVENT_LONG_TAP) &&
                (((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->mmi_pen_event != MMI_PEN_EVENT_UP))
            {
                /* Adjust editor view when out of boundary */
                if (((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos.y < (editor_ptr->y + WGUI_INPUTS_ADJUST_VIEW_OFFSET))
                {
                    editor_ptr->display_y += WGUI_INPUTS_ADJUST_VIEW_OFFSET;
                }
                else if (((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos.y > (editor_ptr->y + editor_ptr->height - WGUI_INPUTS_ADJUST_VIEW_OFFSET))
                {
                    editor_ptr->display_y -= WGUI_INPUTS_ADJUST_VIEW_OFFSET;
                }
                if (editor_ptr->display_y > 0 || editor_ptr->height >= editor_ptr->display_height + editor_ptr->header_height)
                {
                    editor_ptr->display_y = 0;
                }
                else if ((editor_ptr->display_y < (editor_ptr->height - (editor_ptr->display_height + editor_ptr->header_height))) && 
                         (editor_ptr->height < (editor_ptr->display_height + editor_ptr->header_height + 5)))
                {
                    // +5 for extra gap between margin area of editor
                    editor_ptr->display_y = editor_ptr->height - editor_ptr->display_height - editor_ptr->header_height - 5;
                }
            }
        }
        else
        {
            if (((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->mmi_pen_event == MMI_PEN_EVENT_LONG_TAP)
            {
                ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_1)->ems_start_p = editor_ptr->data->CurrentPosition;
            }
        }
        break;

    case MMI_IMC_MESSAGE_CLIPBOARD_ADJUST_VIEW:
        cursor_move_old_flags = editor_ptr->flags;
        editor_ptr->flags &= ~UI_EMS_INPUT_BOX_VIEW_MODE;
        if (((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos.y < editor_ptr->y)
        {
            gui_EMS_input_box_previous_line(editor_ptr);
            ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_1)->ems_end_p = editor_ptr->data->CurrentPosition;
            ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_1)->highlight_text_length =
                (((mmi_imc_clipboard_data_struct_p)msg_ptr->param_1)->ems_end_p.OffsetToText -
                ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_1)->ems_start_p.OffsetToText) / ENCODING_LENGTH;
        }
        else if (((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos.y > (editor_ptr->y + editor_ptr->height))
        {
            gui_EMS_input_box_next_line(editor_ptr);
            ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_1)->ems_end_p = editor_ptr->data->CurrentPosition;
            ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_1)->highlight_text_length =
                (((mmi_imc_clipboard_data_struct_p)msg_ptr->param_1)->ems_end_p.OffsetToText -
                ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_1)->ems_start_p.OffsetToText) / ENCODING_LENGTH;
        }
        editor_ptr->flags = cursor_move_old_flags;
        break;
#endif /* __MMI_TOUCH_SCREEN__ */

    case MMI_IMC_MESSAGE_CLIPBOARD_INSERT_STRING_WITH_LENGTH:
#if(UI_DOUBLE_BUFFER_SUPPORT)
        gui_lock_double_buffer();
#endif
        lresult = wgui_inputs_ems_insert_string((UI_string_type)msg_ptr->param_0, (U32)msg_ptr->param_1, MMI_TRUE);
        gui_EMS_input_box_locate_cursor(editor_ptr);
#if(UI_DOUBLE_BUFFER_SUPPORT)
        gui_unlock_double_buffer();
#endif
        redraw_EMS_inputbox();
        break;

    case MMI_IMC_MESSAGE_CLIPBOARD_SET_START_CURSOR_P:
        ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_0)->ems_start_p = editor_ptr->data->CurrentPosition;
        break;

    case MMI_IMC_MESSAGE_CLIPBOARD_MARK_TEXT:
        if (((mmi_imc_clipboard_data_struct_p)msg_ptr->param_0)->highlight_text_length > 0)
        {
            editor_ptr->highlight_start_position = ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_0)->ems_start_p;
            editor_ptr->highlight_end_position = ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_0)->ems_end_p;
            cursor_move_old_flags = editor_ptr->flags;
            editor_ptr->flags &= ~UI_EMS_INPUT_BOX_VIEW_MODE;        
        #ifdef __MMI_CLIPBOARD_FLOATING_MENU__   
            dm_imui_window_hide();
        #else
            show_EMS_inputbox();
        #endif
            editor_ptr->flags = cursor_move_old_flags;
        }
        else if (((mmi_imc_clipboard_data_struct_p)msg_ptr->param_0)->highlight_text_length < 0)
        {
            editor_ptr->highlight_start_position = ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_0)->ems_end_p;
            editor_ptr->highlight_end_position = ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_0)->ems_start_p;
              
        #ifdef __MMI_CLIPBOARD_FLOATING_MENU__   
            dm_imui_window_hide();
        #else
            show_EMS_inputbox();
        #endif
        }
        else if ((((mmi_imc_clipboard_data_struct_p)msg_ptr->param_0)->ems_start_p.OffsetToText) == 
              (((mmi_imc_clipboard_data_struct_p)msg_ptr->param_0)->ems_end_p.OffsetToText))
        {
            editor_ptr->highlight_start_position = ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_0)->ems_start_p;
            editor_ptr->highlight_end_position = ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_0)->ems_end_p;
        #ifdef __MMI_CLIPBOARD_FLOATING_MENU__   
            dm_imui_window_hide();
        #else
            show_EMS_inputbox();
        #endif
        }
        break;

    case MMI_IMC_MESSAGE_CLIPBOARD_MOVE_CORSOR:
        cursor_move_old_flags = editor_ptr->flags;
        editor_ptr->flags &= ~UI_EMS_INPUT_BOX_VIEW_MODE;
        switch (msg_ptr->param_0)
        {
            case MMI_IMC_EDITOR_CURSOR_UP:
                gui_EMS_input_box_previous_line(editor_ptr);
                break;
            case MMI_IMC_EDITOR_CURSOR_DOWN:
                gui_EMS_input_box_next_line(editor_ptr);
                break;
            case MMI_IMC_EDITOR_CURSOR_LEFT:
                gui_EMS_input_box_previous(editor_ptr);
                break;
            case MMI_IMC_EDITOR_CURSOR_RIGHT:
                gui_EMS_input_box_next(editor_ptr);
                break;
        }
        if (msg_ptr->param_1)
        {
            ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_1)->ems_end_p = editor_ptr->data->CurrentPosition;
            /* Caculate the highlight text length */
            ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_1)->highlight_text_length =
                (((mmi_imc_clipboard_data_struct_p)msg_ptr->param_1)->ems_end_p.OffsetToText -
                ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_1)->ems_start_p.OffsetToText) / ENCODING_LENGTH;
        }
        else
        {
            /* Redraw editor in locate start cursor mode */
            show_EMS_inputbox();
        }
        editor_ptr->flags = cursor_move_old_flags;
        break;

    case MMI_IMC_MESSAGE_CLIPBOARD_SAVE_STATUS:

        ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_0)->pre_flags = editor_ptr->flags;

        if (!mmi_imc_is_ime_state())
        {
            ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_0)->ems_pre_highlight_start_p = editor_ptr->highlight_start_position;
            ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_0)->ems_pre_highlight_end_p = editor_ptr->highlight_end_position;
        }
        else
        {
            ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_0)->pre_flags &= ~UI_EMS_INPUT_BOX_WORD_HIGHLIGHT;
        }    

        ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_0)->is_saved = 1;

        /* If view mode editor and locate start cursor position mode, we set the cursor at text start position */
        if (editor_ptr->flags & UI_EMS_INPUT_BOX_VIEW_MODE && (msg_ptr->param_1))
        {
#if(!UI_DISABLE_EMS_INPUT_BOX)
            gui_EMS_input_box_set_cursor_position(editor_ptr, &(editor_ptr->start_position));
#endif /* UI_DISABLE_EMS_INPUT_BOX */
            editor_ptr->display_y = 0;
        }

        if (editor_ptr->flags & UI_EMS_INPUT_BOX_VIEW_MODE)
        {
            /* Do not save keys when locate cursor because it saved in mmi_imc_clipboard_enter_locate_start_cursor_state */
            if (!msg_ptr->param_1)
            {
                mmi_imc_clipboard_save_keys();
            }
            wgui_inputs_ems_register_set_key_callback(mmi_imc_clipboard_restore_keys);
        }

    #if defined(__MMI_TOUCH_SCREEN__) && defined(__MMI_GESTURES_FRAMEWORK__) 
        mmi_frm_gesture_disable(); 
    #endif
        editor_ptr->flags |= UI_EMS_INPUT_BOX_WORD_HIGHLIGHT;
        editor_ptr->flags &= ~UI_EMS_INPUT_BOX_DISABLE_CURSOR_DRAW;
        memset(&editor_ptr->highlight_start_position, 0, sizeof(EMSPosition));
        memset(&editor_ptr->highlight_end_position, 0, sizeof(EMSPosition));
        editor_ptr->state = GUI_INPUT_BOX_STATE_SELECTING_TEXT;

        mmi_imc_clipboard_save_keys();

        break;

    case MMI_IMC_MESSAGE_CLIPBOARD_RESTORE_STATUS:
        editor_ptr->highlight_start_position = ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_0)->ems_pre_highlight_start_p;
        editor_ptr->highlight_end_position = ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_0)->ems_pre_highlight_end_p;
        editor_ptr->flags = ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_0)->pre_flags;
        editor_ptr->state = GUI_INPUT_BOX_STATE_IDLE;
        /* If read only editor, stop cursor draw */
        if (editor_ptr->flags & UI_EMS_INPUT_BOX_DISABLE_CURSOR_DRAW)
        {
            StopTimer(BLINKING_CURSOR);
        }
    #if defined(__MMI_TOUCH_SCREEN__) && defined(__MMI_GESTURES_FRAMEWORK__) 
        mmi_frm_gesture_enable(); 
    #endif
        break;

    case MMI_IMC_MESSAGE_CLIPBOARD_GET_ALL_TEXT:
         *((S8 **)(msg_ptr->param_0)) = (S8 *)editor_ptr->data->textBuffer;
         *((U32 *)msg_ptr->param_1) = editor_ptr->data->textLength;
        break;

    case MMI_IMC_MESSAGE_CLIPBOARD_GET_HIGHLIGHT_TEXT:
        if (((mmi_imc_clipboard_data_struct_p)msg_ptr->param_0)->highlight_text_length > 0)
        {
            *((U8 **)(msg_ptr->param_1)) = (U8 *)((S8 *)editor_ptr->data->textBuffer + 
                ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_0)->ems_start_p.OffsetToText);
        }
        else
        {
            *((U8 **)(msg_ptr->param_1)) = (U8 *)((S8 *)editor_ptr->data->textBuffer + 
                ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_0)->ems_end_p.OffsetToText);
        }
        break;    
    case MMI_IMC_MESSAGE_CLIPBOARD_IS_TEXT_HIGHLIGHT:
        if (((mmi_imc_clipboard_data_struct_p)msg_ptr->param_0)->highlight_text_length != 0)
        {
            lresult = 1;
        }
        else
        {
            lresult = 0;
        }
        break;

    case MMI_IMC_MESSAGE_CLIPBOARD_IS_READ_ONLY_EDITOR:
        if (msg_ptr->param_0 == 0)
        {
            lresult = (editor_ptr->flags & UI_EMS_INPUT_BOX_VIEW_MODE);
        }
        else 
        {
            if (((mmi_imc_clipboard_data_struct_p)msg_ptr->param_0)->is_saved == 1)
            {
                lresult = (((mmi_imc_clipboard_data_struct_p)msg_ptr->param_0)->pre_flags & UI_EMS_INPUT_BOX_VIEW_MODE);
            }
            else
            {
                lresult = (editor_ptr->flags & UI_EMS_INPUT_BOX_VIEW_MODE);
            }
        }

        break;

    case MMI_IMC_MESSAGE_CLIPBOARD_SET_HIGHLIGHT:
        /* Restore highlight info */
        if (((mmi_imc_clipboard_data_struct_p)msg_ptr->param_0)->highlight_text_length > 0)
        {
            editor_ptr->highlight_start_position = ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_0)->ems_start_p;
            editor_ptr->highlight_end_position = ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_0)->ems_end_p;
        }
        else if (((mmi_imc_clipboard_data_struct_p)msg_ptr->param_0)->highlight_text_length < 0)
        {
            editor_ptr->highlight_start_position = ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_0)->ems_end_p;
            editor_ptr->highlight_end_position = ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_0)->ems_start_p;
        }
        else
        {
            memset(&editor_ptr->highlight_end_position, 0, sizeof(EMSPosition));
        }

        /* Restore cursor position */
#if(!UI_DISABLE_EMS_INPUT_BOX)
        if (((mmi_imc_clipboard_data_struct_p)msg_ptr->param_0)->ems_end_p.OffsetToText > 0)
        {
            gui_EMS_input_box_set_cursor_position(editor_ptr, &(((mmi_imc_clipboard_data_struct_p)msg_ptr->param_0)->ems_end_p));
        }
#endif /* UI_DISABLE_EMS_INPUT_BOX */

        editor_ptr->flags |= UI_EMS_INPUT_BOX_WORD_HIGHLIGHT;
        editor_ptr->flags &= ~UI_EMS_INPUT_BOX_DISABLE_CURSOR_DRAW;
        ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_0)->is_saved = 1;

         /* When close cascading menu, the set key callback will be reset when previous exit screen, need reset here */
        wgui_inputs_ems_register_set_key_callback(mmi_imc_clipboard_restore_keys);
        break;

    case MMI_IMC_MESSAGE_CLIPBOARD_GET_EDITOR_TYPE:
        if (editor_ptr->flags & UI_EMS_INPUT_BOX_VIEW_MODE)
        {
            ((mmi_imc_editor_menu_history_data_struct_p)msg_ptr->param_0)->is_read_only = MMI_TRUE;
        }
        else
        {
            ((mmi_imc_editor_menu_history_data_struct_p)msg_ptr->param_0)->is_read_only = MMI_FALSE;
        }

        if ((UI_EMS_input_box *)editor_ptr->data->textLength == 0)
        {
            ((mmi_imc_editor_menu_history_data_struct_p)msg_ptr->param_0)->is_empty = MMI_TRUE;
        }
        else
        {
            ((mmi_imc_editor_menu_history_data_struct_p)msg_ptr->param_0)->is_empty = MMI_FALSE;
        }
        ((mmi_imc_editor_menu_history_data_struct_p)msg_ptr->param_0)->is_paging = MMI_FALSE;
        ((mmi_imc_editor_menu_history_data_struct_p)msg_ptr->param_0)->is_wcss = MMI_FALSE;
        ((mmi_imc_editor_menu_history_data_struct_p)msg_ptr->param_0)->is_password = MMI_FALSE;

        lresult = MMI_TRUE;
        break;

    case MMI_IMC_MESSAGE_CLIPBOARD_CUT_HIGHLIGHT_STRING:
        old_show_action_flag = MMI_EMS_inputbox.show_action_flag;
        MMI_EMS_inputbox.show_action_flag = 0;
        if (msg_ptr->param_1 == 1)
        {
            /* Mark text backward, start > end */
#if(!UI_DISABLE_EMS_INPUT_BOX)
            gui_EMS_input_box_set_cursor_position(editor_ptr, &(((mmi_imc_clipboard_data_struct_p)msg_ptr->param_0)->ems_start_p));
#endif /* UI_DISABLE_EMS_INPUT_BOX */

            highlight_count = gui_EMS_input_box_get_unit_count(
                editor_ptr, 
                ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_0)->ems_end_p,
                ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_0)->ems_start_p);
        }
        else if (msg_ptr->param_1 == 0)
        {
            /* Mark text forward, start < end */
            highlight_count = gui_EMS_input_box_get_unit_count(
                editor_ptr, 
                ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_0)->ems_start_p,
                ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_0)->ems_end_p);
        }
        else if (msg_ptr->param_1 == 3)
        {
            /* Mark text backward, memory not enough, start > end */
            cut_cursor_p = ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_0)->ems_end_p;
            while (editor_ptr->data->CurrentPosition.OffsetToText < (cut_cursor_p.OffsetToText + WGUI_INPUTS_CLIPBOARD_MAX_SIZE))
            {
                gui_EMS_input_box_next(editor_ptr);
                highlight_count++;
            }

            /* If contain 0x1b char, move backward */
            if (editor_ptr->data->CurrentPosition.OffsetToText > (editor_ptr->start_position.OffsetToText + WGUI_INPUTS_CLIPBOARD_MAX_SIZE))
            {
                gui_EMS_input_box_previous(editor_ptr);
                highlight_count--;
            }
        }
        else if (msg_ptr->param_1 == 2)
        {
            /* Mark text forward, memory not enough, start < end */
            cut_cursor_p = ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_0)->ems_start_p;
#if(!UI_DISABLE_EMS_INPUT_BOX)
            gui_EMS_input_box_set_cursor_position(editor_ptr, &(cut_cursor_p));
#endif /* UI_DISABLE_EMS_INPUT_BOX */

            while (editor_ptr->data->CurrentPosition.OffsetToText < (cut_cursor_p.OffsetToText + WGUI_INPUTS_CLIPBOARD_MAX_SIZE))
            {
                gui_EMS_input_box_next(editor_ptr);
                highlight_count++;
            }

            /* If contain 0x1b char, move backward */
            if (editor_ptr->data->CurrentPosition.OffsetToText > (editor_ptr->start_position.OffsetToText + WGUI_INPUTS_CLIPBOARD_MAX_SIZE))
            {
                gui_EMS_input_box_previous(editor_ptr);
                highlight_count--;
            }
        }

        while (highlight_count)
        {
            if (lresult == 0)
            {
                temp_position = editor_ptr->data->CurrentPosition;
                pre_obj = gui_EMS_input_box_get_previous_object(editor_ptr->data, &temp_position, &c, &obj);
                if (pre_obj != 1)
                {
                    /* Unsupported object (Pic, melody, format...) */
                    lresult = 1;
                }
            }
            EMS_inputbox_backspace_no_draw();
            highlight_count--;
        }
        MMI_EMS_inputbox.show_action_flag = old_show_action_flag;
        gui_EMS_input_box_locate_cursor(&MMI_EMS_inputbox);

        EMS_inputbox_input_callback();
        break;

    case MMI_IMC_MESSAGE_CLIPBOARD_CUT_ALL:
        if (msg_ptr->param_0 == 0)
        {
            if (MMI_EMS_inputbox.data->listHead != NULL)
            {
                /* Unsupported object (Pic, melody, format...) */
                lresult = 1;
            }
            EMS_inputbox_delete_all();
        }
        else if (msg_ptr->param_0 == 1)
        {
#if(!UI_DISABLE_EMS_INPUT_BOX)
            gui_EMS_input_box_set_cursor_position(editor_ptr, &(editor_ptr->start_position));
#endif /* UI_DISABLE_EMS_INPUT_BOX */

            old_show_action_flag = MMI_EMS_inputbox.show_action_flag;
            MMI_EMS_inputbox.show_action_flag = 0;
            while (editor_ptr->data->CurrentPosition.OffsetToText < (editor_ptr->start_position.OffsetToText + WGUI_INPUTS_CLIPBOARD_MAX_SIZE))
            {
                gui_EMS_input_box_next(editor_ptr);
                highlight_count++;
            }

            /* If contain 0x1b char, move backward */
            if (editor_ptr->data->CurrentPosition.OffsetToText > (editor_ptr->start_position.OffsetToText + WGUI_INPUTS_CLIPBOARD_MAX_SIZE))
            {
                gui_EMS_input_box_previous(editor_ptr);
                highlight_count--;
            }

            while (highlight_count)
            {
                if (lresult == 0)
                {
                    temp_position = editor_ptr->data->CurrentPosition;
                    pre_obj = gui_EMS_input_box_get_previous_object(editor_ptr->data, &temp_position, &c, &obj);
                    if (pre_obj != 1)
                    {
                        /* Unsupported object (Pic, melody, format...) */
                        lresult = 1;
                    }
                }
                EMS_inputbox_backspace_no_draw();
                highlight_count--;
            }
            MMI_EMS_inputbox.show_action_flag = old_show_action_flag;

            gui_EMS_input_box_locate_cursor(&MMI_EMS_inputbox);

            redraw_EMS_inputbox();
        }
        break;
        
    case MMI_IMC_MESSAGE_CLIPBOARD_IS_PASSWORD_EDITOR:
        lresult = MMI_FALSE;
        break;

    case MMI_IMC_MESSAGE_CLIPBOARD_IS_DISABLE:
        lresult = MMI_FALSE;
        break;

#ifdef __MMI_CLIPBOARD_FLOATING_MENU__
    case MMI_IMC_MESSAGE_CLIPBOARD_GET_HILITE_RECT:
        ((mmi_imc_clipboard_hilite_rect_p)msg_ptr->param_0)->s_x = editor_ptr->hilite_s_x;
        ((mmi_imc_clipboard_hilite_rect_p)msg_ptr->param_0)->s_y = editor_ptr->hilite_s_y;
        ((mmi_imc_clipboard_hilite_rect_p)msg_ptr->param_0)->e_x = editor_ptr->hilite_e_x;
        ((mmi_imc_clipboard_hilite_rect_p)msg_ptr->param_0)->e_y = editor_ptr->hilite_e_y;
        break;
#endif /* __MMI_CLIPBOARD_FLOATING_MENU__ */

#endif /* __MMI_CLIPBOARD__ */

    case MMI_IMC_MESSAGE_HAS_SSP_ACTED:
    #if defined(__MMI_EDITOR_SSP_SUPPORT__) && defined(__MMI_TOUCH_SCREEN__)
        lresult = gui_input_box_ssp_is_scrolling();
    #endif
        break;
    default:
        break;
    }
    
    UI_UNUSED_PARAMETER(ret);

    return lresult;
}


/*****************************************************************************
 * FUNCTION
 *  CloseCategory28Screen
 * DESCRIPTION
 *  Releases data used by the MO EMS/SMS screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void CloseCategory28Screen(void)
{
#if(UI_DISABLE_EMS_INPUT_BOX)
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 length;
    S32 i, j;
    U8 *buffer;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    length = wgui_inputs_ml_get_text_length();
    buffer = (U8*) gui_malloc((length << 1) + 2);
    i = j = 0;
    ResetCurrentPosition(temp_EMS_data);
    while (i < length)
    {
        buffer[j++] = 0;
        buffer[j++] = (U8) temp_EMS_buffer[i++];
    }
    buffer[j++] = 0;
    buffer[j++] = '\0';
    AddString(temp_EMS_data, buffer, (U16) length, NULL);
    gui_free(buffer);
    gui_free(temp_EMS_buffer);
#endif /* (UI_DISABLE_EMS_INPUT_BOX) */ 
}


/*****************************************************************************
 * FUNCTION
 *  ExitCategory28Screen
 * DESCRIPTION
 *  Exits the MO EMS/SMS screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitCategory28Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_MSG_EDITOR_WITH_RECIPIENT__
    g_wgui_cat28_add_recipients_in_BG = MMI_FALSE;
    wgui_inputs_ems_register_pre_key_handler(NULL);
    gui_inputs_set_pen_scrollbar_cb(NULL);
    gui_inputs_register_redraw_background_filler(NULL);
#endif /* __MMI_MSG_EDITOR_WITH_RECIPIENT__ */

    EMS_inputbox_has_changed = 0;
    category28_RSK_label_clear = 0;
    category28_RSK_function = NULL;
    wgui_inputbox_information_flag = 0;
    mmi_imc_disconnect();
#ifdef __MMI_MESSAGES_EMS__
    close_EMS_objects();
#endif 
#if(!UI_DISABLE_EMS_INPUT_BOX)
    {
        wgui_EMS_text_format = MMI_EMS_inputbox.text_format;
        reset_EMS_inputbox();
    }
#endif /* (!UI_DISABLE_EMS_INPUT_BOX) */ 

#ifdef __MMI_MSG_EDITOR_WITH_RECIPIENT__
    wgui_inputs_sl_close();
#endif

#ifdef __MMI_WALLPAPER_ON_BOTTOM__
    dm_set_scr_bg_opacity(editor_scr_bg_opacity);
#endif /* __MMI_WALLPAPER_ON_BOTTOM__ */ 

    ExitCategoryFunction = MMI_dummy_function;
    RedrawCategoryFunction = MMI_dummy_function;
    GetCategoryHistory = dummy_get_history;
    GetCategoryHistorySize = dummy_get_history_size;
    /* W05.36 Fix Vietnamese Tone Input Issue */
    wgui_inputs_set_current_input_box_type(EDITOR_NONE_INPUT_BOX);
    wgui_EMS_reset_input_information();
}


#ifndef __MMI_MSG_EDITOR_WITH_RECIPIENT__
/*****************************************************************************
 * FUNCTION
 *  GetCategory28HistorySize
 * DESCRIPTION
 *  Gets the history buffer size for the MO EMS/SMS screen
 * PARAMETERS
 *  void
 * RETURNS
 *  size in U8s of the history buffer
 *****************************************************************************/
S32 GetCategory28HistorySize(void)
{
#if(UI_DISABLE_EMS_INPUT_BOX)
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return (0);
#else /* (UI_DISABLE_EMS_INPUT_BOX) */ 
    return (sizeof(EMS_inputbox_category_history));
#endif /* (UI_DISABLE_EMS_INPUT_BOX) */ 
}


/*****************************************************************************
 * FUNCTION
 *  GetCategory28History
 * DESCRIPTION
 *  Gets the history buffer for the MO EMS/SMS screen
 * PARAMETERS
 *  history_buffer      [IN]        Is the buffer into which the history data is stored (pre-allocated)
 * RETURNS
 *  pointer to the history buffer
 *****************************************************************************/
U8 *GetCategory28History(U8 *history_buffer)
{
#if(UI_DISABLE_EMS_INPUT_BOX)
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return (history_buffer);
#else /* (UI_DISABLE_EMS_INPUT_BOX) */ 
    get_EMS_inputbox_category_history(MMI_CATEGORY28_ID, history_buffer);
    return (history_buffer);
#endif /* (UI_DISABLE_EMS_INPUT_BOX) */ 
}
#endif /* __MMI_MSG_EDITOR_WITH_RECIPIENT__ */


/*****************************************************************************
 * FUNCTION
 *  RedrawCategory39Screen
 * DESCRIPTION
 *  Redraws the MT EMS/SMS screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void RedrawCategory39Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();
    clear_screen();
    show_title_status_icon();
    draw_title();
    show_softkey_background();
    show_left_softkey();
    show_right_softkey();
#if(UI_DISABLE_EMS_INPUT_BOX)
    wgui_inputs_ml_show();
#else 
    show_EMS_inputbox();
#endif 
    gdi_layer_unlock_frame_buffer();
    gdi_layer_blt_previous(0, 0, UI_device_width - 1, UI_device_height - 1);
}


/* For detail description, please refer to wgui_categories_inputs.h */
void ShowCategory39Screen(
        U16 title,
        U16 title_icon,
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        EMSData *data,
        U8 *header,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 dm_data_cat_id;

#ifdef __MMI_CLIPBOARD__
    mmi_imm_input_mode_enum default_input_mode = IMM_INPUT_MODE_NONE;
#endif /* __MMI_CLIPBOARD__ */

#if(UI_DISABLE_EMS_INPUT_BOX)
    S32 length;
    S32 i, j, h, fh;

    UI_UNUSED_PARAMETER(history_buffer);
#else /* (UI_DISABLE_EMS_INPUT_BOX) */ 
    U8 h;
#endif /* (UI_DISABLE_EMS_INPUT_BOX) */ 
#ifdef __UI_EMS_HIGHLIGHT_LIST_SUPPORT__
    S32 saved_display_y;
#endif /* __UI_EMS_HIGHLIGHT_LIST_SUPPORT__ */

    S32 left_bt_x = 0, right_bt_x = 0;
    S32 bt_y = 0, bt_w, bt_h;
    icontext_button *left_bt = NULL, *right_bt = NULL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_setup_common_layout();

#if(UI_DOUBLE_BUFFER_SUPPORT)
    gui_lock_double_buffer();
#endif

    EMS_inputbox_has_changed = 0;

#ifdef __MMI_MESSAGES_EMS__
    initialize_EMS_objects();
#endif

    wgui_title_set_menu_shortcut_number(-1);
    change_left_softkey(left_softkey, left_softkey_icon);
    change_right_softkey(right_softkey, right_softkey_icon);
    SetupCategoryKeyHandlers();

    MMI_title_string = (UI_string_type) get_string(title);
    MMI_title_icon = (PU8) get_image(title_icon);

    /* setup slide control */  
#ifdef __WGUI_CAT_SLIDE_CONTROLS_SUPPORT__
    if (g_wgui_cat_slide_control_ptr != NULL)
    {
        /* setup button */
        g_wgui_cat_slide_control_ptr->left_button_id = dm_add_button(
                g_wgui_cat_slide_control_ptr->left_button_string,
                g_wgui_cat_slide_control_ptr->left_button_up_image,
                g_wgui_cat_slide_control_ptr->left_button_down_image,
                wgui_cat_clear_button_bg);

       g_wgui_cat_slide_control_ptr->right_button_id = dm_add_button(
               g_wgui_cat_slide_control_ptr->right_button_string,
               g_wgui_cat_slide_control_ptr->right_button_up_image,
               g_wgui_cat_slide_control_ptr->right_button_down_image,
               wgui_cat_clear_button_bg);
       
#if defined(__MMI_TOUCH_SCREEN__)
       dm_register_button_functions(
           g_wgui_cat_slide_control_ptr->left_button_id, 
           KEY_EVENT_UP, 
           g_wgui_cat_slide_control_ptr->left_button_function);
       dm_register_button_functions(
           g_wgui_cat_slide_control_ptr->right_button_id, 
           KEY_EVENT_UP, 
           g_wgui_cat_slide_control_ptr->right_button_function);
#endif /* defined(__MMI_TOUCH_SCREEN__) */

        /* if callback is NULL, disable button */
        left_bt = dm_get_button(g_wgui_cat_slide_control_ptr->left_button_id);
        right_bt = dm_get_button(g_wgui_cat_slide_control_ptr->right_button_id);
        if (g_wgui_cat_slide_control_ptr->left_button_function == NULL)
        {
            left_bt->flags |= UI_BUTTON_NO_SHIFT_BUTTON;
        }
        if (g_wgui_cat_slide_control_ptr->right_button_function == NULL)
        {
            right_bt->flags |= UI_BUTTON_NO_SHIFT_BUTTON;
        }

        /* move and resize button */
        gdi_image_get_dimension(g_wgui_cat_slide_control_ptr->left_button_up_image, &bt_w, &bt_h);
        left_bt_x = ((UI_device_width - WGUI_CAT_SLIDE_CONTROL_STRING_MAX_W - (bt_w << 1)) >> 1);
        right_bt_x = left_bt_x + bt_w + WGUI_CAT_SLIDE_CONTROL_STRING_MAX_W;
        bt_y = MMI_CONTENT_Y + ((WGUI_CAT_SLIDE_CONTROL_H  - bt_h) >> 1);

        dm_move_button(g_wgui_cat_slide_control_ptr->left_button_id, left_bt_x, bt_y); 
        dm_resize_button(g_wgui_cat_slide_control_ptr->left_button_id, bt_w, bt_h);
        dm_move_button(g_wgui_cat_slide_control_ptr->right_button_id, right_bt_x, bt_y);
        dm_resize_button(g_wgui_cat_slide_control_ptr->right_button_id, bt_w, bt_h);

        /* setup middle string */
        dm_add_string(
            g_wgui_cat_slide_control_ptr->middle_string,
            &MMI_medium_font,
            *current_MMI_theme->title_text_color,
            *current_MMI_theme->title_text_border_color,
            NULL);
    }
#endif /* __WGUI_CAT_SLIDE_CONTROLS_SUPPORT__ */


#if(UI_DISABLE_EMS_INPUT_BOX)
    length = (data->textBufferSize >> 1);
    if (length == 0)
    {
        UI_string_type s = (UI_string_type) "EMS Data not initialized";
        S32 l = gui_strlen((UI_string_type) s);

        temp_EMS_buffer = (UI_string_type) gui_malloc(l * sizeof(UI_character_type));
        gui_strcpy((UI_string_type) temp_EMS_buffer, (UI_string_type) s);
        length = l + 1;
        i = l;
    }
    else
    {
        temp_EMS_buffer = (UI_string_type) gui_malloc(length * sizeof(UI_character_type));
        i = j = 0;
        while (j < data->textLength)
        {
            if ((data->textBuffer[j] == '\0') && (data->textBuffer[j + 1] == '\0'))
            {
                temp_EMS_buffer[i] = '\0';
                break;
            }
            else
            {
                temp_EMS_buffer[i] = data->textBuffer[j + 1];
            }
            i++;
            j += 2;
        }
    }
    temp_EMS_data = data;
    wgui_inputs_ml_create_set_buffer(temp_EMS_buffer, length, i, 0);
    wgui_inputs_ml_register_keys();
    wgui_inputs_ml_move(0, (MMI_title_y + MMI_title_height));
    h = MMI_content_height - MMI_multitap_height - 8;
    gui_set_font(MMI_multiline_inputbox.text_font);
    fh = gui_get_character_height();
    h = ((h / fh) * fh) + 8;
    wgui_inputs_ml_resize(WGUI_INPUTS_STYLE_DEFAULT, h);
    wgui_inputs_ml_set_mask(0);
#else /* (UI_DISABLE_EMS_INPUT_BOX) */ 
#if((UI_ENABLE_FRAME_SKIPPING) && (ENABLE_EMS_INPUTBOX_FRAME_SKIPPING))
    wgui_EMS_inputbox_frame_counter = 0;
#endif 
    register_EMS_inputbox_input_callback(UI_dummy_function);
    gui_create_EMS_input_box(
        &MMI_EMS_inputbox,
        0,
        (MMI_title_y + MMI_title_height),
        MMI_content_width,
        MMI_content_height);
    
    MMI_EMS_inputbox.flags |= UI_EMS_INPUT_BOX_VIEW_MODE;
    gui_set_EMS_input_box_data(&MMI_EMS_inputbox, data);

#ifdef __UI_EMS_HIGHLIGHT_LIST_SUPPORT__
    wgui_inputs_EMS_set_hilite_info();
#endif /* __UI_EMS_HIGHLIGHT_LIST_SUPPORT__ */
#ifdef __MMI_ICON_BAR_SUPPORT__
#if defined(__MMI_FTE_SUPPORT__)
    if(MMI_TRUE == wgui_icon_bar_is_created())
    {
#ifdef __WGUI_CAT_SLIDE_CONTROLS_SUPPORT__
        if (g_wgui_cat_slide_control_ptr != NULL)
        {
            h = set_EMS_inputbox_category_history(MMI_CATEGORY39_ID_ICON_BAR_SLIDE_CONTROL, history_buffer);
        }
        else
#endif /* __WGUI_CAT_SLIDE_CONTROLS_SUPPORT__ */
        {
            h = set_EMS_inputbox_category_history(MMI_CATEGORY39_ID_ICON_BAR, history_buffer);
        }
    }
    else
#endif
#endif /*__MMI_ICON_BAR_SUPPORT__*/
    {
#ifdef __WGUI_CAT_SLIDE_CONTROLS_SUPPORT__
        if (g_wgui_cat_slide_control_ptr != NULL)
        {
            h = set_EMS_inputbox_category_history(MMI_CATEGORY39_ID_SLIDE_CONTROL, history_buffer);
        }
        else
#endif /* __WGUI_CAT_SLIDE_CONTROLS_SUPPORT__ */
        {
            h = set_EMS_inputbox_category_history(MMI_CATEGORY39_ID, history_buffer);
        }
    }

#ifdef __UI_EMS_HIGHLIGHT_LIST_SUPPORT__
    if (MMI_EMS_inputbox.hilite_str_number != 0)
    {
        /* Go to highlight will change the visible range, so we need to save it before, then restore after goto hilite */
        saved_display_y = MMI_EMS_inputbox.display_y;
    	gui_EMS_input_box_go_to_hilite(&MMI_EMS_inputbox, MMI_EMS_inputbox.current_hilite_idx);
        MMI_EMS_inputbox.display_y = saved_display_y;
    }
    else
    {
        /* if set auto find off when view EMS message, reinitialize current hilite index to 0 */
        MMI_EMS_inputbox.current_hilite_idx = 0;
    }
#endif /* __UI_EMS_HIGHLIGHT_LIST_SUPPORT__ */
    if (!h)
    {
        ResetCurrentPosition(MMI_EMS_inputbox.data);
    }
    MMI_EMS_inputbox.flags |= UI_EMS_INPUT_BOX_DISABLE_CURSOR_DRAW;

#ifdef __MMI_CLIPBOARD__
    mmi_imm_set_required_mode_list(IMM_INPUT_TYPE_SENTENCE, NULL, default_input_mode);
    g_mmi_editor_hanler.input_box_type = MMI_EDITOR_EMS_INPUT_BOX;
    g_mmi_editor_hanler.input_box_sub_type = MMI_EDITOR_INPUT_BOX_READ_ONLY;
    g_mmi_editor_hanler.input_box_handler = &MMI_EMS_inputbox;
    mmi_imc_disable_key_input();
#ifdef __MMI_TOUCH_SCREEN__
    mmi_imc_disable_handwriting();
    mmi_imc_disable_virtual_keyboard();
#endif /* __MMI_TOUCH_SCREEN__ */
    mmi_imc_connect((void *)&g_mmi_editor_hanler, mmi_input_box_msg_call_back_ems);
#endif /* __MMI_CLIPBOARD__ */

#ifdef __MMI_WALLPAPER_ON_BOTTOM__ 
    MMI_EMS_inputbox.flags |= UI_EMS_INPUT_BOX_TRANSPARENT_BACKGROUND;
    dm_get_scr_bg_opacity(&editor_scr_bg_opacity);
    dm_set_scr_bg_opacity((U8)(current_MMI_theme->bg_opacity_low));
#endif    
    register_EMS_inputbox_viewer_keys();
    create_EMS_viewer_header(header);
    MMI_EMS_inputbox.display_header = EMS_viewer_show_header;
    MMI_EMS_inputbox.measure_header = EMS_viewer_measure_header;
#endif /* (UI_DISABLE_EMS_INPUT_BOX) */
    
#if(UI_DOUBLE_BUFFER_SUPPORT)
    gui_unlock_double_buffer();
#endif

    dm_register_category_controlled_callback(DrawCate39CategoryControlArea);
#ifdef __MMI_ICON_BAR_SUPPORT__
#if defined(__MMI_FTE_SUPPORT__)
    if(MMI_TRUE == wgui_icon_bar_is_created())
    {
#ifdef __WGUI_CAT_SLIDE_CONTROLS_SUPPORT__
        if (g_wgui_cat_slide_control_ptr != NULL)
        {
            dm_data_cat_id = MMI_CATEGORY39_ID_ICON_BAR_SLIDE_CONTROL;
        }
        else
#endif /* __WGUI_CAT_SLIDE_CONTROLS_SUPPORT__ */
        {
            dm_data_cat_id = MMI_CATEGORY39_ID_ICON_BAR;
        }
    }
    else
#endif /* __MMI_FTE_SUPPORT__ */
#endif /*__MMI_ICON_BAR_SUPPORT__*/
    {
#ifdef __WGUI_CAT_SLIDE_CONTROLS_SUPPORT__
        if (g_wgui_cat_slide_control_ptr != NULL)
        {
            dm_data_cat_id = MMI_CATEGORY39_ID_SLIDE_CONTROL;
        }
        else
#endif /* __WGUI_CAT_SLIDE_CONTROLS_SUPPORT__ */
        {
            dm_data_cat_id = MMI_CATEGORY39_ID;
        }
    }

    wgui_cat_setup_category(
        dm_data_cat_id, 
        DM_CLEAR_SCREEN_BACKGROUND,
        ExitCategory39Screen,
        GetCategory39History,
        GetCategory39HistorySize);
    dm_redraw_category_screen();

#ifdef __MMI_TOUCH_SCREEN__
#ifdef __WGUI_CAT_SLIDE_CONTROLS_SUPPORT__
    if (g_wgui_cat_slide_control_ptr != NULL)
    {
        gui_icontext_button_overwirte_pen_response_area(left_bt, left_bt_x, bt_y, left_bt_x + bt_w - 1, bt_y + bt_h - 1);
        gui_icontext_button_overwirte_pen_response_area(right_bt, right_bt_x, bt_y, right_bt_x + bt_w - 1, bt_y + bt_h - 1);
    }
#endif /* __WGUI_CAT_SLIDE_CONTROLS_SUPPORT__ */
#endif /* __MMI_TOUCH_SCREEN__ */
}


/*****************************************************************************
 * FUNCTION
 *  DrawCate39CategoryControlArea
 * DESCRIPTION
 *  This function is used to draw the category controlled area of category39 screen
 * PARAMETERS
 *  coordinate      [IN/OUT]        Coordinates of category controlled area.
 * RETURNS
 *  void
 *****************************************************************************/
void DrawCate39CategoryControlArea(dm_coordinates *coordinate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 top_image_width, top_image_height;
    S32 bottom_image_width, bottom_image_height;
    S32 header_height;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    header_height = EMS_viewer_measure_header();
#if defined(__MMI_MAINLCD_128X128__)
    EMS_viewer_show_header(coordinate->s16X,
        coordinate->s16Y,
        coordinate->s16Width,
        coordinate->s16Y + header_height);

    coordinate->s16Height = header_height;
#else
    gdi_image_get_dimension_id(WGUI_IMG_TEXT_BG_TOP, &top_image_width, &top_image_height);
    gdi_image_get_dimension_id(WGUI_IMG_TEXT_BG_TOP, &bottom_image_width, &bottom_image_height);

    EMS_viewer_show_header(coordinate->s16X,
        coordinate->s16Y + top_image_height,
        coordinate->s16Width,
        coordinate->s16Y + header_height + top_image_height);

    coordinate->s16Height = header_height + top_image_height + bottom_image_height;
#endif
}


/*****************************************************************************
 * FUNCTION
 *  CloseCategory39Screen
 * DESCRIPTION
 *  Releases data used by the MT EMS/SMS screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void CloseCategory39Screen(void)
{
#if(UI_DISABLE_EMS_INPUT_BOX)
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 length;
    S32 i, j;
    U8 *buffer;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    length = wgui_inputs_ml_get_text_length();
    buffer = (U8*) gui_malloc((length << 1) + 2);
    i = j = 0;
    ResetCurrentPosition(temp_EMS_data);
    while (i < length)
    {
        buffer[j++] = 0;
        buffer[j++] = (U8) temp_EMS_buffer[i++];
    }
    buffer[j++] = 0;
    buffer[j++] = '\0';
    AddString(temp_EMS_data, buffer, (U16) length, NULL);
    gui_free(buffer);
    gui_free(temp_EMS_buffer);
#endif /* (UI_DISABLE_EMS_INPUT_BOX) */ 
}


/*****************************************************************************
 * FUNCTION
 *  ExitCategory39Screen
 * DESCRIPTION
 *  Exits the MT EMS/SMS screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitCategory39Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if(!UI_DISABLE_EMS_INPUT_BOX)
    reset_EMS_inputbox();
#endif 

#ifdef __MMI_CLIPBOARD__
    mmi_imc_disconnect();
#endif /* __MMI_CLIPBOARD__ */

#ifdef __MMI_MESSAGES_EMS__
    close_EMS_objects();
#endif 
#ifdef __MMI_WALLPAPER_ON_BOTTOM__ 
    dm_set_scr_bg_opacity(editor_scr_bg_opacity);
#endif 
    ExitCategoryFunction = MMI_dummy_function;
    RedrawCategoryFunction = MMI_dummy_function;
    GetCategoryHistory = dummy_get_history;
    GetCategoryHistorySize = dummy_get_history_size;

#ifdef __WGUI_CAT_SLIDE_CONTROLS_SUPPORT__
    if(g_wgui_cat_slide_control_ptr != NULL)
    {
        applib_mem_screen_free(g_wgui_cat_slide_control_ptr);
		g_wgui_cat_slide_control_ptr = NULL;
    } 
#endif /* __WGUI_CAT_SLIDE_CONTROLS_SUPPORT__ */
}


/*****************************************************************************
 * FUNCTION
 *  GetCategory39HistorySize
 * DESCRIPTION
 *  Gets the history buffer size for the MT EMS/SMS screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
S32 GetCategory39HistorySize(void)
{
#if(UI_DISABLE_EMS_INPUT_BOX)
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return (0);
#else /* (UI_DISABLE_EMS_INPUT_BOX) */ 
    return (sizeof(EMS_inputbox_category_history));
#endif /* (UI_DISABLE_EMS_INPUT_BOX) */ 

}


/*****************************************************************************
 * FUNCTION
 *  GetCategory39History
 * DESCRIPTION
 *  Gets the history buffer for the MT EMS/SMS screen
 * PARAMETERS
 *  history_buffer      [?]             
 *  history(?)          [IN/OUT]        The buffer into which the history data is stored (pre-allocated)
 * RETURNS
 *  void
 *****************************************************************************/
U8 *GetCategory39History(U8 *history_buffer)
{
#if(UI_DISABLE_EMS_INPUT_BOX)
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return (history_buffer);
#else /* (UI_DISABLE_EMS_INPUT_BOX) */ 
#ifdef __MMI_ICON_BAR_SUPPORT__
    #if defined(__MMI_FTE_SUPPORT__)
        if(MMI_TRUE == wgui_icon_bar_is_created())
        {
#ifdef __WGUI_CAT_SLIDE_CONTROLS_SUPPORT__
            if (g_wgui_cat_slide_control_ptr != NULL)
            {
                get_EMS_inputbox_category_history(MMI_CATEGORY39_ID_ICON_BAR_SLIDE_CONTROL, history_buffer);
            }
            else
#endif /* __WGUI_CAT_SLIDE_CONTROLS_SUPPORT__ */
            {
                get_EMS_inputbox_category_history(MMI_CATEGORY39_ID_ICON_BAR, history_buffer);
            }
        }
        else
    #endif /* __MMI_FTE_SUPPORT__ */
#endif /*__MMI_ICON_BAR_SUPPORT__*/
        {
#ifdef __WGUI_CAT_SLIDE_CONTROLS_SUPPORT__
            if (g_wgui_cat_slide_control_ptr != NULL)
            {
                get_EMS_inputbox_category_history(MMI_CATEGORY39_ID_SLIDE_CONTROL, history_buffer);
            }
            else
#endif /* __WGUI_CAT_SLIDE_CONTROLS_SUPPORT__ */
            {
                get_EMS_inputbox_category_history(MMI_CATEGORY39_ID, history_buffer);
            }
        }
    return (history_buffer);
#endif /* (UI_DISABLE_EMS_INPUT_BOX) */ 
}

#endif /* UI_EMS_SUPPORT */


/* Cat_215 Start */
/*****************************************************************************
 * FUNCTION
 *  cat_215_text_change_event_callback
 * DESCRIPTION
 *  Function to call info bar fillers
 * PARAMETERS
 *  event       [IN]        Action performed on insert, delete character or delete all
 *  C           [IN]        Character to insert or delete
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL cat_215_text_change_event_callback(gui_multi_line_input_box_change_event_enum event, U16 C)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL result = MMI_TRUE;
    U8 cat_215_1_bytes_char_num_temp = cat_215_1_bytes_char_num;
    U8 cat_215_2_bytes_char_num_temp = cat_215_2_bytes_char_num;
    U8 cat_215_3_bytes_char_num_temp = cat_215_3_bytes_char_num;
    U8 cat_215_text_length_temp = cat_215_text_length;
    U8 char_len = app_unicode_to_utf8_len(C);

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (event)
    {
        case GUI_MULTI_LINE_INPUT_BOX_INSERT_CHAR:
            if (char_len == 1)
            {
                cat_215_1_bytes_char_num_temp ++;
            }
            else if (char_len == 2)
            {
                cat_215_2_bytes_char_num_temp ++;
            }
            else if (char_len == 3)
            {
                cat_215_3_bytes_char_num_temp ++;
            }
            /*
            if (cat_215_3_bytes_char_num_temp != 0)
            {
                cat_215_text_length_temp = ((cat_215_1_bytes_char_num_temp + cat_215_2_bytes_char_num_temp + cat_215_3_bytes_char_num_temp) * 3);
            }
            else if (cat_215_2_bytes_char_num_temp != 0)
            {
                cat_215_text_length_temp = ((cat_215_1_bytes_char_num_temp + cat_215_2_bytes_char_num_temp) * 2);
            }
            else
            {
                cat_215_text_length_temp = cat_215_1_bytes_char_num_temp;
            }
            */
            cat_215_text_length_temp += char_len;

            if (cat_215_text_length_temp > (wgui_inputbox_buffer_size - 1))
            {
                result = MMI_FALSE;
            }
            else
            {
                cat_215_text_length = cat_215_text_length_temp;
                cat_215_1_bytes_char_num = cat_215_1_bytes_char_num_temp;
                cat_215_2_bytes_char_num = cat_215_2_bytes_char_num_temp;
                cat_215_3_bytes_char_num = cat_215_3_bytes_char_num_temp;
            }
            break;
        case GUI_MULTI_LINE_INPUT_BOX_DELETE_CHAR:
            if (char_len == 1)
            {
                cat_215_1_bytes_char_num --;
            }
            else if (char_len == 2)
            {
                cat_215_2_bytes_char_num --;
            }
            else if (char_len == 3)
            {
                cat_215_3_bytes_char_num --;
            }

            /*
            if (cat_215_3_bytes_char_num != 0)
            {
                cat_215_text_length = ((cat_215_1_bytes_char_num + cat_215_2_bytes_char_num + cat_215_3_bytes_char_num) * 3);
            }
            else if (cat_215_2_bytes_char_num != 0)
            {
                cat_215_text_length = ((cat_215_1_bytes_char_num + cat_215_2_bytes_char_num) * 2);
            }
            else
            {
                cat_215_text_length = cat_215_1_bytes_char_num;
            }
            */
            cat_215_text_length -= char_len;
            break;
        case GUI_MULTI_LINE_INPUT_BOX_DELETEALL:
            cat_215_text_length = 0;
            cat_215_1_bytes_char_num = 0;
            cat_215_2_bytes_char_num = 0;
            cat_215_3_bytes_char_num = 0;
            break;
    }
    return result;
}


/*****************************************************************************
 * FUNCTION
 *  cat_215_text_total_characters_in_byte_callback
 * DESCRIPTION
 *  Function to call info bar fillers
 * PARAMETERS
 *  x1      [IN]        Start x position of input box
 *  y1      [IN]        Start y position of input box
 *  x2      [IN]        End x position of input box
 *  y2      [IN]        End y position of input box
 * RETURNS
 *  void
 *****************************************************************************/
void cat_215_text_total_characters_in_byte_callback(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    color c;

#if !defined(__MMI_TOUCH_SCREEN__)
    stFontAttribute *f = &MMI_small_font;
    S32 w;
#else /* !defined(__MMI_TOUCH_SCREEN__) */ 
    stFontAttribute *f = &MMI_medium_font;
    S32 w, h;
#endif /* !defined(__MMI_TOUCH_SCREEN__) */ 
    UI_character_type str[32];
    U8 text_length_temp = cat_215_text_length;
    S32 totla_buffer_temp = wgui_inputbox_buffer_size - 1;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (cat_215_3_bytes_char_num > 0)
    {
        text_length_temp = text_length_temp/3;
        totla_buffer_temp = totla_buffer_temp/3;
    }
    else if (cat_215_2_bytes_char_num > 0)
    {
        text_length_temp = text_length_temp/2;
        totla_buffer_temp = totla_buffer_temp/2;
    }
    
    gui_lock_double_buffer();
    gui_reset_text_clip();
    wgui_inputs_input_information_background(x1, y1, x2, y2);
    wgui_inputs_ml_show_current_input_method(x1, y1, x2, y2);
    if ((totla_buffer_temp - (cat_215_1_bytes_char_num + cat_215_2_bytes_char_num + cat_215_3_bytes_char_num)) >= 1)
    {
        gui_sprintf(str, "%d/%d", (cat_215_1_bytes_char_num + cat_215_2_bytes_char_num + cat_215_3_bytes_char_num), totla_buffer_temp);
        c = *current_MMI_theme->remaining_length_text_color;
        gui_set_font(f);
        gui_set_text_color(c);
        gui_set_text_clip(0, 0, UI_device_width - 1, UI_device_height - 1);
#if !defined(__MMI_TOUCH_SCREEN__)
        w = gui_get_string_width(str);
#else 
        gui_measure_string(str, &w, &h);
#endif 
        if (!mmi_fe_get_r2l_state())
#if !defined(__MMI_TOUCH_SCREEN__)
            gui_move_text_cursor(x2 - 2 - w, y1 + 2);
#else 
            gui_move_text_cursor(x2 - 2 - w, y1 + (wgui_inputbox_information_bar_height - h) / 2);
#endif 
        else
#if !defined(__MMI_TOUCH_SCREEN__)
            gui_move_text_cursor(x1 + 2 + w, y1 + 2);
#else 
            gui_move_text_cursor(x1 + 2 + w, y1 + (wgui_inputbox_information_bar_height - h) / 2);
#endif 
        gui_print_text(str);
    }
    gui_unlock_double_buffer();
    gui_BLT_double_buffer(x1, y1, x2, y2);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat215_get_counter_string_callback
 * DESCRIPTION
 *  Function to call info bar fillers
 * PARAMETERS
 *  buffer           [OUT]       Put in counter string.
 *  buffer_size      [IN]        string length.
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
static MMI_BOOL wgui_cat215_get_counter_string_callback(UI_character_type *buffer, S32 buffer_size)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S8 temp_str[32];
    U8 text_length_temp = cat_215_text_length;
    S32 totla_buffer_temp = wgui_inputbox_buffer_size - 1;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (cat_215_3_bytes_char_num > 0)
    {
        text_length_temp = text_length_temp/3;
        totla_buffer_temp = totla_buffer_temp/3;
    }
    else if (cat_215_2_bytes_char_num > 0)
    {
        text_length_temp = text_length_temp/2;
        totla_buffer_temp = totla_buffer_temp/2;
    }

    memset(buffer, 0, buffer_size);
    sprintf((S8*) temp_str, "%d/%d", (cat_215_1_bytes_char_num + cat_215_2_bytes_char_num + cat_215_3_bytes_char_num), totla_buffer_temp);
    mmi_asc_to_ucs2((PS8) buffer, (PS8) temp_str);

    //if ((text_length_temp < totla_buffer_temp - GUI_INPUT_BOX_FLOATING_COUNTER_DISPLAY_THRESHOLD) || ((totla_buffer_temp - text_length_temp) <= 1))
    if ((totla_buffer_temp - (cat_215_1_bytes_char_num + cat_215_2_bytes_char_num + cat_215_3_bytes_char_num)) < 1)
    {
        return MMI_FALSE;
    }
    else
    {
        return MMI_TRUE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  cat_215_fit_text_for_ut8_length_in_multiline_inputbox
 * DESCRIPTION
 *  Function to take only buffer upto limit
 * PARAMETERS
 *  buffer      [IN/OUT]        To change the string buffer to the passed size
 * RETURNS
 *  void
 *****************************************************************************/
void cat_215_fit_text_for_ut8_length_in_multiline_inputbox(U8 *buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 i = 0;
    U8 char_len;
    U16 ucs2_char;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    cat_215_text_length = 0;
    cat_215_1_bytes_char_num = 0;
    cat_215_2_bytes_char_num = 0;
    cat_215_3_bytes_char_num = 0;
    ucs2_char = (buffer[i]) | ((buffer[i + 1] << 8));
    char_len = app_unicode_to_utf8_len(ucs2_char);
    while (ucs2_char && (cat_215_text_length + char_len <= (wgui_inputbox_buffer_size - 1)))
    {
        //cat_215_text_length += char_len;
        
        if (char_len == 1)
        {
            cat_215_1_bytes_char_num++;
        }
        else if (char_len == 2)
        {
            cat_215_2_bytes_char_num++;
        }
        else if (char_len == 3)
        {
            cat_215_3_bytes_char_num++;
        }
        /*
        if (cat_215_3_bytes_char_num != 0)
        {
            cat_215_text_length = ((cat_215_1_bytes_char_num + cat_215_2_bytes_char_num + cat_215_3_bytes_char_num) * 3);
        }
        else if (cat_215_2_bytes_char_num != 0)
        {
            cat_215_text_length = ((cat_215_1_bytes_char_num + cat_215_2_bytes_char_num) * 2);
        }
        else
        {
            cat_215_text_length = cat_215_1_bytes_char_num;
        }
        */
        cat_215_text_length = cat_215_3_bytes_char_num*3 + cat_215_2_bytes_char_num*2 + cat_215_1_bytes_char_num;
        
        i += ENCODING_LENGTH;
        ucs2_char = (buffer[i]) | ((buffer[i + 1] << 8));
        char_len = app_unicode_to_utf8_len(ucs2_char);
        /*
        if ((cat_215_2_bytes_char_num > 0) && (char_len < 2))
        {
            char_len = 2;
        }
        if ((cat_215_3_bytes_char_num > 0) && (char_len < 3))
        {
            char_len = 3;
        }
        */
    }
    buffer[i] = 0;
    buffer[i + 1] = 0;
}


/* For detail description, please refer to wgui_categories_inputs.h */
void ShowCategory215Screen_int(
        U16 title,
        U16 title_icon,
        U16 left_softkey,
        U16 right_softkey,
        U32 input_type,
        U8 *buffer,
        S32 buffer_size,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_lock_double_buffer();
    wgui_inputbox_buffer_size = buffer_size;
    cat_215_fit_text_for_ut8_length_in_multiline_inputbox(buffer);
    ShowCategory5Screen(
        title,
        title_icon,
        left_softkey,
        0,
        right_softkey,
        0,
        input_type,
        buffer,
        buffer_size,
        history_buffer);
    wgui_inputs_ml_register_change_event_handler(cat_215_text_change_event_callback);
#ifdef __MMI_FTE_SUPPORT__
    wgui_inputs_ml_register_floating_counter(wgui_cat215_get_counter_string_callback);
    wgui_inputs_ml_show();
#else
    wgui_inputs_ml_register_infobar_callback(
        cat_215_text_total_characters_in_byte_callback,
        cat_215_text_total_characters_in_byte_callback,
        0);
    wgui_inputs_ml_redraw_input_information_bar();
#endif
    gui_unlock_double_buffer();
    gui_BLT_double_buffer(0, 0, UI_device_width - 1, UI_device_height - 1);
}


/*****************************************************************************
 * FUNCTION
 *  cat_215_fit_text_for_gb_length_in_multiline_inputbox
 * DESCRIPTION
 *  Function to take only buffer upto limit
 * PARAMETERS
 *  buffer      [IN/OUT]        To change the string buffer to the passed size
 * RETURNS
 *  void
 *****************************************************************************/
void cat_215_fit_text_for_gb_length_in_multiline_inputbox(U8 *buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 i = 0;
    U8 char_len;
    U16 ucs2_char;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    cat_215_text_length = 0;
    ucs2_char = (buffer[i]) | ((buffer[i + 1] << 8));
    char_len = wgui_inputs_ucs2_to_gb_len(ucs2_char);
    while (ucs2_char && (cat_215_text_length + char_len <= (wgui_inputbox_buffer_size - 1)))
    {
        cat_215_text_length += char_len;
        i += ENCODING_LENGTH;
        ucs2_char = (buffer[i]) | ((buffer[i + 1] << 8));
        char_len = wgui_inputs_ucs2_to_gb_len(ucs2_char);
    }
    buffer[i] = 0;
    buffer[i + 1] = 0;
}


/*****************************************************************************
 * FUNCTION
 *  cat_215_text_change_event_callback
 * DESCRIPTION
 *  Function to call info bar fillers
 * PARAMETERS
 *  event       [IN]        Action performed on insert, delete character or delete all
 *  C           [IN]        Character to insert or delete
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL cat_215_ext_text_change_event_callback(gui_multi_line_input_box_change_event_enum event, U16 C)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL result = MMI_TRUE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (event)
    {
        case GUI_MULTI_LINE_INPUT_BOX_INSERT_CHAR:
            if (cat_215_text_length + wgui_inputs_ucs2_to_gb_len(C) > (wgui_inputbox_buffer_size - 1))
            {
                result = MMI_FALSE;
            }
            else
            {
                cat_215_text_length += wgui_inputs_ucs2_to_gb_len(C);
            }
            break;
        case GUI_MULTI_LINE_INPUT_BOX_DELETE_CHAR:
            cat_215_text_length -= wgui_inputs_ucs2_to_gb_len(C);
            break;
        case GUI_MULTI_LINE_INPUT_BOX_DELETEALL:
            cat_215_text_length = 0;
            break;
    }
    return result;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat215_ext_get_counter_string_callback
 * DESCRIPTION
 *  Function to call info bar fillers
 * PARAMETERS
 *  buffer           [OUT]       Put in counter string.
 *  buffer_size      [IN]        string length.
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
static MMI_BOOL wgui_cat215_ext_get_counter_string_callback(UI_character_type *buffer, S32 buffer_size)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S8 temp_str[32];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(buffer, 0, buffer_size);
    sprintf((S8*) temp_str, "%d/%d", cat_215_text_length, (wgui_inputbox_buffer_size - 1));
    mmi_asc_to_ucs2((PS8) buffer, (PS8) temp_str);
    return MMI_TRUE;

/*
    if (cat_215_text_length < (wgui_inputbox_buffer_size - 1) - GUI_INPUT_BOX_FLOATING_COUNTER_DISPLAY_THRESHOLD)
    {
        return MMI_FALSE;
    }
    else
    {
        return MMI_TRUE;
    }
*/
}


/*****************************************************************************
 * FUNCTION
 *  cat_215_ext_text_total_characters_in_byte_callback
 * DESCRIPTION
 *  Function to call info bar fillers
 * PARAMETERS
 *  x1      [IN]        Start x position of input box
 *  y1      [IN]        Start y position of input box
 *  x2      [IN]        End x position of input box
 *  y2      [IN]        End y position of input box
 * RETURNS
 *  void
 *****************************************************************************/
void cat_215_ext_text_total_characters_in_byte_callback(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    color c;

#if !defined(__MMI_TOUCH_SCREEN__)
    stFontAttribute *f = &MMI_small_font;
    S32 w;
#else /* !defined(__MMI_TOUCH_SCREEN__) */ 
    stFontAttribute *f = &MMI_medium_font;
    S32 w, h;
#endif /* !defined(__MMI_TOUCH_SCREEN__) */ 
    UI_character_type str[32];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_lock_double_buffer();
    gui_reset_text_clip();
    wgui_inputs_input_information_background(x1, y1, x2, y2);
    wgui_inputs_ml_show_current_input_method(x1, y1, x2, y2);
    gui_sprintf(str, "%d/%d", cat_215_text_length, (wgui_inputbox_buffer_size - 1));
    c = *current_MMI_theme->remaining_length_text_color;
    gui_set_font(f);
    gui_set_text_color(c);
    gui_set_text_clip(0, 0, UI_device_width - 1, UI_device_height - 1);
#if !defined(__MMI_TOUCH_SCREEN__)
    w = gui_get_string_width(str);
#else 
    gui_measure_string(str, &w, &h);
#endif 
    if (!mmi_fe_get_r2l_state())
#if !defined(__MMI_TOUCH_SCREEN__)
        gui_move_text_cursor(x2 - 2 - w, y1 + 2);
#else 
        gui_move_text_cursor(x2 - 2 - w, y1 + (wgui_inputbox_information_bar_height - h) / 2);
#endif 
    else
#if !defined(__MMI_TOUCH_SCREEN__)
        gui_move_text_cursor(x1 + 2 + w, y1 + 2);
#else 
        gui_move_text_cursor(x1 + 2 + w, y1 + (wgui_inputbox_information_bar_height - h) / 2);
#endif 
    gui_print_text(str);
    gui_unlock_double_buffer();
    gui_BLT_double_buffer(x1, y1, x2, y2);
}


/* For detail description, please refer to wgui_categories_inputs.h */
void ShowCategory215Screen_ext_int(
        U16 title,
        U16 title_icon,
        U16 left_softkey,
        U16 right_softkey,
        U32 input_type,
        U8 *buffer,
        S32 buffer_size,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_lock_double_buffer();
    gui_setup_common_layout();
    wgui_inputbox_buffer_size = buffer_size;
    cat_215_fit_text_for_gb_length_in_multiline_inputbox(buffer);
    ShowCategory5Screen(
        title,
        title_icon,
        left_softkey,
        0,
        right_softkey,
        0,
        input_type,
        buffer,
        buffer_size,
        history_buffer);
    wgui_inputs_ml_register_change_event_handler(cat_215_ext_text_change_event_callback);
#ifdef __MMI_FTE_SUPPORT__
    wgui_inputs_ml_register_floating_counter(wgui_cat215_ext_get_counter_string_callback);
    wgui_inputs_ml_show();
#else
    wgui_inputs_ml_register_infobar_callback(
        cat_215_ext_text_total_characters_in_byte_callback,
        cat_215_ext_text_total_characters_in_byte_callback,
        0);
    wgui_inputs_ml_redraw_input_information_bar();
#endif
    gui_unlock_double_buffer();
    gui_BLT_double_buffer(0, 0, UI_device_width - 1, UI_device_height - 1);
}

/* Cat_215 End */


/*Cat 415 Start */
static void cat415_display_callback(dm_coordinates *coordinate);

#if defined(__MMI_MAINLCD_240X320__)
#define CAT415_TIPS_AREA_HEIGHT   (Get_CharHeightOfAllLang(LARGE_FONT) * 2 + 6)
#else
#define CAT415_TIPS_AREA_HEIGHT   (Get_CharHeightOfAllLang(MEDIUM_FONT) * 2 + 5)
#endif 


/*****************************************************************************
 * FUNCTION
 *  GetCategory415HistorySize
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
S32 GetCategory415HistorySize(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return (sizeof(multiline_inputbox_category_history));
}


/*****************************************************************************
 * FUNCTION
 *  GetCategory415History
 * DESCRIPTION
 *  Gets the history buffer for category5 screen
 * PARAMETERS
 *  history_buffer      [IN]        Is the buffer into which the history data is stored (pre-allocated)
 * RETURNS
 *  Pointer to the history buffer
 *****************************************************************************/
U8 *GetCategory415History(U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_inputs_ml_get_category_history(MMI_CATEGORY415_ID, history_buffer);
    return (history_buffer);
}


/* For detail description, please refer to wgui_categories_inputs.h */
void ShowCategory415Screen_int(
        U16 title,
        U16 title_icon,
        U16 left_softkey,
        U16 right_softkey,
        U16 message,
        U32 input_type,
        U8 *buffer,
        S32 buffer_size,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 inputbox_height = MMI_content_height - CAT415_TIPS_AREA_HEIGHT;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if(UI_DOUBLE_BUFFER_SUPPORT)
	gui_lock_double_buffer();
#endif 
    MMI_message_string = (UI_string_type) get_string(message);
	wgui_title_set_menu_shortcut_number(-1);
    wgui_title_disable_menu_shortcut_display(MMI_TRUE);
    
    dm_add_title_id(title, title_icon);
    dm_add_softkey_id(left_softkey, right_softkey);

	wgui_inputs_ml_setup(
		0,
		(MMI_title_y + MMI_title_height + CAT415_TIPS_AREA_HEIGHT),
		MMI_content_width,
		inputbox_height,
		buffer,
		buffer_size,
		MMI_CATEGORY415_ID,
		get_string(right_softkey),
	        NULL,
		input_type,
		history_buffer,
    #ifdef __MMI_FTE_SUPPORT__        
        0
    #else
        1
    #endif
		);

	if (((input_type & INPUT_TYPE_MASK) == IMM_INPUT_TYPE_NUMERIC_PASSWORD) ||
		((input_type & INPUT_TYPE_MASK) == IMM_INPUT_TYPE_ALPHANUMERIC_PASSWORD) ||
		((input_type & INPUT_TYPE_MASK) == IMM_INPUT_TYPE_SAT_NUMERIC_PASSWORD) ||
		((input_type & INPUT_TYPE_MASK) == IMM_INPUT_TYPE_SIGNED_DECIMAL_NUMERIC_PASSWORD) ||
		((input_type & INPUT_TYPE_MASK) == IMM_INPUT_TYPE_SIGNED_NUMERIC_PASSWORD))
	{
		MMI_current_input_ext_type |= INPUT_TYPE_EXT_NO_SHOW_NEW_LINE_SYMBOL;
	}
	
	inputbox_height = MMI_content_height - wgui_inputbox_information_bar_height;
	if (wgui_inputs_ml_get_height() > inputbox_height)
	{
	    wgui_inputs_ml_resize(WGUI_INPUTS_STYLE_DEFAULT, inputbox_height);
	}

    wgui_inputs_ml_set_common_style(MMI_TRUE, MMI_TRUE);
	
#ifdef __MMI_WALLPAPER_ON_BOTTOM__
	dm_get_scr_bg_opacity(&editor_scr_bg_opacity);
	dm_set_scr_bg_opacity((U8)(current_MMI_theme->bg_opacity_low));
#endif 
	
	gui_unlock_double_buffer();
	
	dm_register_category_controlled_callback(cat415_display_callback);
	dm_register_vkpad_callback(mmi_imc_redraw_screen_by_state);
    wgui_cat_setup_category(
        MMI_CATEGORY415_ID,
        DM_CLEAR_SCREEN_BACKGROUND | DM_SHOW_VKPAD,
        ExitCategory415Screen,
        GetCategory415History,
        GetCategory415HistorySize);
	dm_redraw_category_screen();
}


/*****************************************************************************
 * FUNCTION
 *  ExitCategory4155Screen
 * DESCRIPTION
 *  Exits the category415 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitCategory415Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_inputs_ml_close();
#ifdef __MMI_WALLPAPER_ON_BOTTOM__
    dm_set_scr_bg_opacity(editor_scr_bg_opacity);
#endif /* __MMI_WALLPAPER_ON_BOTTOM__ */ 
}


/*****************************************************************************
 * FUNCTION
 *  cat415_display_callback
 * DESCRIPTION
 *  
 * PARAMETERS
 *  coordinate      [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void cat415_display_callback(dm_coordinates *coordinate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    multi_line_input_box read_only_inputbox;
    S32 inputbox_x = 0;
    S32 inputbox_y = (MMI_title_y + MMI_title_height);
    S32 inputbox_width = MMI_content_width;
    S32 inputbox_height = CAT415_TIPS_AREA_HEIGHT;
    S32 len;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    len = gui_strlen(MMI_message_string);
    gui_create_multi_line_input_box_set_buffer(
        &read_only_inputbox,
        inputbox_x,
        inputbox_y,
        inputbox_width,
        inputbox_height,
        MMI_message_string,
        len * 2,
        (len + 1) * 2,
        0);
    read_only_inputbox.normal_text_color = *current_MMI_theme->list_normal_text_color;
    read_only_inputbox.flags |=
            (UI_MULTI_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW | UI_MULTI_LINE_INPUT_BOX_DISABLE_BACKGROUND |
             UI_MULTI_LINE_INPUT_BOX_DISABLE_SCROLLBAR | UI_MULTI_LINE_INPUT_BOX_VIEW_MODE | UI_MULTI_LINE_INPUT_BOX_CENTER_JUSTIFY);
    read_only_inputbox.ext_flags |= GUI_MULTI_LINE_INPUT_BOX_TRUNCATE_CONTENT;

    /* show read only inputbox */
    gui_show_multi_line_input_box(&read_only_inputbox);

    /* show editor */
    gui_show_multi_line_input_box(&MMI_multiline_inputbox);

    /* redraw information bar */
    wgui_inputs_ml_redraw_input_information_bar();
    
}


/*****************************************************************************
 * FUNCTION
 *  wgui_inputs_get_editor_handler
 * DESCRIPTION
 *  get editor hanlder;
 * PARAMETERS
 *  void
 * RETURNS
 *  mmi_editor_handler_struct
 *****************************************************************************/
mmi_editor_handler_struct* wgui_inputs_get_editor_handler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return &g_mmi_editor_hanler;
}



/* filled colr scheme for category111 */
UI_filled_area PIN_inputbox_BG_filler = 
{
    UI_FILLED_AREA_TYPE_COLOR | UI_FILLED_AREA_SINGLE_BORDER | UI_FILLED_AREA_SHADOW,
    UI_NULL_IMAGE,
    NULL,
    {255, 222, 255, 100},
    {0, 0, 0, 0},
    {255, 0, 0, 100},
    {255, 0, 0, 100},
    0
};

/* theme of single input box of enter pin screen */

UI_single_line_input_box_theme PIN_singleline_inputbox_theme = { &PIN_inputbox_BG_filler,
    &PIN_inputbox_BG_filler,
    &PIN_inputbox_BG_filler,
    {0, 0, 0, 100},
    {128, 128, 128, 100},
    {0, 0, 0, 100},
    {255, 255, 255, 100},
    {51, 88, 171, 100},
    {255, 0, 0, 100},
    &UI_DEFAULT_FONT,
    1,
    UI_SINGLE_LINE_INPUT_BOX_CENTER_Y,
    '*'
};


/*****************************************************************************
 * FUNCTION
 *  ExitCategory69Screen
 * DESCRIPTION
 *  Exit category69 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitCategory69Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_inputs_ml_reset();
    wgui_inputs_sl_close();
}


/*****************************************************************************
 * FUNCTION
 *  ShowCategory69Screen
 * DESCRIPTION
 *  show cateogyry69 screen
 * PARAMETERS
 *  title                   [IN]        Title
 *  title_icon              [IN]        Title icon
 *  left_softkey            [IN]        Left softkey label
 *  left_softkey_icon       [IN]        Left softkey icon
 *  right_softkey           [IN]        Right softkey label
 *  right_softkey_icon      [IN]        Right softkey icon
 *  message                 [IN]        Message to show
 *  input_type              [IN]        Input method, only support IMM_INPUT_TYPE_NUMERIC
 *  buffer                  [OUT]       Buffer for input box
 *  buffer_size             [IN]        Buffer size for input box
 *  history_buffer          [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory69Screen_int(
        U16 title,
        U16 title_icon,
        U16 left_softkey,
        U16 right_softkey,
        U16 message,
        U32 input_type,
        U8 *buffer,
        S32 buffer_size,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 dm_data_flags;
    S32 len;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();

    MMI_ASSERT(input_type == IMM_INPUT_TYPE_NUMERIC); /* only support IMM_INPUT_TYPE_NUMERIC */

#if defined(__MMI_MAINLCD_128X64__)
    title = 0;
#endif /* __MMI_MAINLCD_128X64__ */

    dm_add_softkey_id(left_softkey, right_softkey);

    /* title */
    wgui_title_set_menu_shortcut_number(-1);
    wgui_title_disable_menu_shortcut_display(MMI_TRUE);
    if (title == 0)
    {
        dm_data_flags = DM_NO_TITLE | DM_CLEAR_SCREEN_BACKGROUND;
    }
    else
    {
        dm_data_flags = DM_CLEAR_SCREEN_BACKGROUND;
        MMI_title_string = get_string(title);
        MMI_title_icon = get_image(title_icon);
    }

    /* multiline inputbox (show message) */
    MMI_message_string = (UI_string_type)GetString(message);
    len = gui_strlen(MMI_message_string);
    create_multiline_inputbox_set_buffer(MMI_message_string, len, len, 0);
	MMI_multiline_inputbox.normal_text_color = *current_MMI_theme->list_normal_text_color;
    MMI_multiline_inputbox.flags |=
        (UI_MULTI_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW | UI_MULTI_LINE_INPUT_BOX_CENTER_JUSTIFY |
         UI_MULTI_LINE_INPUT_BOX_DISABLE_BACKGROUND | UI_MULTI_LINE_INPUT_BOX_DISABLE_SCROLLBAR |
         UI_MULTI_LINE_INPUT_BOX_VIEW_MODE);
    mmi_imc_set_fixed_input_box();

    /* singleline inputbox */
    wgui_inputs_sl_setup(
        0,  /* will set later */
        0,  /* will set later */
        0,  /* will set later */
        0,  /* will set later */
        buffer,
        buffer_size,
        MMI_CATEGORY69_ID,
        get_string(right_softkey),
        NULL,
        input_type,
        history_buffer,
        0);
#ifndef __MMI_FTE_SUPPORT__
    gui_set_single_line_input_box_theme(&MMI_singleline_inputbox, &PIN_singleline_inputbox_theme);
#endif

    gdi_layer_unlock_frame_buffer();

    /* set category function & draw manager data */
#if defined(__MMI_TOUCH_SCREEN__)
    dm_data_flags |= DM_SHOW_VKPAD;
    dm_register_vkpad_callback(mmi_imc_redraw_screen_by_state);
#endif /* defined(__MMI_TOUCH_SCREEN__) */
    wgui_cat_setup_category_default_history(
        MMI_CATEGORY69_ID,
        dm_data_flags,
        ExitCategory69Screen);
    dm_redraw_category_screen();
}


#ifdef __MMI_SMALL_PIN_EDIT_SCREEN__
    
typedef struct _wgui_cat112_cntx_struct
{
    U8* multiline_message;
    U8* singleline_buffer;
    U8* history_buffer;
    PU8 rsk_icon;
    UI_string_type rsk_label;
    U32 input_type;
    S32 singleline_buffer_size;    
} wgui_cat112_cntx_struct;
    
static wgui_cat112_cntx_struct* g_wgui_cat112_cntx_ptr = NULL;
/*****************************************************************************
 * FUNCTION
 *  cat112_draw_scroll_text_cb
 * DESCRIPTION
 *  draw scrolling text background
 * PARAMETERS
 *  x1      [IN]        start X
 *  y1      [IN]        start Y
 *  x2      [IN]        end X
 *  y2      [IN]        end Y
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat112_draw_scroll_text_background(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#if defined(DM_NEW_POPUPBG_METHOD)
    dm_coordinates popup_clip = {0};
#endif /* defined(DM_NEW_POPUPBG_METHOD) */

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(DM_NEW_POPUPBG_METHOD)
    popup_clip.s16X = (S16)x1;
    popup_clip.s16Y = (S16)y1;
    popup_clip.s16Width = (S16)(x2 - x1 + 1);
    popup_clip.s16Height = (S16)(y2 - y1 + 1);
    dm_popupbg_set_clip((dm_coordinates*)&popup_clip);
    dm_redraw_popup_background();
#else /* defined(DM_NEW_POPUPBG_METHOD) */
    wgui_category_clear_region_with_transparent_color(x1, y1, x2, y2);
#endif /* defined(DM_NEW_POPUPBG_METHOD) */
}

#if defined(__MMI_MAINLCD_320X480__) && !defined(__MMI_FTE_SUPPORT__)
/*****************************************************************************
 * FUNCTION
 *  wgui_cat112_hide_lsk_cb
 * DESCRIPTION
 *  hide function of left softkey
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat112_hide_lsk_cb(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	wgui_cat112_draw_scroll_text_background(
        MMI_softkeys[MMI_LEFT_SOFTKEY].x,
        MMI_softkeys[MMI_LEFT_SOFTKEY].y,
        MMI_softkeys[MMI_LEFT_SOFTKEY].x + MMI_softkeys[MMI_LEFT_SOFTKEY].width - 1,
        MMI_softkeys[MMI_LEFT_SOFTKEY].y + MMI_softkeys[MMI_LEFT_SOFTKEY].height - 1);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat112_hide_rsk_cb
 * DESCRIPTION
 *  hide function of right softkey
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat112_hide_rsk_cb(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	wgui_cat112_draw_scroll_text_background(
        MMI_softkeys[MMI_RIGHT_SOFTKEY].x,
        MMI_softkeys[MMI_RIGHT_SOFTKEY].y,
        MMI_softkeys[MMI_RIGHT_SOFTKEY].x + MMI_softkeys[MMI_RIGHT_SOFTKEY].width - 1,
        MMI_softkeys[MMI_RIGHT_SOFTKEY].y + MMI_softkeys[MMI_RIGHT_SOFTKEY].height - 1);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat112_hide_csk_cb
 * DESCRIPTION
 *  hide function of center softkey
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat112_hide_csk_cb(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	wgui_cat112_draw_scroll_text_background(
        MMI_softkeys[MMI_CENTER_SOFTKEY].x,
        MMI_softkeys[MMI_CENTER_SOFTKEY].y,
        MMI_softkeys[MMI_CENTER_SOFTKEY].x + MMI_softkeys[MMI_CENTER_SOFTKEY].width - 1,
        MMI_softkeys[MMI_CENTER_SOFTKEY].y + MMI_softkeys[MMI_CENTER_SOFTKEY].height - 1);
}
#endif /* defined(__MMI_MAINLCD_320X480__) */

/*****************************************************************************
 * FUNCTION
 *  wgui_cat112_control_area_callback
 * DESCRIPTION
 *  control area callback for category112
 *  1. draw multiline
 *  2. draw sinlgeline
 * PARAMETERS
 *  coordinate    [IN]   control area coordinate
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat112_control_area_callback(dm_coordinates *coordinate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/        
    S32 len, total_height, left_space, y_space, multiline_h;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    /* multiline inputbox */
#ifdef __MMI_FTE_SUPPORT__
    multiline_h = ((Get_CharDisplayHeightOfAllLangAndType(MMI_medium_font.size) + 5));
#else
    multiline_h = Get_CharDisplayHeightOfAllLangAndType(MMI_medium_font.size) * 3; /* multiline height: max two lines */
#endif    
    total_height = multiline_h + MMI_SINGLELINE_INPUTBOX_HEIGHT;
	if (coordinate->s16Height < total_height)
	{
		/* adjust multline inputbox height */
		multiline_h = coordinate->s16Height - MMI_SINGLELINE_INPUTBOX_HEIGHT - 1;
		y_space = 0;
	}
	else
	{
		left_space = coordinate->s16Height - total_height;
		y_space = left_space / 3;
	}

    len = gui_strlen((UI_string_type) g_wgui_cat112_cntx_ptr->multiline_message);
    wgui_inputs_ml_create_set_buffer((UI_string_type) g_wgui_cat112_cntx_ptr->multiline_message, len, len, 0);
    MMI_multiline_inputbox.normal_text_color = *(current_MMI_theme->popup_text_color);
    MMI_multiline_inputbox.flags |=
        UI_MULTI_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW | UI_MULTI_LINE_INPUT_BOX_DISABLE_BACKGROUND | 
        UI_MULTI_LINE_INPUT_BOX_DISABLE_SCROLLBAR | UI_MULTI_LINE_INPUT_BOX_VIEW_MODE;
#ifdef __MMI_FTE_SUPPORT__
    MMI_multiline_inputbox.flags |=UI_MULTI_LINE_INPUT_BOX_CENTER_JUSTIFY;
#endif

    wgui_inputs_ml_move(coordinate->s16X, coordinate->s16Y + y_space);
    wgui_inputs_ml_resize(coordinate->s16Width, multiline_h);
    wgui_inputs_ml_show();

    /* single-line editor */
    wgui_inputs_sl_move(coordinate->s16X, MMI_multiline_inputbox.y + MMI_multiline_inputbox.height + y_space);
    wgui_inputs_sl_resize(coordinate->s16Width, MMI_SINGLELINE_INPUTBOX_HEIGHT);
    wgui_inputs_sl_show();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat112_get_history_size
 * DESCRIPTION
 *  get history size for category112
 * PARAMETERS
 *  void
 * RETURNS
 *  S32
 *****************************************************************************/
S32 wgui_cat112_get_history_size(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return (sizeof(singleline_inputbox_category_history));
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat112_get_history
 * DESCRIPTION
 *  get history for category112
 * PARAMETERS
 *  history_buffer    [IN]   histroy buffer
 * RETURNS
 *  U8*
 *****************************************************************************/
U8* wgui_cat112_get_history(U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_inputs_sl_get_category_history(MMI_CATEGORY112_ID, history_buffer);
    return (history_buffer);
}


/*****************************************************************************
 * FUNCTION
 *  ExitCategory112Screen
 * DESCRIPTION
 *  Exits category 112 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitCategory112Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    reset_small_screen();

    wgui_inputs_ml_reset();
    wgui_inputs_sl_close();

#if !defined(__MMI_MAINLCD_320X480__)
    wgui_softkey_set_is_in_popup(MMI_FALSE);
#endif

    /* free parameter */
    if(g_wgui_cat112_cntx_ptr != NULL)
    {
        OslMfree(g_wgui_cat112_cntx_ptr);
		g_wgui_cat112_cntx_ptr = NULL;
    }    
}


/*****************************************************************************
 * FUNCTION
 *  ShowCategory112Screen
 * DESCRIPTION
 *  Displays the category112 screen - main used for enter pin screen
 * PARAMETERS
 *  left_softkey            [IN]        Left softkey label
 *  left_softkey_icon       [IN]        Left softkey icon
 *  right_softkey           [IN]        Right softkey label
 *  right_softkey_icon      [IN]        Right softkey icon
 *  message                 [IN]        Message (only support max two lines)
 *  input_type              [IN]        Input type. Only numeric passward is allowed
 *  buffer                  [IN]        Input buffer
 *  buffer_size             [IN]        Size of the buffer
 *  message2                [IN]        Second message (scrolling)
 *  history_buffer          [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory112Screen_int(
        U16 left_softkey,
        U16 right_softkey,
        U8 *message,
        U32 input_type,
        U8 *buffer,
        S32 buffer_size,
        U8 *message2,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    /* Currently, only numeric password is allowed. */
    /* Becasue the layout is restricted by virtual keypad */
    MMI_ASSERT(input_type == IMM_INPUT_TYPE_NUMERIC_PASSWORD);

    /* pre-process memory */
    if(g_wgui_cat112_cntx_ptr != NULL)
    {
        OslMfree(g_wgui_cat112_cntx_ptr);
		g_wgui_cat112_cntx_ptr = NULL;
    }    

    /* allocate memory */
    g_wgui_cat112_cntx_ptr = (wgui_cat112_cntx_struct*)OslMalloc(sizeof(wgui_cat112_cntx_struct));
    MMI_ASSERT(g_wgui_cat112_cntx_ptr != NULL);
    memset(g_wgui_cat112_cntx_ptr, 0, sizeof(wgui_cat112_cntx_struct));
    
    gdi_layer_lock_frame_buffer();

    set_small_screen();
    gui_add_cleanup_hook(disable_resized_small_screen);

    /* set softkey */
    dm_add_softkey_id(left_softkey, right_softkey);
    /* multiline data */
    g_wgui_cat112_cntx_ptr->multiline_message = message;

    /* singleline data */
    g_wgui_cat112_cntx_ptr->singleline_buffer = buffer;
    g_wgui_cat112_cntx_ptr->singleline_buffer_size = buffer_size;
    g_wgui_cat112_cntx_ptr->rsk_label = get_string(right_softkey);
    g_wgui_cat112_cntx_ptr->rsk_icon = NULL;
    g_wgui_cat112_cntx_ptr->input_type = input_type;
    g_wgui_cat112_cntx_ptr->history_buffer = history_buffer;

#if !defined(__MMI_MAINLCD_320X480__)
    wgui_softkey_set_is_in_popup(MMI_TRUE);
#endif 

    /* singleline inputbox */
    mmi_imc_set_fixed_input_box();
    wgui_inputs_sl_setup(
        0,
        0,
        0,
        MMI_SINGLELINE_INPUTBOX_HEIGHT,
        g_wgui_cat112_cntx_ptr->singleline_buffer,
        g_wgui_cat112_cntx_ptr->singleline_buffer_size,
        MMI_CATEGORY112_ID,
        g_wgui_cat112_cntx_ptr->rsk_label,
        g_wgui_cat112_cntx_ptr->rsk_icon,
        g_wgui_cat112_cntx_ptr->input_type,
        g_wgui_cat112_cntx_ptr->history_buffer,
        0);
    gui_set_single_line_input_box_theme(&MMI_singleline_inputbox, &PIN_singleline_inputbox_theme);
#if defined(__MMI_MAINLCD_320X480__)  && !defined(__MMI_FTE_SUPPORT__)
    mmi_imc_set_backgroud_filler(wgui_cat112_draw_scroll_text_background);
#endif /* defined(__MMI_MAINLCD_320X480__) */

    /* set scrolling text */
    dm_add_scroll_text(
          (UI_string_type) message2, 
          NULL, 
          wgui_cat112_draw_scroll_text_background, 
          *(current_MMI_theme->popup_text_color),
          *(current_MMI_theme->popup_text_color));

#if defined(__MMI_MAINLCD_320X480__) && !defined(__MMI_FTE_SUPPORT__)
	register_hide_softkey(wgui_cat112_hide_lsk_cb, MMI_LEFT_SOFTKEY);
	register_hide_softkey(wgui_cat112_hide_rsk_cb, MMI_RIGHT_SOFTKEY);
        register_hide_softkey(wgui_cat112_hide_csk_cb, MMI_CENTER_SOFTKEY);
#endif /* defined(__MMI_MAINLCD_320X480__) */
    gdi_layer_unlock_frame_buffer();

    dm_register_category_controlled_callback(wgui_cat112_control_area_callback);
    dm_register_vkpad_callback(mmi_imc_redraw_screen_by_state);
    wgui_cat_setup_category(
        MMI_CATEGORY112_ID,
        DM_SHOW_VKPAD | DM_SET_NEW_LAYER_ACTIVE,
        ExitCategory112Screen,
        wgui_cat112_get_history,
        wgui_cat112_get_history_size);
    dm_redraw_category_screen();
}
#endif /* __MMI_SMALL_PIN_EDIT_SCREEN__ */ 


#ifndef __MMI_WALLPAPER_ON_BOTTOM__
static UI_filled_area pin_editor_background_filler;
#endif /* __MMI_WALLPAPER_ON_BOTTOM__ */

#ifdef __WGUI_CAT111_SUPPORT_DURATION__
static S32 Cat111CountDownValue;
static FuncPtr Cat111TimerExpireCallBack = UI_dummy_function;

/*****************************************************************************
 * FUNCTION
 *  SetCat111TimerExpireFunc
 * DESCRIPTION
 *  Set cat 111 countdown callback function
 * PARAMETERS
 *  f       [IN]        Countdown callback function
 * RETURNS
 *  void
 *****************************************************************************/
void SetCat111TimerExpireFunc(FuncPtr f)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    Cat111TimerExpireCallBack = f;
}


/*****************************************************************************
 * FUNCTION
 *  Cat111CountDownCallBack
 * DESCRIPTION
 *  cat 111 countdown callback function
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void Cat111CountDownCallBack(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 buf[6];
    S32 count_y;
    S32 sw, sh;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (Cat111CountDownValue == 0)
    {
        StopTimer(POPUP_TIMER);
        if (Cat111TimerExpireCallBack != NULL)
        {
            Cat111TimerExpireCallBack();
        }
        Cat111TimerExpireCallBack = UI_dummy_function;
    }
    else
    {
        gui_itoa(Cat111CountDownValue, (UI_string_type) buf, 10);
        gui_set_font(&MMI_medium_font);
        gui_set_text_color(*current_MMI_theme->list_normal_text_color);

        gui_measure_string((UI_string_type) buf, &sw, &sh);
        count_y = UI_device_height - MMI_button_bar_height - sh - 1;
#ifdef __MMI_TOUCH_SCREEN__
#ifdef __MMI_MAINLCD_320X240__
        count_y = MMI_COMMON_CONTENT_Y - (MMI_TITLE_HEIGHT >> 1) + (MMI_MENUITEM_HEIGHT * 3) + (CAT111_GAP * 3) + 6 /* editor border */;
#else
#ifdef __MMI_FTE_SUPPORT__ 
        count_y = UI_device_height - MMI_VKBD_TRAY_HEIGHT - MMI_SINGLELINE_INPUTBOX_HEIGHT;
#else
        count_y = MMI_COMMON_CONTENT_Y - (MMI_TITLE_HEIGHT >> 1) + (MMI_MENUITEM_HEIGHT << 2) + (CAT111_GAP * 3) + 6 /* editor border */;
#endif
#endif
#endif

        gdi_layer_push_clip();
        
#ifndef __MMI_WALLPAPER_ON_BOTTOM__
        gui_draw_filled_area(0, count_y, UI_device_width - 1, count_y + sh - 1, &pin_editor_background_filler);
#else
        gdi_draw_solid_rect(0, count_y, UI_device_width - 1, count_y + sh - 1, GDI_COLOR_TRANSPARENT);
#endif

        gui_move_text_cursor((UI_device_width - sw) >> 1, count_y);
        gui_print_text((UI_string_type) buf);
        gdi_layer_pop_clip();
        gui_BLT_double_buffer(0, count_y, UI_device_width - 1, count_y + sh - 1);
        
        Cat111CountDownValue--;
        StartTimer(POPUP_TIMER, 1000, Cat111CountDownCallBack);
    }
}
#endif /* __WGUI_CAT111_SUPPORT_DURATION__ */


/*****************************************************************************
 * FUNCTION
 *  ShowCategory111Screen
 * DESCRIPTION
 *  Show category 111 screen, full screen PIN editor
 * PARAMETERS
 *  left_softkey            [IN]        Left softkey label
 *  left_softkey_icon       [IN]        Left softkey icon
 *  right_softkey           [IN]        Right softkey label
 *  right_softkey_icon      [IN]        Right softkey icon
 *  message                 [IN]        Message (max support two lines)
 *  input_type              [IN]        Input type. Only numeric or alpha-numeric passward is allowed
 *  buffer                  [IN]        Buffer the input box
 *  buffer_size             [IN]        Size of the buffer
 *  message2                [IN]        Second message below inputbox (scrolling text)
 *  history_buffer          [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory111Screen_int(
        U16 left_softkey,
        U16 right_softkey,
        U16 message,
        U32 input_type,
        U8 *buffer,
        S32 buffer_size,
        U8 *message2,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ShowCategory111Screen_ext(
        left_softkey,
        0,
        right_softkey,
        0,
        (U8*) get_string(message),
        input_type,
        buffer,
        buffer_size,
        message2,
        0,
        history_buffer);
}


/*****************************************************************************
 * FUNCTION
 *  Cat111ScrolTextBg
 * DESCRIPTION
 *  scrol text background
 * PARAMETERS
 *  x1      [IN]        Start x
 *  y1      [IN]        Start y
 *  x2      [IN]        End x
 *  y2      [IN]        End y
 * RETURNS
 *  void
 *****************************************************************************/
void Cat111ScrolTextBg(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifndef __MMI_WALLPAPER_ON_BOTTOM__
    gui_draw_filled_area(x1, y1, x2, y2, &pin_editor_background_filler);
#else
    wgui_category_clear_region_with_transparent_color(x1, y1, x2, y2);
#endif
}

#if defined(__MMI_MAINLCD_96X64__) 

/*****************************************************************************
 * FUNCTION
 *  RedrawCategoryControlledArea111Screen
 * DESCRIPTION
 *  redraw category111
 * PARAMETERS
 *  coordinate      [IN]     Area to redraw     
 * RETURNS
 *  void
 *****************************************************************************/
void RedrawCategoryControlledArea111Screen(dm_coordinates *coordinate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    color ccblack = {255, 255, 255, 100};
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_draw_rectangle(
        2,
        (MMI_singleline_inputbox.y -1),
        (UI_device_width - 2),
        (MMI_singleline_inputbox.y + MMI_SINGLELINE_INPUTBOX_HEIGHT),
        ccblack);

}
#endif /* __MMI_MAINLCD_96X64__ */

#ifndef __MMI_FTE_SUPPORT__  
   #ifndef __MMI_MAINLCD_96X64__
   void RedrawCategoryControlledArea111Screen_IME_HINT(dm_coordinates *coordinate);
   /*****************************************************************************
    * FUNCTION
    *  RedrawCategoryControlledArea111Screen_IME_HINT
    * DESCRIPTION
    *  redraw category111
    * PARAMETERS
    *  coordinate      [IN]     Area to redraw     
    * RETURNS
    *  void
    *****************************************************************************/
   void RedrawCategoryControlledArea111Screen_IME_HINT(dm_coordinates *coordinate)
       {
           /*----------------------------------------------------------------*/
           /* Local Variables                                                */
           /*----------------------------------------------------------------*/
           S32 x1 = 0, y1 = 0, x2 = 0, y2 = 0, sl_w = 0, sl_x = 0;
           U32 ime_w = 0;
           S32 Margin_WIDTH = 3;
           /*----------------------------------------------------------------*/
           /* Code Body                                                      */
           /*----------------------------------------------------------------*/   
           UI_UNUSED_PARAMETER(coordinate);
           gdi_layer_lock_frame_buffer();
           gdi_layer_push_clip();
       
           gdi_layer_set_clip(
               0, 
               MMI_singleline_inputbox.y,
               UI_device_width - 1,
               MMI_singleline_inputbox.y + MMI_singleline_inputbox.height - 1);
       
           ime_w = mmi_imc_get_input_mode_hint_width()+2;
       
           {
               x2 = UI_device_width  - 1 - Margin_WIDTH;
               y1 = MMI_singleline_inputbox.y;
               y2 = MMI_singleline_inputbox.y + MMI_singleline_inputbox.height - 1;
               ime_w = mmi_imc_get_input_mode_hint_width();
               x1 = x2 - ime_w + 1;
               sl_w = x1 - MMI_singleline_inputbox.x + 1;
               sl_x =  1 + Margin_WIDTH;
           }
       
           /* draw IME background */ 
          // gui_fill_rectangle(x1, y1, x2, y2,MMI_singleline_inputbox.normal_filler->c);
       
          gui_fill_rectangle(x1, y1, x2, y2,current_information_bar_theme->background_color);
           mmi_imc_draw_input_mode_hint(x1, y1, x2, y2);
       
           if (MMI_singleline_inputbox.width != sl_w || MMI_singleline_inputbox.x != x1)
           {
               wgui_inputs_sl_resize(sl_w, MMI_singleline_inputbox.height);
               wgui_inputs_sl_move(sl_x, MMI_singleline_inputbox.y);
               wgui_inputs_sl_redraw();
           }
           
           gdi_layer_pop_clip();
           gdi_layer_unlock_frame_buffer();
           gdi_layer_blt_previous(0, 0, UI_device_width - 1, UI_device_height - 1);
       }

   #endif 
#endif


/*****************************************************************************
 * FUNCTION
 *  ShowCategory111Screen_ext
 * DESCRIPTION
 *  Extension of category 111. Can support duration.
 * PARAMETERS
 *  left_softkey            [IN]        Left softkey label
 *  left_softkey_icon       [IN]        Icon for the Left softkey
 *  right_softkey           [IN]        Right softkey label
 *  right_softkey_icon      [IN]        Icon for the right softkey
 *  message                 [IN]        Message (two line)
 *  input_type              [IN]        Input type. Currently only numeric or alpha-numeric passward is allowed
 *  buffer                  [IN]        Buffer the input box
 *  buffer_size             [IN]        Size of the buffer
 *  message2                [IN]        Second message (scrolling)
 *  duration                [IN]        Auto close duration, only for numeric password
 *  history_buffer          [IN]        History buffe
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory111Screen_ext_int(
        U16 left_softkey,
        U16 right_softkey,
        U8 *message,
        U32 input_type,
        U8 *buffer,
        S32 buffer_size,
        U8 *message2,
        S32 duration,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_SMALL_PIN_EDIT_SCREEN__
    if (whether_no_small_screen())
    {
        ShowCategory112Screen(
            left_softkey,
            0,
            right_softkey,
            0,
            message,
            input_type,
            buffer,
            buffer_size,
            message2,
            history_buffer);
    }
    else
#endif /* __MMI_SMALL_PIN_EDIT_SCREEN__ */ 
    {
        S32 len;

        gdi_layer_lock_frame_buffer();
        
#ifdef __WGUI_CAT111_SUPPORT_DURATION__
        if (duration != 0)
        {
            /* Currently, only numeric password is allowed for duration. */
            /* Becasue the layout is restricted by virtual keypad */
            MMI_ASSERT(input_type == IMM_INPUT_TYPE_NUMERIC_PASSWORD);
        }
#endif /* __WGUI_CAT111_SUPPORT_DURATION__ */

        /* set softkey */
        dm_add_softkey_id(left_softkey, right_softkey);

#ifndef __MMI_WALLPAPER_ON_BOTTOM__
        pin_editor_background_filler = *current_MMI_theme->PIN_screen_background_filler;
        pin_editor_background_filler.flags = UI_FILLED_AREA_TYPE_COLOR;
        dm_add_back_fill_area(&pin_editor_background_filler);
#endif

        /* set two line message */
        len = gui_strlen((UI_string_type) message);
        create_multiline_inputbox_set_buffer((UI_string_type) message, len, len, 0);
#if defined(__MMI_MAINLCD_128X64__)
        MMI_multiline_inputbox.text_y = 0;
#endif /* __MMI_MAINLCD_128X64__ */
        MMI_multiline_inputbox.normal_text_color = *current_MMI_theme->list_normal_text_color;
        MMI_multiline_inputbox.flags |=
            (UI_MULTI_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW | UI_MULTI_LINE_INPUT_BOX_DISABLE_BACKGROUND |
             UI_MULTI_LINE_INPUT_BOX_DISABLE_SCROLLBAR | UI_MULTI_LINE_INPUT_BOX_VIEW_MODE);
        MMI_multiline_inputbox.ext_flags |= GUI_MULTI_LINE_INPUT_BOX_TRUNCATE_CONTENT;
#if defined(__MMI_MAINLCD_96X64__)
        MMI_multiline_inputbox.text_y = 0;
        MMI_multiline_inputbox.flags |=UI_MULTI_LINE_INPUT_BOX_ONLY_SHOW_FIRST_LINE;
        MMI_multiline_inputbox.flags |=UI_MULTI_LINE_INPUT_BOX_DISABLE_WRAPPING_BY_WORD;
#endif /* __MMI_MAINLCD_96X64__ */
#if defined(__MMI_MAINLCD_320X240__)
        MMI_multiline_inputbox.flags |= UI_MULTI_LINE_INPUT_BOX_DISABLE_WRAPPING_BY_WORD;
#endif
        wgui_inputs_ml_show_no_draw();

        mmi_imc_set_fixed_input_box();
        
        /* set input_box */
        wgui_inputs_sl_setup(
            CAT111_MARGIN,
            MMI_multiline_inputbox.y + MMI_multiline_inputbox.height + 1 /* gap */, /* according to the multi-line input-box above */
            UI_device_width - (CAT111_MARGIN << 1),
            MMI_SINGLELINE_INPUTBOX_HEIGHT,
            buffer,
            buffer_size,
            MMI_CATEGORY111_ID,
            get_string(right_softkey),
            NULL,
            input_type,
            history_buffer,
            0);

        gui_set_single_line_input_box_theme(&MMI_singleline_inputbox, &PIN_singleline_inputbox_theme);
#if defined(__MMI_MAINLCD_96X64__)        
       dm_register_category_controlled_callback(RedrawCategoryControlledArea111Screen);
#endif /* __MMI_MAINLCD_96X64__ */
        
#ifndef __MMI_FTE_SUPPORT__  //
   #ifndef __MMI_MAINLCD_96X64__
    if(input_type !=IMM_INPUT_TYPE_NUMERIC_PASSWORD)  
    {  
       dm_register_category_controlled_callback(RedrawCategoryControlledArea111Screen_IME_HINT);   
       g_wgui_cat111_draw_information_bar_func =  RedrawCategoryControlledArea111Screen_IME_HINT;
    }
    else
    {
        g_wgui_cat111_draw_information_bar_func = NULL;
    }
   #endif 
#endif
        /* set scrolling text */
        dm_add_scroll_text((UI_string_type) message2, NULL, Cat111ScrolTextBg, *current_MMI_theme->list_normal_text_color, *current_MMI_theme->list_normal_text_color);

        gdi_layer_unlock_frame_buffer();

        dm_register_vkpad_callback(mmi_imc_redraw_screen_by_state);
        wgui_cat_setup_category_default_history(
            MMI_CATEGORY111_ID,
            DM_CLEAR_SCREEN_BACKGROUND | DM_NO_TITLE | DM_SHOW_VKPAD,
            ExitCategory111Screen);

        dm_redraw_category_screen();

#ifdef __WGUI_CAT111_SUPPORT_DURATION__
        Cat111CountDownValue = duration;
        if (Cat111CountDownValue != 0)
        {
            Cat111CountDownCallBack();
        }
#endif /* __WGUI_CAT111_SUPPORT_DURATION__ */
    }
}   /* end of ShowCategory111Screen */


/*****************************************************************************
 * FUNCTION
 *  ExitCategory111Screen
 * DESCRIPTION
 *  Exits category 184 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitCategory111Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_inputs_ml_reset();
    StopTimer(POPUP_TIMER);
#ifdef __WGUI_CAT111_SUPPORT_DURATION__
    Cat111TimerExpireCallBack = UI_dummy_function;
#endif /* __WGUI_CAT111_SUPPORT_DURATION__ */
    g_wgui_cat111_draw_information_bar_func = NULL;
    wgui_inputs_sl_close();
}


#ifdef __MMI_SEARCH_WEB__

#if defined(__MMI_FTE_SUPPORT__) && defined(__MMI_TOUCH_SCREEN__)

#if (defined (__MMI_MAINLCD_240X320__))
#define WGUI_CAT2001_SEARCH_BUTTON_GAP_L              (5)
#define WGUI_CAT2001_SEARCH_BUTTON_GAP_R              (3)
#elif (defined (__MMI_MAINLCD_240X400__))
#define WGUI_CAT2001_SEARCH_BUTTON_GAP_L              (5)
#define WGUI_CAT2001_SEARCH_BUTTON_GAP_R              (3)
#elif (defined (__MMI_MAINLCD_320X480__))
#define WGUI_CAT2001_SEARCH_BUTTON_GAP_L              (6)
#define WGUI_CAT2001_SEARCH_BUTTON_GAP_R              (8)
#elif (defined (__MMI_MAINLCD_480X800__))
#define WGUI_CAT2001_SEARCH_BUTTON_GAP_L              (0)
#define WGUI_CAT2001_SEARCH_BUTTON_GAP_R              (0)
#else
#define WGUI_CAT2001_SEARCH_BUTTON_GAP_L              (0)
#define WGUI_CAT2001_SEARCH_BUTTON_GAP_R              (0)
#endif

static U16 g_wgui_cat2001_search_button_id = 0;
static PU8 g_wgui_cat2001_search_button_up_image = NULL;
static PU8 g_wgui_cat2001_search_button_down_image = NULL;
static FuncPtr g_wgui_cat2001_search_button_function = NULL;
#endif /* #if defined(__MMI_FTE_SUPPORT__) && defined(__MMI_TOUCH_SCREEN__) */

/* total size of input buffer */
extern S32 wgui_singleline_inputbox_buffer_size;
/* for infor-bar logo */
static PU8 g_wgui_cat2001_info_bar_icon;
/* for counter based on GB2312 */
static U8 g_wgui_cat2001_buf_used_size;
static S32 g_wgui_cat2001_ime_ui_height = 0;
/* for input method to tell category the height of virtual keyboard */
void (*g_wgui_cat2001_resize_and_draw_func) (S32);
/* for application use key_up_arrow and key_down_arrow */
void (*g_wgui_cat2001_set_special_key_func)(void) = NULL;

#ifdef __MMI_CATEGORY2001_PANEL_SUPPORT__
static wgui_cat2001_panel_element_struct *g_wgui_cat2001_element_list = NULL;
static wgui_cat2001_highlight_change_callback g_wgui_cat2001_highlight_change_callback = NULL;
static S32 g_wgui_cat2001_num_of_element = 0;
static S32 g_wgui_cat2001_focused_element = -1;
static U32 g_wgui_cat2001_repent_period = 0;
static S32 g_wgui_cat2001_panel_handle;
#endif /* #ifdef __MMI_CATEGORY2001_PANEL_SUPPORT__ */

#ifndef __MMI_FTE_SUPPORT__
/* Singleline inputbox filler */
static UI_filled_area g_wgui_cat2001_inputbox_BG_filler = 
{
    UI_FILLED_AREA_TYPE_COLOR,
    UI_NULL_IMAGE,
    NULL,
    {255, 255, 255, 100},
    {0, 0, 0, 0},
    {255, 255, 255, 100},
    {255, 255, 255, 100},
    0
};
static UI_single_line_input_box_theme g_wgui_cat2001_singleline_inputbox_theme = { 
    &g_wgui_cat2001_inputbox_BG_filler,
    &g_wgui_cat2001_inputbox_BG_filler,
    &g_wgui_cat2001_inputbox_BG_filler,
    {0, 0, 0, 100},
    {128, 128, 128, 100},
    {0, 0, 0, 100},
    {255, 255, 255, 100},
    {51, 88, 171, 100},
    {255, 0, 0, 100},
    &UI_DEFAULT_FONT,
    1,
    UI_SINGLE_LINE_INPUT_BOX_CENTER_Y,
    '*'
};
#endif /* __MMI_FTE_SUPPORT__ */
#if defined(__COSMOS_MMI_PACKAGE__)
/* Singleline inputbox filler */
static UI_filled_area g_wgui_cat2001_inputbox_BG_filler = 
{
	UI_FILLED_AREA_TYPE_COLOR,
	UI_NULL_IMAGE,
	NULL,
	{0, 0, 0, 100},
	{0, 0, 0, 0},
	{0, 0, 0, 100},
	{0, 0, 0, 100},
	0
};
#endif /* __COSMOS_MMI_PACKAGE__ */

#ifdef __MMI_CATEGORY2001_PANEL_SUPPORT__
static MMI_BOOL wgui_cat2001_is_show_panel(void);
#endif /* __MMI_CATEGORY2001_PANEL_SUPPORT__ */
static void wgui_cat2001_register_navigation_kay(void);
static void wgui_cat2001_change_callback(void);

/*****************************************************************************
 * FUNCTION
 *  wgui_cat2001_redraw_counter
 * DESCRIPTION
 *  Show the counter of the info-bar 
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat2001_redraw_counter(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#if !defined(__MMI_TOUCH_SCREEN__)
    stFontAttribute *f = &MMI_small_font;
#else /* !defined(__MMI_TOUCH_SCREEN__) */ 
    stFontAttribute *f = &MMI_medium_font;
#endif /* !defined(__MMI_TOUCH_SCREEN__) */ 
    S32 w, h;
    UI_character_type str[32];
    color c;
    S32 panel_h = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer(); 

#ifdef __MMI_CATEGORY2001_PANEL_SUPPORT__
    if (wgui_cat2001_is_show_panel())
    {
        panel_h = WGUI_CAT2001_INFO_BAR_HEIGHT;
    }
#endif /* __MMI_CATEGORY2001_PANEL_SUPPORT__ */  

    gui_reset_text_clip();

    gui_sprintf(str, "%d/%d", g_wgui_cat2001_buf_used_size, (wgui_singleline_inputbox_buffer_size - 1));
    c = *current_MMI_theme->title_text_color;
    gui_set_font(f);
    gui_set_text_color(c);
    gui_set_text_border_color(*current_MMI_theme->title_text_border_color);
    
    gui_measure_string(str, &w, &h);

    if(mmi_fe_get_r2l_state())
    {
        gui_move_text_cursor(
            UI_device_width - 4, 
            MMI_singleline_inputbox.y - ((WGUI_CAT2001_INFO_BAR_HEIGHT + h)>>1) - panel_h);
    }
    else
    {
        gui_move_text_cursor(
            UI_device_width - w - 4, 
            MMI_singleline_inputbox.y - ((WGUI_CAT2001_INFO_BAR_HEIGHT + h)>>1) - panel_h);
    }

    gui_print_bordered_text(str);

    gdi_layer_unlock_frame_buffer();
    gui_BLT_double_buffer(0, MMI_singleline_inputbox.y - WGUI_CAT2001_INFO_BAR_HEIGHT - panel_h, UI_device_width - 1, MMI_singleline_inputbox.y);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat2001_redraw_information_bar
 * DESCRIPTION
 *  Show information bar 
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat2001_redraw_information_bar(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gdi_handle cat2001_active_layer;
    gui_panel_struct *cat2001_panel;
    S32 panel_h = 0;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer(); 

#ifdef __MMI_CATEGORY2001_PANEL_SUPPORT__
    if (wgui_cat2001_is_show_panel())
    {
        panel_h = WGUI_CAT2001_INFO_BAR_HEIGHT;
    }        
#endif /* __MMI_CATEGORY2001_PANEL_SUPPORT__ */
/* draw the background of the info-bar and singleline inputbox */  
#if defined(__COSMOS_MMI_PACKAGE__) 
    gui_draw_filled_area(
		0, 
		MMI_singleline_inputbox.y - WGUI_CAT2001_INFO_BAR_HEIGHT - panel_h, 
		UI_device_width - 1, 
		MMI_singleline_inputbox.y - 1,
		&g_wgui_cat2001_inputbox_BG_filler);

#else	
    gui_draw_filled_area(
		0, 
		MMI_singleline_inputbox.y - WGUI_CAT2001_INFO_BAR_HEIGHT - panel_h, 
		UI_device_width - 1, 
		MMI_singleline_inputbox.y - 1,
		(current_MMI_theme->singleline_editor_bg_filler));
#endif	
    
#ifndef __MMI_FTE_SUPPORT__
    /* show the inputbox border */
    gdi_draw_rect(
        MMI_singleline_inputbox.x - 1,
        MMI_singleline_inputbox.y - 1,
        MMI_singleline_inputbox.x + MMI_singleline_inputbox.width,
        MMI_singleline_inputbox.y + MMI_singleline_inputbox.height,
        WGUI_CAT2001_BORDER_COLOR);
#endif

    /* show the info-bar border */
    gdi_draw_line(
		0, 
		MMI_singleline_inputbox.y - WGUI_CAT2001_INFO_BAR_HEIGHT - panel_h - 1, 
		UI_device_width - 1, 
		MMI_singleline_inputbox.y - WGUI_CAT2001_INFO_BAR_HEIGHT - panel_h - 1,
		WGUI_CAT2001_BORDER_COLOR);

    /* show the IME icon */
    gdi_layer_get_active(&cat2001_active_layer);
    gdi_push_and_set_alpha_blending_source_layer(cat2001_active_layer);
    mmi_imc_draw_input_mode_infor(
        UI_device_width - mmi_imc_get_ime_infor_width() - WGUI_CAT2001_COUNTER_MAX_WIDTH, 
        MMI_singleline_inputbox.y - ((WGUI_CAT2001_INFO_BAR_HEIGHT + WGUI_CAT2001_INPUT_MODE_ICON_MAX_HEIGHT)>>1) - panel_h - 1, 
        UI_device_width - WGUI_CAT2001_COUNTER_MAX_WIDTH,
        MMI_singleline_inputbox.y - ((WGUI_CAT2001_INFO_BAR_HEIGHT - WGUI_CAT2001_INPUT_MODE_ICON_MAX_HEIGHT)>>1) - panel_h - 1);

    /* show the logo of info-bar */
    gui_show_image(2, MMI_singleline_inputbox.y - WGUI_CAT2001_INFO_BAR_HEIGHT  - panel_h + 1, g_wgui_cat2001_info_bar_icon);
    gdi_pop_and_restore_alpha_blending_source_layer();

    /* show the counter */
#ifndef __MMI_MAINLCD_128X160__
    wgui_cat2001_redraw_counter();
#endif

#ifdef __MMI_CATEGORY2001_PANEL_SUPPORT__
    /* show panel */
    if (wgui_cat2001_is_show_panel())
    {
        S32 i, img_w, img_h;
        cat2001_panel = dm_get_panel(g_wgui_cat2001_panel_handle);
        cat2001_panel->x = 0;
        cat2001_panel->y = MMI_singleline_inputbox.y - WGUI_CAT2001_INFO_BAR_HEIGHT - 1;
        for (i = 0; i < g_wgui_cat2001_num_of_element; i++)
        {
            gdi_image_get_dimension(g_wgui_cat2001_element_list[i].off_imageid, &img_w, &img_h);
            cat2001_panel->elements[i].y1 = MMI_singleline_inputbox.y - WGUI_CAT2001_INFO_BAR_HEIGHT + ((WGUI_CAT2001_INFO_BAR_HEIGHT - img_h) >> 1) - 1;
            cat2001_panel->elements[i].y2 = cat2001_panel->elements[i].y1 + img_h;
        }

        /* set single line pen area */
        if (i == (cat2001_panel->element_count - 1))
        {
            cat2001_panel->elements[i].x1 = MMI_singleline_inputbox.x;
            cat2001_panel->elements[i].y1 = MMI_singleline_inputbox.y;
            cat2001_panel->elements[i].x2 = MMI_singleline_inputbox.x + MMI_singleline_inputbox.width - 1;
            cat2001_panel->elements[i].y2 = MMI_singleline_inputbox.y + MMI_singleline_inputbox.height - 1;
        }
        gui_panel_show(cat2001_panel);
    }
#endif /* __MMI_CATEGORY2001_PANEL_SUPPORT__ */

    gdi_layer_unlock_frame_buffer();
    gdi_lcd_repaint_all();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat2001_resize_and_draw
 * DESCRIPTION
 *  1. Move singleline inputbox based on IME.
 *  2. Redraw the singleline inputbox, and information bar.
 * PARAMETERS
 *  virtual_keyboard_h            [IN]          Height of virtual keyboard
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat2001_resize_and_draw(S32 virtual_keyboard_h)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 singleline_y;
    S32 gap;
#if defined(__MMI_FTE_SUPPORT__) && defined(__MMI_TOUCH_SCREEN__)
    icontext_button *search_bt;
    S32 bt_w, bt_h;
    gdi_handle cat2001_active_layer;
#endif
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_wgui_cat2001_ime_ui_height = virtual_keyboard_h;
    gdi_layer_lock_frame_buffer();    

#ifdef __MMI_VIRTUAL_KEYBOARD__
    gap = (virtual_keyboard_h <= 2) ? 2 : 0 /* border */;
#else
    gap = 2;
#endif
    
    /* set singleline inputbox position */
    singleline_y = UI_device_height - MMI_BUTTON_BAR_HEIGHT - virtual_keyboard_h - gap - MMI_SINGLELINE_INPUTBOX_HEIGHT - 1;
    move_singleline_inputbox((UI_device_width - MMI_SINGLELINE_INPUTBOX_WIDTH) >> 1, singleline_y); 

    /* clear the background */  
    wgui_category_clear_region_with_transparent_color(
        0, 
        0, 
        UI_device_width - 1, 
        MMI_singleline_inputbox.y - WGUI_CAT2001_INFO_BAR_HEIGHT);

    /* draw the background of the singleline inputbox */  
    if (gap == 0)
    {
#if defined(__COSMOS_MMI_PACKAGE__)
			gui_draw_filled_area(
				0, 
				MMI_singleline_inputbox.y, 
				UI_device_width - 1, 
				UI_device_height - MMI_BUTTON_BAR_HEIGHT - virtual_keyboard_h,
				&g_wgui_cat2001_inputbox_BG_filler);
#else	
			gui_draw_filled_area(
				0, 
				MMI_singleline_inputbox.y, 
				UI_device_width - 1, 
				UI_device_height - MMI_BUTTON_BAR_HEIGHT - virtual_keyboard_h,
				(current_MMI_theme->singleline_editor_bg_filler));
#endif	
    }
    else
    {
#if defined(__COSMOS_MMI_PACKAGE__)
					gui_draw_filled_area(
						0, 
						MMI_singleline_inputbox.y, 
						UI_device_width - 1, 
						MMI_singleline_inputbox.y + MMI_SINGLELINE_INPUTBOX_HEIGHT + gap,
					    &g_wgui_cat2001_inputbox_BG_filler);

#else	
					gui_draw_filled_area(
						0, 
						MMI_singleline_inputbox.y, 
						UI_device_width - 1, 
						MMI_singleline_inputbox.y + MMI_SINGLELINE_INPUTBOX_HEIGHT + gap,
						(current_MMI_theme->singleline_editor_bg_filler));
#endif	
    }

#if defined(__MMI_FTE_SUPPORT__) && defined(__MMI_TOUCH_SCREEN__)
    /* setup search button */
    search_bt = dm_get_button(g_wgui_cat2001_search_button_id);
    gdi_image_get_dimension(g_wgui_cat2001_search_button_up_image, &bt_w, &bt_h);
    if ((bt_w > 0) && (bt_h > 0))
    {
        gui_move_icontext_button(
            search_bt, 
            UI_device_width - WGUI_CAT2001_SEARCH_BUTTON_GAP_L - WGUI_CAT2001_SEARCH_BUTTON_GAP_R- bt_w,
            MMI_singleline_inputbox.y + (((MMI_SINGLELINE_INPUTBOX_HEIGHT) - (bt_h)) >> 1));
        gui_resize_icontext_button(search_bt, bt_w, bt_h);
        gui_icontext_button_overwirte_pen_response_area(
            search_bt,
            search_bt->x,
            search_bt->y,
            search_bt->x + search_bt->width,
            search_bt->y + search_bt->height);

        /* show search button */
        gdi_layer_get_active(&cat2001_active_layer);
        gdi_push_and_set_alpha_blending_source_layer(cat2001_active_layer);
        gui_show_icontext_button(search_bt);
        gdi_pop_and_restore_alpha_blending_source_layer();

        /* show the singleline inputbox */
        wgui_inputs_sl_resize(
            MMI_SINGLELINE_INPUTBOX_WIDTH - WGUI_CAT2001_SEARCH_BUTTON_GAP_L - WGUI_CAT2001_SEARCH_BUTTON_GAP_R - bt_w,
            MMI_singleline_inputbox.height);
        wgui_inputs_sl_show();
    }
    else 
    {
        wgui_inputs_sl_show();
    }

#else
    /* show the singleline inputbox */
    wgui_inputs_sl_show();
#endif /* #if defined(__MMI_FTE_SUPPORT__) && defined(__MMI_TOUCH_SCREEN__) */

    /* show the info-bar */
    wgui_cat2001_redraw_information_bar();
    
    gdi_layer_unlock_frame_buffer();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat2001_draw_virtual_keypad_background
 * DESCRIPTION
 *  Draw the virtual keypad area by IME.
 * PARAMETERS
 *  x1      [IN]        start X
 *  y1      [IN]        start Y
 *  x2      [IN]        end X
 *  y2      [IN]        end Y
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat2001_draw_virtual_keypad_background(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_push_clip();
    gdi_layer_set_clip(x1, y1, x2, y2);

    gui_fill_rectangle(x1, y1, x2, y2, WGUI_CAT2001_BG_COLOR);
    //TODO: we need to add a new theme for VK_BG, the singleline background should not same to VK background.
    //gui_fill_rectangle(x1, y1, x2, y2, (current_MMI_theme->singleline_editor_bg_filler->c));
    //gui_draw_filled_area(x1, y1, x2, y2, (current_MMI_theme->singleline_editor_bg_filler));

    gdi_layer_pop_clip();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat2001_draw_sl_background
 * DESCRIPTION
 *  Draw the virtual keypad area by IME.
 * PARAMETERS
 *  x1      [IN]        start X
 *  y1      [IN]        start Y
 *  x2      [IN]        end X
 *  y2      [IN]        end Y
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat2001_draw_sl_background(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_push_clip();
    gdi_layer_set_clip(x1, y1, x2, y2);

    gui_draw_filled_area(x1, y1, x2, y2, (current_MMI_theme->singleline_editor_bg_filler));

    gdi_layer_pop_clip();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat2001_draw_ctrl_area
 * DESCRIPTION
 *  For IME redraw.
 * PARAMETERS
 *  coordinate   [IN]  Unused.
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat2001_draw_ctrl_area(dm_coordinates *coordinate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!mmi_imc_redraw_screen_by_state_ext())
    {
        wgui_cat2001_resize_and_draw(g_wgui_cat2001_ime_ui_height);
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat2001_initialize_counter
 * DESCRIPTION
 *  Function to take only buffer upto limit
 * PARAMETERS
 *  buffer      [IN/OUT]        To change the string buffer to the passed size
 * RETURNS
 *  S32         The used buffer size.
 *****************************************************************************/
static S32 wgui_cat2001_initialize_counter(U8 *buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 i = 0;
    U8 char_len;
    U16 ucs2_char;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_wgui_cat2001_buf_used_size = 0;
    ucs2_char = (buffer[i]) | ((buffer[i + 1] << 8));
    char_len = wgui_inputs_ucs2_to_gb_len(ucs2_char);
    while (ucs2_char && (g_wgui_cat2001_buf_used_size + char_len <= (wgui_singleline_inputbox_buffer_size - 1)))
    {
        g_wgui_cat2001_buf_used_size += char_len;
        i += ENCODING_LENGTH;
        ucs2_char = (buffer[i]) | ((buffer[i + 1] << 8));
        char_len = wgui_inputs_ucs2_to_gb_len(ucs2_char);
    }
    buffer[i] = 0;
    buffer[i + 1] = 0;

    return i;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat2001_text_change_event_callback
 * DESCRIPTION
 *  Function to call info bar fillers
 * PARAMETERS
 *  event       [IN]        Action performed on insert, delete character or delete all
 *  C           [IN]        Character to insert or delete
 * RETURNS
 *  void
 *****************************************************************************/
static MMI_BOOL wgui_cat2001_text_change_event_callback(gui_multi_line_input_box_change_event_enum event, U16 C)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL result = MMI_TRUE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (event)
    {
        case GUI_MULTI_LINE_INPUT_BOX_INSERT_CHAR:
            if (g_wgui_cat2001_buf_used_size + wgui_inputs_ucs2_to_gb_len(C) > (wgui_singleline_inputbox_buffer_size - 1))
            {
                result = MMI_FALSE;
            }
            else
            {
                g_wgui_cat2001_buf_used_size += wgui_inputs_ucs2_to_gb_len(C);
            }
            break;
        case GUI_MULTI_LINE_INPUT_BOX_DELETE_CHAR:
            g_wgui_cat2001_buf_used_size -= wgui_inputs_ucs2_to_gb_len(C);
            break;
        case GUI_MULTI_LINE_INPUT_BOX_DELETEALL:
            g_wgui_cat2001_buf_used_size = 0;
            break;
        case GUI_MULTI_LINE_INPUT_BOX_INSERT_STRING:
            if ((g_wgui_cat2001_buf_used_size + C) > (wgui_singleline_inputbox_buffer_size - 1))
            {
                result = MMI_FALSE;
            }
            break;
    }
    
    /* redraw infor-bar */
    wgui_cat2001_redraw_information_bar();
    
    if (result == MMI_FALSE)
    {
#ifdef __MMI_CATEGORY2001_PANEL_SUPPORT__
        if (wgui_cat2001_is_show_panel())
        {
            wgui_cat2001_change_callback();
        }
#endif /* __MMI_CATEGORY2001_PANEL_SUPPORT__ */
        UI_editor_play_tone_cannot_insert();
    }
    
    return result;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat2001_set_special_key_function
 * DESCRIPTION
 *  set category2001 screen special key callback function
 * PARAMETERS
 *  f       [IN]        Callback function
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat2001_set_special_key_function(void (*f) (void))
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_wgui_cat2001_set_special_key_func = f;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat2001_execute_special_key_function
 * DESCRIPTION
 *  execute category2001 screen special key callback function
 * PARAMETERS
 *  f       [IN]        Callback function
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat2001_reset_special_key(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_wgui_cat2001_set_special_key_func != NULL)
    {
        g_wgui_cat2001_set_special_key_func();
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat2001_get_history_size
 * DESCRIPTION
 *  Get category2001 history size.
 * PARAMETERS
 *  void
 * RETURNS
 *  the size of history buffer
 *****************************************************************************/
static S32 wgui_cat2001_get_history_size(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return (((sizeof(singleline_inputbox_category_history) + 3) / 4) * 4 + 
             sizeof(panel_category_history));
}  


/*****************************************************************************
 * FUNCTION
 *  wgui_cat2001_get_history
 * DESCRIPTION
 *  Get category2001 history.
 * PARAMETERS
 *  history_buffer      [IN]        History buffer
 * RETURNS
 *  hitsory buffer
 *****************************************************************************/
static U8 *wgui_cat2001_get_history(U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *h;
    S32 sl_s;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_inputs_sl_get_category_history((U16) MMI_CAT2001_ID, history_buffer);
    sl_s = sizeof(singleline_inputbox_category_history);
    sl_s = (sl_s + 3) / 4;
    sl_s *= 4;

    h = (U8*)(history_buffer + sl_s);
    get_panel_category_history((U16) MMI_CAT2001_ID, h);

    return history_buffer;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat2001_get_inputbox_coordinate
 * DESCRIPTION
 *  get the Y-axis of the single line inputbox, only for category2001.
 * PARAMETERS
 *  inputbox       [IN] coordinates of single line inputbox.
 * RETURNS
 *  void.
 *****************************************************************************/
void wgui_cat2001_get_inputbox_coordinate(wgui_cat_inputbox_coordinate_struct *inputbox)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    inputbox->x = MMI_singleline_inputbox.x;
    inputbox->y = MMI_singleline_inputbox.y;
    inputbox->width = MMI_singleline_inputbox.width;
    inputbox->height = MMI_singleline_inputbox.height;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat2001_exit
 * DESCRIPTION
 *  Exit category2001 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat2001_exit(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#ifdef __MMI_VIRTUAL_KEYBOARD__
#ifndef __MMI_UI_VIRTUAL_KEYBOARD_DEFAULT_VERSION_1__
    S32 vk_x, vk_y;
#endif
#endif
    S32 panel_h = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_CATEGORY2001_PANEL_SUPPORT__
    if (wgui_cat2001_is_show_panel())
    {
        panel_h = WGUI_CAT2001_INFO_BAR_HEIGHT;
    }
#endif /* __MMI_CATEGORY2001_PANEL_SUPPORT__ */
    reset_small_screen();

    wgui_inputs_sl_close();
    g_wgui_cat2001_resize_and_draw_func = NULL;

    /* darken Inputbox area */
#ifdef __MMI_VIRTUAL_KEYBOARD__
#ifdef __MMI_UI_VIRTUAL_KEYBOARD_DEFAULT_VERSION_1__
    gdi_draw_darken_rect(
        0, 
        MMI_singleline_inputbox.y - WGUI_CAT2001_INFO_BAR_HEIGHT  - panel_h - 1, 
        UI_device_width - 1, 
        MMI_virtual_keyboard.y - 2,
        WGUI_CAT2001_DARKEN_PERCENT);
#else
    wgui_virtual_keyboard_get_positon(&vk_x, &vk_y);
    gdi_draw_darken_rect(
        0, 
        MMI_singleline_inputbox.y - WGUI_CAT2001_INFO_BAR_HEIGHT - panel_h - 1, 
        UI_device_width - 1, 
        vk_y - 2,
        WGUI_CAT2001_DARKEN_PERCENT);
#endif /* __MMI_UI_VIRTUAL_KEYBOARD_DEFAULT_VERSION_1__ */
#else  /* __MMI_VIRTUAL_KEYBOARD__ */
    gdi_draw_darken_rect(
        0, 
        MMI_singleline_inputbox.y - WGUI_CAT2001_INFO_BAR_HEIGHT - panel_h - 1, 
        UI_device_width - 1, 
        UI_device_height - MMI_SOFTKEY_HEIGHT - 1,
        WGUI_CAT2001_DARKEN_PERCENT);
#endif /* __MMI_VIRTUAL_KEYBOARD__ */

#if defined(__MMI_FTE_SUPPORT__) && defined(__MMI_TOUCH_SCREEN__)
    g_wgui_cat2001_search_button_id = 0;
    g_wgui_cat2001_search_button_up_image = NULL;
    g_wgui_cat2001_search_button_down_image = NULL;
    g_wgui_cat2001_search_button_function = NULL;
#endif
    wgui_cat2001_setup_panel(NULL, 0, 0, 0, NULL);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat2001_setup_search_button
 * DESCRIPTION
 *  Setup the search button of category2001.
 * PARAMETERS
 *  up_image   :       [IN] (N/A) the normal status image of search button.
 *  down_image :       [IN] (N/A) the press-down status image of search button.
 *  search_function :  [IN] (N/A) search function.
 * RETURNS
 *  void.
 *****************************************************************************/
void wgui_cat2001_setup_search_button(PU8 up_image, PU8 down_image, FuncPtr search_function)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(__MMI_FTE_SUPPORT__) && defined(__MMI_TOUCH_SCREEN__)
    g_wgui_cat2001_search_button_up_image = up_image;
    g_wgui_cat2001_search_button_down_image = down_image;
    g_wgui_cat2001_search_button_function = search_function;
#endif
}


#if defined(__MMI_FTE_SUPPORT__) && defined(__MMI_TOUCH_SCREEN__)
/*****************************************************************************
 * FUNCTION
 *  wgui_cat2001_search_button_handler
 * DESCRIPTION
 *  search button handler.
 * PARAMETERS
 *  history_buffer      [IN]        History buffer
 * RETURNS
 *  hitsory buffer
 *****************************************************************************/
static void wgui_cat2001_search_button_handler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if ( g_wgui_cat2001_search_button_function != NULL)
    {
        g_wgui_cat2001_search_button_function();
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat2001_clear_search_button_bg
 * DESCRIPTION
 *  clear button area.
 * PARAMETERS
 *  button   [IN]   button information
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat2001_clear_search_button_bg(void *button)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    icontext_button *b = (icontext_button*) button;
    S32 x1 = b->x;
    S32 y1 = b->y;
    S32 x2 = b->x + b->width - 1;
    S32 y2 = b->y + b->height - 1;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer(); 

    /* draw the background */  
    gui_draw_filled_area(x1, y1, x2 + 1, y2 + 1, (current_MMI_theme->singleline_editor_bg_filler));

    gdi_layer_unlock_frame_buffer();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat2001_search_button_draw_down
 * DESCRIPTION
 *  draw pen down of button
 * PARAMETERS
 *  button_object       [IN]        The target button
 * RETURNS
 *  void
 *****************************************************************************/
static MMI_BOOL wgui_cat2001_search_button_draw_down(void *button_object)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    icontext_button *current_bt;
    GDI_HANDLE act_layer = GDI_NULL_HANDLE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    current_bt = dm_get_button(g_wgui_cat2001_search_button_id);
    
    if (button_object != (void*)current_bt)
    {
        return MMI_TRUE;
    }
    
    mmi_imc_reset_ime_state();
    
    gdi_layer_get_active(&act_layer);
    
    if (act_layer != GDI_NULL_HANDLE)
    {
        gdi_push_and_set_alpha_blending_source_layer(act_layer);
    }
    gui_icontext_button_show_down_by_pen((void*)current_bt);
    if (act_layer != GDI_NULL_HANDLE)
    {
        gdi_pop_and_restore_alpha_blending_source_layer();
    }
    return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat2001_search_button_draw_up
 * DESCRIPTION
 *  draw pen up of button
 * PARAMETERS
 *  button_object       [IN]        The target button
 * RETURNS
 *  void
 *****************************************************************************/
static MMI_BOOL wgui_cat2001_search_button_draw_up(void *button_object)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    icontext_button *current_bt;
    GDI_HANDLE act_layer = GDI_NULL_HANDLE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    current_bt = dm_get_button(g_wgui_cat2001_search_button_id);
    
    if (button_object != (void*)current_bt)
    {
        return MMI_TRUE;
    }
    
    gdi_layer_get_active(&act_layer);
    
    if (act_layer != GDI_NULL_HANDLE)
    {
        gdi_push_and_set_alpha_blending_source_layer(act_layer);
    }
    gui_icontext_button_show_up_by_pen((void*)current_bt);
    if (act_layer != GDI_NULL_HANDLE)
    {
        gdi_pop_and_restore_alpha_blending_source_layer();
    }
    return MMI_TRUE;

}
#endif /* #if defined(__MMI_FTE_SUPPORT__) && defined(__MMI_TOUCH_SCREEN__) */

#ifdef __MMI_CATEGORY2001_PANEL_SUPPORT__

/*****************************************************************************
 * FUNCTION
 *  wgui_cat2001_is_show_panel
 * DESCRIPTION
 *  Setup the buttons in information bar.
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
static MMI_BOOL wgui_cat2001_is_show_panel(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if ((g_wgui_cat2001_element_list != NULL) && (g_wgui_cat2001_num_of_element > 0))
    {
        return MMI_TRUE;
    }
    else
    {
        return MMI_FALSE;
    }
}
#endif /* __MMI_CATEGORY2001_PANEL_SUPPORT__ */


/*****************************************************************************
 * FUNCTION
 *  wgui_cat2001_dummy_func
 * DESCRIPTION
 *  for pen event 
 * PARAMETERS
 *  x            [IN]        x of the top-left of the title
 *  y            [IN]        y of the top-left of the title
 *  clip_x1      [IN]        x1 of the clip area
 *  clip_y1      [IN]        y1 of the clip area
 *  clip_x2      [IN]        x2 of the clip area
 *  clip_y2      [IN]        y2 of the clip area
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat2001_dummy_func(
                    S32 x, 
                    S32 y, 
                    S32 clip_x1, 
                    S32 clip_y1, 
                    S32 clip_x2, 
                    S32 clip_y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
}
#ifdef __MMI_CATEGORY2001_PANEL_SUPPORT__


/*****************************************************************************
 * FUNCTION
 *  wgui_cat2001_setup_panel
 * DESCRIPTION
 *  Setup the buttons in information bar.
 * PARAMETERS
 *  wgui_cat2001_panel_element_struct   [IN]        Logo of infomation bar.
 *  num_of_element                      [IN]        Left softkey string.
 *  focused_element                     [IN]        Left softkey icon.
 *  repent_period                       [IN]        Right softkey string.
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat2001_setup_panel(
        wgui_cat2001_panel_element_struct *element_list,
        S32 num_of_element,
        S32 focused_element,
        U32 repent_period,
        wgui_cat2001_highlight_change_callback highlight_change_callback)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_wgui_cat2001_element_list = element_list;
    g_wgui_cat2001_num_of_element = num_of_element;
    g_wgui_cat2001_focused_element = focused_element;
    g_wgui_cat2001_repent_period = repent_period;   
    g_wgui_cat2001_highlight_change_callback = highlight_change_callback;
}
#else  /* __MMI_CATEGORY2001_PANEL_SUPPORT__ */          
void wgui_cat2001_setup_panel(
        wgui_cat2001_panel_element_struct *element_list,
        S32 num_of_element,
        S32 focused_element,
        U32 repent_period,
        wgui_cat2001_highlight_change_callback highlight_change_callback)
{

}

#endif /* __MMI_CATEGORY2001_PANEL_SUPPORT__ */
#ifdef __MMI_CATEGORY2001_PANEL_SUPPORT__

/*****************************************************************************
 * FUNCTION
 *  wgui_cat2001_editor_msg_callback
 * DESCRIPTION
 *  Eidtor/IME callback function
 *  
 * PARAMETERS
 *  input_box_handle    [IN]  inputbox handle
 *  msg_ptr             [IN]  message type
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat2001_change_highlight(S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gui_panel_struct *cat2001_panel = dm_get_panel(g_wgui_cat2001_panel_handle);
    S32 current_highlight = gui_panel_get_element_focus(cat2001_panel);

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (current_highlight != index)
    {
        gui_panel_set_element_focus(cat2001_panel, index, MMI_TRUE);
        if (g_wgui_cat2001_highlight_change_callback)
        {
            g_wgui_cat2001_highlight_change_callback(index);
        }

        /* highlight to editor */
        if (index == g_wgui_cat2001_num_of_element)
        {
            wgui_inputs_sl_enable();
            wgui_inputs_sl_set_RSK();
            register_right_softkey_handler();
        }
        else
        {
            wgui_inputs_sl_disable();
        }
    }
}
#endif /* __MMI_CATEGORY2001_PANEL_SUPPORT__ */


/*****************************************************************************
 * FUNCTION
 *  wgui_cat2001_editor_msg_callback
 * DESCRIPTION
 *  Eidtor/IME callback function
 *  
 * PARAMETERS
 *  input_box_handle    [IN]  inputbox handle
 *  msg_ptr             [IN]  message type
 * RETURNS
 *  void
 *****************************************************************************/
static U32 wgui_cat2001_editor_msg_callback(void * input_box_handle, mmi_imc_message_struct_p msg_ptr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 lresult = 0;
#ifdef __MMI_CATEGORY2001_PANEL_SUPPORT__    
    gui_panel_struct *cat2001_panel = dm_get_panel(g_wgui_cat2001_panel_handle);
    S32 current_highlight = gui_panel_get_element_focus(cat2001_panel);
#endif /* __MMI_CATEGORY2001_PANEL_SUPPORT__ */    
    MMI_BOOL need_default_handle = MMI_TRUE;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    single_line_input_box * editor_ptr;
    editor_ptr = (single_line_input_box *)((mmi_editor_handler_struct *)input_box_handle)->input_box_handler;
    if (editor_ptr == &MMI_singleline_inputbox)
    {
#ifdef __MMI_CATEGORY2001_PANEL_SUPPORT__
        if (wgui_cat2001_is_show_panel())
        {
            #if defined(__MMI_TOUCH_SCREEN__)
            if (msg_ptr->message_id == MMI_IMC_MESSAGE_PEN_EVENT)
            {
                if ((((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->mmi_pen_event == MMI_PEN_EVENT_DOWN))
                {
                    if (PEN_CHECK_BOUND(
                        ((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos.x,
                        ((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos.y, 
                        MMI_singleline_inputbox.x, 
                        MMI_singleline_inputbox.y, 
                        MMI_singleline_inputbox.width, 
                        MMI_singleline_inputbox.height))
                    {
                        if (current_highlight != g_wgui_cat2001_num_of_element)
                        {
                            wgui_cat2001_change_highlight(g_wgui_cat2001_num_of_element);
                            return lresult;
                        }
                    }
                }
            }
            else
            #endif 
            if (msg_ptr->message_id == MMI_IMC_MESSAGE_SET_KEY)
            {
                wgui_cat2001_register_navigation_kay();

                if (current_highlight != g_wgui_cat2001_num_of_element)
                {
                    need_default_handle = MMI_FALSE;
                }
            }
            else if (msg_ptr->message_id == MMI_IMC_MESSAGE_MODE_CHANGED)
            {
                wgui_cat2001_change_highlight(g_wgui_cat2001_num_of_element);
            }
            else if (msg_ptr->message_id == MMI_IMC_MESSGAE_GET_EXT_INPUT_BOX_RECT)
            {
                mmi_imc_rect *rect = (mmi_imc_rect*)msg_ptr->param_0;
			    rect->x = 0;
			    rect->y = MMI_singleline_inputbox.y - WGUI_CAT2001_INFO_BAR_HEIGHT * 2;
			    rect->width = MMI_singleline_inputbox.width;
			    rect->height = WGUI_CAT2001_INFO_BAR_HEIGHT * 2;
                return 1;
            }
        }
#endif /* __MMI_CATEGORY2001_PANEL_SUPPORT__ */
        
        if (need_default_handle)
        {
            lresult = mmi_input_box_msg_call_back_singleline(input_box_handle, msg_ptr);
        }
    }
    return lresult;
}


#ifdef __MMI_CATEGORY2001_PANEL_SUPPORT__


/*****************************************************************************
 * FUNCTION
 *  wgui_cat2001_change_callback
 * DESCRIPTION
 *  change focus
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat2001_change_callback(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_cat2001_change_highlight(g_wgui_cat2001_num_of_element);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat2001_navigation_key_handler
 * DESCRIPTION
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat2001_navigation_key_handler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 keycode, keytype;
    gui_panel_struct *cat2001_panel = dm_get_panel(g_wgui_cat2001_panel_handle);
    S32 current_focus = gui_panel_get_element_focus(cat2001_panel);

    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    GetkeyInfo(&keycode, &keytype);

    switch (keycode)
    {
        case KEY_UP_ARROW:
            {
                 if ((current_focus == g_wgui_cat2001_num_of_element) &&
                    (keytype == KEY_EVENT_DOWN))
                {
                    wgui_cat2001_change_highlight(0);
                }
                else if ((current_focus != g_wgui_cat2001_num_of_element) &&
                    (keytype == KEY_EVENT_DOWN))
                {
                    UI_editor_play_tone_cannot_navigate();
                }
            }
            break;
    
        case KEY_DOWN_ARROW:
            {
                if ((current_focus != g_wgui_cat2001_num_of_element) &&
                    (keytype == KEY_EVENT_DOWN))
                {
                    wgui_cat2001_change_highlight(g_wgui_cat2001_num_of_element);
                }
                else if ((current_focus == g_wgui_cat2001_num_of_element) &&
                    (keytype == KEY_EVENT_DOWN))
                {
                    UI_editor_play_tone_cannot_navigate();
                }
            }
            break;
    
        case KEY_LEFT_ARROW:
            {
                if (current_focus != g_wgui_cat2001_num_of_element)
                {
                    if ((current_focus > 0) &&
                       ((keytype == KEY_EVENT_DOWN) || (keytype == KEY_REPEAT)))
                    {
                        wgui_cat2001_change_highlight(--current_focus);
                    }
                    else if ((current_focus == 0) && (keytype == KEY_EVENT_DOWN))
                    {
                        UI_editor_play_tone_cannot_navigate();
                    }
                }
                else
                {
                    switch (keytype)
                    {
                        case KEY_EVENT_DOWN:
                            wgui_inputs_sl_previous_character();
                            break;

                        case KEY_REPEAT:
                            wgui_inputs_fast_del_nav_handler(WGUI_INPUTS_OPER_FAST_NAV_LEFT, WGUI_INPUTS_EDITOR_SL, WGUI_INPUTS_KPD_REPEAT_PERIOD);
                            break;

                        case KEY_LONG_PRESS:
                            wgui_inputs_fast_del_nav_reset_repeat_count();
                            break;

                        default:
                            break;
                    }
                }
            }
            break;

        case KEY_RIGHT_ARROW:
            {
                if (current_focus != g_wgui_cat2001_num_of_element)
                {
                    if ((current_focus < (g_wgui_cat2001_num_of_element - 1)) &&
                       ((keytype == KEY_EVENT_DOWN) || (keytype == KEY_REPEAT)))
                    {
                        wgui_cat2001_change_highlight(++current_focus);
                    }
                    else if ((current_focus == (g_wgui_cat2001_num_of_element - 1)) && (keytype == KEY_EVENT_DOWN))
                    {
                        UI_editor_play_tone_cannot_navigate();
                    }
                }
                else
                {
                    switch (keytype)
                    {
                        case KEY_EVENT_DOWN:
                            wgui_inputs_sl_next_character();
                            break;

                        case KEY_REPEAT:
                            wgui_inputs_fast_del_nav_handler(WGUI_INPUTS_OPER_FAST_NAV_RIGHT, WGUI_INPUTS_EDITOR_SL, WGUI_INPUTS_KPD_REPEAT_PERIOD);
                            break;

                        case KEY_LONG_PRESS:
                            wgui_inputs_fast_del_nav_reset_repeat_count();
                            break;

                        default:
                            break;
                    }
                }
            }
            break;
    
        default:
            break;
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat2001_register_navigation_kay
 * DESCRIPTION
 *  change focus
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat2001_register_navigation_kay(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    SetKeyHandler(wgui_cat2001_navigation_key_handler, KEY_UP_ARROW, KEY_EVENT_DOWN);
    SetKeyHandler(wgui_cat2001_navigation_key_handler, KEY_UP_ARROW, KEY_REPEAT);

    SetKeyHandler(wgui_cat2001_navigation_key_handler, KEY_DOWN_ARROW, KEY_EVENT_DOWN);
    SetKeyHandler(wgui_cat2001_navigation_key_handler, KEY_DOWN_ARROW, KEY_REPEAT);

    SetKeyHandler(wgui_cat2001_navigation_key_handler, KEY_LEFT_ARROW, KEY_EVENT_DOWN);
    SetKeyHandler(wgui_cat2001_navigation_key_handler, KEY_LEFT_ARROW, KEY_REPEAT);
    SetKeyHandler(wgui_cat2001_navigation_key_handler, KEY_LEFT_ARROW, KEY_LONG_PRESS);

    SetKeyHandler(wgui_cat2001_navigation_key_handler, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
    SetKeyHandler(wgui_cat2001_navigation_key_handler, KEY_RIGHT_ARROW, KEY_REPEAT);
    SetKeyHandler(wgui_cat2001_navigation_key_handler, KEY_RIGHT_ARROW, KEY_LONG_PRESS);
}
#endif /* #ifdef __MMI_CATEGORY2001_PANEL_SUPPORT__ */

/*****************************************************************************
 * FUNCTION
 *  wgui_cat2001_show
 * DESCRIPTION
 *  This category is a small screen, and show a singleline inputbox at the bottom.
 * PARAMETERS
 *  info_bar_icon           [IN]        Logo of infomation bar.
 *  left_softkey            [IN]        Left softkey string.
 *  left_softkey_icon       [IN]        Left softkey icon.
 *  right_softkey           [IN]        Right softkey string.
 *  right_softkey_icon      [IN]        Right softkey icon.
 *  input_type              [IN]        Allowable input type for this inputbox.
 *                                      Please refer to mmi_input_type_enum(ImeGprot.h) for detail.
 *  buffer                  [OUT]       Buffer for input box
 *  buffer_size             [IN]        Buffer size for input box
 *  history_buffer          [IN]        History buffer
 *  required_input_mode_set [IN]        Allowable input mode for this inputbox.
 *                                      Please refer to mmi_input_mode_enum(ImeGprot.h) for detail.
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat2001_show_int(
        PU8 info_bar_icon,
        UI_string_type left_softkey,
        UI_string_type right_softkey,
        U32 input_type,
        U8 *buffer,
        S32 buffer_size,
        U8 *history_buffer,
        mmi_imm_input_mode_enum *required_input_mode_set,
        U32 category_flags)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    color c = {0, 0, 0, 100};
    mmi_imm_input_mode_enum input_mode;
#if defined(__MMI_FTE_SUPPORT__) && defined(__MMI_TOUCH_SCREEN__)
    icontext_button *search_bt;
#endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    set_small_screen();
    gui_add_cleanup_hook(disable_resized_small_screen);
    
#if(UI_DOUBLE_BUFFER_SUPPORT)
    gui_lock_double_buffer();
#endif 

    dm_add_softkey_str(left_softkey, right_softkey);

#if !defined (__MMI_MAINLCD_320X480__) && (!defined (__MMI_FTE_SUPPORT__))
    wgui_softkey_set_is_in_popup(MMI_TRUE);
#endif 
    
    /* initialize category2001 global variable */
    g_wgui_cat2001_resize_and_draw_func = wgui_cat2001_resize_and_draw;
    g_wgui_cat2001_info_bar_icon = info_bar_icon;

    /* discard gui buffer */
    if ((history_buffer != NULL) && (category_flags & WGUI_CAT2001_HIGHLIGHT_TEXT))
    {
        input_mode = (((singleline_inputbox_category_history*)history_buffer)->ime_history).input_mode;
        mmi_imm_set_app_desired_input_mode(input_mode);
        history_buffer = NULL;
    }

#ifdef __MMI_CATEGORY2001_PANEL_SUPPORT__
    /* disable navigation key */
    if (wgui_cat2001_is_show_panel())
    {
        wgui_inputs_sl_disable_up_down_key_register(MMI_TRUE);
        wgui_inputs_sl_disable_left_right_key_register(MMI_TRUE);
    }
#endif /* __MMI_CATEGORY2001_PANEL_SUPPORT__ */   

    /* singleline inputbox */
    wgui_inputs_sl_setup_ext(
        MMI_singleline_inputbox_x,
        MMI_singleline_inputbox_y,
        MMI_singleline_inputbox_width,
        MMI_singleline_inputbox_height,
        buffer,
        buffer_size,
        MMI_CAT2001_ID,
        right_softkey,
        NULL,
        input_type,
        (U8*) (history_buffer),
        MMI_FALSE,
        wgui_cat2001_editor_msg_callback);

	/* Set highlight */
    if ((history_buffer == NULL) || (category_flags & WGUI_CAT2001_HIGHLIGHT_TEXT))
    {
	    MMI_singleline_inputbox.flags |= UI_SINGLE_LINE_INPUT_BOX_WORD_HIGHLIGHT | UI_SINGLE_LINE_INPUT_BOX_AUTO_CLEAR_HIGHLIGHT_MODE;
    }
	MMI_singleline_inputbox.highlight_start_position = buffer;
	MMI_singleline_inputbox.highlight_end_position = buffer + buffer_size;
    
#ifndef __MMI_FTE_SUPPORT__
    MMI_singleline_inputbox.text_x = 1;
    gui_set_single_line_input_box_theme(&MMI_singleline_inputbox, &g_wgui_cat2001_singleline_inputbox_theme);
#endif /* __MMI_FTE_SUPPORT__ */
    mmi_imc_set_backgroud_filler(wgui_cat2001_draw_virtual_keypad_background);
    gui_inputs_register_redraw_background_filler(wgui_cat2001_draw_sl_background);

    /* call the function while the text change (insert/ delete/ delete all) */
    wgui_inputs_sl_register_change_event_handler(wgui_cat2001_text_change_event_callback);

    /* set the highlight text */
    wgui_cat2001_initialize_counter(buffer);
    wgui_singleline_inputbox_buffer_size = buffer_size >> 1;
    
    /* set flags for singleline editor */
    MMI_current_input_ext_type |= INPUT_TYPE_EXT_NO_SHOW_NEW_LINE_SYMBOL;

#if defined(__MMI_FTE_SUPPORT__) && defined(__MMI_TOUCH_SCREEN__)
    /* setup button */
    g_wgui_cat2001_search_button_id = dm_add_button(
                                                NULL,
                                                g_wgui_cat2001_search_button_up_image,
                                                g_wgui_cat2001_search_button_down_image,
                                                wgui_cat2001_clear_search_button_bg);
    dm_register_button_functions(g_wgui_cat2001_search_button_id, KEY_EVENT_UP, wgui_cat2001_search_button_handler);
    search_bt = dm_get_button(g_wgui_cat2001_search_button_id);
    search_bt->draw_down_fp = wgui_cat2001_search_button_draw_down;
    search_bt->draw_up_fp = wgui_cat2001_search_button_draw_up;
    search_bt->flags |= UI_BUTTON_NO_SHIFT_BUTTON;
#endif /* #if defined(__MMI_FTE_SUPPORT__) && defined(__MMI_TOUCH_SCREEN__) */  

#ifdef __MMI_CATEGORY2001_PANEL_SUPPORT__
    /* setop panel */
    if (wgui_cat2001_is_show_panel())
    {
        S32 i, sl_s, img_w = 0, img_h = 0;
        U8 h_flag;
        gui_util_painter_struct bg_painter, disable_painter, off_painter, on_painter, down_painter, sl_painter;
        
        gui_util_painter_create_filler(&bg_painter, current_MMI_theme->singleline_editor_bg_filler);
        
        g_wgui_cat2001_panel_handle = dm_add_panel(
            0,
            MMI_singleline_inputbox.y - WGUI_CAT2001_INFO_BAR_HEIGHT, 
            UI_device_width, 
            WGUI_CAT2001_INFO_BAR_HEIGHT, 
            bg_painter,
            MMI_TRUE, 
            g_wgui_cat2001_repent_period);
        
        for(i = 0; i < g_wgui_cat2001_num_of_element; i++)
        {
            gui_util_painter_create_imageres(&disable_painter, g_wgui_cat2001_element_list[i].disable_imageid);
            gui_util_painter_create_imageres(&off_painter, g_wgui_cat2001_element_list[i].off_imageid);
            gui_util_painter_create_imageres(&on_painter, g_wgui_cat2001_element_list[i].on_imageid);
            gui_util_painter_create_imageres(&down_painter, g_wgui_cat2001_element_list[i].down_imageid);
            gdi_image_get_dimension(g_wgui_cat2001_element_list[i].off_imageid, &img_w, &img_h);
            dm_add_panel_element(
                g_wgui_cat2001_panel_handle,
                WGUI_CAT2001_PANEL_GAP_X + (WGUI_CAT2001_PANEL_GAP_X + img_w) * i,
                (WGUI_CAT2001_INFO_BAR_HEIGHT - img_h) >> 1,
                img_w,
                img_h,
                g_wgui_cat2001_element_list[i].keycode,
                g_wgui_cat2001_element_list[i].down_event_callback,
                g_wgui_cat2001_element_list[i].up_event_callback,
                g_wgui_cat2001_element_list[i].repeat_event_callback,
                off_painter,
                on_painter,
                down_painter,
                disable_painter,
                MMI_FALSE);
            dm_set_panel_enable_element(g_wgui_cat2001_panel_handle, i, g_wgui_cat2001_element_list[i].enabled, MMI_FALSE);
        }

        /* for pen handler */
        gui_util_painter_create_callback(&sl_painter, wgui_cat2001_dummy_func);
        dm_add_panel_element(
                g_wgui_cat2001_panel_handle,
                MMI_singleline_inputbox.x,
                MMI_singleline_inputbox.y,
                MMI_singleline_inputbox.width,
                MMI_singleline_inputbox.height,
                KEY_INVALID,
                NULL,
                NULL,
                NULL,
                sl_painter,
                sl_painter,
                sl_painter,
                sl_painter,
                MMI_FALSE);
        
        if (history_buffer)
        {
            sl_s = sizeof(singleline_inputbox_category_history);
            sl_s = (sl_s + 3) / 4;
            sl_s *= 4;
            h_flag = set_panel_category_history(MMI_CAT2001_ID, history_buffer + sl_s);
            if(h_flag)
            {
                gui_panel_struct *cat2001_panel = dm_get_panel(g_wgui_cat2001_panel_handle);
                S32 current_highlight = gui_panel_get_element_focus(cat2001_panel);

                if (current_highlight != g_wgui_cat2001_num_of_element)
                {
                    //wgui_inputs_sl_disable();
                    MMI_singleline_inputbox.flags |= (UI_SINGLE_LINE_INPUT_BOX_STATE_DISABLED | UI_SINGLE_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW);
                    StopTimer(BLINKING_CURSOR);
                    if (g_wgui_cat2001_highlight_change_callback)
                    {
                        g_wgui_cat2001_highlight_change_callback(current_highlight);
                    }
                }
            }
            else
            {
                dm_set_panel_element_focus(g_wgui_cat2001_panel_handle, g_wgui_cat2001_focused_element, MMI_FALSE);
            }
        }
        else
        {
            dm_set_panel_element_focus(g_wgui_cat2001_panel_handle, g_wgui_cat2001_num_of_element, MMI_FALSE);
        }
        MMI_singleline_inputbox.change_callback = wgui_cat2001_change_callback;
    }
#endif /* __MMI_CATEGORY2001_PANEL_SUPPORT__ */

#if(UI_DOUBLE_BUFFER_SUPPORT)
    gui_unlock_double_buffer();
#endif 

    dm_register_category_controlled_callback(wgui_cat2001_draw_ctrl_area);
    dm_add_rectangle(c, DM_RECTANGLE_FILL_GRAYSCALE);
    wgui_cat_setup_category(
        MMI_CAT2001_ID,
        DM_SET_NEW_LAYER_ACTIVE | DM_NO_TITLE | DM_NO_STATUS_BAR,
        wgui_cat2001_exit,
        wgui_cat2001_get_history,
        wgui_cat2001_get_history_size);
    dm_redraw_category_screen();
}
#endif /* __MMI_SEARCH_WEB__  */

/*****************************************************************************
 * FUNCTION
 *  wgui_cat2003_resize_and_draw
 * DESCRIPTION
 *  Adjust the EMS inputbox height, 
 *  and move the text offset for keep singleline editor visible.
 * PARAMETERS
 *  imui_x :                [IN] (N/A) X-axis of the input mode ui.
 *  imui_y :                [IN] (N/A) Y-axis of the input mode ui.
 *  imui_w :                [IN] (N/A) Width of the input mode ui.
 *  imui_h :                [IN] (N/A) Height of the input mode ui.
 * RETURNS
 *  U32
 *****************************************************************************/
static void wgui_cat2003_resize_and_draw(S32 imui_x, S32 imui_y, S32 imui_w, S32 imui_h)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 multiline_h, singleline_y;
    S32 gap = 0;
    S32 softkey_h = MMI_BUTTON_BAR_HEIGHT;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();    

    //gap = (imui_h <= 2) ? 2 : 0 /* border */;

#ifdef __MMI_FTE_SUPPORT__
    if (imui_h > MMI_BUTTON_BAR_HEIGHT)
    {
        softkey_h = 0;
    }
#endif
    
    /* set singleline inputbox position */
    singleline_y = UI_device_height - softkey_h - imui_h - gap - MMI_SINGLELINE_INPUTBOX_HEIGHT;
    wgui_inputs_sl_move(WGUI_CAT2003_SL_X, singleline_y); 

#ifndef __MMI_FTE_SUPPORT__
    /* set information bar position */
    wgui_setup_input_information( 
        MMI_singleline_inputbox.x,
        MMI_singleline_inputbox.y - INFORMATION_BAR_HEIGHT,
        MMI_singleline_inputbox.width,
        wgui_inputbox_information_bar_height);
#endif

    /* set multiline inputbox position and resize it */
    multiline_h = singleline_y - INFORMATION_BAR_HEIGHT - WGUI_CAT2003_ML_Y;
    wgui_inputs_ml_resize(WGUI_CAT2003_ML_W, multiline_h);
    wgui_inputs_ml_move(WGUI_CAT2003_ML_X, WGUI_CAT2003_ML_Y);

    /* clear background and show multiline inputbox, singleline inputbox, and information bar */  
    gdi_draw_solid_rect(
        0, 
        WGUI_CAT2003_ML_Y, 
        UI_device_width - 1, 
        UI_device_height - MMI_BUTTON_BAR_HEIGHT - imui_h - 1,
        GDI_COLOR_TRANSPARENT);

    /* draw the background of the singleline inputbox */  
    if (gap == 0)
    {
        gui_fill_rectangle(
            0, 
            MMI_singleline_inputbox.y, 
            UI_device_width - 1, 
            UI_device_height - softkey_h - imui_h,
            WGUI_CAT2003_BG_COLOR);
    }
    else
    {
        gui_fill_rectangle(
            0, 
            MMI_singleline_inputbox.y, 
            UI_device_width - 1, 
            MMI_singleline_inputbox.y + MMI_SINGLELINE_INPUTBOX_HEIGHT + gap,
            WGUI_CAT2003_BG_COLOR);
    }

    wgui_inputs_ml_show();
    wgui_inputs_sl_show();

#ifndef __MMI_FTE_SUPPORT__
    wgui_inputs_sl_redraw_information_bar();
#endif
    
    gdi_layer_unlock_frame_buffer();
}



/*****************************************************************************
 * FUNCTION
 *  wgui_cat2003_editor_msg_callback
 * DESCRIPTION
 *  Eidtor/IME callback function
 *  
 * PARAMETERS
 *  input_box_handle    [IN]  inputbox handle
 *  msg_ptr             [IN]  message type
 * RETURNS
 *  void
 *****************************************************************************/
static U32 wgui_cat2003_editor_msg_callback(void * input_box_handle, mmi_imc_message_struct_p msg_ptr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_imc_rect_p imui_rect_p;
    U32 lresult = 0;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    single_line_input_box * editor_ptr;
    editor_ptr = (single_line_input_box *)((mmi_editor_handler_struct *)input_box_handle)->input_box_handler;
    if (editor_ptr == &MMI_singleline_inputbox)
    {
        switch (msg_ptr->message_id)
        {
            case MMI_IMC_MESSAGE_RESIZE:
            case MMI_IMC_MESSAGE_MOVE:
                break;

            case MMI_IMC_MESSAGE_SET_KEY:
                wgui_inputs_ml_register_viewer_keys();
                lresult = mmi_input_box_msg_call_back_singleline(input_box_handle, msg_ptr);
                break;
                    
            case MMI_IMC_MESSAGE_IMUI_RECTANGLE_IS_UPDATED:
                imui_rect_p = (mmi_imc_rect_p)(msg_ptr->param_0);
                wgui_cat2003_resize_and_draw(imui_rect_p->x, imui_rect_p->y, imui_rect_p->width, imui_rect_p->height);
                break;

            case MMI_IMC_MESSAGE_DRAW_INFORMATION_BAR:
                #ifndef __MMI_FTE_SUPPORT__
                    wgui_inputs_sl_redraw_information_bar();
                #endif
                break;

            default:
                lresult = mmi_input_box_msg_call_back_singleline(input_box_handle, msg_ptr);
        }
    }
    return lresult;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat2003_get_history_size
 * DESCRIPTION
 *  Gets the history buffer size of category 2003
 * PARAMETERS
 *  void
 * RETURNS
 *  size in U8s of the history buffer
 *****************************************************************************/
static S32 wgui_cat2003_get_history_size(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return (((sizeof(singleline_inputbox_category_history) + 3) / 4) * 4 + sizeof(multiline_inputbox_category_history));
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat2003_get_history
 * DESCRIPTION
 *  Gets the history buffer of category2003
 * PARAMETERS
 *  history_buffer      [OUT]        Is the buffer into which the history data is stored
 * RETURNS
 *  return history buffer
 *****************************************************************************/
static U8 *wgui_cat2003_get_history(U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 s;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_inputs_sl_get_category_history(MMI_CAT2003_ID, history_buffer);
    s = sizeof(singleline_inputbox_category_history);
    s = (s + 3) / 4;
    s *= 4;
    get_multiline_inputbox_category_history(MMI_CAT2003_ID, (U8*) (history_buffer + s));
    return (history_buffer);
}



/*****************************************************************************
 * FUNCTION
 *  wgui_cat2003_show
 * DESCRIPTION
 *  Multi-line text viewer + Single-line editor screen
 * PARAMETERS
 *  title :                       [IN] (TITLE) Title string
 *  title_icon :                  [IN] (N/A) Title icon
 *  left_softkey :                [IN] (LSK) Left softkey label
 *  left_softkey_icon :           [IN] (N/A) Icon for the Left softkey
 *  right_softkey :               [IN] (RSK) Right softkey label
 *  right_softkey_icon :          [IN] (N/A) Icon for the right softkey
 *  message :                     [IN] (UNLIM) text viewer buffer
 *  input_buffer :                [IN] (N/A) Singleline inputbox input buffer
 *  input_buffer_size :           [IN] (N/A) Input buffer size (Orange call plan max is 183)
 *  input_type :                  [IN] (N/A) Input method
 *  history_buffer :              [IN] (N/A) History buffer
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat2003_show_int(
        UI_string_type title,
        PU8 title_icon,
        UI_string_type left_softkey,
        UI_string_type right_softkey,
        UI_string_type message,
        UI_buffer_type input_buffer,
        S32 input_buffer_size,
        U32 input_type,
        UI_buffer_type history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 msg_length, singleline_history_size; 
    MMI_BOOL has_info_bar = MMI_TRUE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();

    /* title and softkey */
    dm_add_title(title, title_icon);
    dm_add_softkey_str(left_softkey, right_softkey);
    SetupCategoryKeyHandlers();

    /* multiline inputbox */
    msg_length = gui_strlen(message);
    wgui_inputs_ml_create_set_buffer(message, msg_length, msg_length, 0);
    if (history_buffer != NULL)
    {
        singleline_history_size = sizeof(singleline_inputbox_category_history);
        singleline_history_size = (singleline_history_size + 3) / 4;
        singleline_history_size *= 4;
        set_multiline_inputbox_category_history(MMI_CAT2003_ID, (U8*) (history_buffer + singleline_history_size));
    }

    MMI_multiline_inputbox.flags |=
        (UI_MULTI_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW |
         UI_MULTI_LINE_INPUT_BOX_VIEW_MODE |
         UI_MULTI_LINE_INPUT_BOX_TRANSPARENT_BACKGROUND |
         UI_MULTI_LINE_INPUT_BOX_AUTO_DISABLE_SCROLLBAR);
    MMI_multiline_inputbox.ext_flags |= GUI_MULTI_LINE_INPUT_BOX_FIXED_Y_OFFSET;
    wgui_inputs_ml_register_viewer_keys();

    /* set flags for singleline editor */
    MMI_current_input_ext_type |= INPUT_TYPE_EXT_NO_SHOW_NEW_LINE_SYMBOL;
    wgui_inputs_sl_disable_up_down_key_register(MMI_TRUE);
    
#ifdef __MMI_FTE_SUPPORT__
    has_info_bar = MMI_FALSE;
#endif /* __MMI_FTE_SUPPORT__ */

	/* singleline inputbox */
    wgui_inputs_sl_setup_ext(
        WGUI_CAT2003_SL_X, 
        WGUI_CAT2003_SL_Y, 
        WGUI_CAT2003_SL_W, 
        WGUI_CAT2003_SL_H, 
        input_buffer, 
        input_buffer_size, 
        MMI_CAT2003_ID, 
        right_softkey, 
        NULL, 
        input_type, 
        history_buffer,
        has_info_bar,
        wgui_cat2003_editor_msg_callback); 

#ifndef __MMI_FTE_SUPPORT__
    /* information bar */
    wgui_setup_input_information(
        MMI_singleline_inputbox.x,
        MMI_singleline_inputbox.y - wgui_inputbox_information_bar_height,
        MMI_singleline_inputbox.width,
        wgui_inputbox_information_bar_height);
#endif /* __MMI_FTE_SUPPORT__ */
        
    gdi_layer_unlock_frame_buffer();

    dm_register_vkpad_callback(mmi_imc_redraw_screen_by_state);
#ifndef __MMI_FTE_SUPPORT__
    wgui_cat_setup_category(
        MMI_CAT2003_ID,
        DM_CLEAR_SCREEN_BACKGROUND | DM_SET_AS_ABM_LAYER | DM_SHOW_VKPAD | DM_SINGLE_LINE_INPUT_BOX_WITH_INFORMATION_BAR,
        ExitCategory69Screen,
        wgui_cat2003_get_history,
        wgui_cat2003_get_history_size);
#else /* __MMI_FTE_SUPPORT__ */
    wgui_cat_setup_category(
        MMI_CAT2003_ID,
        DM_CLEAR_SCREEN_BACKGROUND | DM_SET_AS_ABM_LAYER | DM_SHOW_VKPAD,
        ExitCategory69Screen,
        wgui_cat2003_get_history,
        wgui_cat2003_get_history_size);
#endif /* __MMI_FTE_SUPPORT__ */


    dm_redraw_category_screen();

    MMI_multiline_inputbox.ext_flags &= ~GUI_MULTI_LINE_INPUT_BOX_FIXED_Y_OFFSET;
}




/* support mATV */
#ifdef __ATV_SMS_SUPPORT__
/*****************************************************************************
 * FUNCTION
 *  wgui_cat9007_draw_ctrl_area
 * DESCRIPTION
 *  For video redraw.
 * PARAMETERS
 *  coordinate   [IN]  Unused.
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat9007_draw_ctrl_area(dm_coordinates *coordinate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    show_video_func show_video;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    show_video = wgui_cat_matv_get_show_video_func();
    if ((show_video != NULL) && (!mmi_is_redrawing_bk_screens()))
    {
        show_video(
            wgui_cat_matv_get_video_layer_handle(), 
            GDI_LAYER_ENABLE_LAYER_0 | GDI_LAYER_ENABLE_LAYER_1 |GDI_LAYER_ENABLE_LAYER_2 | GDI_LAYER_ENABLE_LAYER_3, 
            GDI_LAYER_ENABLE_LAYER_1, 
            WGUI_CAT_MATV_VIDEO_X,
            WGUI_CAT_MATV_VIDEO_Y,
            WGUI_CAT_MATV_VIDEO_W,
            WGUI_CAT_MATV_VIDEO_H);
    }
    else
    {
	    gdi_draw_solid_rect(
	        WGUI_CAT_MATV_VIDEO_X, 
	        WGUI_CAT_MATV_VIDEO_Y,
	        WGUI_CAT_MATV_VIDEO_X + WGUI_CAT_MATV_VIDEO_W -1,
	        WGUI_CAT_MATV_VIDEO_Y + WGUI_CAT_MATV_VIDEO_H - 1,
	        GDI_COLOR_BLACK);
	  }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat9007_exit
 * DESCRIPTION
 *  Exit the category9007 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat9007_exit(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_inputs_ml_close();
}


#ifdef UI_EMS_SUPPORT
/* For detail description, please refer to wgui_categories_inputs.h */
void wgui_cat9006_show(
        UI_string_type default_text,
        UI_string_type left_softkey,
        PU8 left_softkey_icon,
        UI_string_type right_softkey,
        PU8 right_softkey_icon,
        U32 input_type,
        EMSData *data,
        U8 *history_buffer,
        FuncPtr change_callback)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#if defined __MMI_LANG_HINDI__ && defined __MMI_BIDI_ALG__
    U16 unicode = 0;
    U16 clFill = 0;
#endif /*__MMI_BIDI_ALG__ */

    U8 h;
    S32 box_height;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_frm_set_curr_scr_blt_mode(MMI_FRM_SCR_BLT_IMMEDIATE);
    gdi_layer_lock_frame_buffer();
    wgui_inputs_set_current_input_box_type(EDITOR_EMS_INPUT_BOX);

#ifndef __MMI_FTE_SUPPORT__
    wgui_inputbox_information_flag = 1;
    wgui_inputbox_information_bar_height = INFORMATION_BAR_HEIGHT;
    wgui_EMS_setup_input_information(
        0,
        (MMI_title_y + MMI_title_height),
        UI_device_width,
        wgui_inputbox_information_bar_height);
#endif

#if defined (__MMI_MAINLCD_320X240__)
    wgui_title_set_menu_shortcut_number(-1);
    wgui_title_disable_menu_shortcut_display(MMI_TRUE);
    dm_add_title(default_text, NULL);
#endif
    dm_add_softkey_str(left_softkey, right_softkey);

#if((UI_ENABLE_FRAME_SKIPPING) && (ENABLE_EMS_INPUTBOX_FRAME_SKIPPING))
    wgui_EMS_inputbox_frame_counter = 0;
#endif 

#ifdef __MMI_MESSAGES_EMS__
    initialize_EMS_objects();
#endif 

    box_height = MMI_content_height - 13;
    register_EMS_inputbox_input_callback(UI_dummy_function);

    mmi_imc_config_floating_state(MMI_TRUE);

    gui_create_EMS_input_box(
        &MMI_EMS_inputbox,
        0,
        (MMI_title_y + MMI_title_height) + wgui_EMS_inputbox_information_bar_height,
        UI_device_width,
        box_height);
    gui_set_EMS_input_box_data(&MMI_EMS_inputbox, data);
#if !defined (__MMI_MAINLCD_320X240__)
    gui_EMS_input_box_set_default_text(&MMI_EMS_inputbox, default_text);
#endif
    h = set_EMS_inputbox_category_history(MMI_CAT9006_ID, history_buffer);
    if (h)
    {   /* Current alignment is not saved in history, so test it using a flag   */
        if (EMS_inputbox_alignment_added_flag)
        {
            wgui_EMS_text_format.Alignment = EMS_inputbox_alignment;
            MMI_EMS_inputbox.text_format.Alignment = EMS_inputbox_alignment;
            EMS_inputbox_alignment_added_flag = 0;
        }
    #ifdef __MMI_MESSAGES_EMS__
        gui_EMS_input_box_set_text_format_object(&MMI_EMS_inputbox, &wgui_EMS_text_format);
    #endif 
    }
    else
    {
        gui_EMS_input_box_set_text_format_cursor_position(&MMI_EMS_inputbox);
        wgui_EMS_text_format = MMI_EMS_inputbox.text_format;
    }

    /* Comment this line because this function will make the display_y change due to the inputbox size is not correct when show
       it will be resized in DM for VK */
    /* gui_EMS_input_box_locate_cursor(&MMI_EMS_inputbox);*/ 
    /* Switch IME by long press # */

    register_EMS_inputbox_keys();
    set_right_softkey_function(handle_category28_right_softkey_down, KEY_EVENT_DOWN);
    set_right_softkey_function(handle_category28_right_softkey_long_press, KEY_LONG_PRESS);

#ifdef __MMI_WALLPAPER_ON_BOTTOM__
    MMI_EMS_inputbox.flags |= UI_EMS_INPUT_BOX_TRANSPARENT_BACKGROUND;
    dm_get_scr_bg_opacity(&editor_scr_bg_opacity);
    dm_set_scr_bg_opacity((U8)(current_MMI_theme->bg_opacity_low));
#endif /* __MMI_WALLPAPER_ON_BOTTOM__ */ 

    wgui_EMS_inputbox_information_icon = NULL;

    category28_RSK_label_icon = right_softkey_icon;
    category28_RSK_label_string = right_softkey;

#if(EMS_USE_INTERNAL_MENU)
    SetKeyHandler(EntryEMSMainMenu, KEY_SEND, KEY_EVENT_UP);
#endif 

    if (h)
    {
        mmi_imc_set_input_method_history(&(((EMS_inputbox_category_history*)history_buffer)->ime_history));
    }

    mmi_imm_set_required_mode_list(input_type, NULL, IMM_INPUT_MODE_NONE);
    g_mmi_editor_hanler.input_box_type = MMI_EDITOR_EMS_INPUT_BOX;
    g_mmi_editor_hanler.input_box_sub_type = MMI_EDITOR_NORMAL_INPUT_BOX;
    g_mmi_editor_hanler.input_box_handler = &MMI_EMS_inputbox;
    mmi_imc_connect((void *)&g_mmi_editor_hanler, mmi_input_box_msg_call_back_ems);

    wgui_set_EMS_inputbox_RSK();

    gui_unlock_double_buffer();

    //dm_register_category_controlled_callback(wgui_cat9007_draw_ctrl_area);
    dm_register_vkpad_callback(mmi_imc_redraw_screen_by_state);
    wgui_cat_setup_category_default_history(
        MMI_CAT9006_ID,
        DM_CLEAR_SCREEN_BACKGROUND | DM_SHOW_VKPAD,
        ExitCategory28Screen);

    dm_redraw_category_screen();
    wgui_cat9007_draw_ctrl_area(NULL);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat9006_get_history_size
 * DESCRIPTION
 *  Gets the history buffer size for the MO EMS/SMS screen
 * PARAMETERS
 *  void
 * RETURNS
 *  size in U8s of the history buffer
 *****************************************************************************/
S32 wgui_cat9006_get_history_size(void)
{
#if(UI_DISABLE_EMS_INPUT_BOX)
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return (0);
#else /* (UI_DISABLE_EMS_INPUT_BOX) */ 
    return (sizeof(EMS_inputbox_category_history));
#endif /* (UI_DISABLE_EMS_INPUT_BOX) */ 
}
#endif /* UI_EMS_SUPPORT */


/* For detail description, please refer to wgui_categories_inputs.h */
void wgui_cat9007_show(
        UI_string_type default_text,
        UI_string_type left_softkey,
        PU8 left_softkey_icon,
        UI_string_type right_softkey,
        PU8 right_softkey_icon,
        U32 input_type,
        U8 *buffer,
        S32 buffer_size,
        U8 *history_buffer,
        FuncPtr change_callback,
        S16 input_ext_type,
        mmi_imm_input_mode_enum *required_input_mode_set)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/  
    mmi_frm_set_curr_scr_blt_mode(MMI_FRM_SCR_BLT_IMMEDIATE);
#if(UI_DOUBLE_BUFFER_SUPPORT)
    gui_lock_double_buffer();
#endif 

#if defined (__MMI_MAINLCD_320X240__)
    wgui_title_set_menu_shortcut_number(-1);
    wgui_title_disable_menu_shortcut_display(MMI_TRUE);
    dm_add_title(default_text, NULL);
#endif
    /* setup softkey */
    dm_add_softkey_str(left_softkey, right_softkey);

    mmi_imc_config_floating_state(MMI_TRUE);

    wgui_inputs_ml_setup_ext2(
        WGUI_CAT_MATV_EDITOR_X,
        WGUI_CAT_MATV_EDITOR_Y,
        WGUI_CAT_MATV_EDITOR_W,
        WGUI_CAT_MATV_EDITOR_H,
        buffer,
        buffer_size,
        MMI_CAT9007_ID,
        right_softkey,
        right_softkey_icon,
        input_type,
        history_buffer,
        required_input_mode_set,
#ifdef __MMI_FTE_SUPPORT__        
        MMI_FALSE,
#else
        MMI_TRUE,
#endif
        0,
        0,
        0,
        0,
        0,
        NULL,
        mmi_input_box_msg_call_back_multiline,
        MMI_TRUE);

    wgui_inputs_ml_set_common_style(MMI_TRUE, MMI_TRUE);
#if !defined (__MMI_MAINLCD_320X240__)
    gui_multi_line_input_box_set_default_text(&MMI_multiline_inputbox, default_text);
#endif
    if (change_callback != NULL)
    {
        MMI_multiline_inputbox.change_callback = change_callback;
    }
    
    if (input_ext_type != 0)
    {
        MMI_current_input_ext_type = input_ext_type;
    }

    if (((input_type & INPUT_TYPE_MASK) == IMM_INPUT_TYPE_NUMERIC_PASSWORD) ||
        ((input_type & INPUT_TYPE_MASK) == IMM_INPUT_TYPE_ALPHANUMERIC_PASSWORD) ||
        ((input_type & INPUT_TYPE_MASK) == IMM_INPUT_TYPE_SAT_NUMERIC_PASSWORD) ||
        ((input_type & INPUT_TYPE_MASK) == IMM_INPUT_TYPE_SIGNED_DECIMAL_NUMERIC_PASSWORD) ||
        ((input_type & INPUT_TYPE_MASK) == IMM_INPUT_TYPE_SIGNED_NUMERIC_PASSWORD))
    {
        MMI_current_input_ext_type |= INPUT_TYPE_EXT_NO_SHOW_NEW_LINE_SYMBOL;
    }
    
    wgui_inputs_ml_handle_input_ext_type(input_type);
    
#if(UI_DOUBLE_BUFFER_SUPPORT)
    gui_unlock_double_buffer();
#endif

    dm_register_vkpad_callback(mmi_imc_redraw_screen_by_state);
    //dm_register_category_controlled_callback(wgui_cat9007_draw_ctrl_area);
    wgui_cat_setup_category_default_history(
        MMI_CAT9007_ID,
        DM_CLEAR_SCREEN_BACKGROUND | DM_SHOW_VKPAD,
        wgui_cat9007_exit);
    dm_redraw_category_screen();
    wgui_cat9007_draw_ctrl_area(NULL);
}

static UI_string_type g_cat9008_header_info_1;
static UI_string_type g_cat9008_header_info_2;

/*****************************************************************************
 * FUNCTION
 *  wgui_cat9008_draw_ctrl_area
 * DESCRIPTION
 *  Start video and draw the header.
 * PARAMETERS
 *  coordinate   [IN]  Unused.
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat9008_draw_ctrl_area(dm_coordinates *coordinate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    show_video_func show_video;
    S32 header_info_1_w, header_info_1_h, header_info_2_w, header_info_2_h;
    S32 gap_x, gap_y;
    S32 draw_x, draw_y, draw_w;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* show video */
    /*
    show_video = wgui_cat_matv_get_show_video_func();
    if ((show_video != NULL) && (!(mmi_is_redrawing_bk_screens())))
    {
        show_video(
            wgui_cat_matv_get_video_layer_handle(), 
            GDI_LAYER_ENABLE_LAYER_0 | GDI_LAYER_ENABLE_LAYER_1 |GDI_LAYER_ENABLE_LAYER_2 | GDI_LAYER_ENABLE_LAYER_3, 
            GDI_LAYER_ENABLE_LAYER_1, 
            WGUI_CAT_MATV_VIDEO_X,
            WGUI_CAT_MATV_VIDEO_Y,
            WGUI_CAT_MATV_VIDEO_W,
            WGUI_CAT_MATV_VIDEO_H);
    }
    else
    {
	    gdi_draw_solid_rect(
	        WGUI_CAT_MATV_VIDEO_X, 
	        WGUI_CAT_MATV_VIDEO_Y,
	        WGUI_CAT_MATV_VIDEO_X + WGUI_CAT_MATV_VIDEO_W -1,
	        WGUI_CAT_MATV_VIDEO_Y + WGUI_CAT_MATV_VIDEO_H - 1,
	        GDI_COLOR_BLACK);
    }*/
    
    /* show header */
    gui_set_font(&MMI_default_font);
    
    gui_push_clip();
    gui_set_clip(
        (S32)coordinate->s16X,
        (S32)coordinate->s16Y,
        (S32)coordinate->s16X + (S32)coordinate->s16Width - 1,
        (S32)coordinate->s16Y + (S32)coordinate->s16Height - 1);
    
#if !defined(__MMI_MAINLCD_128X128__)
    gui_set_text_color(current_header_information_text_theme->text_color);
    DrawTextAreaBackground(
        (S32)coordinate->s16X,
        (S32)coordinate->s16Y,
        (S32)coordinate->s16X + (S32)coordinate->s16Width - 1,
        (S32)coordinate->s16Y + (S32)coordinate->s16Height - 1);
#else
    gui_set_text_color(UI_COLOR_BLACK);
    gui_draw_filled_area(
        (S32)coordinate->s16X,
        (S32)coordinate->s16Y,
        (S32)coordinate->s16X + (S32)coordinate->s16Width - 1,
        (S32)coordinate->s16Y + (S32)coordinate->s16Height - 1,
        &EMS_viewer_header_background_filler);
#endif

    gui_measure_string(g_cat9008_header_info_1, &header_info_1_w, &header_info_1_h);
    gui_measure_string(g_cat9008_header_info_2, &header_info_2_w, &header_info_2_h);
    MMI_ASSERT((header_info_1_h + header_info_2_h) <= (S32)coordinate->s16Height);
    
    gap_x = WGUI_CAT9008_HEADER_GAP;
    gap_y = ((S32)coordinate->s16Height - header_info_1_h - header_info_2_h) / 3;
    draw_x = (S32)coordinate->s16X + gap_x;
    draw_y = (S32)coordinate->s16Y + gap_y;
    draw_w = (S32)coordinate->s16Width - (gap_x << 1);

    gui_print_truncated_text(draw_x, draw_y, draw_w, g_cat9008_header_info_1);

    draw_y += header_info_1_h + gap_y;
    gui_print_truncated_text(draw_x, draw_y, draw_w, g_cat9008_header_info_2);
    
    gui_pop_clip();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat9008_exit
 * DESCRIPTION
 *  Exits the category9008 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat9008_exit(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    reset_multiline_inputbox();  
}   /* end of ExitCategory74Screen */


/* For detail description, please refer to wgui_categories_inputs.h */
void wgui_cat9008_show(
        UI_string_type title,
        PU8 title_icon,
        UI_string_type left_softkey,
        PU8 left_softkey_icon,
        UI_string_type right_softkey,
        PU8 right_softkey_icon,
        EMSData *data,
        UI_string_type header_info_1,
        UI_string_type header_info_2,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 l;
    S8 n_tabs;
    S32 left_bt_x, right_bt_x;
    S32 bt_y, bt_w, bt_h;
    icontext_button *left_bt, *right_bt;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_frm_set_curr_scr_blt_mode(MMI_FRM_SCR_BLT_IMMEDIATE);
    gdi_layer_lock_frame_buffer();

    /* setup softkey */
    dm_add_softkey_str(left_softkey, right_softkey);

    wgui_title_set_menu_shortcut_number(-1);
    wgui_title_disable_menu_shortcut_display(MMI_TRUE);
    dm_add_title(title, title_icon);

    g_cat9008_header_info_1 = header_info_1;
    g_cat9008_header_info_2 = header_info_2;    
    
    /* setup inputbox */
    l = gui_strlen((UI_string_type) data->textBuffer);
    wgui_inputs_ml_create_set_buffer((UI_string_type) data->textBuffer, data->textBufferSize, l, 0);
    wgui_inputs_ml_register_viewer_keys();
    wgui_inputs_ml_set_category_history((U16)MMI_CAT9008_ID, history_buffer);

    MMI_multiline_inputbox.flags |= (UI_MULTI_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW | UI_MULTI_LINE_INPUT_BOX_VIEW_MODE);

#ifdef __MMI_WALLPAPER_ON_BOTTOM__ 
    MMI_multiline_inputbox.flags |= UI_MULTI_LINE_INPUT_BOX_TRANSPARENT_BACKGROUND;
#endif

    gdi_layer_unlock_frame_buffer();

    dm_register_category_controlled_callback(wgui_cat9008_draw_ctrl_area);
    wgui_cat_setup_category_default_history(
        MMI_CAT9008_ID,
        DM_CLEAR_SCREEN_BACKGROUND,
        wgui_cat9008_exit);
    dm_redraw_category_screen();
    wgui_cat9007_draw_ctrl_area(NULL);
}

#endif /* __ATV_SMS_SUPPORT__ */
/* support mATV end */


/*****************************************************************************
 * FUNCTION
 *  wgui_cat_editor_disable_new_line_symbol
 * DESCRIPTION
 *  Disable new line symbol or not.
 * PARAMETERS
 *  disable       [IN]  flag 
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat_editor_disable_new_line_symbol(MMI_BOOL disable)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_cat_cat_editor_disable_new_line_symbol = disable;
}






