/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*****************************************************************************
 *
 * Filename: 
 * ---------
 *   wgui_categories_popup.c
 *
 * Project:
 * --------
 *   Maui_Software
 *
 * Description:
 * ------------
 *  Popup screen related categories.
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/
#include "MMI_features.h"
#include "CustThemesRes.h"
#if defined(__MMI_TOUCH_SCREEN__) || defined(__MMI_HANDWRITING_PAD__)
#include "PhoneSetupGprots.h"
#endif /* defined(__MMI_TOUCH_SCREEN__) || defined(__MMI_HANDWRITING_PAD__) */ 

#ifdef __MMI_HANDWRITING_PAD__
#include "touch_panel_custom.h"
#endif 
#include "CommonScreens.h"
#include "ScreenRotationGprot.h"
#include "ScrLockerGprot.h"
#include "gui_data_types.h"
#include "MMIDataType.h"
#include "wgui_categories_list.h"
#include "gui.h"
#include "gui_effect_oem.h"
#include "wgui_categories_util.h"
#include "wgui.h"
#include "gui_typedef.h"
#include "wgui_include.h"
#include "wgui_inputs.h"
#include "gui_themes.h"
#include "gui_inputs.h"
#include "wgui_draw_manager.h"
#include "kal_general_types.h"
#include "gdi_include.h"
#include "gdi_const.h"
#include "CustDataRes.h"
#include "mmi_frm_history_gprot.h"
#include "wgui_touch_screen.h"
#include "mmi_frm_input_gprot.h"
#include "mmi_frm_events_gprot.h"
#include "wgui_categories_enum.h"
#include "kal_public_api.h"
#include "DebugInitDef_Int.h"
#include "wgui_categories_inputs.h"
#include "gdi_datatype.h"
#include "gui_theme_struct.h"
#include "gui_scrollbars.h"
#include "gui_switch.h"
#include "PixcomFontEngine.h"
#include "FontRes.h"
#include "wgui_categories_popup.h"
#include "lcd_sw_inc.h"
#include "Gui_Setting.h"
#include "GlobalConstants.h"
#include "Unicodexdcl.h"
#include "gui_buttons.h"
#include "mmi_rp_app_uiframework_def.h"
#include "wgui_categories.h"
#include "wgui_title.h"
#include "dialercuigprot.h"

#include "DialerGprot.h"
#if defined(__MMI_NCENTER_SUPPORT__)
#include "Vapp_ncenter_gprot.h"
#endif

extern UI_string_type MMI_message_string;
extern PU8 MMI_message_icon;

extern S32 wgui_image_clip_y1;
extern S32 wgui_image_clip_y2;
extern FuncPtr PopupFunc;

/*
static U8 *outside_memory_layer_buf = NULL;
*/
#if defined(__MMI_BASIC_UI_STYLE__)
	#define __MMI_POPUP_NO_SHOW_ICON__
#endif
/* micha1021, Joyce Requirement, Here to change pop up window background and color */
UI_filled_area greywgui_pop_up_dialog_background =
    {UI_FILLED_AREA_TYPE_COLOR | UI_FILLED_AREA_DOUBLE_BORDER | UI_FILLED_AREA_ROUNDED_BORDER |
UI_FILLED_AREA_SHADOW_DOUBLE_LINE | UI_FILLED_AREA_SHADOW,
    UI_NULL_IMAGE,
    NULL,
    {234, 234, 234, 100},
    {0, 0, 0, 0},
    {142, 204, 145, 100},
    {50, 50, 50, 100},
    0
};

#ifdef __MMI_MAINLCD_96X64__
UI_filled_area wgui_pop_up_dialog_background =
    {UI_FILLED_AREA_TYPE_COLOR | UI_FILLED_AREA_DOUBLE_BORDER | UI_FILLED_AREA_ROUNDED_BORDER |
UI_FILLED_AREA_SHADOW_DOUBLE_LINE | UI_FILLED_AREA_SHADOW,
    UI_NULL_IMAGE,
    NULL,
    {255, 255, 255, 100},
    {0, 0, 0, 0},
    {255, 255, 255, 100},
    {0, 0, 0, 100},
    0
};
#elif defined(__MMI_DEFAULT_THEME_1__)
UI_filled_area wgui_pop_up_dialog_background =
    {UI_FILLED_AREA_TYPE_COLOR | UI_FILLED_AREA_DOUBLE_BORDER | UI_FILLED_AREA_ROUNDED_BORDER |
UI_FILLED_AREA_SHADOW_DOUBLE_LINE | UI_FILLED_AREA_SHADOW,
    UI_NULL_IMAGE,
    NULL,
    {246, 255, 171, 100},
    {0, 0, 0, 0},
    {142, 204, 145, 100},
    {50, 50, 50, 100},
    0
};

#else /* __MMI_DEFAULT_THEME_1__ */ 

UI_filled_area wgui_pop_up_dialog_background =
    {UI_FILLED_AREA_TYPE_COLOR | UI_FILLED_AREA_DOUBLE_BORDER | UI_FILLED_AREA_ROUNDED_BORDER |
UI_FILLED_AREA_SHADOW_DOUBLE_LINE | UI_FILLED_AREA_SHADOW,
    UI_NULL_IMAGE,
    NULL,
    {255, 255, 255, 100},
    {0, 0, 0, 0},
    {0, 0, 0, 100},
    {50, 50, 50, 100},
    0
};

#endif /* __MMI_DEFAULT_THEME_1__ */ 

UI_filled_area borderwgui_pop_up_dialog_background = {UI_FILLED_AREA_TYPE_COLOR | UI_FILLED_AREA_SINGLE_BORDER,
    UI_NULL_IMAGE,
    NULL,
    {255, 255, 255, 100},
    {0, 0, 0, 0},
    {0, 0, 0, 100},
    {50, 50, 50, 100},
    0
};


#ifdef __MMI_SCREEN_SWITCH_EFFECT__
static gui_screen_switch_effect_custom_return_code_enum
    wgui_category_sse_popup_custom_handler(
        gui_screen_switch_effect_stage_enum stage_type,
        gui_screen_switch_effect_custom_param_struct *param);
#endif /* __MMI_SCREEN_SWITCH_EFFECT__ */

static void ShowCommonCategoryPopupScreen(UI_string_type message);
#define ShowCommonCategoryPopupScreenType2(_arg0, _arg1, _arg2, _arg3, _arg4)\
	ShowCommonCategoryPopupScreenType(get_string(_arg0), get_image(_arg1), get_string(_arg2), get_string(_arg3), _arg4)


/*****************************************************************************
 * FUNCTION
 *  ShowCommonCategoryPopupScreen
 * DESCRIPTION
 *  Displays the category63 screen
 * PARAMETERS
 *  message             [IN]        Message string
 *  history_buffer      [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCommonCategoryPopupScreen(UI_string_type message)//, U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 l;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    //UI_UNUSED_PARAMETER(history_buffer);
    clear_category_screen_key_handlers();
    clear_left_softkey();
    clear_right_softkey();
    MMI_message_string = message;
    l = gui_strlen(MMI_message_string);
    create_multiline_inputbox_set_buffer(MMI_message_string, l, l, 0);
	MMI_multiline_inputbox.normal_text_color = *current_MMI_theme->popup_text_color;
    MMI_multiline_inputbox.flags |= UI_MULTI_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW
        | UI_MULTI_LINE_INPUT_BOX_CENTER_JUSTIFY
        | UI_MULTI_LINE_INPUT_BOX_DISABLE_BACKGROUND
        | UI_MULTI_LINE_INPUT_BOX_DISABLE_SCROLLBAR | UI_MULTI_LINE_INPUT_BOX_VIEW_MODE;
    MMI_multiline_inputbox.ext_flags |= GUI_MULTI_LINE_INPUT_BOX_TRUNCATE_CONTENT;
	MMI_multiline_inputbox.text_x = 0;
}


/*****************************************************************************
 * FUNCTION
 *  ShowCommonCategoryPopupScreenType
 * DESCRIPTION
 *  show common category popup screen
 * PARAMETERS
 *  title                   [IN]        =0 and title_icon=0, then status bar is displayed instead of the title
 *  title_icon              [IN]        Title icon
 *  left_softkey            [IN]        Left softkey label
 *  left_softkey_icon       [IN]        Icon for the left softkey
 *  right_softkey           [IN]        Right softkey label
 *  right_softkey_icon      [IN]        Icon for the right softkey
 *  message                 [IN]        Message to show
 *  history_buffer          [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/
static void ShowCommonCategoryPopupScreenType(
        UI_string_type title,
        PU8 title_icon,
        UI_string_type left_softkey,
        UI_string_type right_softkey,
        UI_string_type message)//,
//        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
 //   UI_UNUSED_PARAMETER(history_buffer);
    ShowCommonCategoryPopupScreen(message);//, history_buffer);
    dm_add_softkey_str(left_softkey, right_softkey);
    dm_add_title(title, title_icon);
}
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif

/*****************************************************************************
 * FUNCTION
 *  wgui_draw_small_screen_background
 * DESCRIPTION
 *  draw the background of popup screens (use color)
 * PARAMETERS
 *  x1                      [IN]        Start x position
 *  y1                      [IN]        Start y position
 *  x2                      [IN]        End x position
 *  y2                      [IN]        End y posityion
 *  f                       [IN]        Filled pattern
 *  enable_3D_effect        [IN]        It will no use from 08A
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_draw_small_screen_background(S32 x1, S32 y1, S32 x2, S32 y2, UI_filled_area *f)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(__MMI_MAINLCD_240X320__)|| (defined(__MMI_UI_POPUP_SLIM__)&& !defined(__MMI_MAINLCD_96X64__))
   gui_draw_gradient_rounded_rectangle(x1, y1, x2, y2, f->border_color, f->c, UI_POPUP_BORDER_SIZE);/* 091506 popup border */
   gui_fill_rectangle(x1 + UI_POPUP_BORDER_SIZE, y1 + UI_POPUP_BORDER_SIZE, x2 - UI_POPUP_BORDER_SIZE, y2 - UI_POPUP_BORDER_SIZE, f->c);

#else /* defined(__MMI_MAINLCD_240X320__) || defined(__MMI_MAINLCD_320X240__) */ 
   y2--; /* the border is out of the clip area in 3D popup*/
   gui_fill_rectangle(x1 + 1, y1 + 7, x2 - 1, y2 - 7, f->c);
   gui_draw_vertical_line(y1 + 6, y2 - 6, x1, f->border_color);
   gui_draw_vertical_line(y1 + 6, y2 - 6, x2, f->border_color);
   gui_draw_horizontal_line(x1 + 6, x2 - 6, y1, f->border_color);
   gui_draw_horizontal_line(x1 + 6, x2 - 6, y2, f->border_color);
   gui_draw_horizontal_line(x1 + 6, x2 - 6, y1 + 1, f->c);
   gui_draw_horizontal_line(x1 + 4, x2 - 4, y1 + 2, f->c);
   gui_draw_horizontal_line(x1 + 3, x2 - 3, y1 + 3, f->c);
   gui_draw_horizontal_line(x1 + 2, x2 - 2, y1 + 4, f->c);
   gui_draw_horizontal_line(x1 + 2, x2 - 2, y1 + 5, f->c);
   gui_draw_horizontal_line(x1 + 1, x2 - 1, y1 + 6, f->c);
   gui_draw_horizontal_line(x1 + 6, x2 - 6, y2 - 1, f->c);
   gui_draw_horizontal_line(x1 + 4, x2 - 4, y2 - 2, f->c);
   gui_draw_horizontal_line(x1 + 3, x2 - 3, y2 - 3, f->c);
   gui_draw_horizontal_line(x1 + 2, x2 - 2, y2 - 4, f->c);
   gui_draw_horizontal_line(x1 + 2, x2 - 2, y2 - 5, f->c);
   gui_draw_horizontal_line(x1 + 1, x2 - 1, y2 - 6, f->c);         
   gui_putpixel(x1 + 5, y1 + 1, f->border_color);
   gui_putpixel(x1 + 4, y1 + 1, f->border_color);
   gui_putpixel(x1 + 3, y1 + 2, f->border_color);
   gui_putpixel(x1 + 2, y1 + 3, f->border_color);
   gui_putpixel(x1 + 1, y1 + 4, f->border_color);
   gui_putpixel(x1 + 1, y1 + 5, f->border_color);
   gui_putpixel(x2 - 5, y1 + 1, f->border_color);
   gui_putpixel(x2 - 4, y1 + 1, f->border_color);
   gui_putpixel(x2 - 3, y1 + 2, f->border_color);
   gui_putpixel(x2 - 2, y1 + 3, f->border_color);
   gui_putpixel(x2 - 1, y1 + 4, f->border_color);
   gui_putpixel(x2 - 1, y1 + 5, f->border_color);
    
   gui_putpixel(x1 + 5, y2 - 1, f->border_color);
   gui_putpixel(x1 + 4, y2 - 1, f->border_color);
   gui_putpixel(x1 + 3, y2 - 2, f->border_color);
   gui_putpixel(x1 + 2, y2 - 3, f->border_color);
   gui_putpixel(x1 + 1, y2 - 4, f->border_color);
   gui_putpixel(x1 + 1, y2 - 5, f->border_color);
   gui_putpixel(x2 - 5, y2 - 1, f->border_color);
   gui_putpixel(x2 - 4, y2 - 1, f->border_color);
   gui_putpixel(x2 - 3, y2 - 2, f->border_color);
   gui_putpixel(x2 - 2, y2 - 3, f->border_color);
   gui_putpixel(x2 - 1, y2 - 4, f->border_color);
   gui_putpixel(x2 - 1, y2 - 5, f->border_color);
   {
        gui_draw_horizontal_line(x1 + 7, x2 - 6, y2 + 1, f->border_color);
        gui_draw_vertical_line(y1 + 7, y2 - 6, x2 + 1, f->border_color);
    
        gui_putpixel(x2 - 5, y2, f->border_color);
        gui_putpixel(x2 - 5, y2 + 1, f->border_color);
        gui_putpixel(x2 - 4, y2, f->border_color);
        gui_putpixel(x2 - 4, y2 + 1, f->border_color);
        gui_putpixel(x2 - 3, y2, f->border_color);
        gui_putpixel(x2 - 3, y2 - 1, f->border_color);
        gui_putpixel(x2 - 2, y2 - 2, f->border_color);
        gui_putpixel(x2 - 2, y2 - 1, f->border_color);
        gui_putpixel(x2 - 1, y2 - 3, f->border_color);
        gui_putpixel(x2 - 1, y2 - 2, f->border_color);
        gui_putpixel(x2 - 0, y2 - 4, f->border_color);
        gui_putpixel(x2 - 0, y2 - 3, f->border_color);
        gui_putpixel(x2, y2 - 5, f->border_color);
        gui_putpixel(x2 + 1, y2 - 5, f->border_color);
        gui_putpixel(x2 + 1, y2 - 4, f->border_color);
   }
#endif /* defined(__MMI_MAINLCD_240X320__) */  
}


/*****************************************************************************
 * FUNCTION
 *  wgui_draw_pop_up_screen_background
 * DESCRIPTION
 *  draw the background of popup screns
 * PARAMETERS
 *  x1                      [IN]        Start x position
 *  y1                      [IN]        Start y position
 *  x2                      [IN]        End x position
 *  y2                      [IN]        End y posityion
 *  f                       [IN]        Filled pattern
 *  enable_3D_effect        [IN]        It will no use from 08A
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_draw_pop_up_screen_background(S32 x1, S32 y1, S32 x2, S32 y2, UI_filled_area *f, MMI_BOOL enable_3D_effect)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_SCREEN_ROTATE__
    if (mmi_frm_is_screen_width_height_swapped())
    {
        if (current_MMI_theme->rotated_popup_screen_bg_filler->b != NULL)
        {
            gdi_image_draw_resized(x1, y1, (x2 - x1 + 1), (y2 - y1 + 1), current_MMI_theme->rotated_popup_screen_bg_filler->b);
            return;
        }
		wgui_draw_small_screen_background(x1, y1, x2, y2, current_MMI_theme->rotated_popup_screen_bg_filler);

    }
    else
#endif     
    {
        if (f->b != NULL)
        {
            gdi_image_draw_resized(x1, y1, (x2 - x1 + 1), (y2 - y1 + 1), f->b);
            return;
        }
		wgui_draw_small_screen_background(x1, y1, x2, y2, f);
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_draw_pop_up_screen_background_style2
 * DESCRIPTION
 *  draw the background of popup screns
 * PARAMETERS
 *  x1          [IN]        Start x position
 *  y1          [IN]        Start y position
 *  x2          [IN]        End x position
 *  y2          [IN]        End y posityion
 *  f           [IN]        Filled pattern
 *  top         [IN]        Whether to display top border
 *  bottom      [IN]        Whether to display bottom border
 *  left        [IN]        Whether to display left border
 *  right       [IN]        Whether to display right border
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_draw_pop_up_screen_background_style2(
        S32 x1,
        S32 y1,
        S32 x2,
        S32 y2,
        UI_filled_area *f,
        MMI_BOOL top,
        MMI_BOOL bottom,
        MMI_BOOL left,
        MMI_BOOL right)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 fy1, fy2, fx1, fx2;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (top)
    {
        fy1 = y1 + 6;
        gui_draw_horizontal_line(x1 + 6, x2 - 6, y1 + 1, f->c);
        gui_draw_horizontal_line(x1 + 4, x2 - 4, y1 + 2, f->c);
        gui_draw_horizontal_line(x1 + 3, x2 - 3, y1 + 3, f->c);
        gui_draw_horizontal_line(x1 + 2, x2 - 2, y1 + 4, f->c);
        gui_draw_horizontal_line(x1 + 2, x2 - 2, y1 + 5, f->c);

        gui_draw_horizontal_line(x1 + 6, x2 - 6, y1, f->border_color);
        gui_putpixel(x1 + 5, y1 + 1, f->border_color);
        gui_putpixel(x1 + 4, y1 + 1, f->border_color);
        gui_putpixel(x1 + 3, y1 + 2, f->border_color);
        gui_putpixel(x1 + 2, y1 + 3, f->border_color);
        gui_putpixel(x1 + 1, y1 + 4, f->border_color);
        gui_putpixel(x1 + 1, y1 + 5, f->border_color);
        gui_putpixel(x2 - 5, y1 + 1, f->border_color);
        gui_putpixel(x2 - 4, y1 + 1, f->border_color);
        gui_putpixel(x2 - 3, y1 + 2, f->border_color);
        gui_putpixel(x2 - 2, y1 + 3, f->border_color);
        gui_putpixel(x2 - 1, y1 + 4, f->border_color);
        gui_putpixel(x2 - 1, y1 + 5, f->border_color);
    }
    else
    {
        fy1 = y1;
    }

    if (bottom)
    {
        fy2 = y2 - 6;

        gui_draw_horizontal_line(x1 + 6, x2 - 6, y2 - 1, f->c);
        gui_draw_horizontal_line(x1 + 4, x2 - 4, y2 - 2, f->c);
        gui_draw_horizontal_line(x1 + 3, x2 - 3, y2 - 3, f->c);
        gui_draw_horizontal_line(x1 + 2, x2 - 2, y2 - 4, f->c);
        gui_draw_horizontal_line(x1 + 2, x2 - 2, y2 - 5, f->c);

        gui_draw_horizontal_line(x1 + 6, x2 - 6, y2, f->border_color);
        gui_putpixel(x1 + 5, y2 - 1, f->border_color);
        gui_putpixel(x1 + 4, y2 - 1, f->border_color);
        gui_putpixel(x1 + 3, y2 - 2, f->border_color);
        gui_putpixel(x1 + 2, y2 - 3, f->border_color);
        gui_putpixel(x1 + 1, y2 - 4, f->border_color);
        gui_putpixel(x1 + 1, y2 - 5, f->border_color);
        gui_putpixel(x2 - 5, y2 - 1, f->border_color);
        gui_putpixel(x2 - 4, y2 - 1, f->border_color);
        gui_putpixel(x2 - 3, y2 - 2, f->border_color);
        gui_putpixel(x2 - 2, y2 - 3, f->border_color);
        gui_putpixel(x2 - 1, y2 - 4, f->border_color);
        gui_putpixel(x2 - 1, y2 - 5, f->border_color);
    }
    else
    {
        fy2 = y2;
    }

    if (left)
    {
        fx1 = x1 + 1;
        gui_draw_vertical_line(fy1, fy2, x1, f->border_color);
    }
    else
    {
        fx1 = x1;
    }

    if (right)
    {
        fx2 = x2 - 1;
        gui_draw_vertical_line(fy1, fy2, x2, f->border_color);
    }
    else
    {
        fx2 = x2;
    }

    gui_fill_rectangle(fx1, fy1, fx2, fy2, f->c);
}

extern void wgui_set_animation_image_y(S32 x, S32 y, PU8 img);


/*****************************************************************************
 * FUNCTION
 *  ShowCategory62Screen
 * DESCRIPTION
 *  Displays the category62 screen
 * PARAMETERS
 *  message             [IN]        Message string
 *  message_icon        [IN]        Message icon
 *  history_buffer      [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory62Screen(U16 message, U16 message_icon, U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ShowCategory63Screen(
        (U8 *)GetString(message),
        message_icon,
        history_buffer);
}


/*****************************************************************************
 * FUNCTION
 *  ExitCategoryPopupScreen
 * DESCRIPTION
 *  Exits the common popup category screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitCategoryPopupScreen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    reset_small_screen();
    gui_hide_animations();
#ifdef __MMI_FTE_SUPPORT__
    {
        GDI_HANDLE new_layer;
        new_layer = dm_get_layer_handle(1);
        if(new_layer != GDI_NULL_HANDLE)
        {
            gdi_layer_push_and_set_active(new_layer);
            gdi_layer_clear(GDI_COLOR_TRANSPARENT);
            gdi_layer_pop_and_restore_active();
        }
    }
#endif
}

#if (defined __MMI_TOUCH_SCREEN__)
/*****************************************************************************
 * FUNCTION
 *  wgui_cat63_register_pen_down_handler
 * DESCRIPTION
 *  register application's private pen down handler
 *  This API should be called after ShowCategory63Screen
 *  Application should return:  MMI_TRUE if the event is handled
 *                              MMI_FALSE, otherwise
 * PARAMETERS
 *  pen_handler       [IN]        pen event handler
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat63_register_pen_down_handler(mmi_pen_handler pen_handler)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_register_category_screen_control_area_pen_handlers(pen_handler, MMI_PEN_EVENT_DOWN);
}
#endif /* (defined __MMI_TOUCH_SCREEN__) */ 

/*****************************************************************************
 * FUNCTION
 *  ShowCategory63Screen
 * DESCRIPTION
 *  Displays the category63 screen
 * PARAMETERS
 *  message             [IN]        Message string
 *  message_icon        [IN]        Message icon
 *  history_buffer      [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory63Screen(U8 *message, U16 message_icon, U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 flags;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    set_small_screen();

#ifdef __MMI_POPUP_NO_SHOW_ICON__
	message_icon = 0;
#endif

    ShowCommonCategoryPopupScreen((UI_string_type) message);//, history_buffer);
#ifdef __MMI_MAINLCD_128X64__
	flags = DM_CLEAR_SCREEN_BACKGROUND_COLOR;
    dm_add_image(get_image(0), NULL, NULL);
#else
    dm_add_image(get_image(message_icon), NULL, NULL);
    flags = 0;
#endif  
    wgui_cat_setup_category(
        MMI_CATEGORY63_ID,
        flags,
        ExitCategoryPopupScreen,
        dummy_get_history,
        dummy_get_history_size);
    dm_redraw_category_screen();
}

/*****************************************************************************
 * FUNCTION
 *  ShowCategory64Screen
 * DESCRIPTION
 *  Displays the category64 screen
 * PARAMETERS
 *  message             [IN]        Message string
 *  message_icon        [IN]        Message icon
 *  history_buffer      [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory64Screen(U16 message, U16 message_icon, U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ShowCategory63Screen(
        (U8 *)GetString(message),
        message_icon,
        history_buffer);
}

/* Leo start 20050722, pen down on image close popup */
#if (defined __MMI_TOUCH_SCREEN__)


/*****************************************************************************
 * FUNCTION
 *  Cat65ImagePenDownHdlr
 * DESCRIPTION
 *  pen down handler
 * PARAMETERS
 *  point       [IN]        pen down position
 * RETURNS
 *  Is handled
 *****************************************************************************/
MMI_BOOL Cat65ImagePenDownHdlr(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_frm_scrn_close_active_id();
    return MMI_TRUE;
}

/*****************************************************************************
 * FUNCTION
 *  wgui_cat65_register_pen_down_handler
 * DESCRIPTION
 *  register application's private pen down handler
 *  This API should be called after ShowCategory65Screen
 *  Application should return:  MMI_TRUE if the event is handled
 *                              MMI_FALSE, otherwise
 * PARAMETERS
 *  pen_handler       [IN]        pen event handler
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat65_register_pen_down_handler(mmi_pen_handler pen_handler)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_register_category_screen_control_area_pen_handlers(pen_handler, MMI_PEN_EVENT_DOWN);
}
#endif /* (defined __MMI_TOUCH_SCREEN__) */ 
/* Len end 20050722 */

#ifdef __MMI_TOUCH_SCREEN__
/*****************************************************************************
 * FUNCTION
 *  ShowCategory65Screen
 * DESCRIPTION
 *  Displays the category65 screen
 * PARAMETERS
 *  message             [IN]        Message string
 *  message_icon        [IN]        Message icon
 *  history_buffer      [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory65Screen(U8 *message, U16 message_icon, U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ShowCategory63Screen(message, message_icon, history_buffer);

    wgui_register_category_screen_control_area_pen_handlers(Cat65ImagePenDownHdlr, MMI_PEN_EVENT_DOWN);
 
}
#endif


#if defined(__MMI_TOUCH_SCREEN__) || defined(__MMI_HANDWRITING_PAD__)
typedef struct
{
    S16 image_x;    /* left-top corner of image */
    S16 image_y;
    U16 image_id;
    U16 state;
} gui_calibration_screen_struct;

static gui_calibration_screen_struct g_gui_calibration_screen_cntx;


/*****************************************************************************
 * FUNCTION
 *  UpdateCalibrationScreen
 * DESCRIPTION
 *  Updates Multiline buffer contents before redrawing calibration setting screens.
 * PARAMETERS
 *  image_id        [IN]        Image ID
 *  cali_x          [IN]        The position of central point of image X(i.e. the calibration point)
 *  cali_y          [IN]        The position of central point of image Y
 *  string          [IN]        Calibration string
 *  state           [IN]        Casted from PHNSET_CALIBRATION_STATE_ENUM
 *  redraw          [IN]        Redraw the category screen
 * RETURNS
 *  void
 * REMARKS
 *  We should avoid overlapping of image and text
 *****************************************************************************/
void UpdateCalibrationScreen(U16 image_id, S16 cali_x, S16 cali_y, U16 string, U16 state, MMI_BOOL redraw)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 l, fh, image_width = 0, image_height = 0;
    S32 yloc = 0;   /* start y coordinate *//* 111605 warning Calvin */
    S32 maxht;      /* maximum height of Multiline Box */
    S32 max_space;  /* max_space is the available height excluding the image */
    PU8 image;
    S32 image_x1, image_y1, image_y2;//, image_x2

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_gui_calibration_screen_cntx.image_id = image_id;
    g_gui_calibration_screen_cntx.state = state;

    if (image_id)
    {
        image = get_image((MMI_ID_TYPE) image_id);
        gui_measure_image(image, &image_width, &image_height);

        image_x1 = g_gui_calibration_screen_cntx.image_x = (S16) (cali_x - (image_width >> 1));
        image_y1 = g_gui_calibration_screen_cntx.image_y = (S16) (cali_y - (image_height >> 1));
//        image_x2 = image_x1 + image_width - 1;
        image_y2 = image_x1 + image_height - 1;

        MMI_DBG_ASSERT(image_x1 >= 0 && image_x2 < UI_device_width && image_y1 >= 0 && image_y2 < UI_device_height);
    }
    else
    {
        image = NULL;
        image_x1 = image_y1 = image_y2 = 0;//= image_x2 
    }

    /* Compute inputbox height */
    MMI_message_string = (UI_string_type) GetString(string);
    l = gui_strlen(MMI_message_string);
    create_multiline_inputbox_set_buffer(MMI_message_string, l, l, 0);
    #if defined (__MMI_FTE_SUPPORT__)
	    MMI_multiline_inputbox.normal_text_color = gui_color(255, 255, 255);
    #elif (defined (__MMI_MAINLCD_320X480__) || defined (__MMI_MAINLCD_360X640__))
	    MMI_multiline_inputbox.normal_text_color = gui_color(0, 0, 0);
	#else
	    MMI_multiline_inputbox.normal_text_color = *current_MMI_theme->popup_text_color;
	#endif
    MMI_multiline_inputbox.flags |= UI_MULTI_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW
        | UI_MULTI_LINE_INPUT_BOX_CENTER_JUSTIFY
        | UI_MULTI_LINE_INPUT_BOX_DISABLE_BACKGROUND
        | UI_MULTI_LINE_INPUT_BOX_DISABLE_SCROLLBAR | UI_MULTI_LINE_INPUT_BOX_VIEW_MODE;
    resize_multiline_inputbox(UI_device_width - 2, UI_device_height);
    show_multiline_inputbox_no_draw();
    fh = get_multiline_inputbox_line_height();

    /* Move the inputbox to appropriate position */
#ifdef __MMI_MAINLCD_128X128__
    maxht = (MMI_multiline_inputbox.n_lines * fh) + MULTILINE_INPUTBOX_HEIGHT_PAD + MMI_multiline_inputbox.text_y + 10;
#else 
    maxht = (MMI_multiline_inputbox.n_lines * fh) + MULTILINE_INPUTBOX_HEIGHT_PAD + MMI_multiline_inputbox.text_y;
#endif 

    if (maxht > UI_device_height)
    {
        maxht = UI_device_height;
    }

    switch (state)
    {
        case CALIBRATION_WELCOME_STATE:
            yloc = (UI_device_height >> 1) - (maxht >> 1);
            break;

        case CALIBRATION_TOP_LEFT_POINT_STATE:
            max_space = UI_device_height - image_y2 - 1;
            if (maxht > max_space)
            {
                yloc = image_y2 + 1;
                maxht = max_space;
            }
            else
            {
                yloc = image_y2 + 1 + (max_space - maxht) / 3;
            }
            break;

        case CALIBRATION_CENTER_POINT_STATE:
            max_space = image_y1 - 1;
            if (maxht > max_space)
            {
                yloc = 0;
                maxht = max_space;
            }
            else
            {
                yloc = (max_space >> 1) - (maxht >> 1);
            }
            break;

        case CALIBRATION_BOTTOM_RIGHT_POINT_STATE:
            max_space = image_y1 - 1;
            if (maxht > max_space)
            {
                yloc = 0;
                maxht = max_space;
            }
            else
            {
                yloc = (max_space - maxht) * 2 / 3;
            }
            break;

        default:
            MMI_ASSERT(0);
            break;
    }

    resize_multiline_inputbox(UI_device_width - 2, maxht);
    move_multiline_inputbox(1, yloc);

    if (redraw)
    {
        RedrawCalibrationScreen();
    }
}


/*****************************************************************************
 * FUNCTION
 *  ExitCalibrationScreen
 * DESCRIPTION
 *  Exits Calibration Screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitCalibrationScreen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_hide_animations();
}


/*****************************************************************************
 * FUNCTION
 *  RedrawCalibrationScreen
 * DESCRIPTION
 *  Redraws Calibration Screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void RedrawCalibrationScreen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    PU8 image = NULL;
    gdi_handle handle;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_lock_double_buffer();
    gui_hide_animations();

    if (g_gui_calibration_screen_cntx.image_id)
    {
        image = get_image((MMI_ID_TYPE) g_gui_calibration_screen_cntx.image_id);
    }

    gui_push_clip();
    gui_reset_clip();

#ifdef __MMI_FTE_SUPPORT__
    {
        color c = {0, 0, 0, 100};
        clear_screen_with_color(c); /* clear screen with black color in FTE */
    }
#else
    clear_screen();  /* clear screeN with white color */
#endif /* __MMI_FTE_SUPPORT__ */

    show_multiline_inputbox();

    gui_reset_clip();
    if (image)
    {
        gdi_image_draw_animation(
            g_gui_calibration_screen_cntx.image_x,
            g_gui_calibration_screen_cntx.image_y,
            image,
            (gdi_handle*) & handle);
    }
    gui_pop_clip();

    gui_unlock_double_buffer();
    gui_BLT_double_buffer(0, 0, UI_device_width - 1, UI_device_height - 1);
}


/*****************************************************************************
 * FUNCTION
 *  ShowCalibrationScreen
 * DESCRIPTION
 *  Shows Calibration Screen
 * PARAMETERS
 *  image_id        [IN]        Image ID
 *  cali_x          [IN]        Calibration position x
 *  cali_y          [IN]        Calibration position y
 *  string          [IN]        Calibration string
 *  state           [IN]        Format of screen
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCalibrationScreen(U16 image_id, S16 cali_x, S16 cali_y, U16 string, U16 state)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    entry_full_screen();
    wgui_title_set_menu_shortcut_number(-1);

    gui_lock_double_buffer();
    clear_category_screen_key_handlers();
    clear_left_softkey();
    clear_right_softkey();
    UpdateCalibrationScreen(image_id, cali_x, cali_y, string, state, MMI_FALSE);
    gui_unlock_double_buffer();

    ExitCategoryFunction = ExitCalibrationScreen;
    RedrawCategoryFunction = RedrawCalibrationScreen;
    GetCategoryHistory = dummy_get_history;
    GetCategoryHistorySize = dummy_get_history_size;
    RedrawCalibrationScreen();
}

#ifdef __MMI_HANDWRITING_PAD__

static U8 g_gui_control_area[TP_AREA_MAX_NUM];


/*****************************************************************************
 * FUNCTION
 *  UpdateTestControlAreaScreen
 * DESCRIPTION
 *  Updates Multiline buffer contents before redrawing test control area screens.
 * PARAMETERS
 *  pos         [IN]        The position of the click point
 *  string      [IN]        String to show
 *  state       [IN]        Casted from PHNSET_CALIBRATION_STATE_ENUM
 *  redraw      [IN]        Redraw the category screen
 * RETURNS
 *  the state in testing control area screen
 * REMARKS
 *  We should avoid overlapping of image and text
 *****************************************************************************/
U16 UpdateTestControlAreaScreen(mmi_pen_point_struct pos, U16 string, U16 state, MMI_BOOL redraw)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 l, fh;
    S32 yloc;   /* start y coordinate */
    S32 maxht;  /* maximum height of Multiline Box */

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Compute inputbox height */
    MMI_message_string = (UI_string_type) GetString(string);
    l = gui_strlen(MMI_message_string);
    create_multiline_inputbox_set_buffer(MMI_message_string, l, l, 0);
	MMI_multiline_inputbox.normal_text_color = *current_MMI_theme->popup_text_color;
    MMI_multiline_inputbox.flags |= UI_MULTI_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW
        | UI_MULTI_LINE_INPUT_BOX_CENTER_JUSTIFY
        | UI_MULTI_LINE_INPUT_BOX_DISABLE_BACKGROUND
        | UI_MULTI_LINE_INPUT_BOX_DISABLE_SCROLLBAR | UI_MULTI_LINE_INPUT_BOX_VIEW_MODE;
    resize_multiline_inputbox(UI_device_width - 2, UI_device_height);
    show_multiline_inputbox_no_draw();
    fh = get_multiline_inputbox_line_height();

    /* Move the inputbox to appropriate position */
#ifdef __MMI_UI_STYLE_1__
    maxht = (MMI_multiline_inputbox.n_lines * fh) + MULTILINE_INPUTBOX_HEIGHT_PAD + MMI_multiline_inputbox.text_y + 10;
#else 
    maxht = (MMI_multiline_inputbox.n_lines * fh) + MULTILINE_INPUTBOX_HEIGHT_PAD + MMI_multiline_inputbox.text_y;
#endif 

    if (maxht > UI_device_height)
    {
        maxht = UI_device_height;
    }

    switch (state)
    {
        case TEST_CONTROL_AREA_WELCOME_STATE:
            memset(g_gui_control_area, 0, sizeof(U8) * TP_AREA_MAX_NUM);
            yloc = 20; 
            state = TEST_CONTROL_AREA_TESTING_STATE;
            break;

        case TEST_CONTROL_AREA_TESTING_STATE:
        {
            S32 i;

            yloc = 20; 
            if ((i = mmi_pen_check_inside_control_area(pos)) >= 0)
            {
                g_gui_control_area[i] = MMI_TRUE;
            }

            state = TEST_CONTROL_AREA_FINISH_STATE;
            for (i = 0; i < TP_AREA_MAX_NUM; i++)
            {
                if (IS_ENABLE_FLAG(tp_area_table[i].flag, TP_CONTROL_AREA) && (g_gui_control_area[i] != MMI_TRUE))
                {
                    state = TEST_CONTROL_AREA_TESTING_STATE;
                    break;
                }
            }
        }
            break;

        default:
            MMI_ASSERT(0);
            state = TEST_CONTROL_AREA_WELCOME_STATE;
            break;
    }

    resize_multiline_inputbox(UI_device_width - 2, maxht);
    move_multiline_inputbox(1, yloc);

    if (redraw)
    {
        RedrawTestControlAreaScreen();
    }
    return state;
}


/*****************************************************************************
 * FUNCTION
 *  ExitTestControlAreaScreen
 * DESCRIPTION
 *  Exits Control Area Screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitTestControlAreaScreen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ExitCategoryFunction = MMI_dummy_function;
    RedrawCategoryFunction = MMI_dummy_function;
    GetCategoryHistory = dummy_get_history;
    GetCategoryHistorySize = dummy_get_history_size;
}


/*****************************************************************************
 * FUNCTION
 *  RedrawTestControlAreaScreen
 * DESCRIPTION
 *  Redraws Control Area Screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void RedrawTestControlAreaScreen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    int i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_lock_double_buffer();

    gui_push_clip();
    gui_reset_clip();

    clear_screen();
    show_multiline_inputbox();

    gui_reset_clip();

    for (i = 0; i < TP_AREA_MAX_NUM; i++)
    {
        if (IS_ENABLE_FLAG(tp_area_table[i].flag, TP_CONTROL_AREA) && (g_gui_control_area[i] != MMI_TRUE))
        {
            int index = 0;
            mmi_pen_point_struct pos1, pos2;

            pos1 = tp_area_table[i].pos[index];
            index++;
            while ((tp_area_table[i].pos[index].x != -1) && (tp_area_table[i].pos[index].y != -1))
            {
                pos2 = tp_area_table[i].pos[index];
                gdi_draw_line(pos1.x, pos1.y, pos2.x, pos2.y, GDI_COLOR_BLACK);
                pos1 = pos2;
                index++;
            }
            pos2 = tp_area_table[i].pos[0];
            gdi_draw_line(pos1.x, pos1.y, pos2.x, pos2.y, GDI_COLOR_BLACK);

        }
        else
        {
            /* handwriting area */
        }
    }

    gui_pop_clip();

    gui_unlock_double_buffer();
    gui_BLT_double_buffer(0, 0, UI_device_width - 1, UI_device_height - 1);
}


/*****************************************************************************
 * FUNCTION
 *  ShowTestControlAreaScreen
 * DESCRIPTION
 *  Shows Control Area Screen
 * PARAMETERS
 *  pos         [IN]        position 
 *  string      [IN]        string to show
 *  state       [IN]        state
 * RETURNS
 *  void
 *****************************************************************************/
void ShowTestControlAreaScreen(mmi_pen_point_struct pos, U16 string, U16 state)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    entry_full_screen();
    wgui_title_set_menu_shortcut_number(-1);

    gui_lock_double_buffer();
    clear_category_screen_key_handlers();
    clear_left_softkey();
    clear_right_softkey();
    UpdateTestControlAreaScreen(pos, string, state, MMI_FALSE);
    gui_unlock_double_buffer();

    ExitCategoryFunction = ExitTestControlAreaScreen;
    RedrawCategoryFunction = RedrawTestControlAreaScreen;
    GetCategoryHistory = dummy_get_history;
    GetCategoryHistorySize = dummy_get_history_size;
    RedrawTestControlAreaScreen();
}
#endif /* __MMI_HANDWRITING_PAD__ */ 

#endif /* defined(__MMI_TOUCH_SCREEN__) || defined(__MMI_HANDWRITING_PAD__) */ 


/*****************************************************************************
 * FUNCTION
 *  ShowCategory121Screen
 * DESCRIPTION
 *  Displays the category121 screen
 * PARAMETERS
 *  left_softkey            [IN]        Left softkey label
 *  left_softkey_icon       [IN]        Icon for the right softkey
 *  right_softkey           [IN]        Right softkey label
 *  right_softkey_icon      [IN]        Icon for the left softkey
 *  message                 [IN]        String to display
 *  message_icon            [IN]        Icon to display
 *  history_buffer          [IN]        History buffer
 *  flag                    [IN]        Value shpuld be 0/1 -
 *  no(?)                   [IN]        Border drawn
 *  border(?)               [IN]        Around image and text
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory121Screen_int(
        U16 left_softkey,
        U16 right_softkey,
        U8 *message,
        U16 message_icon,
        U8 *history_buffer,
        U8 flag)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ShowCategory163Screen_int(
        get_string(left_softkey),
        get_string(right_softkey),
        (UI_string_type) message,
        message_icon,
        history_buffer);
}

/** Slide 56,57 ****/


/*****************************************************************************
 * FUNCTION
 *  Cate123CategoryControlAreaPenDownHandler
 * DESCRIPTION
 *  Category 123 control area pen down event handler
 * PARAMETERS
 *  point       [IN]        position
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
/* diamond, 2006/01/16 Category 123 control area pen down event handler */
#if (defined __MMI_TOUCH_SCREEN__)
MMI_BOOL Cate123CategoryControlAreaPenDownHandler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_scr_locker_restart_timer();
    return MMI_TRUE;
}
#endif /* (defined __MMI_TOUCH_SCREEN__) */ 

/*****************************************************************************
 * FUNCTION
 *  ShowCategory123Screen
 * DESCRIPTION
 *  Displays the category123 screen with status bar at the top
 * PARAMETERS
 *  title                   [IN]        =0 and title_icon=0, then status bar is displayed instead of the title
 *  title_icon              [IN]        Title icon
 *  left_softkey            [IN]        Left softkey label
 *  left_softkey_icon       [IN]        Icon for the left softkey
 *  right_softkey           [IN]        Right softkey label
 *  right_softkey_icon      [IN]        Icon for the right softkey
 *  message                 [IN]        Notification message
 *  message_icon            [IN]        message icon
 *  history_buffer          [IN]        History buffer
 *  MMI_ID_TYPE(?)          [IN]        Image          Notification image
 *  For(?)                  [IN]        Other values, a title is displayed
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory123Screen_int(
        U16 title,
        U16 title_icon,
        U16 left_softkey,
        U16 right_softkey,
        U16 message,
        U16 message_icon,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ShowCategory124Screen_int(
        title,
        title_icon,
        left_softkey,
        right_softkey,
        (U8*)get_string(message),
        message_icon,
        history_buffer);
}

/** Slide 56,57: Dynamic version of 123 ****/


/*****************************************************************************
 * FUNCTION
 *  ExitCategory124Screen
 * DESCRIPTION
 *  Exits the category124 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitCategory124Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    wgui_status_icon_bar_reset();
    reset_softkeys();
    reset_multiline_inputbox();
    gui_hide_animations();
#if defined(__MMI_MAINLCD_320X480__) && !defined(__MMI_FTE_SUPPORT__)
    wgui_popup_reset_softkey_flag();
    wgui_popup_reset_softkey_theme();
    enable_softkey_background();
#endif
}

#if defined(__OP01__)
//#include "SimDetectionResDef.h" //removed for bootup slim
/*****************************************************************************
 * FUNCTION
 *  wgui_cat124_hide_status_icon_in_idle
 * DESCRIPTION
 *  hide function of stats icon horizontal bar of idle screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat124_hide_status_icon_in_idle(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x1, y1, x2, y2;
#ifndef __MMI_IDLE_FULL_SCREEN__
    UI_filled_area *f = current_MMI_theme->status_icon_bar_filler;
#endif 

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_push_clip();
    wgui_status_icon_bar_get_clip(WGUI_STATUS_ICON_BAR_H_BAR, &x1, &y1, &x2, &y2);
    gdi_layer_set_clip(x1, y1, x2, y2);
#ifdef __MMI_IDLE_FULL_SCREEN__
    draw_wallpaper();
#else /* __MMI_IDLE_FULL_SCREEN__ */ 
    gui_draw_filled_area(x1, y1, x2 -x1 + 1, y2 - y1 + 1, f);
#endif /* __MMI_IDLE_FULL_SCREEN__ */ 
    gdi_layer_pop_clip();
}
#endif

#ifdef __MMI_ICON_BAR_SUPPORT__ 
#ifdef __MMI_FTE_SUPPORT__   
static void wgui_cat123_iconbar_hide_function(S32 x1, S32 y1, S32 x2, S32 y2)
{
   // gdi_layer_push_clip();
    gdi_layer_push_and_set_clip(x1, y1, x2, y2);
    gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_BLACK);
    gdi_layer_pop_clip();

}
#endif
#endif


/*****************************************************************************
 * FUNCTION
 *  ShowCategory124Screen
 * DESCRIPTION
 *  Displays the category124 screen with status bar at the top
 * PARAMETERS
 *  title                   [IN]        =0 and title_icon=0, then status bar is displayed instead of the title
 *  title_icon              [IN]        
 *  left_softkey            [IN]        Left softkey label
 *  left_softkey_icon       [IN]        Icon for the left softkey
 *  right_softkey           [IN]        Right softkey label
 *  right_softkey_icon      [IN]        Icon for the right softkey
 *  message                 [IN]        Notification message
 *  message_icon            [IN]        
 *  history_buffer          [IN]        History buffer
 *  MMI_ID_TYPE(?)          [IN]        Image          Notification image
 *  For(?)                  [IN]        Other values, a title is displayed
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory124Screen_int(
        U16 title,
        U16 title_icon,
        U16 left_softkey,
        U16 right_softkey,
        U8 *message,
        U16 message_icon,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 flags;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_POPUP_NO_SHOW_ICON__
	message_icon = 0;
#endif

#ifdef __MMI_MAINLCD_128X64__
    
    ShowCategory163Screen_int(
        get_string(left_softkey),
        get_string(right_softkey),
        (UI_string_type)message,
        message_icon,
        history_buffer);
        
    return;
#else//__MMI_MAINLCD_128X64__


    ShowCommonCategoryPopupScreenType2(
        title,
        title_icon,
        left_softkey,
        right_softkey,
        (UI_string_type) message);//,
//        history_buffer);
    dm_add_image(get_image(message_icon), NULL, NULL);

#if (defined __MMI_TOUCH_SCREEN__)
    wgui_register_category_screen_control_area_pen_handlers(
        Cate123CategoryControlAreaPenDownHandler,
        MMI_PEN_EVENT_DOWN);
#endif /* (defined __MMI_TOUCH_SCREEN__) */ 
#if defined(__MMI_MAINLCD_320X480__) && !defined(__MMI_FTE_SUPPORT__)
    register_hide_softkey(wgui_popup_hide_lsk, MMI_LEFT_SOFTKEY);
    register_hide_softkey(wgui_popup_hide_rsk, MMI_RIGHT_SOFTKEY);
	register_hide_softkey(wgui_popup_hide_csk, MMI_CENTER_SOFTKEY);
    wgui_popup_set_softkey_theme();
    wgui_popup_set_softkey_flag();
    disable_softkey_background();
#endif

#ifdef __MMI_ICON_BAR_SUPPORT__ 
#ifdef __MMI_FTE_SUPPORT__ 
    if(wgui_icon_bar_is_created())//MMI_TRUE == 
    {
        wgui_icon_bar_register_hide_function(wgui_cat123_iconbar_hide_function);
    }
#endif
#endif

    flags = DM_CLEAR_SCREEN_BACKGROUND | DM_NO_TITLE;
#if defined(__MMI_MAINLCD_128X128__) || defined (__MMI_MAINLCD_128X160__)
	flags |= DM_NO_STATUS_BAR;
#endif
    wgui_cat_setup_category(
        MMI_CATEGORY123_ID,
        flags,
        ExitCategory124Screen,
        dummy_get_history,
        dummy_get_history_size);
    dm_redraw_category_screen();
	
#endif//__MMI_MAINLCD_128X64__	
}

/*****************************************************************************
 * FUNCTION
 *  ExitCategory151Screen
 * DESCRIPTION
 *  Exits the category151 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitCategory151Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_multiline_inputbox.normal_filler = current_UI_theme->multi_line_input_box_theme->normal_filler;
    gui_hide_animations();
    reset_softkeys();
#if defined(DM_NEW_POPUPBG_METHOD)
    gui_vertical_scrollbar_reset_hide_callback(&MMI_multiline_inputbox.vbar);
#endif
    wgui_status_icon_bar_reset();
    reset_multiline_inputbox();
#if defined(__MMI_MAINLCD_320X480__) && !defined(__MMI_FTE_SUPPORT__)
    wgui_popup_reset_softkey_flag();
    wgui_popup_reset_softkey_theme();
    enable_softkey_background();
#endif
#if defined(__MMI_MAINLCD_176X220__) || defined (__MMI_MAINLCD_240X320__)
    leave_full_screen();
#endif 
}


/*****************************************************************************
 * FUNCTION
 *  GetCategory151HistorySize
 * DESCRIPTION
 *  Gets the size of the history buffer for category69 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  size in U8s of the history buffer
 *****************************************************************************/
S32 GetCategory151HistorySize(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return (sizeof(multiline_inputbox_category_history));
}


/*****************************************************************************
 * FUNCTION
 *  GetCategory151History
 * DESCRIPTION
 *  Gets the history buffer for category69 screen
 * PARAMETERS
 *  history_buffer      [IN]        Is the buffer into which the history data is stored (pre-allocated)
 * RETURNS
 *  Pointer to the history buffer
 *****************************************************************************/
U8 *GetCategory151History(U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    get_multiline_inputbox_category_history(MMI_CATEGORY151_ID, history_buffer);
    return (history_buffer);
}

static UI_filled_area g_cat151_normal_filler;

#if defined(DM_NEW_POPUPBG_METHOD) || defined(__MMI_FTE_SUPPORT__)
/*****************************************************************************
 * FUNCTION
 *  wgui_cat151_multi_line_hide
 * DESCRIPTION
 *  hide mulitline background
 * PARAMETERS
 *  x1       [IN]     start x position
 *  y1       [IN]     start y position
 *  x2       [IN]     end x position
 *  y2       [IN]     end y position
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat151_multi_line_hide(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	g_cat151_normal_filler = wgui_pop_up_dialog_background;
	if(g_cat151_normal_filler.b != NULL)
	{
		g_cat151_normal_filler.flags = UI_FILLED_AREA_TYPE_BITMAP;
		g_cat151_normal_filler.transparent_color = UI_NULL_TRANSPARENT_COLOR;
	}
	else
	{
		g_cat151_normal_filler.flags = UI_FILLED_AREA_TYPE_COLOR;
	}
    //gdi_layer_push_clip();
    gdi_layer_push_and_set_clip(x1, y1, x2, y2);
    if(g_cat151_normal_filler.b != NULL)
    {
#if !defined (__MMI_FTE_SUPPORT__)
	    gui_show_transparent_image(MMI_POP_UP_DIALOG_X, MMI_POP_UP_DIALOG_Y, g_cat151_normal_filler.b, 0);
#else
        {
            dm_coordinates dm_popup_background_info;
            GDI_HANDLE scr_bg_layer;

            scr_bg_layer = dm_get_scr_bg_layer();
            dm_get_popup_bg_coordinate(&dm_popup_background_info);
			if(scr_bg_layer != GDI_NULL_HANDLE)
			{
            gdi_push_and_set_alpha_blending_source_layer(scr_bg_layer);
			}
            gdi_image_draw_resized(
                dm_popup_background_info.s16X, 
                dm_popup_background_info.s16Y,
                dm_popup_background_info.s16Width,
                dm_popup_background_info.s16Height,
                wgui_pop_up_dialog_background.b);
			if(scr_bg_layer != GDI_NULL_HANDLE)
			{
                gdi_pop_and_restore_alpha_blending_source_layer();
            }
        }
#endif
    }
    else
    {
        gui_fill_rectangle(x1, y1, x2, y2, g_cat151_normal_filler.c);
    } 
    gdi_layer_pop_clip();
}
#endif///
/*****************************************************************************
 * FUNCTION
 *  ShowCategory151Screen
 * DESCRIPTION
 *  Displays the category151 screen with status bar at the top
 * PARAMETERS
 *  title                   [IN]        =0 and title_icon=0, then status bar is displayed instead of the title
 *  title_icon              [IN]        Title icon
 *  left_softkey            [IN]        Left softkey label
 *  left_softkey_icon       [IN]        Icon for the left softkey
 *  right_softkey           [IN]        Right softkey label
 *  right_softkey_icon      [IN]        Icon for the right softkey
 *  message                 [IN]        Notification message
 *  message_icon            [?]         Message icon
 *  history_buffer          [IN]        History buffer
 *  MMI_ID_TYPE(?)          [IN]        Image          Notification image
 *  For(?)                  [IN]        Other values, a title is displayed
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory151Screen_int(
        U16 title,
        U16 title_icon,
        U16 left_softkey,
        U16 right_softkey,
        U8 *message,
        U8 *message_icon,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ShowCommonCategoryPopupScreenType2(
        title,
        title_icon,
        left_softkey,
        right_softkey,
        (UI_string_type) message);//,
//        history_buffer);

    /* 110805 SAT text Calvin Start */
    show_multiline_inputbox_no_draw();
    /* 110805 SAT text Calvin End */
#ifdef __MMI_POPUP_NO_SHOW_ICON__
	message_icon = 0;
#endif
    dm_add_image(message_icon, NULL, NULL);
#if defined(__MMI_MAINLCD_320X480__) && !defined(__MMI_FTE_SUPPORT__)
	  register_hide_softkey(wgui_popup_hide_lsk, MMI_LEFT_SOFTKEY);
    register_hide_softkey(wgui_popup_hide_rsk, MMI_RIGHT_SOFTKEY);
    register_hide_softkey(wgui_popup_hide_csk, MMI_CENTER_SOFTKEY);
    wgui_popup_set_softkey_theme();
    wgui_popup_set_softkey_flag();
	disable_softkey_background();
#endif 
    ExitCategoryFunction = ExitCategory151Screen;
    dm_setup_category_functions(dm_redraw_category_screen, GetCategory151History, GetCategory151HistorySize);
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32CatId = MMI_CATEGORY151_ID;
    dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND;
    if ((title == 0) && (title_icon == 0))
    {
        dm_data.s32flags |= DM_NO_TITLE;
    #ifndef __MMI_MAINLCD_128X64__
        ShowStatusIconsTitle();
    #endif
    }
    else if (!((title == 0xffff) && (title_icon == 0xffff)))
    {
    #if !defined(__MMI_MAINLCD_176X220__) && !defined (__MMI_MAINLCD_240X320__) 
        dm_data.s32flags |= DM_NO_STATUS_BAR;
    #endif 
    }
    else
    {
    #if !defined(__MMI_MAINLCD_176X220__) && !defined (__MMI_MAINLCD_240X320__) 
        dm_data.s32flags |= DM_NO_STATUS_BAR | DM_NO_TITLE;
    #else /* !defined(__MMI_MAINLCD_176X220__) && !defined (__MMI_MAINLCD_240X320__) */ 
        {
            dm_data.s32flags |= DM_NO_TITLE;
            ShowStatusIconsTitle();
        }
    #endif /* !defined(__MMI_MAINLCD_176X220__) && !defined (__MMI_MAINLCD_240X320__) */ 

    }
    dm_setup_data(&dm_data);
#ifdef __MMI_FTE_SUPPORT__
    MMI_multiline_inputbox.flags |= UI_MULTI_LINE_INPUT_BOX_DISABLE_BACKGROUND;
#else
    MMI_multiline_inputbox.flags &= ~UI_MULTI_LINE_INPUT_BOX_DISABLE_BACKGROUND;
#endif
#if !defined(DM_NEW_POPUPBG_METHOD) && !defined(__MMI_FTE_SUPPORT__)
#ifdef __GDI_MEMORY_PROFILE_2__
    MMI_multiline_inputbox.flags |= UI_MULTI_LINE_INPUT_BOX_TRANSPARENT_BACKGROUND;
//#else
 //   MMI_multiline_inputbox.normal_filler = &wgui_pop_up_dialog_inputbox_background;
#endif
#else
	MMI_multiline_inputbox.hide_callback = wgui_cat151_multi_line_hide;
    gui_vertical_scrollbar_register_hide_callback(&MMI_multiline_inputbox.vbar, wgui_cat151_multi_line_hide);
#endif
    MMI_multiline_inputbox.ext_flags |= GUI_MULTI_LINE_INPUT_BOX_NONE_BORDER;
    gdi_layer_lock_frame_buffer();
    dm_redraw_category_screen();
    set_multiline_inputbox_category_history(MMI_CATEGORY151_ID, history_buffer);
    show_multiline_inputbox();
    gdi_layer_unlock_frame_buffer();

    gdi_layer_blt_previous(0, 0, UI_device_width - 1, UI_device_height - 1);
}


/*****************************************************************************
 * FUNCTION
 *  ShowCategory162Screen
 * DESCRIPTION
 *  Displays the category62 screen
 * PARAMETERS
 *  left_softkey            [IN]        String ID of left softkey
 *  left_softkey_icon       [IN]        Image ID of left softkey
 *  right_softkey           [IN]        String ID of right softkey
 *  right_softkey_icon      [IN]        Image ID of right softkey
 *  message                 [IN]        String ID of message
 *  message_icon            [IN]        Image ID of message icon
 *  history_buffer          [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory162Screen(
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        U16 message,
        U16 message_icon,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ShowCategory165Screen(
        left_softkey,
        left_softkey_icon,
        right_softkey,
        right_softkey_icon,
        (UI_string_type)GetString(message),
        message_icon,
        history_buffer);
}

/*****************************************************************************
 * FUNCTION
 *  ShowCategory164Screen
 * DESCRIPTION
 *  Displays the category64 screen
 * PARAMETERS
 *  left_softkey            [IN]        String ID of left softkey
 *  left_softkey_icon       [IN]        Image ID of left softkey
 *  right_softkey           [IN]        String ID of right softkey
 *  right_softkey_icon      [IN]        Image ID of right softkey
 *  message                 [IN]        String ID of message
 *  message_icon            [IN]        Image ID of message icon
 *  history_buffer          [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory164Screen_int(
        U16 left_softkey,
        U16 right_softkey,
        U16 message,
        U16 message_icon,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ShowCategory163Screen_int(
        get_string(left_softkey),
        get_string(right_softkey),
        (UI_string_type)GetString(message),
        message_icon,
        history_buffer);
}

/* MTK Leo start, count down for confirm screen */
S32 Cat165CountDownValue;
FuncPtr Cat165TimerExpireCallBack = UI_dummy_function;


/*****************************************************************************
 * FUNCTION
 *  SetCat165TimerExpireFunc
 * DESCRIPTION
 *  Set popup countdown callback function
 * PARAMETERS
 *  f       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void SetCat165TimerExpireFunc(FuncPtr f)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    Cat165TimerExpireCallBack = f;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_popup_draw_region_with_background_color
 * DESCRIPTION
 *  clear a region to background color
 * PARAMETERS
 *  x1       [IN]     start x position
 *  y1       [IN]     start y position
 *  x2       [IN]     end x position
 *  y2       [IN]     end y position
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_popup_draw_region_with_background_color(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    //gdi_layer_push_clip();
    gdi_layer_push_and_set_clip(x1, y1, x2, y2);
    if(wgui_pop_up_dialog_background.b != NULL)
    {
#ifdef __MMI_FTE_SUPPORT__
        {
            dm_coordinates dm_popup_background_info;
            GDI_HANDLE alpha_layer;

            dm_get_popup_bg_coordinate(&dm_popup_background_info);
            alpha_layer = dm_get_scr_bg_layer();
			if(alpha_layer != GDI_NULL_HANDLE)
			{
				gdi_push_and_set_alpha_blending_source_layer(alpha_layer);
			}
			else
			{
				gdi_layer_get_base_handle(&alpha_layer);
				if(alpha_layer != GDI_NULL_HANDLE)
			    {
					gdi_push_and_set_alpha_blending_source_layer(alpha_layer);
				}
			}
            gdi_image_draw_resized(
                    dm_popup_background_info.s16X, 
                    dm_popup_background_info.s16Y,
                    dm_popup_background_info.s16Width,
                    dm_popup_background_info.s16Height,
                    wgui_pop_up_dialog_background.b);
			if(alpha_layer != GDI_NULL_HANDLE)
			{
                gdi_pop_and_restore_alpha_blending_source_layer();
            }
        }
#else
	    gdi_image_draw_resized(x1, y1, x2-x1+1, y2-y1+1, wgui_pop_up_dialog_background.b);
#endif    
    }
    else
    {
        gui_fill_rectangle(x1, y1, x2, y2, wgui_pop_up_dialog_background.c);
    } 
    gdi_layer_pop_clip();
}

#if defined (__MMI_MAINLCD_128X128__)
	#define WGUI_CAT165_COUNT_GAP 7
#elif defined (__MMI_MAINLCD_320X480__)
	#define WGUI_CAT165_COUNT_GAP 15
#elif defined (__MMI_MAINLCD_320X240__)
	#define WGUI_CAT165_COUNT_GAP 1
#else
	#define WGUI_CAT165_COUNT_GAP 5
#endif

/*****************************************************************************
 * FUNCTION
 *  Cat165CountDownCallBack
 * DESCRIPTION
 *  popup countdown callback function
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
extern UI_font_type UI_font;
#ifdef __MMI_MAINLCD_96X64__
void Cat165CountDownCallBack(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 buf[6];
    UI_font_type saved_font = UI_font;
    color saved_color = gui_get_text_color();

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (Cat165CountDownValue == 0)
    {
        gui_cancel_timer(Cat165CountDownCallBack);
        if (Cat165TimerExpireCallBack != NULL)
        {
            Cat165TimerExpireCallBack();
        }
    }
    else
    {
        S32 str_width, str_height;//, width, height;
        color *fg;
       // color bg;   /* popup countdown */

        fg = current_MMI_theme->popup_text_color;//popup_content_text_color
      //  bg = wgui_pop_up_dialog_background.c;

        gui_set_font(&MMI_medium_font);
        gui_set_text_color(*fg);
        gui_itoa(Cat165CountDownValue, (UI_string_type) buf, 10);
        gdi_layer_push_clip();
        gdi_layer_reset_clip();
        gui_measure_string((UI_string_type) buf, &str_width, &str_height);
        str_height = Get_CharHeightOfAllLang(MEDIUM_FONT);
        gdi_draw_solid_rect(
            (UI_device_width>>1) - 10,
            MMI_POP_UP_DIALOG_HEIGHT- MMI_SOFTKEY_HEIGHT-str_height/2,
			(UI_device_width>>1) + 10,
            MMI_POP_UP_DIALOG_HEIGHT- MMI_SOFTKEY_HEIGHT,
            GDI_COLOR_BLACK);
        gui_move_text_cursor(
                MMI_pop_up_dialog_x + ((MMI_pop_up_dialog_width - str_width) >> 1),//(UI_device_width>>1) - 10
               MMI_POP_UP_DIALOG_HEIGHT- MMI_SOFTKEY_HEIGHT-str_height/2);// +10
        gui_print_text((UI_string_type) buf);
        gdi_layer_pop_clip();
        gui_BLT_double_buffer(
            (UI_device_width>>1) - 10,
            MMI_POP_UP_DIALOG_HEIGHT- MMI_SOFTKEY_HEIGHT-str_height,
            (UI_device_width>>1)+10,
            UI_device_height);
        gui_set_font(saved_font);
        gui_set_text_color(saved_color);
        Cat165CountDownValue--;
        gui_start_timer(1000, Cat165CountDownCallBack);
    }
}
#elif __MMI_MAINLCD_128X64__
void Cat165CountDownCallBack(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 buf[6];
    UI_font_type saved_font = UI_font;
    color saved_color = gui_get_text_color();

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (Cat165CountDownValue == 0)
    {
        gui_cancel_timer(Cat165CountDownCallBack);
        if (Cat165TimerExpireCallBack != NULL)
        {
            Cat165TimerExpireCallBack();
        }
    }
    else
    {
        S32 str_width, str_height;//, width, height;
        color *fg;
     //   color bg;   /* popup countdown */

        fg = current_MMI_theme->popup_text_color;//popup_content_text_color
    //    bg = wgui_pop_up_dialog_background.c;

        gui_set_font(&MMI_medium_font);
        gui_set_text_color(*fg);
        gui_itoa(Cat165CountDownValue, (UI_string_type) buf, 10);
        gdi_layer_push_clip();
        gdi_layer_reset_clip();
        gui_measure_string((UI_string_type) buf, &str_width, &str_height);
        str_height = Get_CharHeightOfAllLang(MEDIUM_FONT);
        gdi_draw_solid_rect(
            (UI_device_width>>1) - 10,
            UI_device_height - MMI_button_bar_height,
			(UI_device_width>>1) + 10,
            UI_device_height - MMI_button_bar_height + str_height,
            GDI_COLOR_WHITE);
        gui_move_text_cursor(
                (UI_device_width>>1) - 10,
               UI_device_height - MMI_button_bar_height);
        gui_print_text((UI_string_type) buf);
        gdi_layer_pop_clip();
        gui_BLT_double_buffer(
            (UI_device_width>>1) - 10,
            UI_device_height - MMI_button_bar_height,
            (UI_device_width>>1)+10,
            UI_device_height);
        gui_set_font(saved_font);
        gui_set_text_color(saved_color);
        Cat165CountDownValue--;
        gui_start_timer(1000, Cat165CountDownCallBack);
    }
}
#else /* __MMI_MAINLCD_128X64__ */
void Cat165CountDownCallBack(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    UI_string_type buf[6];
    UI_font_type saved_font = UI_font;
    color saved_color = gui_get_text_color();

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (Cat165CountDownValue == 0)
    {
        gui_cancel_timer(Cat165CountDownCallBack);
        if (Cat165TimerExpireCallBack != NULL)
        {
            Cat165TimerExpireCallBack();
        }
    }
    else
    {
        S32 str_width, str_height, height;//, width
        color *fg;
#ifndef __GDI_MEMORY_PROFILE_2__		
        color bg;   /* popup countdown */
		bg = wgui_pop_up_dialog_background.c;
#endif
        fg = current_MMI_theme->popup_text_color;//popup_content_text_color
        
        

#ifdef __GDI_MEMORY_PROFILE_2__
        gdi_layer_push_and_set_active(dm_get_layer_handle(1));
#endif
        gui_set_font(&MMI_medium_font);
        gui_set_text_color(*fg);
        gui_itoa(Cat165CountDownValue, (UI_string_type) buf, 10);
        gdi_layer_push_clip();
        gdi_layer_reset_clip();
        gui_measure_string((UI_string_type) buf, &str_width, &str_height);
        str_height = Get_CharHeightOfAllLang(MEDIUM_FONT);
//        width = MMI_pop_up_dialog_width - 5 - str_width;
#if defined(__MMI_MAINLCD_320X480__)
		if(g_dm_data.s32CatId  == MMI_CATEGORY165_ID)
		{
            height = MMI_POP_UP_SOFTKEY_Y - MMI_pop_up_dialog_y - str_height-1;
		}
		else
#endif
		{
			height = MMI_pop_up_dialog_height - WGUI_CAT165_COUNT_GAP - str_height;
		}

#if  defined(DM_NEW_POPUPBG_METHOD)
        wgui_popup_draw_region_with_background_color(
            MMI_pop_up_dialog_x + 10,
            MMI_pop_up_dialog_y + height,
            MMI_pop_up_dialog_x + MMI_pop_up_dialog_width - 10,
            MMI_pop_up_dialog_y + height + str_height - 1);
#else
        gdi_draw_solid_rect(
            MMI_pop_up_dialog_x + 10,
            MMI_pop_up_dialog_y + height,
            MMI_pop_up_dialog_x + MMI_pop_up_dialog_width - 10,
            MMI_pop_up_dialog_y + height + str_height - 1,
#ifdef __GDI_MEMORY_PROFILE_2__
            GDI_COLOR_TRANSPARENT);
#else
            gdi_act_color_from_rgb(bg.alpha, bg.r, bg.g, bg.b));
#endif
#endif /* defined(__MMI_MAINLCD_320X480__) */

        if (mmi_fe_get_r2l_state())
        {
            gui_move_text_cursor(
                MMI_pop_up_dialog_x + ((MMI_pop_up_dialog_width + str_width) >> 1),
                MMI_pop_up_dialog_y + height);
        }
        else
        {
            gui_move_text_cursor(
                MMI_pop_up_dialog_x + ((MMI_pop_up_dialog_width - str_width) >> 1),
                MMI_pop_up_dialog_y + height);
        }
        gui_print_text((UI_string_type) buf);
        gdi_layer_pop_clip();
#ifdef __GDI_MEMORY_PROFILE_2__
        gdi_layer_pop_and_restore_active();
#endif
        gui_BLT_double_buffer(
            MMI_pop_up_dialog_x + 10,
            MMI_pop_up_dialog_y + height,
            MMI_pop_up_dialog_x + MMI_pop_up_dialog_width - 10,
            MMI_pop_up_dialog_y + height + str_height - 1);
        gui_set_font(saved_font);
        gui_set_text_color(saved_color);
        Cat165CountDownValue--;
        gui_start_timer(1000, Cat165CountDownCallBack);
    }
}

#endif /* __MMI_MAINLCD_128X64__ */

/*****************************************************************************
 * FUNCTION
 *  Cat165CountDownCallBack_ext
 * DESCRIPTION
 *  popup countdown callback function for FTE
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void Cat165CountDownCallBack_ext(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 buf[6];
    UI_font_type saved_font = UI_font;
    color saved_color = gui_get_text_color();

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (Cat165CountDownValue == 0)
    {
        gui_cancel_timer(Cat165CountDownCallBack_ext);
        if (Cat165TimerExpireCallBack != NULL)
        {
            Cat165TimerExpireCallBack();
        }
    }
    else
    {
        S32 str_width, str_height;
        color *fg;
   
		S32 str_y;
#ifndef __GDI_MEMORY_PROFILE_2__		
		color bg;   /* popup countdown */
		bg = wgui_pop_up_dialog_background.c;
#endif		
        fg = current_MMI_theme->popup_text_color;//popup_content_text_color
       

#ifdef __GDI_MEMORY_PROFILE_2__
        gdi_layer_push_and_set_active(dm_get_layer_handle(1));
#endif
        gui_set_font(&MMI_medium_font);
        gui_set_text_color(*fg);
        gui_itoa(Cat165CountDownValue, (UI_string_type) buf, 10);
        gdi_layer_push_clip();
        gdi_layer_reset_clip();
        gui_measure_string((UI_string_type) buf, &str_width, &str_height);
        str_height = Get_CharHeightOfAllLang(MEDIUM_FONT);
		str_y = UI_device_height - MMI_button_bar_height - WGUI_POPUP_FTE_AREA_BOTTOM_SPACE - str_height;

#if  defined(DM_NEW_POPUPBG_METHOD)
        wgui_popup_draw_region_with_background_color(
            WGUI_POPUP_FTE_AREA_X + 10,
            str_y,
            WGUI_POPUP_FTE_AREA_X + WGUI_POPUP_FTE_AREA_WIDTH - 10,
            str_y + str_height - 1);
#else
        gdi_draw_solid_rect(
            WGUI_POPUP_FTE_AREA_X + 10,
            str_y,
            WGUI_POPUP_FTE_AREA_X + WGUI_POPUP_FTE_AREA_WIDTH - 10,
            str_y + str_height - 1,
#ifdef __GDI_MEMORY_PROFILE_2__
            GDI_COLOR_TRANSPARENT);
#else
            gdi_act_color_from_rgb(bg.alpha, bg.r, bg.g, bg.b));
#endif
#endif /* defined(__MMI_MAINLCD_320X480__) */

        if (mmi_fe_get_r2l_state())
        {
            gui_move_text_cursor(
                WGUI_POPUP_FTE_AREA_X + ((WGUI_POPUP_FTE_AREA_WIDTH + str_width) >> 1),
                str_y);
        }
        else
        {
            gui_move_text_cursor(
                WGUI_POPUP_FTE_AREA_X + ((WGUI_POPUP_FTE_AREA_WIDTH - str_width) >> 1),
                str_y);
        }
        gui_print_text((UI_string_type) buf);
        gdi_layer_pop_clip();
#ifdef __GDI_MEMORY_PROFILE_2__
        gdi_layer_pop_and_restore_active();
#endif
        gui_BLT_double_buffer(
            WGUI_POPUP_FTE_AREA_X + 10,
            str_y,
            WGUI_POPUP_FTE_AREA_X + WGUI_POPUP_FTE_AREA_WIDTH - 10,
            str_y + str_height - 1);
        gui_set_font(saved_font);
        gui_set_text_color(saved_color);
        Cat165CountDownValue--;
        gui_start_timer(1000, Cat165CountDownCallBack_ext);
    }
}

/*****************************************************************************
 * FUNCTION
 *  ExitCategory165Screen
 * DESCRIPTION
 *  Exits the category65 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat165ext_exit(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    reset_small_screen();
    gui_hide_animations();
    gui_cancel_timer(Cat165CountDownCallBack_ext);
    Cat165TimerExpireCallBack = UI_dummy_function;
    wgui_softkey_set_is_in_popup(MMI_FALSE);
#ifdef __MMI_FTE_SUPPORT__
    {
        GDI_HANDLE new_layer;
        new_layer = dm_get_layer_handle(1);
        if(new_layer != GDI_NULL_HANDLE)
        {
            gdi_layer_push_and_set_active(new_layer);
            gdi_layer_clear(GDI_COLOR_TRANSPARENT);
            gdi_layer_pop_and_restore_active();
        }
    }
#endif
}

#ifdef __MMI_FTE_SUPPORT__
/*****************************************************************************
 * FUNCTION
 *  ShowCategory165Screen_ext_internal
 * DESCRIPTION
 *  Displays the category65 screen
 * PARAMETERS
 *  left_softkey            [IN]        
 *  left_softkey_icon       [IN]        
 *  right_softkey           [IN]        
 *  right_softkey_icon      [IN]        
 *  message                 [IN]        Message string
 *  message_icon            [IN]        
 *  duration                [IN]        
 *  history_buffer          [IN]        History buffer
 *  MMI_ID_TYPE(?)          [IN]        Icon        Message icon
 * RETURNS
 *  void
 *****************************************************************************/
static void ShowCategory165Screen_ext_internal(
        U16 left_softkey,
        U16 right_softkey,
        UI_string_type message,
        U16 message_icon,
        S32 duration,
        U8 *history_buffer)
{    
   /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 flags, catId;
	U16 string_ptr[MAX_SUB_MENU_SIZE];  

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    set_small_screen();

	flags = 0;

	mmi_ucs2cpy((S8 *)string_ptr, (S8 *)message);
	if(duration > 0)
	{
		mmi_ucs2cat((S8*)string_ptr,  (S8*)L"\n "); /* reserve place for countdown string*/
	}
	if((left_softkey == 0)&&(right_softkey == 0))
	{
		flags = DM_NO_SOFTKEY;
		ShowCommonCategoryPopupScreen(string_ptr);//, history_buffer);
        catId = MMI_CATEGORY63_ID;
	}
	else
	{
		ShowCommonCategoryPopupScreenType(
				0,
				0,
				get_string(left_softkey),
				get_string(right_softkey),
				string_ptr);//,
//				history_buffer);
        catId = MMI_CATEGORY165_ID;
	}
    dm_add_image(get_image(message_icon), NULL, NULL);
    wgui_softkey_set_is_in_popup(MMI_TRUE);

    flags |= DM_NO_TITLE | DM_NO_STATUS_BAR | DM_SET_NEW_LAYER_ACTIVE;
    wgui_cat_setup_category(catId, flags, wgui_cat165ext_exit, 
        dummy_get_history, dummy_get_history_size);
    dm_redraw_category_screen();
}
#endif

/*****************************************************************************
 * FUNCTION
 *  ShowCategory165Screen_ext
 * DESCRIPTION
 *  Displays the category65 screen
 * PARAMETERS
 *  left_softkey            [IN]        
 *  left_softkey_icon       [IN]        
 *  right_softkey           [IN]        
 *  right_softkey_icon      [IN]        
 *  message                 [IN]        Message string
 *  message_icon            [IN]        
 *  duration                [IN]        
 *  history_buffer          [IN]        History buffer
 *  MMI_ID_TYPE(?)          [IN]        Icon        Message icon
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory165Screen_ext_int(
        U16 left_softkey,
        U16 right_softkey,
        UI_string_type message,
        U16 message_icon,
        S32 duration,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_FTE_SUPPORT__
	ShowCategory165Screen_ext_internal(
		left_softkey,
        right_softkey,
        message,
        message_icon,
		duration,
        history_buffer);
    Cat165CountDownValue = duration;
    if (Cat165CountDownValue != 0)
    {
        Cat165CountDownCallBack_ext();
    }
#else
    ShowCategory165Screen_int(
        left_softkey,
        right_softkey,
        message,
        message_icon,
        history_buffer);
    
    Cat165CountDownValue = duration;
    if (Cat165CountDownValue != 0)
    {
        Cat165CountDownCallBack();
    }
#endif
}

extern icontext_button MMI_softkeys[];

/*****************************************************************************
 * FUNCTION
 *  wgui_popup_hide_lsk
 * DESCRIPTION
 *   hide left softkey
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_popup_hide_lsk(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_popup_draw_region_with_background_color(
        MMI_softkeys[MMI_LEFT_SOFTKEY].x,
        MMI_softkeys[MMI_LEFT_SOFTKEY].y,
        MMI_softkeys[MMI_LEFT_SOFTKEY].x + MMI_softkeys[MMI_LEFT_SOFTKEY].width - 1,
        MMI_softkeys[MMI_LEFT_SOFTKEY].y + MMI_softkeys[MMI_LEFT_SOFTKEY].height - 1);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_popup_hide_rsk
 * DESCRIPTION
 *  hide left softkey
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_popup_hide_rsk(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_popup_draw_region_with_background_color(
        MMI_softkeys[MMI_RIGHT_SOFTKEY].x,
        MMI_softkeys[MMI_RIGHT_SOFTKEY].y,
        MMI_softkeys[MMI_RIGHT_SOFTKEY].x + MMI_softkeys[MMI_RIGHT_SOFTKEY].width - 1,
        MMI_softkeys[MMI_RIGHT_SOFTKEY].y + MMI_softkeys[MMI_RIGHT_SOFTKEY].height - 1);
}

/*****************************************************************************
 * FUNCTION
 *  wgui_popup_hide_rsk
 * DESCRIPTION
 *  hide left softkey
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_popup_hide_csk(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_popup_draw_region_with_background_color(
        MMI_softkeys[MMI_CENTER_SOFTKEY].x,
        MMI_softkeys[MMI_CENTER_SOFTKEY].y,
        MMI_softkeys[MMI_CENTER_SOFTKEY].x + MMI_softkeys[MMI_CENTER_SOFTKEY].width - 1,
        MMI_softkeys[MMI_CENTER_SOFTKEY].y + MMI_softkeys[MMI_CENTER_SOFTKEY].height - 1);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_popup_set_softkey_theme
 * DESCRIPTION
 *  set popup softkey theme
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_popup_set_softkey_theme(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
     wgui_softkey_set_theme(
        MMI_LEFT_SOFTKEY,
        current_MMI_theme->popup_embedded_lsk_normal_up_filler,
        current_MMI_theme->popup_embedded_lsk_normal_down_filler,
        *current_MMI_theme->popup_embedded_softkey_text_color,
		*current_MMI_theme->popup_embedded_softkey_text_color,
        *current_MMI_theme->popup_embedded_softkey_text_border_color,
        &MMI_medium_font);
 #if 0       
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif	
}


/*****************************************************************************
 * FUNCTION
 *  wgui_popup_reset_softkey_theme
 * DESCRIPTION
 *  reset popup softkey theme
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_popup_reset_softkey_theme(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_softkey_reset_theme(MMI_LEFT_SOFTKEY);
    //wgui_softkey_reset_theme(MMI_RIGHT_SOFTKEY);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_popup_set_softkey_flag
 * DESCRIPTION
 *  set popup softkey flag
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_popup_set_softkey_flag(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    set_softkey_flags_on(UI_BUTTON_NO_SHIFT_BUTTON | UI_BUTTON_SHIFT_TEXT | UI_BUTTON_CENTER_TEXT_X | UI_BUTTON_FULL_TOUCH_AREA, MMI_LEFT_SOFTKEY);
    set_softkey_flags_on(UI_BUTTON_NO_SHIFT_BUTTON | UI_BUTTON_SHIFT_TEXT | UI_BUTTON_CENTER_TEXT_X | UI_BUTTON_FULL_TOUCH_AREA, MMI_RIGHT_SOFTKEY);
	set_softkey_flags_off(UI_BUTTON_DISABLE_BACKGND_DISPLAY, MMI_LEFT_SOFTKEY);
	set_softkey_flags_off(UI_BUTTON_DISABLE_BACKGND_DISPLAY, MMI_RIGHT_SOFTKEY);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_popup_reset_softkey_flag
 * DESCRIPTION
 *  reset popup softkey flag
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_popup_reset_softkey_flag(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    set_softkey_flags_off(UI_BUTTON_NO_SHIFT_BUTTON, MMI_LEFT_SOFTKEY);
    set_softkey_flags_off(UI_BUTTON_SHIFT_TEXT, MMI_LEFT_SOFTKEY);
    set_softkey_flags_off(UI_BUTTON_NO_SHIFT_BUTTON, MMI_RIGHT_SOFTKEY);
    set_softkey_flags_off(UI_BUTTON_SHIFT_TEXT, MMI_RIGHT_SOFTKEY);
	set_softkey_flags_off(UI_BUTTON_CENTER_TEXT_X, MMI_LEFT_SOFTKEY);
	set_softkey_flags_off(UI_BUTTON_CENTER_TEXT_X, MMI_RIGHT_SOFTKEY);
	set_softkey_flags_off(UI_BUTTON_FULL_TOUCH_AREA, MMI_LEFT_SOFTKEY);
	set_softkey_flags_off(UI_BUTTON_FULL_TOUCH_AREA, MMI_RIGHT_SOFTKEY);
	set_softkey_flags_on(UI_BUTTON_DISABLE_BACKGND_DISPLAY, MMI_LEFT_SOFTKEY);
	set_softkey_flags_on(UI_BUTTON_DISABLE_BACKGND_DISPLAY, MMI_RIGHT_SOFTKEY);
}


/*****************************************************************************
 * FUNCTION
 *  ShowCategory163Screen
 * DESCRIPTION
 *  Displays the category63 screen
 * PARAMETERS
 *  left_softkey            [IN]        
 *  left_softkey_icon       [IN]        
 *  right_softkey           [IN]        
 *  right_softkey_icon      [IN]        
 *  message                 [IN]        Message string
 *  message_icon            [IN]        
 *  history_buffer          [IN]        History buffer
 *  MMI_ID_TYPE(?)          [IN]        Icon        Message icon
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory163Screen_int(
        UI_string_type left_softkey,
        UI_string_type right_softkey,
        UI_string_type message,
        U16 message_icon,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    set_small_screen();
#ifdef __MMI_POPUP_NO_SHOW_ICON__
	message_icon = 0;
#endif
	dm_data.s32flags = 0;
	if((left_softkey == 0)&&(right_softkey == 0))
	{
		dm_data.s32flags = DM_NO_SOFTKEY;
		ShowCommonCategoryPopupScreen(message);//, history_buffer);
        dm_data.s32CatId = MMI_CATEGORY63_ID;
	}
	else
	{
		ShowCommonCategoryPopupScreenType(
				0,
				0,
				left_softkey,
				right_softkey,
				message);//,
//				history_buffer);
        dm_data.s32CatId = MMI_CATEGORY165_ID;
	}
#ifdef __MMI_MAINLCD_128X64__
	dm_add_image(get_image(0), NULL, NULL);
#else
    dm_add_image(get_image(message_icon), NULL, NULL);
#endif
#if !defined(__MMI_FTE_SUPPORT__)
#if defined(__MMI_MAINLCD_320X480__)
#ifdef __MMI_SCREEN_ROTATE__
	if(!mmi_frm_is_screen_width_height_swapped())
#endif
    {
        register_hide_softkey(wgui_popup_hide_lsk, MMI_LEFT_SOFTKEY);
        register_hide_softkey(wgui_popup_hide_rsk, MMI_RIGHT_SOFTKEY);
		register_hide_softkey(wgui_popup_hide_csk, MMI_CENTER_SOFTKEY);
        wgui_popup_set_softkey_theme();
        wgui_popup_set_softkey_flag();
        disable_softkey_background();
    }
#else
    wgui_softkey_set_is_in_popup(MMI_TRUE);
#endif
#endif /* !defined(__MMI_FTE_SUPPORT__) */

    ExitCategoryFunction = ExitCategory165Screen;
    dm_setup_category_functions(dm_redraw_category_screen, dummy_get_history, dummy_get_history_size);
    dm_data.s32ScrId = (S32) GetActiveScreenId();
#ifdef __MMI_MAINLCD_128X64__
	dm_data.s32flags |= DM_CLEAR_SCREEN_BACKGROUND_COLOR;
#else
    dm_data.s32flags |= DM_SET_NEW_LAYER_ACTIVE;
#endif
    dm_setup_data(&dm_data);
    dm_redraw_category_screen();

}



/*****************************************************************************
 * FUNCTION
 *  ShowCategory163Screen_ext
 * DESCRIPTION
 *  Displays the category63 screen, support image buffer and image file
 * PARAMETERS
 *  left_softkey            [IN]  LSK string             
 *  right_softkey           [IN]  RSK string
 *  message                 [IN]  Message string
 *  message_icon_type       [IN]  Message icon type
 *  message_icon            [IN]  Message icon buffer
 *  message_icon_size       [IN]  Message icon buffer size
 *  message_icon_format     [IN]  Message icon format
 *  message_icon_file_path  [IN]  Message icon file name
 *  history_buffer          [IN]  History buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory163Screen_ext(
        UI_string_type left_softkey,
        UI_string_type right_softkey,
        UI_string_type message,
        wgui_cat_popup_icon_type_enum message_icon_type,
        PU8 message_icon,
        S32 message_icon_size,
        U8 message_icon_format,
        UI_string_type message_icon_file_path,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    set_small_screen();
#ifdef __MMI_POPUP_NO_SHOW_ICON__
	message_icon = NULL;
#endif

	dm_data.s32flags = 0;
	if((left_softkey == 0)&&(right_softkey == 0))
	{
		dm_data.s32flags = DM_NO_SOFTKEY;
		ShowCommonCategoryPopupScreen(message);//, history_buffer);
        dm_data.s32CatId = MMI_CATEGORY63_ID;
	}
	else
	{
		ShowCommonCategoryPopupScreenType(
				0,
				0,
				left_softkey,
				right_softkey,
				message);//,
//				history_buffer);
        dm_data.s32CatId = MMI_CATEGORY165_ID;
	}
    
    switch (message_icon_type)
    {
        case IMAGE_BUFFER:
            {
                dm_add_image(message_icon, NULL, NULL);
                break;
            }
        
        case IMAGE_BUFFER_WITHOUT_HEADER:
            {
                dm_add_image_2(message_icon, message_icon_size, NULL, DM_IMAGE_WITHOUT_HEADER, message_icon_format, 0, 0);
                break;
            }

        case IMAGE_FILE_PATH:
            {
                dm_add_image(NULL, message_icon_file_path, NULL);
                break;
            }

        default:
            {
                dm_add_image(NULL, NULL, NULL);
                break;
            }
    }

    wgui_softkey_set_is_in_popup(MMI_TRUE);
    ExitCategoryFunction = ExitCategory165Screen;
    dm_setup_category_functions(dm_redraw_category_screen, dummy_get_history, dummy_get_history_size);
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32flags |= DM_SET_NEW_LAYER_ACTIVE;

    dm_setup_data(&dm_data);
    dm_redraw_category_screen();

}

/*****************************************************************************
 * FUNCTION
 *  ShowCategory165Screen
 * DESCRIPTION
 *  Displays the category65 screen
 * PARAMETERS
 *  left_softkey            [IN]        
 *  left_softkey_icon       [IN]        
 *  right_softkey           [IN]        
 *  right_softkey_icon      [IN]        
 *  message                 [IN]        Message string
 *  message_icon            [IN]        
 *  history_buffer          [IN]        History buffer
 *  MMI_ID_TYPE(?)          [IN]        Icon        Message icon
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory165Screen_int(
        U16 left_softkey,
        U16 right_softkey,
        UI_string_type message,
        U16 message_icon,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ShowCategory163Screen_int(
        get_string(left_softkey),
        get_string(right_softkey),
        message,
        message_icon,
        history_buffer);
}

void wgui_cat_popup_update_string(UI_string_type message)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	MMI_message_string = message;
	cat66_update_progress_string();
}
/* MTK Leo end */


/*****************************************************************************
 * FUNCTION
 *  ExitCategory165Screen
 * DESCRIPTION
 *  Exits the category65 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitCategory165Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(__MMI_NCENTER_SUPPORT__)
    vapp_ncenter_enable_drag();
#endif

    reset_small_screen();
#if  !defined(__MMI_FTE_SUPPORT__)
#if defined(__MMI_MAINLCD_320X480__)
#ifdef __MMI_SCREEN_ROTATE__
	if(!mmi_frm_is_screen_width_height_swapped())
#endif
    {
        wgui_popup_reset_softkey_theme();
        wgui_popup_reset_softkey_flag();
        enable_softkey_background();
    }
#else
    wgui_softkey_set_is_in_popup(MMI_FALSE);
#endif
#endif /*  !defined(__MMI_FTE_SUPPORT__) */
    gui_hide_animations();
    gui_cancel_timer(Cat165CountDownCallBack);
    Cat165TimerExpireCallBack = UI_dummy_function;
#ifdef __MMI_FTE_SUPPORT__
    {
        GDI_HANDLE new_layer;
        new_layer = dm_get_layer_handle(1);
        if(new_layer != GDI_NULL_HANDLE)
        {
            gdi_layer_push_and_set_active(new_layer);
            gdi_layer_clear(GDI_COLOR_TRANSPARENT);
            gdi_layer_pop_and_restore_active();
        }
    }
#endif
}

#ifdef __MMI_TOUCH_SCREEN__


/*****************************************************************************
 * FUNCTION
 *  DrawCate264CategoryControlArea
 * DESCRIPTION
 *  redraw control area
 * PARAMETERS
 *  coordinate      [IN]     area to redraw
 * RETURNS
 *  void
 *****************************************************************************/
void DrawCate264CategoryControlArea(dm_coordinates *coordinate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 img_width, img_height;
    S32 msg_width, msg_height;
    S32 pop_x = coordinate->s16X;
    S32 pop_y = coordinate->s16Y;
    S32 pop_width = coordinate->s16Width;
    S32 pop_height = coordinate->s16Height;
    extern S32 wgui_image_clip_x1;
    extern S32 wgui_image_clip_y1;
    extern S32 wgui_image_clip_x2;
    extern S32 wgui_image_clip_y2;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_image_get_dimension((U8*) MMI_message_icon, &img_width, &img_height);
    //resize_multiline_inputbox_fit((pop_width >> 1), (pop_height >> 1), &msg_width, &msg_height);//061507 128x160 touch
    resize_multiline_inputbox_fit((pop_width - 12), (pop_height >> 1), &msg_width, &msg_height);

    wgui_image_clip_x1 = pop_x + ((pop_width - img_width) >> 1);
    wgui_image_clip_y1 = pop_y + ((pop_height - img_height) >> 1);
    wgui_image_clip_x2 = wgui_image_clip_x1 + img_width;
    wgui_image_clip_y2 = wgui_image_clip_y1 + img_height;
    gdi_image_draw(wgui_image_clip_x1, wgui_image_clip_y1, (U8*) MMI_message_icon);
    move_multiline_inputbox(pop_x + ((pop_width - msg_width) >> 1), pop_y + ((pop_height + img_height) >> 1));
    show_multiline_inputbox();
}


/*****************************************************************************
 * FUNCTION
 *  category264_pen_down_handler
 * DESCRIPTION
 *  pen down hanlder
 * PARAMETERS
 *  point       [IN]        position
 * RETURNS
 *  Is handled
 *****************************************************************************/
MMI_BOOL category264_pen_down_handler(mmi_pen_point_struct point)
{
#if !defined(__MMI_FTE_SUPPORT__)
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	S32 pos_x = point.x, pos_y = point.y;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if ((mmi_scr_locker_is_locked()) &&
        (pos_x > wgui_image_clip_x1 && pos_x < wgui_image_clip_x2) && 
        (pos_y > wgui_image_clip_y1 && pos_y < wgui_image_clip_y2))
#endif
    {
        mmi_scr_locker_close();
        return MMI_TRUE;
    }
#if !defined(__MMI_FTE_SUPPORT__)
    else
     return MMI_FALSE;
#endif
}


/*****************************************************************************
 * FUNCTION
 *  Category264_image_pen_down_handler
 * DESCRIPTION
 *  image pen down handler
 * PARAMETERS
 *  point       [IN]        position
 * RETURNS
 *  Is handled
 *****************************************************************************/
MMI_BOOL Category264_image_pen_up_handler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(point);
    mmi_dialer_launch_by_string_ex(CUI_DIALER_TYPE_SOS, L"112");
    return MMI_TRUE;
}

MMI_BOOL Category264_image_pen_down_handler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(point);
    return MMI_TRUE;
}
/*****************************************************************************
 * FUNCTION
 *  ShowCategory264Screen
 * DESCRIPTION
 *  show category 264 
 * PARAMETERS
 *  message             [IN]        Char array of message
 *  message_icon        [IN]        Byte array of message icon
 *  dial_icon           [IN]        Image ID of the dial icon
 *  para                [IN]        Non-used now
 *  history_buffer      [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory264Screen(UI_string_type message, PU8 message_icon, U16 dial_icon, void *para, U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    set_small_screen();

    ShowCommonCategoryPopupScreen(message);//, history_buffer);
    MMI_message_icon = message_icon;
    MMI_message_string = message;

    if ( dial_icon == 0 )
    {
        dm_add_image(NULL,NULL,NULL );
    }
    else
    {
        dm_add_image(get_image(IMG_CSK_DIAL_ICON), NULL, NULL);
        wgui_register_image_control_pen_handlers(0, Category264_image_pen_down_handler, MMI_PEN_EVENT_DOWN);
		wgui_register_image_control_pen_handlers(0, Category264_image_pen_up_handler, MMI_PEN_EVENT_UP);
    }
#ifdef __MMI_FTE_SUPPORT__
    dm_add_image(MMI_message_icon, NULL, NULL);
    wgui_register_image_control_pen_handlers(1, category264_pen_down_handler, MMI_PEN_EVENT_DOWN);
#else 
    dm_register_category_controlled_callback(DrawCate264CategoryControlArea);
    wgui_register_category_screen_control_area_pen_handlers(category264_pen_down_handler, MMI_PEN_EVENT_DOWN);
#endif /* __MMI_FTE_SUPPORT__ */

    ExitCategoryFunction = ExitCategoryPopupScreen;
    RedrawCategoryFunction = dm_redraw_category_screen;
    GetCategoryHistory = dummy_get_history;
    GetCategoryHistorySize = dummy_get_history_size;
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32CatId = MMI_CATEGORY264_ID;
    dm_data.s32flags = 0;
    dm_setup_data(&dm_data);
    dm_redraw_category_screen();
}
#endif /* __MMI_TOUCH_SCREEN__ */ 

static PU8 g_cat366_image_p;
#if defined(DM_NEW_POPUPBG_METHOD)
static S32 g_cat366_image_x, g_cat366_image_y, g_cat366_image_height = 0;//, g_cat366_image_width

/*****************************************************************************
 * FUNCTION
 *  wgui_cat366_anim_draw_before_callback
 * DESCRIPTION
 *  This function is used to draw the pop-up background
 * PARAMETERS
 *  return_code [IN]    unused
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat366_anim_draw_before_callback(GDI_RESULT return_code)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	dm_coordinates popup_coordinate, temp_popup_coordinate;
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	dm_get_popup_bg_coordinate(&popup_coordinate);
	temp_popup_coordinate = popup_coordinate;
	temp_popup_coordinate.s16X = g_cat366_image_x;
	temp_popup_coordinate.s16Y = g_cat366_image_y;
	temp_popup_coordinate.s16Height = g_cat366_image_height;

	dm_popupbg_set_clip(&temp_popup_coordinate);
    dm_redraw_popup_background();
	dm_popupbg_set_clip(&popup_coordinate);
}
#endif
/*****************************************************************************
 * FUNCTION
 *  wgui_cat366_draw_controlled_area
 * DESCRIPTION
 *  Draw icon and string
 * PARAMETERS
 *  coordinate          [IN]   
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat366_draw_controlled_area(dm_coordinates *coordinate)
{
	/*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	S32 image_width;
    S32 image_height;
#if defined(DM_NEW_POPUPBG_METHOD)	
    U16 img_type = GDI_IMAGE_TYPE_INVALID;
#endif
    s32 x, y;
    gdi_handle image_handle;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

	gdi_layer_lock_frame_buffer();
   // gdi_layer_push_clip();
    gdi_layer_push_and_set_clip(
        coordinate->s16X,
        coordinate->s16Y,
        coordinate->s16X + coordinate->s16Width,
        coordinate->s16Y + coordinate->s16Height);
#if defined(DM_NEW_POPUPBG_METHOD)

    img_type = gdi_image_get_buf_type(g_cat366_image_p);
    
//#if defined(DM_NEW_POPUPBG_METHOD)
    if ((img_type != GDI_IMAGE_TYPE_GIF) && (img_type != GDI_IMAGE_TYPE_GIF_FILE))
    {
        gdi_anim_set_draw_before_callback(wgui_cat366_anim_draw_before_callback);
    }

#endif
    gdi_image_get_dimension(g_cat366_image_p, &image_width, &image_height);
    x = coordinate->s16X + ((coordinate->s16Width - image_width) >> 1);
    y = coordinate->s16Y;

#if defined(DM_NEW_POPUPBG_METHOD)
	g_cat366_image_x = x;
	g_cat366_image_y = y;
	//g_cat366_image_width = image_width;
	g_cat366_image_height = image_height;
#endif
	gdi_image_draw_animation(x, y, (U8*) g_cat366_image_p, &(image_handle));
    x = coordinate->s16X;
    y = coordinate->s16Y + image_height + 1;    /* 1 is gap between image and string */
    move_multiline_inputbox(x, y);
    resize_multiline_inputbox(coordinate->s16Width, coordinate->s16Height - image_height - 1);
    show_multiline_inputbox();
    gdi_layer_pop_clip();
	gdi_layer_unlock_frame_buffer();
}

/*****************************************************************************
 * FUNCTION
 *  ExitCategory266Screen
 * DESCRIPTION
 *  Exits the category266 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void ExitCategory366Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_hide_animations();

#if defined(__MMI_MAINLCD_320X480__) && !defined(__MMI_FTE_SUPPORT__)
    wgui_popup_reset_softkey_flag();
	wgui_popup_reset_softkey_theme();
	enable_softkey_background();
#endif
#ifdef __MMI_FTE_SUPPORT__
    {
        if(wgui_popup_is_enable_clear_background())
        {
            GDI_HANDLE base_layer;
            gdi_layer_get_base_handle(&base_layer);
            if(base_layer != GDI_NULL_HANDLE)
            {
                gdi_layer_push_and_set_active(base_layer);
                //gdi_layer_clear(GDI_COLOR_TRANSPARENT);
                gdi_draw_solid_rect(0, MMI_content_y, UI_device_width - 1, UI_device_height - MMI_button_bar_height - 1, GDI_COLOR_TRANSPARENT);
                gdi_layer_pop_and_restore_active();
            }
        }
        else
        {
             wgui_popup_enable_clear_background();
        }
    }
#endif
}   /* end of ExitCategory66Screen */

/*****************************************************************************
 * FUNCTION
 *  ShowCategory366Screen
 * DESCRIPTION
 *  Displays the category366 screen, it support update string dynamically. but 
 *   the string position is fixed to area except image.
 * PARAMETERS
 *  title                   [IN]        Title for the screen
 *  title_icon              [IN]        Icon shown with the title
 *  left_softkey            [IN]        Left softkey label
 *  left_softkey_icon       [IN]        Icon for the left softkey
 *  right_softkey           [IN]        Right softkey label
 *  right_softkey_icon      [IN]        Icon for the right softkey
 *  message                 [IN]        Notification message
 *  message_icon            [IN]        Message icon
 *  history_buffer          [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory366Screen_int(
        UI_string_type title,
        PU8 title_icon,
        UI_string_type left_softkey,
        UI_string_type right_softkey,
        UI_string_type message,
        U16 message_icon,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 l = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* register the custom SSE effect handler */
#ifdef __MMI_POPUP_NO_SHOW_ICON__
	message_icon = 0;
#endif
    gdi_layer_lock_frame_buffer();
    g_cat366_image_p = get_image(message_icon);
    dm_add_title(title, title_icon);
	dm_add_softkey_str(left_softkey, right_softkey);
#if defined(__MMI_MAINLCD_320X480__) && !defined(__MMI_FTE_SUPPORT__)
    {
        register_hide_softkey(wgui_popup_hide_lsk, MMI_LEFT_SOFTKEY);
        register_hide_softkey(wgui_popup_hide_rsk, MMI_RIGHT_SOFTKEY);
        register_hide_softkey(wgui_popup_hide_csk, MMI_CENTER_SOFTKEY);
        wgui_popup_set_softkey_theme();
        wgui_popup_set_softkey_flag();
        disable_softkey_background();
    }
#endif

    MMI_message_string = message;
    l = gui_strlen(MMI_message_string);
    create_multiline_inputbox_set_buffer(MMI_message_string, l, l, 0);
	MMI_multiline_inputbox.normal_text_color = *current_MMI_theme->popup_text_color;
    MMI_multiline_inputbox.flags |= UI_MULTI_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW
        | UI_MULTI_LINE_INPUT_BOX_CENTER_JUSTIFY
        | UI_MULTI_LINE_INPUT_BOX_DISABLE_BACKGROUND
        | UI_MULTI_LINE_INPUT_BOX_DISABLE_SCROLLBAR | UI_MULTI_LINE_INPUT_BOX_VIEW_MODE;
    MMI_multiline_inputbox.ext_flags |= GUI_MULTI_LINE_INPUT_BOX_TRUNCATE_CONTENT;
	MMI_multiline_inputbox.text_x = 0;

    gdi_layer_unlock_frame_buffer();

	dm_register_category_controlled_callback(wgui_cat366_draw_controlled_area);

    wgui_cat_setup_category(
        MMI_CATEGORY366_ID,
        DM_CLEAR_SCREEN_BACKGROUND,
        ExitCategory366Screen,
        dummy_get_history,
        dummy_get_history_size);
        
    dm_redraw_category_screen();

}   /* end of ShowCategory366Screen */


/*****************************************************************************
 * FUNCTION
 *  wgui_cat366_update_progress_string
 * DESCRIPTION
 *  Update status of progress for category66screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat366_update_progress_string(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	cat66_update_progress_string();
}   /* end of wgui_cat366_update_progress_string */

#ifdef __MMI_FTE_SUPPORT__
static MMI_BOOL g_popup_clear_bg = MMI_TRUE;
#endif
void wgui_popup_disable_clear_background(void)
{
#ifdef __MMI_FTE_SUPPORT__
    g_popup_clear_bg = MMI_FALSE;
#endif
}
void wgui_popup_enable_clear_background(void)
{
#ifdef __MMI_FTE_SUPPORT__
    g_popup_clear_bg = MMI_TRUE;
#endif
}
MMI_BOOL wgui_popup_is_enable_clear_background(void)
{
#ifdef __MMI_FTE_SUPPORT__
    return g_popup_clear_bg;
#else
    return MMI_FALSE;
#endif
}
#ifdef __MMI_SCREEN_SWITCH_EFFECT__

/* popup sliding up done flag */
static MMI_BOOL is_popup_sliding_up_done;

#ifndef __MMI_FTE_SUPPORT__
/*****************************************************************************
 * FUNCTION
 *  wgui_category_sse_popup_effect_draw_frame
 * DESCRIPTION
 *  Popup sliding effect draw frame callback handler
 * PARAMETERS
 *  effect_type               [IN]  effect type
 *  current_frame_index       [IN]  current frame index
 *  total_frame_num           [IN]  total frame num
 * RETURNS
 *  MMI_FALSE if to stop the effect; otherwise, MMI_TRUE.
 *****************************************************************************/
static MMI_BOOL wgui_category_sse_popup_effect_draw_frame(gui_screen_switch_effect_type_enum effect_type, S32 current_frame_index, S32 total_frame_num)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    /* 
     * This value makes the popup stay on the final position for a minimun 
     * period to let users OBSERVE the popup clearly enough.
     *
     * UI_POPUP_NOTIFYDURATION_TIME = 1000 ms 
     */
#define GUI_SCREEN_SWITCH_EFFECT_POPUP_MINIMUM_SHOW_TIME_IN_MS  400    
  //buildwarning  
    S32 old_layer_x, old_layer_y;
    dm_coordinates pop_coord = {0};
    S32 pop_y,  pop_h;//pop_x, pop_w,
    S32 bpp;
    PU8 buf_p;
    gdi_handle popup_layer;

    /* save the last popup sliding up displayed time to ensure the popup will appear as long as a pre-defined time */
    static kal_uint32 popup_first_displayed_time;
    
    kal_uint32 current_time;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
   // pop_x = 0;
    pop_y = 0;
   // pop_w = 0;
    pop_h = 0;

    /* make sure the popup only has two valid layers */
    if ((dm_get_layer_handle(0) == GDI_NULL_HANDLE) || 
        (dm_get_layer_handle(1) == GDI_NULL_HANDLE) || 
        (dm_get_layer_handle(2) != GDI_NULL_HANDLE) || 
        (dm_get_layer_handle(3) != GDI_NULL_HANDLE))
    {
        return MMI_FALSE;
    }

    dm_get_control_coordinates_from_category(
        -1,
        g_dm_data.s32CatId,
        DM_POPUP_BACKGROUND,
        -1,
        &pop_coord);

 //   pop_x = (S32)pop_coord.s16X;
    pop_y = (S32)pop_coord.s16Y;
 //   pop_w = (S32)pop_coord.s16Width;
    pop_h = (S32)pop_coord.s16Height;

    /* only for DM_POPUP_BACKGROUND */
    if (!pop_h || !pop_y)
    {
        return MMI_FALSE;
    }

    /* A special case to clear the popup when exiting screen. NOTE: This case is not called by SSE. */
    if (total_frame_num == 0)
    {   /* clear the popup area (including the softkey bar) */
        gdi_draw_solid_rect(0, pop_y, UI_device_width - 1, UI_device_height - 1, GDI_COLOR_TRANSPARENT);

        return MMI_TRUE;
    }

    /* make sure sliding down/up is paired */   
    if (current_frame_index == 0)
    {         
        if ((effect_type == GUI_SCREEN_SWITCH_EEFECT_OWNER_DRAW2) && !is_popup_sliding_up_done)
        {   /* no sliding up, given up */
            return MMI_FALSE;
        }

        is_popup_sliding_up_done = MMI_FALSE;
    }

    /* sleep some time at the beginning of sliding down */
    if ((current_frame_index == 0) && (effect_type == GUI_SCREEN_SWITCH_EEFECT_OWNER_DRAW2))
    {
        kal_uint32 elapsed_time;
    
        kal_get_time(&current_time);

        /* prevent u32 wrapping */
        if (current_time < popup_first_displayed_time)
        {
            current_time = popup_first_displayed_time;
        }

        elapsed_time = kal_ticks_to_milli_secs(current_time - popup_first_displayed_time);

        /* sleep for the minimum show time */
        if (elapsed_time < GUI_SCREEN_SWITCH_EFFECT_POPUP_MINIMUM_SHOW_TIME_IN_MS)
        {
            kal_sleep_task(kal_milli_secs_to_ticks(GUI_SCREEN_SWITCH_EFFECT_POPUP_MINIMUM_SHOW_TIME_IN_MS - elapsed_time));
        }
    }

    gdi_layer_push_and_set_active(dm_get_layer_handle(1));
    bpp = (S32)gdi_layer_get_bit_per_pixel();
    gdi_layer_get_buffer_ptr(&buf_p);    
    gdi_layer_get_position(&old_layer_x, &old_layer_y);

    gdi_layer_reset_clip();

    /* split the foreground layer into two parts */
    gdi_layer_resize(UI_device_width, pop_y);

    /* create the popup layer which cover the lower part */
    gdi_layer_create_using_outside_memory(
        0, 
        0,
        UI_device_width, 
        UI_device_height - pop_y, 
        &popup_layer, 
        buf_p + UI_device_width * pop_y * bpp / 8, 
        UI_device_width * (UI_device_height - pop_y) * bpp / 8);

    /* set popup layer offset */
    gdi_layer_push_and_set_active(popup_layer);
    gdi_layer_set_source_key(TRUE, GDI_COLOR_TRANSPARENT);
    if (effect_type == GUI_SCREEN_SWITCH_EEFECT_OWNER_DRAW2)
    {   /* sliding down */
        gdi_layer_set_position(0, pop_y + (current_frame_index + 1) * (UI_device_height - pop_y) / total_frame_num);
    }
    else
    {   /* sliding up */
        gdi_layer_set_position(0, pop_y + pop_h - (current_frame_index + 1) * pop_h / total_frame_num);
    }
    gdi_layer_pop_and_restore_active();

    gdi_layer_set_blt_layer(dm_get_layer_handle(0), dm_get_layer_handle(1), popup_layer, 0);

    if (current_frame_index == 0)
    {   /* blt out the whole screen for the first frame */
        gdi_layer_blt_previous(0, 0, UI_device_width - 1, UI_device_height - 1);
    }
    else
    {   /* blt lower part only to speed up */
        // TODO: can be optimized by dirty rectangles
        gdi_layer_blt_previous(0, pop_y, UI_device_width - 1, UI_device_height - 1);
    }
    
    /* restore blt layers */
    gdi_layer_set_blt_layer(dm_get_layer_handle(0), dm_get_layer_handle(1), 0, 0);

    /* restore the foreground layer height and position */
    gdi_layer_resize(UI_device_width, UI_device_height);
    gdi_layer_set_position(old_layer_x, old_layer_y);

    /* the last frame */
    if (current_frame_index == total_frame_num - 1)
    {
        if (effect_type == GUI_SCREEN_SWITCH_EEFECT_OWNER_DRAW2)
        {   /* clear the popup area (including the softkey bar) at the last frame of sliding down. */
            gdi_draw_solid_rect(0, pop_y, UI_device_width - 1, UI_device_height - 1, GDI_COLOR_TRANSPARENT);
        }
        else
        {   /* save the last displayed time of sliding up */
            kal_get_time(&popup_first_displayed_time);
            /* mark sliding up done to make sure sliding down/up is paired */
            is_popup_sliding_up_done = MMI_TRUE;            
        }
    }

    gdi_layer_pop_and_restore_active();

    /* free popup layer */
    gdi_layer_free(popup_layer);

    return MMI_TRUE;
}
#endif

/*****************************************************************************
 * FUNCTION
 *  wgui_category_sse_popup_custom_handler
 * DESCRIPTION
 *  Custom SSE effect handler for popup category 63 and 165
 * PARAMETERS
 *  stage_type       [IN]   SSE stage type
 *  param            [IN]   parameter
 * RETURNS
 *  Custom effect return code
 *****************************************************************************/
static gui_screen_switch_effect_custom_return_code_enum wgui_category_sse_popup_custom_handler(gui_screen_switch_effect_stage_enum stage_type, gui_screen_switch_effect_custom_param_struct *param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#define GUI_SCREEN_SWITCH_EFFECT_POPUP_SLIDING_FRAMES   4
#if !defined(__MMI_FTE_SUPPORT__)
    MMI_BOOL is_go_back_small = MMI_FALSE;
    MMI_BOOL is_force_pair = MMI_FALSE;
#endif
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(__MMI_FTE_SUPPORT__)
    /* no effect for FTE popup because the background of FTE popup is PNG */
    return GUI_SSE_CUSTOM_RETURN_CODE_NO_EFFECT;
#else /* defined(__MMI_FTE_SUPPORT__) */

#ifdef __MMI_SCREEN_ROTATE__
    /* no effect for rotated popup because it does not support DM_NEW_POPUPBG_METHOD yet. */
    if (mmi_frm_is_screen_width_height_swapped())
    {
        return GUI_SSE_CUSTOM_RETURN_CODE_NO_EFFECT;
    }
#endif /* __MMI_SCREEN_ROTATE__ */

    /* 
     * Make sure DM is activated to prevent ExitCategoryFunction() is called by APP, such as
     * camera, such that, when EntryNewScreen invokes GUI_SSE_STAGE_EXIT for the current popup,
     * the gdi blt layer handles are already FREED by ExitCategoryFunction().
     */
    if (!dm_is_activated())
    {            
        return GUI_SSE_CUSTOM_RETURN_CODE_NO_EFFECT;
    }

    /* 
     * Black list some categories.
     *
     * Category ID      Reason                                          Comment
     * --------------------------------------------------------------------------
     * 223              HVGA only. Popup is in middle, not on bottom.
     *
     * 112              PIN input. NOT good to apply.
     */    
    if (g_dm_data.s32CatId == MMI_CATEGORY223_ID)
    {
        return GUI_SSE_CUSTOM_RETURN_CODE_NO_EFFECT;
    }   
       

    switch (stage_type)
    {
        case GUI_SSE_STAGE_PRE_SETUP:
            
    #ifdef __MMI_SMALL_PIN_EDIT_SCREEN__
            if (g_dm_data.s32CatId == MMI_CATEGORY112_ID)
            {
                return GUI_SSE_CUSTOM_RETURN_CODE_NO_EFFECT;
            }
    #endif /* __MMI_SMALL_PIN_EDIT_SCREEN__ */
    
            /* popup sliding up */
            gui_screen_switch_effect_register_owner_draw_frame_callback(wgui_category_sse_popup_effect_draw_frame);
            gui_screen_switch_effect_setup_effect(GUI_SCREEN_SWITCH_EEFECT_OWNER_DRAW1, GUI_SCREEN_SWITCH_EFFECT_POPUP_SLIDING_FRAMES, GUI_SCREEN_SWITCH_EFFECT_TIMER_UNIT);
            return GUI_SSE_CUSTOM_RETURN_CODE_CUSTOM_EFFECT;

        case GUI_SSE_STAGE_POST_RUN:
            /* must blt the popup if no effect */
            if (!is_popup_sliding_up_done)
            {
                gdi_layer_blt_previous(0, 0, UI_device_width - 1, UI_device_height - 1);
            }
            break; 

        case GUI_SSE_STAGE_EXIT:
            /* clear the popup area to avoid a disabled-sliding popup on bottom */
            if (!is_popup_sliding_up_done && dm_get_layer_handle(1))
            {
        #ifdef __MMI_SMALL_PIN_EDIT_SCREEN__
                /* do not clear cat 112 when exiting */
                if (g_dm_data.s32CatId == MMI_CATEGORY112_ID)
                {
                    return GUI_SSE_CUSTOM_RETURN_CODE_NO_EFFECT;
                }
        #endif /* __MMI_SMALL_PIN_EDIT_SCREEN__ */
        
                gdi_layer_push_and_set_active(dm_get_layer_handle(1));            
                wgui_category_sse_popup_effect_draw_frame(GUI_SCREEN_SWITCH_EEFECT_OWNER_DRAW2, 0, 0);            
                gdi_layer_pop_and_restore_active();
                
                return GUI_SSE_CUSTOM_RETURN_CODE_NO_EFFECT;
            }
        
            /* 
             * If the toppest screen is a popup and 
             * 1. go back to a small screen
             * 2. sliding up is finished,
             * to make sliding up/down paired, sliding down is necessary.
             */
            // TODO: maybe this is dangerous
            if (is_popup_sliding_up_done && mmi_is_redrawing_bk_screens() && gdi_lcd_get_freeze())
            {
                is_go_back_small = MMI_TRUE;
                /* unfreeze LCD since history framework freezes LCD when redrawing bk screens */
                gdi_lcd_freeze(MMI_FALSE);
                /* got to force enable SSE in this case because SSE will verify mmi_is_redrawing_bk_screens() does not return true. */
                gui_screen_switch_effect_force_enable(MMI_TRUE);
            }

            /* force sliding up/down paired because NO SIM WLAN -> GSM mode switch will cause sliding up only */
            if (is_popup_sliding_up_done)
            {
                is_force_pair = MMI_TRUE;
                gui_screen_switch_effect_force_enable(MMI_TRUE);
            }

            /* popup sliding down */
            gui_screen_switch_effect_register_owner_draw_frame_callback(wgui_category_sse_popup_effect_draw_frame);
            gui_screen_switch_effect_setup_effect(GUI_SCREEN_SWITCH_EEFECT_OWNER_DRAW2, GUI_SCREEN_SWITCH_EFFECT_POPUP_SLIDING_FRAMES, GUI_SCREEN_SWITCH_EFFECT_TIMER_UNIT);
            /* must run sliding down effect here */
            gui_screen_switch_effect_run_effect(GUI_SCREEN_SWITCH_EEFECT_OWNER_DRAW2);

            if (is_force_pair)
            {
                gui_screen_switch_effect_force_enable(MMI_FALSE);
            }

            /* restore the lcd freeze and clear force flag */
            if (is_go_back_small)
            {
                gdi_lcd_freeze(MMI_TRUE);
                gui_screen_switch_effect_force_enable(MMI_FALSE);
            }

            is_popup_sliding_up_done = MMI_FALSE;
            
            return GUI_SSE_CUSTOM_RETURN_CODE_CUSTOM_EFFECT;

        default:
            break;
    }

    return GUI_SSE_CUSTOM_RETURN_CODE_DEFAULT;
#endif//unreachable	
}


/*****************************************************************************
 * FUNCTION
 *  wgui_category_sse_register_popup_sliding
 * DESCRIPTION
 *  Registers popup sliding handler.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_category_sse_register_popup_sliding(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    /* register the custom SSE effect handler */
    gui_screen_switch_effect_register_custom_callback(wgui_category_sse_popup_custom_handler);
}


#endif /* __MMI_SCREEN_SWITCH_EFFECT__ */



UI_string_type wgui_cat6003_sub_msg;
UI_string_type wgui_cat6003_cur_item;
U8 wgui_cat6003_percentage;

typedef enum
{
    WGUI_CAT6003_STR_MSG = 0,
    WGUI_CAT6003_STR_SUB_MSG,   
    WGUI_CAT6003_CUR_ITEM
} mmi_cat6003_str_enum;


typedef enum
{
    WGUI_CAT6003_STYLE1, /* message + percentage */
    WGUI_CAT6003_STYLE2, /* message + submessage */
    WGUI_CAT6003_STYLE3  /* full info */
} mmi_cat6003_style_enum;


/*****************************************************************************
 * FUNCTION
 *  wgui_cat6003_draw_str_bg
 * DESCRIPTION
 *  Displays the category6003 string background
 * PARAMETERS
 *  x             [IN]        x of the top-left of the title
 *  y             [IN]        y of the top-left of the title
 *  clip_x1       [IN]        x1 of the clip area
 *  clip_y1       [IN]        y1 of the clip area
 *  clip_x2       [IN]        x2 of the clip area
 *  clip_y2       [IN]        y2 of the clip area
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat6003_draw_str_bg(
                    S32 x, 
                    S32 y, 
                    S32 clip_x1, 
                    S32 clip_y1, 
                    S32 clip_x2, 
                    S32 clip_y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/ 
#if defined(DM_NEW_POPUPBG_METHOD)	
    dm_coordinates popup_clip = {0};

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    popup_clip.s16X = clip_x1;
    popup_clip.s16Y = clip_y1;
    popup_clip.s16Width = clip_x2 - clip_x1 + 1;
    popup_clip.s16Height = clip_y2 - clip_y1 + 1;  
#endif/*DM_NEW_POPUPBG_METHOD*/
#ifdef __MMI_MAINLCD_128X64__

    gdi_draw_solid_rect(clip_x1, clip_y1, clip_x2, clip_y2, GDI_COLOR_WHITE);
#elif defined(DM_NEW_POPUPBG_METHOD)
    dm_popupbg_set_clip(&popup_clip);
    dm_redraw_popup_background();

    dm_get_control_coordinates_from_category(
        -1,
        g_dm_data.s32CatId,
        DM_POPUP_BACKGROUND,
        -1,
        &popup_clip);

    dm_popupbg_set_clip(&popup_clip);
#else
    gdi_draw_solid_rect(clip_x1, clip_y1, clip_x2, clip_y2, GDI_COLOR_TRANSPARENT);
#endif
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat6003_show_string
 * DESCRIPTION
 *  Displays the category6003 screen string
 * PARAMETERS
 *  index           [IN]        Index of string in current screen
 *  buf             [IN]        String buffer
 *  x               [IN]        x position
 *  y               [IN]        y position
 *  width           [IN]        Area width
 *  height          [IN]        Area height
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat6003_show_string(
        U32 index, 
        UI_string_type buf, 
        S32 x, S32 y, S32 width, S32 height)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	gdi_handle layer_handle;
	gdi_handle lcd_handle;
	gui_util_painter_struct bg_painter;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (buf == NULL)
        return;

    if (wgui_text_label_get_title(index) == NULL)
    {
        gdi_layer_get_active(&layer_handle);
        gdi_lcd_get_active(&lcd_handle);
        gui_util_painter_create_callback(&bg_painter, wgui_cat6003_draw_str_bg);

        wgui_text_label_create(
            index, x, y, width, height, (U8*)buf,
            &MMI_medium_font,
            *current_MMI_theme->popup_text_color,
            MMI_FALSE,
            *current_MMI_theme->popup_text_color,
            bg_painter,
            GUI_TEXT_LABEL_H_ALIGN_CENTER,
            GUI_TEXT_LABEL_V_ALIGN_CENTER,
            layer_handle,
            lcd_handle);
    }
    
    wgui_text_label_show(index);
    
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat6003_show_progress
 * DESCRIPTION
 *  Displays the category6003 screen progress
 * PARAMETERS
 *  x               [IN]        x position
 *  y               [IN]        y position
 *  width           [IN]        Area width
 *  height          [IN]        Area height
 *  percentage      [IN]        percentage number
 *  info_l          [IN]        left info buffer 
 *  info_r          [IN]        right info buffer 
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat6003_show_progress(S32 x, S32 y, S32 width, S32 height, U8 percentage)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 percentage_width = width * percentage/100;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/   

#if defined(__MMI_SLIM_IMG_RES__)
    gdi_draw_rect(
        x, 
        y, 
        x + width - 1, 
        y + height - 1, 
        GDI_COLOR_RED);

    gdi_draw_solid_rect(
        x, 
        y, 
        x + percentage_width - 1, 
        y + height - 1, 
        GDI_COLOR_RED);
#elif defined(__MMI_FTE_SUPPORT__)
    gdi_image_draw_resized(
        x, 
        y, 
        width + 1,
        height + 1, 
        get_image(WGUI_VOLUME_PROGRESS_OFF));
    if (percentage > 0)
    {
        GDI_HANDLE act_layer = GDI_NULL_HANDLE;

        gdi_layer_get_active(&act_layer);
        if (act_layer != GDI_NULL_HANDLE)
        {
            gdi_push_and_set_alpha_blending_source_layer(act_layer);
        }

        gdi_image_draw_resized(
                x + 1, 
                y + 1,
                (width * percentage / 100) - 1,
                height - 1, 
                get_image(WGUI_VOLUME_PROGRESS_ON));

        if (act_layer != GDI_NULL_HANDLE)
        {
            gdi_pop_and_restore_alpha_blending_source_layer();
        }
    }
#else
    gdi_draw_rect(
        x, 
        y, 
        x + width - 1, 
        y + height - 1, 
        GDI_COLOR_RED);

    gdi_draw_solid_rect(
        x, 
        y, 
        x + percentage_width - 1, 
        y + height - 1, 
        GDI_COLOR_RED);
#endif
}


#ifdef __MMI_MAINLCD_128X64__
/*****************************************************************************
 * FUNCTION
 *  wgui_cat6003_draw_ctrl_area
 * DESCRIPTION
 *  Redraw category control area of category6003 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat6003_draw_ctrl_area(dm_coordinates *coordinate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 buffer[16];
    
    S32 y = coordinate->s16Y;
    S32 text_height = coordinate->s16Height/3;

    S32 progress_height = 13;
    S32 progress_width = coordinate->s16Width * 4/5;
    S32 progress_x = coordinate->s16X + ((coordinate->s16Width - progress_width)>>1);

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
	gdi_layer_lock_frame_buffer();
   // gdi_layer_push_clip();
    gdi_layer_push_and_set_clip(
        coordinate->s16X,
        coordinate->s16Y,
        coordinate->s16X + coordinate->s16Width - 1,
        coordinate->s16Y + coordinate->s16Height - 1);
    kal_wsprintf((kal_wchar*)buffer, "%d", wgui_cat6003_percentage);
    kal_wstrcat((kal_wchar*)buffer, L"%");  
	gdi_draw_solid_rect(
		coordinate->s16X, 
		coordinate->s16Y,
		coordinate->s16X + coordinate->s16Width - 1,
		coordinate->s16Y + coordinate->s16Height - 1, 
		GDI_COLOR_WHITE);
    wgui_cat6003_show_string(
        WGUI_CAT6003_STR_MSG, MMI_message_string, 
        coordinate->s16X, y, coordinate->s16Width, text_height);

    if (wgui_cat6003_sub_msg != NULL)
    {
        wgui_cat6003_show_string(
            WGUI_CAT6003_STR_SUB_MSG, wgui_cat6003_sub_msg, 
            coordinate->s16X, y+text_height, coordinate->s16Width, text_height);    
    }
    else
    {
        wgui_cat6003_show_string(
            WGUI_CAT6003_STR_SUB_MSG, buffer, 
            coordinate->s16X, y+text_height, coordinate->s16Width, text_height);                
    }

    /* Draw progress bar */
    wgui_cat6003_show_progress(
        progress_x, 
        y + 2*text_height, 
        progress_width, 
        progress_height, 
        wgui_cat6003_percentage);    

    wgui_text_label_close(0);
    wgui_text_label_close(1);

    gdi_layer_pop_clip();
	gdi_layer_unlock_frame_buffer();    
}
#else
/*****************************************************************************
 * FUNCTION
 *  wgui_cat6003_draw_ctrl_area
 * DESCRIPTION
 *  Redraw category control area of category6003 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat6003_draw_ctrl_area(dm_coordinates *coordinate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 buffer[16];
    
    S32 y_center = coordinate->s16Y + (coordinate->s16Height>>1);
    S32 text_height = MMI_SINGLELINE_INPUTBOX_HEIGHT;

    S32 progress_height = text_height/2;
    S32 progress_width = coordinate->s16Width * 4/5;
    S32 progress_x = coordinate->s16X + ((coordinate->s16Width - progress_width)>>1);

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
   // gdi_layer_push_clip();
    gdi_layer_push_and_set_clip(
        coordinate->s16X,
        coordinate->s16Y,
        coordinate->s16X + coordinate->s16Width - 1,
        coordinate->s16Y + coordinate->s16Height - 1);

    kal_wsprintf((kal_wchar*)buffer, "%d", wgui_cat6003_percentage);
    kal_wstrcat((kal_wchar*)buffer, L"%");

    gui_set_font(&MMI_medium_font);

    if (gui_get_string_width(MMI_message_string) >= WGUI_CAT6003_WIDTH)
    {
        S32 item_gap;
        S32 message_height, message_width;

#ifdef __MMI_FTE_SUPPORT__
        message_width = WGUI_POPUP_FTE_AREA_WIDTH;
#else
        message_width = MMI_POP_UP_DIALOG_WIDTH - UI_POPUP_BORDER_SIZE*2;
#endif
        /*
        wgui_cat6003_show_string(
                WGUI_CAT6003_STR_MSG, MMI_message_string, 
                coordinate->s16X, y_center - text_height*2, coordinate->s16Width, text_height);
                */
        MMI_multiline_inputbox.text = (UI_buffer_type)MMI_message_string;
        //wgui_inputs_ml_update_content();
        wgui_inputs_ml_resize_fit(message_width, coordinate->s16Height, &message_width, &message_height);
        item_gap = (coordinate->s16Height - message_height - progress_height - text_height) >> 2;

        wgui_inputs_ml_move(((UI_device_width - message_width)>>1), coordinate->s16Y + item_gap);
        wgui_inputs_ml_resize(message_width, message_height);
        wgui_inputs_ml_show();

        wgui_cat6003_show_string(
                WGUI_CAT6003_STR_SUB_MSG,
                wgui_cat6003_sub_msg ? wgui_cat6003_sub_msg : buffer,
                coordinate->s16X, 
                coordinate->s16Y + item_gap * 2 + message_height, 
                coordinate->s16Width,
                text_height);     

        /* Draw progress bar */
        wgui_cat6003_show_progress(
                progress_x, 
                coordinate->s16Y + item_gap * 3 + message_height + text_height, 
                progress_width, 
                progress_height, 
                wgui_cat6003_percentage);
    }
    else
    {
        wgui_cat6003_show_string(
                WGUI_CAT6003_STR_MSG, MMI_message_string, 
                coordinate->s16X, y_center - text_height*2, coordinate->s16Width, text_height);

        wgui_cat6003_show_string(
                WGUI_CAT6003_STR_SUB_MSG,
                wgui_cat6003_sub_msg ? wgui_cat6003_sub_msg : buffer,
                coordinate->s16X, y_center - text_height, coordinate->s16Width, text_height);     

        /* Draw progress bar */
        wgui_cat6003_show_progress(
                progress_x, 
                y_center + text_height, 
                progress_width, 
                progress_height, 
                wgui_cat6003_percentage);
    }

    wgui_text_label_close(0);
    wgui_text_label_close(1);

    gdi_layer_pop_clip();   
}

#endif

/*****************************************************************************
 * FUNCTION
 *  wgui_cat6003_exit
 * DESCRIPTION
 *  Exits the category6003 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat6003_exit(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    reset_small_screen();
    wgui_inputs_ml_reset();
#if defined(__MMI_MAINLCD_320X480__)
#ifdef __MMI_SCREEN_ROTATE__
	if(!mmi_frm_is_screen_width_height_swapped())
#endif
    {
        wgui_popup_reset_softkey_theme();
        wgui_popup_reset_softkey_flag();
        enable_softkey_background();
    }
#else
    wgui_softkey_set_is_in_popup(MMI_FALSE);
#endif
    gui_hide_animations();
#ifdef __MMI_FTE_SUPPORT__
    {
        GDI_HANDLE new_layer;
        new_layer = dm_get_layer_handle(1);
        if(new_layer != GDI_NULL_HANDLE)
        {
            gdi_layer_push_and_set_active(new_layer);
            gdi_layer_clear(GDI_COLOR_TRANSPARENT);
            gdi_layer_pop_and_restore_active();
        }
    }
#endif  
}

/*****************************************************************************
 * FUNCTION
 *  wgui_cat6003_show
 * DESCRIPTION
 *  Displays the category6003 screen, do not support Hisotry, small progress screeen
 * PARAMETERS
 *  left_softkey            [IN]        Left softkey label
 *  left_softkey_icon       [IN]        Icon for the left softkey
 *  right_softkey           [IN]        Right softkey label
 *  right_softkey_icon      [IN]        Icon for the right softkey
 *  message                 [IN]        Message string
 *  sub_message             [IN]        Message sub string
 *  progress_info_l         [IN]        Left progress string
 *  progress_info_r         [IN]        Right progress string
 *  current_item            [IN]        Current item string
 *  percentage              [IN]        Percentage of progress Ex:80 => 80%
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat6003_show(
        U16 left_softkey,
        U16 right_softkey,
        WCHAR* message,
        WCHAR* sub_message,
        U8 percentage)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 flags, catId;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    set_small_screen();
    gui_lock_double_buffer();

    flags = 0;

	if((left_softkey == 0)&&(right_softkey == 0))
	{
		flags = DM_NO_SOFTKEY;
        catId = MMI_CAT6003_NO_SK_ID;
	}
	else
	{
        dm_add_softkey_id(left_softkey, right_softkey);
        catId = MMI_CAT6003_ID;
	}

    MMI_message_string = message;
    gui_set_font(&MMI_medium_font);
    if (gui_get_string_width(message) >= WGUI_CAT6003_WIDTH)
    {
        S32 l;

        MMI_message_string = message;
        l = gui_strlen(MMI_message_string);
        create_multiline_inputbox_set_buffer(MMI_message_string, l, l, 0);
        MMI_multiline_inputbox.normal_text_color = *current_MMI_theme->popup_text_color;
        MMI_multiline_inputbox.flags |= UI_MULTI_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW
            | UI_MULTI_LINE_INPUT_BOX_CENTER_JUSTIFY
            | UI_MULTI_LINE_INPUT_BOX_DISABLE_BACKGROUND
            | UI_MULTI_LINE_INPUT_BOX_DISABLE_SCROLLBAR | UI_MULTI_LINE_INPUT_BOX_VIEW_MODE;
        MMI_multiline_inputbox.ext_flags |= GUI_MULTI_LINE_INPUT_BOX_TRUNCATE_CONTENT;
        MMI_multiline_inputbox.text_x = 0;
    }

    wgui_cat6003_sub_msg = sub_message;
    wgui_cat6003_percentage = percentage;

    dm_register_category_controlled_callback(wgui_cat6003_draw_ctrl_area);
    
#if !defined(__MMI_FTE_SUPPORT__)
#if defined(__MMI_MAINLCD_320X480__)
#ifdef __MMI_SCREEN_ROTATE__
	if(!mmi_frm_is_screen_width_height_swapped())
#endif
    {
        register_hide_softkey(wgui_popup_hide_lsk, MMI_LEFT_SOFTKEY);
        register_hide_softkey(wgui_popup_hide_rsk, MMI_RIGHT_SOFTKEY);
        wgui_popup_set_softkey_theme();
        wgui_popup_set_softkey_flag();
        disable_softkey_background();
    }
#else
    wgui_softkey_set_is_in_popup(MMI_TRUE);
#endif
#endif /* !defined(__MMI_FTE_SUPPORT__) */

    gui_unlock_double_buffer();
	flags |= DM_NO_TITLE | DM_NO_STATUS_BAR | DM_SET_NEW_LAYER_ACTIVE;
    wgui_cat_setup_category(
        catId,
        flags,
        wgui_cat6003_exit,
        dummy_get_history,
        dummy_get_history_size);
    dm_redraw_category_screen();

}

#ifdef __MMI_MAINLCD_128X64__
/*****************************************************************************
 * FUNCTION
 *  wgui_cat6003_update_all
 * DESCRIPTION
 *  Displays the category63 screen
 * PARAMETERS
 *  message                 [IN]        Message string
 *  sub_message             [IN]        Message sub string
 *  progress_info_l         [IN]        Left progress string
 *  progress_info_r         [IN]        Right progress string
 *  current_item            [IN]        Current item string
 *  percentage              [IN]        Percentage of progress Ex:80 => 80%
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat6003_update_all(
        WCHAR* message,
        WCHAR* sub_message,
        U8 percentage)
{
    dm_coordinates coordinate;

    gui_lock_double_buffer();

    MMI_message_string = message;
    wgui_cat6003_sub_msg = sub_message;
    wgui_cat6003_percentage = percentage;

    dm_get_control_coordinates_from_category(
        -1,
        g_dm_data.s32CatId,
        DM_CATEGORY_CONTROLLED_AREA,
        -1,
        &coordinate);

	gdi_draw_solid_rect(
            coordinate.s16X,
            coordinate.s16Y,
            coordinate.s16X + coordinate.s16Width - 1,
            coordinate.s16Y + coordinate.s16Height - 1,
            GDI_COLOR_WHITE);
    
    wgui_cat6003_draw_ctrl_area(&coordinate);

    gui_unlock_double_buffer();
    gui_BLT_double_buffer(0, 0, UI_device_width - 1, UI_device_height - 1);     
}
#else
/*****************************************************************************
 * FUNCTION
 *  wgui_cat6003_update_all
 * DESCRIPTION
 *  Displays the category63 screen
 * PARAMETERS
 *  message                 [IN]        Message string
 *  sub_message             [IN]        Message sub string
 *  progress_info_l         [IN]        Left progress string
 *  progress_info_r         [IN]        Right progress string
 *  current_item            [IN]        Current item string
 *  percentage              [IN]        Percentage of progress Ex:80 => 80%
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat6003_update_all(
        WCHAR* message,
        WCHAR* sub_message,
        U8 percentage)
{
    dm_coordinates coordinate;
        
    gui_lock_double_buffer();

    MMI_message_string = message;
    wgui_cat6003_sub_msg = sub_message;
    wgui_cat6003_percentage = percentage;

    dm_get_control_coordinates_from_category(
        -1,
        g_dm_data.s32CatId,
        DM_CATEGORY_CONTROLLED_AREA,
        -1,
        &coordinate);

	gdi_draw_solid_rect(
            coordinate.s16X,
            coordinate.s16Y,
            coordinate.s16X + coordinate.s16Width - 1,
            coordinate.s16Y + coordinate.s16Height - 1,
            GDI_COLOR_TRANSPARENT);

#if defined(DM_NEW_POPUPBG_METHOD)
    dm_popupbg_set_clip(&coordinate);
    dm_redraw_popup_background();
#endif
    wgui_cat6003_draw_ctrl_area(&coordinate);
#if defined(DM_NEW_POPUPBG_METHOD)
    dm_get_control_coordinates_from_category(
        -1,
        g_dm_data.s32CatId,
        DM_POPUP_BACKGROUND,
        -1,
        &coordinate);
    
    dm_popupbg_set_clip(&coordinate);
#endif
    gui_unlock_double_buffer();
    gui_BLT_double_buffer(0, 0, UI_device_width - 1, UI_device_height - 1);     
}

#endif

/*****************************************************************************
 * FUNCTION
 *  ShowCategory8Screen
 * DESCRIPTION
 *  Displays the category8 screen
 * PARAMETERS
 *  title                   [IN]        Title for the screen
 *  title_icon              [IN]        Icon shown with the title
 *  left_softkey            [IN]        Left softkey label
 *  left_softkey_icon       [IN]        Icon for the left softkey
 *  right_softkey           [IN]        Right softkey label
 *  right_softkey_icon      [IN]        Icon for the right softkey
 *  message                 [IN]        Notification message
 *  message_icon            [IN]        Message icon
 *  history_buffer          [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory8Screen_int(
        U16 title,
        U16 title_icon,
        U16 left_softkey,
        U16 right_softkey,
        U16 message,
        U16 message_icon,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ShowCategory66Screen_int(
        title,
        title_icon,
        left_softkey,
        right_softkey,
        (U8*) get_string(message),
        message_icon,
        history_buffer);
}   /* end of ShowCategory8Screen */


/*****************************************************************************
 * FUNCTION
 *  ShowCategory208Screen
 * DESCRIPTION
 *  
 * PARAMETERS
 *  title                   [IN]        Title for the screen
 *  title_icon              [IN]        Icon shown with the title
 *  left_softkey            [IN]        Left softkey label
 *  left_softkey_icon       [IN]        Icon for the left softkey
 *  right_softkey           [IN]        Right softkey label
 *  right_softkey_icon      [IN]        Icon for the right softkey
 *  message                 [IN]        String of message
 *  message_icon            [IN]        Icon of message
 *  history_buffer          [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory208Screen_int(
        U16 title,
        U16 title_icon,
        U16 left_softkey,
        U16 right_softkey,
        S8 *message,
        U16 message_icon,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ShowCategory66Screen_int(
        title,
        title_icon,
        left_softkey,
        right_softkey,
        (U8*) message,
        message_icon,
        history_buffer);
}


/*****************************************************************************
 * FUNCTION
 *  cat66_update_progress_string
 * DESCRIPTION
 *  Update status of progress for category66screen
 *  [IMPORTANT] Please notice that this function will not redo the layout.
 *  [IMPORTANT] The updated string length can't longer than length of the first string.
 *  [IMPORTANT] Otherwise the updated string will be trunacated.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void cat66_update_progress_string(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 l = 0;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();
    //gdi_layer_push_clip();
    gdi_layer_push_and_set_clip(
        MMI_multiline_inputbox.x + 2,
        MMI_multiline_inputbox.y,
        MMI_multiline_inputbox.x + MMI_multiline_inputbox.width - 2,
        MMI_multiline_inputbox.y + MMI_multiline_inputbox.height - 1);
#ifdef __GDI_MEMORY_PROFILE_2__
#if  defined(DM_NEW_POPUPBG_METHOD)
    wgui_popup_draw_region_with_background_color(
        MMI_multiline_inputbox.x + 2,
        MMI_multiline_inputbox.y,
        MMI_multiline_inputbox.x + MMI_multiline_inputbox.width - 2,
        MMI_multiline_inputbox.y + MMI_multiline_inputbox.height - 1);
#else   /* __MMI_MAINLCD_320X480__ */
    gdi_draw_solid_rect(
        MMI_multiline_inputbox.x + 2,
        MMI_multiline_inputbox.y,
        MMI_multiline_inputbox.x + MMI_multiline_inputbox.width - 2,
        MMI_multiline_inputbox.y + MMI_multiline_inputbox.height - 1,
        GDI_COLOR_TRANSPARENT);
#endif  /* __MMI_MAINLCD_320X480__*/
#else /* __GDI_MEMORY_PROFILE_2__ */
#ifdef __MMI_MAINLCD_240X320__
    gui_fill_rectangle(
        MMI_multiline_inputbox.x + 2,
        MMI_multiline_inputbox.y,
        MMI_multiline_inputbox.x + MMI_multiline_inputbox.width - 2,
        MMI_multiline_inputbox.y + MMI_multiline_inputbox.height - 1,
        wgui_pop_up_dialog_background.c);
#else /* __MMI_MAINLCD_240X320__ */ 
    gui_fill_rectangle(
        MMI_multiline_inputbox.x + 2,
        MMI_multiline_inputbox.y,
        MMI_multiline_inputbox.x + MMI_multiline_inputbox.width - 2,
        MMI_multiline_inputbox.y + MMI_multiline_inputbox.height - 1,
        UI_COLOR_WHITE);
#endif /* __MMI_MAINLCD_240X320__ */ 
#endif /* __GDI_MEMORY_PROFILE_2__ */

    l = gui_strlen(MMI_message_string);
    
    gui_create_multi_line_input_box_set_buffer(
        &MMI_multiline_inputbox,
        MMI_multiline_inputbox.x,
        MMI_multiline_inputbox.y,
        MMI_multiline_inputbox.width,
        MMI_multiline_inputbox.height,
        (UI_string_type) MMI_message_string,
        l * 2,
        (l + 1) * 2,
        0);
    MMI_multiline_inputbox.text_x = 0;
    MMI_multiline_inputbox.normal_text_color = *current_MMI_theme->popup_text_color;
    MMI_multiline_inputbox.flags |= UI_MULTI_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW
        | UI_MULTI_LINE_INPUT_BOX_CENTER_JUSTIFY
        | UI_MULTI_LINE_INPUT_BOX_DISABLE_BACKGROUND
        | UI_MULTI_LINE_INPUT_BOX_DISABLE_SCROLLBAR | UI_MULTI_LINE_INPUT_BOX_VIEW_MODE;
    MMI_multiline_inputbox.ext_flags |= GUI_MULTI_LINE_INPUT_BOX_TRUNCATE_CONTENT;
    
	show_multiline_inputbox_no_draw();
    show_multiline_inputbox();
    gdi_layer_pop_clip();
    gdi_layer_unlock_frame_buffer();
    gdi_layer_blt_previous(
        MMI_multiline_inputbox.x,
        MMI_multiline_inputbox.y,
        MMI_multiline_inputbox.x + MMI_multiline_inputbox.width - 1,
        MMI_multiline_inputbox.y + MMI_multiline_inputbox.height - 1);
}   /* end of cat66_update_progress_string */

/* 101205 irda Calvin Start */


/*****************************************************************************
 * FUNCTION
 *  ShowCategory66Screen
 * DESCRIPTION
 *  Displays the category66 screen
 * PARAMETERS
 *  title                   [IN]        Title for the screen
 *  title_icon              [IN]        Icon shown with the title
 *  left_softkey            [IN]        Left softkey label
 *  left_softkey_icon       [IN]        Icon for the left softkey
 *  right_softkey           [IN]        Right softkey label
 *  right_softkey_icon      [IN]        Icon for the right softkey
 *  message                 [IN]        Notification message
 *  message_icon            [IN]        Message icon
 *  history_buffer          [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory66Screen_int(
        U16 title,
        U16 title_icon,
        U16 left_softkey,
        U16 right_softkey,
        U8 *message,
        U16 message_icon,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;
    S32 l = 0;
	MMI_BOOL is_BW = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(__MMI_NCENTER_SUPPORT__)
    vapp_ncenter_disable_drag();
#endif

    wgui_popup_enable_clear_background();
#ifdef __MMI_MAINLCD_128X64__
	is_BW = MMI_TRUE;
#endif
    dm_reset_context();
    if (((title == 0) && (title_icon == 0)) || ((title == CAT66_AREA_NONE) && (title_icon == CAT66_AREA_NONE)) || is_BW)
    {
        ShowCategory165Screen_int(
            left_softkey,
            right_softkey,
            (UI_string_type) message,
            message_icon,
            history_buffer);
    }
    else
    {
    UI_UNUSED_PARAMETER(history_buffer);
#ifdef __MMI_POPUP_NO_SHOW_ICON__
	message_icon = 0;
#endif
    gdi_layer_lock_frame_buffer();

    wgui_title_set_menu_shortcut_number(-1);
    clear_category_screen_key_handlers();
    clear_left_softkey();
    clear_right_softkey();
    dm_data.s32flags = 0;

    change_left_softkey(left_softkey, 0);
    change_right_softkey(right_softkey, 0);
    register_default_hide_softkeys();

    if ((left_softkey == 0) && (right_softkey == 0))
    {
        dm_data.s32flags |= DM_NO_SOFTKEY;
    }
    else
    {
        dm_data.s32flags &= ~DM_NO_SOFTKEY;
        register_left_softkey_handler();
        register_right_softkey_handler();
    }
        
    dm_add_title_id(title, title_icon);
    MMI_message_string = (UI_string_type) message;
    l = gui_strlen(MMI_message_string);
    create_multiline_inputbox_set_buffer(MMI_message_string, l, l, 0);
    MMI_multiline_inputbox.text_x = 0;
	  MMI_multiline_inputbox.normal_text_color = *current_MMI_theme->popup_text_color;
    MMI_multiline_inputbox.flags |= UI_MULTI_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW
        | UI_MULTI_LINE_INPUT_BOX_CENTER_JUSTIFY
        | UI_MULTI_LINE_INPUT_BOX_DISABLE_BACKGROUND
        | UI_MULTI_LINE_INPUT_BOX_DISABLE_SCROLLBAR | UI_MULTI_LINE_INPUT_BOX_VIEW_MODE;
    MMI_multiline_inputbox.ext_flags |= GUI_MULTI_LINE_INPUT_BOX_TRUNCATE_CONTENT;
        
    if (message_icon)
    {
        dm_add_image(get_image(message_icon), NULL, NULL);
    }
#if (defined(__MMI_MAINLCD_320X480__) && !defined(__MMI_FTE_SUPPORT__))
#ifdef __MMI_SCREEN_ROTATE__
	if(!mmi_frm_is_screen_width_height_swapped())
#endif
	{
		register_hide_softkey(wgui_popup_hide_lsk, MMI_LEFT_SOFTKEY);
		register_hide_softkey(wgui_popup_hide_rsk, MMI_RIGHT_SOFTKEY);
		register_hide_softkey(wgui_popup_hide_csk, MMI_CENTER_SOFTKEY);
		wgui_popup_set_softkey_theme();
		wgui_popup_set_softkey_flag();
		disable_softkey_background();
	}
#endif
    gdi_layer_unlock_frame_buffer();

    ExitCategoryFunction = ExitCategory66Screen;
    dm_setup_category_functions(dm_redraw_category_screen, dm_get_category_history, dm_get_category_history_size);
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32CatId = MMI_CATEGORY66_ID;
#if (defined(__MMI_MAINLCD_320X480__) && !defined(__MMI_FTE_SUPPORT__))
    if((left_softkey == 0) && (right_softkey == 0))
    {
        dm_data.s32CatId = MMI_CATEGORY66_N0_SOFTKEY_ID;
		dm_data.s32flags |= DM_NO_SOFTKEY;
    }
#endif
#ifdef __MMI_SCREEN_ROTATE__
	if(mmi_frm_is_screen_width_height_swapped())
	{
		dm_data.s32flags |= DM_NO_STATUS_BAR | DM_NO_TITLE;
	}
#endif
#if (defined(__MMI_MAINLCD_320X240__) && defined(__MMI_FTE_SUPPORT__))
    {
        //dm_data.s32flags |= DM_NO_STATUS_BAR | DM_NO_TITLE;
    }
#endif
    dm_data.s32flags |= DM_CLEAR_SCREEN_BACKGROUND;
    dm_setup_data(&dm_data);
    dm_redraw_category_screen();
    }

}   /* end of ShowCategory66Screen */


/*****************************************************************************
 * FUNCTION
 *  ExitCategory66Screen
 * DESCRIPTION
 *  Exits the category66 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitCategory66Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(__MMI_NCENTER_SUPPORT__)
    vapp_ncenter_enable_drag();
#endif

    gui_hide_animations();
#if (defined(__MMI_MAINLCD_320X480__)&& !defined(__MMI_FTE_SUPPORT__))
#ifdef __MMI_SCREEN_ROTATE__
	if(!mmi_frm_is_screen_width_height_swapped())
#endif
	{
		wgui_popup_reset_softkey_flag();
		wgui_popup_reset_softkey_theme();
		enable_softkey_background();
	}
#endif
#ifdef __MMI_FTE_SUPPORT__
    {
        if(wgui_popup_is_enable_clear_background())
        {
            GDI_HANDLE base_layer;
            gdi_layer_get_base_handle(&base_layer);
            if(base_layer != GDI_NULL_HANDLE)
            {
                gdi_layer_push_and_set_active(base_layer);
                //gdi_layer_clear(GDI_COLOR_TRANSPARENT);
#if (defined(__MMI_MAINLCD_320X240__) && defined(__MMI_FTE_SUPPORT__))
                gdi_draw_solid_rect(0, 0, UI_device_width - 1, UI_device_height - MMI_button_bar_height - 1, GDI_COLOR_TRANSPARENT);
#else
                gdi_draw_solid_rect(0, MMI_content_y, UI_device_width - 1, UI_device_height - MMI_button_bar_height - 1, GDI_COLOR_TRANSPARENT);
#endif
                gdi_layer_pop_and_restore_active();
            }
    }
        else
        {
             wgui_popup_enable_clear_background();
        }
    }
#endif
}   /* end of ExitCategory66Screen */

#ifdef __ATV_SMS_SUPPORT__
#if (!defined(__MMI_VIRTUAL_KEYBOARD__) && defined(__MMI_MAINLCD_320X240__)) || \
	(!defined(__MMI_FTE_SUPPORT__) && defined(__MMI_MAINLCD_240X320__))
	#define __MMI_CAT9009_HIDE_ICON__
#endif
static void wgui_cat9009_draw_controlled_area(dm_coordinates *coordinate)
{
	return;
	gdi_layer_lock_frame_buffer();
    gdi_layer_push_clip();
    gdi_layer_set_clip(
        coordinate->s16X,
        coordinate->s16Y,
        coordinate->s16X + coordinate->s16Width,
        coordinate->s16Y + coordinate->s16Height);
	gdi_draw_solid_rect(
			coordinate->s16X, 
			coordinate->s16Y,
			coordinate->s16X + coordinate->s16Width,
			coordinate->s16Y + coordinate->s16Height,
			GDI_COLOR_WHITE);
	gdi_layer_pop_clip();
	gdi_layer_unlock_frame_buffer();
}
static void wgui_cat9009_exit(void)
{
	gui_hide_animations();
}
void wgui_cat9009_show(
        UI_string_type left_softkey,
        PU8 left_softkey_icon,
        UI_string_type right_softkey,
        PU8 right_softkey_icon,
        UI_string_type message,
        U16 message_icon,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;
	show_video_func show_video;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	dm_data.s32flags = 0;
    show_video = wgui_cat_matv_get_show_video_func();
    if (show_video != NULL)
    {
        show_video(
            wgui_cat_matv_get_video_layer_handle(), 
            GDI_LAYER_ENABLE_LAYER_0 | GDI_LAYER_ENABLE_LAYER_1 |GDI_LAYER_ENABLE_LAYER_2 | GDI_LAYER_ENABLE_LAYER_3, 
            GDI_LAYER_ENABLE_LAYER_1, 
            WGUI_CAT_MATV_VIDEO_X,
            WGUI_CAT_MATV_VIDEO_Y,
            WGUI_CAT_MATV_VIDEO_W,
            WGUI_CAT_MATV_VIDEO_H);
    }
	ShowCommonCategoryPopupScreen(message);//,history_buffer);
	if((left_softkey == 0)&&(left_softkey_icon == 0)&&(right_softkey == 0)&&(right_softkey_icon == 0))
	{
		dm_data.s32flags = DM_NO_SOFTKEY;
        dm_data.s32CatId = MMI_CAT9009_FULL_ID;
	}
	else
	{
	    dm_add_softkey(left_softkey, left_softkey_icon, right_softkey, right_softkey_icon);
        dm_data.s32CatId = MMI_CAT9009_ID;

	}
	dm_register_category_controlled_callback(wgui_cat9009_draw_controlled_area);
#if defined(__MMI_CAT9009_HIDE_ICON__)
    message_icon = 0;
#endif
    dm_add_image(get_image(message_icon), NULL, NULL);

    ExitCategoryFunction = wgui_cat9009_exit;
    RedrawCategoryFunction = dm_redraw_category_screen;
    GetCategoryHistory = dummy_get_history;
    GetCategoryHistorySize = dummy_get_history_size;
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32flags |= DM_CLEAR_SCREEN_BACKGROUND;
    dm_setup_data(&dm_data);
    dm_redraw_category_screen();
}
#endif
#ifdef __OP01__
static wgui_cat3010_op01_state_callback_func_type g_cat3010_state_callback_func;
static MMI_BOOL g_cat3010_is_checked;
/*****************************************************************************
 * FUNCTION
 *  wgui_cat3010_draw_controlled_area
 * DESCRIPTION
 *  Draw icon and string
 * PARAMETERS
 *  coordinate          [IN]   
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat3010_draw_controlled_area(dm_coordinates *coordinate)
{
	/*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	S32 image_width;
    S32 image_height;
    U16 img_id;
    S32 x, y;
	S32 img_x, img_y;
    gdi_handle image_handle;
	S32 sw, sh;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	gdi_layer_lock_frame_buffer();
    gdi_layer_push_clip();
    gdi_layer_set_clip(
        coordinate->s16X,
        coordinate->s16Y,
        coordinate->s16X + coordinate->s16Width,
        coordinate->s16Y + coordinate->s16Height);
	x = coordinate->s16X;
	y = coordinate->s16Y;
    move_multiline_inputbox(x, y);
    resize_multiline_inputbox(coordinate->s16Width, coordinate->s16Height - MMI_MENUITEM_HEIGHT - 1);
    show_multiline_inputbox();

	y = y + coordinate->s16Height - MMI_MENUITEM_HEIGHT;
	gdi_image_get_dimension_id(CHECKBOX_ON_IMAGE_ID, &image_width, &image_height);
	if(g_cat3010_is_checked)
		img_id = CHECKBOX_ON_IMAGE_ID;
	else
		img_id = CHECKBOX_OFF_IMAGE_ID;
	img_x = x;
	img_y = y + (MMI_MENUITEM_HEIGHT - image_height)/2;
	gdi_image_draw_animation_id(img_x, img_y, img_id, &(image_handle));

	x = img_x + image_width + 2;
	Get_StringWidthHeight((U8*)MMI_message_string2, &sw, &sh);
	y = y + (MMI_MENUITEM_HEIGHT - sh)/2;

	gui_move_text_cursor(x,y);
	gui_print_text(MMI_message_string2);
    gdi_layer_pop_clip();
	gdi_layer_unlock_frame_buffer();
}
#ifdef __MMI_TOUCH_SCREEN__
static MMI_BOOL wgui_cat3010_pen_hdlr(mmi_pen_point_struct point)
{
	S32 x1, y1;
	S32 h;
	S32 iw, ih;
	U16 img_id;
	gdi_handle image_handle;

#ifdef __MMI_FTE_SUPPORT__
	x1 = WGUI_POPUP_FTE_AREA_X;
	y1 = MMI_POP_UP_DIALOG_Y + WGUI_POPUP_FTE_AREA_TOP_SPACE + WGUI_CAT3010_POPUP_Y_SHIFT;
	h = MMI_POP_UP_DIALOG_HEIGHT - WGUI_POPUP_FTE_AREA_TOP_SPACE - WGUI_POPUP_FTE_AREA_BOTTOM_SPACE - WGUI_CAT3010_POPUP_Y_SHIFT;
#else
	x1 = MMI_POP_UP_DIALOG_X + UI_POPUP_BORDER_SIZE;
	y1 = MMI_POP_UP_DIALOG_Y + UI_POPUP_BORDER_SIZE;
	h = MMI_POP_UP_DIALOG_HEIGHT - UI_POPUP_BORDER_SIZE*2;
#endif
	y1 = y1 + h - MMI_MENUITEM_HEIGHT;
	gdi_image_get_dimension_id(CHECKBOX_ON_IMAGE_ID, &iw, &ih);
	y1 = y1 + (MMI_MENUITEM_HEIGHT - ih)/2;

	if((point.x >= x1) && (point.x < x1+iw) && (point.y >= y1) && (point.y < y1+ih))
	{
		GDI_HANDLE handle1;

		handle1 = dm_get_layer_handle(1);
		if(g_cat3010_is_checked)
		{
			img_id = CHECKBOX_OFF_IMAGE_ID;
			g_cat3010_is_checked = MMI_FALSE;
		}
		else
		{
			img_id = CHECKBOX_ON_IMAGE_ID;
			g_cat3010_is_checked = MMI_TRUE;
		}
		if(g_cat3010_state_callback_func)
			g_cat3010_state_callback_func(g_cat3010_is_checked);
		gdi_layer_push_and_set_active(handle1);
		gdi_image_draw_animation_id(x1, y1, img_id, &(image_handle));
		gdi_layer_pop_and_restore_active();
		gdi_layer_blt_previous(x1, y1, x1+iw, y1+ih);
		return MMI_TRUE;
	}
	return MMI_FALSE;

}
#endif
/*****************************************************************************
 * FUNCTION
 *  wgui_cat3010_enter_key_handler
 * DESCRIPTION
 *  Enter key handler, to toggle checkbox state
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat3010_enter_key_handler(void)
{
	S32 x1, y1;
	S32 h;
	S32 iw, ih;
	U16 img_id;
	gdi_handle image_handle;
	GDI_HANDLE handle1;

#ifdef __MMI_FTE_SUPPORT__
	x1 = WGUI_POPUP_FTE_AREA_X;
	y1 = MMI_POP_UP_DIALOG_Y + WGUI_POPUP_FTE_AREA_TOP_SPACE + WGUI_CAT3010_POPUP_Y_SHIFT;
	h = MMI_POP_UP_DIALOG_HEIGHT - WGUI_POPUP_FTE_AREA_TOP_SPACE - WGUI_POPUP_FTE_AREA_BOTTOM_SPACE - WGUI_CAT3010_POPUP_Y_SHIFT;
#else
	x1 = MMI_POP_UP_DIALOG_X + UI_POPUP_BORDER_SIZE;
	y1 = MMI_POP_UP_DIALOG_Y + UI_POPUP_BORDER_SIZE;
	h = MMI_POP_UP_DIALOG_HEIGHT - UI_POPUP_BORDER_SIZE*2;
#endif
	y1 = y1 + h - MMI_MENUITEM_HEIGHT;
	gdi_image_get_dimension_id(CHECKBOX_ON_IMAGE_ID, &iw, &ih);
	y1 = y1 + (MMI_MENUITEM_HEIGHT - ih)/2;

	handle1 = dm_get_layer_handle(1);
	if(g_cat3010_is_checked)
	{
		img_id = CHECKBOX_OFF_IMAGE_ID;
		g_cat3010_is_checked = MMI_FALSE;
	}
	else
	{
		img_id = CHECKBOX_ON_IMAGE_ID;
		g_cat3010_is_checked = MMI_TRUE;
	}
	if(g_cat3010_state_callback_func)
		g_cat3010_state_callback_func(g_cat3010_is_checked);
	gdi_layer_push_and_set_active(handle1);
	gdi_image_draw_animation_id(x1, y1, img_id, &(image_handle));
	gdi_layer_pop_and_restore_active();
	gdi_layer_blt_previous(x1, y1, x1+iw, y1+ih);
}
/*****************************************************************************
 * FUNCTION
 *  wgui_cat3010_exit
 * DESCRIPTION
 *  Exits the category3010 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat3010_exit(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_hide_animations();
	g_cat3010_state_callback_func = NULL;
}   /* end of ExitCategory66Screen */


/*****************************************************************************
 * FUNCTION
 *  wgui_cat3010_show
 * DESCRIPTION
 *  Displays the category3010 screen
 * PARAMETERS
 *  left_softkey            [IN]        Left softkey label
 *  left_softkey_icon       [IN]        Icon for the left softkey
 *  right_softkey           [IN]        Right softkey label
 *  right_softkey_icon      [IN]        Icon for the right softkey
 *  message1                [IN]        Notification message
 *  message2				[IN]        Check box message
 *  state_callback			[IN]        Callbck when state changed
 *  isChecked				[IN]		check box state
 *  history_buffer          [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat3010_op01_show(
        UI_string_type left_softkey,
        PU8 left_softkey_icon,
        UI_string_type right_softkey,
        PU8 right_softkey_icon,
        UI_string_type message1,
		UI_string_type message2,
		wgui_cat3010_op01_state_callback_func_type state_callback,
		MMI_BOOL isChecked,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;
    S32 l = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* register the custom SSE effect handler */
    gdi_layer_lock_frame_buffer();
    dm_data.s32flags = 0;
	dm_add_softkey(left_softkey, left_softkey_icon, right_softkey, right_softkey_icon);

	g_cat3010_is_checked = isChecked;
	g_cat3010_state_callback_func = state_callback;
    MMI_message_string = message1;
    l = gui_strlen(MMI_message_string);
    create_multiline_inputbox_set_buffer(MMI_message_string, l, l, 0);
	MMI_multiline_inputbox.normal_text_color = *current_MMI_theme->popup_text_color;
    MMI_multiline_inputbox.flags |= UI_MULTI_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW
        | UI_MULTI_LINE_INPUT_BOX_CENTER_JUSTIFY
        | UI_MULTI_LINE_INPUT_BOX_DISABLE_BACKGROUND
        | UI_MULTI_LINE_INPUT_BOX_DISABLE_SCROLLBAR | UI_MULTI_LINE_INPUT_BOX_VIEW_MODE;
    MMI_multiline_inputbox.ext_flags |= GUI_MULTI_LINE_INPUT_BOX_TRUNCATE_CONTENT;
	MMI_multiline_inputbox.text_x = 0;

	MMI_message_string2 = message2;
#ifdef __MMI_TOUCH_SCREEN__
	wgui_register_category_screen_control_area_pen_handlers(wgui_cat3010_pen_hdlr, MMI_PEN_EVENT_DOWN);
#endif
    SetKeyHandler(wgui_cat3010_enter_key_handler, KEY_ENTER, KEY_EVENT_UP);
	gdi_layer_unlock_frame_buffer();

    ExitCategoryFunction = wgui_cat3010_exit;
    dm_setup_category_functions(dm_redraw_category_screen, dm_get_category_history, dm_get_category_history_size);
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32CatId = MMI_CAT3010_OP01_ID;
    dm_data.s32flags = DM_SET_NEW_LAYER_ACTIVE;
	dm_register_category_controlled_callback(wgui_cat3010_draw_controlled_area);
    dm_setup_data(&dm_data);
    dm_redraw_category_screen();
}   /* end of ShowCategory366Screen */
#endif /* __OP01__ */
