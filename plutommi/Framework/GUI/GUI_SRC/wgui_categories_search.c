/*******************************************************************************
*  Modification Notice:
*  --------------------------
*  This software is modified by MediaTek Inc. and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*******************************************************************************/

 /*******************************************************************************
 * Filename:
 * ---------
 *   wgui_categories_search.c
 *
 * Project:
 * --------
 *   Maui
 *
 * Description:
 * ------------
 *  
 *
 * Author:
 * -------
 *  
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/
 
#include "MMI_features.h"
//#include "mmi_frm_gprot.h"
//#include "WguiCategoryGprot.h"
//#include "CommonScreens.h"
#include "Wgui_fixed_menuitems.h"
#include "Wgui_dynamic_menus.h"
#include "wgui_asyncdynamic_menus.h"
#include "wgui_asyncdynamic_menuitems.h"
#include "gui_dynamic_menus.h"
#include "gui_asyncdynamic_menus.h"
#include "wgui_virtual_keyboard.h"

//RHR
    #include "gui_data_types.h"
    #include "MMIDataType.h"
    #include "kal_general_types.h"
    #include "wgui_categories_util.h"
    #include "wgui.h"
    #include "wgui_inputs.h"
    #include "ImeGprot.h"
    #include "mmi_frm_input_gprot.h"
    #include "gui_fixed_menus.h"
    #include "wgui_fixed_menus.h"
    #include "wgui_include.h"
    #include "gui_scrollbars.h"
    #include "wgui_touch_screen.h"
    #include "gui_switch.h"
    #include "wgui_categories_search.h"
    #include "gui.h"
    #include "gdi_include.h"
    #include "gui_inputs.h"
    #include "gui_typedef.h"
    #include "gui_fixed_menuitems.h"
    #include "kal_public_api.h"
    #include "DebugInitDef_Int.h"
    #include "wgui_dynamic_menuitems.h"
    #include "wgui_categories_enum.h"
    #include "GlobalConstants.h"
    #include "wgui_categories_inputs.h"
    #include "wgui_draw_manager.h"
    #include "lcd_sw_inc.h"
    #include "Gui_Setting.h"
    #include "mmi_frm_events_gprot.h"
    #include "CustThemesRes.h"
    #include "gui_theme_struct.h"
    #include "gui_themes.h"
    #include "gui_windows.h"
    #include "gui_title.h"
    //#include "operator_gui.h"
    #include "mmi_frm_history_gprot.h"
    #include "wgui_categories_CM.h"
    #include "mmi_rp_app_uiframework_def.h"
    #include "gdi_image_alpha_bmp_v2.h"

/***************************************************************************** 
* Local Function
*****************************************************************************/
static void wgui_cat199_draw_input_method(void);
extern void ShowListCategoryScreen_ext(
        UI_string_type title,
        PU8 title_icon,
        UI_string_type left_softkey,
        UI_string_type right_softkey);

extern BOOL dynamic_item_text_align_left;

#ifdef __MMI_PHONEBOOK_LIST_THUMBNAIL__
//extern module_type stack_int_get_active_module_id( void );
#endif /* __MMI_PHONEBOOK_LIST_THUMBNAIL__ */


#ifdef __MMI_CAT103_SUPPORT__
static MMI_BOOL wgui_cat103_is_menu_active(void);

S32 (*g_wgui_cat103_search_function) (UI_buffer_type) = NULL;
static MMI_BOOL g_wgui_cat103_editor_active = MMI_FALSE;
static MMI_BOOL g_wgui_cat103_from_history = MMI_FALSE;
static void (*g_wgui_cat103_RSK_function) (void) = NULL;
void (*g_wgui_cat103_resize_and_draw_func) (S32) = NULL;
void (*g_wgui_cat103_highlight_handler) (S32) = NULL;

extern UI_string_type wgui_singleline_inputbox_RSK_label_string;
extern PU8 wgui_singleline_inputbox_RSK_label_icon;


/*****************************************************************************
 * FUNCTION
 *  wgui_cat103_register_highlight_handler
 * DESCRIPTION
 *  register category103 highlight handler
 * PARAMETERS
 *  f      [IN]   highlight handler function
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat103_register_highlight_handler(void (*f) (S32))
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_wgui_cat103_highlight_handler = f;
    RegisterHighlightHandler(f);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat103_set_right_softkey_function
 * DESCRIPTION
 *  set right softkey function of category103
 * PARAMETERS
 *  f      [IN]   RSK function
 *  k      [IN]   key event type
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat103_set_right_softkey_function(void (*f) (void), MMI_key_event_type k)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(k);
    wgui_singleline_inputbox_RSK_function = f;
    g_wgui_cat103_RSK_function = f;
}


#ifdef __MMI_TOUCH_SCREEN__
/*****************************************************************************
 * FUNCTION
 *  wgui_cat103_virtual_keypad_callback
 * DESCRIPTION
 *  virtual keypad callback
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat103_virtual_keypad_callback(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_imc_redraw_screen_by_state();    
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat103_controlled_area_pen_down_handler
 * DESCRIPTION
 *  pen down handler
 * PARAMETERS
 *  point            [IN]        pen postion
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL wgui_cat103_controlled_area_pen_down_handler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    BOOL ret = MMI_FALSE;
#ifndef GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN
    gui_list_pen_enum menu_event;
#endif
    S32 list_h;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_fixed_list_menu.pen_redraw_menu_function = wgui_dynamic_list_show_icontext_menu;
    gui_vertical_scrollbar_set_pen_self_scroll(&MMI_fixed_list_menu.vbar, MMI_TRUE);
    gui_fixed_list_menu_set_pen_scroll_delay(&MMI_fixed_list_menu, GUI_DYNAMIC_LIST_PEN_SCROLL_DELAY);

    if ((MMI_fixed_list_menu.n_items * MMI_MENUITEM_HEIGHT) > MMI_fixed_list_menu.height)
    {
        list_h = MMI_fixed_list_menu.height;
    }
    else
    {
        list_h = MMI_fixed_list_menu.n_items * MMI_MENUITEM_HEIGHT;
    }
    
#if defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN)
    if (PEN_CHECK_BOUND(
            point.x, 
            point.y, 
            MMI_fixed_list_menu.x, 
            MMI_fixed_list_menu.y, 
            MMI_fixed_list_menu.width, 
            list_h))
    {
        if (wgui_cat103_is_editor_active() == MMI_TRUE)
        {
            gui_lock_double_buffer();
            wgui_cat103_set_menu_focus_state(MMI_TRUE);
            dynamic_list_highlight_handler(MMI_fixed_list_menu.highlighted_item);
            wgui_cat103_set_editor_focus_state(MMI_FALSE);
            redraw_singleline_inputbox();
            gui_unlock_double_buffer();
        }
    }
    return MMI_FALSE;
#else
    ClearHighlightHandler();
    ret = gui_dynamic_list_menu_translate_pen_event(
            &MMI_fixed_list_menu,
            MMI_PEN_EVENT_DOWN,
            point.x,
            point.y,
            &menu_event);
    RegisterHighlightHandler(g_wgui_cat103_highlight_handler);
    if (ret)
    {
        if (menu_event == GUI_LIST_PEN_HIGHLIGHT_CHANGED 
            || menu_event == GUI_LIST_PEN_NEED_REDRAW 
            || wgui_cat103_is_editor_active() == MMI_TRUE)
        {
            wgui_cat103_set_menu_focus_state(MMI_TRUE);
            dynamic_list_highlight_handler(MMI_fixed_list_menu.highlighted_item);
            redraw_dynamic_list();
            wgui_cat103_set_editor_focus_state(MMI_FALSE);
            redraw_singleline_inputbox();
        }
        return MMI_TRUE;
    }
    else
    {
        return MMI_FALSE;
    }    
#endif /* GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN */
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat103_controlled_area_pen_up_handler
 * DESCRIPTION
 *  pen up handler
 * PARAMETERS
 *  point            [IN]        pen postion
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL wgui_cat103_controlled_area_pen_up_handler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL ret = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_general_pen_dynamic_list_menu_hdlr(point, MMI_PEN_EVENT_UP);
    return ret;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat103_controlled_area_pen_move_handler
 * DESCRIPTION
 *  pen move handler
 * PARAMETERS
 *  point            [IN]        pen postion
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL wgui_cat103_controlled_area_pen_move_handler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL ret = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_general_pen_dynamic_list_menu_hdlr(point, MMI_PEN_EVENT_MOVE);
    return ret;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat103_controlled_area_pen_long_tap_handler
 * DESCRIPTION
 *  pen long tap handler
 * PARAMETERS
 *  point            [IN]        pen postion
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL wgui_cat103_controlled_area_pen_long_tap_handler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL ret = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_general_pen_dynamic_list_menu_hdlr(point, MMI_PEN_EVENT_LONG_TAP);
    return ret;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat203_controlled_area_pen_repeat_handler
 * DESCRIPTION
 *  pen repeat handler
 * PARAMETERS
 *  point            [IN]        pen postion
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/ 
MMI_BOOL wgui_cat103_controlled_area_pen_repeat_handler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL ret = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_general_pen_dynamic_list_menu_hdlr(point, MMI_PEN_EVENT_REPEAT);
    return ret;
}
#endif /* __MMI_TOUCH_SCREEN__ */


/*****************************************************************************
 * FUNCTION
 *  wgui_cat103_resize_and_draw
 * DESCRIPTION
 *  resize category103 component
 * PARAMETERS
 *  ime_h      [IN]   reserve height for ime
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat103_resize_and_draw(S32 ime_h)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 menu_h = 0, singleline_y = 0;
    S32 old_highlight_item;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* calculate menu height */
#ifdef MMI_SHOW_STATUS_ICON_IN_TITLE
    menu_h = UI_device_height - MMI_TITLE_HEIGHT - wgui_inputbox_information_bar_height - MMI_SINGLELINE_INPUTBOX_HEIGHT - ime_h - MMI_BUTTON_BAR_HEIGHT - 1;
#else
    menu_h = UI_device_height - MMI_STATUS_BAR_HEIGHT - MMI_TITLE_HEIGHT - wgui_inputbox_information_bar_height - MMI_SINGLELINE_INPUTBOX_HEIGHT - ime_h - MMI_BUTTON_BAR_HEIGHT - 1;
#endif /* MMI_SHOW_STATUS_ICON_IN_TITLE */

    //if (menu_h != MMI_fixed_list_menu.height)  /* resize */
    {
        gdi_layer_lock_frame_buffer();

        ClearHighlightHandler();  /* avoid execute highlight handler when redraw list */

        /* set dynamic list position and resize it */     
        old_highlight_item = MMI_fixed_list_menu.highlighted_item;
        wgui_dynamic_list_move_icontext_menu(0, CAT103_DYNAMIC_LIST_Y);
        wgui_dynamic_list_resize_icontext_menu(UI_device_width, menu_h);
        dynamic_list_goto_item_no_redraw(MMI_fixed_list_menu.highlighted_item);
        if (old_highlight_item == -1)
        {
            MMI_fixed_list_menu.highlighted_item = old_highlight_item;
        }
        
        /* set singleline inputbox position */
        singleline_y = CAT103_DYNAMIC_LIST_Y + menu_h + wgui_inputbox_information_bar_height;
        wgui_inputs_sl_move(MMI_singleline_inputbox.x, singleline_y);
        
        /* set information bar position */
        wgui_inputs_setup_input_information( 
                MMI_singleline_inputbox.x,
                MMI_singleline_inputbox.y - wgui_inputbox_information_bar_height,
                MMI_singleline_inputbox.width,
                wgui_inputbox_information_bar_height);
        
        /* clear background and show multiline inputbox, singleline inputbox, and information bar */  
        gdi_draw_solid_rect(
                0,
                CAT103_DYNAMIC_LIST_Y,
                UI_device_width - 1,
                UI_device_height - MMI_BUTTON_BAR_HEIGHT - ime_h - 1,
                GDI_COLOR_TRANSPARENT);        
        
        redraw_dynamic_list();
        //wgui_inputs_sl_redraw();
#ifndef __MMI_FTE_SUPPORT__
        wgui_inputs_sl_redraw_information_bar();
#endif
        RegisterHighlightHandler(g_wgui_cat103_highlight_handler);

        gdi_layer_unlock_frame_buffer();
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat103_is_editor_active
 * DESCRIPTION
 *  get editor state
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL wgui_cat103_is_editor_active(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    return g_wgui_cat103_editor_active;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat103_is_menu_active
 * DESCRIPTION
 *  get menu state
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
static MMI_BOOL wgui_cat103_is_menu_active(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL result = MMI_TRUE;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    if (MMI_fixed_icontext_menuitem.flags & UI_MENUITEM_DISABLE_HIGHLIGHT)
    {
        result = MMI_FALSE;        
	}
    return result;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat103_set_editor_focus_state
 * DESCRIPTION
 *  set editor state
 * PARAMETERS
 *  active    [IN]    editor state
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat103_set_editor_focus_state(MMI_BOOL active)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    g_wgui_cat103_editor_active = active;
    /*
    if (active == MMI_TRUE)
    {
        MMI_singleline_inputbox.flags &= ~UI_SINGLE_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW;
    }
    else
    {
        MMI_singleline_inputbox.flags |= UI_SINGLE_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW;
        StopTimer(BLINKING_CURSOR);
    }
    */
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat103_set_menu_focus_state
 * DESCRIPTION
 *  set menu state
 * PARAMETERS
 *  active    [IN]    menu state
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat103_set_menu_focus_state(MMI_BOOL active)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    if (active == MMI_TRUE)
    {
        S32 old_flags = MMI_fixed_icontext_menuitem.flags;

        MMI_fixed_icontext_menuitem.flags &= ~UI_MENUITEM_DISABLE_HIGHLIGHT;
        MMI_fixed_icontext_menuitem.ext_flags &= ~UI_MENUITEM_EXT_DISABLED_SCROLL;
        if (old_flags != MMI_fixed_icontext_menuitem.flags)
        {
            MMI_fixed_list_menu.highlighted_item = -1;
        }
    }
    else
    {
        MMI_fixed_icontext_menuitem.flags |= UI_MENUITEM_DISABLE_HIGHLIGHT;
        MMI_fixed_icontext_menuitem.ext_flags |= UI_MENUITEM_EXT_DISABLED_SCROLL;
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat103_refresh_search_list
 * DESCRIPTION
 *  refresh search list in category103
 * PARAMETERS
 *  input_number    [IN]    editor content
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat103_refresh_search_list(U8 * input_number)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 no_entries = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(g_wgui_cat103_search_function != NULL);
    no_entries = g_wgui_cat103_search_function(input_number);
    init_dynamic_item_buffer(no_entries, dynamic_item_buffer.load_func, dynamic_item_buffer.hint_func, UI_dummy_function);
    MMI_fixed_list_menu.n_items = no_entries;
    dynamic_list_goto_item_no_redraw(0);
    wgui_text_menuitem_reset_scrolling(); /* reset menuitem not to scroll */
    redraw_dynamic_list();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat103_singleline_inputbox_input_callback
 * DESCRIPTION
 *  editor input callback function
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat103_singleline_inputbox_input_callback(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* set menu */
    wgui_cat103_set_menu_focus_state(MMI_FALSE);
    wgui_cat103_set_editor_focus_state(MMI_TRUE); // g_wgui_cat103_editor_active = MMI_TRUE;
    wgui_cat103_refresh_search_list(MMI_singleline_inputbox.text);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat103_refresh_input_area
 * DESCRIPTION
 *  refresh editor content
 * PARAMETERS
 *  input_buffer               [IN]   input buffer
 *  input_buffer_max_length    [IN]   input buffer max length
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat103_refresh_input_area(U8* input_buffer, S32 input_buffer_max_length, U32 input_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    if (g_wgui_cat103_from_history == MMI_FALSE)
    {
        gdi_layer_lock_frame_buffer();

        mmi_imm_set_default_input_mode(mmi_imm_get_curr_input_mode());
    #if defined(__MMI_IMC_CAPITAL_SWITCH__)
        mmi_imm_set_writing_language_from_history(mmi_imm_get_current_writing_language());
    #endif  /* defined(__MMI_IMC_CAPITAL_SWITCH__) */
        mmi_imc_disconnect();
        wgui_inputs_sl_disable_up_down_key_register(MMI_TRUE);
#ifdef __MMI_FTE_SUPPORT__
        wgui_inputs_sl_setup(
                MMI_singleline_inputbox.x,
                MMI_singleline_inputbox.y,
                MMI_singleline_inputbox.width,
                MMI_singleline_inputbox.height,
                input_buffer,
                input_buffer_max_length,
                MMI_CATEGORY103_ID,
                wgui_singleline_inputbox_RSK_label_string,
                wgui_singleline_inputbox_RSK_label_icon,
                input_type,
                NULL,
                0);
#else
        wgui_inputs_sl_setup(
                MMI_singleline_inputbox.x,
                MMI_singleline_inputbox.y,
                MMI_singleline_inputbox.width,
                MMI_singleline_inputbox.height,
                input_buffer,
                input_buffer_max_length,
                MMI_CATEGORY103_ID,
                wgui_singleline_inputbox_RSK_label_string,
                wgui_singleline_inputbox_RSK_label_icon,
                input_type,
                NULL,
                1);
#endif
    #if defined(__MMI_TOUCH_SCREEN__)
        mmi_imc_disable_handwriting();
    #endif /* defined(__MMI_TOUCH_SCREEN__) */
    
        /*
        if (wgui_cat103_is_editor_active() == MMI_TRUE)
        {
            MMI_singleline_inputbox.flags &= ~UI_SINGLE_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW;
        }
        else
        {
            MMI_singleline_inputbox.flags |= UI_SINGLE_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW;
            StopTimer(BLINKING_CURSOR);
        }
        */

        wgui_inputs_setup_input_information(
                0, MMI_singleline_inputbox.y - wgui_inputbox_information_bar_height, 
                UI_device_width, wgui_inputbox_information_bar_height);
    
        MMI_singleline_inputbox.change_callback = wgui_cat103_singleline_inputbox_input_callback;

        wgui_singleline_inputbox_RSK_function = g_wgui_cat103_RSK_function;
#ifndef __MMI_FTE_SUPPORT__
        wgui_inputs_sl_redraw_information_bar();
#endif
        mmi_imc_redraw_screen_by_state();
        //wgui_inputs_sl_redraw();

        gdi_layer_unlock_frame_buffer();
    }
    else
    {
        g_wgui_cat103_from_history = MMI_FALSE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat103_menu_pre_key_handler
 * DESCRIPTION
 *  menu pre-key handler
 * PARAMETERS
 *  key_code    [IN]   key code
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL wgui_cat103_menu_pre_key_handler(MMI_key_code_type key_code)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL result = MMI_FALSE; /* when result = MMI_TRUE, menu will not process key event */

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (key_code)
    {
        /* menu key */    
        case KEY_UP_ARROW:
        case KEY_VOL_UP:
            if (wgui_cat103_is_editor_active() == MMI_TRUE)
            {   
                /* set menu inactive */
                wgui_cat103_set_menu_focus_state(MMI_TRUE);
                dynamic_list_goto_item_no_redraw(MMI_fixed_list_menu.n_items - 1);
                redraw_dynamic_list();

                wgui_cat103_set_editor_focus_state(MMI_FALSE);
                wgui_inputs_sl_redraw();
                
                result = MMI_TRUE;
            }            
            else if (wgui_cat103_is_menu_active() == MMI_TRUE)
            {
                if (MMI_fixed_list_menu.highlighted_item == 0) /* highilight on the first item */
                {
                    /* editor do what? */
                    g_wgui_cat103_highlight_handler(CAT103_INVALID_HIGHLIGHT);
                    wgui_cat103_set_editor_focus_state(MMI_TRUE);
                    wgui_inputs_sl_redraw();
                    
                    /* set menu inactive */
                    wgui_cat103_set_menu_focus_state(MMI_FALSE);
                    dynamic_list_goto_item_no_redraw(0);
                    wgui_text_menuitem_reset_scrolling(); /* reset menuitem not to scroll */
                    redraw_dynamic_list();

                    result = MMI_TRUE;
                }
            }
            break;
        case KEY_DOWN_ARROW:
        case KEY_VOL_DOWN: 
            if (wgui_cat103_is_editor_active() == MMI_TRUE)
            {
                /* set menu active*/
                wgui_cat103_set_menu_focus_state(MMI_TRUE);
                dynamic_list_goto_item_no_redraw(0);
                redraw_dynamic_list();

                /* set editor inactive */
                wgui_cat103_set_editor_focus_state(MMI_FALSE);
                wgui_inputs_sl_redraw();
                
                result = MMI_TRUE;
            }
            else if (wgui_cat103_is_menu_active() == MMI_TRUE)/* highlight on menu */
            {
                if (MMI_fixed_list_menu.highlighted_item == MMI_fixed_list_menu.n_items - 1)
                {
                    /* set editor active */
                    g_wgui_cat103_highlight_handler(CAT103_INVALID_HIGHLIGHT);
                    wgui_cat103_set_editor_focus_state(MMI_TRUE);
                    wgui_inputs_sl_redraw();

                    /* set menu inactive */
                    wgui_cat103_set_menu_focus_state(MMI_FALSE);                    
                    dynamic_list_goto_item_no_redraw(MMI_fixed_list_menu.n_items - 1);
                    wgui_text_menuitem_reset_scrolling(); /* reset menuitem not to scroll */
                    redraw_dynamic_list();

                    result = MMI_TRUE;
                }
            }
            break;
        default:
            break; 
    }
    return result;
}


/*****************************************************************************
 * FUNCTION
 *  GetCategory103HistorySize
 * DESCRIPTION
 *  get category103 history size
 * PARAMETERS
 *  void
 * RETURNS
 *  S32
 *****************************************************************************/
S32 GetCategory103HistorySize(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return (((sizeof(list_menu_category_history) + 3) / 4) * 4 + sizeof(singleline_inputbox_category_history));
}


/*****************************************************************************
 * FUNCTION
 *  GetCategory103History
 * DESCRIPTION
 *  get category103 history
 * PARAMETERS
 *  history_buffer    [IN]   history buffer
 * RETURNS
 *  U8*
 *****************************************************************************/
U8* GetCategory103History(U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 s = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    get_list_menu_category_history(MMI_CATEGORY103_ID, history_buffer);
    s = sizeof(list_menu_category_history);
    s = (s + 3) / 4;
    s *= 4;
    wgui_inputs_sl_get_category_history(MMI_CATEGORY103_ID, (U8*) (history_buffer + s));
    return (history_buffer);
}


/*****************************************************************************
 * FUNCTION
 *  ExitCategory103Screen
 * DESCRIPTION
 *  exit category103 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitCategory103Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/  
    /* enable loop menu */
    MMI_fixed_list_menu.flags |= UI_LIST_MENU_LOOP;

    ClearHighlightHandler();
    reset_fixed_list();
    reset_dynamic_list();
    reset_pop_up_descriptions();
    wgui_inputs_sl_close();
#ifdef __MMI_UI_HINTS_IN_MENUITEM__
    reset_all_force_flags_for_hints();
  #ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
    gui_unblock_list_effect();
  #endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */
#endif /* __MMI_UI_HINTS_IN_MENUITEM__ */ 

    g_wgui_cat103_search_function = NULL;     
    g_wgui_cat103_resize_and_draw_func = NULL;
    g_wgui_cat103_highlight_handler = NULL;
    g_wgui_cat103_RSK_function = NULL;
}


/*****************************************************************************
 * FUNCTION
 *  ShowCategory103Screen
 * DESCRIPTION
 *  category screen for Vodafone WAP auto-complete
 * PARAMETERS
 *  title                   [IN]        Title
 *  title_icon              [IN]        Title icon
 *  left_softkey            [IN]        Left softkey label
 *  left_softkey_icon       [IN]        Left softkey icon
 *  right_softkey           [IN]        Right softkey label
 *  right_softkey_icon      [IN]        Right softkey icon
 *  number_of_items         [IN]        Number of list items
 *  get_item_func           [IN]        Get menu item function
 *  get_hint_func           [IN]        Get menu hint funtion
 *  search_func             [IN]        Search result function
 *  input_buffer            [IN]        Buffer for input
 *  input_buffer_max_length [IN]        Max length for input
 *  input_type               [IN]        Editor input type
 *  history_buffer          [IN]        Histpry buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory103Screen_int(
         UI_string_type title,
         PU8 title_icon,
         UI_string_type left_softkey,
         UI_string_type right_softkey,
         S32 number_of_items,    
         S32 highlighted_item,
         GetItemFuncPtr get_item_func,
         GetHintFuncPtr get_hint_func,
         S32(*search_func) (UI_buffer_type),
         U8 *input_buffer,
         S32 input_buffer_max_length,
         U32 input_type,
         U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;
    S32 no_entries;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();

    /* title */
    ShowListCategoryScreen_ext(
                 title, title_icon,
                 left_softkey, 
                 right_softkey);

    /* register search function */
    if (search_func != NULL)
    {
        g_wgui_cat103_search_function = search_func;
    }    
    g_wgui_cat103_resize_and_draw_func = wgui_cat103_resize_and_draw;

    /* dynamic icontext list */
    if ((history_buffer != NULL) && wgui_cat103_is_editor_active() == MMI_FALSE)
    {
        wgui_dynamic_list_create_icontext_menu(
            number_of_items, 
            get_item_func, 
            get_hint_func, 
            WGUI_LIST_INVALID_HIGHLIGHT,
            MMI_TRUE, 
            UI_dummy_function,
            WGUI_LIST_MENU_DISABLE_SHORTCUT,
            MMI_CATEGORY103_ID,
            history_buffer);
    }
    else
    {
        wgui_dynamic_list_create_icontext_menu(
            number_of_items, 
            get_item_func, 
            get_hint_func, 
            WGUI_LIST_INVALID_HIGHLIGHT,
            MMI_TRUE, 
            UI_dummy_function,
            WGUI_LIST_MENU_DISABLE_SHORTCUT,
            MMI_CATEGORY103_ID,
            NULL);
    }
            
    if (history_buffer != NULL && wgui_cat103_is_editor_active()== MMI_TRUE)  /* from history and focus on editor */
	{
	    wgui_cat103_set_menu_focus_state(MMI_FALSE);
	}

    wgui_fixed_list_register_pre_key_handler(wgui_cat103_menu_pre_key_handler);
       
#ifdef __MMI_TOUCH_SCREEN__
    /* Because the list menu is resized according to virtual keyboard */
    MMI_fixed_list_menu.flags |= UI_LIST_MENU_ALIGN_TO_TOP;
#endif /* __MMI_TOUCH_SCREEN__ */ 
    
    /* disable loop menu */
    MMI_fixed_list_menu.flags &= ~UI_LIST_MENU_LOOP;

    //wgui_dynamic_list_resize_icontext_menu(MAIN_LCD_DEVICE_WIDTH, CAT103_DYNAMIC_LIST_H);
    //wgui_dynamic_list_move_icontext_menu(0, CAT103_DYNAMIC_LIST_Y);
    
    //resize_dynamic_icontext_menuitems_to_list_width();

    ClearHighlightHandler();  /* avoid execute highlight handler when redraw list */

    if (history_buffer == NULL) /* initial */
    {
        /* singleline inputbox */
        mmi_imc_disconnect();
        wgui_inputs_sl_disable_up_down_key_register(MMI_TRUE);
#ifdef __MMI_FTE_SUPPORT__
        wgui_inputs_sl_setup(
            0,
            CAT103_SINGLE_LINE_INPUTBOX_Y,
            MAIN_LCD_DEVICE_WIDTH,
            MMI_SINGLELINE_INPUTBOX_HEIGHT,
            input_buffer,
            input_buffer_max_length,
            MMI_CATEGORY103_ID,
            right_softkey,
            NULL,
            input_type,
            NULL,
            0);
#else
        wgui_inputs_sl_setup(
                    0,
                    CAT103_SINGLE_LINE_INPUTBOX_Y,
                    MAIN_LCD_DEVICE_WIDTH,
                    MMI_SINGLELINE_INPUTBOX_HEIGHT,
                    input_buffer,
                    input_buffer_max_length,
                    MMI_CATEGORY103_ID,
                    right_softkey,
                    NULL,
                    input_type,
                    NULL,
                    1);
#endif
        MMI_current_input_ext_type |= INPUT_TYPE_EXT_NO_SHOW_NEW_LINE_SYMBOL;
        wgui_inputs_setup_input_information(
                    0, MMI_singleline_inputbox.y - wgui_inputbox_information_bar_height, 
                    UI_device_width, wgui_inputbox_information_bar_height);
        
    #if defined(__MMI_TOUCH_SCREEN__)
        mmi_imc_disable_handwriting();
    #endif /* defined(__MMI_TOUCH_SCREEN__) */

        if (highlighted_item >= 0)  /* highlight on list */
        {
            wgui_cat103_set_menu_focus_state(MMI_TRUE);
            wgui_cat103_set_editor_focus_state(MMI_FALSE);
            MMI_fixed_list_menu.highlighted_item = highlighted_item;
            dynamic_list_goto_item_no_redraw(highlighted_item);
        }
        else  /* highlight on editor */
        {
            wgui_cat103_set_menu_focus_state(MMI_FALSE);
            wgui_cat103_set_editor_focus_state(MMI_TRUE);
        }

        if (g_wgui_cat103_search_function)
        {                
            no_entries = g_wgui_cat103_search_function((U8*) MMI_singleline_inputbox.text);
            init_dynamic_item_buffer(no_entries, dynamic_item_buffer.load_func, dynamic_item_buffer.hint_func, UI_dummy_function);
            MMI_fixed_list_menu.n_items = no_entries;
            dynamic_list_goto_item_no_redraw(0);
            MMI_fixed_list_menu.highlighted_item = highlighted_item;
        }
    }
    else
    {  
        S32 s = sizeof(list_menu_category_history);
        s = (s + 3) / 4;
        s *= 4;

        /* singleline inputbox */
        wgui_inputs_sl_disable_up_down_key_register(MMI_TRUE);
#ifdef __MMI_FTE_SUPPORT__
        wgui_inputs_sl_setup(
            0,
            CAT103_SINGLE_LINE_INPUTBOX_Y,
            MAIN_LCD_DEVICE_WIDTH,
            MMI_SINGLELINE_INPUTBOX_HEIGHT,
            input_buffer,
            input_buffer_max_length,
            MMI_CATEGORY103_ID,
            right_softkey,
            NULL,
            input_type,
            (U8*) (history_buffer + s),
            0);
#else
        wgui_inputs_sl_setup(
                    0,
                    CAT103_SINGLE_LINE_INPUTBOX_Y,
                    MAIN_LCD_DEVICE_WIDTH,
                    MMI_SINGLELINE_INPUTBOX_HEIGHT,
                    input_buffer,
                    input_buffer_max_length,
                    MMI_CATEGORY103_ID,
                    right_softkey,
                    NULL,
                    input_type,
                    (U8*) (history_buffer + s),
                    1);
#endif 
        MMI_current_input_ext_type |= INPUT_TYPE_EXT_NO_SHOW_NEW_LINE_SYMBOL;
        wgui_inputs_setup_input_information(
                    0, MMI_singleline_inputbox.y - wgui_inputbox_information_bar_height, 
                    UI_device_width, wgui_inputbox_information_bar_height);

    #if defined(__MMI_TOUCH_SCREEN__)
        mmi_imc_disable_handwriting();
    #endif /* defined(__MMI_TOUCH_SCREEN__) */

        g_wgui_cat103_from_history = MMI_TRUE;

        if (wgui_cat103_is_editor_active() == MMI_TRUE)  /* highlight on editor */
        {
            wgui_cat103_set_menu_focus_state(MMI_FALSE);
            dynamic_list_goto_item_no_redraw(0);
            if (g_wgui_cat103_search_function)
            {
                no_entries = g_wgui_cat103_search_function((U8*) MMI_singleline_inputbox.text);
                init_dynamic_item_buffer(no_entries, dynamic_item_buffer.load_func, dynamic_item_buffer.hint_func, UI_dummy_function);
                MMI_fixed_list_menu.n_items = no_entries;
                dynamic_list_goto_item_no_redraw(0);
            }
        }
        else /* highlight on menu */
        {
            wgui_cat103_set_menu_focus_state(MMI_TRUE);
            if (highlighted_item >= 0)  /* highlight on list */
			{
                MMI_fixed_list_menu.highlighted_item = highlighted_item;
                dynamic_list_goto_item_no_redraw(highlighted_item);
			}
        }
    }

    RegisterHighlightHandler(g_wgui_cat103_highlight_handler);
    /* singlelin change callback */
    MMI_singleline_inputbox.change_callback = wgui_cat103_singleline_inputbox_input_callback;
    
    gdi_layer_unlock_frame_buffer();
    
    ExitCategoryFunction = ExitCategory103Screen;
    dm_setup_category_functions(dm_redraw_category_screen, GetCategory103History, GetCategory103HistorySize);
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32CatId = MMI_CATEGORY103_ID;
    dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND | DM_SINGLE_LINE_INPUT_BOX_WITH_INFORMATION_BAR;
#ifdef __MMI_TOUCH_SCREEN__
    dm_data.s32flags |= DM_SHOW_VKPAD;
    dm_register_vkpad_callback(wgui_cat103_virtual_keypad_callback);
#endif /* __MMI_TOUCH_SCREEN__ */

    dm_setup_data(&dm_data);


#ifdef __MMI_TOUCH_SCREEN__
    wgui_register_category_screen_control_area_pen_handlers(
            wgui_cat103_controlled_area_pen_down_handler, 
            MMI_PEN_EVENT_DOWN);
    wgui_register_category_screen_control_area_pen_handlers(
            wgui_cat103_controlled_area_pen_up_handler, 
            MMI_PEN_EVENT_UP);
    wgui_register_category_screen_control_area_pen_handlers(
            wgui_cat103_controlled_area_pen_move_handler,
            MMI_PEN_EVENT_MOVE);
    wgui_register_category_screen_control_area_pen_handlers(
            wgui_cat103_controlled_area_pen_long_tap_handler,
            MMI_PEN_EVENT_LONG_TAP);
    wgui_register_category_screen_control_area_pen_handlers(
            wgui_cat103_controlled_area_pen_repeat_handler,
            MMI_PEN_EVENT_REPEAT);    
#endif /* __MMI_TOUCH_SCREEN__ */ 

    dm_redraw_category_screen();
	g_wgui_cat103_from_history = MMI_FALSE;
}
#endif /* __MMI_CAT103_SUPPORT__ */


S32 input_box_y = 0, input_box_x = 0;
static U16 cat200_search_img = 0;
MMI_BOOL g_wgui_cat199_has_checkbox = MMI_FALSE;
static MMI_BOOL g_wgui_cat200_set_specific_highlight = MMI_FALSE;
MMI_BOOL g_wgui_cat199_disable_tab_title = MMI_FALSE;
static MMI_BOOL g_wgui_cat199_menuitem_stop_scrolling = MMI_TRUE;
MMI_BOOL g_wgui_cat_is_async_dynamic_list = MMI_FALSE;
void wgui_cat199_redraw_controlled_area(dm_coordinates *coordinate);

PU8(*g_wgui_cat199_get_attachment_icon) (S32);
PU8(*g_wgui_cat199_get_attachment_icon_filepath) (S32);
gdi_image_cache_bmp_struct(*g_wgui_cat199_get_attachment_icon_buffer) (S32);
S32(*cat200_search_function) (U8 *);
BOOL(*wgui_check_application_present) (S32 *max_number) = NULL;
void (*g_wgui_cat200_resize_and_move_func)(S32) = NULL;
void (*g_wgui_cat200_draw_information_bar_func)(void) = NULL;
void (*g_wgui_cat200_set_special_key_func)(void) = NULL;
#define WGUI_CAT199_DEFAULT_HIGHLIGHT_ITEM (1)

#if defined(__MMI_MAINLCD_96X64__) 
UI_filled_area cat200_inputbox_BG_filler = 
{
    UI_FILLED_AREA_TYPE_COLOR,
    UI_NULL_IMAGE,
    NULL,
    {0, 0, 0, 0},
    {255, 255, 255, 100},
    {0, 0, 0, 0},
    {0, 0, 0, 0},
    0
};

UI_single_line_input_box_theme cat200_singleline_inputbox_theme = { 
    &cat200_inputbox_BG_filler,
    &cat200_inputbox_BG_filler,
    &cat200_inputbox_BG_filler,
    {255, 255, 255, 100},
    {255, 255, 255, 100},
    {0, 0, 0, 0},
    {0, 0, 0, 0},
    {255, 255, 255, 100},
    {255, 255, 255, 100},
    &UI_DEFAULT_FONT,
    1,
    UI_SINGLE_LINE_INPUT_BOX_CENTER_Y,
    '*'
};

#else /*__MMI_MAINLCD_96X64__*/
UI_filled_area cat200_inputbox_BG_filler = 
{
    UI_FILLED_AREA_TYPE_COLOR,
    UI_NULL_IMAGE,
    NULL,
    {255, 255, 255, 100},
    {0, 0, 0, 0},
    {255, 255, 255, 100},
    {255, 255, 255, 100},
    0
};


UI_single_line_input_box_theme cat200_singleline_inputbox_theme = { 
    &cat200_inputbox_BG_filler,
    &cat200_inputbox_BG_filler,
    &cat200_inputbox_BG_filler,
    {0, 0, 0, 100},
    {128, 128, 128, 100},
    {0, 0, 0, 100},
    {255, 255, 255, 100},
    {51, 88, 171, 100},
    {255, 0, 0, 100},
    &UI_DEFAULT_FONT,
    1,
    UI_SINGLE_LINE_INPUT_BOX_CENTER_Y,
    '*'
};
#endif

#include "timerEvents.h"
#include "gd_include.h"
#include "Med_api.h"
#include "kal_public_api.h"
#include "FileMgrSrvGprot.h"
#include "FileMgrType.h"
//#include "mmi_rp_srv_phb_def.h"
//#include "mmi_rp_app_phonebook_def.h"


extern S32 GUI_current_fixed_icontext_menuitem_x, GUI_current_fixed_icontext_menuitem_y;
extern S32 GUI_current_fixed_icontext_list_menuitem_x, GUI_current_fixed_icontext_list_menuitem_y;
#if defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_KEY)
extern MMI_BOOL gui_in_ssk;
#endif

#if defined(__MMI_UI_LIST_SLIDE_EFFECT__)
extern gui_effect_struct *g_slide_effect;
#endif



#ifdef __MMI_MAINLCD_240X400__
    #define WGUI_CAT199_IMAGE_WIDTH 30
    #define WGUI_CAT199_IMAGE_HEIGHT 30
    #define WGUI_CAT199_IMAGE_X_GAP 5
    #define WGUI_CAT199_IMAGE_Y_GAP 8
#elif defined(__MMI_MAINLCD_240X320__)
    #define WGUI_CAT199_IMAGE_WIDTH 30
    #define WGUI_CAT199_IMAGE_HEIGHT 30
    #define WGUI_CAT199_IMAGE_X_GAP 5
    #define WGUI_CAT199_IMAGE_Y_GAP 4
#elif defined(__MMI_MAINLCD_320X480__)
    #define WGUI_CAT199_IMAGE_WIDTH 30
    #define WGUI_CAT199_IMAGE_HEIGHT 30
    #define WGUI_CAT199_IMAGE_X_GAP 5
    #define WGUI_CAT199_IMAGE_Y_GAP 8
#elif defined(__MMI_MAINLCD_320X240__)
    #define WGUI_CAT199_IMAGE_WIDTH 30
    #define WGUI_CAT199_IMAGE_HEIGHT 30
    #define WGUI_CAT199_IMAGE_X_GAP 5
    #define WGUI_CAT199_IMAGE_Y_GAP 8
#else
    #define WGUI_CAT199_IMAGE_WIDTH ((MMI_MENUITEM_HEIGHT * 7 / 10) + 1)
    #define WGUI_CAT199_IMAGE_HEIGHT ((MMI_MENUITEM_HEIGHT * 7 / 10) + 1)
    #define WGUI_CAT199_IMAGE_X_GAP (MMI_MENUITEM_HEIGHT >> 3)
    #define WGUI_CAT199_IMAGE_Y_GAP (MMI_MENUITEM_HEIGHT / 6)
#endif

#define WGUI_CAT_THUMBNAIL_CACHENONE  1
#define WGUI_CAT_THUMBNAIL_CACHING    2
#define WGUI_CAT_THUMBNAIL_CACHED     3
#define WGUI_CAT_THUMBNAIL_CACHEERROR 4

#define WGUI_CAT_THUMBNAIL_CACHE_ASM 0
#define WGUI_CAT_THUMBNAIL_CACHE_MDI 1

#define WGUI_CAT_THUMBNAIL_UI_DELAY_DECODE_FIRST_DUR 80 
#define WGUI_CAT_THUMBNAIL_UI_DELAY_DECODE_NEXT_DUR  20 

#define WGUI_THUMBNAIL_MED_CACHE_SIZE 1024*500

#ifdef __MMI_PHONEBOOK_LIST_THUMBNAIL__
wgui_thumbnail_set_displayable_func wgui_thumbnail_set_displayable = NULL;
wgui_thumbnail_get_displayable_func wgui_thumbnail_get_displayable = NULL;
wgui_thumbnail_get_image_func wgui_thumbnail_get_image_path_callback = NULL;
wgui_thumbnail_get_image_func_ex wgui_thumbnail_get_image_callback = NULL;
wgui_thumbnail_imgdec_done_callback_func wgui_thumbnail_imgdec_done_callback = NULL;

static S16 image_box_width;
static S16 image_box_height;

typedef struct tagCacheNode
{
    S32 index;
    U16 id;
    PU8 buffer;
    S16 state;
    S16 mem_flag;
    struct tagCacheNode *next;
    struct tagCacheNode *prev;
    U16 cache_width;
    U16 cache_height;
} wgui_cat_thumbnail_cache_node;

typedef struct
{
    wgui_cat_thumbnail_cache_node *front_p;
    wgui_cat_thumbnail_cache_node *rear_p;
} wgui_cat_thumbnail_cache_search_list;

typedef struct
{
    S16 x;
    S16 y;
} wgui_cat_thumbnail_cache_position;
typedef enum
{
    WGUI_THUMBNAIL_DECODER_TYPE_OLD,
    WGUI_THUMBNAIL_DECODER_TYPE_NEW,
    WGUI_THUMBNAIL_DECODER_TYPE_NONE
}wgui_thumbnail_decoder_type_enum;
typedef struct
{
    /* Number of cache group */
    S32 first_displayed_item;
    S32 prev_first_displayed_item;
    wgui_cat_thumbnail_cache_search_list cache_search_list;
    /* The item that is decoding currently */
    wgui_cat_thumbnail_cache_node *cur_decode_p;
    gdi_handle decoding_layer;
    gdi_handle decoding_handle;
    wgui_thumbnail_decoder_type_enum decoder_type;
    S32 decoding_index;
    wgui_cat_thumbnail_cache_position cache_pos[10];
    U16 decoder_create;
    S16 med_cache_num;
} wgui_thumbnail_cache_struct;

wgui_thumbnail_get_info_func wgui_cat_thumbnail_get_menuitem = NULL;

static wgui_thumbnail_cache_struct *g_thumbnail_cache_p;
static wgui_thumbnail_get_store_id_func g_thumbnail_get_store_id_func = NULL;

static MMI_BOOL wgui_cat_thumbnail_is_cached(S32 idx, wgui_cat_thumbnail_cache_node **node_p);
static void wgui_cat_thumbnail_stop_decoder(void);
static void wgui_cat_thumbnail_cache_list_decoding_next(S32 idx);
static void wgui_cat_thumbnail_draw_cached_img(wgui_cat_thumbnail_cache_node *node_p, S32 x, S32 y);
static void wgui_cat_thumbnail_decode_result_hdlr(GDI_RESULT decode_result, gdi_handle handle);
static wgui_cat_thumbnail_cache_node *wgui_cat_thumbnail_cache_create_node(void);
static void wgui_cat_thumbnail_cache_free_node(wgui_cat_thumbnail_cache_node *node);
static void wgui_cat_thumbnail_cache_free_all(void);
static void wgui_cat_thumbnail_cache_list_add(S32 idx, PU8 file_icon_p, wgui_cat_thumbnail_cache_node *ref_node);
static S32 wgui_cat_thumbnail_find_next(S32 cur_cache);
static void wgui_cat_thumbnail_start_next(void);
static void wgui_cat_thumbnail_delay_decode_timer(void);
static void wgui_cat_thumbnail_set_cache_pos(S32 idx, S32 first_displayed, wgui_thumbnail_cache_struct* fmgr_cache_p, S32 x1, S32 y1);
static void wgui_cat_thumbnail_show_img(
        S32 idx, 
        BOOL is_hilighted, 
        wgui_thumbnail_info_struct *menuitem_data, 
        S32 x1, 
        S32 y1, 
        S32 x2, 
        S32 y2);
static gdi_color wgui_thumbnail_get_bg_color(BOOL is_hilighted);
static void wgui_cat_thumbnail_stop_decoder(void);

#endif /* __MMI_PHONEBOOK_LIST_THUMBNAIL__ */
/*****************************************************************************
 * FUNCTION
 *  wgui_cat200_set_specific_highlight
 * DESCRIPTION
 *  for APP to set specific highlight
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat200_set_specific_highlight(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_wgui_cat200_set_specific_highlight = MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  SetCategory200LeftSoftkeyFunction
 * DESCRIPTION
 *  Set left softkey function of category 200
 * PARAMETERS
 *  f               [IN]        Function pointer
 *  k               [IN]        Event type
 * RETURNS
 *  void
 *****************************************************************************/
void SetCategory200LeftSoftkeyFunction(void (*f) (void), MMI_key_event_type k)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(k);
    wgui_singleline_inputbox_LSK_function = f;
}


/*****************************************************************************
 * FUNCTION
 *  RegisterCat200SearchFunction
 * DESCRIPTION
 *  Register search function (for APP)
 * PARAMETERS
 *  search_function     [IN]        Function pointer
 * RETURNS
 *  void
 *****************************************************************************/
void RegisterCat200SearchFunction(S32(*search_function) (U8 *))
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (search_function)
    {
        cat200_search_function = search_function;
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat199_register_get_attachment_icon_callback
 * DESCRIPTION
 *  Register search function (for APP)
 * PARAMETERS
 *  search_function     [IN]        Function pointer
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat199_register_get_attachment_icon_callback(PU8(*get_attachment_icon) (S32))
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (get_attachment_icon)
    {
        g_wgui_cat199_get_attachment_icon = get_attachment_icon;
    }
}

/*****************************************************************************
 * FUNCTION
 *  wgui_cat199_register_get_attachment_icon_filepath_callback
 * DESCRIPTION
 *  Register search function (for APP)
 * PARAMETERS
 *  search_function     [IN]        Function pointer
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat199_register_get_attachment_icon_filepath_callback(PU8(*get_attachment_icon_filepath) (S32))
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (get_attachment_icon_filepath)
    {
        g_wgui_cat199_get_attachment_icon_filepath = get_attachment_icon_filepath;
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat199_register_get_attachment_icon_buffer_callback
 * DESCRIPTION
 *  Register search function (for APP)
 * PARAMETERS
 *  search_function     [IN]        Function pointer
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat199_register_get_attachment_icon_buffer_callback(gdi_image_cache_bmp_struct(*get_attachment_icon_buffer) (S32))
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (get_attachment_icon_buffer)
    {
        g_wgui_cat199_get_attachment_icon_buffer = get_attachment_icon_buffer;
    }
}


/*****************************************************************************
 * FUNCTION
 *  Register_appl_present_function
 * DESCRIPTION
 *  Register application present function
 * PARAMETERS
 *  application_present_function        [IN]        Function pointer
 * RETURNS
 *  void
 *****************************************************************************/
void Register_appl_present_function(BOOL(*application_present_function) (S32 *max_number))
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_check_application_present = application_present_function;
}


/*****************************************************************************
 * FUNCTION
 *  refresh_search_list_change_list_ext
 * DESCRIPTION
 *  draw search list and related setting
 * PARAMETERS
 *  no_entries              [IN]        Item count
 *  highlighted_item        [IN]        Inedex of highlighted item
 * RETURNS
 *  void
 *****************************************************************************/
void refresh_search_list_change_list_ext(S32 no_entries, S32 highlighted_item)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 max_entries = 0;
    BOOL showOption, application_present;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_fixed_list_menu.highlighted_item = highlighted_item;
    MMI_fixed_list_menu.n_items = no_entries;
    MMI_fixed_list_menu.displayed_items = no_entries;

    if (wgui_check_application_present)
    {
        application_present = wgui_check_application_present(&max_entries);   /* true in case of dictionary */
    }
    else
    {
        application_present = MMI_FALSE;
    }

	if (g_dm_data.s32CatId ==  MMI_CATEGORY199_ID ||
        g_dm_data.s32CatId ==  MMI_CATEGORY199_SCROLLTEXT_ID) 
    {
		if (g_wgui_cat199_disable_tab_title == MMI_FALSE)
		{
			set_menu_item_count(no_entries);
		}
    }
	else
	{
        #ifndef  MMI_CATEGORIES_SUPPORT_EDITOR_INFO_BAR        
        if (application_present)
        {
            set_menu_item_count(max_entries);  /* number of words goes beyond this limit, and increases at the run time */
        }
        else
        {
            set_menu_item_count(no_entries);
        }
        #endif/*MMI_CATEGORIES_SUPPORT_EDITOR_INFO_BAR*/
    }

    if (application_present)
    {
        showOption = no_entries >= 0 ? MMI_TRUE : MMI_FALSE;
    }
    else
    {
        showOption = no_entries > 0 ? MMI_TRUE : MMI_FALSE;
    }

    if (showOption)
    {
        S32 first_item, last_item;

        set_left_softkey_label(wgui_singleline_inputbox_LSK_label_string);
        set_left_softkey_icon(wgui_singleline_inputbox_LSK_label_icon);
        redraw_left_softkey();
        register_left_softkey_handler();
        set_left_softkey_function(wgui_singleline_inputbox_LSK_function, KEY_EVENT_UP);
        set_left_softkey_function(UI_dummy_function, KEY_EVENT_DOWN);

        if (g_wgui_cat_is_async_dynamic_list)
        {
            if (no_entries == 0)
            {
                gui_fixed_icontext_list_menuitem_stop_scroll();
                gui_pop_up_description_stop_scroll();
            }
            init_asyncdynamic_item_buffer(no_entries, asyncdynamic_item_buffer.load_func, asyncdynamic_item_buffer.hint_func);
            MMI_fixed_list_menu.n_items = no_entries;
            asyncdynamic_list_goto_item_no_redraw(MMI_fixed_list_menu.highlighted_item);
        }
        else
        {
            first_item = MMI_fixed_list_menu.first_displayed_item;
            last_item = MMI_fixed_list_menu.last_displayed_item;
            if (no_entries == 0)
            {
                gui_fixed_icontext_menuitem_stop_scroll();
                gui_pop_up_description_stop_scroll();
            }

            dynamic_list_goto_item_no_redraw(MMI_fixed_list_menu.highlighted_item);
            MMI_fixed_list_menu.first_displayed_item = first_item;
            MMI_fixed_list_menu.last_displayed_item = last_item;
        }
    }
    else
    {
        set_left_softkey_label(NULL);
        set_left_softkey_icon(NULL);
        redraw_left_softkey();
        set_left_softkey_function(UI_dummy_function, KEY_EVENT_UP);
        set_left_softkey_function(UI_dummy_function, KEY_EVENT_DOWN);
        if (g_wgui_cat_is_async_dynamic_list)
        {
            gui_fixed_icontext_list_menuitem_stop_scroll();
        }
        else
        {
            gui_fixed_icontext_menuitem_stop_scroll();
        }
        gui_pop_up_description_stop_scroll();
#if !defined(GUI_EDITOR_SHOW_TITLE)
        if (g_dm_data.s32CatId !=  MMI_CATEGORY202_ID &&
            g_dm_data.s32CatId !=  MMI_CATEGORY202_NOINFO_ID)
#endif
        {
            wgui_title_set_menu_shortcut_number(0);
        }
        wgui_current_pop_up_description_index = -1;
    }
#ifndef  MMI_CATEGORIES_SUPPORT_EDITOR_INFO_BAR 

    /* title */
    if (g_dm_data.s32CatId !=  MMI_CATEGORY199_ID && 
        g_dm_data.s32CatId !=  MMI_CATEGORY199_SCROLLTEXT_ID)  /* for category199 */
    {
#if !defined(GUI_EDITOR_SHOW_TITLE)
        if (g_dm_data.s32CatId !=  MMI_CATEGORY202_ID &&
            g_dm_data.s32CatId !=  MMI_CATEGORY202_NOINFO_ID)
#endif
        {
            draw_title();
        }
    }
    else if (g_dm_data.s32CatId ==  MMI_CATEGORY199_ID ||
        g_dm_data.s32CatId ==  MMI_CATEGORY199_SCROLLTEXT_ID )  /* for category199 */
    {
        if (g_wgui_cat199_disable_tab_title == MMI_FALSE)
        {
            wgui_horizontal_show(GUI_TITLE_PART_ALL);
        }
    }
    else
    {
        draw_title();
    }
#endif/* MMI_CATEGORIES_SUPPORT_EDITOR_INFO_BAR */
    if (g_wgui_cat_is_async_dynamic_list)
    {
        wgui_async_list_show_multi_icontext_menu();
    }
    else
    {
        wgui_dynamic_list_show_icontext_menu();
    }
}


/*****************************************************************************
 * FUNCTION
 *  refresh_search_list
 * DESCRIPTION
 *  Refreash search list
 * PARAMETERS
 *  name        [IN]     Name to search
 * RETURNS
 *  void
 *****************************************************************************/
void refresh_search_list(U8 *name)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 no_entries = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(cat200_search_function == NULL)
    {
        return;
    }
    
    no_entries = cat200_search_function(name);
    
    MMI_ASSERT(no_entries >= 0); /* return entry must >=0 or list will have problem */
    if (g_wgui_cat_is_async_dynamic_list)
    {
        /* do nothing ? */
    }
    else
    {
        load_dynamic_item_buffer(no_entries);
    }
    
    if ( ((g_dm_data.s32CatId == MMI_CATEGORY199_ID) && (g_wgui_cat199_has_checkbox == MMI_FALSE))
         || ((g_dm_data.s32CatId == MMI_CATEGORY200_ID) && (g_wgui_cat200_set_specific_highlight == MMI_TRUE)) )
    {
        if (wgui_inputs_sl_is_empty() && (no_entries >= (WGUI_CAT199_DEFAULT_HIGHLIGHT_ITEM + 1)))
        {
            /* there are some items */
            /* because first line is "Add new content", should not highlight on first line */
            refresh_search_list_change_list_ext(no_entries, WGUI_CAT199_DEFAULT_HIGHLIGHT_ITEM);
        }
        else
        {
            refresh_search_list_change_list_ext(no_entries, 0);
        }
    }
    else
    {
        refresh_search_list_change_list_ext(no_entries, 0);
    }
    gdi_layer_blt_previous(0, 0, UI_device_width - 1, UI_device_height - 1);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat200_set_left_and_right_arrow_key
 * DESCRIPTION
 *  Because IME will register left and right arrow key and will not restore it
 *   so category should restore left and right arrow key by ourselves.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat200_set_left_and_right_arrow_key(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
        
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_wgui_cat_is_async_dynamic_list)
    {
       register_asyncdynamic_list_keys();
    }
}


#ifdef __MMI_TOUCH_SCREEN__
/*****************************************************************************
 * FUNCTION
 *  wgui_cat200_virtual_keypad_callback
 * DESCRIPTION
 *  virtual keypad callback of category 200
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat200_virtual_keypad_callback(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_imc_redraw_screen_by_state();
}


/*****************************************************************************
 * FUNCTION
 *  Cate200CategoryControlAreaPenDownHandler
 * DESCRIPTION
 *  pen down handler for category 200
 * PARAMETERS
 *  point       [IN]        Pen down position
 * RETURNS
 *  
 *****************************************************************************/
#if defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN)
extern gui_list_smooth_scrolling_by_pen_state_enum g_gui_ssp_state;
#endif
MMI_BOOL Cate200CategoryControlAreaPenDownHandler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    BOOL ret = 0;
    gui_list_pen_enum menu_event = GUI_LIST_PEN_NONE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_wgui_cat_is_async_dynamic_list)
    {
        MMI_fixed_list_menu.pen_redraw_menu_function = wgui_async_list_show_multi_icontext_menu;
    }
    else
    {
        MMI_fixed_list_menu.pen_redraw_menu_function = show_dynamic_list;
    }

    if (MMI_fixed_list_menu.pen_state.pen_on_scrollbar)
    {
        return MMI_TRUE;
    }

    gui_vertical_scrollbar_set_pen_self_scroll(&MMI_fixed_list_menu.vbar, MMI_TRUE);
    gui_fixed_list_menu_set_pen_scroll_delay(&MMI_fixed_list_menu, GUI_DYNAMIC_LIST_PEN_SCROLL_DELAY);

    if (g_wgui_cat_is_async_dynamic_list)
    {
        #if defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN)
        if (g_gui_ssp_state == GUI_LIST_SMOOTH_SCROLLING_BY_PEN_STATE_FREE_RUN)
        {
            return MMI_FALSE;
        }
        else
        #endif
        {

            ret = gui_asyncdynamic_list_menu_translate_pen_event(
                    &MMI_fixed_list_menu,
                    MMI_PEN_EVENT_DOWN,
                    point.x,
                    point.y,
                    &menu_event);
        }
    }
    else
    {
        ret = gui_dynamic_list_menu_translate_pen_event(
                &MMI_fixed_list_menu,
                MMI_PEN_EVENT_DOWN,
                point.x,
                point.y,
                &menu_event);
    }
    if (ret)
    {
        if (menu_event == GUI_LIST_PEN_HIGHLIGHT_CHANGED || menu_event == GUI_LIST_PEN_NEED_REDRAW)
        {
            if (g_wgui_cat_is_async_dynamic_list)
            {
                wgui_async_list_show_multi_icontext_menu();
            }
            else
            {
                show_dynamic_list();
            }
        }
        return MMI_TRUE;
    }

    return MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  Cate200CategoryControlAreaPenUpHandler
 * DESCRIPTION
 *  pen up handler of category 200
 * PARAMETERS
 *  point       [IN]        Pen up position
 * RETURNS
 *  
 *****************************************************************************/
MMI_BOOL Cate200CategoryControlAreaPenUpHandler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL ret = MMI_FALSE;
    MMI_BOOL is_in_vbar = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* if pen event in vbar area */
    if (MMI_fixed_list_menu.vbar.pen_state.state != GUI_SCROLLBAR_PEN_STATE_INVALID)
    {
        is_in_vbar = MMI_TRUE;
    }

    if (g_wgui_cat_is_async_dynamic_list)
    {
        ret = wgui_general_pen_asyncdynamic_list_menu_hdlr(point, MMI_PEN_EVENT_UP);
    }
    else
    {
        ret = wgui_general_pen_dynamic_list_menu_hdlr(point, MMI_PEN_EVENT_UP);
    }

    if (ret && (is_in_vbar == MMI_FALSE))
    {
        if (g_dm_data.s32CatId ==  MMI_CATEGORY199_ID ||
            g_dm_data.s32CatId ==  MMI_CATEGORY199_SCROLLTEXT_ID ||
            g_dm_data.s32CatId ==  MMI_CATEGORY200_ID ||
            g_dm_data.s32CatId ==  MMI_CATEGORY202_ID ||
            g_dm_data.s32CatId ==  MMI_CATEGORY202_NOINFO_ID)
        {
            if (g_wgui_cat_is_async_dynamic_list)
            {
                gui_fixed_icontext_list_menuitem_stop_scroll();
            }
            else
            {
                gui_fixed_icontext_menuitem_stop_scroll();
            }
            gui_pop_up_description_stop_scroll();

            if (g_wgui_cat_is_async_dynamic_list)
            {
                gui_fixed_icontext_list_menuitem_start_scroll();
                wgui_async_list_show_multi_icontext_menu();
            }
            else
            {
                gui_fixed_icontext_menuitem_start_scroll();
                wgui_dynamic_list_show_icontext_menu();
            }
        }
    }

    MMI_fixed_list_menu.pen_state.pen_on_scrollbar = 0;
    return ret;
}


/*****************************************************************************
 * FUNCTION
 *  Cate200CategoryControlAreaPenMoveHandler
 * DESCRIPTION
 *  pen move handler of category 200
 * PARAMETERS
 *  point       [IN]        Pen move position
 * RETURNS
 *  
 *****************************************************************************/
MMI_BOOL Cate200CategoryControlAreaPenMoveHandler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL ret = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_wgui_cat_is_async_dynamic_list)
    {
        wgui_general_pen_asyncdynamic_list_menu_hdlr(point, MMI_PEN_EVENT_MOVE);
    }
    else
    {
        wgui_general_pen_dynamic_list_menu_hdlr(point, MMI_PEN_EVENT_MOVE);
    }
    return ret;
}


/*****************************************************************************
 * FUNCTION
 *  Cate200CategoryControlAreaPenLongTapHandler
 * DESCRIPTION
 *  pen long tap hanlder
 * PARAMETERS
 *  point       [IN]        Pen long tap position
 * RETURNS
 *  
 *****************************************************************************/
MMI_BOOL Cate200CategoryControlAreaPenLongTapHandler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL ret = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_wgui_cat_is_async_dynamic_list)
    {
        wgui_general_pen_asyncdynamic_list_menu_hdlr(point, MMI_PEN_EVENT_LONG_TAP);
    }
    else
    {
        wgui_general_pen_dynamic_list_menu_hdlr(point, MMI_PEN_EVENT_LONG_TAP);
    }
    return ret;
}


/*****************************************************************************
 * FUNCTION
 *  Cate200CategoryControlAreaPenRepeatHandler
 * DESCRIPTION
 *  pen repeat hanlder
 * PARAMETERS
 *  point       [IN]        Pen repeat position
 * RETURNS
 *  
 *****************************************************************************/
MMI_BOOL Cate200CategoryControlAreaPenRepeatHandler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL ret = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_wgui_cat_is_async_dynamic_list)
    {
        wgui_general_pen_asyncdynamic_list_menu_hdlr(point, MMI_PEN_EVENT_REPEAT);
    }
    else
    {
        wgui_general_pen_dynamic_list_menu_hdlr(point, MMI_PEN_EVENT_REPEAT);
    }

    return ret;
}
#endif /* __MMI_TOUCH_SCREEN__ */ 


/*****************************************************************************
 * FUNCTION
 *  wgui_cat200_resize_and_move
 * DESCRIPTION
 *  This is a callback function when IME send resize and move message
 *  1.resize list
 *  2.move singleline inputbox
 * PARAMETERS
 *  inputbox_y   [IN]    sinlgeline inputbox y position
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat200_resize_and_move(S32 inputbox_y)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 menu_h = 0, sl_y = 0;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    sl_y = inputbox_y - 1; /* border */
    menu_h = sl_y - 1 /* border */ - MMI_fixed_list_menu.y;
    resize_fixed_list(MMI_fixed_list_menu.width, menu_h);
    
    if (g_wgui_cat_is_async_dynamic_list)
    {
        if (MMI_fixed_list_menu.n_items > 0)
        {
            gui_asyncdynamic_list_menu_locate_highlighted_item(&MMI_fixed_list_menu);
        }
    }
    else
    {
        gui_dynamic_list_menu_locate_highlighted_item(&MMI_fixed_list_menu);
    }

    wgui_inputs_sl_move(MMI_singleline_inputbox.x, sl_y);
}

#if defined(__MMI_VIRTUAL_KEYBOARD__)
/*****************************************************************************
 * FUNCTION
 *  wgui_cat_stop_pop_up_description_scroll
 * DESCRIPTION
 *  stop the pop up description scroll.
 * PARAMETERS
 *  x1        [IN]   unused.
 *  y1        [IN]   unused.
 *  x2        [IN]   unused.
 *  y2        [IN]   unused.
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL wgui_cat_stop_pop_up_description_scroll(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL ret;    
#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
    extern S32 gblock_list_effect;
    S32 temp;
#endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */ 

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
    temp = gblock_list_effect;
    gblock_list_effect = 1;
#endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */ 

    ret = UI_inputbox_stop_cursor(x1, y1, x2, y2);
    if (g_wgui_cat_is_async_dynamic_list)
    {
        gui_fixed_icontext_list_menuitem_stop_scroll();
    }
    else
    {
        gui_fixed_icontext_menuitem_stop_scroll();
    }
    //gui_pop_up_description_stop_scroll();
    if (g_wgui_cat_is_async_dynamic_list)
    {
        wgui_async_list_show_multi_icontext_menu();
    }
    else
    {
        wgui_dynamic_list_show_icontext_menu();
    }
    gui_pop_up_description_stop_scroll();

#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
    gblock_list_effect = temp;
#endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */ 

    return ret;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat_resume_pop_up_description_scroll
 * DESCRIPTION
 *  resume the pop up description scroll.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat_resume_pop_up_description_scroll(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
    extern S32 gblock_list_effect;
    S32 temp;
#endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */ 
        
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
    temp = gblock_list_effect;
    gblock_list_effect = 1;
#endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */ 

    UI_inputbox_start_cursor();
    /* Revise: gui_pop_up_description_start_scroll(..) */
    if (g_wgui_cat_is_async_dynamic_list)
    {
        gui_fixed_icontext_list_menuitem_stop_scroll();
        gui_fixed_icontext_list_menuitem_start_scroll();
        wgui_async_list_show_multi_icontext_menu();
    }
    else
    {
        gui_pop_up_description_stop_scroll();
        gui_fixed_icontext_menuitem_start_scroll();
        wgui_dynamic_list_show_icontext_menu();
    }

    
#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
    gblock_list_effect = temp;
#endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */ 
}
#endif


/*****************************************************************************
 * FUNCTION
 *  RedrawCategoryControlledArea200Screen
 * DESCRIPTION
 *  redraw category200
 *  1. information bar
 *  2. list
 *  3. search image
 *  4. singleline inputbox
 * PARAMETERS
 *  coordinate      [IN]     Area to redraw     
 * RETURNS
 *  void
 *****************************************************************************/
void RedrawCategoryControlledArea200Screen(dm_coordinates *coordinate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#ifdef MMI_CATEGORIES_SUPPORT_EDITOR_INFO_BAR
    color ccblack = {255, 255, 255, 100};
    color ccblack2 = {0, 0, 0, 100};
#else /*MMI_CATEGORIES_SUPPORT_EDITOR_INFO_BAR*/
    color ccblack = {0, 0, 0, 100};
#endif /*MMI_CATEGORIES_SUPPORT_EDITOR_INFO_BAR*/
    S32 temp_w = 0, temp_h = 0, image_y = 0, image_x1 = 0, image_x2 = 0;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_dm_data.s32CatId ==  MMI_CATEGORY202_ID ||
        g_dm_data.s32CatId ==  MMI_CATEGORY202_NOINFO_ID)  /* for category202 */
    {
        RedrawCategoryControlledArea202Screen(coordinate);
        return;
    }
    else if (g_dm_data.s32CatId ==  MMI_CATEGORY199_ID || 
             g_dm_data.s32CatId ==  MMI_CATEGORY199_SCROLLTEXT_ID)  /* for category199 */
    {
        wgui_cat199_redraw_controlled_area(coordinate);
        return;
    }
    else
    {    
        gdi_layer_lock_frame_buffer();

        gui_reset_clip();
        gdi_layer_reset_clip();

#ifndef __MMI_FTE_SUPPORT__
  #ifndef MMI_CATEGORIES_SUPPORT_EDITOR_INFO_BAR
        /* information bar */
        wgui_cat199_draw_input_method();
  #endif/*MMI_CATEGORIES_SUPPORT_EDITOR_INFO_BAR*/
#endif
        if (g_wgui_cat_is_async_dynamic_list)
        {
            gui_pop_up_description_stop_scroll();
            gui_fixed_icontext_list_menuitem_stop_scroll();
            gui_fixed_icontext_list_menuitem_start_scroll();
            wgui_async_list_show_multi_icontext_menu();
        }
        else
        {
            /* list */
            if (MMI_fixed_list_menu.n_items > 0)
            {
                gui_pop_up_description_stop_scroll();
                gui_fixed_icontext_menuitem_stop_scroll();
                gui_fixed_icontext_menuitem_start_scroll();
            }
            show_dynamic_list();
        }

        gui_reset_clip();
        
#if defined(__MMI_TOUCH_SCREEN__)
        /* clear background of input area*/
        input_box_y = MMI_SUBMENU_CONTENT_Y + MMI_fixed_list_menu.height + 1;
        gdi_draw_solid_rect(0, input_box_y - 1, UI_device_width - 1, input_box_y + CAT200_INPUTBOX_H, GDI_COLOR_TRANSPARENT);
#endif /* defined(__MMI_TOUCH_SCREEN__) */ 

#ifndef __MMI_FTE_SUPPORT__
#ifdef  MMI_CATEGORIES_SUPPORT_EDITOR_INFO_BAR
        gui_fill_rectangle(
            0,
            input_box_y - 1,
            UI_device_width-1 ,
            input_box_y + CAT200_INPUTBOX_H,
            ccblack2); 
        gui_draw_rectangle(
            CAT200_MARGIN_WIDTH,
            input_box_y - 1,
            UI_device_width - CAT200_MARGIN_WIDTH,
            input_box_y + CAT200_INPUTBOX_H, 
            ccblack); 

#else /*MMI_CATEGORIES_SUPPORT_EDITOR_INFO_BAR*/

        /* draw black frame of input area */
        gui_draw_rectangle(
            CAT200_MARGIN_WIDTH,
            input_box_y - 1,
            UI_device_width - CAT200_MARGIN_WIDTH,
            input_box_y + CAT200_INPUTBOX_H,
            ccblack); 
#endif
#endif /* __MMI_FTE_SUPPORT__ */

        /* draw search image */
        gui_measure_image(get_image(cat200_search_img), &temp_w, &temp_h);
        image_y = ((CAT200_INPUTBOX_H >> 1) - (temp_h >> 1));
        
//         if (r2lMMIFlag)
//         {        
//             input_box_y = MMI_singleline_inputbox.y;
//             input_box_x = CAT200_MARGIN_WIDTH + 2;
//             image_x1 = UI_device_width - CAT200_MARGIN_WIDTH - 1 - 2 - temp_w;
//             image_x2 = UI_device_width - CAT200_MARGIN_WIDTH - 1 - 1;            
//         }
//         else
        {            
            input_box_y = MMI_singleline_inputbox.y;
            input_box_x = CAT200_INPUTBOX_X;
            image_x1 = CAT200_MARGIN_WIDTH + 2;
            image_x2 = input_box_x;            
        }
        
        
        gdi_layer_set_clip(CAT200_MARGIN_WIDTH + 1, input_box_y, UI_device_width - CAT200_MARGIN_WIDTH - 1 - 1, input_box_y + CAT200_INPUTBOX_H - 1);
        if (wgui_is_wallpaper_on_bottom() == MMI_TRUE)
        {
            /* clear background of image area */
        #ifdef __MMI_FTE_SUPPORT__
            gdi_draw_solid_rect(CAT200_MARGIN_WIDTH + 1, input_box_y, UI_device_width - CAT200_MARGIN_WIDTH - 1 - 1, input_box_y + CAT200_INPUTBOX_H - 1, GDI_COLOR_TRANSPARENT);
        #else
            gui_fill_rectangle(CAT200_MARGIN_WIDTH + 1, input_box_y, UI_device_width - CAT200_MARGIN_WIDTH - 1 - 1, input_box_y + CAT200_INPUTBOX_H - 1, MMI_singleline_inputbox.normal_filler->c);
        #endif /* __MMI_FTE_SUPPORT__ */
        }

#ifndef __MMI_FTE_SUPPORT__
        #ifndef MMI_CATEGORIES_SUPPORT_EDITOR_INFO_BAR
        gui_show_image(image_x1, input_box_y + image_y, get_image(cat200_search_img));
        /* information bar */
        wgui_cat199_draw_input_method();
        #endif /*MMI_CATEGORIES_SUPPORT_EDITOR_INFO_BAR*/
#endif
        #ifdef  MMI_CATEGORIES_SUPPORT_EDITOR_INFO_BAR   
        wgui_inputs_setup_input_information(0,0,UI_device_width,INFO_HIGHT);
        wgui_inputs_sl_redraw_information_bar();
        #endif /*MMI_CATEGORIES_SUPPORT_EDITOR_INFO_BAR*/
        wgui_inputs_sl_move(input_box_x + 1, input_box_y);
        redraw_singleline_inputbox();

/* update status icon bar */
#if defined(__MMI_FTE_SUPPORT__) && !defined(__MMI_TOUCH_SCREEN__)
        mmi_imc_redraw_screen_by_state();
#endif

        gdi_layer_unlock_frame_buffer();
        gdi_layer_blt_previous(0, 0, UI_device_width - 1, UI_device_height - 1);

#if defined(__MMI_VIRTUAL_KEYBOARD__)
        wgui_virtual_keyboard_register_hide_cursor_callback(wgui_cat_stop_pop_up_description_scroll);
        wgui_virtual_keyboard_register_blink_cursor_callback(wgui_cat_resume_pop_up_description_scroll);
#endif

        /* 
         * In Category 200, redraw_category_screen() is being called here instead of ShowCategory, 
         * since RedrawCategory200Screen is doing many other things like drawing image etc.
         */
    }
}


/*****************************************************************************
 * FUNCTION
 *  ExitCategory200Screen
 * DESCRIPTION
 *  Exit category200 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitCategory200Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ClearHighlightHandler();
    reset_softkeys();
    reset_menu_shortcut_handler();
    reset_fixed_list();
    wgui_inputs_sl_close();
#ifdef __MMI_PHONEBOOK_LIST_THUMBNAIL__
    wgui_cat_thumbnail_deninit();
#endif
    if (g_wgui_cat_is_async_dynamic_list)
    {
        reset_asyncdynamic_list();
    }
    else
    {
        reset_dynamic_list();
    }
    
    reset_pop_up_descriptions();

    cat200_search_img = 0;
    cat200_search_function = NULL;
    g_wgui_cat200_resize_and_move_func = NULL;
    g_wgui_cat200_draw_information_bar_func = NULL;
    wgui_check_application_present = NULL;
    g_wgui_cat200_set_special_key_func = NULL;
    g_wgui_cat_is_async_dynamic_list = MMI_FALSE;
#ifdef __MMI_UI_HINTS_IN_MENUITEM__
    reset_all_force_flags_for_hints();
    #ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
    gui_unblock_list_effect();
    #endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__*/ 
#endif /* __MMI_UI_HINTS_IN_MENUITEM__ */ 
    dynamic_item_text_align_left = FALSE;
    g_wgui_cat200_set_specific_highlight = MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  GetCategory200HistorySize
 * DESCRIPTION
 *  Gets the history buffer size of category 200
 * PARAMETERS
 *  void
 * RETURNS
 *  size in U8s of the history buffer
 *****************************************************************************/
S32 GetCategory200HistorySize(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return (((sizeof(list_menu_category_history) + 3) / 4) * 4 + sizeof(singleline_inputbox_category_history));
}


/*****************************************************************************
 * FUNCTION
 *  GetCategory200History
 * DESCRIPTION
 *  Gets the history buffer of category200
 * PARAMETERS
 *  history_buffer      [OUT]        Is the buffer into which the history data is stored
 * RETURNS
 *  return history buffer
 *****************************************************************************/
U8 *GetCategory200History(U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 s;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    get_list_menu_category_history(MMI_CATEGORY200_ID, history_buffer);
    s = sizeof(list_menu_category_history);
    s = (s + 3) / 4;
    s *= 4;
    wgui_inputs_sl_get_category_history(MMI_CATEGORY200_ID, (U8*) (history_buffer + s));
    return (history_buffer);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat200_editor_change_callback
 * DESCRIPTION
 *  editor change callback
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat200_editor_change_callback(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();
#ifdef  MMI_CATEGORIES_SUPPORT_EDITOR_INFO_BAR          
    wgui_inputs_setup_input_information(0,0,UI_device_width,INFO_HIGHT);
    wgui_inputs_sl_redraw_information_bar();
#endif /*MMI_CATEGORIES_SUPPORT_EDITOR_INFO_BAR*/
    MMI_fixed_list_menu.last_displayed_item -= MMI_fixed_list_menu.first_displayed_item;
    MMI_fixed_list_menu.first_displayed_item = 0;
    refresh_search_list(MMI_singleline_inputbox.text);
    wgui_inputs_sl_handle_input();
    gdi_layer_unlock_frame_buffer();
    gdi_lcd_repaint_all();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat_search_editor_msg_callback
 * DESCRIPTION
 *  Eidtor/IME callback function
 *  
 * PARAMETERS
 *  input_box_handle    [IN]  inputbox handle
 *  msg_ptr             [IN]  message type
 * RETURNS
 *  void
 *****************************************************************************/
U32 wgui_cat_search_editor_msg_callback(void * input_box_handle, mmi_imc_message_struct_p msg_ptr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    #if defined(__MMI_FTE_SUPPORT__) && defined(__MMI_CLIPBOARD__)
        U32 lresult = 0;
        single_line_input_box * editor_ptr;
    #endif
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    #if defined(__MMI_FTE_SUPPORT__) && defined(__MMI_CLIPBOARD__)
    editor_ptr = (single_line_input_box *)((mmi_editor_handler_struct *)input_box_handle)->input_box_handler;
    if (editor_ptr == &MMI_singleline_inputbox)
    {
        switch (msg_ptr->message_id)
        {
            case MMI_IMC_MESSAGE_CLIPBOARD_SAVE_STATUS:
                if (g_wgui_cat_is_async_dynamic_list)
                {
                    gui_fixed_icontext_list_menuitem_stop_scroll();
                    wgui_async_list_show_multi_icontext_menu();
                    gui_pop_up_description_stop_scroll();
                }
                lresult = mmi_input_box_msg_call_back_singleline(input_box_handle, msg_ptr);
                break;
                    
            case MMI_IMC_MESSAGE_CLIPBOARD_RESTORE_STATUS:
                if (g_wgui_cat_is_async_dynamic_list)
                {
                    wgui_async_list_show_multi_icontext_menu();
                    gui_fixed_icontext_list_menuitem_start_scroll();
                }
                lresult = mmi_input_box_msg_call_back_singleline(input_box_handle, msg_ptr);
                break;

            default:
                lresult = mmi_input_box_msg_call_back_singleline(input_box_handle, msg_ptr);
        }
    }
    return lresult;
    #else /* defined(__MMI_FTE_SUPPORT__) && defined(__MMI_CLIPBOARD__) */
        return mmi_input_box_msg_call_back_singleline(input_box_handle, msg_ptr);
    #endif /* defined(__MMI_FTE_SUPPORT__) && defined(__MMI_CLIPBOARD__) */
}


/*****************************************************************************
 * FUNCTION
 *  ShowCategory200Screen
 * DESCRIPTION
 *  Show Category200 screen (phonebook quick search)
 * PARAMETERS
 *  title                   [IN]        Title id
 *  title_icon              [IN]        Title icon
 *  left_softkey            [IN]        Left soft key label
 *  left_softkey_icon       [IN]        Left soft key icon
 *  right_softkey           [IN]        Right soft key label
 *  right_softkey_icon      [IN]        Right soft key icon
 *  number_of_items         [IN]        Number of items
 *  get_item_func           [IN]        Callback function of get menu item 
 *  get_hint_func           [IN]        Callback function of get menu item hint
 *  highlighted_item        [IN]        Highlighted item index
 *  search_image            [IN]        Seach image in input area
 *  buffer                  [IN]        Buffer
 *  buffer_max_length       [IN]        Buffer max length
 *  history_buffer          [IN]        Histpry buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory200Screen_int(
        U16 title,
        U16 title_icon,
        U16 left_softkey,
        U16 right_softkey,
        S32 number_of_items,
        GetItemFuncPtr get_item_func,
        GetHintFuncPtr get_hint_func,
        S32 highlighted_item,
        U16 search_image,
        U8 *buffer,
        S32 buffer_max_length,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;
    S32 input_box_width = 0, list_height = 0, max_entries = 0;
    U8 h_flag;
    BOOL application_present;
    U32 input_type;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();

    ShowListCategoryScreen_ext(
        get_string(title),
        get_image(title_icon),
        get_string(left_softkey),
        get_string(right_softkey));

	wgui_singleline_inputbox_LSK_label_icon = NULL;
    wgui_singleline_inputbox_LSK_label_string = get_string(left_softkey);

    g_wgui_cat200_resize_and_move_func = wgui_cat200_resize_and_move;

#ifndef __MMI_FTE_SUPPORT__
    g_wgui_cat200_draw_information_bar_func = wgui_cat199_draw_input_method;
#endif

    dynamic_item_text_align_left = TRUE;
    
    wgui_dynamic_list_create_icontext_menu(
        number_of_items,
        get_item_func,
        get_hint_func,
        WGUI_LIST_INVALID_HIGHLIGHT,
        MMI_FALSE,
        UI_dummy_function,
        0,
        0,
        NULL);

    if (wgui_check_application_present)
    {
        application_present = wgui_check_application_present(&max_entries);     /* true in case of dictionary */
    }
    else
    {
        application_present = MMI_FALSE;
    }

    if (application_present)
    {
        /* number of words goes beyond this limit, and increases at the run time */
        set_menu_item_count(max_entries);
        input_type = IMM_INPUT_TYPE_SENTENCE;
        MMI_current_input_ext_type |= INPUT_TYPE_EXT_NO_SHOW_NEW_LINE_SYMBOL;
    }
    else
    {
        set_menu_item_count(number_of_items);
        input_type = IMM_INPUT_TYPE_QUICK_SEARCH;
    }

#ifdef __MMI_TOUCH_SCREEN__
    /* Because the list menu is resized according to virtual keyboard */
    MMI_fixed_list_menu.flags |= UI_LIST_MENU_ALIGN_TO_TOP;
#endif /* __MMI_TOUCH_SCREEN__ */ 

    list_height = UI_device_height - MMI_button_bar_height - MMI_SUBMENU_CONTENT_Y - CAT200_INPUTBOX_H - 2;

    resize_fixed_list(MMI_content_width, list_height);
    move_fixed_list(0, MMI_SUBMENU_CONTENT_Y);
    
    h_flag = set_list_menu_category_history(MMI_CATEGORY200_ID, history_buffer);
#ifdef __MMI_UI_HINTS_IN_MENUITEM__
    if (get_hint_func)
    {
        if (is_set_force_icon_on_highlight_only_in_menuitem())
        {
            wgui_show_icon_only_highlight_in_icontext_menuitem();
        }
        if (is_set_force_all_hints_in_menuitem())
        {
            wgui_enable_hints_in_icontext_menuitem();
        }
        else if (is_set_force_hints_on_highlight_in_menuitem())
        {
            wgui_enable_hint_highlight_in_icontext_menuitem();
        }
        else
        {
            wgui_enable_hint_highlight_in_icontext_menuitem();
        }

        if (history_buffer != NULL)
        {
            set_dynamic_pop_up_descriptions(MMI_fixed_list_menu.highlighted_item);
        }
        else
        {
            set_dynamic_pop_up_descriptions(highlighted_item);
        }

    #ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
        gui_block_list_effect();
    #endif 
    }
#endif /* __MMI_UI_HINTS_IN_MENUITEM__ */ 

    input_box_x = CAT200_INPUTBOX_X;
    input_box_y = MMI_SUBMENU_CONTENT_Y + MMI_fixed_list_menu.height + 1;    
    input_box_width = MAIN_LCD_DEVICE_WIDTH - CAT200_INPUTBOX_X - CAT200_MARGIN_WIDTH - 1 /* border */;

    if (history_buffer != NULL)
    {
        S32 size = sizeof(list_menu_category_history);

        size = (size + 3) / 4;
        size *= 4;
        wgui_inputs_sl_disable_up_down_key_register(MMI_TRUE);

        wgui_inputs_sl_setup_ext(
            input_box_x,
            input_box_y,
            input_box_width,
            CAT200_INPUTBOX_H,
            buffer,
            buffer_max_length,
            MMI_CATEGORY200_ID,
            get_string(right_softkey),
            NULL,
            input_type,
            (U8*) (history_buffer + size),
            0,
            wgui_cat_search_editor_msg_callback);

        list_height -= mmi_imc_get_current_imui_height();
        resize_fixed_list(MMI_content_width, list_height);
        if (history_buffer == NULL)
        {
            dynamic_list_goto_item_no_redraw(MMI_fixed_list_menu.highlighted_item);
        }

        if (cat200_search_function)
        {
            if (!application_present)
            {
                S32 no_entries;

                no_entries = cat200_search_function((U8*) MMI_singleline_inputbox.text);
                load_dynamic_item_buffer(no_entries);
                refresh_search_list_change_list_ext(no_entries, MMI_fixed_list_menu.highlighted_item);
            }
        }
    }
    else /* initial */
    {
        dynamic_list_goto_item_no_redraw(highlighted_item);
        wgui_inputs_sl_disable_up_down_key_register(MMI_TRUE);

        wgui_inputs_sl_setup_ext(
            input_box_x,
            input_box_y,
            input_box_width,
            CAT200_INPUTBOX_H,
            buffer,
            buffer_max_length,
            MMI_CATEGORY200_ID,
            get_string(right_softkey),
            NULL,
            input_type,
            NULL,
            0,
            wgui_cat_search_editor_msg_callback);

    }
#ifndef __MMI_FTE_SUPPORT__
    gui_set_single_line_input_box_theme(&MMI_singleline_inputbox, &cat200_singleline_inputbox_theme);
    cat200_search_img = search_image;
#endif

    resize_dynamic_icontext_menuitems_to_list_width();
    if (h_flag)
    {
        set_dynamic_pop_up_descriptions(MMI_fixed_list_menu.highlighted_item);

        if (application_present)
        {
            if (MMI_fixed_list_menu.highlighted_item <= 0)
            {
                ClearKeyHandler(KEY_UP_ARROW, KEY_EVENT_DOWN);
                ClearKeyHandler(KEY_VOL_UP, KEY_EVENT_DOWN);
            }
        }
    }
    else
    {
        set_dynamic_pop_up_descriptions(highlighted_item);
    }

    singleline_inputbox_input_callback();
    if (!h_flag)
    {
        if ((number_of_items > 0) || ((application_present) && (number_of_items == 0)))
        {
            set_left_softkey_label(wgui_singleline_inputbox_LSK_label_string);
            set_left_softkey_icon(wgui_singleline_inputbox_LSK_label_icon);
            redraw_left_softkey();
            register_left_softkey_handler();
            set_left_softkey_function(wgui_singleline_inputbox_LSK_function, KEY_EVENT_UP);
            set_left_softkey_function(UI_dummy_function, KEY_EVENT_DOWN);
        }
        else
        {
            set_left_softkey_label(NULL);
            set_left_softkey_icon(NULL);
            redraw_left_softkey();
            set_left_softkey_function(UI_dummy_function, KEY_EVENT_UP);
            set_left_softkey_function(UI_dummy_function, KEY_EVENT_DOWN);
        }
    }
    
    register_singleline_inputbox_input_callback(wgui_cat200_editor_change_callback);

    gdi_layer_unlock_frame_buffer();
    ExitCategoryFunction = ExitCategory200Screen;
    dm_setup_category_functions(dm_redraw_category_screen, GetCategory200History, GetCategory200HistorySize);
    dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND;
#ifdef __MMI_TOUCH_SCREEN__
    dm_data.s32flags |= DM_SHOW_VKPAD;
#endif /* __MMI_TOUCH_SCREEN__ */
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32CatId = MMI_CATEGORY200_ID;
    dm_setup_data(&dm_data);
    dm_register_category_controlled_callback(RedrawCategoryControlledArea200Screen);
    
#ifdef __MMI_TOUCH_SCREEN__
    dm_register_vkpad_callback(wgui_cat200_virtual_keypad_callback);
    wgui_register_category_screen_control_area_pen_handlers(Cate200CategoryControlAreaPenDownHandler, MMI_PEN_EVENT_DOWN);
    wgui_register_category_screen_control_area_pen_handlers(Cate200CategoryControlAreaPenUpHandler, MMI_PEN_EVENT_UP);
    wgui_register_category_screen_control_area_pen_handlers(Cate200CategoryControlAreaPenMoveHandler, MMI_PEN_EVENT_MOVE);
    wgui_register_category_screen_control_area_pen_handlers(Cate200CategoryControlAreaPenLongTapHandler, MMI_PEN_EVENT_LONG_TAP);
    wgui_register_category_screen_control_area_pen_handlers(Cate200CategoryControlAreaPenRepeatHandler, MMI_PEN_EVENT_REPEAT);
#endif /* __MMI_TOUCH_SCREEN__ */ 

#if defined(__MMI_VIRTUAL_KEYBOARD__)
    wgui_virtual_keyboard_register_hide_cursor_callback(wgui_cat_stop_pop_up_description_scroll);
    wgui_virtual_keyboard_register_blink_cursor_callback(wgui_cat_resume_pop_up_description_scroll);
    wgui_icon_bar_register_resume_interactive_UI_callback(wgui_cat_resume_pop_up_description_scroll);
#endif
    dm_redraw_category_screen();
}


/*****************************************************************************
 * FUNCTION
 *  ShowCategory200Screen_ext
 * DESCRIPTION
 *  Show Category200 screen (phonebook quick search)
 * PARAMETERS
 *  title                   [IN]        Title id
 *  title_icon              [IN]        Title icon
 *  left_softkey            [IN]        Left soft key label
 *  left_softkey_icon       [IN]        Left soft key icon
 *  right_softkey           [IN]        Right soft key label
 *  right_softkey_icon      [IN]        Right soft key icon
 *  number_of_items         [IN]        Number of items
 *  get_item_func           [IN]        Callback function of get menu item 
 *  get_hint_func           [IN]        Callback function of get menu item hint
 *  highlighted_item        [IN]        Highlighted item index
 *  search_image            [IN]        Seach image in input area
 *  left_icon               [IN]        Menuitme left icon 
 *  right_icon              [IN]        Menuitme right icon 
 *  buffer                  [IN]        Buffer
 *  buffer_max_length       [IN]        Buffer max length
 *  history_buffer          [IN]        Histpry buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory200Screen_ext_int(
        U16 title,
        U16 title_icon,
        U16 left_softkey,
        U16 right_softkey,
        S32 number_of_items,
        GetAsyncItemFuncPtr get_item_func,
        GetAsyncHintFuncPtr get_hint_func,
        S32 highlighted_item,
        U16 search_image,
        PU8 left_icon,
        PU8 right_icon,
        U8 *buffer,
        S32 buffer_max_length,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;
    S32 input_box_width = 0, list_height = 0, max_entries = 0;
    U8 h_flag;
    BOOL application_present;
    U32 input_type;
    S32 left_icon_w = 0, left_icon_h = 0, right_icon_w = 0, right_icon_h = 0, attachment_icon_w = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();
    if (history_buffer != NULL) 
    {
        list_menu_category_history *h = (list_menu_category_history*) history_buffer;
        if(!number_of_items)
        {
            number_of_items = h->num_items;
        }     
    }
#ifdef __MMI_PHONEBOOK_LIST_THUMBNAIL__
    wgui_cat_thumbnail_init(number_of_items);
#endif
#ifdef  MMI_CATEGORIES_SUPPORT_EDITOR_INFO_BAR   
    dm_add_softkey_str(get_string(left_softkey), get_string(right_softkey));
#else /*MMI_CATEGORIES_SUPPORT_EDITOR_INFO_BAR*/
    ShowListCategoryScreen_ext(
        get_string(title),
        get_image(title_icon),
        get_string(left_softkey),
        get_string(right_softkey));
#endif /*MMI_CATEGORIES_SUPPORT_EDITOR_INFO_BAR*/
	wgui_singleline_inputbox_LSK_label_icon = NULL;
    wgui_singleline_inputbox_LSK_label_string = get_string(left_softkey);

    g_wgui_cat200_resize_and_move_func = wgui_cat200_resize_and_move;

#ifndef __MMI_FTE_SUPPORT__
    g_wgui_cat200_draw_information_bar_func = wgui_cat199_draw_input_method;
#endif

    dynamic_item_text_align_left = TRUE;
    
    g_wgui_cat_is_async_dynamic_list = MMI_TRUE;
    wgui_async_list_create_multi_icontext_menu(
        number_of_items,
        1,
        2,
        get_item_func,
        get_hint_func,
        highlighted_item,
        MMI_MENUITEM_HEIGHT,
        0,
        0,
        NULL);

#ifdef __MMI_PHONEBOOK_LIST_THUMBNAIL__
    set_fixed_icontext_list_menuitems_post_display(wgui_cat_thumbnail_post_display_callback);
#endif

    /* set the icon/text position */
    if (left_icon != NULL)
    {
        gui_measure_image(left_icon, &left_icon_w, &left_icon_h);
    }
    if (right_icon != NULL)
    {
        gui_measure_image(right_icon, &right_icon_w, &right_icon_h);
    }

#if defined(__MMI_PHONEBOOK_LIST_THUMBNAIL__)
    if (g_wgui_cat199_get_attachment_icon_filepath || g_wgui_cat199_get_attachment_icon_buffer)
    {
        attachment_icon_w = WGUI_CAT199_IMAGE_WIDTH;
    }
#endif

    set_fixed_icontext_list_icon_coordinates(
        0, 
        WGUI_CAT199_GAP_1,
        0,
        left_icon_w, 
        MMI_ICONTEXT_MENUITEM_HEIGHT);
    set_fixed_icontext_list_icon_coordinates(
        1, 
        MMI_fixed_list_menu.width - MMI_fixed_list_menu.vbar.width - WGUI_CAT199_GAP_4 - right_icon_w, 
        0, 
        right_icon_w, 
        MMI_ICONTEXT_MENUITEM_HEIGHT);
    set_fixed_icontext_list_text_coordinates(
        0, 
        WGUI_CAT199_GAP_1 + left_icon_w + WGUI_CAT199_GAP_2, 
        0,
        MMI_fixed_list_menu.width - MMI_fixed_list_menu.vbar.width  - left_icon_w - right_icon_w - WGUI_CAT199_GAP_1 - WGUI_CAT199_GAP_2 - WGUI_CAT199_GAP_3 - WGUI_CAT199_GAP_4 - attachment_icon_w, 
        MMI_ICONTEXT_MENUITEM_HEIGHT);

    MMI_fixed_icontext_list_menuitem.flags |= UI_MENUITEM_CENTER_TEXT_Y;
    g_wgui_cat200_set_special_key_func = wgui_cat200_set_left_and_right_arrow_key;

    if (wgui_check_application_present)
    {
        application_present = wgui_check_application_present(&max_entries);     /* true in case of dictionary */
    }
    else
    {
        application_present = MMI_FALSE;
    }

    if (application_present)
    {
        /* number of words goes beyond this limit, and increases at the run time */
        set_menu_item_count(max_entries);
        input_type = IMM_INPUT_TYPE_SENTENCE;
        MMI_current_input_ext_type |= INPUT_TYPE_EXT_NO_SHOW_NEW_LINE_SYMBOL;
    }
    else
    {
        set_menu_item_count(number_of_items);
        input_type = IMM_INPUT_TYPE_QUICK_SEARCH;
    }

#ifdef __MMI_TOUCH_SCREEN__
    /* Because the list menu is resized according to virtual keyboard */
    MMI_fixed_list_menu.flags |= UI_LIST_MENU_ALIGN_TO_TOP;
#endif /* __MMI_TOUCH_SCREEN__ */ 

#ifdef __MMI_ICON_BAR_SUPPORT__
#ifdef __MMI_FTE_SUPPORT__
    if (wgui_icon_bar_is_created())
    {
        list_height = UI_device_height - MMI_button_bar_height - MMI_SUBMENU_CONTENT_Y - CAT200_INPUTBOX_H - 2 - MMI_ICON_BAR_HEIGHT;
    }
    else
#endif /* __MMI_FTE_SUPPORT__ */
#endif /*__MMI_ICON_BAR_SUPPORT__*/
    {
        list_height = UI_device_height - MMI_button_bar_height - MMI_SUBMENU_CONTENT_Y - CAT200_INPUTBOX_H - 2;
    }

#ifdef MMI_CATEGORIES_SUPPORT_EDITOR_INFO_BAR
    list_height =UI_device_height - MMI_button_bar_height - INFO_HIGHT - CAT200_INPUTBOX_H - 2;    
#endif/*MMI_CATEGORIES_SUPPORT_EDITOR_INFO_BAR*/
    resize_fixed_list(MMI_content_width, list_height);
    move_fixed_list(0, MMI_SUBMENU_CONTENT_Y);
#ifdef MMI_CATEGORIES_SUPPORT_EDITOR_INFO_BAR
    move_fixed_list(0, INFO_HIGHT);    
#endif/*MMI_CATEGORIES_SUPPORT_EDITOR_INFO_BAR*/ 
    
    h_flag = set_list_menu_category_history(MMI_CATEGORY200_ID, history_buffer);
#ifdef __MMI_UI_HINTS_IN_MENUITEM__
    if (get_hint_func)
    {
        if (is_set_force_icon_on_highlight_only_in_menuitem())
        {
            wgui_show_icon_only_highlight_in_icontext_menuitem();
        }
        if (is_set_force_all_hints_in_menuitem())
        {
            wgui_enable_hints_in_icontext_menuitem();
        }
        else if (is_set_force_hints_on_highlight_in_menuitem())
        {
            wgui_enable_hint_highlight_in_icontext_menuitem();
        }
        else
        {
            wgui_enable_hint_highlight_in_icontext_menuitem();
        }

        if (history_buffer != NULL)
        {
            set_asyncdynamic_pop_up_descriptions(MMI_fixed_list_menu.highlighted_item);
        }
        else
        {
            set_asyncdynamic_pop_up_descriptions(highlighted_item);
        }

    #ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
        gui_block_list_effect();
    #endif 
    }
#endif /* __MMI_UI_HINTS_IN_MENUITEM__ */ 

    input_box_x = CAT200_INPUTBOX_X;
    input_box_y = MMI_SUBMENU_CONTENT_Y + MMI_fixed_list_menu.height + 1;    
#ifdef MMI_CATEGORIES_SUPPORT_EDITOR_INFO_BAR
    //input_box_y = INFO_HIGHT + MMI_fixed_list_menu.height + 1;
    input_box_y = MAIN_LCD_DEVICE_HEIGHT - MMI_BUTTON_BAR_HEIGHT - CAT200_INPUTBOX_H - 1;
#endif/*MMI_CATEGORIES_SUPPORT_EDITOR_INFO_BAR*/ 
    input_box_width = MAIN_LCD_DEVICE_WIDTH - CAT200_INPUTBOX_X - CAT200_MARGIN_WIDTH - 1 /* border */;

    if (history_buffer != NULL)
    {
        S32 size = sizeof(list_menu_category_history);

        size = (size + 3) / 4;
        size *= 4;
        wgui_inputs_sl_disable_up_down_key_register(MMI_TRUE);

        wgui_inputs_sl_setup_ext(
            input_box_x,
            input_box_y,
            input_box_width,
            CAT200_INPUTBOX_H,
            buffer,
            buffer_max_length,
            MMI_CATEGORY200_ID,
            get_string(right_softkey),
            NULL,
            input_type,
            (U8*) (history_buffer + size),
            0,
            wgui_cat_search_editor_msg_callback);

        list_height -= mmi_imc_get_current_imui_height();
#ifdef __MMI_ICON_BAR_SUPPORT__
    #if defined (__MMI_FTE_SUPPORT__) && defined (__MMI_TOUCH_SCREEN__)
        if (wgui_icon_bar_is_created())
        {
            list_height += MMI_ICON_BAR_HEIGHT + MMI_button_bar_height;
        }
        else
        {
            list_height += MMI_button_bar_height;
        }
    #endif /* __MMI_FTE_SUPPORT__ */
#endif /*__MMI_ICON_BAR_SUPPORT__*/	
        resize_fixed_list(MMI_content_width, list_height);
        if (history_buffer == NULL)
        {
            if (g_wgui_cat_is_async_dynamic_list)
            {
                asyncdynamic_list_goto_item_no_redraw(MMI_fixed_list_menu.highlighted_item);
            }
            else
            {
                dynamic_list_goto_item_no_redraw(MMI_fixed_list_menu.highlighted_item);
            }
        }

        if (cat200_search_function)
        {
            if (!application_present)
            {
                S32 no_entries;

                no_entries = cat200_search_function((U8*) MMI_singleline_inputbox.text);
                //load_dynamic_item_buffer(no_entries);
                refresh_search_list_change_list_ext(no_entries, MMI_fixed_list_menu.highlighted_item);
            }
        }
    }
    else /* initial */
    {
        if (g_wgui_cat_is_async_dynamic_list)
        {
            asyncdynamic_list_goto_item_no_redraw(highlighted_item);
        }
        else
        {
            dynamic_list_goto_item_no_redraw(highlighted_item);
        }
        
        wgui_inputs_sl_disable_up_down_key_register(MMI_TRUE);

        wgui_inputs_sl_setup_ext(
            input_box_x,
            input_box_y,
            input_box_width,
            CAT200_INPUTBOX_H,
            buffer,
            buffer_max_length,
            MMI_CATEGORY200_ID,
            get_string(right_softkey),
            NULL,
            input_type,
            NULL,
            0,
            wgui_cat_search_editor_msg_callback);

    }
#ifndef __MMI_FTE_SUPPORT__
    gui_set_single_line_input_box_theme(&MMI_singleline_inputbox, &cat200_singleline_inputbox_theme);
    cat200_search_img = search_image;
#endif

    //resize_dynamic_icontext_menuitems_to_list_width();
    resize_asyncdynamic_icontext_menuitems_to_list_width();

    if (h_flag)
    {
        set_asyncdynamic_pop_up_descriptions(MMI_fixed_list_menu.highlighted_item);

        if (application_present)
        {
            if (MMI_fixed_list_menu.highlighted_item <= 0)
            {
                ClearKeyHandler(KEY_UP_ARROW, KEY_EVENT_DOWN);
                ClearKeyHandler(KEY_VOL_UP, KEY_EVENT_DOWN);
            }
        }
    }
    else
    {
        set_asyncdynamic_pop_up_descriptions(highlighted_item);
    }

    singleline_inputbox_input_callback();
    if (!h_flag)
    {
        if ((number_of_items > 0) || ((application_present) && (number_of_items == 0)))
        {
            set_left_softkey_label(wgui_singleline_inputbox_LSK_label_string);
            set_left_softkey_icon(wgui_singleline_inputbox_LSK_label_icon);
            redraw_left_softkey();
            register_left_softkey_handler();
            set_left_softkey_function(wgui_singleline_inputbox_LSK_function, KEY_EVENT_UP);
            set_left_softkey_function(UI_dummy_function, KEY_EVENT_DOWN);
        }
        else
        {
            set_left_softkey_label(NULL);
            set_left_softkey_icon(NULL);
            redraw_left_softkey();
            set_left_softkey_function(UI_dummy_function, KEY_EVENT_UP);
            set_left_softkey_function(UI_dummy_function, KEY_EVENT_DOWN);
        }
    }
    
    register_singleline_inputbox_input_callback(wgui_cat200_editor_change_callback);

    gdi_layer_unlock_frame_buffer();
    ExitCategoryFunction = ExitCategory200Screen;
    dm_setup_category_functions(dm_redraw_category_screen, GetCategory200History, GetCategory200HistorySize);
    dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND;
#ifdef __MMI_TOUCH_SCREEN__
    dm_data.s32flags |= DM_SHOW_VKPAD;
#endif /* __MMI_TOUCH_SCREEN__ */
#ifdef MMI_CATEGORIES_SUPPORT_EDITOR_INFO_BAR
    dm_data.s32flags |= DM_NO_TITLE|DM_NO_STATUS_BAR;   
#endif/*MMI_CATEGORIES_SUPPORT_EDITOR_INFO_BAR*/ 
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32CatId = MMI_CATEGORY200_ID;
    dm_setup_data(&dm_data);
    dm_register_category_controlled_callback(RedrawCategoryControlledArea200Screen);
    
#ifdef __MMI_TOUCH_SCREEN__
    dm_register_vkpad_callback(wgui_cat200_virtual_keypad_callback);
    wgui_register_category_screen_control_area_pen_handlers(Cate200CategoryControlAreaPenDownHandler, MMI_PEN_EVENT_DOWN);
    wgui_register_category_screen_control_area_pen_handlers(Cate200CategoryControlAreaPenUpHandler, MMI_PEN_EVENT_UP);
    wgui_register_category_screen_control_area_pen_handlers(Cate200CategoryControlAreaPenMoveHandler, MMI_PEN_EVENT_MOVE);
    wgui_register_category_screen_control_area_pen_handlers(Cate200CategoryControlAreaPenLongTapHandler, MMI_PEN_EVENT_LONG_TAP);
    wgui_register_category_screen_control_area_pen_handlers(Cate200CategoryControlAreaPenRepeatHandler, MMI_PEN_EVENT_REPEAT);
#endif /* __MMI_TOUCH_SCREEN__ */ 

#if defined(__MMI_VIRTUAL_KEYBOARD__)
    wgui_virtual_keyboard_register_hide_cursor_callback(wgui_cat_stop_pop_up_description_scroll);
    wgui_virtual_keyboard_register_blink_cursor_callback(wgui_cat_resume_pop_up_description_scroll);
    wgui_icon_bar_register_resume_interactive_UI_callback(wgui_cat_resume_pop_up_description_scroll);
#endif

    dm_redraw_category_screen();
    wgui_fixed_list_set_alpha_blending_layer(dm_get_scr_bg_layer());

#ifdef __MMI_PHONEBOOK_LIST_THUMBNAIL__
    wgui_cat_thumbnail_post_init(number_of_items);
#endif

}


#if  defined(__MMI_TOUCH_SCREEN__)
#if (defined (__MMI_MAINLCD_240X320__))
#define WGUI_CAT199_SEARCH_BUTTON_GAP_L              (5)
#define WGUI_CAT199_SEARCH_BUTTON_GAP_R              (3)
#elif (defined (__MMI_MAINLCD_240X400__))
#define WGUI_CAT199_SEARCH_BUTTON_GAP_L              (5)
#define WGUI_CAT199_SEARCH_BUTTON_GAP_R              (3)
#elif (defined (__MMI_MAINLCD_320X480__))
#define WGUI_CAT199_SEARCH_BUTTON_GAP_L              (6)
#define WGUI_CAT199_SEARCH_BUTTON_GAP_R              (8)
#else
#define WGUI_CAT199_SEARCH_BUTTON_GAP_L              (0)
#define WGUI_CAT199_SEARCH_BUTTON_GAP_R              (0)
#endif

U16 g_wgui_cat199_search_button_id = 0;
PU8 g_wgui_cat199_search_button_up_image = NULL;
PU8 g_wgui_cat199_search_button_down_image = NULL;
FuncPtr g_wgui_cat199_search_button_function = NULL;


/*****************************************************************************
 * FUNCTION
 *  wgui_cat199_setup_search_button
 * DESCRIPTION
 *  Setup the search button of category199.
 * PARAMETERS
 *  up_image   :       [IN] (N/A) the normal status image of search button.
 *  down_image :       [IN] (N/A) the press-down status image of search button.
 *  search_function :  [IN] (N/A) search function.
 * RETURNS
 *  void.
 *****************************************************************************/
void wgui_cat199_setup_search_button(PU8 up_image, PU8 down_image, FuncPtr search_function)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_wgui_cat199_search_button_up_image = up_image;
    g_wgui_cat199_search_button_down_image = down_image;
    g_wgui_cat199_search_button_function = search_function;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat199_clear_search_button_bg
 * DESCRIPTION
 *  clear button area.
 * PARAMETERS
 *  button   [IN]   button information
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat199_clear_search_button_bg(void *button)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    icontext_button *b = (icontext_button*) button;
    S32 x1 = b->x;
    S32 y1 = b->y;
    S32 x2 = b->x + b->width - 1;
    S32 y2 = b->y + b->height - 1;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer(); 

    /* draw the background */  
    //gui_draw_filled_area(x1, y1, x2 + 1, y2 + 1, (current_MMI_theme->singleline_editor_bg_filler));
    wgui_category_clear_region_with_transparent_color(x1, y1, x2 + 1, y2 + 1);

    gdi_layer_unlock_frame_buffer();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat199_search_button_draw_down
 * DESCRIPTION
 *  draw pen down of button
 * PARAMETERS
 *  button_object       [IN]        The target button
 * RETURNS
 *  void
 *****************************************************************************/
static MMI_BOOL wgui_cat199_search_button_draw_down(void *button_object)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    icontext_button *current_bt;
    GDI_HANDLE act_layer = GDI_NULL_HANDLE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    current_bt = dm_get_button(g_wgui_cat199_search_button_id);
    
    if (button_object != (void*)current_bt)
    {
        return MMI_TRUE;
    }
    
    mmi_imc_reset_ime_state();
    
    gdi_layer_get_active(&act_layer);
    
    if (act_layer != GDI_NULL_HANDLE)
    {
        gdi_push_and_set_alpha_blending_source_layer(dm_get_scr_bg_layer());
    }
    gui_icontext_button_show_down_by_pen((void*)current_bt);
    if (act_layer != GDI_NULL_HANDLE)
    {
        gdi_pop_and_restore_alpha_blending_source_layer();
    }
    return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat199_search_button_draw_up
 * DESCRIPTION
 *  draw pen up of button
 * PARAMETERS
 *  button_object       [IN]        The target button
 * RETURNS
 *  void
 *****************************************************************************/
static MMI_BOOL wgui_cat199_search_button_draw_up(void *button_object)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    icontext_button *current_bt;
    GDI_HANDLE act_layer = GDI_NULL_HANDLE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    current_bt = dm_get_button(g_wgui_cat199_search_button_id);
    
    if (button_object != (void*)current_bt)
    {
        return MMI_TRUE;
    }
    
    gdi_layer_get_active(&act_layer);
    
    if (act_layer != GDI_NULL_HANDLE)
    {
        gdi_push_and_set_alpha_blending_source_layer(dm_get_scr_bg_layer());
    }
    gui_icontext_button_show_up_by_pen((void*)current_bt);
    if (act_layer != GDI_NULL_HANDLE)
    {
        gdi_pop_and_restore_alpha_blending_source_layer();
    }
    return MMI_TRUE;

}
#endif /* __MMI_TOUCH_SCREEN__ */


#if defined(__MMI_MAINLCD_128X128__)
UI_filled_area g_cat199_inputbox_BG_filler = 
{
    UI_FILLED_AREA_TYPE_COLOR,
    UI_NULL_IMAGE,
    NULL,
    {180, 180, 180, 100},   /* gray because no black frame */
    {0, 0, 0, 0},
    {180, 180, 180, 100},
    {180, 180, 180, 100},
    0
};
#else  /* defined(__MMI_MAINLCD_128X128__) */
UI_filled_area g_cat199_inputbox_BG_filler = 
{
    UI_FILLED_AREA_TYPE_COLOR,
    UI_NULL_IMAGE,
    NULL,
    {255, 255, 255, 100},
    {0, 0, 0, 0},
    {255, 255, 255, 100},
    {255, 255, 255, 100},
    0
};
#endif /* defined(__MMI_MAINLCD_128X128__) */


UI_single_line_input_box_theme g_cat199_singleline_inputbox_theme = { 
    &g_cat199_inputbox_BG_filler,
    &g_cat199_inputbox_BG_filler,
    &g_cat199_inputbox_BG_filler,
    {0, 0, 0, 100},
    {128, 128, 128, 100},
    {0, 0, 0, 100},
    {255, 255, 255, 100},
    {51, 88, 171, 100},
    {255, 0, 0, 100},
    &UI_DEFAULT_FONT,
    1,
    UI_SINGLE_LINE_INPUT_BOX_CENTER_Y,
    '*'
};


/*****************************************************************************
 * FUNCTION
 *  wgui_cat199_set_left_and_right_arrow_key
 * DESCRIPTION
 *  Because IME will register left and right arrow key and will not restore it
 *   so category should restore left and right arrow key by ourselves.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat199_set_left_and_right_arrow_key(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
        
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    SetKeyHandler(mmi_frm_general_tab_l_arrow_key_hdlr, KEY_LEFT_ARROW, KEY_EVENT_DOWN);
    SetKeyHandler(mmi_frm_general_tab_r_arrow_key_hdlr, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
    if (g_wgui_cat_is_async_dynamic_list)
    {
       register_asyncdynamic_list_keys();
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat199_draw_input_method
 * DESCRIPTION
 *  draw input method in the end of singleline inputbox
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat199_draw_input_method(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#ifndef __MMI_FTE_SUPPORT__
	S32 x1 = 0, y1 = 0, x2 = 0, y2 = 0, sl_w = 0, sl_x = 0;
    U32 ime_w = 0;
#endif /* __MMI_FTE_SUPPORT__ */  
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
#ifndef __MMI_FTE_SUPPORT__
    gdi_layer_lock_frame_buffer();
	gdi_layer_push_clip();

    gdi_layer_set_clip(
        0, 
        MMI_singleline_inputbox.y,
        UI_device_width - 1,
        MMI_singleline_inputbox.y + MMI_singleline_inputbox.height - 1);

    ime_w = mmi_imc_get_input_mode_hint_width();

//     if (r2lMMIFlag)
//     {
//         y1 = MMI_singleline_inputbox.y;
//         y2 = MMI_singleline_inputbox.y + MMI_singleline_inputbox.height - 1;
//         x1 = CAT199_MARGIN_WIDTH + 1;        
//         x2 = x1 + ime_w - 1;
//         sl_w = UI_device_width - (CAT199_MARGIN_WIDTH << 1) - x2;
//         sl_x = x2 + 1;
//     }
//     else
    {
        x2 = UI_device_width - CAT199_MARGIN_WIDTH - 1;
        y1 = MMI_singleline_inputbox.y;
        y2 = MMI_singleline_inputbox.y + MMI_singleline_inputbox.height - 1;
        ime_w = mmi_imc_get_input_mode_hint_width();
        x1 = x2 - ime_w + 1;
        sl_w = x1 - MMI_singleline_inputbox.x + 1;
        if (get_image(cat200_search_img) != NULL)
        {
            sl_x = MMI_singleline_inputbox.x;
        }
        else
        {
            sl_x = CAT199_MARGIN_WIDTH + 1;
        }
    }

    /* draw IME background */ 
    gui_fill_rectangle(x1, y1, x2, y2, /*gui_color(255,0,0));*/ MMI_singleline_inputbox.normal_filler->c);

    mmi_imc_draw_input_mode_hint(x1, y1, x2, y2);

    if (MMI_singleline_inputbox.width != sl_w || MMI_singleline_inputbox.x != x1)
    {
        wgui_inputs_sl_resize(sl_w, MMI_singleline_inputbox.height);
        wgui_inputs_sl_move(sl_x, MMI_singleline_inputbox.y);
        wgui_inputs_sl_redraw();
    }
    
	gdi_layer_pop_clip();
    gdi_layer_unlock_frame_buffer();
    gdi_layer_blt_previous(0, 0, UI_device_width - 1, UI_device_height - 1);
#endif /* __MMI_FTE_SUPPORT__ */  
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat199_resize_and_move
 * DESCRIPTION
 *  resize and move list & singleline inputbox
 * PARAMETERS
 *  inputbox_y   [IN]   singleline inputbox y position
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat199_resize_and_move(S32 inputbox_y)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 menu_h = 0;
    S32 first_item, last_item;
#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
    extern S32 gblock_list_effect;
    S32 temp;
#endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */ 
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
    temp = gblock_list_effect;
    gblock_list_effect = 1;
#endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */ 

#if defined(__MMI_MAINLCD_128X128__)
    menu_h = inputbox_y - MMI_fixed_list_menu.y;
#else
    inputbox_y -= 1; /* button border */
    menu_h = inputbox_y - MMI_fixed_list_menu.y - 1 /* up border */;
#endif /* defined(__MMI_MAINLCD_128X128__) */
    resize_fixed_list(MMI_fixed_list_menu.width, menu_h);

    if (g_wgui_cat_is_async_dynamic_list)
    {
        if (MMI_fixed_list_menu.n_items > 0)
        {
            gui_asyncdynamic_list_menu_locate_highlighted_item(&MMI_fixed_list_menu);
        }
    }
    else
    {
        gui_dynamic_list_menu_locate_highlighted_item(&MMI_fixed_list_menu);
    }

    first_item = MMI_fixed_list_menu.first_displayed_item;
    last_item = MMI_fixed_list_menu.last_displayed_item;

    if (g_wgui_cat_is_async_dynamic_list)
    {
        asyncdynamic_list_goto_item_no_redraw(MMI_fixed_list_menu.highlighted_item);
    }
    else
    {
        dynamic_list_goto_item_no_redraw(MMI_fixed_list_menu.highlighted_item);
    }

    MMI_fixed_list_menu.first_displayed_item = first_item;
    MMI_fixed_list_menu.last_displayed_item = last_item;
    wgui_inputs_sl_move(MMI_singleline_inputbox.x, inputbox_y);

#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
    gblock_list_effect = temp;
#endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */ 
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat_set_search_icon
 * DESCRIPTION
 *  set the search icon.
 * PARAMETERS
 *  search_image   [IN]   search image ID
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat_set_search_icon(U16 search_image)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    cat200_search_img = search_image;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat199_redraw_controlled_area
 * DESCRIPTION
 *  redraw category199 controlled area
 *   1. dynamic list
 *   2. input method
 *   3. singleline inputbox
 * PARAMETERS
 *  coordinate   [IN]   control area coordinate (not used)
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat199_redraw_controlled_area(dm_coordinates *coordinate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    color ccblack = {0, 0, 0, 100};    
    S32 temp_w = 0, temp_h = 0, image_x = 0, image_y = 0, tab_h = 0, scrolltext_h = 0;
    S32 input_box_x = 0, input_box_y = 0, input_box_w = 0;
        
#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
    extern S32 gblock_list_effect;
    S32 temp;
#endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */ 

#ifdef __MMI_TOUCH_SCREEN__
    icontext_button *search_bt;
    S32 bt_w, bt_h;
    //gdi_handle cat199_active_layer;
#endif /* __MMI_TOUCH_SCREEN__ */

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(coordinate);
    gdi_layer_lock_frame_buffer();

    gui_reset_clip();
    gdi_layer_reset_clip();

#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
    temp = gblock_list_effect;
    gblock_list_effect = 1;
#endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */ 

    if (g_wgui_cat_is_async_dynamic_list)
    {
        wgui_async_list_show_multi_icontext_menu();
    }
    else
    {
        /* list */
        if ((MMI_fixed_list_menu.n_items > 0) && (g_wgui_cat199_menuitem_stop_scrolling))
        {
            gui_fixed_icontext_menuitem_stop_scroll();
            gui_fixed_icontext_menuitem_start_scroll();
            gui_pop_up_description_stop_scroll();
        }

        show_dynamic_list();
    }

#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
    gblock_list_effect = temp;
#endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */ 

    gui_reset_clip();

#if defined(__MMI_TOUCH_SCREEN__)
#if defined(__MMI_MAINLCD_128X128__) || (defined(__MMI_MAINLCD_320X240__) && defined(__MMI_VIRTUAL_KEYBOARD__)) || (defined(__MMI_MAINLCD_320X240__) && defined(__MMI_FTE_SUPPORT__))
    tab_h = MMI_HORIZONTAL_TAB_BAR_TAB_AREA_HEIGHT;
#else
    tab_h = MMI_HORIZONTAL_TAB_BAR_TAB_AREA_HEIGHT + MMI_HORIZONTAL_TAB_BAR_HINT_AREA_HEIGHT;
    if (g_dm_data.s32CatId ==  MMI_CATEGORY199_SCROLLTEXT_ID)
    {
        scrolltext_h = CAT202_SCROLL_HEIGHT;
    }
#endif /* defined(__MMI_MAINLCD_128X128__) */
    /* clear background of input area*/
    input_box_y = MMI_HORIZONTAL_TAB_BAR_Y + tab_h + scrolltext_h + MMI_fixed_list_menu.height + 1;
    gdi_draw_solid_rect(0, input_box_y - 1, UI_device_width - 1, input_box_y + CAT199_INPUTBOX_H, GDI_COLOR_TRANSPARENT);
#endif /* defined(__MMI_TOUCH_SCREEN__) */ 

    wgui_cat199_draw_input_method();

#if defined(__MMI_MAINLCD_128X128__) || (defined(__MMI_MAINLCD_320X240__) && defined(__MMI_VIRTUAL_KEYBOARD__)) || (defined(__MMI_MAINLCD_320X240__) && defined(__MMI_FTE_SUPPORT__))
    tab_h = MMI_HORIZONTAL_TAB_BAR_TAB_AREA_HEIGHT;
#else
    tab_h = MMI_HORIZONTAL_TAB_BAR_TAB_AREA_HEIGHT + MMI_HORIZONTAL_TAB_BAR_HINT_AREA_HEIGHT;
#endif /* defined(__MMI_MAINLCD_128X128__) */
    input_box_y = MMI_HORIZONTAL_TAB_BAR_Y + tab_h + scrolltext_h + MMI_fixed_list_menu.height + 1;

/* draw black frame of input area */
#if !defined(__MMI_MAINLCD_128X128__)
#ifndef __MMI_FTE_SUPPORT__
    gui_draw_rectangle(
        CAT199_MARGIN_WIDTH,
        input_box_y - 1,
        UI_device_width - CAT199_MARGIN_WIDTH,
        input_box_y + CAT199_INPUTBOX_H,
        ccblack);
#endif
#endif /* !defined(__MMI_MAINLCD_128X128__) */

#ifndef __MMI_FTE_SUPPORT__
    if (cat200_search_img)
    {
        gui_measure_image(get_image(cat200_search_img), &temp_w, &temp_h);
        image_x = CAT200_MARGIN_WIDTH + 2;
        image_y = ((CAT200_INPUTBOX_H >> 1) - (temp_h >> 1));
        input_box_x = CAT200_INPUTBOX_X;
        input_box_y = MMI_singleline_inputbox.y;
        input_box_w = UI_device_width - CAT199_MARGIN_WIDTH - mmi_imc_get_input_mode_hint_width() - input_box_x + 1;
        
        wgui_inputs_sl_move(input_box_x, input_box_y);
        wgui_inputs_sl_resize(input_box_w, MMI_singleline_inputbox.height);

        gui_fill_rectangle(CAT200_MARGIN_WIDTH + 1, input_box_y, input_box_x, input_box_y + CAT200_INPUTBOX_H - 1, MMI_singleline_inputbox.normal_filler->c);
        gui_show_image(CAT200_MARGIN_WIDTH + 2, (input_box_y + image_y), get_image(cat200_search_img));
    }
#endif

#ifdef __MMI_TOUCH_SCREEN__
    if (g_wgui_cat199_search_button_function)
    {
        search_bt = dm_get_button(g_wgui_cat199_search_button_id);
        gdi_image_get_dimension(g_wgui_cat199_search_button_up_image, &bt_w, &bt_h);
        if ((bt_w > 0) && (bt_h > 0))
        {
            gui_move_icontext_button(
                search_bt, 
                UI_device_width - WGUI_CAT199_SEARCH_BUTTON_GAP_L - WGUI_CAT199_SEARCH_BUTTON_GAP_R- bt_w,
                MMI_singleline_inputbox.y + (((MMI_SINGLELINE_INPUTBOX_HEIGHT) - (bt_h)) >> 1));
            gui_resize_icontext_button(search_bt, bt_w, bt_h);
            gui_icontext_button_overwirte_pen_response_area(
                search_bt,
                search_bt->x,
                search_bt->y,
                search_bt->x + search_bt->width,
                search_bt->y + search_bt->height);

            /* show search button */
            //gdi_layer_get_active(&cat199_active_layer);
            //gdi_push_and_set_alpha_blending_source_layer(cat199_active_layer);
            gui_show_icontext_button(search_bt);
            //gdi_pop_and_restore_alpha_blending_source_layer();

            /* show the singleline inputbox */
            wgui_inputs_sl_resize(
                MMI_SINGLELINE_INPUTBOX_WIDTH - WGUI_CAT199_SEARCH_BUTTON_GAP_L - WGUI_CAT199_SEARCH_BUTTON_GAP_R - bt_w,
                MMI_singleline_inputbox.height);
            wgui_inputs_sl_show();
        }
    }
    else
#endif /* __MMI_TOUCH_SCREEN__ */
    {
        wgui_inputs_sl_redraw(); 
    }

    gdi_layer_unlock_frame_buffer();
    gdi_layer_blt_previous(0, 0, UI_device_width - 1, UI_device_height - 1);

#if defined(__MMI_VIRTUAL_KEYBOARD__)
    wgui_virtual_keyboard_register_hide_cursor_callback(wgui_cat_stop_pop_up_description_scroll);
    wgui_virtual_keyboard_register_blink_cursor_callback(wgui_cat_resume_pop_up_description_scroll);
#endif
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat199_refresh_search_list
 * DESCRIPTION
 *  refresh category199 search list
 * PARAMETERS
 *  no_entries         [IN]   number of menu item
 *  highlighted_item   [IN]   highlight item
 *  has_tab_title      [IN]   if tab has title
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat199_refresh_search_list(S32 no_entries, S32 highlighted_item, BOOL has_tab_title)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 max_entries = 0;
    BOOL showOption, application_present;
    S32 first_item, last_item;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_fixed_list_menu.highlighted_item = highlighted_item;
    MMI_fixed_list_menu.n_items = no_entries;
    MMI_fixed_list_menu.displayed_items = no_entries;

    application_present = MMI_FALSE;

    if (has_tab_title == TRUE)
    {
        set_menu_item_count(no_entries);
    }
    showOption = no_entries > 0 ? MMI_TRUE : MMI_FALSE;

    if (showOption)
    {
        set_left_softkey_label(wgui_singleline_inputbox_LSK_label_string);
        set_left_softkey_icon(wgui_singleline_inputbox_LSK_label_icon);
        //redraw_left_softkey();
        register_left_softkey_handler();
        set_left_softkey_function(wgui_singleline_inputbox_LSK_function, KEY_EVENT_UP);
        set_left_softkey_function(UI_dummy_function, KEY_EVENT_DOWN);
        first_item = MMI_fixed_list_menu.first_displayed_item;
        last_item = MMI_fixed_list_menu.last_displayed_item;

        if (g_wgui_cat_is_async_dynamic_list)
        {
            if (no_entries == 0)
            {
                gui_fixed_icontext_list_menuitem_stop_scroll();
                gui_pop_up_description_stop_scroll();
            }
            init_asyncdynamic_item_buffer(no_entries, asyncdynamic_item_buffer.load_func, asyncdynamic_item_buffer.hint_func);
            MMI_fixed_list_menu.n_items = no_entries;
            asyncdynamic_list_goto_item_no_redraw(MMI_fixed_list_menu.highlighted_item);
        }
        else
        {
            dynamic_list_goto_item_no_redraw(MMI_fixed_list_menu.highlighted_item);
        }

        MMI_fixed_list_menu.first_displayed_item = first_item;
        MMI_fixed_list_menu.last_displayed_item = last_item;
    }
    else
    {
        set_left_softkey_label(NULL);
        set_left_softkey_icon(NULL);
        //redraw_left_softkey();
        set_left_softkey_function(UI_dummy_function, KEY_EVENT_UP);
        set_left_softkey_function(UI_dummy_function, KEY_EVENT_DOWN);
        if (g_wgui_cat_is_async_dynamic_list)
        {
            gui_fixed_icontext_list_menuitem_stop_scroll();
        }
        else
        {
            gui_fixed_icontext_menuitem_stop_scroll();
        }
        gui_pop_up_description_stop_scroll();
        wgui_title_set_menu_shortcut_number(0);
        wgui_current_pop_up_description_index = -1;
    }

	//if (has_tab_title == TRUE)
    //{
    //    draw_title();
    //}

    //show_dynamic_list();
    if (g_wgui_cat_is_async_dynamic_list)
    {
        if (no_entries == 0)
        {
            gui_fixed_icontext_list_menuitem_stop_scroll();
            gui_pop_up_description_stop_scroll();
        }
        init_asyncdynamic_item_buffer(no_entries, asyncdynamic_item_buffer.load_func, asyncdynamic_item_buffer.hint_func);
        MMI_fixed_list_menu.n_items = no_entries;
        asyncdynamic_list_goto_item_no_redraw(MMI_fixed_list_menu.highlighted_item);
    }
}


/*****************************************************************************
 * FUNCTION
 *  ExitCategory199Screen
 * DESCRIPTION
 *  Exit function of category199
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitCategory199Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_FTE_SUPPORT__
    mmi_imc_set_vk_present(MMI_IMC_VK_PRESENT_DEFAULT);
#endif

    ClearHighlightHandler();
    reset_softkeys();
    reset_menu_shortcut_handler();
    reset_fixed_list();
    reset_pop_up_descriptions();
    wgui_inputs_sl_close();
#ifdef __MMI_PHONEBOOK_LIST_THUMBNAIL__
    wgui_cat_thumbnail_deninit();
#endif
    wgui_close_horizontal_tab_bar();
    if (g_wgui_cat_is_async_dynamic_list)
    {
        reset_asyncdynamic_list();
    }
    else
    {
        reset_dynamic_list();
    }

    cat200_search_function = NULL;
    g_wgui_cat199_get_attachment_icon = NULL;
    g_wgui_cat199_get_attachment_icon_filepath = NULL;
    g_wgui_cat199_get_attachment_icon_buffer =NULL;
#if  defined(__MMI_TOUCH_SCREEN__)
    wgui_cat199_setup_search_button(NULL, NULL, NULL);
#endif
    cat200_search_img = 0;
    g_wgui_cat200_resize_and_move_func = NULL;
    g_wgui_cat200_draw_information_bar_func = NULL;
    g_wgui_cat200_set_special_key_func = NULL;
#ifdef __MMI_UI_HINTS_IN_MENUITEM__
    reset_all_force_flags_for_hints();
    #ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
    gui_unblock_list_effect();
    #endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__*/ 
#endif /* __MMI_UI_HINTS_IN_MENUITEM__ */ 
    dynamic_item_text_align_left = FALSE;
    g_wgui_cat199_has_checkbox = MMI_FALSE;
    g_wgui_cat199_disable_tab_title = MMI_FALSE;
    g_wgui_cat_is_async_dynamic_list = MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat199_get_history_size
 * DESCRIPTION
 *  Gets the history buffer size of category 199
 * PARAMETERS
 *  void
 * RETURNS
 *  S32
 *****************************************************************************/
S32 wgui_cat199_get_history_size(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return (((sizeof(list_menu_category_history) + 3) / 4) * 4 + sizeof(singleline_inputbox_category_history));
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat199_get_history
 * DESCRIPTION
 *  Gets the history buffer of category199
 * PARAMETERS
 *  history_buffer      [OUT]        The buffer into which the history data is stored
 * RETURNS
 *  U8*
 *****************************************************************************/
U8 *wgui_cat199_get_history(U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 s;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    get_list_menu_category_history(MMI_CATEGORY199_ID, history_buffer);
    s = sizeof(list_menu_category_history);
    s = (s + 3) / 4;
    s *= 4;
    wgui_inputs_sl_get_category_history(MMI_CATEGORY199_ID, (U8*) (history_buffer + s));
    return (history_buffer);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat199_draw_virtual_keypad_background
 * DESCRIPTION
 *  Draw the virtual keypad area by IME.
 * PARAMETERS
 *  x1      [IN]        start X
 *  y1      [IN]        start Y
 *  x2      [IN]        end X
 *  y2      [IN]        end Y
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat199_draw_virtual_keypad_background(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_push_clip();
    gdi_layer_set_clip(x1, y1, x2, y2);
    gui_fill_rectangle(x1, y1, x2, y2, (gui_color(0, 0, 255)));
    gdi_layer_pop_clip();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat199_redraw_screen
 * DESCRIPTION
 *  category202 redraw function
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat199_redraw_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_wgui_cat199_menuitem_stop_scrolling = MMI_FALSE;
    //dm_redraw_category_screen();
    gdi_layer_lock_frame_buffer();
    init_asyncdynamic_item_buffer(asyncdynamic_item_buffer.n_total_items, asyncdynamic_item_buffer.load_func, asyncdynamic_item_buffer.hint_func);
    asyncdynamic_list_goto_item_no_redraw(MMI_fixed_list_menu.highlighted_item);
    wgui_async_list_show_multi_icontext_menu();
    gdi_layer_unlock_frame_buffer();
    g_wgui_cat199_menuitem_stop_scrolling = MMI_TRUE;

    gdi_layer_blt_previous(
        MMI_fixed_list_menu.x, 
        MMI_fixed_list_menu.y, 
        MMI_fixed_list_menu.x + MMI_fixed_list_menu.width - 1, 
        MMI_fixed_list_menu.y + MMI_fixed_list_menu.height - 1);
}


/*****************************************************************************
 * FUNCTION
 *  ShowCategory199Screen
 * DESCRIPTION
 *  Show category199 screen
 * PARAMETERS
 *  left_softkey            [IN]        Left soft key label
 *  left_softkey_icon       [IN]        Left soft key icon
 *  right_softkey           [IN]        Right soft key label
 *  right_softkey_icon      [IN]        Right soft key icon
 *  highlighted_tab         [IN]        Highlighted tab
 *  tab_title               [IN]        Tab title
 *  number_of_items         [IN]        Number of items
 *  info_message            [IN]        Text in info area, NULL will not show info area
 *  get_item_func           [IN]        Callback function of get menu item 
 *  get_hint_func           [IN]        Callback function of get menu item hint
 *  get_state_func          [IN]        Callback function of get state, NULL will not show check box
 *  set_state_func          [IN]        Callback function of state changed, NULL will not show check box
 *  highlighted_item        [IN]        Highlighted item index
 *  buffer                  [IN]        Buffer
 *  buffer_max_length       [IN]        Buffer max length
 *  history_buffer          [IN]        Histpry buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory199Screen_int(
        UI_string_type left_softkey,
        UI_string_type right_softkey,
        S8 highlighted_tab,
        UI_string_type tab_title,
        UI_string_type info_message,
        S32 number_of_items,
        GetItemFuncPtr get_item_func,
        GetHintFuncPtr get_hint_func,
        checkbox_get_image_funcptr_type get_state_func,
        checkbox_clicked_funcptr_type set_state_func,
        S32 highlighted_item,
        U8 *buffer,
        S32 buffer_max_length,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;
    S32 input_box_width = 0, list_height = 0, max_entries = 0, i = 0, tab_h = 0, scrolltext_h = 0;
    U8 h_flag;
    BOOL has_tab_title;
    S8 n_tabs;
    S32 first_item, last_item;
    MMI_BOOL is_empty_buffer = MMI_TRUE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();

    /* softkey */
    dm_add_softkey_str(left_softkey, right_softkey);
      
    /* horizontal tab bar */
#if defined(__MMI_MAINLCD_128X128__) || (defined(__MMI_MAINLCD_320X240__) && defined(__MMI_VIRTUAL_KEYBOARD__)) || (defined(__MMI_MAINLCD_320X240__) && defined(__MMI_FTE_SUPPORT__))
    has_tab_title = FALSE;
	g_wgui_cat199_disable_tab_title = MMI_TRUE;
    tab_h = MMI_HORIZONTAL_TAB_BAR_TAB_AREA_HEIGHT;
#else
    has_tab_title = TRUE;
	g_wgui_cat199_disable_tab_title = MMI_FALSE;
    tab_h = MMI_HORIZONTAL_TAB_BAR_TAB_AREA_HEIGHT + MMI_HORIZONTAL_TAB_BAR_HINT_AREA_HEIGHT;
    if (info_message != NULL)
    {
        scrolltext_h = CAT202_SCROLL_HEIGHT;
        /* Scroll Text */
        dm_add_scroll_text(
            (UI_string_type)info_message, 
            NULL, 
            wgui_category_clear_region_with_transparent_color, 
            *current_MMI_theme->list_normal_text_color,
            *current_MMI_theme->list_normal_text_color);
    }
#endif /* defined(__MMI_MAINLCD_128X128__) */

    mmi_frm_get_tab_bar_items(MMI_tab_bar_items, &n_tabs); 
    wgui_create_horizontal_tab_bar(has_tab_title, tab_title, n_tabs, highlighted_tab, MMI_TRUE);
    if (has_tab_title == FALSE)
    {
        wgui_setup_horizontal_tab_bar_no_title_shortcut();
    }
    
    dynamic_item_text_align_left = TRUE;

    wgui_dynamic_list_create_icontext_menu(
        number_of_items,
        get_item_func,
        get_hint_func,
        WGUI_LIST_INVALID_HIGHLIGHT,
        MMI_FALSE,
        UI_dummy_function,
        0,
        0,
        NULL);

    if (has_tab_title == FALSE)
    {
        //wgui_set_disable_shortcut_display();
        wgui_title_set_no_icon_shct(MMI_FALSE);
    }
    else
    {
        set_menu_item_count(number_of_items);
    }

#ifdef __MMI_TOUCH_SCREEN__
    /* Because the list menu is resized according to virtual keyboard */
    MMI_fixed_list_menu.flags |= UI_LIST_MENU_ALIGN_TO_TOP;
#endif /* __MMI_TOUCH_SCREEN__ */ 

    list_height = UI_device_height - MMI_HORIZONTAL_TAB_BAR_Y - tab_h - scrolltext_h - CAT199_INPUTBOX_H - MMI_BUTTON_BAR_HEIGHT;
#if !defined(__MMI_MAINLCD_128X128__)
    list_height -= 2; /* border */
#endif

    resize_fixed_list(MMI_content_width, list_height);
    move_fixed_list(0, MMI_HORIZONTAL_TAB_BAR_Y + tab_h + scrolltext_h);
    
    h_flag = set_list_menu_category_history(MMI_CATEGORY199_ID, history_buffer);
#ifdef __MMI_UI_HINTS_IN_MENUITEM__
    if (get_hint_func)
    {
        if (is_set_force_icon_on_highlight_only_in_menuitem())
        {
            wgui_show_icon_only_highlight_in_icontext_menuitem();
        }
        if (is_set_force_all_hints_in_menuitem())
        {
            wgui_enable_hints_in_icontext_menuitem();
        }
        else if (is_set_force_hints_on_highlight_in_menuitem())
        {
            wgui_enable_hint_highlight_in_icontext_menuitem();
        }
        else
        {
            wgui_enable_hint_highlight_in_icontext_menuitem();
        }

        if (h_flag)
        {
            set_dynamic_pop_up_descriptions(MMI_fixed_list_menu.highlighted_item);
        }
        else
        {
            set_dynamic_pop_up_descriptions(highlighted_item);
        }

    #ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
        gui_block_list_effect();
    #endif 
    }
#endif /* __MMI_UI_HINTS_IN_MENUITEM__ */ 

    if ((get_state_func != NULL) && (set_state_func != NULL))
    {
        /* if function isn't NULL, then set check-box */
        wgui_menuitem_set_icontext_checkbox_position(1, 0);
        wgui_menuitem_register_icontext_checkbox_callback(set_state_func, get_state_func);
        set_fixed_icontext_positions((2*CFG_UI_ICONTEXT_MENUITEM_TEXT_X - CFG_UI_ICONTEXT_MENUITEM_ICON_X), 0, CFG_UI_ICONTEXT_MENUITEM_TEXT_X, 0);
        g_wgui_cat199_has_checkbox = MMI_TRUE;
    }

    wgui_singleline_inputbox_LSK_label_icon = NULL;
    wgui_singleline_inputbox_LSK_label_string = left_softkey;
    g_wgui_cat200_resize_and_move_func = wgui_cat199_resize_and_move;
    g_wgui_cat200_draw_information_bar_func = wgui_cat199_draw_input_method;
    g_wgui_cat200_set_special_key_func = wgui_cat199_set_left_and_right_arrow_key;

    input_box_x = CAT199_MARGIN_WIDTH + 1;
    input_box_y = UI_device_height - MMI_BUTTON_BAR_HEIGHT - CAT199_INPUTBOX_H;
    input_box_width = UI_device_width - CAT199_MARGIN_WIDTH - CAT199_MARGIN_WIDTH;
    
#if !defined(__MMI_MAINLCD_128X128__)
    input_box_y -= 1; /* buttom border */
#endif

    if (h_flag)
    {
        S32 size = sizeof(list_menu_category_history);

        size = (size + 3) / 4;
        size *= 4;

        first_item = MMI_fixed_list_menu.first_displayed_item;
        last_item = MMI_fixed_list_menu.last_displayed_item;
        dynamic_list_goto_item_no_redraw(MMI_fixed_list_menu.highlighted_item);
        MMI_fixed_list_menu.first_displayed_item = first_item;
        MMI_fixed_list_menu.last_displayed_item = last_item;

        wgui_inputs_sl_disable_up_down_key_register(MMI_TRUE);
        wgui_inputs_sl_disable_left_right_key_register(MMI_TRUE);

        if ((buffer != NULL) && ((buffer[0] != 0) || (buffer[1] != 0)))
        {
            is_empty_buffer = MMI_FALSE;
        }

        wgui_inputs_sl_setup_ext(
            input_box_x,
            input_box_y,
            input_box_width,
            CAT199_INPUTBOX_H,
            buffer,
            buffer_max_length,
            MMI_CATEGORY199_ID,
            right_softkey,
            NULL,
            IMM_INPUT_TYPE_QUICK_SEARCH,
            (U8*) (history_buffer + size),
            0,
            wgui_cat_search_editor_msg_callback);

        /* when input method changed, we will clear the input buffer, so the highlight item need to reset */
        if ((buffer != NULL) && (is_empty_buffer == MMI_FALSE) && ((buffer[0] == 0) && (buffer[1] == 0)))
        {
            MMI_fixed_list_menu.highlighted_item = 1;
        }

        if (cat200_search_function)
        {
            S32 no_entries;

            no_entries = cat200_search_function((U8*) MMI_singleline_inputbox.text);
            load_dynamic_item_buffer(no_entries);
            //refresh_search_list_change_list_ext(no_entries, MMI_fixed_list_menu.highlighted_item);
            wgui_cat199_refresh_search_list(no_entries, MMI_fixed_list_menu.highlighted_item, has_tab_title);
        }
    }
    else /* initial */
    {
        dynamic_list_goto_item_no_redraw(highlighted_item);
        wgui_inputs_sl_disable_up_down_key_register(MMI_TRUE);
        wgui_inputs_sl_disable_left_right_key_register(MMI_TRUE);
        wgui_inputs_sl_setup_ext(
            input_box_x,
            input_box_y,
            input_box_width,
            CAT199_INPUTBOX_H,
            buffer,
            buffer_max_length,
            MMI_CATEGORY199_ID,
            right_softkey,
            NULL,
            IMM_INPUT_TYPE_QUICK_SEARCH,
            NULL,
            0,
            wgui_cat_search_editor_msg_callback);

        gui_inputs_register_redraw_background_filler(wgui_cat199_draw_virtual_keypad_background);
    }

#ifndef __MMI_FTE_SUPPORT__
    gui_set_single_line_input_box_theme(&MMI_singleline_inputbox, &g_cat199_singleline_inputbox_theme);
#endif

    resize_dynamic_icontext_menuitems_to_list_width();
    if (h_flag)
    {
        set_dynamic_pop_up_descriptions(MMI_fixed_list_menu.highlighted_item);
    }
    else
    {
        set_dynamic_pop_up_descriptions(highlighted_item);
    }

    singleline_inputbox_input_callback();
    if (!h_flag)
    {
        if (number_of_items > 0)
        {
            set_left_softkey_label(wgui_singleline_inputbox_LSK_label_string);
            set_left_softkey_icon(wgui_singleline_inputbox_LSK_label_icon);
            redraw_left_softkey();
            register_left_softkey_handler();
            set_left_softkey_function(wgui_singleline_inputbox_LSK_function, KEY_EVENT_UP);
            set_left_softkey_function(UI_dummy_function, KEY_EVENT_DOWN);
        }
        else
        {
            set_left_softkey_label(NULL);
            set_left_softkey_icon(NULL);
            redraw_left_softkey();
            set_left_softkey_function(UI_dummy_function, KEY_EVENT_UP);
            set_left_softkey_function(UI_dummy_function, KEY_EVENT_DOWN);
        }
    }
    
    register_singleline_inputbox_input_callback(wgui_cat200_editor_change_callback);

    gdi_layer_unlock_frame_buffer();
    ExitCategoryFunction = ExitCategory199Screen;
    dm_setup_category_functions(wgui_cat199_redraw_screen, wgui_cat199_get_history, wgui_cat199_get_history_size);
    dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND;
#ifdef __MMI_TOUCH_SCREEN__
    dm_data.s32flags |= DM_SHOW_VKPAD;
#endif /* __MMI_TOUCH_SCREEN__ */
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    if (info_message != NULL)
    {
        dm_data.s32CatId = MMI_CATEGORY199_SCROLLTEXT_ID;
    }
    else
    {
        dm_data.s32CatId = MMI_CATEGORY199_ID;
    }
    dm_setup_data(&dm_data);

    dm_register_category_controlled_callback(RedrawCategoryControlledArea200Screen);
    
#ifdef __MMI_TOUCH_SCREEN__
    dm_register_vkpad_callback(wgui_cat200_virtual_keypad_callback);
    wgui_register_category_screen_control_area_pen_handlers(Cate200CategoryControlAreaPenDownHandler, MMI_PEN_EVENT_DOWN);
    wgui_register_category_screen_control_area_pen_handlers(Cate200CategoryControlAreaPenUpHandler, MMI_PEN_EVENT_UP);
    wgui_register_category_screen_control_area_pen_handlers(Cate200CategoryControlAreaPenMoveHandler, MMI_PEN_EVENT_MOVE);
    wgui_register_category_screen_control_area_pen_handlers(Cate200CategoryControlAreaPenLongTapHandler, MMI_PEN_EVENT_LONG_TAP);
    wgui_register_category_screen_control_area_pen_handlers(Cate200CategoryControlAreaPenRepeatHandler, MMI_PEN_EVENT_REPEAT);
#endif /* __MMI_TOUCH_SCREEN__ */ 

#if defined(__MMI_VIRTUAL_KEYBOARD__)
    wgui_virtual_keyboard_register_hide_cursor_callback(wgui_cat_stop_pop_up_description_scroll);
    wgui_virtual_keyboard_register_blink_cursor_callback(wgui_cat_resume_pop_up_description_scroll);
#endif

    dm_redraw_category_screen();
}


/*****************************************************************************
 * FUNCTION
 *  ShowCategory199Screen_ext
 * DESCRIPTION
 *  Quick search screen, support tab bar.
 * PARAMETERS
 *  left_softkey            [IN]        Left soft key label
 *  left_softkey_icon       [IN]        Left soft key icon
 *  right_softkey           [IN]        Right soft key label
 *  right_softkey_icon      [IN]        Right soft key icon
 *  highlighted_tab         [IN]        Highlighted tab
 *  tab_title               [IN]        Tab title
 *  number_of_items         [IN]        Number of items
 *  info_message            [IN]        Text in info area, NULL will not show info area
 *  get_item_func           [IN]        Callback function of get menu item 
 *  get_hint_func           [IN]        Callback function of get menu item hint
 *  get_state_func          [IN]        Callback function of get state, NULL will not show check box
 *  set_state_func          [IN]        Callback function of state changed, NULL will not show check box
 *  highlighted_item        [IN]        Highlighted item index
 *  left_icon               [IN]        Menuitme left icon 
 *  right_icon              [IN]        Menuitme right icon 
 *  buffer                  [IN]        Buffer
 *  buffer_max_length       [IN]        Buffer max length
 *  history_buffer          [IN]        Histpry buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory199Screen_ext_int(
        UI_string_type left_softkey,
        UI_string_type right_softkey,
        S8 highlighted_tab,
        UI_string_type tab_title,
        UI_string_type info_message,
        S32 number_of_items,
        GetAsyncItemFuncPtr get_item_func,
        GetAsyncHintFuncPtr get_hint_func,
        checkbox_get_image_funcptr_type get_state_func,
        checkbox_clicked_funcptr_type set_state_func,
        S32 highlighted_item,
        PU8 left_icon,
        PU8 right_icon,
        U8 *buffer,
        S32 buffer_max_length,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;
    S32 input_box_width = 0, list_height = 0, max_entries = 0, i = 0, tab_h = 0, scrolltext_h = 0;
    U8 h_flag;
    BOOL has_tab_title;
    S8 n_tabs;
    S32 first_item, last_item;
    MMI_BOOL is_empty_buffer = MMI_TRUE;
    S32 left_icon_w = 0, left_icon_h = 0, right_icon_w = 0, right_icon_h = 0;
    S32 checkbox_w = 0, checkbox_h = 0;
    
#if  defined(__MMI_TOUCH_SCREEN__)
    icontext_button *search_bt;
#endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();
    if (history_buffer != NULL) 
    {
        list_menu_category_history *h = (list_menu_category_history*) history_buffer;
        if(!number_of_items)
        {
            number_of_items = h->num_items;
        }     
    }
#ifdef __MMI_PHONEBOOK_LIST_THUMBNAIL__
    wgui_cat_thumbnail_init(number_of_items);
#endif 
    /* softkey */
    dm_add_softkey_str(left_softkey, right_softkey);
      
    /* horizontal tab bar */
#if defined(__MMI_MAINLCD_128X128__) || (defined(__MMI_MAINLCD_320X240__) && defined(__MMI_VIRTUAL_KEYBOARD__)) || (defined(__MMI_MAINLCD_320X240__) && defined(__MMI_FTE_SUPPORT__))
    has_tab_title = FALSE;
	g_wgui_cat199_disable_tab_title = MMI_TRUE;
    tab_h = MMI_HORIZONTAL_TAB_BAR_TAB_AREA_HEIGHT;
#else
    has_tab_title = TRUE;
	g_wgui_cat199_disable_tab_title = MMI_FALSE;
    tab_h = MMI_HORIZONTAL_TAB_BAR_TAB_AREA_HEIGHT + MMI_HORIZONTAL_TAB_BAR_HINT_AREA_HEIGHT;
    if (info_message != NULL)
    {
        scrolltext_h = CAT202_SCROLL_HEIGHT;
        /* Scroll Text */
        dm_add_scroll_text(
            (UI_string_type)info_message, 
            NULL, 
            wgui_category_clear_region_with_transparent_color, 
            *current_MMI_theme->list_normal_text_color,
            *current_MMI_theme->list_normal_text_color);
    }
#endif /* defined(__MMI_MAINLCD_128X128__) */

    mmi_frm_get_tab_bar_items(MMI_tab_bar_items, &n_tabs); 
    wgui_create_horizontal_tab_bar(has_tab_title, tab_title, n_tabs, highlighted_tab, MMI_TRUE);
    if (has_tab_title == FALSE)
    {
        wgui_setup_horizontal_tab_bar_no_title_shortcut();
    }
    
    dynamic_item_text_align_left = TRUE;
    g_wgui_cat_is_async_dynamic_list = MMI_TRUE;

    wgui_async_list_create_multi_icontext_menu(
        number_of_items,
        1,
        2,
        get_item_func,
        get_hint_func,
        highlighted_item,
        MMI_MENUITEM_HEIGHT,
        0,
        0,
        NULL);

    if ((get_state_func != NULL) && (set_state_func != NULL))
    {
        /* if function isn't NULL, then set check-box */
        wgui_menuitem_set_icontext_list_checkbox_position(1, 0);
        wgui_menuitem_register_icontext_list_checkbox_callback(set_state_func, get_state_func);
        set_fixed_icontext_positions((2*CFG_UI_ICONTEXT_MENUITEM_TEXT_X - CFG_UI_ICONTEXT_MENUITEM_ICON_X), 0, CFG_UI_ICONTEXT_MENUITEM_TEXT_X, 0);
        g_wgui_cat199_has_checkbox = MMI_TRUE;
        gui_measure_image(get_image(CHECKBOX_ON_IMAGE_ID), &checkbox_w, &checkbox_h);
    }
#ifdef __MMI_PHONEBOOK_LIST_THUMBNAIL__
    set_fixed_icontext_list_menuitems_post_display(wgui_cat_thumbnail_post_display_callback);
#endif
    /* set the icon/text position */
    if (left_icon != NULL)
    {
        gui_measure_image(left_icon, &left_icon_w, &left_icon_h);
    }
    if (right_icon != NULL)
    {
        gui_measure_image(right_icon, &right_icon_w, &right_icon_h);
    }

    set_fixed_icontext_list_icon_coordinates(
        0, 
        WGUI_CAT199_GAP_1 + checkbox_w,
        0,
        left_icon_w, 
        MMI_ICONTEXT_MENUITEM_HEIGHT);
    set_fixed_icontext_list_icon_coordinates(
        1, 
        MMI_fixed_list_menu.width - WGUI_CAT199_GAP_4 - right_icon_w - MMI_fixed_list_menu.vbar.width, 
        0, 
        right_icon_w, 
        MMI_ICONTEXT_MENUITEM_HEIGHT);
    set_fixed_icontext_list_text_coordinates(
        0, 
        WGUI_CAT199_GAP_1 + left_icon_w + WGUI_CAT199_GAP_2 + checkbox_w, 
        0,
        MMI_fixed_list_menu.width - MMI_fixed_list_menu.vbar.width - left_icon_w - right_icon_w - WGUI_CAT199_GAP_1 - WGUI_CAT199_GAP_2 - WGUI_CAT199_GAP_3 - WGUI_CAT199_GAP_4 - checkbox_w, 
        MMI_ICONTEXT_MENUITEM_HEIGHT);

    MMI_fixed_icontext_list_menuitem.flags |= UI_MENUITEM_CENTER_TEXT_Y;

    if (has_tab_title == FALSE)
    {
        wgui_title_set_no_icon_shct(MMI_FALSE);
    }
    else
    {
        set_menu_item_count(number_of_items);
    }

#ifdef __MMI_TOUCH_SCREEN__
    /* Because the list menu is resized according to virtual keyboard */
    MMI_fixed_list_menu.flags |= UI_LIST_MENU_ALIGN_TO_TOP;
#endif /* __MMI_TOUCH_SCREEN__ */ 

#ifdef __MMI_ICON_BAR_SUPPORT__
#ifdef __MMI_FTE_SUPPORT__
    if (wgui_icon_bar_is_created())
    {
        list_height = UI_device_height - MMI_HORIZONTAL_TAB_BAR_Y - tab_h - scrolltext_h - CAT199_INPUTBOX_H - MMI_BUTTON_BAR_HEIGHT - MMI_ICON_BAR_HEIGHT;
    }
    else
#endif /* __MMI_FTE_SUPPORT__ */
#endif /*__MMI_ICON_BAR_SUPPORT__*/
    {
        list_height = UI_device_height - MMI_HORIZONTAL_TAB_BAR_Y - tab_h - scrolltext_h - CAT199_INPUTBOX_H - MMI_BUTTON_BAR_HEIGHT;
    }

#if !defined(__MMI_MAINLCD_128X128__)
    list_height -= 2; /* border */
#endif

    resize_fixed_list(MMI_content_width, list_height);
    move_fixed_list(0, MMI_HORIZONTAL_TAB_BAR_Y + tab_h + scrolltext_h);
    
    h_flag = set_list_menu_category_history(MMI_CATEGORY199_ID, history_buffer);
#ifdef __MMI_UI_HINTS_IN_MENUITEM__
    if (get_hint_func)
    {
        if (is_set_force_icon_on_highlight_only_in_menuitem())
        {
            wgui_show_icon_only_highlight_in_icontext_menuitem();
        }
        if (is_set_force_all_hints_in_menuitem())
        {
            wgui_enable_hints_in_icontext_menuitem();
        }
        else if (is_set_force_hints_on_highlight_in_menuitem())
        {
            wgui_enable_hint_highlight_in_icontext_menuitem();
        }
        else
        {
            wgui_enable_hint_highlight_in_icontext_menuitem();
        }

        if (h_flag)
        {
            set_asyncdynamic_pop_up_descriptions(MMI_fixed_list_menu.highlighted_item);
        }
        else
        {
            set_asyncdynamic_pop_up_descriptions(highlighted_item);
        }

    #ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
        gui_block_list_effect();
    #endif 
    }
#endif /* __MMI_UI_HINTS_IN_MENUITEM__ */ 

    wgui_singleline_inputbox_LSK_label_icon = NULL;
    wgui_singleline_inputbox_LSK_label_string = left_softkey;
    g_wgui_cat200_resize_and_move_func = wgui_cat199_resize_and_move;
    g_wgui_cat200_draw_information_bar_func = wgui_cat199_draw_input_method;
    g_wgui_cat200_set_special_key_func = wgui_cat199_set_left_and_right_arrow_key;

    input_box_x = CAT199_MARGIN_WIDTH + 1;
    
#ifdef __MMI_ICON_BAR_SUPPORT__
#ifdef __MMI_FTE_SUPPORT__
    if (wgui_icon_bar_is_created())
    {
        input_box_y = UI_device_height - MMI_BUTTON_BAR_HEIGHT - CAT199_INPUTBOX_H - MMI_ICON_BAR_HEIGHT;
    }
    else
#endif /* __MMI_FTE_SUPPORT__ */
#endif /*__MMI_ICON_BAR_SUPPORT__*/
    {
        input_box_y = UI_device_height - MMI_BUTTON_BAR_HEIGHT - CAT199_INPUTBOX_H;
    }
    input_box_width = UI_device_width - CAT199_MARGIN_WIDTH - CAT199_MARGIN_WIDTH;
    
#if !defined(__MMI_MAINLCD_128X128__)
    input_box_y -= 1; /* buttom border */
#endif

#if  defined(__MMI_TOUCH_SCREEN__)
    if (g_wgui_cat199_search_button_function)
    {
        /* setup button */
        g_wgui_cat199_search_button_id = dm_add_button(
                                                    NULL,
                                                    g_wgui_cat199_search_button_up_image,
                                                    g_wgui_cat199_search_button_down_image,
                                                    wgui_cat199_clear_search_button_bg);
        dm_register_button_functions(g_wgui_cat199_search_button_id, KEY_EVENT_UP, g_wgui_cat199_search_button_function);
        search_bt = dm_get_button(g_wgui_cat199_search_button_id);
        //search_bt->draw_down_fp = wgui_cat199_search_button_draw_down;
        //search_bt->draw_up_fp = wgui_cat199_search_button_draw_up;
        search_bt->flags |= UI_BUTTON_NO_SHIFT_BUTTON;
    }
#endif /*  defined(__MMI_TOUCH_SCREEN__) */  


    if (h_flag)
    {
        S32 size = sizeof(list_menu_category_history);

        size = (size + 3) / 4;
        size *= 4;

        first_item = MMI_fixed_list_menu.first_displayed_item;
        last_item = MMI_fixed_list_menu.last_displayed_item;
        if (g_wgui_cat_is_async_dynamic_list)
        {
            asyncdynamic_list_goto_item_no_redraw(MMI_fixed_list_menu.highlighted_item);
        }
        else
        {
            dynamic_list_goto_item_no_redraw(MMI_fixed_list_menu.highlighted_item);
        }
        MMI_fixed_list_menu.first_displayed_item = first_item;
        MMI_fixed_list_menu.last_displayed_item = last_item;

        wgui_inputs_sl_disable_up_down_key_register(MMI_TRUE);
        wgui_inputs_sl_disable_left_right_key_register(MMI_TRUE);

        if ((buffer != NULL) && ((buffer[0] != 0) || (buffer[1] != 0)))
        {
            is_empty_buffer = MMI_FALSE;
        }

        wgui_inputs_sl_setup_ext(
            input_box_x,
            input_box_y,
            input_box_width,
            CAT199_INPUTBOX_H,
            buffer,
            buffer_max_length,
            MMI_CATEGORY199_ID,
            right_softkey,
            NULL,
            IMM_INPUT_TYPE_QUICK_SEARCH,
            (U8*) (history_buffer + size),
            0,
            wgui_cat_search_editor_msg_callback);

        /* when input method changed, we will clear the input buffer, so the highlight item need to reset */
        if ((buffer != NULL) && (is_empty_buffer == MMI_FALSE) && ((buffer[0] == 0) && (buffer[1] == 0)))
        {
            MMI_fixed_list_menu.highlighted_item = highlighted_item;
        }

        if (cat200_search_function)
        {
            S32 no_entries;

            no_entries = cat200_search_function((U8*) MMI_singleline_inputbox.text);
            //load_dynamic_item_buffer(no_entries);
            wgui_cat199_refresh_search_list(no_entries, MMI_fixed_list_menu.highlighted_item, has_tab_title);
        }
    }
    else /* initial */
    {
#ifdef __MMI_FTE_SUPPORT__
        mmi_imc_set_vk_present(MMI_IMC_VK_DEFAULT_HIDE);
#endif
        if (g_wgui_cat_is_async_dynamic_list)
        {
            asyncdynamic_list_goto_item_no_redraw(highlighted_item);
        }
        else
        {
            dynamic_list_goto_item_no_redraw(highlighted_item);
        }
        wgui_inputs_sl_disable_up_down_key_register(MMI_TRUE);
        wgui_inputs_sl_disable_left_right_key_register(MMI_TRUE);
        wgui_inputs_sl_setup_ext(
            input_box_x,
            input_box_y,
            input_box_width,
            CAT199_INPUTBOX_H,
            buffer,
            buffer_max_length,
            MMI_CATEGORY199_ID,
            right_softkey,
            NULL,
            IMM_INPUT_TYPE_QUICK_SEARCH,
            NULL,
            0,
            wgui_cat_search_editor_msg_callback);

        gui_inputs_register_redraw_background_filler(wgui_cat199_draw_virtual_keypad_background);
    }

#if  defined(__MMI_TOUCH_SCREEN__)
    if (g_wgui_cat199_search_button_function)
    {
        mmi_imc_disable_handwriting();
        g_mmi_editor_hanler.input_box_type = MMI_EDITOR_SINGLE_LINE_INPU_BOX;
        g_mmi_editor_hanler.input_box_sub_type = MMI_EDITOR_QUICK_SEARCH_SINGLE_LINE_INPUT_BOX;
        g_mmi_editor_hanler.input_box_handler = &MMI_singleline_inputbox;
        mmi_imc_connect((void *)&g_mmi_editor_hanler, wgui_cat_search_editor_msg_callback);
    }
#endif /*  defined(__MMI_TOUCH_SCREEN__) */  


#ifndef __MMI_FTE_SUPPORT__
    gui_set_single_line_input_box_theme(&MMI_singleline_inputbox, &g_cat199_singleline_inputbox_theme);
#endif

    //resize_dynamic_icontext_menuitems_to_list_width();
    resize_asyncdynamic_icontext_menuitems_to_list_width();

    if (h_flag)
    {
        set_asyncdynamic_pop_up_descriptions(MMI_fixed_list_menu.highlighted_item);
    }
    else
    {
        set_asyncdynamic_pop_up_descriptions(highlighted_item);
    }

    singleline_inputbox_input_callback();
    if (!h_flag)
    {
        if (number_of_items > 0)
        {
            set_left_softkey_label(wgui_singleline_inputbox_LSK_label_string);
            set_left_softkey_icon(wgui_singleline_inputbox_LSK_label_icon);
            redraw_left_softkey();
            register_left_softkey_handler();
            set_left_softkey_function(wgui_singleline_inputbox_LSK_function, KEY_EVENT_UP);
            set_left_softkey_function(UI_dummy_function, KEY_EVENT_DOWN);
        }
        else
        {
            set_left_softkey_label(NULL);
            set_left_softkey_icon(NULL);
            redraw_left_softkey();
            set_left_softkey_function(UI_dummy_function, KEY_EVENT_UP);
            set_left_softkey_function(UI_dummy_function, KEY_EVENT_DOWN);
        }
    }

#ifdef __MMI_TOUCH_SCREEN__
    if (g_wgui_cat199_search_button_function == NULL)
#endif /* __MMI_TOUCH_SCREEN__ */
    {
        wgui_inputs_sl_register_input_callback(wgui_cat200_editor_change_callback);
    }

    gdi_layer_unlock_frame_buffer();
    ExitCategoryFunction = ExitCategory199Screen;
    dm_setup_category_functions(wgui_cat199_redraw_screen, wgui_cat199_get_history, wgui_cat199_get_history_size);
    dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND;
    dm_data.s32flags |= DM_SHOW_VKPAD;
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    if (info_message != NULL)
    {
        dm_data.s32CatId = MMI_CATEGORY199_SCROLLTEXT_ID;
    }
    else
    {
        dm_data.s32CatId = MMI_CATEGORY199_ID;
    }
    dm_setup_data(&dm_data);

#ifndef __MMI_TOUCH_SCREEN__
    dm_register_category_controlled_callback(RedrawCategoryControlledArea200Screen);
#endif

    dm_register_vkpad_callback(mmi_imc_redraw_screen_by_state);

#ifdef __MMI_TOUCH_SCREEN__
    wgui_register_category_screen_control_area_pen_handlers(Cate200CategoryControlAreaPenDownHandler, MMI_PEN_EVENT_DOWN);
    wgui_register_category_screen_control_area_pen_handlers(Cate200CategoryControlAreaPenUpHandler, MMI_PEN_EVENT_UP);
    wgui_register_category_screen_control_area_pen_handlers(Cate200CategoryControlAreaPenMoveHandler, MMI_PEN_EVENT_MOVE);
    wgui_register_category_screen_control_area_pen_handlers(Cate200CategoryControlAreaPenLongTapHandler, MMI_PEN_EVENT_LONG_TAP);
    wgui_register_category_screen_control_area_pen_handlers(Cate200CategoryControlAreaPenRepeatHandler, MMI_PEN_EVENT_REPEAT);
#endif /* __MMI_TOUCH_SCREEN__ */ 

#if defined(__MMI_VIRTUAL_KEYBOARD__)
    wgui_virtual_keyboard_register_hide_cursor_callback(wgui_cat_stop_pop_up_description_scroll);
    wgui_virtual_keyboard_register_blink_cursor_callback(wgui_cat_resume_pop_up_description_scroll);
    wgui_icon_bar_register_resume_interactive_UI_callback(wgui_cat_resume_pop_up_description_scroll);
#endif

    dm_redraw_category_screen();
    wgui_fixed_list_set_alpha_blending_layer(dm_get_scr_bg_layer());

#ifdef __MMI_TOUCH_SCREEN__
    dm_register_category_controlled_callback(RedrawCategoryControlledArea200Screen);
#endif
#ifdef __MMI_PHONEBOOK_LIST_THUMBNAIL__
    wgui_cat_thumbnail_post_init(number_of_items);
#endif
}


extern void DrawCate384CategoryControlAreaBackground(S32 x1, S32 y1, S32 x2, S32 y2);

/*****************************************************************************
 * FUNCTION
 *  RedrawCategoryControlledArea202Screen
 * DESCRIPTION
 *  redraw category202
 * PARAMETERS
 *  coordinate      [IN]     Area to redraw     
 * RETURNS
 *  void
 *****************************************************************************/
void RedrawCategoryControlledArea202Screen(dm_coordinates *coordinate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    #ifdef MMI_CATEGORIES_SUPPORT_EDITOR_INFO_BAR
    color ccblack = {255, 255, 255, 100};
    #else /*MMI_CATEGORIES_SUPPORT_EDITOR_INFO_BAR*/
    color ccblack = {0, 0, 0, 100};
    #endif /*MMI_CATEGORIES_SUPPORT_EDITOR_INFO_BAR*/
    S32 temp_w = 0, temp_h = 0, image_y = 0;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();

    gui_reset_clip();
    gdi_layer_reset_clip();
#ifndef __MMI_FTE_SUPPORT__
     #ifndef MMI_CATEGORIES_SUPPORT_EDITOR_INFO_BAR
    wgui_cat199_draw_input_method();
     #endif/*MMI_CATEGORIES_SUPPORT_EDITOR_INFO_BAR*/
#endif /* __MMI_FTE_SUPPORT__ */
#ifdef MMI_CATEGORIES_SUPPORT_EDITOR_INFO_BAR
    wgui_inputs_setup_input_information(0,0,UI_device_width,INFO_HIGHT);
    wgui_inputs_sl_redraw_information_bar();
#endif /*MMI_CATEGORIES_SUPPORT_EDITOR_INFO_BAR*/

    if (g_wgui_cat_is_async_dynamic_list)
    {
        /* list */
        if (g_wgui_cat199_menuitem_stop_scrolling)
        {
            gui_fixed_icontext_list_menuitem_stop_scroll();
            gui_fixed_icontext_list_menuitem_start_scroll();
            gui_pop_up_description_stop_scroll();
        }
        wgui_async_list_show_multi_icontext_menu();
    }
    else
    {
        /* list */
        if (g_wgui_cat199_menuitem_stop_scrolling)
        {
            gui_fixed_icontext_menuitem_stop_scroll();
            gui_fixed_icontext_menuitem_start_scroll();
            gui_pop_up_description_stop_scroll();
        }

        show_dynamic_list();
    }

    gui_reset_clip();
#if defined(__MMI_TOUCH_SCREEN__)
    input_box_y = MMI_singleline_inputbox.y;
    gdi_draw_solid_rect(0, input_box_y - 1, UI_device_width - 1, input_box_y + CAT200_INPUTBOX_H, GDI_COLOR_TRANSPARENT);
#endif /* defined(__MMI_TOUCH_SCREEN__) */ 

#ifndef __MMI_FTE_SUPPORT__
    gui_draw_rectangle(
        CAT200_MARGIN_WIDTH,
        (input_box_y - 1),
        (UI_device_width - CAT200_MARGIN_WIDTH),
        (input_box_y + CAT200_INPUTBOX_H),
        ccblack);
#endif /* __MMI_FTE_SUPPORT__ */

    gdi_layer_set_clip(CAT200_MARGIN_WIDTH + 1, input_box_y, (input_box_x), (input_box_y + CAT200_INPUTBOX_H - 1));

    gui_measure_image(get_image(cat200_search_img), &temp_w, &temp_h);
    image_y = ((CAT200_INPUTBOX_H >> 1) - (temp_h >> 1));

#ifndef __MMI_FTE_SUPPORT__
    if (wgui_is_wallpaper_on_bottom() == MMI_TRUE)
    {
        gui_fill_rectangle(CAT200_MARGIN_WIDTH + 1, input_box_y, input_box_x, input_box_y + CAT200_INPUTBOX_H - 1, MMI_singleline_inputbox.normal_filler->c);
    }
    gui_show_image(CAT200_MARGIN_WIDTH + 2, (input_box_y + image_y), get_image(cat200_search_img));
#endif
    
    redraw_singleline_inputbox();

    gdi_layer_unlock_frame_buffer();
    gdi_layer_blt_previous(0, 0, UI_device_width - 1, UI_device_height - 1);

#if defined(__MMI_VIRTUAL_KEYBOARD__)
    wgui_virtual_keyboard_register_hide_cursor_callback(wgui_cat_stop_pop_up_description_scroll);
    wgui_virtual_keyboard_register_blink_cursor_callback(wgui_cat_resume_pop_up_description_scroll);
#endif
}

/*****************************************************************************
 * FUNCTION
 *  cat202_virtual_keypad_callback
 * DESCRIPTION
 *  virtual keypad callback of category 202
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void cat202_virtual_keypad_callback(void)
{
#if defined(__MMI_TOUCH_SCREEN__)
    mmi_imc_redraw_screen_by_state();
#endif /* defined(__MMI_TOUCH_SCREEN__) */ 
}


/*****************************************************************************
 * FUNCTION
 *  ExitCategory202Screen
 * DESCRIPTION
 *  exit function of category202
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitCategory202Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ClearHighlightHandler();
    reset_softkeys();
    reset_menu_shortcut_handler();
    reset_fixed_list();
    if (g_wgui_cat_is_async_dynamic_list)
    {
        reset_asyncdynamic_list();
    }
    else
    {
        reset_dynamic_list();
    }

    reset_pop_up_descriptions();
    wgui_close_singleline_inputbox();
    cat200_search_img = 0;
    cat200_search_function = NULL;
    g_wgui_cat200_resize_and_move_func = NULL;
    g_wgui_cat200_draw_information_bar_func = NULL;
    g_wgui_cat200_set_special_key_func = NULL;
    g_wgui_cat_is_async_dynamic_list = MMI_FALSE;
#ifdef __MMI_UI_HINTS_IN_MENUITEM__
    reset_all_force_flags_for_hints();
#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
    gui_unblock_list_effect();
#endif 
#endif /* __MMI_UI_HINTS_IN_MENUITEM__ */ 

}



/*****************************************************************************
 * FUNCTION
 *  ShowCategory202Screen
 * DESCRIPTION
 *  category screen of phone search and Multi Select
 * PARAMETERS
 *  title                   [IN]        Title id
 *  title_icon              [IN]        Title icon
 *  left_softkey            [IN]        Left soft key label
 *  left_softkey_icon       [IN]        Left soft key icon
 *  right_softkey           [IN]        Right soft key label
 *  right_softkey_icon      [IN]        Right soft key icon
 *  number_of_items         [IN]        Number of items
 *  get_item_func           [IN]        
 *  get_hint_func           [IN]        
 *  highlighted_item        [IN]        Highlighted item index
 *  search_image            [IN]        Seach image
 *  buffer                  [IN]        Buffer
 *  buffer_max_length       [IN]        
 *  history_buffer          [IN]        Histpry buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory202Screen_int(
        U16 title,
        U16 title_icon,
        U16 left_softkey,
        U16 right_softkey,
        U8* info_message,
        S32 number_of_items,
        GetItemFuncPtr get_item_func,
        GetHintFuncPtr get_hint_func,
        checkbox_get_image_funcptr_type get_state_func,
        checkbox_clicked_funcptr_type set_state_func,        
        S32 highlighted_item,
        U16 search_image,
        U8 *buffer,
        S32 buffer_max_length,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;
    S32 input_box_width = 0;
    U8 h_flag;
    S32 scroll_height = 0;
    S32 first_item, last_item;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_setup_common_layout();

    gdi_layer_lock_frame_buffer();

    g_wgui_cat200_resize_and_move_func = wgui_cat200_resize_and_move;

#ifndef __MMI_FTE_SUPPORT__
    g_wgui_cat200_draw_information_bar_func = wgui_cat199_draw_input_method;
#endif

    /* Title,shortcut and Softkey */
    dm_add_title_id(title, title_icon);

    wgui_title_set_menu_shortcut_number(-1);
    wgui_title_disable_menu_shortcut_display(MMI_TRUE);

    dm_add_softkey_id(left_softkey, right_softkey);
    
    if (info_message != NULL)
    {
        /* Scroll Text */
        dm_add_scroll_text(
            (UI_string_type)info_message, 
            NULL, 
            DrawCate384CategoryControlAreaBackground, 
            *current_MMI_theme->list_normal_text_color,
            *current_MMI_theme->list_normal_text_color);
        scroll_height = CAT202_SCROLL_HEIGHT;
    }

    /* Dynamic list */
    wgui_dynamic_list_create_icontext_menu(
        number_of_items,
        get_item_func,
        get_hint_func,
        WGUI_LIST_INVALID_HIGHLIGHT,
        MMI_FALSE,
        UI_dummy_function,
#if !defined(GUI_EDITOR_SHOW_TITLE)
        WGUI_LIST_MENU_DISABLE_SHORTCUT,
#else
        0,
#endif
        0,
        NULL);

#ifdef __MMI_TOUCH_SCREEN__
    /* Because the list menu is resized according to virtual keyboard */
    MMI_fixed_list_menu.flags |= UI_LIST_MENU_ALIGN_TO_TOP;
#endif /* __MMI_TOUCH_SCREEN__ */ 

    resize_fixed_list(
        MMI_content_width,
        MAIN_LCD_DEVICE_HEIGHT - CAT202_SCROLL_Y - CAT200_INPUTBOX_H - 2 - scroll_height - MMI_BUTTON_BAR_HEIGHT);

    input_box_y = MAIN_LCD_DEVICE_HEIGHT - MMI_BUTTON_BAR_HEIGHT - CAT200_INPUTBOX_H - 1;
    
    move_fixed_list(0, (CAT202_SCROLL_Y + scroll_height));
    resize_fixed_icontext_menuitems(0, MMI_MENUITEM_HEIGHT);
    set_fixed_icontext_positions(2*MMI_ICONTEXT_MENUITEM_HEIGHT + 3, 0, MMI_ICONTEXT_MENUITEM_HEIGHT + 2, 0);

    input_box_width = MMI_content_width - CAT200_INPUTBOX_X - CAT200_MARGIN_WIDTH - 1/* border */;
    input_box_x = CAT200_INPUTBOX_X;

    ExitCategoryFunction = ExitCategory200Screen;
    dm_setup_category_functions(wgui_cat199_redraw_screen, GetCategory200History, GetCategory200HistorySize);   /* 102605 quick search history Calvin add */

    dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND | DM_SHOW_VKPAD;
#if !defined(GUI_EDITOR_SHOW_TITLE) && (!defined(__MMI_FTE_SUPPORT__))
    dm_data.s32flags |= DM_NO_TITLE;
#endif /* !defined(GUI_EDITOR_SHOW_TITLE) */        
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    if (info_message != NULL)
    {
        dm_data.s32CatId = MMI_CATEGORY202_ID;
    }
    else
    {
        dm_data.s32CatId = MMI_CATEGORY202_NOINFO_ID;
    }
    dm_setup_data(&dm_data);


    h_flag = set_list_menu_category_history(MMI_CATEGORY200_ID, history_buffer);
#ifdef __MMI_UI_HINTS_IN_MENUITEM__
    if (get_hint_func)
    {
        if (is_set_force_icon_on_highlight_only_in_menuitem())
        {
            wgui_show_icon_only_highlight_in_icontext_menuitem();
        }
        if (is_set_force_all_hints_in_menuitem())
        {
            wgui_enable_hints_in_icontext_menuitem();
        }
        else if (is_set_force_hints_on_highlight_in_menuitem())
        {
            wgui_enable_hint_highlight_in_icontext_menuitem();
        }
        else
        {
            wgui_enable_hint_highlight_in_icontext_menuitem();
        }

        if (h_flag)
        {
            set_dynamic_pop_up_descriptions(MMI_fixed_list_menu.highlighted_item);
        }
        else
        {
            set_dynamic_pop_up_descriptions(highlighted_item);
        }

    #ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
        gui_block_list_effect();
    #endif 
    }
#endif /* __MMI_UI_HINTS_IN_MENUITEM__ */ 


    /* set check-box */
    wgui_menuitem_set_icontext_checkbox_position(1, 0);
    wgui_menuitem_register_icontext_checkbox_callback(set_state_func, get_state_func);


    if (h_flag)
    {
        S32 s = sizeof(list_menu_category_history);

        s = (s + 3) / 4;
        s *= 4;

        first_item = MMI_fixed_list_menu.first_displayed_item;
        last_item = MMI_fixed_list_menu.last_displayed_item;
        dynamic_list_goto_item_no_redraw(MMI_fixed_list_menu.highlighted_item);
        MMI_fixed_list_menu.first_displayed_item = first_item;
        MMI_fixed_list_menu.last_displayed_item = last_item;

        wgui_inputs_sl_disable_up_down_key_register(MMI_TRUE);
        wgui_setup_singleline_inputbox(
            input_box_x,
            (input_box_y),
            input_box_width,
            CAT200_INPUTBOX_H,
            buffer,
            buffer_max_length,
            MMI_CATEGORY200_ID,
            get_string(right_softkey),
            NULL,
            IMM_INPUT_TYPE_QUICK_SEARCH,
            (U8*) (history_buffer + s),
            0); 
        if (cat200_search_function)
        {
            S32 no_entries;

            no_entries = cat200_search_function((U8*) MMI_singleline_inputbox.text);
            load_dynamic_item_buffer(no_entries);
            refresh_search_list_change_list_ext(no_entries, MMI_fixed_list_menu.highlighted_item);
        }
    }
    else
    {
        dynamic_list_goto_item_no_redraw(highlighted_item);
        wgui_inputs_sl_disable_up_down_key_register(MMI_TRUE);
        wgui_setup_singleline_inputbox(
            input_box_x,
            (input_box_y),
            input_box_width,
            CAT200_INPUTBOX_H,
            buffer,
            buffer_max_length,
            MMI_CATEGORY200_ID,
            get_string(right_softkey),
            NULL,
            IMM_INPUT_TYPE_QUICK_SEARCH,
            NULL,
            0); 
    }

#ifndef __MMI_FTE_SUPPORT__
    gui_set_single_line_input_box_theme(&MMI_singleline_inputbox, &cat200_singleline_inputbox_theme);
    cat200_search_img = search_image;
#endif

    resize_dynamic_icontext_menuitems_to_list_width();

    if (h_flag)
    {
        set_dynamic_pop_up_descriptions(MMI_fixed_list_menu.highlighted_item);
    }
    else
    {
        set_dynamic_pop_up_descriptions(highlighted_item);
    }

    singleline_inputbox_input_callback();
    wgui_singleline_inputbox_LSK_label_icon = NULL;
    wgui_singleline_inputbox_LSK_label_string = get_string(left_softkey);
    if (!h_flag)
    {
        if (number_of_items > 0)
        {
            set_left_softkey_label(wgui_singleline_inputbox_LSK_label_string);
            set_left_softkey_icon(wgui_singleline_inputbox_LSK_label_icon);
            redraw_left_softkey();
            register_left_softkey_handler();
            set_left_softkey_function(wgui_singleline_inputbox_LSK_function, KEY_EVENT_UP);
            set_left_softkey_function(UI_dummy_function, KEY_EVENT_DOWN);
        }
        else
        {
            set_left_softkey_label(NULL);
            set_left_softkey_icon(NULL);
            redraw_left_softkey();
            set_left_softkey_function(UI_dummy_function, KEY_EVENT_UP);
            set_left_softkey_function(UI_dummy_function, KEY_EVENT_DOWN);
        }
    }
    register_singleline_inputbox_input_callback(wgui_cat200_editor_change_callback);
    
    gdi_layer_unlock_frame_buffer();

    dm_register_category_controlled_callback(RedrawCategoryControlledArea202Screen);
    dm_register_vkpad_callback(cat202_virtual_keypad_callback);
#ifdef __MMI_TOUCH_SCREEN__
    wgui_register_category_screen_control_area_pen_handlers(
        Cate200CategoryControlAreaPenDownHandler,
        MMI_PEN_EVENT_DOWN);
    wgui_register_category_screen_control_area_pen_handlers(Cate200CategoryControlAreaPenUpHandler, MMI_PEN_EVENT_UP);
    wgui_register_category_screen_control_area_pen_handlers(
        Cate200CategoryControlAreaPenMoveHandler,
        MMI_PEN_EVENT_MOVE);
    wgui_register_category_screen_control_area_pen_handlers(
        Cate200CategoryControlAreaPenLongTapHandler,
        MMI_PEN_EVENT_LONG_TAP);
    wgui_register_category_screen_control_area_pen_handlers(
        Cate200CategoryControlAreaPenRepeatHandler,
        MMI_PEN_EVENT_REPEAT);
#endif /* __MMI_TOUCH_SCREEN__ */ 

#if defined(__MMI_VIRTUAL_KEYBOARD__)
    wgui_virtual_keyboard_register_hide_cursor_callback(wgui_cat_stop_pop_up_description_scroll);
    wgui_virtual_keyboard_register_blink_cursor_callback(wgui_cat_resume_pop_up_description_scroll);
#endif
    
    dm_redraw_category_screen();

}


/*****************************************************************************
 * FUNCTION
 *  ShowCategory202Screen_ext
 * DESCRIPTION
 *  category screen of phone search and Multi Select
 * PARAMETERS
 *  title                   [IN]        Title id
 *  title_icon              [IN]        Title icon
 *  left_softkey            [IN]        Left soft key label
 *  left_softkey_icon       [IN]        Left soft key icon
 *  right_softkey           [IN]        Right soft key label
 *  right_softkey_icon      [IN]        Right soft key icon
 *  number_of_items         [IN]        Number of items
 *  get_item_func           [IN]        
 *  get_hint_func           [IN]        
 *  highlighted_item        [IN]        Highlighted item index
 *  search_image            [IN]        Seach image 
 *  left_icon               [IN]        Menuitme left icon 
 *  right_icon              [IN]        Menuitme right icon 
 *  buffer                  [IN]        Buffer
 *  buffer_max_length       [IN]        
 *  history_buffer          [IN]        Histpry buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory202Screen_ext_int(
        U16 title,
        U16 title_icon,
        U16 left_softkey,
        U16 right_softkey,
        U8* info_message,
        S32 number_of_items,
        GetAsyncItemFuncPtr get_item_func,
        GetAsyncHintFuncPtr get_hint_func,
        checkbox_get_image_funcptr_type get_state_func,
        checkbox_clicked_funcptr_type set_state_func,        
        S32 highlighted_item,
        U16 search_image,
        PU8 left_icon,
        PU8 right_icon,
        U8 *buffer,
        S32 buffer_max_length,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;
    S32 input_box_width = 0;
    U8 h_flag;
    S32 scroll_height = 0;
    S32 first_item, last_item;
    S32 list_height = 0, left_icon_w = 0, left_icon_h = 0, right_icon_w = 0, right_icon_h = 0;
    S32 checkbox_w = 0, checkbox_h = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_setup_common_layout();
    gdi_layer_lock_frame_buffer();

#ifdef __MMI_PHONEBOOK_LIST_THUMBNAIL__
    wgui_cat_thumbnail_init(number_of_items);
#endif 
    g_wgui_cat200_resize_and_move_func = wgui_cat200_resize_and_move;

#ifndef __MMI_FTE_SUPPORT__
    g_wgui_cat200_draw_information_bar_func = wgui_cat199_draw_input_method;
#endif

    /* Title,shortcut and Softkey */
#ifndef  MMI_CATEGORIES_SUPPORT_EDITOR_INFO_BAR   
    dm_add_title_id(title, title_icon);
#endif /*MMI_CATEGORIES_SUPPORT_EDITOR_INFO_BAR*/

    wgui_title_set_menu_shortcut_number(-1);
    wgui_title_disable_menu_shortcut_display(MMI_TRUE);
    
    dm_add_softkey_id(left_softkey, right_softkey);
    if (info_message != NULL)
    {
        /* Scroll Text */
        dm_add_scroll_text(
            (UI_string_type)info_message, 
            NULL, 
            DrawCate384CategoryControlAreaBackground, 
            *current_MMI_theme->list_normal_text_color,
            *current_MMI_theme->list_normal_text_color);
        scroll_height = CAT202_SCROLL_HEIGHT;
    }

    g_wgui_cat_is_async_dynamic_list = MMI_TRUE;
    wgui_async_list_create_multi_icontext_menu(
        number_of_items,
        1, /* text */
        2, /* icon */
        get_item_func,
        get_hint_func,
        highlighted_item,
        MMI_MENUITEM_HEIGHT,
        0,
        0,
        NULL);

#ifdef __MMI_PHONEBOOK_LIST_THUMBNAIL__
    set_fixed_icontext_list_menuitems_post_display(wgui_cat_thumbnail_post_display_callback);
#endif
    /* set the icon/text position */
    if (left_icon != NULL)
    {
        gui_measure_image(left_icon, &left_icon_w, &left_icon_h);
    }
    if (right_icon != NULL)
    {
        gui_measure_image(right_icon, &right_icon_w, &right_icon_h);
    }

    gui_measure_image(get_image(CHECKBOX_ON_IMAGE_ID), &checkbox_w, &checkbox_h);
    set_fixed_icontext_list_icon_coordinates(
        0, 
        WGUI_CAT199_GAP_1 + checkbox_w,
        0,
        left_icon_w, 
        MMI_ICONTEXT_MENUITEM_HEIGHT);
    set_fixed_icontext_list_icon_coordinates(
        1, 
        MMI_fixed_list_menu.width - MMI_fixed_list_menu.vbar.width - WGUI_CAT199_GAP_4 - right_icon_w, 
        0, 
        right_icon_w, 
        MMI_ICONTEXT_MENUITEM_HEIGHT);
    set_fixed_icontext_list_text_coordinates(
        0, 
        WGUI_CAT199_GAP_1 + left_icon_w + WGUI_CAT199_GAP_2 + checkbox_w, 
        0,
        MMI_fixed_list_menu.width - MMI_fixed_list_menu.vbar.width  - left_icon_w - right_icon_w - WGUI_CAT199_GAP_1 - WGUI_CAT199_GAP_2 - WGUI_CAT199_GAP_3 - WGUI_CAT199_GAP_4 - checkbox_w, 
        MMI_ICONTEXT_MENUITEM_HEIGHT);

    MMI_fixed_icontext_list_menuitem.flags |= UI_MENUITEM_CENTER_TEXT_Y;
    g_wgui_cat200_set_special_key_func = wgui_cat200_set_left_and_right_arrow_key;

#ifdef __MMI_TOUCH_SCREEN__
    /* Because the list menu is resized according to virtual keyboard */
    MMI_fixed_list_menu.flags |= UI_LIST_MENU_ALIGN_TO_TOP;
#endif /* __MMI_TOUCH_SCREEN__ */ 

#ifdef __MMI_ICON_BAR_SUPPORT__
#ifdef __MMI_FTE_SUPPORT__
        if (wgui_icon_bar_is_created())
        {
            list_height = MAIN_LCD_DEVICE_HEIGHT - CAT202_SCROLL_Y - CAT200_INPUTBOX_H - 2 - scroll_height - MMI_BUTTON_BAR_HEIGHT - MMI_ICON_BAR_HEIGHT;
            input_box_y = MAIN_LCD_DEVICE_HEIGHT - MMI_BUTTON_BAR_HEIGHT - CAT200_INPUTBOX_H - 1 - MMI_ICON_BAR_HEIGHT;
        }
        else
#endif /* __MMI_FTE_SUPPORT__ */
#endif/*__MMI_ICON_BAR_SUPPORT__*/
        {
            list_height = MAIN_LCD_DEVICE_HEIGHT - CAT202_SCROLL_Y - CAT200_INPUTBOX_H - 2 - scroll_height - MMI_BUTTON_BAR_HEIGHT;
            input_box_y = MAIN_LCD_DEVICE_HEIGHT - MMI_BUTTON_BAR_HEIGHT - CAT200_INPUTBOX_H - 1;
        }

#ifdef MMI_CATEGORIES_SUPPORT_EDITOR_INFO_BAR
    list_height =UI_device_height - MMI_button_bar_height - INFO_HIGHT - CAT200_INPUTBOX_H - 2;  
#endif/*MMI_CATEGORIES_SUPPORT_EDITOR_INFO_BAR*/
    resize_fixed_list(MMI_content_width, list_height);    
    move_fixed_list(0, (CAT202_SCROLL_Y + scroll_height));
#ifdef MMI_CATEGORIES_SUPPORT_EDITOR_INFO_BAR
        move_fixed_list(0, INFO_HIGHT);    
#endif/*MMI_CATEGORIES_SUPPORT_EDITOR_INFO_BAR*/
    resize_fixed_icontext_menuitems(0, MMI_MENUITEM_HEIGHT);
    set_fixed_icontext_positions(2*MMI_ICONTEXT_MENUITEM_HEIGHT + 3, 0, MMI_ICONTEXT_MENUITEM_HEIGHT + 2, 0);

    input_box_width = MMI_content_width - CAT200_INPUTBOX_X - CAT200_MARGIN_WIDTH - 1/* border */;
    input_box_x = CAT200_INPUTBOX_X;

    ExitCategoryFunction = ExitCategory200Screen;
    dm_setup_category_functions(wgui_cat199_redraw_screen, GetCategory200History, GetCategory200HistorySize);   /* 102605 quick search history Calvin add */

    dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND | DM_SHOW_VKPAD;
#if !defined(GUI_EDITOR_SHOW_TITLE) && (!defined(__MMI_FTE_SUPPORT__))
    dm_data.s32flags |= DM_NO_TITLE;
#endif /* !defined(GUI_EDITOR_SHOW_TITLE) */        
#ifdef MMI_CATEGORIES_SUPPORT_EDITOR_INFO_BAR
        dm_data.s32flags |= DM_NO_TITLE|DM_NO_STATUS_BAR;   
#endif/*MMI_CATEGORIES_SUPPORT_EDITOR_INFO_BAR*/ 
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    if (info_message != NULL)
    {
        dm_data.s32CatId = MMI_CATEGORY202_ID;
    }
    else
    {
        dm_data.s32CatId = MMI_CATEGORY202_NOINFO_ID;
    }
    dm_setup_data(&dm_data);


    h_flag = set_list_menu_category_history(MMI_CATEGORY200_ID, history_buffer);
#ifdef __MMI_UI_HINTS_IN_MENUITEM__
    if (get_hint_func)
    {
        if (is_set_force_icon_on_highlight_only_in_menuitem())
        {
            wgui_show_icon_only_highlight_in_icontext_menuitem();
        }
        if (is_set_force_all_hints_in_menuitem())
        {
            wgui_enable_hints_in_icontext_menuitem();
        }
        else if (is_set_force_hints_on_highlight_in_menuitem())
        {
            wgui_enable_hint_highlight_in_icontext_menuitem();
        }
        else
        {
            wgui_enable_hint_highlight_in_icontext_menuitem();
        }

        if (h_flag)
        {
            set_asyncdynamic_pop_up_descriptions(MMI_fixed_list_menu.highlighted_item);
        }
        else
        {
            set_asyncdynamic_pop_up_descriptions(highlighted_item);
        }

    #ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
        gui_block_list_effect();
    #endif 
    }
#endif /* __MMI_UI_HINTS_IN_MENUITEM__ */ 


    /* set check-box */
    wgui_menuitem_set_icontext_list_checkbox_position(1, 0);
    wgui_menuitem_register_icontext_list_checkbox_callback(set_state_func, get_state_func);


    if (h_flag)
    {
        S32 s = sizeof(list_menu_category_history);

        s = (s + 3) / 4;
        s *= 4;

        first_item = MMI_fixed_list_menu.first_displayed_item;
        last_item = MMI_fixed_list_menu.last_displayed_item;
        
        if (g_wgui_cat_is_async_dynamic_list)
        {
            asyncdynamic_list_goto_item_no_redraw(MMI_fixed_list_menu.highlighted_item);
        }
        else
        {
            dynamic_list_goto_item_no_redraw(MMI_fixed_list_menu.highlighted_item);
        }

        MMI_fixed_list_menu.first_displayed_item = first_item;
        MMI_fixed_list_menu.last_displayed_item = last_item;

        wgui_inputs_sl_disable_up_down_key_register(MMI_TRUE);
        wgui_setup_singleline_inputbox(
            input_box_x,
            (input_box_y),
            input_box_width,
            CAT200_INPUTBOX_H,
            buffer,
            buffer_max_length,
            MMI_CATEGORY200_ID,
            get_string(right_softkey),
            NULL,
            IMM_INPUT_TYPE_QUICK_SEARCH,
            (U8*) (history_buffer + s),
            0); 
        if (cat200_search_function)
        {
            S32 no_entries;

            no_entries = cat200_search_function((U8*) MMI_singleline_inputbox.text);
            //load_dynamic_item_buffer(no_entries);
            refresh_search_list_change_list_ext(no_entries, MMI_fixed_list_menu.highlighted_item);
        }
    }
    else
    {
        if (g_wgui_cat_is_async_dynamic_list)
        {
            asyncdynamic_list_goto_item_no_redraw(highlighted_item);
        }
        else
        {
            dynamic_list_goto_item_no_redraw(highlighted_item);
        }

        wgui_inputs_sl_disable_up_down_key_register(MMI_TRUE);
        wgui_setup_singleline_inputbox(
            input_box_x,
            (input_box_y),
            input_box_width,
            CAT200_INPUTBOX_H,
            buffer,
            buffer_max_length,
            MMI_CATEGORY200_ID,
            get_string(right_softkey),
            NULL,
            IMM_INPUT_TYPE_QUICK_SEARCH,
            NULL,
            0); 
    }

#ifndef __MMI_FTE_SUPPORT__
    gui_set_single_line_input_box_theme(&MMI_singleline_inputbox, &cat200_singleline_inputbox_theme);
    cat200_search_img = search_image;
#endif

    //resize_dynamic_icontext_menuitems_to_list_width();
    resize_asyncdynamic_icontext_menuitems_to_list_width();

    if (h_flag)
    {
        set_asyncdynamic_pop_up_descriptions(MMI_fixed_list_menu.highlighted_item);
    }
    else
    {
        set_asyncdynamic_pop_up_descriptions(highlighted_item);
    }

    singleline_inputbox_input_callback();
    wgui_singleline_inputbox_LSK_label_icon = NULL;
    wgui_singleline_inputbox_LSK_label_string = get_string(left_softkey);
    if (!h_flag)
    {
        if (number_of_items > 0)
        {
            set_left_softkey_label(wgui_singleline_inputbox_LSK_label_string);
            set_left_softkey_icon(wgui_singleline_inputbox_LSK_label_icon);
            redraw_left_softkey();
            register_left_softkey_handler();
            set_left_softkey_function(wgui_singleline_inputbox_LSK_function, KEY_EVENT_UP);
            set_left_softkey_function(UI_dummy_function, KEY_EVENT_DOWN);
        }
        else
        {
            set_left_softkey_label(NULL);
            set_left_softkey_icon(NULL);
            redraw_left_softkey();
            set_left_softkey_function(UI_dummy_function, KEY_EVENT_UP);
            set_left_softkey_function(UI_dummy_function, KEY_EVENT_DOWN);
        }
    }
    register_singleline_inputbox_input_callback(wgui_cat200_editor_change_callback);
    
    gdi_layer_unlock_frame_buffer();

    dm_register_category_controlled_callback(RedrawCategoryControlledArea202Screen);
    dm_register_vkpad_callback(cat202_virtual_keypad_callback);
#ifdef __MMI_TOUCH_SCREEN__
    wgui_register_category_screen_control_area_pen_handlers(
        Cate200CategoryControlAreaPenDownHandler,
        MMI_PEN_EVENT_DOWN);
    wgui_register_category_screen_control_area_pen_handlers(Cate200CategoryControlAreaPenUpHandler, MMI_PEN_EVENT_UP);
    wgui_register_category_screen_control_area_pen_handlers(
        Cate200CategoryControlAreaPenMoveHandler,
        MMI_PEN_EVENT_MOVE);
    wgui_register_category_screen_control_area_pen_handlers(
        Cate200CategoryControlAreaPenLongTapHandler,
        MMI_PEN_EVENT_LONG_TAP);
    wgui_register_category_screen_control_area_pen_handlers(
        Cate200CategoryControlAreaPenRepeatHandler,
        MMI_PEN_EVENT_REPEAT);
#endif /* __MMI_TOUCH_SCREEN__ */ 

#if defined(__MMI_VIRTUAL_KEYBOARD__)
    wgui_virtual_keyboard_register_hide_cursor_callback(wgui_cat_stop_pop_up_description_scroll);
    wgui_virtual_keyboard_register_blink_cursor_callback(wgui_cat_resume_pop_up_description_scroll);
#endif
    
    dm_redraw_category_screen();
    wgui_fixed_list_set_alpha_blending_layer(dm_get_scr_bg_layer());
#ifdef __MMI_PHONEBOOK_LIST_THUMBNAIL__
    wgui_cat_thumbnail_post_init(number_of_items);
#endif
}


/* for category 201 */
static MMI_BOOL g_wgui_cat201_is_timer_started = MMI_FALSE;
BOOL(*g_wgui_cat201_check_language_changed) (U8 input_type) = NULL;
static MMI_BOOL g_wgui_cat201_highlight_from_history = MMI_FALSE;
static S32 g_wgui_cat201_number_of_entry_in_history = 0;

/*****************************************************************************
 * FUNCTION
 *  wgui_cat201_register_language_changed_indicator
 * DESCRIPTION
 *  register language changed indicator of category 201
 * PARAMETERS
 *  FuncPtr     [IN]        Function to register
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat201_register_language_changed_indicator(BOOL(*FuncPtr) (U8 input_type))
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_wgui_cat201_check_language_changed = FuncPtr;
}


#if defined(__MMI_TOUCH_SCREEN__)
/*****************************************************************************
 * FUNCTION
 *  wgui_cat201_virtual_keypad_callback
 * DESCRIPTION
 *  virtual keypad callback
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat201_virtual_keypad_callback(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_imc_redraw_screen_by_state();
}
#endif /* defined(__MMI_TOUCH_SCREEN__) */


/*****************************************************************************
 * FUNCTION
 *  wgui_cat201_redraw_search_list
 * DESCRIPTION
 *  refresh and draw search list
 * PARAMETERS
 *  no_entries      [IN]        Entries count
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat201_redraw_search_list(S32 no_entries)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 shortcut_width;
    S32 max_entries = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_fixed_list_menu.n_items = no_entries;
    MMI_fixed_list_menu.displayed_items = no_entries;

    if (wgui_check_application_present)
    {
        wgui_check_application_present(&max_entries);
    }
#ifndef __MMI_TITLE_BAR_NO_ICON_SHCT__
    shortcut_width = set_menu_item_count(max_entries) + 7;  /* number of element increases at the run time */
#else
    shortcut_width = 7;	/* number of element increases at the run time */
#endif/*__MMI_TITLE_BAR_NO_ICON_SHCT__*/
    resize_menu_shortcut_handler(shortcut_width, MMI_title_height);
    move_menu_shortcut_handler(UI_device_width - shortcut_width, MMI_title_y);

    if (g_wgui_cat201_highlight_from_history == MMI_TRUE && g_wgui_cat201_is_timer_started == MMI_TRUE)
    {
        dynamic_list_goto_item_no_redraw(MMI_fixed_list_menu.highlighted_item);
    }
    else
    {
        MMI_fixed_list_menu.highlighted_item = 0;   
        if (no_entries > 0)
        {
            dynamic_list_goto_item_no_redraw(MMI_fixed_list_menu.highlighted_item);
        }
        else
        {
            gui_fixed_icontext_menuitem_stop_scroll();
            gui_pop_up_description_stop_scroll();
            wgui_title_set_menu_shortcut_number(0);
            wgui_current_pop_up_description_index = -1;
        }
    }
    
#if defined(GUI_EDITOR_SHOW_TITLE)
    draw_title();
#endif
    show_dynamic_list();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat201_refresh_search_list
 * DESCRIPTION
 *  refresh category 201 search list
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat201_refresh_search_list(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 no_entries = 0;
    U8 *name = MMI_multiline_inputbox.text;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(cat200_search_function != NULL);

    if (g_wgui_cat201_highlight_from_history == MMI_TRUE && g_wgui_cat201_is_timer_started == MMI_TRUE)
    {
        /* when come back from history, list should contain same items as history and cannot search again */   
        /* If search again, search function will change list result and cause wrong result */
        no_entries = g_wgui_cat201_number_of_entry_in_history;   
    }
	else
	{
		/* not come back from history, search for right list */
		no_entries = cat200_search_function(name);
	}

    MMI_ASSERT(no_entries >= 0); /* return entry must >=0 or list will have problem */
    
    load_dynamic_item_buffer(no_entries);
    gdi_layer_lock_frame_buffer();
    wgui_cat201_redraw_search_list(no_entries); /* show list */
#ifdef __MMI_IME_FLOATING_CAND_BOX__
#ifndef __MMI_FTE_SUPPORT__ 
    wgui_inputs_ml_redraw_input_information_bar();
#endif /* __MMI_FTE_SUPPORT__ */
    mmi_imc_redraw_floating_ui_controls();
#endif
    gdi_layer_unlock_frame_buffer();
    gdi_layer_blt_previous(0, 0, UI_device_width - 1, UI_device_height - 1);

    g_wgui_cat201_highlight_from_history = MMI_FALSE;    
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat201_multiline_text_change
 * DESCRIPTION
 *  multiline input changed callback function
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat201_multiline_text_change(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_wgui_cat201_is_timer_started) /* the first time must show dynamice list */
    {
   	   g_wgui_cat201_is_timer_started = MMI_FALSE;
       gdi_layer_lock_frame_buffer();
       wgui_cat201_refresh_search_list();
       gdi_layer_unlock_frame_buffer();
    }

    /* use timer to avoid changing list too frequently (search e-dictionary spends much time) */
    gui_cancel_timer(wgui_cat201_refresh_search_list);
    gui_start_timer(20, wgui_cat201_refresh_search_list);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat201_register_key_handler
 * DESCRIPTION
 *  register default key handle function
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat201_register_key_handler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* when first word is highlighted, user should not be able to go to last item by pressing up arrow key. */
    if (MMI_fixed_list_menu.highlighted_item != 0 || MMI_fixed_list_menu.n_items == 0)
    {
        SetKeyHandler(dynamic_list_goto_previous_item, KEY_UP_ARROW, KEY_EVENT_DOWN);
        SetKeyHandler(dynamic_list_goto_previous_item, KEY_VOL_UP, KEY_EVENT_DOWN);
    }
    else
    {
        /* input method will register key event, disable here */
        SetKeyHandler(UI_dummy_function, KEY_UP_ARROW, KEY_EVENT_DOWN);
        SetKeyHandler(UI_dummy_function, KEY_VOL_UP, KEY_EVENT_DOWN);
    }
    SetKeyHandler(dynamic_list_goto_next_item, KEY_DOWN_ARROW, KEY_EVENT_DOWN);
    SetKeyHandler(dynamic_list_goto_next_item, KEY_VOL_DOWN, KEY_EVENT_DOWN);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat201_redraw_controlled_area
 * DESCRIPTION
 *  redraw category201 control area
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat201_redraw_controlled_area(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();

    /* dynamic list */
    wgui_cat201_refresh_search_list();
    dynamic_list_goto_item_no_redraw(MMI_fixed_list_menu.highlighted_item);
    show_dynamic_list();

    /* multiline inputbox */
#ifndef __MMI_FTE_SUPPORT__ 
    wgui_inputs_ml_redraw_input_information_bar();
#endif /* __MMI_FTE_SUPPORT__ */
    wgui_inputs_ml_redraw();

    gdi_layer_unlock_frame_buffer();
    gdi_layer_blt_previous(0, 0, UI_device_width - 1, UI_device_height - 1);
}


/*****************************************************************************
 * FUNCTION
 *  ExitCategory201Screen
 * DESCRIPTION
 *  exit function of category 201
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitCategory201Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_cancel_timer(wgui_cat201_refresh_search_list);
    g_wgui_cat201_check_language_changed = NULL;
    g_wgui_cat201_is_timer_started = MMI_FALSE;

    ClearHighlightHandler();

    /* IMPORTANT: 
     *        wgui_close_inputbox() must execute before reset list component & reset softkey & reset search function.
     *        When close inputbox, IME will do something that need refresh list and redraw editor.
     *        For example, IME will confirm multitap and must redraw editor and refresh search list.
     *        If reseting list component and setting refresh function to be NULL is before close multiline inputbox,
     *        it will cause some problems.
     * wgui_close_inputbox() cannot be moved.
     */
    wgui_close_inputbox();
    
    reset_softkeys();
    reset_menu_shortcut_handler();
    reset_fixed_list();
    reset_dynamic_list();
    reset_pop_up_descriptions();
    wgui_reset_multiline_inputbox_register_up_down_key_funcptr();
    g_wgui_cat201_highlight_from_history = MMI_FALSE;    
    cat200_search_function = NULL;      
}


/*****************************************************************************
 * FUNCTION
 *  GetCategory201HistorySize
 * DESCRIPTION
 *  Gets the history buffer size of category 201
 * PARAMETERS
 *  void
 * RETURNS
 *  size in U8 of the history buffer
 *****************************************************************************/
S32 GetCategory201HistorySize(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return (((sizeof(list_menu_category_history) + 3) / 4) * 4 + sizeof(multiline_inputbox_category_history));
}


/*****************************************************************************
 * FUNCTION
 *  GetCategory201History
 * DESCRIPTION
 *  Gets the history buffer of category 201
 * PARAMETERS
 *  history_buffer     [OUT]        Is the buffer into which the history data is stored
 * RETURNS
 *  return history buffer
 *****************************************************************************/
U8 *GetCategory201History(U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 s;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    get_list_menu_category_history(MMI_CATEGORY201_ID, history_buffer);
    s = sizeof(list_menu_category_history);
    s = (s + 3) / 4;
    s *= 4;
    get_multiline_inputbox_category_history(MMI_CATEGORY201_ID, (U8*) (history_buffer + s));
    return (history_buffer);
}


/*****************************************************************************
 * FUNCTION
 *  ShowCategory201Screen
 * DESCRIPTION
 *  category screen of phone search
 * PARAMETERS
 *  title                       [IN]        Title id
 *  title_icon                  [IN]        Title icon
 *  left_softkey                [IN]        Left soft key label
 *  left_softkey_icon           [IN]        Left soft key icon
 *  right_softkey               [IN]        Right soft key label
 *  right_softkey_icon          [IN]        Right soft key icon
 *  number_of_items             [IN]        Number of items
 *  get_item_func               [IN]        Function to get item
 *  get_hint_func               [IN]        Function to get hint
 *  highlighted_item            [IN]        Highlighted item index
 *  search_image                [IN]        Seach image
 *  buffer                      [IN]        Buffer
 *  buffer_max_length           [IN]        Length
 *  input_type                  [IN]        Input type
 *  history_buffer              [IN]        Histpry buffer
 *  required_input_mode_set     [IN]        Input mode set
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory201Screen_int(
        U16 title,
        U16 title_icon,
        U16 left_softkey,
        U16 right_softkey,
        S32 number_of_items,
        GetItemFuncPtr get_item_func,
        GetHintFuncPtr get_hint_func,
        S32 highlighted_item,
        U16 search_image,
        U8 *buffer,
        S32 buffer_max_length,
        U32 input_type,
        U8 *history_buffer,
        mmi_imm_input_mode_enum *required_input_mode_set)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;
    U8 h_flag;
    BOOL languageChanged = FALSE;
    S32 iwidth, iheight, max_entries = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();
    
    g_wgui_cat201_is_timer_started = MMI_TRUE;

    dm_add_title_id(title, title_icon);
    dm_add_softkey_id(left_softkey, right_softkey);
    if (history_buffer)
    {
        if (mmi_imm_get_user_desired_input_mode() != IMM_INPUT_MODE_NONE)
        {
            languageChanged = g_wgui_cat201_check_language_changed((U8) mmi_imm_get_user_desired_input_mode());
        }
    }

    wgui_dynamic_list_create_icontext_menu(
        number_of_items,
        get_item_func,
        get_hint_func,
        WGUI_LIST_INVALID_HIGHLIGHT,
        MMI_FALSE,
        UI_dummy_function,
        0,
        0,
        NULL);

    /* because set menu as UI_LIST_MENU_DISABLE_SCROLLBAR, it should set focussed_without_sc_filler as default filler */
    MMI_fixed_icontext_menuitem.focussed_without_sc_filler = MMI_fixed_icontext_menuitem.focussed_filler;

    /* disable shortcut must after create dynamic list, because dynamic list default has shortcut */
    //wgui_set_disable_shortcut_display();
    wgui_title_set_no_icon_shct(MMI_FALSE);
    
    if (wgui_check_application_present)
    {
        wgui_check_application_present(&max_entries);
    }

    MMI_fixed_list_menu.flags |= UI_LIST_MENU_ALIGN_TO_TOP | UI_LIST_MENU_DISABLE_SCROLLBAR;

    h_flag = set_list_menu_category_history(MMI_CATEGORY201_ID, history_buffer);

    if (h_flag)
    {
        S32 s = sizeof(list_menu_category_history);
        
        g_wgui_cat201_highlight_from_history = MMI_TRUE;

        s = (s + 3) / 4;
        s *= 4;
        MMI_fixed_list_menu.item_measure_function(NULL, MMI_fixed_list_menu.common_item_data, &iwidth, &iheight);
        MMI_fixed_list_menu.height = iheight * MMI_fixed_list_menu.displayed_items + 10;        /* need to handle this in more cleaner way, it is 22X4 +10 =98, as we only show 4 rows */

        if (languageChanged)
        {
            MMI_fixed_list_menu.highlighted_item = 0;
        }
        
        dynamic_list_goto_item_no_redraw(MMI_fixed_list_menu.highlighted_item);
        wgui_setup_inputbox_ext(
            0,
            0,
            UI_device_width/* - temp_w*/,
            CAT201_EDITOR_HEIGHT,
            buffer,
            buffer_max_length,
            MMI_CATEGORY201_ID,
            get_string(right_softkey),
            NULL,
            input_type,
            history_buffer + s,
            required_input_mode_set,
        #ifdef __MMI_FTE_SUPPORT__        
            0,
        #else
            1,
        #endif
            UI_MULTI_LINE_INPUT_BOX_AUTO_DISABLE_SCROLLBAR,
            0,
            0,
            0,
            0,
            NULL);

        if (languageChanged)
        {
            multiline_inputbox_delete_all_characters();
            set_right_softkey_function(GoBackHistory, KEY_EVENT_UP);
        }
        
        g_wgui_cat201_number_of_entry_in_history = MMI_fixed_list_menu.n_items;        
    }
    else
    {
        g_wgui_cat201_highlight_from_history = MMI_FALSE;
        wgui_setup_inputbox_ext(
            0,
            0,
            UI_device_width/* - temp_w*/,
            CAT201_EDITOR_HEIGHT,
            buffer,
            buffer_max_length,
            MMI_CATEGORY201_ID,
            get_string(right_softkey),
            NULL,
            input_type,
            NULL,
            required_input_mode_set,
        #ifdef __MMI_FTE_SUPPORT__        
            0,
        #else
            1,
        #endif
            UI_MULTI_LINE_INPUT_BOX_AUTO_DISABLE_SCROLLBAR,
            0,
            0,
            0,
            0,
            NULL);
        dynamic_list_goto_item_no_redraw(highlighted_item);
    }

    /* multiline inputbox */
    MMI_multiline_inputbox.change_callback = wgui_cat201_multiline_text_change;
    wgui_set_multiline_inputbox_register_up_down_key_funcptr(wgui_cat201_register_key_handler);
     /* up and down keys are handled by list menu */
     /* can't remove */
    register_dynamic_list_keys();
    resize_dynamic_icontext_menuitems_to_list_width();
    if (h_flag)
    {
        set_dynamic_pop_up_descriptions(MMI_fixed_list_menu.highlighted_item);
        if (MMI_fixed_list_menu.highlighted_item <= 0)
        {
            ClearKeyHandler(KEY_UP_ARROW, KEY_EVENT_DOWN);
            ClearKeyHandler(KEY_VOL_UP, KEY_EVENT_DOWN);
        }
    }
    else
    {
        set_dynamic_pop_up_descriptions(highlighted_item);
    }
    wgui_singleline_inputbox_LSK_label_icon = NULL;
    wgui_singleline_inputbox_LSK_label_string = get_string(left_softkey);

    gdi_layer_unlock_frame_buffer();
    
    ExitCategoryFunction = ExitCategory201Screen;
    dm_setup_category_functions(dm_redraw_category_screen, GetCategory201History, GetCategory201HistorySize);    
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32CatId = MMI_CATEGORY201_ID;
    dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND;
#if !defined(GUI_EDITOR_SHOW_TITLE)
    dm_data.s32flags |= DM_NO_TITLE;
#endif /* !defined(GUI_EDITOR_SHOW_TITLE) */  
#ifdef __MMI_TOUCH_SCREEN__
    dm_data.s32flags |= DM_SHOW_VKPAD;
    dm_register_vkpad_callback(wgui_cat201_virtual_keypad_callback);
#endif      
    dm_setup_data(&dm_data);

    dm_redraw_category_screen();
}


#ifdef __MMI_PHONEBOOK_LIST_THUMBNAIL__
/*****************************************************************************
 * FUNCTION
 *  wgui_cat_thumbnail_is_cached
 * DESCRIPTION
 *  check file manager is cached by index
 * PARAMETERS
 *  idx              [IN]     Index to test
 *  node_p           [IN]     Cache pointer if cached
 * RETURNS
 *  MMI_BOOL                  If it is cached
 *****************************************************************************/
static MMI_BOOL wgui_cat_thumbnail_is_cached(S32 idx, wgui_cat_thumbnail_cache_node **node_p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_cat_thumbnail_cache_node *current_node_p;
    U16 id;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_thumbnail_cache_p == NULL)
    {
        return MMI_FALSE;
    }
	if(idx >= MMI_fixed_list_menu.n_items)
		return MMI_FALSE;

    id = g_thumbnail_get_store_id_func(idx);
    current_node_p = g_thumbnail_cache_p->cache_search_list.front_p;

    while (current_node_p != NULL)
    {
        if(current_node_p->id == id)
            break;
        current_node_p = current_node_p->next;
    }

    *node_p = current_node_p;

    if (current_node_p == NULL)
    {
        return MMI_FALSE;
    }

    if (current_node_p->state == WGUI_CAT_THUMBNAIL_CACHED)
    {
        return MMI_TRUE;
    }
    else
    {
        return MMI_FALSE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_fmgr_cache_stop_decoder
 * DESCRIPTION
 *  Filemanager stop cache decoder
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat_thumbnail_stop_decoder(void)
{
    wgui_cat_thumbnail_cache_node *current_node_p;
    
    if (g_thumbnail_cache_p == NULL)
    {
        return;
    }
    
    current_node_p = g_thumbnail_cache_p->cur_decode_p;
    if (current_node_p != NULL)
    {
        if (current_node_p->state == WGUI_CAT_THUMBNAIL_CACHING)
        {
            /* Stop decoder */
            if(g_thumbnail_cache_p->decoder_type == WGUI_THUMBNAIL_DECODER_TYPE_NEW)
            {
                gdi_imgdec_nb_stop(g_thumbnail_cache_p->decoding_handle);
            }
            else if(g_thumbnail_cache_p->decoder_type == WGUI_THUMBNAIL_DECODER_TYPE_OLD)
            {
                gdi_image_decoder_stop(g_thumbnail_cache_p->decoding_handle);
            }
            current_node_p->state = WGUI_CAT_THUMBNAIL_CACHENONE;

            /* Free decoding layer first */
            if (g_thumbnail_cache_p->decoding_layer != NULL)
            {
                gdi_layer_free(g_thumbnail_cache_p->decoding_layer);
                g_thumbnail_cache_p->decoding_layer = NULL;
            }

            /* Remove it from link list */
            if (current_node_p->next == NULL)
            {
                if (current_node_p->prev == NULL)
                {
                    /* It's the only item in this slot */
                    g_thumbnail_cache_p->cache_search_list.front_p = NULL;
                    g_thumbnail_cache_p->cache_search_list.rear_p = NULL;
                }
                else
                {
                    /* It's the last item */  
                    g_thumbnail_cache_p->cache_search_list.rear_p = current_node_p->prev;
                    current_node_p->prev->next = NULL;
                    current_node_p->prev = NULL;
                }
            }
            else if (current_node_p->prev == NULL)
            {
                /* It's the first item */
                g_thumbnail_cache_p->cache_search_list.front_p = current_node_p->next;
                current_node_p->next->prev = NULL;
                current_node_p->next = NULL;                
            }
            else
            {
                current_node_p->prev->next = current_node_p->next;
                current_node_p->next->prev = current_node_p->prev;
                current_node_p->next = NULL;
                current_node_p->prev = NULL;
            }
        }
    }
    StopTimer(FMGR_DELAY_DECODE_0);

}

/*****************************************************************************
 * FUNCTION
 *  wgui_cat_fmgr_cache_list_decoding_next
 * DESCRIPTION
 *  Filemanager Decoding next item by cache order.
 * PARAMETERS
 *  idx                     [IN] Index to cache
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat_thumbnail_cache_list_decoding_next(S32 idx)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_thumbnail_info_struct menuitem_data;
    wgui_cat_thumbnail_cache_node *current_node_p = NULL;
    MMI_BOOL is_next_directly = MMI_TRUE;
	MMI_BOOL is_displayable = MMI_TRUE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_thumbnail_cache_p == NULL)
    {
        return;
    }  

    if (idx >= MMI_fixed_list_menu.n_items || idx < 0)
    {
        return;
    }

    wgui_cat_thumbnail_get_menuitem(idx, &menuitem_data);

    g_thumbnail_cache_p->decoding_index = idx;
    if(wgui_thumbnail_get_displayable != NULL)
    {
        is_displayable = wgui_thumbnail_get_displayable(idx);
    }
    if (menuitem_data.is_show_thumb && is_displayable)
    {
        /* create jpeg decoder */
        if (g_thumbnail_cache_p->decoder_create == 0)
        {
            /* max image size is 100x100 */
            gdi_image_decoder_create(100, 100, wgui_cat_thumbnail_decode_result_hdlr);
            g_thumbnail_cache_p->decoder_create = 1;
        }
        

        if (!wgui_cat_thumbnail_is_cached(idx, &current_node_p))
        {
            if (g_thumbnail_cache_p->cur_decode_p == NULL || g_thumbnail_cache_p->cur_decode_p->state == WGUI_CAT_THUMBNAIL_CACHENONE || g_thumbnail_cache_p->cur_decode_p->state == WGUI_CAT_THUMBNAIL_CACHEERROR)
            {
                /* Pass node to make search faster */
                wgui_cat_thumbnail_cache_list_add(idx, menuitem_data.file_icon_ptr, current_node_p);
                if (g_thumbnail_cache_p->cur_decode_p != NULL)
                {
                    /* Start decoding image */
                    StartNonAlignTimer(FMGR_DELAY_DECODE_0, WGUI_CAT_THUMBNAIL_UI_DELAY_DECODE_NEXT_DUR, wgui_cat_thumbnail_delay_decode_timer);
                }
                /* If cur_decode_p is NULL, do not need to continue cache next */
                is_next_directly = MMI_FALSE;
            }
        }
    }
    else
    {
        if (g_thumbnail_cache_p->cur_decode_p != NULL)
        {
            if (g_thumbnail_cache_p->cur_decode_p->state == WGUI_CAT_THUMBNAIL_CACHENONE)
            {
                g_thumbnail_cache_p->cur_decode_p->state = WGUI_CAT_THUMBNAIL_CACHEERROR;
            }
        }        
    }

    if (is_next_directly)
    {
        StartNonAlignTimer(FMGR_DELAY_DECODE_0, WGUI_CAT_THUMBNAIL_UI_DELAY_DECODE_NEXT_DUR, wgui_cat_thumbnail_start_next);
    }
    
}

static void wgui_cat_thumbnail_draw_attachment_icon(S32 item_index, S32 x, S32 y);

/*****************************************************************************
 * FUNCTION
 *  wgui_cat_thumbnail_draw_cached_img
 * DESCRIPTION
 *  Filemanager draw a cached image to the layer and blt to screen.
 * PARAMETERS
 *  node_p              [IN]    Cache node of the image
 *  x                   [IN]    x position to draw
 *  y                   [IN]    y position to draw
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat_thumbnail_draw_cached_img(wgui_cat_thumbnail_cache_node *node_p, S32 x, S32 y)
{
    S32 box_width = image_box_width;
    S32 box_height = image_box_height;
    
    gdi_rect_struct dest_clip;
    gdi_handle act_layer;
    
    S32 image_width,image_height;
    S32 draw_pos_x, draw_pos_y;

    gdi_color box_hilight_color;
    S32 temp_y1, temp_y2;
    S32 box_clip_y1, box_clip_y2;
    MMI_BOOL is_in_ssp = gui_screen_smooth_scrolling_by_pen();

    if (g_thumbnail_cache_p == NULL)
    {
        return;
    }  
    gdi_layer_get_active(&act_layer);

    image_width = node_p->cache_width;
    image_height = node_p->cache_height;

    if (image_width < box_width)
    {
        draw_pos_x = x + ((box_width-image_width)>>1);
    }
    else
    {
        draw_pos_x = x;
    }

    if (image_height < box_height)
    {
        draw_pos_y = y + ((box_height-image_height)>>1);
    }
    else
    {
        draw_pos_y = y;
    }

    dest_clip.x1 = draw_pos_x;
    dest_clip.y1 = draw_pos_y;
    dest_clip.x2 = draw_pos_x + image_width - 1;
    dest_clip.y2 = draw_pos_y + image_height - 1;

    if(dest_clip.y2 > MMI_fixed_list_menu.y + MMI_fixed_list_menu.height - 1)
    {
        dest_clip.y2 = MMI_fixed_list_menu.y + MMI_fixed_list_menu.height - 1;
    }
    temp_y1 = dest_clip.y1;
    temp_y2 = dest_clip.y2;
    box_clip_y1 = y;
    box_clip_y2 = y + image_box_height -1;

    if(box_clip_y2 > MMI_fixed_list_menu.y + MMI_fixed_list_menu.height - 1)
    {
        box_clip_y2 = MMI_fixed_list_menu.y + MMI_fixed_list_menu.height - 1;
    }
#if defined(__MMI_UI_LIST_SCROLL_BY_PIXEL__)
    {
        S32 layer_w, layer_h;
        S32 x1, y1, x2, y2;

        gdi_layer_get_dimension(&layer_w, &layer_h);
        if(layer_h == UI_device_height)
        {
            if(temp_y1 < MMI_fixed_list_menu.y)
            {
                temp_y1 = MMI_fixed_list_menu.y;
            }

            if(box_clip_y1 < MMI_fixed_list_menu.y)
            {
                box_clip_y1 = MMI_fixed_list_menu.y;
            }

            if(dest_clip.y2 < MMI_fixed_list_menu.y)
            {
                return;
            }
        }
        else
        {
            gui_get_clip(&x1, &y1, &x2, &y2);
            temp_y1 = temp_y1 > y1 ? temp_y1 : y1;
            box_clip_y1 = box_clip_y1 > y1 ? box_clip_y1 : y1;
            temp_y2 = temp_y2 > y2 ? y2 : temp_y2;
            box_clip_y2 = box_clip_y2 > y2 ? y2 : box_clip_y2;
        }
        if(dest_clip.y2 < 0)
        {
            return;
        }
    }
#endif
    if(box_clip_y1 > box_clip_y2)
        return;

    gui_push_clip();
    gui_set_clip(x, box_clip_y1, x+image_box_width-1, box_clip_y2);
    gdi_draw_solid_rect(x, y, x+image_box_width-1, y+image_box_height-1, GDI_COLOR_BLACK);

    gd_bitblt[gdi_act_layer->cf](
        gdi_act_layer->buf_ptr,
        gdi_act_layer->width, gdi_act_layer->height,
        dest_clip.x1, dest_clip.y1, dest_clip.x2, dest_clip.y2,
        node_p->buffer,
        box_width, box_height,
        0, 0, box_width - 1, box_height -1 ,
        dest_clip.x1, temp_y1, dest_clip.x2, temp_y2,
        0x01FFFFFF, 0x01FFFFFF);            

    /* Draw the line */
    box_hilight_color = gdi_act_color_from_rgb(0,0, 0, 0);     
    
    /* draw frame */
    gdi_draw_rect(
        dest_clip.x1,
        dest_clip.y1,
        dest_clip.x2,
        dest_clip.y2,
        box_hilight_color);
    gui_pop_clip();

    wgui_cat_thumbnail_draw_attachment_icon(node_p->index, x, y);
}
static void wgui_cat_thumbnail_draw_hilight_menuitem_bg(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    UI_filled_area *f;
    S32 count = 0;
    S32 pos_x, pos_y, width, height;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    pos_x = GUI_current_fixed_icontext_list_menuitem_x;
    pos_y = GUI_current_fixed_icontext_list_menuitem_y;
    width = MMI_fixed_icontext_list_menuitem.width;
    height = MMI_fixed_icontext_list_menuitem.height;       

    
    if ((MMI_fixed_list_menu.flags & UI_LIST_MENU_DISABLE_SCROLLBAR) ||
        ((MMI_fixed_list_menu.flags & UI_LIST_MENU_AUTO_DISABLE_SCROLLBAR) && 
         (MMI_fixed_list_menu.displayed_items >= MMI_fixed_list_menu.n_items)))
    {

        f =  MMI_fixed_icontext_list_menuitem.focussed_without_sc_filler;
    }
    else
    {

        f = MMI_fixed_icontext_list_menuitem.selected_filler;

    }
    
    /* check if background decoding finish: yes then start to scroll */
    gui_push_clip();
    gui_set_clip(x1, y1, x2, y2);
    
#if defined(__MMI_UI_LIST_SLIDE_EFFECT__)
    if (g_slide_effect->state != GUI_EFFECT_STATE_RUNNING
#if defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_KEY)
        && !gui_in_ssk
#endif
       )
#endif /* __MMI_UI_LIST_SLIDE_EFFECT__ */
    {
        gdi_image_get_frame_count(f->b, &count);
        if (f->flags & UI_FILLED_AREA_TYPE_BITMAP && f->b && (count > 1) &&
            (f->b[0] == GDI_IMAGE_TYPE_PNG_SEQUENCE || f->b[0] == GDI_IMAGE_TYPE_ABM_SEQUENCE || 
            f->b[0] == GDI_IMAGE_TYPE_AB2_SEQUENCE || 
            f->b[0] == GDI_IMAGE_TYPE_PNG_SEQUENCE_FILE_OFFSET ||
            f->b[0] == GDI_IMAGE_TYPE_ABM_SEQUENCE_FILE_OFFSET || 
            f->b[0] == GDI_IMAGE_TYPE_AB2_SEQUENCE_FILE_OFFSET))
        {
            gdi_draw_solid_rect(            
                pos_x, 
                pos_y, 
                pos_x + width -1,
                pos_y + height -1,  
                GDI_COLOR_TRANSPARENT);
            gdi_image_draw_frames(pos_x, pos_y, f->b, count - 1);
        }
        else
        {
            gui_draw_filled_area(
                pos_x, 
                pos_y, 
                pos_x + width -1,
                pos_y + height -1, 
                f);
        }
    }
    gui_pop_clip();
}

static void wgui_cat_thumbnail_redraw_image_background(BOOL is_hilighted, 
                                             gdi_color bg_color, S32 x1, S32 y1, S32 x2, S32 y2)
{

    if(is_hilighted)
    wgui_cat_thumbnail_draw_hilight_menuitem_bg(x1, y1, x2, y2);
    else
    gdi_draw_solid_rect(x1, y1, x2, y2, bg_color);

}
/*****************************************************************************
 * FUNCTION
 *  wgui_cat_fmgr_decode_result_hdlr
 * DESCRIPTION
 *  Filemanager decode callback from GDI.
 * PARAMETERS
 *  decode_result       [IN]    result code of decode
 *  handle              [IN]    GDI decode handle
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat_thumbnail_decode_result_hdlr(GDI_RESULT decode_result, gdi_handle handle)
{

    wgui_cat_thumbnail_cache_node *decode_node_p;
    S16 per_page;

    if (g_thumbnail_cache_p == NULL)
    {
        return;
    }

    decode_node_p = g_thumbnail_cache_p->cur_decode_p;
    per_page = MMI_fixed_list_menu.displayed_items;

    /* Free decoding layer first */
    if (g_thumbnail_cache_p->decoding_layer != NULL)
    {
        gdi_layer_free(g_thumbnail_cache_p->decoding_layer);
        g_thumbnail_cache_p->decoding_layer = NULL;
    }
    
    /* if decoder is deinited, ignore the decode result hdlr */
    if (g_thumbnail_cache_p->decoder_create == 0)
    {
        if(wgui_thumbnail_imgdec_done_callback)
        {
            wgui_thumbnail_imgdec_done_callback(g_thumbnail_cache_p->cur_decode_p->index);
            wgui_thumbnail_imgdec_done_callback = NULL;
        }
        return;
    }

    if (decode_result == GDI_SUCCEED)
    {
        {
            /* if info style, only draw highlight */
            if ((decode_node_p->index >= g_thumbnail_cache_p->first_displayed_item) && 
                (decode_node_p->index < g_thumbnail_cache_p->first_displayed_item + per_page))
            {
                /* if index in on the current page, draw the cached image */
                S32 x1, y1;
 
                x1 = g_thumbnail_cache_p->cache_pos[decode_node_p->index - g_thumbnail_cache_p->first_displayed_item].x;
                y1 = g_thumbnail_cache_p->cache_pos[decode_node_p->index - g_thumbnail_cache_p->first_displayed_item].y;
     
                wgui_cat_thumbnail_draw_cached_img(decode_node_p, x1, y1);

				if(g_wgui_cat199_get_attachment_icon || g_wgui_cat199_get_attachment_icon_buffer || g_wgui_cat199_get_attachment_icon_filepath)
				{
                    gdi_layer_blt_previous(0, 0, UI_device_width - 1, UI_device_height - 1);    
                }   
				else
				{
                	gdi_layer_blt_previous(x1, y1,x1+image_box_width - 1, y1+image_box_height- 1);    
				}    
            }   
        }
        /* Clear current decoding pointer and set the node state */
        g_thumbnail_cache_p->cur_decode_p = NULL;
        decode_node_p->state = WGUI_CAT_THUMBNAIL_CACHED;
    }
    else
    {
        /* if decode failed, stop link list */
		wgui_thumbnail_set_displayable(decode_node_p->index, MMI_FALSE);
        wgui_cat_thumbnail_stop_decoder();
        decode_node_p->state = WGUI_CAT_THUMBNAIL_CACHEERROR;
    }
    if(wgui_thumbnail_imgdec_done_callback)
    {
        wgui_thumbnail_imgdec_done_callback(decode_node_p->index);
        wgui_thumbnail_imgdec_done_callback = NULL;
    }
    wgui_cat_thumbnail_start_next();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat_thumbnail_cache_create_node
 * DESCRIPTION
 *  Filemanager create a decode node, alloc memory.
 * PARAMETERS
 *  void
 * RETURNS
 *  wgui_cat_thumbnail_cache_node    Node pointer
 *****************************************************************************/
static wgui_cat_thumbnail_cache_node *wgui_cat_thumbnail_cache_create_node(void)
{
    wgui_cat_thumbnail_cache_node *new_node_p;
    PU8 p1 = NULL;

    S32 buf_size;

    if (g_thumbnail_cache_p == NULL)
    {
        return NULL;
    }    
    /*--------------------- check exist memory block first -------------------------------------------*/
    if (g_thumbnail_cache_p->cur_decode_p != NULL)
    {
        if (g_thumbnail_cache_p->cur_decode_p->state == WGUI_CAT_THUMBNAIL_CACHENONE || g_thumbnail_cache_p->cur_decode_p->state == WGUI_CAT_THUMBNAIL_CACHEERROR)
        {
            /* return exist node pointer to use */
            return g_thumbnail_cache_p->cur_decode_p;
        }
    }

    /*--------------------- Alloc memory ------------------------------------------------------------*/
    buf_size = sizeof(wgui_cat_thumbnail_cache_node) + ((image_box_height*image_box_width*GDI_MAINLCD_BIT_PER_PIXEL)>>3);
    /* Alloc new memory from Screen memory first */
    p1 = (PU8)mmi_frm_scrmem_alloc_framebuffer(buf_size);
    if (p1 != NULL)
    {
        /* Point pointer to right address */
        new_node_p = (wgui_cat_thumbnail_cache_node*)p1;
        memset(new_node_p, 0, sizeof(wgui_cat_thumbnail_cache_node));
        new_node_p->buffer = (PU8)(p1 + sizeof(wgui_cat_thumbnail_cache_node));
        new_node_p->mem_flag = WGUI_CAT_THUMBNAIL_CACHE_ASM;    
        return new_node_p;
    }
    

    if (g_thumbnail_cache_p->med_cache_num < (WGUI_THUMBNAIL_MED_CACHE_SIZE/buf_size)) 
    {
        /* ASM not available, try to alloc in MDI*/
        media_get_ext_buffer(
            stack_int_get_active_module_id(),
            (void **)&p1,
            buf_size);  
        if (p1 != NULL)
        {
            /* Point pointer to right address */
            g_thumbnail_cache_p->med_cache_num++;
            new_node_p = (wgui_cat_thumbnail_cache_node*)p1;
            memset(new_node_p, 0, sizeof(wgui_cat_thumbnail_cache_node));
            new_node_p->buffer = (PU8)(p1 + sizeof(wgui_cat_thumbnail_cache_node));
            new_node_p->mem_flag = WGUI_CAT_THUMBNAIL_CACHE_MDI;    
            return new_node_p;
        }
    }

    /*--------------------- Can't found the memory, will use the furthest node ----------------------*/
    return NULL;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat_thumbnail_cache_free_node
 * DESCRIPTION
 *  Filemanager free a decode node
 * PARAMETERS
 *  node                [IN]    node pointer
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat_thumbnail_cache_free_node(wgui_cat_thumbnail_cache_node *node)
{
    if (g_thumbnail_cache_p == NULL)
    {
        return;
    }    
    if (node->mem_flag == WGUI_CAT_THUMBNAIL_CACHE_ASM)
    {
        mmi_frm_scrmem_free(node);
    }
    else
    {
        media_free_ext_buffer(stack_int_get_active_module_id(), (void**)&node);
        g_thumbnail_cache_p->med_cache_num--;
    }
}

/*****************************************************************************
 * FUNCTION
 *  wgui_cat_fmgr_cache_free_all
 * DESCRIPTION
 *  Filemanager free all decode and cached node
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat_thumbnail_cache_free_all(void)
{
    wgui_cat_thumbnail_cache_node *cur_p;
    wgui_cat_thumbnail_cache_node *del_p;

    if (g_thumbnail_cache_p == NULL)
    {
        return;
    }    
    wgui_cat_thumbnail_stop_decoder();
    

    cur_p = g_thumbnail_cache_p->cache_search_list.front_p;
    while (cur_p != NULL)
    {
        del_p = cur_p;
        cur_p = cur_p->next;
        wgui_cat_thumbnail_cache_free_node(del_p);
    }
    g_thumbnail_cache_p->cache_search_list.front_p = NULL;
    g_thumbnail_cache_p->cache_search_list.rear_p = NULL;


    if (g_thumbnail_cache_p->cur_decode_p != NULL)
    {
        wgui_cat_thumbnail_cache_free_node(g_thumbnail_cache_p->cur_decode_p);
    }

    if (g_thumbnail_cache_p->decoder_create == 1)
    {
        gdi_image_decoder_free();
        g_thumbnail_cache_p->decoder_create = 0;
    }
    ASSERT(g_thumbnail_cache_p->med_cache_num == 0);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat_thumbnail_cache_list_add
 * DESCRIPTION
 *  Filemanager add a node to the cache list
 * PARAMETERS
 *  idx                 [IN]    Index of the node
 *  file_icon_p         [IN]    file icon pointer
 *  ref_node            [OUT]   The result when check if it is cached
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat_thumbnail_cache_list_add(S32 idx, PU8 file_icon_p, wgui_cat_thumbnail_cache_node *ref_node)
{
    wgui_cat_thumbnail_cache_node *new_node_p;
    S16 per_page;

    if (g_thumbnail_cache_p == NULL)
    {
        return;
    }     
    per_page =  MMI_fixed_list_menu.displayed_items;
    /* Create a new node to decode the image */
    new_node_p = wgui_cat_thumbnail_cache_create_node();

    if (new_node_p == NULL)
    {
        /* No free memory ,check exist memory */
        if ((idx > g_thumbnail_cache_p->first_displayed_item - per_page) && 
            (idx < (g_thumbnail_cache_p->first_displayed_item + per_page*2))) 
        {

            new_node_p = g_thumbnail_cache_p->cache_search_list.front_p;
            g_thumbnail_cache_p->cache_search_list.front_p = new_node_p->next;
            if (g_thumbnail_cache_p->cache_search_list.front_p != NULL)
            {
                g_thumbnail_cache_p->cache_search_list.front_p->prev = NULL;
            }
            else
            {
                g_thumbnail_cache_p->cache_search_list.rear_p = NULL;
            }
 
            /* reset node */
            new_node_p->index = 0;
            new_node_p->state = 0;
            new_node_p->next = NULL;
            new_node_p->prev = NULL;
            new_node_p->cache_width = 0;
            new_node_p->cache_height = 0;
        }
        else
        {
            /* if idx not in cache area, do not cache it. */
            g_thumbnail_cache_p->cur_decode_p = NULL;
            return;
        }
    }

    new_node_p->index = idx;
    new_node_p->id = g_thumbnail_get_store_id_func(idx);
 /* Add to last */
    if(g_thumbnail_cache_p->cache_search_list.rear_p == NULL)
    {
        g_thumbnail_cache_p->cache_search_list.rear_p = new_node_p;
        g_thumbnail_cache_p->cache_search_list.front_p = g_thumbnail_cache_p->cache_search_list.rear_p;
    }
    else
    {
        g_thumbnail_cache_p->cache_search_list.rear_p->next = new_node_p;
        new_node_p->prev = g_thumbnail_cache_p->cache_search_list.rear_p;
        g_thumbnail_cache_p->cache_search_list.rear_p = new_node_p;
    }
    g_thumbnail_cache_p->cur_decode_p = new_node_p;
    new_node_p->state = WGUI_CAT_THUMBNAIL_CACHING;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat_thumbnail_find_next
 * DESCRIPTION
 *  Filemanager find next item to cache
 * PARAMETERS
 *  cur_cache           [IN]    Current cache item.
 * RETURNS
 *  void
 *****************************************************************************/
static S32 wgui_cat_thumbnail_find_next(S32 curr_cache)
{
    S32 next_to_cache;
    S32 first_item, per_page;

    if (g_thumbnail_cache_p == NULL)
    {
        return -1;
    }
    
    first_item = g_thumbnail_cache_p->first_displayed_item;
    per_page =  MMI_fixed_list_menu.displayed_items;   

    /* If item count more than sort count, will use less cache mode. */
    if ((curr_cache < (first_item + per_page*2)) && (curr_cache >= first_item))
    {
        /* Only cache the item, which is on the screen. */
        if(curr_cache == MMI_fixed_list_menu.n_items - 1)
		{
			if(first_item == 0)
			{
				next_to_cache =  MMI_fixed_list_menu.n_items; // stop decode
			}
			else
			{
				next_to_cache =  first_item - 1;
			}

		}
        else
		{
            next_to_cache =  curr_cache + 1;
		}
    }
	else if ((curr_cache < first_item) && (curr_cache > first_item - 2*per_page))
	{
        if (curr_cache == 0)
        {
            next_to_cache = g_thumbnail_cache_p->first_displayed_item + per_page*2 + 1;
        }
        else
        {
            next_to_cache = curr_cache - 1;
        }
	}
	else if (curr_cache == first_item - 2*per_page)
	{
		next_to_cache = g_thumbnail_cache_p->first_displayed_item + per_page*2 + 1;
	}
	else
	{
		next_to_cache = curr_cache + 1;
	}
    return next_to_cache;
}

/*****************************************************************************
 * FUNCTION
 *  wgui_cat_thumbnail_start_next
 * DESCRIPTION
 *  Filemanager start next cache.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat_thumbnail_start_next(void)
{
    S32 next_to_cache = -1;
    
    if (g_thumbnail_cache_p == NULL)
    {
        return;
    }    
    if (g_thumbnail_cache_p->cur_decode_p != NULL)
    {
        if (g_thumbnail_cache_p->cur_decode_p->state == WGUI_CAT_THUMBNAIL_CACHING)
        {
            return;
        }
    }

    if (g_thumbnail_cache_p->prev_first_displayed_item != g_thumbnail_cache_p->first_displayed_item)
    {
        wgui_cat_thumbnail_cache_node *current_node_p = NULL;

        next_to_cache = g_thumbnail_cache_p->first_displayed_item;
        while (wgui_cat_thumbnail_is_cached(next_to_cache, &current_node_p))
        {
            next_to_cache = wgui_cat_thumbnail_find_next(next_to_cache);
        }

        g_thumbnail_cache_p->prev_first_displayed_item = g_thumbnail_cache_p->first_displayed_item;
    }
    else
    {
        if (g_thumbnail_cache_p->cur_decode_p != NULL)
        {
            if (g_thumbnail_cache_p->cur_decode_p->state == WGUI_CAT_THUMBNAIL_CACHENONE)
            {
                next_to_cache = g_thumbnail_cache_p->decoding_index;
            }
        }
        
        if (next_to_cache == -1)
        {
            next_to_cache = wgui_cat_thumbnail_find_next(g_thumbnail_cache_p->decoding_index);
        }
    }
    wgui_cat_thumbnail_cache_list_decoding_next(next_to_cache);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat_thumbnail_delay_decode_timer
 * DESCRIPTION
 *  Filemanager delay decode timer callback
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat_thumbnail_delay_decode_timer(void)
{
    wgui_cat_thumbnail_cache_node *current_node_p;
    CHAR buffer_UCS2[SRV_FMGR_PATH_BUFFER_SIZE];
    GDI_RESULT ret = -1;
    S32 img_width, img_height;
    S32 resized_width, resized_height;
    S32 resized_offset_x, resized_offset_y;
    S32 item_idx;
    S32 box_width = image_box_width;
    S32 box_height = image_box_height;
    wgui_thumbnail_img_src_enum image_src = WGUI_THUMBNAIL_IMG_SRC_TYPE_TOTAL;
    wgui_thumbnail_img_info_struct img_info;


    memset(&img_info, 0, sizeof(wgui_thumbnail_img_info_struct));
    img_info.img_type = GDI_IMAGE_TYPE_SUM;
    if (g_thumbnail_cache_p == NULL)
    {
        return;
    }    
    current_node_p = g_thumbnail_cache_p->cur_decode_p;
    item_idx = g_thumbnail_cache_p->cur_decode_p->index;

    if (item_idx >= MMI_fixed_list_menu.n_items)
    {
        /* Start next */
        wgui_cat_thumbnail_stop_decoder();
        g_thumbnail_cache_p->cur_decode_p->state = WGUI_CAT_THUMBNAIL_CACHEERROR;
        wgui_cat_thumbnail_start_next();
        return;
    }

    if(wgui_thumbnail_get_image_path_callback != NULL && wgui_thumbnail_get_image_callback != NULL)
    {
        if(wgui_thumbnail_get_image_path_callback(item_idx, buffer_UCS2))
        {
            image_src = WGUI_THUMBNAIL_IMG_SRC_TYPE_FILE;
        }
        else if(wgui_thumbnail_get_image_callback(item_idx, &img_info))
        {
            image_src = img_info.img_src;
            wgui_thumbnail_imgdec_done_callback = img_info.done_callback;
        }
    }
    else if(wgui_thumbnail_get_image_path_callback != NULL)
    {
        if(wgui_thumbnail_get_image_path_callback(item_idx, buffer_UCS2))
        {
            image_src = WGUI_THUMBNAIL_IMG_SRC_TYPE_FILE;
        }
    }
    else if(wgui_thumbnail_get_image_callback != NULL)
    {
        if(wgui_thumbnail_get_image_callback(item_idx, &img_info))
        {
            image_src = img_info.img_src;
        }
    }
    if(image_src == WGUI_THUMBNAIL_IMG_SRC_TYPE_TOTAL || 
        (image_src == WGUI_THUMBNAIL_IMG_SRC_TYPE_MEMORY && 
            (img_info.img_type == GDI_IMAGE_TYPE_INVALID ||
             img_info.img_ptr == NULL ||
             img_info.img_size == 0)))
    {
        /* Start next */
        wgui_cat_thumbnail_stop_decoder();
        g_thumbnail_cache_p->cur_decode_p->state = WGUI_CAT_THUMBNAIL_CACHEERROR;
        wgui_cat_thumbnail_start_next();
        return;
    }
    else if(image_src == WGUI_THUMBNAIL_IMG_SRC_TYPE_FILE)
    {
        /* get jpeg width and height */
        ret = gdi_image_get_dimension_file(buffer_UCS2, &img_width, &img_height);
    }
    else if(image_src == WGUI_THUMBNAIL_IMG_SRC_TYPE_MEMORY)
    {
        if(img_info.img_type == GDI_IMAGE_TYPE_SUM)
        {
            /* if app doesn't pass image type, category try to get it */
            img_info.img_type = (U8)gdi_image_get_type_from_mem((PS8)img_info.img_ptr);

            /* For MRE can't pass image type, category will treat it as AB2 if not JPG/GIF/PNG/BMP */
            if(img_info.img_type == GDI_IMAGE_TYPE_INVALID)
            {
                img_info.img_type = GDI_IMAGE_TYPE_AB2;
            }
        }
        if(img_info.img_type == GDI_IMAGE_TYPE_AB2)
        {
            ret = gdi_image_ab2_get_dimension_handler(
                        GDI_IMAGE_CODEC_FLAG_IS_MEM,
                        img_info.img_ptr,
                        img_info.img_size,
                        &img_width,
                        &img_height);
        }
        else
        {
            ret = gdi_image_get_dimension_mem(
                        img_info.img_type,
                        img_info.img_ptr,
                        img_info.img_size,
                        &img_width,
                        &img_height);
        }
    }
    else if(image_src == WGUI_THUMBNAIL_IMG_SRC_TYPE_RESOURCE)
    {
        ret = gdi_image_get_dimension(img_info.img_ptr,&img_width,&img_height);
    }

    /* check if is a valid image or not */
    /* TODO: Adapt to File limit */
    if ((ret < 0) || (img_width <= 0) || (img_height <= 0))   /* invalid image size */
    {
        wgui_thumbnail_set_displayable(item_idx, MMI_FALSE);
        if(wgui_thumbnail_imgdec_done_callback)
        {
            wgui_thumbnail_imgdec_done_callback(item_idx);
            wgui_thumbnail_imgdec_done_callback = NULL;
        }
        /* Start next */
        wgui_cat_thumbnail_stop_decoder();
        g_thumbnail_cache_p->cur_decode_p->state = WGUI_CAT_THUMBNAIL_CACHEERROR;
        wgui_cat_thumbnail_start_next();
        return;
    }
    /* can get dimesion from file, must be a valid jpeg file, then draw it */
    /* support enlarge jpg image from memory */
    if((WGUI_THUMBNAIL_IMG_SRC_TYPE_MEMORY == img_info.img_src) && 
        (GDI_IMAGE_TYPE_JPG == img_info.img_type) &&
        (img_width < box_width) && 
        (img_height < box_height) &&
        (img_width > 0) &&
        (img_height > 0))
    {
        resized_width = box_width/img_width + 1;
        resized_height = box_height/img_height + 1;
        resized_width = (resized_width > resized_height) ? resized_width : resized_height;
        img_width = resized_width * img_width;
        img_height = resized_width * img_height;
    }
    if ((img_width < box_width) && (img_height < box_height))
    {
        resized_width = img_width;
        resized_height = img_height;
        resized_offset_x = ((box_width-img_width)>>1);
        resized_offset_y = ((box_height-img_height)>>1);   
        current_node_p->cache_width = resized_width;
        current_node_p->cache_height = resized_height;        
    }
    else if ((img_width > box_width) && (img_height > box_height))
    {
        /* Both large, need to resize to fit the box and cut */
        
        gdi_util_fit_box(
            GDI_UTIL_MODE_SHORT_SIDE_FIT,
            box_width,
            box_height,
            img_width,
            img_height,
            &resized_offset_x,
            &resized_offset_y,
            &resized_width,
            &resized_height);     
        current_node_p->cache_width = box_width;
        current_node_p->cache_height = box_height;        
    }
    else
    {
        /* One of them large, fit the box, do not cut */
        gdi_util_fit_box(
            GDI_UTIL_MODE_LONG_SIDE_FIT,
            box_width,
            box_height,
            img_width,
            img_height,
            &resized_offset_x,
            &resized_offset_y,
            &resized_width,
            &resized_height);
        current_node_p->cache_width = resized_width;
        current_node_p->cache_height = resized_height;
    }    
    
    /* Create layer and nb decode on the layer */
    gdi_layer_create_using_outside_memory(
        0,
        0,
        box_width,
        box_height,
        &(g_thumbnail_cache_p->decoding_layer),
        (PU8) current_node_p->buffer,
        (S32) ((box_height*box_width*GDI_MAINLCD_BIT_PER_PIXEL)>>3));

    gdi_layer_push_and_set_active(g_thumbnail_cache_p->decoding_layer);
    gdi_layer_set_source_key(TRUE, GDI_COLOR_TRANSPARENT);
#ifdef __MMI_FTE_SUPPORT__
	gdi_layer_clear(GDI_COLOR_BLACK);
#endif
    gdi_push_and_set_alpha_blending_source_layer(g_thumbnail_cache_p->decoding_layer);
    if (resized_offset_x > 0)
    {
        resized_offset_x = 0;
    }

    if (resized_offset_y > 0)
    {
        resized_offset_y = 0;
    }
    if(image_src == WGUI_THUMBNAIL_IMG_SRC_TYPE_FILE)
    {
        ret = gdi_image_decoder_decode_file(
            resized_offset_x,
            resized_offset_y,
            resized_width,
            resized_height,
            FALSE,
            buffer_UCS2,
            &(g_thumbnail_cache_p->decoding_handle));
        g_thumbnail_cache_p->decoder_type = WGUI_THUMBNAIL_DECODER_TYPE_OLD;
    }
    else if(image_src == WGUI_THUMBNAIL_IMG_SRC_TYPE_MEMORY)
    {
        if(img_info.img_type == GDI_IMAGE_TYPE_AB2)
        {
            ret = gdi_image_ab2_draw_handler(
                    GDI_IMAGE_CODEC_FLAG_IS_MEM,
                    0,
                    resized_offset_x,
                    resized_offset_y,
                    resized_width,
                    resized_height,
                    img_info.img_ptr,
                    img_info.img_size);
            g_thumbnail_cache_p->decoder_type = WGUI_THUMBNAIL_DECODER_TYPE_NONE;
            gdi_pop_and_restore_alpha_blending_source_layer();
            gdi_layer_pop_and_restore_active();
            wgui_cat_thumbnail_decode_result_hdlr(ret, NULL);
            return; 
        }
        ret = gdi_imgdec_nb_draw_resized_mem(
                    g_thumbnail_cache_p->decoding_layer,
                    resized_offset_x,
                    resized_offset_y,
                    resized_width,
                    resized_height,
                    img_info.img_type,
                    img_info.img_size,
                    img_info.img_ptr,
                    wgui_cat_thumbnail_decode_result_hdlr);
        g_thumbnail_cache_p->decoding_handle = ret;
        g_thumbnail_cache_p->decoder_type = WGUI_THUMBNAIL_DECODER_TYPE_NEW;
    }
    else if(image_src == WGUI_THUMBNAIL_IMG_SRC_TYPE_RESOURCE)
    {
        ret = gdi_image_draw_resized(
                    resized_offset_x,
                    resized_offset_y,
                    resized_width,
                    resized_height,
                    img_info.img_ptr);
         g_thumbnail_cache_p->decoder_type = WGUI_THUMBNAIL_DECODER_TYPE_NONE;
         gdi_pop_and_restore_alpha_blending_source_layer();
         gdi_layer_pop_and_restore_active();
         wgui_cat_thumbnail_decode_result_hdlr(ret, NULL);
         return;
    }
    else
    {
        ret = -1;
    }
    
    if (ret >= 0)
    {
        /* Start decode success */
    }
    else
    {
        /* Failed to start the decoding */
        wgui_thumbnail_set_displayable(item_idx, MMI_FALSE);
        if(wgui_thumbnail_imgdec_done_callback)
        {
            wgui_thumbnail_imgdec_done_callback(item_idx);
            wgui_thumbnail_imgdec_done_callback = NULL;
        }
        gdi_layer_blt_previous(0, 0, UI_device_width - 1, UI_device_height - 1);
    }
	gdi_pop_and_restore_alpha_blending_source_layer();
    gdi_layer_pop_and_restore_active();
    
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat_fmgr_set_cache_pos
 * DESCRIPTION
 *  Save thumb image position
 * PARAMETERS
 *  idx             [IN]        Index of image
 *  first_displayed [IN]        first displayed ID
 *  fmgr_cache_p    [IN]        Cache data of fmgr
 *  x1              [IN]        Position x1
 *  y1              [IN]        Position y1
 * RETURNS      
 *  void
 *****************************************************************************/
static void wgui_cat_thumbnail_set_cache_pos(S32 idx, S32 first_displayed, wgui_thumbnail_cache_struct* fmgr_cache_p, S32 x1, S32 y1)
{

    /* Save first_displayed item */
    fmgr_cache_p->first_displayed_item = first_displayed;


    if (!gui_screen_smooth_scrolling_by_pen()
#if defined(__MMI_UI_LIST_SLIDE_EFFECT__)
        && g_slide_effect->state != GUI_EFFECT_STATE_RUNNING
#if defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_KEY)
        && !gui_in_ssk
#endif
#endif /* __MMI_UI_LIST_SLIDE_EFFECT__ */        
        )
    {
        S32 pos = idx - first_displayed;

     //   ASSERT(pos < WGUI_CAT_FMGR_CACHE_MAX_PER_PAGE);
        
        if (pos >= 0)
        {
            fmgr_cache_p->cache_pos[pos].x = x1;
            fmgr_cache_p->cache_pos[pos].y = y1;
        }
    }
}

/*****************************************************************************
 * FUNCTION
 *  wgui_cat_thumbnail_show_img
 * DESCRIPTION
 *  Filemanager to show a thumb image.
 * PARAMETERS
 *  idx             [IN]        Index of image
 *  is_hilighted    [IN]        Is it highlight
 *  menuitem_data   [IN]        Menuitem data of fmgr
 *  x1              [IN]        Position x1
 *  y1              [IN]        Position y1
 *  x2              [IN]        Position x2
 *  y2              [IN]        Position y2
 * RETURNS      
 *  void
 *****************************************************************************/
static void wgui_cat_thumbnail_show_img(
        S32 idx, 
        BOOL is_hilighted, 
        wgui_thumbnail_info_struct *menuitem_data, 
        S32 x1, 
        S32 y1, 
        S32 x2, 
        S32 y2)
{
    wgui_cat_thumbnail_cache_node *current_node_p = NULL;

    if (g_thumbnail_cache_p == NULL)
    {
        return;
    }    
    /* create jpeg decoder */
    if (g_thumbnail_cache_p->decoder_create == 0)
    {
        /* max image size is 100x100 */
        gdi_image_decoder_create(100, 100, wgui_cat_thumbnail_decode_result_hdlr);
        g_thumbnail_cache_p->decoder_create = 1;
    }
    
    if (wgui_cat_thumbnail_is_cached(idx, &current_node_p))
    {
        /* Draw the cached image */
        wgui_cat_thumbnail_draw_cached_img(current_node_p, x1, y1);
    }
    else
    {
        if (menuitem_data->is_show_thumb && !gui_screen_smooth_scrolling_by_pen())
        {
            if (g_thumbnail_cache_p->cur_decode_p == NULL || g_thumbnail_cache_p->cur_decode_p->state == WGUI_CAT_THUMBNAIL_CACHENONE || g_thumbnail_cache_p->cur_decode_p->state == WGUI_CAT_THUMBNAIL_CACHEERROR)
            {
                /* Pass node to make search faster */
                wgui_cat_thumbnail_cache_list_add(idx, menuitem_data->file_icon_ptr, current_node_p);
                
                if (g_thumbnail_cache_p->cur_decode_p != NULL)
                {
                    /* Start decoding image */
                    StartNonAlignTimer(FMGR_DELAY_DECODE_0, WGUI_CAT_THUMBNAIL_UI_DELAY_DECODE_FIRST_DUR, wgui_cat_thumbnail_delay_decode_timer);
                    g_thumbnail_cache_p->decoding_index = idx;
                }
            }
        }
    }
}

static gdi_color wgui_thumbnail_get_bg_color(BOOL is_hilighted)
{
    gdi_color bg_color = GDI_COLOR_BLACK;
    color *color_ptr;
 /* get color from theme */
    if (is_hilighted)
    {
        color_ptr = &(current_MMI_theme->list_selected_item_filler->c);
        bg_color = gdi_act_color_from_rgb(255,color_ptr->r, color_ptr->g, color_ptr->b);
    }
    else
    {
#if defined(__MMI_WALLPAPER_ON_BOTTOM__)
        bg_color = GDI_COLOR_TRANSPARENT;
#else /* defined(__MMI_WALLPAPER_ON_BOTTOM__) */ /* __MMI_MAINLCD_240X320__ */
        color_ptr = &(current_MMI_theme->list_background_filler->c);
        bg_color = gdi_act_color_from_rgb(255,color_ptr->r, color_ptr->g, color_ptr->b);
#endif /* defined(__MMI_WALLPAPER_ON_BOTTOM__) */ /* __MMI_MAINLCD_240X320__ */
    }
    return bg_color;
}
static void wgui_cat_thumbnail_unhighight_item(void *item, void *common_item_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    gui_remove_highlight_fixed_icontext_list_menuitem(item, common_item_data);

    /* stop async image decoding */
    if (g_thumbnail_cache_p != NULL)
    {
        wgui_cat_thumbnail_stop_decoder();
    }
}
void wgui_thumbnail_register_get_displayable_func(wgui_thumbnail_get_displayable_func get_displayable_func)
{
    wgui_thumbnail_get_displayable = get_displayable_func;
}

void wgui_thumbnail_register_set_displayable_func(wgui_thumbnail_set_displayable_func set_displayable_func)
{
    wgui_thumbnail_set_displayable = set_displayable_func;
}

void wgui_thumbnail_register_get_image_path_func(wgui_thumbnail_get_image_func get_image_path_func)
{
    wgui_thumbnail_get_image_path_callback = get_image_path_func;
}

void wgui_thumbnail_register_get_image_func(wgui_thumbnail_get_image_func_ex get_image_func)
{
    wgui_thumbnail_get_image_callback = get_image_func;
}

void wgui_thumbnail_register_get_image_info_func(wgui_thumbnail_get_info_func get_info_func)
{
    wgui_cat_thumbnail_get_menuitem = get_info_func;
}

void wgui_thumbnail_register_get_store_id_func(wgui_thumbnail_get_store_id_func get_store_id_func)
{
	g_thumbnail_get_store_id_func = get_store_id_func;
}

static wgui_thumbnail_cache_struct g_thumbnail;
void wgui_cat_thumbnail_init(S32 num_of_items)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/   
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* check if it need decode thumbnail */
    if(wgui_thumbnail_get_image_path_callback != NULL || wgui_thumbnail_get_image_callback != NULL) 
    {
        memset(&g_thumbnail, 0, sizeof(g_thumbnail));
        g_thumbnail_cache_p= &(g_thumbnail);

    	image_box_width = WGUI_CAT199_IMAGE_WIDTH;
    	image_box_height = WGUI_CAT199_IMAGE_HEIGHT;
	}
    else
    {
        g_thumbnail_cache_p = NULL;
    }
}
void wgui_cat_thumbnail_set_image_box_size(S32 width, S32 height)
{
    image_box_width = width;
    image_box_height = height;
}

void wgui_cat_thumbnail_post_init(S32 num_of_items)
{
    if(g_thumbnail_cache_p == NULL)
        return;
    MMI_fixed_list_menu.item_remove_highlight_function = wgui_cat_thumbnail_unhighight_item;
    if (g_thumbnail_cache_p->cur_decode_p == NULL && num_of_items != 0)
    {
        g_thumbnail_cache_p->first_displayed_item = MMI_fixed_list_menu.first_displayed_item;
        wgui_cat_thumbnail_cache_list_decoding_next(g_thumbnail_cache_p->first_displayed_item);
    }

}

void wgui_cat_thumbnail_deninit(void)
{
    if(g_thumbnail_cache_p == NULL)
        return;
    
    wgui_cat_thumbnail_cache_free_all();
    g_thumbnail_cache_p->cur_decode_p = NULL;
    g_thumbnail_cache_p = NULL;
    wgui_thumbnail_register_get_image_path_func(NULL);
    wgui_thumbnail_register_get_image_func(NULL);
    wgui_thumbnail_register_set_displayable_func(NULL);
    wgui_thumbnail_register_get_displayable_func(NULL);
    wgui_thumbnail_register_get_image_info_func(NULL);
    wgui_thumbnail_register_get_store_id_func(NULL);
}


static void wgui_cat_thumbnail_draw_attachment_icon(S32 item_index, S32 x, S32 y)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/   
    MMI_BOOL is_in_ssp = gui_screen_smooth_scrolling_moved_by_pen();
    PU8 attachment_icon = NULL;
    S32 attachment_icon_x = 0, attachment_icon_y = 0, attachment_icon_w = 0, attachment_icon_h = 0;
    S32 i, j;
    gdi_handle act_layer;
    S32 act_layer_w, act_layer_h;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_wgui_cat199_get_attachment_icon)
    {
        attachment_icon = g_wgui_cat199_get_attachment_icon(item_index);
        if (attachment_icon)
        {
            gui_measure_image(attachment_icon, &attachment_icon_w, &attachment_icon_h);

            attachment_icon_x = x + WGUI_CAT199_IMAGE_WIDTH - 1 - (attachment_icon_w / 3 * 2);
            attachment_icon_y = y + WGUI_CAT199_IMAGE_HEIGHT - 1 - (attachment_icon_h / 3 * 2);
            if ((MMI_fixed_list_menu.y + MMI_fixed_list_menu.height) > attachment_icon_y)
            {
                if (!is_in_ssp)
                {
                    gui_push_clip();
                    gui_set_clip(
                        MMI_fixed_list_menu.x, 
                        MMI_fixed_list_menu.y, 
                        MMI_fixed_list_menu.x + MMI_fixed_list_menu.width - 1, 
                        MMI_fixed_list_menu.y + MMI_fixed_list_menu.height - 1);
                }
                gdi_image_draw_blend2layers(attachment_icon_x, attachment_icon_y, attachment_icon);
                if (!is_in_ssp)
                {
                    gui_pop_clip();
                }

                //gdi_layer_blt_previous(attachment_icon_x, attachment_icon_y, attachment_icon_x + attachment_icon_w - 1, attachment_icon_y + attachment_icon_h - 1);
            }
        }
    }
    if (g_wgui_cat199_get_attachment_icon_buffer)
    {
        gdi_image_cache_bmp_struct attachment_icon_cache = g_wgui_cat199_get_attachment_icon_buffer(item_index);
        S32 y_offset;
        U16 *cached_buffer = (U16*) attachment_icon_cache.buf_ptr;
        
        if (attachment_icon_cache.buf_ptr)
        {
            attachment_icon_w = attachment_icon_cache.width;
            attachment_icon_h = attachment_icon_cache.height;
                
            if (mmi_fe_get_r2l_state())
            {
                attachment_icon_x = WGUI_CAT199_IMAGE_X_GAP + ((WGUI_CAT199_IMAGE_WIDTH - attachment_icon_w) >> 1) + MMI_fixed_list_menu.vbar.width;
            }
            else
            {
                attachment_icon_x = MMI_fixed_list_menu.width - WGUI_CAT199_IMAGE_X_GAP - WGUI_CAT199_IMAGE_WIDTH + ((WGUI_CAT199_IMAGE_WIDTH - attachment_icon_w) >> 1) - MMI_fixed_list_menu.vbar.width;
            }
            
            attachment_icon_y = y + ((WGUI_CAT199_IMAGE_HEIGHT - attachment_icon_h) >> 1);

            gdi_layer_get_active(&act_layer);
            gdi_layer_get_dimension(&act_layer_w, &act_layer_h);

            if ((MMI_fixed_list_menu.y + MMI_fixed_list_menu.height) > attachment_icon_y)
            {
                for (i = 0; i <= (attachment_icon_h - 1); i++)
                {
                    y_offset = i * attachment_icon_w;
                    for (j = 0; j <= (attachment_icon_w - 1); j++)
                    {
                        if ((((attachment_icon_y + i) >= MMI_fixed_list_menu.y) && 
                            ((attachment_icon_y + i) <= (MMI_fixed_list_menu.y + MMI_fixed_list_menu.height - 1))) ||
                            (MMI_fixed_list_menu.act_layer_handle != act_layer))
                        {
                            if (attachment_icon_y + i >= 0 && attachment_icon_y + i < act_layer_h)
                            {
                                GDI_SET_BUFFER_PIXEL2(attachment_icon_x + j, attachment_icon_y + i, cached_buffer[y_offset + j]);
                            }
                        }
                    }
                }
            }
        }
    }
    else if (g_wgui_cat199_get_attachment_icon_filepath)
    {
        attachment_icon = g_wgui_cat199_get_attachment_icon_filepath(item_index);
        if (attachment_icon)
        {
            gdi_image_get_dimension_file((CHAR*)attachment_icon, &attachment_icon_w, &attachment_icon_h);
            
            if (mmi_fe_get_r2l_state())
            {
                attachment_icon_x = WGUI_CAT199_IMAGE_X_GAP + ((WGUI_CAT199_IMAGE_WIDTH - attachment_icon_w) >> 1) + MMI_fixed_list_menu.vbar.width;
            }
            else
            {
                attachment_icon_x = MMI_fixed_list_menu.width - WGUI_CAT199_IMAGE_X_GAP - WGUI_CAT199_IMAGE_WIDTH + ((WGUI_CAT199_IMAGE_WIDTH - attachment_icon_w) >> 1) - MMI_fixed_list_menu.vbar.width;
            }
            attachment_icon_y = y + ((WGUI_CAT199_IMAGE_HEIGHT - attachment_icon_h) >> 1);
            if ((MMI_fixed_list_menu.y + MMI_fixed_list_menu.height) > attachment_icon_y)
            {
                if (!is_in_ssp)
                {
                    gui_push_clip();
                    gui_set_clip(
                        MMI_fixed_list_menu.x, 
                        MMI_fixed_list_menu.y, 
                        MMI_fixed_list_menu.x + MMI_fixed_list_menu.width - 1, 
                        MMI_fixed_list_menu.y + MMI_fixed_list_menu.height - 1);
                }
                gdi_image_draw_file_blend2layers(attachment_icon_x, attachment_icon_y, attachment_icon);
                if (!is_in_ssp)
                {
                    gui_pop_clip();
                }

                //gdi_layer_blt_previous(attachment_icon_x, attachment_icon_y, attachment_icon_x + attachment_icon_w - 1, attachment_icon_y + attachment_icon_h - 1);
            }
        }
    }
}


void wgui_cat_thumbnail_post_display_callback(void *item, void *common_item_data, S32 x, S32 y)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 item_index;
    S32 img_width = WGUI_CAT199_IMAGE_WIDTH, img_height = WGUI_CAT199_IMAGE_HEIGHT;
    wgui_thumbnail_info_struct menuitem_data;
    fixed_icontext_list_menuitem *m = (fixed_icontext_list_menuitem*) common_item_data;


    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(g_thumbnail_cache_p == NULL)
    {
        item_index = MMI_fixed_list_menu.current_displayed_item;
        if (item_index == -1)
        {
            //item_index = wgui_title_get_menu_shortcut_number() - 1;
            item_index = MMI_fixed_list_menu.highlighted_item;
        }

        if(mmi_fe_get_r2l_state())
	    {
                //x = m->width - 1 - m->icon_coordinates[0].x - m->icon_coordinates[0].width - GUI_MENUITEM_X1_GAP - GUI_MENUITEM_X2_GAP;
                x = x + m->width - 1 - m->icon_coordinates[0].x - m->icon_coordinates[0].width + 1;
	    }
	    else
	    {
	        x = m->icon_coordinates[0].x + GUI_MENUITEM_X1_GAP;
	    }

	    if(m->icon_coordinates[0].y == 0)
	    {
		    y  += (m->height - img_height)>> 1;
	    }
	    else
	    {
		    y  += m->icon_coordinates[0].y;
	    }

        wgui_cat_thumbnail_draw_attachment_icon(item_index, x, y);

        return;
    }

    if(mmi_fe_get_r2l_state())
	{
            //x = m->width - 1 - m->icon_coordinates[0].x - m->icon_coordinates[0].width - GUI_MENUITEM_X1_GAP - GUI_MENUITEM_X2_GAP;
            x = x + m->width - 1 - m->icon_coordinates[0].x - m->icon_coordinates[0].width + 1;
	}
	else
	{
	    x = m->icon_coordinates[0].x + GUI_MENUITEM_X1_GAP;
	}

	if(m->icon_coordinates[0].y == 0)
	{
		y  += (m->height - img_height)>> 1;
	}
	else
	{
		y  += m->icon_coordinates[0].y;
	}
    item_index = MMI_fixed_list_menu.current_displayed_item;
    if (item_index == -1)
    {
        //item_index = wgui_title_get_menu_shortcut_number() - 1;
        item_index = MMI_fixed_list_menu.highlighted_item;
    }

	wgui_cat_thumbnail_get_menuitem(item_index,&menuitem_data);
 	wgui_cat_thumbnail_set_cache_pos(
                    item_index, 
                    MMI_fixed_list_menu.first_displayed_item, 
                    g_thumbnail_cache_p, 
                    x,
                    y);
    if(menuitem_data.is_show_thumb == MMI_FALSE)
    {
        wgui_cat_thumbnail_draw_attachment_icon(item_index, x, y);
        return;
    }
	wgui_cat_thumbnail_show_img(
            item_index, 
            TRUE, 
            &menuitem_data, 
            x, 
            y, 
            x + img_width - 1, 
            y + img_height - 1);    
}

void wgui_cat_sns_thumbnail_post_display_callback(void *item, void *common_item_data, S32 index, S32 x, S32 y)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 item_index;
    S32 img_width = WGUI_CAT199_IMAGE_WIDTH, img_height = WGUI_CAT199_IMAGE_HEIGHT;
    wgui_thumbnail_info_struct menuitem_data;
    fixed_icontext_list_menuitem *m = (fixed_icontext_list_menuitem*) common_item_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(g_thumbnail_cache_p == NULL)
        return;
    
    if(mmi_fe_get_r2l_state())
	{
		x = x + m->width - m->icon_coordinates[index].x - m->icon_coordinates[index].width;
	}
	else
	{
	    x = m->icon_coordinates[index].x + GUI_MENUITEM_X1_GAP;
	}

    if(m->icon_coordinates[index].y == 0)
    {
        y  += (m->height - img_height)>> 1;
    }
    else
    {
        y  += m->icon_coordinates[index].y;
    }

    item_index = MMI_fixed_list_menu.current_displayed_item;
    if (item_index == -1)
    {
        item_index = wgui_title_get_menu_shortcut_number() - 1;
    }

	wgui_cat_thumbnail_get_menuitem(item_index,&menuitem_data);
 	wgui_cat_thumbnail_set_cache_pos(
                    item_index, 
                    MMI_fixed_list_menu.first_displayed_item, 
                    g_thumbnail_cache_p, 
                    x,
                    y);
	if(menuitem_data.is_show_thumb == MMI_FALSE)
		return;
	wgui_cat_thumbnail_show_img(
            item_index, 
            TRUE, 
            &menuitem_data, 
            x, 
            y, 
            x + img_width - 1, 
            y + img_height - 1);    
}
void wgui_cat_thumbnail_set_is_show(S32 index)
{
    if (g_thumbnail_cache_p == NULL)
    {
        return ;
    }
    if(index < MMI_fixed_list_menu.first_displayed_item ||
        index > MMI_fixed_list_menu.last_displayed_item)
    {
        return;  // no need refresh now. list will triger later.
    }
    if (!gui_screen_smooth_scrolling_by_pen()
#if defined(__MMI_UI_LIST_SLIDE_EFFECT__)
        && g_slide_effect->state != GUI_EFFECT_STATE_RUNNING
#if defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_KEY)
        && !gui_in_ssk
#endif
#endif /* __MMI_UI_LIST_SLIDE_EFFECT__ */        
        )
    {
        wgui_cat_thumbnail_cache_node *current_node_p;
        current_node_p = g_thumbnail_cache_p->cur_decode_p;

        if(current_node_p->index > index)
        {
            wgui_cat_thumbnail_stop_decoder();
            wgui_cat_thumbnail_cache_list_decoding_next(index);
        }
    }
}
#endif /* __MMI_PHONEBOOK_LIST_THUMBNAIL__*/


#if defined(__SOCIAL_NETWORK_SUPPORT__) && !defined(__MMI_TOUCH_SCREEN__)
U16 g_wgui_cat199_search_button_id = 0;
PU8 g_wgui_cat199_search_button_up_image = NULL;
PU8 g_wgui_cat199_search_button_down_image = NULL;
FuncPtr g_wgui_cat199_search_button_function = NULL;

void wgui_cat200_virtual_keypad_callback(void)
{
}

MMI_BOOL Cate200CategoryControlAreaPenDownHandler(mmi_pen_point_struct point)
{
}

MMI_BOOL Cate200CategoryControlAreaPenUpHandler(mmi_pen_point_struct point)
{
}

MMI_BOOL Cate200CategoryControlAreaPenMoveHandler(mmi_pen_point_struct point)
{
}

MMI_BOOL Cate200CategoryControlAreaPenLongTapHandler(mmi_pen_point_struct point)
{
}

MMI_BOOL Cate200CategoryControlAreaPenRepeatHandler(mmi_pen_point_struct point)
{
}
#endif

#if defined(__SOCIAL_NETWORK_SUPPORT__) && !defined(__MMI_VIRTUAL_KEYBOARD__)
MMI_BOOL wgui_cat_stop_pop_up_description_scroll(S32 x1, S32 y1, S32 x2, S32 y2)
{
}

void wgui_cat_resume_pop_up_description_scroll(void)
{
}
#endif

#if defined(__SOCIAL_NETWORK_SUPPORT__) 

S32 get_cat202_scroll_height(void)
{
    return CAT202_SCROLL_HEIGHT;
}
S32 get_cat199_inputbox_h(void)
{
    return CAT199_INPUTBOX_H;
}
S32 get_cat199_margin_width(void)
{
    return CAT199_MARGIN_WIDTH;
}
#endif



