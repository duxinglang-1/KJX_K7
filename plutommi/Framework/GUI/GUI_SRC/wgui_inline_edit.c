/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*****************************************************************************
 *
 * Filename:
 * ---------
 * wgui_inline_edit.c
 *
 * Project:
 * --------
 *   MAUI
 *
 * Description:
 * ------------
 *   Functions for Inline items.
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/

/***************************************************************************** 
 * This file contains following sections:
 *
 * 1.Inline Editor Common 
 * 2.Inline Text Edit
 * 3.Inline Full Screen Edit 
 * 4.Inline Image Text 
 * 5.Inline Image Attachment
 * 6.Inline Select
 * 7.Inline Date Edit 
 * 8.Inline Time Edit 
 * 9.Inline User Defined Select 
 * 10.Inline Day Of Week Select 
 * 11.Inline Time Period Edit 
 * 12.Inline IP4 Edit
 * 13.Inline Color Select 
 * 14.Inline Multiline Edit Read Only
 * 15.Some Utility function for Inline Editor 
 * 16.Categories for inline editor
 *
 *****************************************************************************/


/***************************************************************************** 
 * Inline Editor Common 
 *
 * This is Inline Editor Common used Declaration and Function 
 *****************************************************************************/

/***************************************************************************** 
 * Include
 *****************************************************************************/
#include "MMI_features.h"
#include "CustDataRes.h"
#include "CustDataProts.h"
#include "wgui_datetime.h"
#include "CommonScreens.h"
#include "wgui_virtual_keyboard.h"
#ifdef __MMI_INDIC_ALG__
#include "IndicEngineGprot.h"
#endif
#include "wgui_fixed_menuitems.h"
#include "wgui_fixed_menus.h"
#include "wgui_asyncdynamic_menus.h"
#include "wgui_softkeys.h"
#include "wgui_tab_bars.h"
#include "ImeGprot.h"
#include "InlineCui.h"
#include "gui_progress_bar.h"
#include "wgui_progress_bar.h"
#include "Imc.h"
#include "PhoneSetupGprots.h"
#include "gui_inputs_internal.h"

#include "Menucuigprot.h"
#include "Gui_font_size.h"

#if defined(__MMI_TOUCH_SCREEN__) && defined(__MMI_GESTURES_FRAMEWORK__)  
#include "mmi_frm_gestures.h"
#endif
#include "gui_touch_feedback.h"

#include "gui_horizontal_selector.h"
#include "kal_debug.h"

 #include "MMIDataType.h"
    #include "kal_public_defs.h"
    #include "wgui_inline_edit.h"
    #include "kal_general_types.h"
    #include "mmi_frm_input_gprot.h"
    #include "wgui_categories_util.h"
    #include "CustThemesRes.h"
    #include "gui.h"
    #include "gui_data_types.h"
    #include "gui_theme_struct.h"
    #include "gui_themes.h"
    #include "gui_typedef.h"
    #include "gui_windows.h"
    #include "gui_inputs.h"
    #include "gui_scrollbars.h"
    #include "wgui_inputs.h"
    #include "gui_buttons.h"
    #include "wgui_fixed_menus.h"
    #include "gdi_include.h"
    #include "gui_fixed_menus.h"
    #include "gui_config.h"
    #include "wgui.h"
    #include "GlobalConstants.h"
    #include "GlobalResDef.h"
    #include "wgui_include.h"
    #include "Unicodexdcl.h"
    #include "mmi_frm_events_gprot.h"
    #include "mmi_frm_history_gprot.h"
    #include "gui_fixed_menuitems.h"
    #include "string.h"
    #include "gdi_datatype.h"
    #include "mmi_rp_app_uiframework_def.h"
    #include "gdi_const.h"
    #include "PixcomFontEngine.h"
    #include "kal_public_api.h"
    #include "DebugInitDef_Int.h"
    #include "TimerEvents.h"
    #include "mmi_frm_timer_gprot.h"
    #include "gui_effect_oem.h"
    #include "wgui_categories_inputs.h"
    #include "InlineCuiGprot.h"
    #include "wgui_draw_manager.h"
    #include "wgui_touch_screen.h"
    #include "mmi_frm_gestures_gprot.h"
    #include "mmi_clipboard_gprot.h"
    #include "ScreenRotationGprot.h"
    #include "wgui_title.h"
    #include "gui_virtual_keyboard_language_type.h"
    #include "gui_virtual_keyboard.h"
    #include "wgui_categories_enum.h"
    #include "gui_switch.h"
    #include "IdleAppResDef.h"
    #include "WapResDef.h"
   // #include "PocResDef.h"
#ifndef __COSMOS_MMI_PACKAGE__
    #include "mmi_rp_app_sms_def.h"
#endif
    #include "CommonScreensResDef.h"
    #include "lcd_sw_inc.h"
    #include "Gui_Setting.h"
    #include "mmi_cb_mgr_gprot.h"
    #include "wgui_categories_list.h"
    #include "mmi_frm_mem_gprot.h"
    #include "CustMenuRes.h"
    #include "kal_trace.h"
    #include "stdio.h"
    #include "mmi_rp_srv_editor_def.h"
    #include "mmi_frm_scenario_gprot.h"

    #include "mmi_frm_mem_gprot.h"

#include "gd_include.h"




/***************************************************************************** 
 * Define
 *****************************************************************************/
/* History IDs for inline items  */
#define INLINE_TEXT_EDIT_HISTORY_ID                1
#define INLINE_SELECT_HISTORY_ID                   3
#define INLINE_USER_DEFINED_SELECT_HISTORY_ID      4
#define INLINE_DATE_HISTORY_ID                     5
#define INLINE_TIME_HISTORY_ID                     6
#define INLINE_DOW_SELECT_HISTORY_ID               7
#define INLINE_TIME_PERIOD_HISTORY_ID              8
#define INLINE_IP4_HISTORY_ID                      9
#define INLINE_FULL_SCREEN_EDIT_HISTORY_ID         10
#define INLINE_MULTI_LINE_EDIT_HISTORY_ID          11
#define INLINE_COLOR_SELECT_SCREEN_ID              12
#define INLINE_IMAGE_TEXT_HISTORY_ID               13

#define CATEGORY57_NO_KEY_FLAG                     0
#define CATEGORY57_UP_ARROW_KEY_FLAG               1
#define CATEGORY57_DOWN_ARROW_KEY_FLAG             2

#ifndef __MMI_INLINE_EDITOR_PRESS_ANY_KEY_ENTER_FULL_SCREEN__
#define __MMI_INLINE_EDITOR_PRESS_ANY_KEY_ENTER_FULL_SCREEN__
#endif

#define INLINE_DEFAULT_TEXT_BORDAR               1  
#define INLINE_DEFAULT_TEXT_BORDAR_GAP           1 

#ifdef  __MMI_FTE_SUPPORT__


U8 g_inline_vk_status;
#endif

#define MMI_INLINE_PROGRESS_BAR_Y_OFFSET_TO_SSP     10

/***************************************************************************** 
 * Typedef 
 *****************************************************************************/
#ifdef __MMI_TOUCH_SCREEN__
    
typedef enum
{
    /* Ignore pen events */
    WGUI_INLINE_PEN_HANDLER_NONE,
    /* Prepare to change highlight on Pen Up. Do nothing else. */
    WGUI_INLINE_PEN_HANDLER_SWITCH_ITEM,
    /* Redirect pen events to scrollbar */
    WGUI_INLINE_PEN_HANDLER_SCROLLBAR,
    /* Redirect pen events to the current menu item */
    WGUI_INLINE_PEN_HANDLER_CURRENT_ITEM,
    /* Wait long press animation to invoke LSK */
    WGUI_INLINE_PEN_HANDLER_WAIT_LONGPRESS,
    /* Redirect pen events to fullscreen editor */
    WGUI_INLINE_PEN_HANDLER_FULLSCREEN_EDITOR
} wgui_inline_pen_handler_type_enum;

#endif /* __MMI_TOUCH_SCREEN__ */
/***************************************************************************** 
 * Local Variable
 *****************************************************************************/
static KAL_ADM_ID   inline_adm_id = NULL;
static void  *wgui_inline_mem_alloc_info[MAX_INLINE_ITEMS*2];
static S32   wgui_inline_mem_alloc_number = 0;
static MMI_BOOL g_inline_menu_disable_loop = MMI_FALSE;
#if defined(__MMI_INLINE_EDITOR_PRESS_ANY_KEY_ENTER_FULL_SCREEN__)
static MMI_BOOL g_inline_disable_auto_enter = MMI_FALSE;
#endif
#if defined(__MMI_TOUCH_SCREEN__) || defined(__MMI_HANDWRITING_PAD__)
static BOOL mmi_pen_editor_is_closecategory57;
#endif /* defined(__MMI_TOUCH_SCREEN__) || defined(__MMI_HANDWRITING_PAD__) */ 

static S32 wgui_inline_item_key_code = -1;
static S32 wgui_inline_item_key_event = -1;
static S32 wgui_inline_item_x = 0;
static S32 wgui_inline_item_y = 0;
static S32 wgui_inline_item_width = 0;
static S32 wgui_inline_item_height = 0;
static S32 wgui_current_inline_item_type = 0;
static PU8 wgui_current_history_buffer = NULL;
#ifdef __MMI_INLINE_HIGHLIGHT_CAPTION__
static S32 wgui_inline_should_hl_caption_index = -1;
#endif

#if defined (__MMI_INLINE_ITEM_IMAGETEXT__)
U8 inline_image_text_edit_flag = 0;
#endif
static U16 *wgui_inline_list_of_icons = NULL;

#ifdef __MMI_TOUCH_SCREEN__
static wgui_inline_pen_handler_type_enum wgui_inline_pen_handler_type;
static S32 wgui_inline_pen_down_item_index;
static S32 wgui_inline_pen_real_down_item_index;
static BOOL(*wgui_current_inline_item_pen_function) (mmi_pen_event_type_enum pen_event, S16 x, S16 y,
                                                     gui_inline_item_pen_enum *item_event) 
                             = UI_dummy_inline_item_pen_function;

#endif /* __MMI_TOUCH_SCREEN__ */



#if defined (__MMI_WALLPAPER_ON_BOTTOM__)
static U8 inline_edit_scr_bg_opacity;
static BOOL inline_opacity_changed = FALSE;
#endif /* defined (__MMI_WALLPAPER_ON_BOTTOM__) */ 

/* for sending inline items' change notify to application */
static void (*inline_item_changed_handler) (U16 index);

static UI_filled_area temp_inline_list_menu_background_filler = 
{
    UI_FILLED_AREA_TYPE_COLOR,
    UI_NULL_IMAGE,
    NULL,
#ifdef __MMI_DEFAULT_THEME_3__
    {206, 206, 206, 100},
#else 
    {240, 240, 240, 100},
#endif 
    {0, 0, 0, 0},
    {0, 0, 0, 100},
    {0, 0, 0, 0},
    0
};

static UI_filled_area temp_inline_list_menu_normal_item_filler = {UI_FILLED_AREA_TYPE_COLOR,
    UI_NULL_IMAGE,
    NULL,
#ifdef __MMI_DEFAULT_THEME_3__
    {206, 206, 206, 100},
#else 
    {240, 240, 240, 100},
#endif 
    {0, 0, 0, 0},
    {0, 0, 0, 0},
    {0, 0, 0, 0},
    0
};

static UI_filled_area temp_inline_list_menu_selected_item_filler = {UI_FILLED_AREA_TYPE_COLOR,
    UI_NULL_IMAGE,
    NULL,
#ifdef __MMI_DEFAULT_THEME_3__
    {255, 255, 255, 100},
#else 
    {167, 232, 93, 100},
#endif 
    {0, 0, 0, 0},
    {0, 0, 0, 0},
    {0, 0, 0, 0},
    0
};

static UI_filled_area temp_inline_list_menu_disabled_item_filler = {UI_FILLED_AREA_TYPE_COLOR,
    UI_NULL_IMAGE,
    NULL,
    {192, 192, 192, 100},
    {0, 0, 0, 0},
    {0, 0, 0, 0},
    {0, 0, 0, 0},
    0
};
/*
static UI_filled_area temp_inline_select_menu_filler = {UI_FILLED_AREA_TYPE_COLOR,
    NULL,
    NULL,
    {71, 127, 255, 100},
    {0, 0, 0, 0},
    {0, 0, 0, 100},
    {0, 0, 0, 0},
    0
};
*/

static UI_fixed_text_menuitem_theme wgui_inline_select_fixed_text_menuitem_theme = { &temp_inline_list_menu_normal_item_filler,
    &temp_inline_list_menu_disabled_item_filler,
    &temp_inline_list_menu_selected_item_filler,
    &temp_inline_list_menu_selected_item_filler,
    &temp_inline_list_menu_selected_item_filler,    
    {0, 0, 0, 100},
    {0, 0, 0, 100},
    {0, 0, 0, 100},
    {0, 0, 0, 100},
    //{0, 0, 0, 100},
    &MMI_default_font,
    UI_MENUITEM_CENTER_TEXT_Y
};


#ifdef __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__
static U8 wgui_enable_inline_item_default_text = 0;

static UI_filled_area temp_inline_edit_normal_filler = {
    UI_FILLED_AREA_TYPE_COLOR,
    UI_NULL_IMAGE,
    NULL,
    {0, 0, 255, 100},
    {0, 0, 0, 0},
    {0, 0, 0, 100},
    {0, 0, 0, 0},
    0
};
#endif /* __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__ */ 

static U8 wgui_inline_edit_arrow_key_flag = CATEGORY57_NO_KEY_FLAG;

static void (*clear_inline_item_keys) (void) = UI_dummy_function;

static UI_string_type inline_text_edit_APP_Assigned_RSK_label_string = NULL;

static PU8 g_inline_picon = NULL;

/* When we draw unhighlight select item by ourselves, we use it to note icon x corrdinate, because it can not aligned for highlight and unhighlight case. */
#ifndef __MMI_FTE_SUPPORT__
static S32 g_select_unhighlight_x_corrdinate = 0;
#endif

static scrolling_text wgui_inline_scroll_text;

#ifdef __MMI_FTE_SUPPORT__
static inline_fte_line_style_enum g_inline_fte_item_height_table[MAX_INLINE_ITEMS];
#endif

#if defined(__MMI_INSCREEN_MULTILINE_TEXTBOX__)
#if defined( __MMI_INLINE_ITEM_MULTILINE_READ_ONLY__) || defined( __MMI_INLINE_ITEM_MULTILINE_EDIT__)
wgui_inline_ml_rdly_highlight_list_struct g_inline_ml_rdly_highlight_list = {0};
#endif
#endif

#if defined(__MMI_PHB_PHOTO_STICKER_SUPPORT__)
static Caption_thumbnail_struct g_caption_thumbnail_struct;
static Caption_thumbnail_struct *g_caption_thumbnail_struct_ptr = NULL;
#endif /* __MMI_PHB_PHOTO_STICKER_SUPPORT__ */

static void (*g_inline_lsk_functions)(void) = NULL;
static UI_string_type g_inline_lsk_string = NULL;
#define INLINE_GET_ITEM_TYPE(index)	(wgui_inline_items[index].flags & INLINE_ITEM_TYPE_MASK)
/***************************************************************************** 
 * Local Function
 *****************************************************************************/
static void wgui_show_image_text_item_highlight(S32 x1, S32 y1, S32 iwidth, S32 iheight, wgui_inline_item *item);
#ifdef __MMI_CLIPBOARD__
static U32 wgui_inline_sl_insert_string(UI_string_type str, U32 len, MMI_BOOL is_redraw);
#endif
U8 *inline_text_edit_get_history(U8 *history_buffer);
U8 *inline_date_edit_get_history(U8 *history_buffer);
U8 *inline_time_edit_get_history(U8 *history_buffer);
U8 *inline_time_period_edit_get_history(U8 *history_buffer);
U8 *inline_IP4_edit_get_history(U8 *history_buffer);
U8 *inline_DOW_select_get_history(U8 *history_buffer);
U8 *inline_multi_line_edit_get_history(U8 *history_buffer);
void inline_DOW_select_change_complete(void);
U8 *inline_image_text_get_history(U8 * history_buffer);
U8 inline_image_text_set_history(U16 history_ID, U8 * history_buffer);

/* IME related callback functions */
static U32 mmi_input_box_msg_call_back_inline(void * input_box_handle, mmi_imc_message_struct_p msg_ptr);
static void mmi_input_box_keep_current_item_info(void);
static void mmi_input_box_resume_current_item_info(void);

static void cat57_virtual_keypad_callback(void);
static void register_inline_fixed_list_keys(void);

static void ShowCommonCategoryInlineEdit(
               UI_string_type title, U16 title_icon, U16 left_softkey,
               U16 left_softkey_icon,U16 right_softkey, U16 right_softkey_icon,
               S32 number_of_items, U16 *list_of_icons,InlineItem *list_of_items,
               S32 highlighted_item, U8 *history_buffer,
               void (*highlight_handler) (S32 item_index),
               void (*unhighlight_handler) (S32 item_index),
               U16 history_id);


/* Inline Editor ADM API */
static void *wgui_inline_malloc(U16 size);

static void wgui_inputs_sl_inline_handle_left_arrow_repeat(void);
static void wgui_inputs_sl_inline_handle_right_arrow_repeat(void);
static void wgui_inputs_sl_inline_handle_right_softkey_repeat(void);
static void wgui_inputs_sl_inline_handle_right_softkey_touch_repeat(void);

static U32 inline_text_edit_get_control_full_width(single_line_input_box *b);
static U32 inline_text_edit_get_control_full_height(single_line_input_box *b);

static U32 inline_text_edit_get_control_x_coordinate(single_line_input_box *b);
static U32 inline_text_edit_get_control_y_coordinate(single_line_input_box *b);

#ifdef __MMI_FTE_SUPPORT__
void wgui_show_inline_fte_displayonly_item_unhighlight_ext(
                S32 x,
                S32 y,
                S32 width,
                S32 height,
                wgui_inline_item *item,
                U8 status_flag);

void wgui_show_inline_fte_displayonly_item_highlight(
                S32 x,
                S32 y,
                S32 width,
                S32 height,
                wgui_inline_item *item);

void wgui_show_inline_fte_displayonly_item_highlight_ext(
                S32 x,
                S32 y,
                S32 width,
                S32 height,
                wgui_inline_item *item,
                U8 status_flag);

void inline_fte_set_item_height_by_guess(InlineItem *list_of_items, S32 number_of_items);
    
void wgui_inline_get_vk_status(U8 *vk_status);
void wgui_inline_set_vk_status(U8 vk_status);

void wgui_inline_brush_item_background(S32 x1, S32 y1, S32 x2, S32 y2);
    
#endif

void wgui_inlinescrolling_timer(void);
void wgui_scrolling_text_draw_background(S32 x1, S32 y1, S32 x2, S32 y2);
void wgui_show_inline_text_edit_list_menuitem(S32 x1, S32 y1, S32 width, S32 height, wgui_inline_item *item);
UI_single_line_input_box_theme wgui_inline_singleline_inputbox_unfocussed_theme;
UI_single_line_input_box_theme wgui_inline_singleline_inputbox_focussed_theme;

void wgui_inline_set_focussed_progress_bar_theme();
void wgui_inline_set_unfocussed_progress_bar_theme();
void wgui_show_inline_progress_bar_list_menuitem(S32 x1, S32 y1, S32 width, S32 height, wgui_inline_item *item);

void wgui_inline_stop_scroll(void);
void wgui_inline_start_scroll(void);

#ifdef __MMI_TOUCH_SCREEN__
S32 wgui_inline_get_item_height_for_scroll_bar(gui_scrollbar_dir_enum direction);
#endif

#ifdef __MMI_INLINE_ITEM_RADIO__
static void inline_radio_select_handler(void);
#endif

#ifdef __MMI_INLINE_ITEM_CHECKBOX__
static void inline_checkbox_lsk_function(void);
#endif

static void wgui_inline_option_handler_for_lsk(void);

static void handle_inline_text_edit_right_softkey_down(void);

/***************************************************************************** 
 * Global Variable
 *****************************************************************************/
static MMI_ID g_inline_op_parent_id = GRP_ID_ROOT;
wgui_inline_item wgui_inline_items[MAX_INLINE_ITEMS];
wgui_inline_item *current_wgui_inline_item = NULL;

PU8 g_wgui_inine_items_buffer = NULL;

S32 wgui_n_inline_items = 0;
S32 wgui_inline_item_highlighted_index = -1;
U8 wgui_inline_item_handled = 0;

U8 g_inline_is_no_redraw_status = 0;

#if defined(__MMI_INSCREEN_MULTILINE_TEXTBOX__)
S8 MMI_multi_line_inputbox_present = 0;
#endif 

/* Added to handle (Back/Done) on RSK  */
U8 wgui_inline_list_menu_changed = 0;
U8 wgui_inline_list_menu_disable_done = 0;
U8 wgui_inline_list_menu_rsk_back = 0;
void (*wgui_inline_edit_BACK_function) (void) = NULL;
void (*wgui_inline_edit_DONE_function) (void) = NULL;
void (*wgui_inline_edit_LSK_function) (void) = NULL;


UI_fixed_list_menu_theme wgui_inline_fixed_list_menu_theme = { 
    &temp_inline_list_menu_background_filler,
    &temp_inline_list_menu_background_filler,
    5,
    UI_LIST_MENU_LOOP
};

UI_fixed_icontext_menuitem_theme wgui_inline_fixed_icontext_menuitem_theme =
    { &temp_inline_list_menu_normal_item_filler,
    &temp_inline_list_menu_disabled_item_filler,
    &temp_inline_list_menu_selected_item_filler,
    &temp_inline_list_menu_selected_item_filler,
    &temp_inline_list_menu_selected_item_filler,
    {0, 0, 0, 100},
    {0, 0, 0, 100},
    {0, 0, 0, 100},
    {0, 0, 0, 100},
    //{0, 0, 0, 100},
    &MMI_default_font,
    UI_MENUITEM_CENTER_TEXT_Y | UI_MENUITEM_CENTER_ICON_Y
};


void (*redraw_current_inline_item) (void) = UI_dummy_function;
void (*complete_inline_item_edit) (void) = UI_dummy_function;


/***************************************************************************** 
 * Extern Global Variable
 *****************************************************************************/

extern mmi_editor_handler_struct g_mmi_editor_hanler;

/* for 0x81 encoding support for Phone Book */
extern S16 MMI_current_input_ext_type;

extern UI_single_line_input_box_theme date_time_input_theme;
extern UI_filled_area date_time_input_field_filler;
extern UI_filled_area date_time_input_background_filler;
extern UI_filled_area time_period_input_background_filler;

extern icontext_button MMI_softkeys[];

extern S32(*wgui_inputbox_UCS2_count_function) (void);

#ifdef __MMI_UI_TRANSPARENT_EFFECT__
extern UI_filled_area fixed_icontext_menuitem_transparent_filled_area;
#endif /* __MMI_UI_TRANSPARENT_EFFECT__ */

extern S32 UI_text_menuitem_scroll_time;


/***************************************************************************** 
 * Extern Global Function
 *****************************************************************************/
extern void gui_single_line_input_box_locate_cursor(single_line_input_box *b);
extern void set_current_input_box_type(mmi_editor_inoutbox_enum input_box_type);
#if defined (__MMI_TOUCH_SCREEN__)
extern void date_input_move_to_x_y(date_input *d, S32 x, S32 y);
extern void time_input_move_to_x_y(time_input *t, S32 x, S32 y);
extern void time_period_input_move_to_x_y(time_period_input *tp, S32 x, S32 y);
extern void IP4_input_move_to_x_y(IP4_input *ip4, S32 x, S32 y);
#endif
extern void reset_pop_up_descriptions(void);

/***************************************************************************** 
 * Common Function Implementation
 *****************************************************************************/

/*****************************************************************************
 * FUNCTION
 *  get_wgui_inline_list_menu_status
 * DESCRIPTION
 *  get inline list menu changed status
 * PARAMETERS
 *  void
 * RETURNS
 *  the value of wgui_inline_list_menu_changed
 *****************************************************************************/
S32 get_wgui_inline_list_menu_status(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return wgui_inline_list_menu_changed;
}


/*****************************************************************************
 * FUNCTION
 *  set_wgui_inline_list_menu_status
 * DESCRIPTION
 *  set inline list menu changed status
 * PARAMETERS
 *  status      [IN]        value of wgui_inline_list_menu_changed
 * RETURNS
 *  void
 *****************************************************************************/
void set_wgui_inline_list_menu_status(S32 status)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_inline_list_menu_changed = (U8) status;
}


/*****************************************************************************
 * FUNCTION
 *  SetInlineListMenuChanged
 * DESCRIPTION
 *  wrapper function of set_wgui_inline_list_menu_changed()
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void SetInlineListMenuChanged(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    set_wgui_inline_list_menu_changed();
}


/*****************************************************************************
 * FUNCTION
 *  GetInlineListMenuChanged
 * DESCRIPTION
 *  get the value of wgui_inline_list_menu_changed
 * PARAMETERS
 *  void
 * RETURNS
 *  the value value of wgui_inline_list_menu_changed
 *****************************************************************************/
S32 GetInlineListMenuChanged(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return wgui_inline_list_menu_changed;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_inline_edit_get_next_highlight_index
 * DESCRIPTION
 *  to get next highlightable inline item's index
 * PARAMETERS
 *  start_index start index of inline item
 * RETURNS
 *  next highlightable index
 *****************************************************************************/
S32 wgui_inline_edit_get_next_highlight_index(S32 start_index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (i = start_index; i < wgui_n_inline_items; i++)
    {
        U32 flags = wgui_inline_items[i].flags;
        S32 item_type = wgui_inline_items[i].flags & INLINE_ITEM_TYPE_MASK;
        
        if (!((flags & INLINE_ITEM_DISABLED) ||
            (item_type == INLINE_ITEM_TYPE_CAPTION)))
        {
            return i;
        }
        
    }
    
    for (i = 0; i < start_index; i++)
    {
        U32 flags = wgui_inline_items[i].flags;
        S32 item_type = wgui_inline_items[i].flags & INLINE_ITEM_TYPE_MASK;
        
        if (!((flags & INLINE_ITEM_DISABLED) ||
            (item_type == INLINE_ITEM_TYPE_CAPTION)))
        {
            return i;
        }
        
    }
    
    return start_index;
}


/*****************************************************************************
 * FUNCTION
*  wgui_inline_edit_get_next_highlight_index
* DESCRIPTION
*  to get previous highlightable inline item's index
* PARAMETERS
*  start_index start index of inline item
* RETURNS
*  previous highlightable index
 *****************************************************************************/
S32 wgui_inline_edit_get_previous_highlight_index(S32 start_index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i = 0;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (i = start_index; i >= 0; i--)
    {
        U32 flags = wgui_inline_items[i].flags;
        S32 item_type = wgui_inline_items[i].flags & INLINE_ITEM_TYPE_MASK;
        
        if (!((flags & INLINE_ITEM_DISABLED) ||
            (item_type == INLINE_ITEM_TYPE_CAPTION)))
        {
            return i;
        }
        
    }
    
    for (i = wgui_n_inline_items - 1; i > start_index; i--)
    {
        U32 flags = wgui_inline_items[i].flags;
        S32 item_type = wgui_inline_items[i].flags & INLINE_ITEM_TYPE_MASK;
        
        if (!((flags & INLINE_ITEM_DISABLED) ||
            (item_type == INLINE_ITEM_TYPE_CAPTION)))
        {
            return i;
        }
        
    }
    
    return start_index;
}



/*****************************************************************************
 * FUNCTION
 *  wgui_inline_edit_is_able_to_switch_highlight
 * DESCRIPTION
 *  to check if current inline editor can switch highlight to next/previous item
 * PARAMETERS
 *  direction   0 -> previous ; 1-> next
 * RETURNS
 *  MMI_TRUE -> can switch highlight   MMI_FALSE -> can't switch highlight
 *****************************************************************************/
MMI_BOOL wgui_inline_edit_is_able_to_switch_highlight(S32 direction)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i = 0;
    S32 switchable_item_no = 0;
    S32 ret_idx = 0;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_inline_menu_disable_loop || (!(MMI_fixed_list_menu.flags & UI_LIST_MENU_LOOP)))
    {
        if (direction == 1)
        {
            if (wgui_inline_item_highlighted_index == (wgui_n_inline_items -1))
            {
                return MMI_FALSE;
            }
            else
            {
                i = wgui_inline_item_highlighted_index + 1;
            }
            ret_idx = wgui_inline_edit_get_next_highlight_index(i);
        }
        else
        {
            if (wgui_inline_item_highlighted_index == 0)
            {
                return MMI_FALSE;
            }
            else
            {
                i = wgui_inline_item_highlighted_index - 1;
            }
            ret_idx = wgui_inline_edit_get_previous_highlight_index(i);
        }
        
        if ((ret_idx == wgui_inline_item_highlighted_index)  ||
            ((ret_idx > wgui_inline_item_highlighted_index) && (direction == 0)) ||
            ((ret_idx < wgui_inline_item_highlighted_index) && (direction == 1)))
        {
            return MMI_FALSE;
        }
        else
        {
            return MMI_TRUE;
        }       
    }
    
    for (i = 0; i < wgui_n_inline_items; i++)
    {
        U32 flags = wgui_inline_items[i].flags;
        S32 item_type = wgui_inline_items[i].flags & INLINE_ITEM_TYPE_MASK;
        
        if (!((flags & INLINE_ITEM_DISABLED)         ||
              (item_type == INLINE_ITEM_TYPE_CAPTION)))
        {
            switchable_item_no++;
        }

        if (switchable_item_no >= 2)
        {
            return MMI_TRUE;
        }
    }

    return MMI_FALSE;

}
    

/*****************************************************************************
 * FUNCTION
 *  inline_fixed_list_goto_previous_item
 * DESCRIPTION
 *  goto previous item in inline fixed list
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void inline_fixed_list_goto_previous_item(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* FIXME. register as complete_inline_item_edit()? */
    if(!wgui_inline_edit_is_able_to_switch_highlight(0))
    {
        return ;
    }

#if defined( __MMI_INLINE_ITEM_MULTILINE_READ_ONLY__) || defined( __MMI_INLINE_ITEM_MULTILINE_EDIT__)
    if (!(MMI_multiline_inputbox.flags & UI_MULTI_LINE_INPUT_BOX_VIEW_MODE) &&
        (MMI_multiline_inputbox.flags & UI_MULTI_LINE_INPUT_BOX_INSIDE_INLINE_MENU))
    {
        handle_inline_multi_line_edit_complete();
    }
#endif    
    wgui_inline_edit_arrow_key_flag = CATEGORY57_UP_ARROW_KEY_FLAG;
    clear_inline_item_keys();
    register_inline_fixed_list_keys();

#ifdef __MMI_FTE_SUPPORT__
    wgui_inline_set_vk_status(g_inline_vk_status);
#endif

    /* Lock frame buffer to avoid partial screen update 
       (e.g. softkey changed before list is redrawn) */
    gdi_layer_lock_frame_buffer();
    fixed_list_goto_previous_item();
    gdi_layer_unlock_frame_buffer();
    gdi_layer_blt_previous(0, 0, UI_device_width - 1, UI_device_height - 1);    

#ifdef __MMI_FTE_SUPPORT__	
	mmi_imc_set_vk_present(MMI_IMC_VK_DEFAULT_ENLARGE);
#endif

}


/*****************************************************************************
 * FUNCTION
 *  inline_fixed_list_goto_next_item
 * DESCRIPTION
 *  goto next item in inline fixed list
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void inline_fixed_list_goto_next_item(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(!wgui_inline_edit_is_able_to_switch_highlight(1))
    {
        return ;
    }
	
    wgui_inline_edit_arrow_key_flag = CATEGORY57_DOWN_ARROW_KEY_FLAG;
    clear_inline_item_keys();
    register_inline_fixed_list_keys();

#ifdef __MMI_FTE_SUPPORT__
    wgui_inline_set_vk_status(g_inline_vk_status);
#endif

    /* Lock frame buffer to avoid partial screen update 
       (e.g. softkey changed before list is redrawn) */
    gdi_layer_lock_frame_buffer();
    fixed_list_goto_next_item();
    gdi_layer_unlock_frame_buffer();
    gdi_layer_blt_previous(0, 0, UI_device_width - 1, UI_device_height - 1);

#ifdef __MMI_FTE_SUPPORT__	
	mmi_imc_set_vk_present(MMI_IMC_VK_DEFAULT_ENLARGE);
#endif

}


/*****************************************************************************
 * FUNCTION
 *  inline_fixed_list_goto_item
 * DESCRIPTION
 *  goto item with item index and backward.
 * PARAMETERS
 *  index           [IN]      item index  
 *  backward        [IN]      TRUE -> up ; FALSE -> down  
 * RETURNS
 *  void
 *****************************************************************************/
void inline_fixed_list_goto_item_no_redraw(S32 index, BOOL backward)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    if (backward)
    {
        wgui_inline_edit_arrow_key_flag = CATEGORY57_UP_ARROW_KEY_FLAG;
    }
    else
    {
        wgui_inline_edit_arrow_key_flag = CATEGORY57_DOWN_ARROW_KEY_FLAG;
    }
    clear_inline_item_keys();
    register_inline_fixed_list_keys();
    
    gdi_layer_lock_frame_buffer();
    g_inline_is_no_redraw_status = 1;
    if (wgui_inline_edit_is_able_to_switch_highlight(!backward)) 
    {
        gui_fixed_list_menu_goto_item(&MMI_fixed_list_menu, index);   
    }
    else
    {
        S32 old_index = wgui_inline_item_highlighted_index;
        MMI_fixed_list_menu.highlighted_item =  -1 ;
        //wgui_inline_item_highlighted_index = -1;
        gui_fixed_list_menu_goto_item(&MMI_fixed_list_menu, old_index);
    }
    g_inline_is_no_redraw_status = 0;
    gdi_layer_unlock_frame_buffer();
}

/*****************************************************************************
 * FUNCTION
 *  inline_fixed_list_goto_item
 * DESCRIPTION
 *  goto item with item index and backward.
 * PARAMETERS
 *  index           [IN]      item index  
 *  backward        [IN]      TRUE -> up ; FALSE -> down  
 * RETURNS
 *  void
 *****************************************************************************/
void inline_fixed_list_goto_item(S32 index, BOOL backward)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* FIXME. register as complete_inline_item_edit()? */
    if (backward)
    {
        wgui_inline_edit_arrow_key_flag = CATEGORY57_UP_ARROW_KEY_FLAG;
    }
    else
    {
        wgui_inline_edit_arrow_key_flag = CATEGORY57_DOWN_ARROW_KEY_FLAG;
    }
    clear_inline_item_keys();
    register_inline_fixed_list_keys();

    /* Lock frame buffer to avoid partial screen update 
       (e.g. softkey changed before list is redrawn) */
    gdi_layer_lock_frame_buffer();
    fixed_list_goto_item(index);
    gdi_layer_unlock_frame_buffer();
    gdi_layer_blt_previous(0, 0, UI_device_width - 1, UI_device_height - 1);    

}


/*****************************************************************************
 * FUNCTION
 *  inline_fixed_list_key_handler
 * DESCRIPTION
 *  key handler used only on PC
 * PARAMETERS
 *  vkey_code       [IN]  key code      
 *  key_state       [IN]  key state      
 * RETURNS
 *  void
 *****************************************************************************/
void inline_fixed_list_key_handler(S32 vkey_code, S32 key_state)
{
#if(MMI_BUILD_TYPE == BUILD_TYPE_X86WIN32)
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (key_state)
    {
        switch (vkey_code)
        {
            case 37:
                break;
            case 39:
                break;
            case 38:
                inline_fixed_list_goto_previous_item();
                break;
            case 40:
                inline_fixed_list_goto_next_item();
                break;
            case 36:
                clear_inline_item_keys();
                fixed_list_goto_home();
                break;
            case 35:
                clear_inline_item_keys();
                fixed_list_goto_end();
                break;
            case 33:
                clear_inline_item_keys();
                fixed_list_goto_previous_page();
                break;
            case 34:
                clear_inline_item_keys();
                fixed_list_goto_next_page();
                break;
        }
    }
#else /* (MMI_BUILD_TYPE == BUILD_TYPE_X86WIN32) */ 
    UI_UNUSED_PARAMETER(vkey_code);
    UI_UNUSED_PARAMETER(key_state);
#endif /* (MMI_BUILD_TYPE == BUILD_TYPE_X86WIN32) */ 
}


/*****************************************************************************
 * FUNCTION
 *  register_inline_fixed_list_keys
 * DESCRIPTION
 *  register inline fixed list key handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void register_inline_fixed_list_keys(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    register_keyboard_key_handler(inline_fixed_list_key_handler);

    /* key rule. 09.10.17 */
    SetKeyHandler(inline_fixed_list_goto_previous_item, KEY_UP_ARROW, KEY_EVENT_REPEAT);
    SetKeyHandler(inline_fixed_list_goto_next_item, KEY_DOWN_ARROW, KEY_EVENT_REPEAT);
    SetKeyHandler(inline_fixed_list_goto_previous_item, KEY_VOL_UP, KEY_EVENT_REPEAT);
    SetKeyHandler(inline_fixed_list_goto_next_item, KEY_VOL_DOWN, KEY_EVENT_REPEAT);
    
    SetKeyHandler(inline_fixed_list_goto_previous_item, KEY_UP_ARROW, KEY_EVENT_DOWN);
    SetKeyHandler(inline_fixed_list_goto_next_item, KEY_DOWN_ARROW, KEY_EVENT_DOWN);
    SetKeyHandler(inline_fixed_list_goto_previous_item, KEY_VOL_UP, KEY_EVENT_DOWN);
    SetKeyHandler(inline_fixed_list_goto_next_item, KEY_VOL_DOWN, KEY_EVENT_DOWN);
}


/* Changes to allow Back/Done key and Clear key in case of Inline edit  */
/* Max: add state to set RSK to "Clear" */
/*****************************************************************************
 * FUNCTION
 *  wgui_inline_edit_get_RSK_string
 * DESCRIPTION
 *  get RSK String
 * PARAMETERS
 *  void
 * RETURNS
 *  UI_string_type
 *****************************************************************************/
UI_string_type wgui_inline_edit_get_RSK_string(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (wgui_inline_list_menu_changed)
    {
        if (wgui_inline_list_menu_disable_done == 2)
        {
            return ((UI_string_type) get_string(STR_GLOBAL_CLEAR));
        }
		else
		{
		    return ((UI_string_type) get_string(STR_GLOBAL_BACK));
		}
    }
    else
    {
        return ((UI_string_type) get_string(STR_GLOBAL_BACK));
    }
}


/*****************************************************************************
 * FUNCTION
 *  execute_wgui_inline_edit_text_empty
 * DESCRIPTION
 *  execute text empty func of inline editor
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void execute_wgui_inline_edit_text_empty(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    if(cui_inline_is_current_cui())
    {
        cui_inline_evt_item_text_empty(); 
    }
    else
    {
        if (wgui_inputbox_empty_callback != NULL)
        {
            wgui_inputbox_empty_callback();
        }
    }	
}


/*****************************************************************************
 * FUNCTION
 *  execute_wgui_inline_edit_text_not_empty
 * DESCRIPTION
 *  execute text not empty func of inline editor
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void execute_wgui_inline_edit_text_not_empty(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(cui_inline_is_current_cui())
    {
        cui_inline_evt_item_text_not_empty(); 
    }
    else
    {
        if (wgui_inputbox_not_empty_callback != NULL)
        {
            wgui_inputbox_not_empty_callback();
        }
    }	
}


/*****************************************************************************
 * FUNCTION
 *  execute_wgui_inline_edit_DONE_function
 * DESCRIPTION
 *  execute DONE func of inline editor
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void execute_wgui_inline_edit_DONE_function(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    complete_inline_item_edit();
    MMI_multi_line_inputbox_present = 0;
    if (wgui_inline_edit_DONE_function != NULL)
    {
        wgui_inline_edit_DONE_function();
    }
}


/*****************************************************************************
 * FUNCTION
 *  execute_wgui_inline_edit_BACK_function
 * DESCRIPTION
 *  execute BACK func of inline editor
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void execute_wgui_inline_edit_BACK_function(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (wgui_inline_edit_BACK_function != NULL)
    {
        MMI_multi_line_inputbox_present = 0;
        wgui_inline_edit_BACK_function();
    }
}


/*****************************************************************************
 * FUNCTION
 *  execute_wgui_inline_edit_RSK_function
 * DESCRIPTION
 *  execute RSK func of inline editor
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void execute_wgui_inline_edit_RSK_function(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(cui_inline_is_current_cui())
    {
        cui_inline_rsk_function();
        return;
    }

	execute_wgui_inline_edit_BACK_function();
}


/*****************************************************************************
 * FUNCTION
 *  execute_wgui_inline_edit_LSK_function
 * DESCRIPTION
 *  execute LSK func of inline editor
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void execute_wgui_inline_edit_LSK_function(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    complete_inline_item_edit();
    if (wgui_inline_edit_LSK_function != NULL)
    {
        wgui_inline_edit_LSK_function();
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_inline_set_anykey_auto_enter
 * DESCRIPTION
 *  disable the anykey auto entering function
 * PARAMETERS
 *  b_enable  [IN]
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_inline_set_anykey_auto_enter(MMI_BOOL b_enable)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(__MMI_INLINE_EDITOR_PRESS_ANY_KEY_ENTER_FULL_SCREEN__)
    g_inline_disable_auto_enter = (MMI_BOOL)(!b_enable);
#endif
}


#ifdef __MMI_INLINE_EDITOR_PRESS_ANY_KEY_ENTER_FULL_SCREEN__
/*****************************************************************************
 * FUNCTION
 *  wgui_inline_key_enter_is_able_to_enter
 * DESCRIPTION
 *  whether is able to enter screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static MMI_BOOL wgui_inline_key_enter_is_able_to_enter(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    const S8 *p1, *p2;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	if (wgui_current_inline_item_type == INLINE_ITEM_TYPE_FULL_SCREEN_EDIT)
	{
		return MMI_FALSE;
	}
    if (g_inline_lsk_string)
    {
        p1 = (const S8*)g_inline_lsk_string;
    }
    else
    {
        p1 = (const S8*)get_softkey_label(MMI_LEFT_SOFTKEY);
    }
    p2 = (const S8*)get_string(STR_GLOBAL_EDIT);
    
    if (p1 == NULL || mmi_ucs2cmp(p1, p2) != 0)
    {
        return MMI_FALSE;
    }
    return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_inline_key_enter_lsk_up_handler
 * DESCRIPTION
 *  Execute left softkey handler
 * PARAMETERS
 *  key_code        [IN]        unused (just for register funchdlr)
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_inline_key_enter_lsk_up_handler(MMI_key_code_type key_code)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL is_input_key = MMI_FALSE, is_enterd = MMI_FALSE;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!g_inline_disable_auto_enter)
    {
        if (!wgui_inline_key_enter_is_able_to_enter())
        {
            return ;
        }
        
        if (g_inline_lsk_functions)
        {
            gui_multi_line_reset_create_flag();
            g_inline_lsk_functions();
            is_enterd = MMI_TRUE;
        }
        else if (GetKeyHandler(KEY_LSK, KEY_EVENT_UP))
        {
            gui_multi_line_reset_create_flag();
            /* Some softkey handlers use GetkeyInfo() */
            SetkeyInfo(KEY_LSK, KEY_EVENT_UP);
            execute_softkey_function(KEY_EVENT_UP, MMI_LEFT_SOFTKEY);
            is_enterd = MMI_TRUE;
        }
        
        if (is_enterd)
        {
            if (mmi_imc_is_connected() && (gui_multi_line_reset_create_flag() == 1))
            {
                if (key_code == KEY_STAR || key_code == KEY_POUND)
                {
                    if (mmi_imc_key_is_current_symbol_key(key_code))
                    {
                        is_input_key = MMI_TRUE;
                    }
                }
                else
                {
                    is_input_key = MMI_TRUE;
                }
                
                if (is_input_key)
                {
                    ExecuteCurrKeyHandler((S16)key_code, KEY_EVENT_DOWN);
                    ExecuteCurrKeyHandler((S16)key_code, KEY_EVENT_UP);
                }
            }
        }
    }
}

#ifdef __MMI_QWERTY_KEYPAD_SUPPORT__
extern mmi_ret mmi_imc_key_qwerty_key_proc(mmi_event_struct *evt);
/*****************************************************************************
 * FUNCTION
 *  wgui_inline_key_enter_key_proc
 * DESCRIPTION
 * PARAMETERS
 * RETURNS
 *  void
 *****************************************************************************/
static mmi_ret wgui_inline_key_enter_key_proc(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_frm_key_evt_struct *key_evt = (mmi_frm_key_evt_struct *)evt;
    U8 mmi_key_code = key_evt->key_code;
    MMI_BOOL is_enterd = MMI_FALSE;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (key_evt->evt_id == EVT_ID_ON_KEY)
    {
        if (!g_inline_disable_auto_enter)
        {
            if (!wgui_inline_key_enter_is_able_to_enter())
            {
                return MMI_RET_OK;
            }
            
            if (mmi_imc_key_is_current_symbol_key(mmi_key_code)
                || mmi_key_code == KEY_SPACE || mmi_key_code == KEY_QWERTY_ENTER)
            {
                if (g_inline_lsk_functions)
                {
                    gui_multi_line_reset_create_flag();
                    g_inline_lsk_functions();
                    is_enterd = MMI_TRUE;
                }
                else if (GetKeyHandler(KEY_LSK, KEY_EVENT_UP))
                {
                    gui_multi_line_reset_create_flag();
                    /* Some softkey handlers use GetkeyInfo() */
                    SetkeyInfo(KEY_LSK, KEY_EVENT_UP);
                    execute_softkey_function(KEY_EVENT_UP, MMI_LEFT_SOFTKEY);
                    is_enterd = MMI_TRUE;
                }
                if (is_enterd)
                {
                    if (mmi_imc_is_connected() && (gui_multi_line_reset_create_flag() == 1))
                    {
                        mmi_frm_key_evt_struct tmp_evt;
                        mmi_frm_construct_key_event(mmi_key_code, KEY_EVENT_DOWN, &tmp_evt);
                        tmp_evt.evt_id = EVT_ID_PRE_KEY;
                        MMI_FRM_SEND_EVENT(&tmp_evt, mmi_imc_key_qwerty_key_proc, NULL);
                        mmi_frm_construct_key_event(mmi_key_code, KEY_EVENT_UP, &tmp_evt);	  
                        tmp_evt.evt_id = EVT_ID_PRE_KEY;
                        MMI_FRM_SEND_EVENT(&tmp_evt, mmi_imc_key_qwerty_key_proc, NULL);
                        return MMI_RET_KEY_HANDLED;
                    }
                    return MMI_RET_KEY_HANDLED;
                }
            }
        }
    }
    return MMI_RET_OK;
}
#endif


/*****************************************************************************
 * FUNCTION
 *  wgui_inline_key_enter_clear_key_handler
 * DESCRIPTION
 *  need to clear all key handler which registered in hightlight handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_inline_key_enter_clear_key_handler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables												  */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body													  */
    /*----------------------------------------------------------------*/
    clear_MMI_key_input_handler();
    ClearKeyHandler(KEY_0, KEY_REPEAT);
    ClearKeyHandler(KEY_1, KEY_REPEAT);
    ClearKeyHandler(KEY_2, KEY_REPEAT);
    ClearKeyHandler(KEY_3, KEY_REPEAT);
    ClearKeyHandler(KEY_4, KEY_REPEAT);
    ClearKeyHandler(KEY_5, KEY_REPEAT);
    ClearKeyHandler(KEY_6, KEY_REPEAT);
    ClearKeyHandler(KEY_7, KEY_REPEAT);
    ClearKeyHandler(KEY_8, KEY_REPEAT);
    ClearKeyHandler(KEY_9, KEY_REPEAT);
    ClearKeyHandler(KEY_POUND, KEY_EVENT_DOWN);
    ClearKeyHandler(KEY_POUND, KEY_EVENT_UP);
    ClearKeyHandler(KEY_STAR, KEY_EVENT_DOWN);
    ClearKeyHandler(KEY_STAR, KEY_EVENT_UP);
    clear_key_up_handler();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_inline_key_enter_register_key_handler
 * DESCRIPTION
 *  needs to register all key up handler of specific keys (key 0~9 , star and pound key )
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_inline_key_enter_register_key_handler(S32 item_index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables												  */
    /*----------------------------------------------------------------*/
    S32 item_type = 0;
    
    /*----------------------------------------------------------------*/
    /* Code Body													  */
    /*----------------------------------------------------------------*/
    item_type = INLINE_GET_ITEM_TYPE(item_index);
    if(item_type == INLINE_ITEM_TYPE_FULL_SCREEN_EDIT ||
        item_type == INLINE_ITEM_TYPE_DISPLAY_ONLY     ||
        item_type == INLINE_ITEM_IMAGE_TEXT_TYPE       ||
        item_type == INLINE_ITEM_TYPE_MULTI_LINE_RD_ONLY)
    {
        if((wgui_inline_items[item_index].flags & INLINE_ITEM_DISPLAY_ONLY_NO_NUMKEY) == 0)
        {
        #if defined(__MMI_QWERTY_KEYPAD_SUPPORT__)
            MMI_WGUI_SET_KEY_PROC(wgui_inline_key_enter_key_proc, NULL);
        #else
            register_MMI_key_input_handler();
            register_MMI_key_input_extend_handler();
            clear_key_down_handler();
            register_key_up_handler(wgui_inline_key_enter_lsk_up_handler);
        #endif
        }
    }
}
#endif /* __MMI_INLINE_EDITOR_PRESS_ANY_KEY_ENTER_FULL_SCREEN__ */


/*****************************************************************************
 * FUNCTION
 *  register_inline_edit_handle_right_softkey_up
 * DESCRIPTION
 *  register Right softkey up handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void register_inline_edit_handle_right_softkey_up(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    set_right_softkey_function(execute_wgui_inline_edit_RSK_function, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  set_wgui_inline_list_menu_changed
 * DESCRIPTION
 *  set wgui_inline_list_menu_changed
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void set_wgui_inline_list_menu_changed(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* for sending inline items' change notify to application */
    if(cui_inline_is_current_cui())
    {
       cui_inline_evt_item_changed(); 
    }
    else
    {
        if (inline_item_changed_handler != NULL)
        {
            inline_item_changed_handler((U16) wgui_inline_item_highlighted_index);
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_inline_edit_register_BACK_function
 * DESCRIPTION
 *  register BACK key handler of inline editor
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_inline_edit_register_BACK_function(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(cui_inline_is_current_cui())
    {
        set_right_softkey_function(cui_inline_rsk_function, KEY_EVENT_UP);
        return;
    }
    set_right_softkey_function(execute_wgui_inline_edit_BACK_function, KEY_EVENT_UP);
}




/*****************************************************************************
 * FUNCTION
 *  wgui_inline_text_edit_set_RSK_BACK_function
 * DESCRIPTION
 *  set RSK back function
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_inline_text_edit_set_RSK_BACK_function(void)
{   
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_frm_kbd_is_key_supported(KEY_CLEAR))
    {
        SetKeyHandler(handle_inline_text_edit_right_softkey_down, KEY_CLEAR, KEY_EVENT_DOWN);
        SetKeyHandler(UI_dummy_function, KEY_CLEAR, KEY_EVENT_UP);
    }
    if (inline_text_edit_APP_Assigned_RSK_label_string != NULL)
    {
        set_right_softkey_label(inline_text_edit_APP_Assigned_RSK_label_string);
    }
    else
    {
        set_right_softkey_label((UI_string_type) get_string(STR_GLOBAL_BACK));
    }
    /*	On DisableDone station, When  pen down to clear text till text is empty ,
    and pen is not left still pen move away rightkey, the rightkey handler can not be registered.
    So we modify that rightkey is registered for KEY_EVENT_DOWN event. 
    */
    set_right_softkey_function(wgui_inline_edit_register_BACK_function, KEY_EVENT_DOWN);

    if(!g_inline_is_no_redraw_status)
    {
        redraw_right_softkey();
    }

}


/*****************************************************************************
 * FUNCTION
 *  ShowAsControl
 * DESCRIPTION
 *  show inline item as control
 * PARAMETERS
 *  item        [IN]     iniline item's pointer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowAsControl(InlineItem *item)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    item->show_img_flag = TRUE;
}

/*****************************************************************************
 * FUNCTION
 *  SetInlineItemActivation
 * DESCRIPTION
 *  set inline item's key code and key state
 * PARAMETERS
 *  item            [IN]        inline item's pointer 
 *  key_code        [IN]        key code
 *  key_event       [IN]        key event
 * RETURNS
 *  void
 *****************************************************************************/
void SetInlineItemActivation(InlineItem *item, S32 key_code, S32 key_event)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    item->key_code = key_code;
    item->key_event = key_event;

}


/*****************************************************************************
 * FUNCTION
 *  DisableInlineItem
 * DESCRIPTION
 *  disable inline item
 * PARAMETERS
 *  item        [IN]    inline item's pointer     
 *  index       [IN]    item's index    
 * RETURNS
 *  void
 *****************************************************************************/
void DisableInlineItem(InlineItem *item, S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    item->flags |= INLINE_ITEM_DISABLED;
    wgui_inline_items[index].flags |= INLINE_ITEM_DISABLED;
}


/*****************************************************************************
 * FUNCTION
 *  EnableInlineItem
 * DESCRIPTION
 *  Enable inline item
 * PARAMETERS
 *  item        [IN]    inline item's pointer         
 *  index       [IN]    inline item's index    
 * RETURNS
 *  void
 *****************************************************************************/
void EnableInlineItem(InlineItem *item, S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    item->flags &= ~INLINE_ITEM_DISABLED;
    wgui_inline_items[index].flags &= ~INLINE_ITEM_DISABLED;
}


/*****************************************************************************
 * FUNCTION
 *  DisableInlineItemHighlight
 * DESCRIPTION
 *  Disable inline item's highlight flag
 * PARAMETERS
 *  item        [IN]    inline item's pointer      
 * RETURNS
 *  void
 *****************************************************************************/
void DisableInlineItemHighlight(InlineItem *item)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    item->flags |= INLINE_ITEM_DISABLE_HIGHLIGHT;
}

/* Add this function at W09.47 */
/*****************************************************************************
 * FUNCTION
 *  DisableInlineItemHighlight
 * DESCRIPTION
 *  Disable inline item's highlight flag
 * PARAMETERS
 *  item        [IN]    inline item's pointer      
 * RETURNS
 *  void
 *****************************************************************************/
void EnableInlineItemHighlight(InlineItem *item)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    item->flags &= ~INLINE_ITEM_DISABLE_HIGHLIGHT;
}


/*****************************************************************************
 * FUNCTION
 *  SetInlineItemFullWidth
 * DESCRIPTION
 *  set inline item as full width
 * PARAMETERS
 *  item        [IN]    inline item's pointer     
 * RETURNS
 *  void
 *****************************************************************************/
void SetInlineItemFullWidth(InlineItem *item)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    item->flags |= INLINE_ITEM_LEFT_ALIGN;
}

/*****************************************************************************
 * FUNCTION
 *  ResetInlineItemFullWidth
 * DESCRIPTION
 *  set inline item as full width
 * PARAMETERS
 *  item        [IN]    inline item's pointer     
 * RETURNS
 *  void
 *****************************************************************************/
void ResetInlineItemFullWidth(InlineItem *item)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    item->flags &= ~INLINE_ITEM_LEFT_ALIGN;
}


/*****************************************************************************
 * FUNCTION
 *  LeftJustifyInlineItem
 * DESCRIPTION
 *  set inline item as left justify
 * PARAMETERS
 *  item        [IN]    inline item's pointer    
 * RETURNS
 *  void
 *****************************************************************************/
void LeftJustifyInlineItem(InlineItem *item)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    item->flags &= ~INLINE_ITEM_JUSTIFY_MASK;
    item->flags |= INLINE_ITEM_LEFT_JUSTIFY;
}


/*****************************************************************************
 * FUNCTION
 *  RightJustifyInlineItem
 * DESCRIPTION
 *  set inline item as right justify
 * PARAMETERS
 *  item        [IN]    inline item's pointer      
 * RETURNS
 *  void
 *****************************************************************************/
void RightJustifyInlineItem(InlineItem *item)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    item->flags &= ~INLINE_ITEM_JUSTIFY_MASK;

    /* Inline items will not be shown right justify, when the default text effect
       is enabled, so removed the flag in that case. */
#ifdef __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__
    if (!(IsInlineItemDefaultTextEnable()))
#endif 

      item->flags |= INLINE_ITEM_RIGHT_JUSTIFY;
}


/*****************************************************************************
 * FUNCTION
 *  CenterJustifyInlineItem
 * DESCRIPTION
 *  set inline item as center justify
 * PARAMETERS
 *  item        [IN]    inline item's pointer    
 * RETURNS
 *  void
 *****************************************************************************/
void CenterJustifyInlineItem(InlineItem *item)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    item->flags &= ~INLINE_ITEM_JUSTIFY_MASK;
    item->flags |= INLINE_ITEM_CENTER_JUSTIFY;
}


/*****************************************************************************
 * FUNCTION
 *  DisableInlineItemBoundary
 * DESCRIPTION
 *  Disable inline item boundary
 * PARAMETERS
 *  item        [IN]    inline item's pointer     
 * RETURNS
 *  void
 *****************************************************************************/
void DisableInlineItemBoundary(InlineItem *item)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    item->flags &= ~INLINE_ITEM_BOUNDARY_MASK;
    item->flags |= INLINE_ITEM_BOUNDARY_NEVER;
}


/*****************************************************************************
 * FUNCTION
 *  EnableInlineItemBoundary
 * DESCRIPTION
 *  Enable inline item boundary
 * PARAMETERS
 *  item        [IN]    inline item's pointer  
 * RETURNS
 *  void
 *****************************************************************************/
void EnableInlineItemBoundary(InlineItem *item)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    item->flags &= ~INLINE_ITEM_BOUNDARY_MASK;
    item->flags |= INLINE_ITEM_BOUNDARY_ALWAYS;
}


/*****************************************************************************
 * FUNCTION
 *  SetInlineItemDottedUnderline
 * DESCRIPTION
 *  Set inine item's INLINE_ITEM_DOTTED_UNDERLINE flag
 * PARAMETERS
 *  item        [IN]    inline item's pointer    
 * RETURNS
 *  void
 *****************************************************************************/
void SetInlineItemDottedUnderline(InlineItem *item)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    item->flags |= INLINE_ITEM_DOTTED_UNDERLINE;
}


#if defined(__WGUI_CAT_DATE_YEAR_ONLY__)
/*****************************************************************************
 * FUNCTION
 *  SetInlineItemYearOnly
 * DESCRIPTION
 *  Set inine item's INLINE_ITEM_YEAR_ONLY flag
 * PARAMETERS
 *  item        [IN]    inline item's pointer    
 * RETURNS
 *  void
 *****************************************************************************/
void SetInlineItemYearOnly(InlineItem *item)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    item->flags |= INLINE_ITEM_YEAR_ONLY;
}
#endif /* __WGUI_CAT_DATE_YEAR_ONLY__ */


/*****************************************************************************
 * FUNCTION
 *  wgui_inline_item_key_handler
 * DESCRIPTION
 *  inline item key handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_inline_item_key_handler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#if defined (__MMI_INLINE_ITEM_RADIO__) || defined (__MMI_INLINE_ITEM_CHECKBOX__)        
	U32 flags = 0;
#endif
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();
    wgui_text_menuitem_reset_scrolling();
    gdi_layer_unlock_frame_buffer();
#if defined (__MMI_INLINE_ITEM_RADIO__) || defined (__MMI_INLINE_ITEM_CHECKBOX__)    
	flags = wgui_inline_items[wgui_inline_item_highlighted_index].flags & 0xff;
#endif
#if defined (__MMI_INLINE_ITEM_RADIO__)
	if (flags == INLINE_ITEM_TYPE_RADIO)
	{
        inline_radio_select_handler();
	}
	else
#endif
#if defined (__MMI_INLINE_ITEM_CHECKBOX__)
		if (flags == INLINE_ITEM_TYPE_CHECKBOX)
	{
	    inline_checkbox_lsk_function();
	}
	else
#endif
	{
		wgui_inline_items[wgui_inline_item_highlighted_index].
			handler(
                wgui_inline_item_x,
                wgui_inline_item_y,
                wgui_inline_item_width,
                wgui_inline_item_height,
                wgui_inline_item_key_code,
                wgui_inline_item_key_event,
                &wgui_inline_items [wgui_inline_item_highlighted_index].text_p,
                wgui_inline_items[wgui_inline_item_highlighted_index]. item,
                wgui_inline_items[wgui_inline_item_highlighted_index]. flags,
                wgui_current_history_buffer);
		wgui_current_history_buffer = NULL;
	}
}


/*****************************************************************************
 * FUNCTION
 *  register_inline_item_key_handler
 * DESCRIPTION
 *  register inline item key handler for index(th) item 
 * PARAMETERS
 *  index       [IN]     inline item's index   
 * RETURNS
 *  void
 *****************************************************************************/
void register_inline_item_key_handler(S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_inline_item_highlighted_index = index;
    wgui_inline_item_key_code = wgui_inline_items[index].key_code;
    wgui_inline_item_key_event = wgui_inline_items[index].key_event;
    if (wgui_inline_item_key_code == KEY_LSK)
    {
        SetLeftSoftkeyFunction(wgui_inline_item_key_handler, wgui_inline_item_key_event);
        if(cui_inline_is_current_cui())
        {
            SetCenterSoftkeyFunction(wgui_inline_item_key_handler, wgui_inline_item_key_event);    
        }   
    }
    else if (wgui_inline_item_key_code == KEY_RSK)
    {
        SetRightSoftkeyFunction(wgui_inline_item_key_handler, wgui_inline_item_key_event);
    }
    else
    {
        SetKeyHandler(wgui_inline_item_key_handler, (U16) wgui_inline_item_key_code, (U16) wgui_inline_item_key_event);
    }
}

#ifdef __MMI_FTE_SUPPORT__
static MMI_BOOL g_ssp_redraw = MMI_FALSE;

/*****************************************************************************
 * FUNCTION
 *  wgui_inline_shift_input_cursor
 * DESCRIPTION
 *  adjust cursor position
 * PARAMETERS
 *  first_display       [IN]     the first displayed list item index 
 *  last_display        [IN]     the last displayed list item index
 *  index               [IN]     the current highlighted index
 *  y                   [IN]     the new position
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_inline_shift_input_cursor(S32 first_display, S32 last_display, S32 index, S32 y)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if(UI_BLINKING_CURSOR_SUPPORT)
    if (index == wgui_inline_item_highlighted_index)
    {
        S32 clip_y1, clip_y2;
        
        clip_y1 = MMI_fixed_list_menu.y;
        clip_y2 = MMI_fixed_list_menu.y + MMI_fixed_list_menu.height - 1;

        UI_inputbox_move_cursor(0, y, -1, clip_y1, -1, clip_y2);
    }
    else
    {
        if (wgui_inline_item_highlighted_index < first_display 
            || wgui_inline_item_highlighted_index > last_display)
        {
            UI_inputbox_move_cursor(0, 0, -1, -1, -1, -1);
        }
    }

#endif

}


/*****************************************************************************
 * FUNCTION
 *  wgui_inline_smooth_scrolling_by_pen
 * DESCRIPTION
 *  set whether ssp call this redraw.
 * PARAMETERS
 *  state     [IN]         indicate whether in ssp state
 * RETURNS
 *  void 
 *****************************************************************************/
void wgui_inline_set_ssp_redraw_state(MMI_BOOL state)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_ssp_redraw = state;
}

/*****************************************************************************
 * FUNCTION
 *  wgui_inline_restore_history
 * DESCRIPTION
 *  restore the inline history
 * PARAMETERS
 *  gui_buffer          [OUT]       the gui_buffer history
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_inline_restore_history(U8* gui_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(cui_inline_is_current_cui())
    {
        /*And highlight item of list hisory is invalid when CUI. */
        cui_inline_item_save_gui_buffer(wgui_inline_item_highlighted_index, 
            &wgui_inline_items[wgui_inline_item_highlighted_index],
            (U8*)(gui_buffer));      
    }
    switch (wgui_current_inline_item_type)
    {
        case INLINE_ITEM_TYPE_TEXT_EDIT:
            inline_text_edit_get_history(gui_buffer);
            break;

        case INLINE_ITEM_TYPE_DATE:
#if defined (__MMI_INLINE_ITEM_DATE__)
            inline_date_edit_get_history(gui_buffer);
#endif /* __MMI_INLINE_ITEM_DATE__ */
            break;

        case INLINE_ITEM_TYPE_TIME:
#if defined (__MMI_INLINE_ITEM_TIME__)
            inline_time_edit_get_history(gui_buffer);
#endif /* __MMI_INLINE_ITEM_TIME__ */
            break;

        case INLINE_ITEM_TYPE_TIME_PERIOD:
#if defined (__MMI_INLINE_ITEM_TIME_PEROID__)
            inline_time_period_edit_get_history(gui_buffer);
#endif
            break;

        case INLINE_ITEM_TYPE_IP4_EDIT:
#if defined (__MMI_INLINE_ITEM_IP4__)
            inline_IP4_edit_get_history(gui_buffer);
#endif /* __MMI_INLINE_ITEM_IP4__ */
            break;

#if defined (__MMI_INLINE_ITEM_DOW__)
        case INLINE_ITEM_TYPE_DOW_SELECT:
            inline_DOW_select_change_complete();
            inline_DOW_select_get_history(gui_buffer);
            break;
#endif            

#if defined( __MMI_INLINE_ITEM_MULTILINE_READ_ONLY__) || defined( __MMI_INLINE_ITEM_MULTILINE_EDIT__)
        case INLINE_ITEM_TYPE_MULTI_LINE_EDIT:
        case INLINE_ITEM_TYPE_MULTI_LINE_RD_ONLY:
            inline_multi_line_edit_get_history(gui_buffer);
            break;
#endif            
        
        default:
            return;
    }
    
    
    wgui_current_history_buffer = gui_buffer;
}
#endif


/*****************************************************************************
 * FUNCTION
 *  wgui_inline_edit_menuitem_adjust_layout
 * DESCRIPTION
 *  fte layout is not special
 * PARAMETERS
 *  
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_inline_edit_menuitem_adjust_layout(S32 item_index, S32 *x_p, S32 *y_p, S32 *width_p, S32 *height_p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x, y, width, height;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    x = *x_p;
    y = *y_p;
    width = *width_p;
    height = *height_p;
    
#ifdef __MMI_FTE_SUPPORT__
    width = width - INLINE_FTE_SCROLL_BAR_WIDTH ;
    if(INLINE_GET_ITEM_TYPE(item_index) != INLINE_ITEM_TYPE_CAPTION)
    {
        if((INLINE_GET_ITEM_TYPE(item_index) != INLINE_ITEM_TYPE_MULTI_LINE_EDIT) &&
            (INLINE_GET_ITEM_TYPE(item_index) != INLINE_ITEM_TYPE_MULTI_LINE_RD_ONLY))
        {
            y = y + INLINE_FTE_CONTROL_VERTICAL_GAP(height);
            height = INLINE_FTE_CONTROL_HEIGHT;
        }
        else
        {
            y = y + INLINE_FTE_CONTROL_VERTICAL_GAP(INLINE_FTE_ONE_LINE_HEIGHT);
            height -= 2 * INLINE_FTE_CONTROL_VERTICAL_GAP(INLINE_FTE_ONE_LINE_HEIGHT);
        }
    }
    if(wgui_inline_items[item_index].side_img !=NULL)
    {
        if(mmi_fe_get_r2l_state() == 0)
        {
            x += INLINE_FTE_ICON_SIZE + INLINE_FTE_ICON_CONTROL_GAP + INLINE_FTE_LEFT_GAP; 
            width -= x + 1;
        }
        else
        {
            x += INLINE_FTE_SCROLL_BAR_WIDTH;
            width = width -  (INLINE_FTE_ICON_SIZE + INLINE_FTE_ICON_CONTROL_GAP + INLINE_FTE_LEFT_GAP);
        }
    }
    else
    {
        if(mmi_fe_get_r2l_state() == 0)
        {
            x += INLINE_FTE_ICON_CONTROL_GAP + INLINE_FTE_LEFT_GAP;
            width -= x + 1;
        }
        else
        {
            x += INLINE_FTE_SCROLL_BAR_WIDTH;
            width = width -  (INLINE_FTE_ICON_CONTROL_GAP + INLINE_FTE_LEFT_GAP);
        }
    }
#endif
    *x_p = x;
    *y_p = y;
    *width_p = width;
    *height_p = height;
}


/*****************************************************************************
 * FUNCTION
 *  handle_inline_item_common_location
 * DESCRIPTION
 *  handle inline common item's location
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void handle_inline_item_common_location(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables												  */
    /*----------------------------------------------------------------*/
    S32 index = wgui_inline_item_highlighted_index;
    
    /*----------------------------------------------------------------*/
    /* Code Body													  */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();
    wgui_text_menuitem_reset_scrolling = gui_fixed_icontext_menuitem_stop_scroll;
    wgui_text_menuitem_restart_scrolling = gui_fixed_icontext_menuitem_start_scroll;
    if (((wgui_inline_items[index].flags & 0xff) != INLINE_ITEM_TYPE_DISPLAY_ONLY)
        && ((wgui_inline_items[index].flags & 0xff) != INLINE_ITEM_TYPE_BUTTON))
    {
        wgui_text_menuitem_reset_scrolling();
    }
    wgui_inline_items[index].handler(
        wgui_inline_item_x,
        wgui_inline_item_y,
        wgui_inline_item_width,
        wgui_inline_item_height,
        wgui_inline_items[index].key_code,
        wgui_inline_items[index].key_event,
        &wgui_inline_items[index].text_p,
        wgui_inline_items[index].item,
        wgui_inline_items[index].flags,
        wgui_current_history_buffer);
    wgui_current_history_buffer = NULL;
    gdi_layer_unlock_frame_buffer();
}


/*****************************************************************************
 * FUNCTION
 *  handle_inline_item_image_text_location
 * DESCRIPTION
 *  handle inline image text item's location
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
#if defined (__MMI_INLINE_ITEM_IMAGETEXT__)
static void handle_inline_item_image_text_location(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables												  */
    /*----------------------------------------------------------------*/
    S32 index = wgui_inline_item_highlighted_index;
    
    /*----------------------------------------------------------------*/
    /* Code Body													  */
    /*----------------------------------------------------------------*/
    wgui_text_menuitem_reset_scrolling();
    inline_image_text_set_history(INLINE_IMAGE_TEXT_HISTORY_ID, wgui_current_history_buffer);
    if (inline_image_text_edit_flag == 1)
    {
        wgui_inline_items[index].handler(
            wgui_inline_item_x,
            wgui_inline_item_y,
            wgui_inline_item_width,
            wgui_inline_item_height,
            wgui_inline_items[index].key_code,
            wgui_inline_items[index].key_event,
            &wgui_inline_items[index].text_p,
            wgui_inline_items[index].item,
            wgui_inline_items[index].flags,
            wgui_current_history_buffer);
        wgui_current_history_buffer = NULL; /* 112105 inline Calvin added */
    }
    else
    {
        if ((wgui_inline_items[index].flags & INLINE_ITEM_DISABLE_HIGHLIGHT))
        {
            gui_draw_filled_area(
                wgui_inline_item_x + 17,
                wgui_inline_item_y,
                (wgui_inline_item_x + wgui_inline_item_width - 1),
                (wgui_inline_item_y + wgui_inline_item_height - 1),
                (wgui_inline_select_fixed_text_menuitem_theme.selected_filler));
        }
        
        wgui_show_image_text_item_highlight(
            wgui_inline_item_x,
            wgui_inline_item_y,
            wgui_inline_item_width,
            wgui_inline_item_height,
            &wgui_inline_items[index]);
        register_left_softkey_handler();
        register_inline_item_key_handler(index);
    }

}
#endif


/*****************************************************************************
 * FUNCTION
 *  handle_inline_item_full_screen_location
 * DESCRIPTION
 *  handle inline full screen item's location
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void handle_inline_item_full_screen_location(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables												  */
    /*----------------------------------------------------------------*/
    S32 index = wgui_inline_item_highlighted_index;
    
    /*----------------------------------------------------------------*/
    /* Code Body													  */
    /*----------------------------------------------------------------*/
    if (wgui_inline_items[index].flags & INLINE_ITEM_OPEN)
    {
        gdi_layer_lock_frame_buffer();
        wgui_text_menuitem_reset_scrolling = gui_fixed_icontext_menuitem_stop_scroll;
        wgui_text_menuitem_restart_scrolling = gui_fixed_icontext_menuitem_start_scroll;
        wgui_text_menuitem_reset_scrolling();
        wgui_inline_items[index].handler(
            wgui_inline_item_x,
            wgui_inline_item_y,
            wgui_inline_item_width,
            wgui_inline_item_height,
            wgui_inline_items[index].key_code,
            wgui_inline_items[index].key_event,
            &wgui_inline_items[index].text_p,
            wgui_inline_items[index].item,
            wgui_inline_items[index].flags,
            wgui_current_history_buffer);
        wgui_inline_items[index].flags &= ~INLINE_ITEM_OPEN;
        wgui_current_history_buffer = NULL;
        gdi_layer_unlock_frame_buffer();
    }
    else
    {
    #ifdef __MMI_FTE_SUPPORT__
        wgui_show_inline_fte_displayonly_item_highlight(
            wgui_inline_item_x,
            wgui_inline_item_y,
            wgui_inline_item_width,
            wgui_inline_item_height,
            &wgui_inline_items[index]);
    #endif

        if (wgui_inline_items[index].key_code == KEY_LSK)
        {
            register_left_softkey_handler();
            register_inline_item_key_handler(index);
            
            if(cui_inline_is_current_cui())
            {
                register_softkey_handler(MMI_CENTER_SOFTKEY);
                set_softkey_function(wgui_inline_item_key_handler, KEY_EVENT_UP, MMI_CENTER_SOFTKEY);
                mmi_imc_key_setup_csk_function(wgui_inline_item_key_handler);
            }
        }
    }
}



/*****************************************************************************
 * FUNCTION
 *  wgui_inline_redraw_softkey
 * DESCRIPTION
 *  This function is special for redraw softkey for performance
 *  and we hope to draw background once
 *  and sometime, center softkey is not drawed, but we hope to draw center softkey background
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_inline_redraw_softkeys(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables												  */
    /*----------------------------------------------------------------*/
    U32 flags = 0;
    
    /*----------------------------------------------------------------*/
    /* Code Body													  */
    /*----------------------------------------------------------------*/
#if defined(__MMI_IME_FTE_ENHANCE__) && defined(__MMI_VIRTUAL_KEYBOARD__)
    if (mmi_imc_get_ui_style(MMI_IMC_UI_STYLE_VK_ON) && !mmi_imc_is_vk_disabled())
    {
        redraw_left_softkey();
        redraw_center_softkey();
        redraw_right_softkey();
        return ;
    }
#endif
    show_softkey_background();
    flags = MMI_softkeys[MMI_LEFT_SOFTKEY].flags;
    MMI_softkeys[MMI_LEFT_SOFTKEY].flags |= UI_BUTTON_DISABLE_BACKGND_DISPLAY;
    redraw_left_softkey();
    MMI_softkeys[MMI_LEFT_SOFTKEY].flags = flags;
    flags = MMI_softkeys[MMI_CENTER_SOFTKEY].flags;
    MMI_softkeys[MMI_CENTER_SOFTKEY].flags |= UI_BUTTON_DISABLE_BACKGND_DISPLAY;
    redraw_center_softkey();
    MMI_softkeys[MMI_CENTER_SOFTKEY].flags = flags;
    flags = MMI_softkeys[MMI_RIGHT_SOFTKEY].flags;
    MMI_softkeys[MMI_RIGHT_SOFTKEY].flags |= UI_BUTTON_DISABLE_BACKGND_DISPLAY;
    redraw_right_softkey();
    MMI_softkeys[MMI_RIGHT_SOFTKEY].flags = flags;
}


/*****************************************************************************
 * FUNCTION
 *  handle_inline_item_location
 * DESCRIPTION
 *  handle inline item's location
 * PARAMETERS
 *  x           [IN]        left corner's x coordinate
 *  y           [IN]        left corner's y coordinate
 *  width       [IN]        width
 *  height      [IN]        height
 * RETURNS
 *  void
 *****************************************************************************/
void handle_inline_item_location(S32 x, S32 y, S32 width, S32 height)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 item_index, item_type = 0;
	MMI_BOOL Is_full_screen_not_open = MMI_TRUE;

#ifdef __MMI_FTE_SUPPORT__
    U8 gui_buffer[MAX_GUI_BUFFER];
#endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (wgui_inline_item_handled)
    {
#ifdef __MMI_FTE_SUPPORT__
        if (!g_ssp_redraw)
#endif
        return;
    }  

#ifdef __MMI_FTE_SUPPORT__
     if (wgui_inline_item_handled && g_ssp_redraw)
     {
         mmi_imc_config_draw(MMI_TRUE);

         wgui_inline_restore_history(gui_buffer);
     }
    
    g_ssp_redraw = (MMI_BOOL)0;
#endif

    wgui_inline_edit_menuitem_adjust_layout(wgui_inline_item_highlighted_index, &x, &y, &width, &height);

    wgui_inline_item_handled = 1;
    wgui_inline_item_x = x;
    wgui_inline_item_y = y;
    wgui_inline_item_width = width;
    wgui_inline_item_height = height;
    item_index = wgui_inline_item_highlighted_index;

    item_type = wgui_inline_items[item_index].flags & INLINE_ITEM_TYPE_MASK;
    if (wgui_inline_items[item_index].key_code == INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT)
    {
        if (item_type == INLINE_ITEM_TYPE_FULL_SCREEN_EDIT)
        {
            if (wgui_inline_items[item_index].flags & INLINE_ITEM_OPEN)
            {
                Is_full_screen_not_open = MMI_FALSE;
            }
            handle_inline_item_full_screen_location();
        }
        else
        {
            handle_inline_item_common_location();
        }
    }
    else
    {
#ifdef __MMI_INLINE_ITEM_IMAGETEXT__
		if (item_type == INLINE_ITEM_IMAGE_TEXT_TYPE)
        {
            handle_inline_item_image_text_location();
        }
        else
#endif		
#if defined(__MMI_INLINE_ITEM_RADIO__) || defined(__MMI_INLINE_ITEM_CHECKBOX__)
			if ((item_type == INLINE_ITEM_TYPE_RADIO) || (item_type == INLINE_ITEM_TYPE_CHECKBOX))
        {
            handle_inline_item_common_location();
            register_left_softkey_handler();
            register_inline_item_key_handler(item_index);
        }
        else
#endif			
        {
            if (wgui_inline_items[item_index].flags & INLINE_ITEM_OPEN)
            {
                Is_full_screen_not_open = MMI_FALSE;
            }
            handle_inline_item_full_screen_location();
        }
    }

    if(cui_inline_is_current_cui())
    {
        if ((item_type != INLINE_ITEM_TYPE_FULL_SCREEN_EDIT)
#ifdef 	__MMI_INLINE_ITEM_RADIO__		
			&& (item_type != INLINE_ITEM_TYPE_RADIO)
#endif
#ifdef __MMI_INLINE_ITEM_CHECKBOX__
			&& (item_type != INLINE_ITEM_TYPE_CHECKBOX)
#endif			
			)
        {
		    cui_inline_lock_draw_softkey(MMI_TRUE);
		    cui_inline_replace_item_softkey_by_app(item_index);
			cui_inline_lock_draw_softkey(MMI_FALSE);
        }
        cui_inline_register_csk_handler();
        cui_inline_evt_set_key();
    }   

    if ((wgui_inline_list_menu_rsk_back)
		|| (item_type == INLINE_ITEM_TYPE_FULL_SCREEN_EDIT)
#ifdef 	__MMI_INLINE_ITEM_RADIO__				
		|| (item_type == INLINE_ITEM_TYPE_RADIO)
#endif		
#ifdef __MMI_INLINE_ITEM_CHECKBOX__		
		|| (item_type == INLINE_ITEM_TYPE_CHECKBOX)
#endif		
		|| (item_type == INLINE_ITEM_TYPE_TEXT_EDIT
			&& (cui_inline_is_current_cui() && (!cui_inline_is_item_lsk_by_app(item_index))))
		)
    {
        if (Is_full_screen_not_open == MMI_TRUE)
        {
            wgui_inline_option_handler_for_lsk();
        }
    }

#ifdef __MMI_FTE_SUPPORT__
    mmi_imc_config_draw(MMI_FALSE);
#endif

    wgui_inline_redraw_softkeys();
}


/*****************************************************************************
 * FUNCTION
 *  GetInlineDoneFlag
 * DESCRIPTION
 *  get inline Done flag from history buffer
 * PARAMETERS
 *  history_buffer      [IN]      history buffer
 * RETURNS
 *  DoneFlag
 *****************************************************************************/
U8 GetInlineDoneFlag(U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 *flags;
    S32 s = sizeof(list_menu_category_history);

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    s = (s + 3) / 4;
    s *= 4;
    if (history_buffer == NULL)
    {
        return (0);
    }
    flags = (U32*) (history_buffer + s);
    if (*flags)
    {
        return (1);
    }
    else
    {
        return (0);
    }
}


/*****************************************************************************
 * FUNCTION
 *  SetInlineDoneFlag
 * DESCRIPTION
 *  Set inline Done flag into history buffer
 * PARAMETERS
 *  history_buffer      [IN/OUT]     history buffer
 * RETURNS
 *  void
 *****************************************************************************/
void SetInlineDoneFlag(U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 *flags;
    S32 s = sizeof(list_menu_category_history);

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    s = (s + 3) / 4;
    s *= 4;
    if (history_buffer == NULL)
    {
        return;
    }
    flags = (U32*) (history_buffer + s);
    *flags = 1;
}


/*****************************************************************************
 * FUNCTION
 *  ResetInlineDoneFlag
 * DESCRIPTION
 *  Rest inline Done flag in history buffer
 * PARAMETERS
 *  history_buffer      [IN/OUT]   history buffer     
 * RETURNS
 *  void
 *****************************************************************************/
void ResetInlineDoneFlag(U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 *flags;
    S32 s = sizeof(list_menu_category_history);

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    s = (s + 3) / 4;
    s *= 4;
    if (history_buffer == NULL)
    {
        return;
    }
    flags = (U32*) (history_buffer + s);
    *flags = 0;
}


/***************************************************************************** 
 * Inline Display Only   
 *
 * This is Display Only Inline Item
 *****************************************************************************/

/***************************************************************************** 
 * Function Implementation
 *****************************************************************************/
 
/*****************************************************************************
 * FUNCTION
 *  wgui_inline_display_only_close
 * DESCRIPTION
 *  close function of inline display only item.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_inline_display_only_close(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    complete_inline_item_edit = UI_dummy_function;
#ifdef  __MMI_FTE_SUPPORT__    
    gui_scrolling_text_stop(&wgui_inline_scroll_text);
    clear_inline_item_keys = UI_dummy_function;
    memset(&wgui_inline_scroll_text, 0, sizeof(wgui_inline_scroll_text));
#endif
}


/*****************************************************************************
 * FUNCTION
 *  handle_inline_display_only
 * DESCRIPTION
 *  activation function of inline display only
 * PARAMETERS
 *  x                   [IN]        left corner's x coordinate
 *  y                   [IN]        left corner's y coordinate
 *  width               [IN]        width
 *  height              [IN]        height
 *  key_code            [IN]        key code
 *  key_event           [IN]        key event
 *  text_p              [IN]        text pointer
 *  item                [IN]        inline item
 *  flags               [IN]        flags
 *  history_buffer      [IN]        history buffer
 * RETURNS
 *  void
 *****************************************************************************/
void handle_inline_display_only(
        S32 x,
        S32 y,
        S32 width,
        S32 height,
        S32 key_code,
        S32 key_event,
        U8 **text_p,
        void *item,
        U32 flags,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#ifdef __MMI_INLINE_HIGHLIGHT_CAPTION__
    S32 left_x = 0, right_x= 0;
    S32 left_text_x= 0, right_text_x = 0;
    S32 text_width = 0, text_height = 0;
    UI_font_type ft = {0};
    color text_colr = gui_color(0, 0, 0);
#endif
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_INLINE_HIGHLIGHT_CAPTION__

    left_x = x + MMI_fixed_icontext_menuitem.text_x ;
    right_x = x + width - 1;

    ft = current_single_line_input_box_theme->text_font;
    gui_set_font(ft);
    text_colr = MMI_fixed_icontext_menuitem.normal_text_color;
    gui_set_text_color(text_colr);  
    Get_StringWidthHeight(*text_p, &text_width, &text_height);

#else
    UI_UNUSED_PARAMETER(x);
    UI_UNUSED_PARAMETER(y);
    UI_UNUSED_PARAMETER(height);
    UI_UNUSED_PARAMETER(width);
    UI_UNUSED_PARAMETER(key_code);
    UI_UNUSED_PARAMETER(key_event);
    UI_UNUSED_PARAMETER(text_p);
    UI_UNUSED_PARAMETER(item);
    UI_UNUSED_PARAMETER(flags);
#endif

#ifdef  __MMI_FTE_SUPPORT__
    wgui_show_inline_fte_displayonly_item_highlight(
        x,
        y,
        width,
        height,
        &wgui_inline_items[wgui_inline_item_highlighted_index]);
#else
    if(flags & INLINE_ITEM_RIGHT_JUSTIFY)
    {
        U32 temp_flags = wgui_inline_items[MMI_fixed_list_menu.highlighted_item].flags;
        UI_single_line_input_box_theme temp_theme = wgui_inline_singleline_inputbox_unfocussed_theme;
        wgui_inline_singleline_inputbox_unfocussed_theme = wgui_inline_singleline_inputbox_focussed_theme;
        wgui_inline_items[MMI_fixed_list_menu.highlighted_item].flags |= INLINE_ITEM_BOUNDARY_ALWAYS;
        wgui_show_inline_text_edit_list_menuitem(x,
                                            y,
                                            width,
                                            height,
                                            &wgui_inline_items[MMI_fixed_list_menu.highlighted_item]);
        wgui_inline_items[MMI_fixed_list_menu.highlighted_item].flags = temp_flags;
        wgui_inline_singleline_inputbox_unfocussed_theme = temp_theme;
    }
#ifdef __MMI_INLINE_HIGHLIGHT_CAPTION__
	else
	{
	    if(mmi_fe_get_r2l_state())
        {
            right_text_x = right_x;
            gui_move_text_cursor(right_text_x, y + (height - text_height)/2);
            gui_print_text((UI_string_type)(*text_p));
        }
        else
        {
            left_text_x = left_x;
            gui_move_text_cursor(left_text_x, y + (height - text_height)/2);
            gui_print_text((UI_string_type)(*text_p));
        }
	}
#endif
#endif
    complete_inline_item_edit = wgui_inline_display_only_close;
    register_inline_fixed_list_keys();
}

#ifdef __MMI_FTE_SUPPORT__

extern UI_single_line_input_box_theme wgui_inline_singleline_inputbox_focussed_theme;

/*****************************************************************************
 * FUNCTION
 *  wgui_show_inline_fte_displayonly_item_unhighlight
 * DESCRIPTION
 *  display the inline display_only item in unhighlighted status
 * PARAMETERS
 *  x                   [IN]        left corner's x coordinate
 *  y                   [IN]        left corner's y coordinate
 *  width               [IN]        width
 *  height              [IN]        height
 *  item                [IN]        inline item
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_show_inline_fte_displayonly_item_unhighlight(
                S32 x,
                S32 y,
                S32 width,
                S32 height,
                wgui_inline_item *item)
{
   
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_show_inline_fte_displayonly_item_unhighlight_ext(
        x,
        y,
        width,
        height,
        item,
        0);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_show_inline_fte_displayonly_item_unhighlight_ext
 * DESCRIPTION
 *  activation function of inline display only
 * PARAMETERS
 *  x                   [IN]        left corner's x coordinate
 *  y                   [IN]        left corner's y coordinate
 *  width               [IN]        width
 *  height              [IN]        height
 *  item                [IN]        inline item
 *  status_flag         [IN]
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_show_inline_fte_displayonly_item_unhighlight_ext(
                S32 x,
                S32 y,
                S32 width,
                S32 height,
                wgui_inline_item *item,
                U8 status_flag)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 left_text_x= 0;
    S32 text_width = 0, text_height = 0;
    UI_font_type ft = {0};
    color text_colr = gui_color(0, 0, 0);
    U8 * image = NULL;
    UI_filled_area *bg_filler = NULL;
    gdi_handle act_layer;
  
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_inline_item_text_edit *i = (wgui_inline_item_text_edit *)item->item;
    i->x = x;
    i->y = y;
    i->width = width;
    i->height = height;
    i->status_flag = status_flag;
    
    gdi_layer_push_clip();
    gdi_layer_get_active(&act_layer);
    
    if (MMI_fixed_list_menu.act_layer_handle == act_layer)
    {
        gdi_layer_set_clip(
        MMI_fixed_list_menu.x, 
        MMI_fixed_list_menu.y, 
        MMI_fixed_list_menu.x + MMI_fixed_list_menu.width - 1,
        MMI_fixed_list_menu.y + MMI_fixed_list_menu.height - 1);
        gui_set_clip_preset(x, y, x + width - 1, y + height - 1);
    }
    else
    {
        gui_set_clip(x, y, x + width - 1, y + height - 1);
    }

    if(item->flags & INLINE_ITEM_DISPLAY_ONLY_SHOW)
    {
        image = (U8*) GetImage(IMG_INLINE_DISPLAY_ONLY_NORMAL_BG);
        gdi_image_draw_resized(x, y, width, height, image);
    }
    else
    {
        if(status_flag == 0)
        {
            bg_filler = current_MMI_theme->inline_item_button_unhighlighted_normal_bg_filler;     
        }
        else
        {
            bg_filler = current_MMI_theme->inline_item_button_unhighlighted_pressed_bg_filler;       
        }

        gui_draw_filled_area(x, y, x + width - 1, y + height - 1, bg_filler);
    }

    
    ft = wgui_inline_singleline_inputbox_focussed_theme.text_font;
    gui_set_font(ft);
    text_colr = wgui_inline_singleline_inputbox_focussed_theme.normal_text_color;
    gui_set_text_color(text_colr);  
    Get_StringWidthHeight(item->text_p, &text_width, &text_height);
    
    if(text_width > (width - INLINE_FTE_BUTTON_RIGHT_BOUNDARY - INLINE_FTE_SINGLELINE_TEXT_OFFSET))
    {
        text_width = width - INLINE_FTE_BUTTON_RIGHT_BOUNDARY - INLINE_FTE_SINGLELINE_TEXT_OFFSET;
    }
    
    if(mmi_fe_get_r2l_state() == 0)
    {
        left_text_x = x + INLINE_FTE_SINGLELINE_TEXT_OFFSET;
        gui_print_truncated_text(left_text_x, y + (height - text_height)/2, text_width, (UI_string_type)(item->text_p));
    }
    else if(mmi_fe_get_r2l_state() == 1)
    {
        S32 right_text_x = x + (width - INLINE_FTE_BUTTON_RIGHT_BOUNDARY);
        gui_print_truncated_text(right_text_x, y + (height - text_height)/2, text_width, (UI_string_type)(item->text_p));
    }
       

    gdi_layer_blt_previous(x, y, x + width, y + height);
    gdi_layer_pop_clip();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_show_inline_fte_displayonly_item_highlight
 * DESCRIPTION
 *  highlight function of inline display only and fullscreen edit
 * PARAMETERS

 * RETURNS
 *  void
 *****************************************************************************/
void wgui_show_inline_fte_displayonly_item_highlight(
                S32 x,
                S32 y,
                S32 width,
                S32 height,
                wgui_inline_item *item)
{
   
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    wgui_show_inline_fte_displayonly_item_highlight_ext(
                x,
                y,
                width,
                height,
                item,
                0);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_show_inline_fte_displayonly_item_highlight_ext
 * DESCRIPTION
 *  highlight function of inline display only and fullscreen edit
 * PARAMETERS

 * RETURNS
 *  void
 *****************************************************************************/
void wgui_show_inline_fte_displayonly_item_highlight_ext(
                S32 x,
                S32 y,
                S32 width,
                S32 height,
                wgui_inline_item *item,
                U8 status_flag)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 left_text_x= 0;
    S32 text_width = 0, text_height = 0;
    UI_font_type ft = {0};
    color text_colr = gui_color(0, 0, 0);
    U8 * image = NULL;
    UI_filled_area *bg_filler = NULL;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    wgui_inline_item_text_edit *i = (wgui_inline_item_text_edit *)item->item;
    i->x = x;
    i->y = y;
    i->width = width;
    i->height = height;
    i->status_flag = status_flag;
    clear_inline_item_keys = wgui_inline_display_only_close;
    if((item->flags & INLINE_ITEM_DISPLAY_ONLY_SHOW))
    {
        image = (U8*) GetImage(IMG_INLINE_DISPLAY_ONLY_HIGHLIGHT_BG);
        gdi_image_draw_resized(x, y, width, height, image);
    }
    else 
    {
        if(status_flag == 0)
        {
            bg_filler = current_MMI_theme->inline_item_button_highlighted_normal_bg_filler;     
        }
        else
        {
            bg_filler = current_MMI_theme->inline_item_button_highlighted_pressed_bg_filler;       
        }

        gui_draw_filled_area(x, y, x + width - 1, y + height - 1, bg_filler);
    }
    
    ft = wgui_inline_singleline_inputbox_focussed_theme.text_font;
    gui_set_font(ft);
    text_colr = wgui_inline_singleline_inputbox_focussed_theme.normal_text_color;
    gui_set_text_color(text_colr);  
    
    Get_StringWidthHeight(item->text_p, &text_width, &text_height);
    left_text_x = x + INLINE_FTE_SINGLELINE_TEXT_OFFSET;
    if((text_width > (width - INLINE_FTE_BUTTON_RIGHT_BOUNDARY - INLINE_FTE_SINGLELINE_TEXT_OFFSET)))
    {
        text_width = width - INLINE_FTE_BUTTON_RIGHT_BOUNDARY - INLINE_FTE_SINGLELINE_TEXT_OFFSET;
        gui_create_scrolling_text(&wgui_inline_scroll_text, left_text_x, y + (height - text_height)/2, text_width, text_height, (UI_string_type)(item->text_p), wgui_inlinescrolling_timer, wgui_scrolling_text_draw_background, text_colr, text_colr);
        gui_show_scrolling_text(&wgui_inline_scroll_text);
    }
    else
    {
        if(mmi_fe_get_r2l_state() == 0)
        {      
            gui_move_text_cursor(left_text_x, y + (height - text_height)/2);
            gui_print_text((UI_string_type)(item->text_p));
        }
        else if(mmi_fe_get_r2l_state() == 1)
        {
            S32 right_text_x = x + (width - INLINE_FTE_BUTTON_RIGHT_BOUNDARY);
            gui_move_text_cursor(right_text_x, y + (height - text_height)/2);
            gui_print_text((UI_string_type)(item->text_p)); 
        }
    }
    gdi_layer_blt_previous(x, y, x + width, y + height);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_show_inline_fte_caption_item
 * DESCRIPTION
 *  highlight function of inline caption
 * PARAMETERS

 * RETURNS
 *  void
 *****************************************************************************/
extern void wgui_show_inline_fte_caption_item(
                S32 x,
                S32 y,
                S32 width,
                S32 height,
                wgui_inline_item *item)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 text_x= 0;
    S32 text_width = 0, text_height = 0;
    UI_font_type ft = {0};
    color text_colr = gui_color(0, 0, 0);
#if defined(__MMI_PHB_PHOTO_STICKER_SUPPORT__)
    wgui_inline_item_caption_tn *i;
    Caption_thumbnail_struct *thumbnail_struct;
    S32 clip_x1, clip_x2, clip_y1, clip_y2;
	MMI_BOOL IsThumbnail = MMI_FALSE;
	S32 i_width, i_height;
	S32 prev_clip_x1, prev_clip_x2, prev_clip_y1, prev_clip_y2;
#endif /* __MMI_PHB_PHOTO_STICKER_SUPPORT__ */
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    
    ft = current_single_line_input_box_theme->text_font;
    gui_set_font(ft);
    text_colr = MMI_fixed_icontext_menuitem.normal_text_color;
    gui_set_text_color(text_colr);  
    Get_StringWidthHeight(item->text_p, &text_width, &text_height);
    
#if !defined(__MMI_PHB_PHOTO_STICKER_SUPPORT__)
    if(mmi_fe_get_r2l_state() == 0)
    {
        text_x = x + INLINE_FTE_SINGLELINE_TEXT_OFFSET;
		gui_print_truncated_text(text_x, y + (height - text_height) - 2, width - INLINE_FTE_SINGLELINE_TEXT_OFFSET, (UI_string_type)(item->text_p));
    }
    else if(mmi_fe_get_r2l_state() == 1)
    {
        text_x = x + width - 1 -  INLINE_FTE_SINGLELINE_TEXT_OFFSET;
		gui_print_truncated_text(text_x, y + (height - text_height) - 2, width - INLINE_FTE_SINGLELINE_TEXT_OFFSET, (UI_string_type)(item->text_p));
    }
#else /* __MMI_PHB_PHOTO_STICKER_SUPPORT__ */
    i = item->item;
    if (i)
    {	
        if (mmi_fe_get_r2l_state() == 0)
        {
        #if defined(__MMI_FTE_SUPPORT__)
			width += x - 1;
		#endif /* __MMI_FTE_SUPPORT__ */
            clip_x1 = x + INLINE_FTE_SINGLELINE_TEXT_OFFSET;
            clip_x2 = width - INLINE_FTE_CAPTION_THUMBNAIL_WIDTH - 1;
            text_x = clip_x1;
        }
        else if (mmi_fe_get_r2l_state() == 1)
        {
        #if defined(__MMI_FTE_SUPPORT__)
            if(wgui_inline_items[MMI_fixed_list_menu.current_displayed_item].side_img !=NULL)
            {
				width += INLINE_FTE_ICON_SIZE + INLINE_FTE_ICON_CONTROL_GAP + INLINE_FTE_LEFT_GAP;
            }
			else
			{
			    width += INLINE_FTE_ICON_CONTROL_GAP + INLINE_FTE_LEFT_GAP;
			}
		#endif /* __MMI_FTE_SUPPORT__ */
            clip_x1 = x + INLINE_FTE_CAPTION_THUMBNAIL_WIDTH + 1;
            clip_x2 = x + width - 1 - INLINE_FTE_SINGLELINE_TEXT_OFFSET;
			text_x = clip_x2;
		#if defined(__MMI_FTE_SUPPORT__)
			if (mmi_fe_get_r2l_state() == 1)
			{
				if(wgui_inline_items[MMI_fixed_list_menu.current_displayed_item].side_img !=NULL)
				{
					text_x -= INLINE_FTE_ICON_SIZE + INLINE_FTE_ICON_CONTROL_GAP + INLINE_FTE_LEFT_GAP;
				}
				else
				{
					text_x -= INLINE_FTE_ICON_CONTROL_GAP + INLINE_FTE_LEFT_GAP;
				}
			}
		#endif /* __MMI_FTE_SUPPORT__ */
        }
        clip_y1 = y + (height - INLINE_FTE_CAPTION_THUMBNAIL_HEIGHT)/2;
        clip_y2 = clip_y1 + INLINE_FTE_CAPTION_THUMBNAIL_HEIGHT;
        gui_push_clip();
        gui_set_clip_preset(clip_x1, clip_y1, clip_x2, clip_y2);
		gui_print_truncated_text(text_x, clip_y1, (clip_x2 - clip_x1), (UI_string_type)(item->text_p));
        gui_pop_clip();

		thumbnail_struct = i->thumbnail_struct;
		i_width = i_height = 0;
		if ((thumbnail_struct) && (thumbnail_struct->thumbnail_path))
		{
	        IsThumbnail = MMI_TRUE;
			if (thumbnail_struct->IsSuccessed)
			{
				if (thumbnail_struct->width > INLINE_FTE_CAPTION_THUMBNAIL_WIDTH)
				{
					thumbnail_struct->width = INLINE_FTE_CAPTION_THUMBNAIL_WIDTH;
				}
				if (thumbnail_struct->height > INLINE_FTE_CAPTION_THUMBNAIL_HEIGHT)
				{
					thumbnail_struct->height = INLINE_FTE_CAPTION_THUMBNAIL_HEIGHT;
				}
				if (thumbnail_struct->x1 < 0)
				{
					thumbnail_struct->x1 = 0;
				}
				if (thumbnail_struct->y1 < 0)
				{
					thumbnail_struct->y1 = 0;
				}
				i_width = thumbnail_struct->width;
				i_height = thumbnail_struct->height;
			}
			else
			{
			    gui_measure_image(get_image(i->default_id), &i_width, &i_height);
			}
		}

		if (IsThumbnail == MMI_FALSE)
		{
		    gui_measure_image(get_image(i->default_id), &i_width, &i_height);
		}
        
        if (mmi_fe_get_r2l_state() == 0)
        {
            clip_x2 = clip_x2 + INLINE_FTE_CAPTION_THUMBNAIL_WIDTH - 1;
			clip_x1 = clip_x2 - i_width;
        }
        else if (mmi_fe_get_r2l_state() == 1)
        {
            clip_x2 = x + INLINE_FTE_CAPTION_THUMBNAIL_WIDTH + 1;
			clip_x1 = x + 1;
        }
        clip_y1 = y + (height - i_height)/2;
        clip_y2 = clip_y1 + i_height;
        gui_push_clip();
        gui_set_clip_preset(clip_x1, clip_y1, clip_x2, clip_y2);
		gui_get_clip(&prev_clip_x1, &prev_clip_y1, &prev_clip_x2, &prev_clip_y2);
		gdi_draw_solid_rect(clip_x1, clip_y1, clip_x2, clip_y2, GDI_COLOR_TRANSPARENT);
		if (IsThumbnail)
		{
		    if (thumbnail_struct->IsFinished)
		    {
		        if (thumbnail_struct->IsSuccessed)
		        {
					gdi_handle act_layer;
					
					gdi_layer_get_active(&act_layer);
					/* For matrix */
					gd_bitblt[gdi_act_layer->cf](
						gdi_act_layer->buf_ptr,
						gdi_act_layer->width, gdi_act_layer->height,
						clip_x1, clip_y1, clip_x2, clip_y2,
						thumbnail_struct->t_buffer,
						INLINE_FTE_CAPTION_THUMBNAIL_WIDTH, INLINE_FTE_CAPTION_THUMBNAIL_HEIGHT,
						thumbnail_struct->x1,
						thumbnail_struct->y1,
						thumbnail_struct->width - 1,
						thumbnail_struct->height - 1,
						prev_clip_x1, prev_clip_y1, prev_clip_x2, prev_clip_y2,
						0x01FFFFFF, 0x01FFFFFF);			
		        }
				else
				{
				    gdi_image_draw_id(clip_x1, clip_y1, i->default_id);
				}
		    }
		}
		else
		{
		    gdi_image_draw_id(clip_x1, clip_y1, i->default_id);
		}
        gui_pop_clip();
    }
    else
    {
        if(mmi_fe_get_r2l_state() == 0)
        {
            text_x = x + INLINE_FTE_SINGLELINE_TEXT_OFFSET;
        }
        else if(mmi_fe_get_r2l_state() == 1)
        {
            text_x = x + width - 1 -  INLINE_FTE_SINGLELINE_TEXT_OFFSET;
        }
		gui_print_truncated_text(text_x, y + (height - text_height)/2, (width - INLINE_FTE_SINGLELINE_TEXT_OFFSET), (UI_string_type)(item->text_p));
    }
#endif /* __MMI_PHB_PHOTO_STICKER_SUPPORT__ */
}

#if defined(__MMI_TOUCH_SCREEN__)
/*****************************************************************************
 * FUNCTION
 *  inline_fte_displayonly_item_pen_handler
 * DESCRIPTION
 *  highlight function of inline caption
 * PARAMETERS

 * RETURNS
 *  void
 *****************************************************************************/
BOOL inline_fte_displayonly_item_pen_handler( 
                mmi_pen_event_type_enum pen_event,
                S16 x,
                S16 y,
                gui_inline_pen_enum *inline_event,
                U16 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    BOOL ret = MMI_FALSE;
    wgui_inline_item_text_edit * i = wgui_inline_items[index].item;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    *inline_event = GUI_INLINE_PEN_NONE;

     switch (pen_event)
    {
        case MMI_PEN_EVENT_DOWN:
        {
            if (PEN_CHECK_BOUND(x, y, (S32)(i->x), (S32)(i->y), (S32)(i->width), (S32)(i->height)))
            {
                if(index == wgui_inline_item_highlighted_index)
                {
                    wgui_show_inline_fte_displayonly_item_highlight_ext(i->x, i->y, 
                        i->width, i->height, 
                        &wgui_inline_items[index], 
                        1);     
                }
                else
                {
                     wgui_show_inline_fte_displayonly_item_unhighlight_ext(i->x, i->y, 
                        i->width, i->height, 
                        &wgui_inline_items[index], 
                        1);     
                }
                return MMI_TRUE;
            }
            else
            {
                return MMI_FALSE;
            }
        }       

        case MMI_PEN_EVENT_MOVE:
        {
            if (!PEN_CHECK_BOUND(x, y, (S32)(i->x), (S32)(i->y), (S32)(i->width), (S32)(i->height)))
            {
                if(index == wgui_inline_item_highlighted_index)
                {
                    wgui_show_inline_fte_displayonly_item_highlight_ext(i->x, i->y, 
                        i->width, i->height, 
                        &wgui_inline_items[index], 
                        0);     
                }
                else
                {
                     wgui_show_inline_fte_displayonly_item_unhighlight_ext(i->x, i->y, 
                        i->width, i->height, 
                        &wgui_inline_items[index], 
                        0);     
                }
                return MMI_FALSE; 
            }
            else 
            {
                return MMI_TRUE; 
            }
        }

        case MMI_PEN_EVENT_UP:
        {
            if (PEN_CHECK_BOUND(x, y, (S32)(i->x), (S32)(i->y), (S32)(i->width), (S32)(i->height)))
            {
                if(index == wgui_inline_item_highlighted_index)
                {
                    wgui_show_inline_fte_displayonly_item_highlight_ext(i->x, i->y, 
                        i->width, i->height, 
                        &wgui_inline_items[index], 
                        0);     
                }
                else
                {
                     wgui_show_inline_fte_displayonly_item_unhighlight_ext(i->x, i->y, 
                        i->width, i->height, 
                        &wgui_inline_items[index], 
                        0);     
                }
                return MMI_TRUE;
            }
            else if(wgui_inline_pen_down_item_index == index)
            {
                if(index == wgui_inline_item_highlighted_index)
                {
                    wgui_show_inline_fte_displayonly_item_highlight_ext(i->x, i->y, 
                        i->width, i->height, 
                        &wgui_inline_items[index], 
                        0);     
                }
            else
            {
                    wgui_show_inline_fte_displayonly_item_unhighlight_ext(i->x, i->y, 
                        i->width, i->height, 
                        &wgui_inline_items[index], 
                        0);     
                }
                return MMI_FALSE;
            }
            break;          
        }

        case MMI_PEN_EVENT_LONG_TAP:
            /* Do Nothing */
            break;

        case MMI_PEN_EVENT_REPEAT:
            /* Do Nothing */
            break;

        case MMI_PEN_EVENT_ABORT:
            /* Do Nothing */
            break;

        default:
            MMI_DBG_ASSERT(0);
    }

    return ret;
}
#endif /* __MMI_TOUCH_SCREEN__ */

#endif

/*****************************************************************************
 * FUNCTION
 *  wgui_show_inline_displayonly_item
 * DESCRIPTION
 *  activation function of inline display only
 * PARAMETERS
 *  x                   [IN]        left corner's x coordinate
 *  y                   [IN]        left corner's y coordinate
 *  width               [IN]        width
 *  height              [IN]        height
 *  key_code            [IN]        key code
 *  key_event           [IN]        key event
 *  text_p              [IN]        text pointer
 *  item                [IN]        inline item
 *  flags               [IN]        flags
 *  history_buffer      [IN]        history buffer
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_show_inline_displayonly_item(
                S32 x,
                S32 y,
                S32 width,
                S32 height,
                wgui_inline_item *item)
{
   
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 left_x = 0, right_x= 0;
    S32 left_text_x= 0, right_text_x = 0;
    S32 text_width = 0, text_height = 0;
    UI_font_type ft = {0};
    color text_colr = gui_color(0, 0, 0);
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    left_x = x + MMI_fixed_icontext_menuitem.text_x ;
    right_x = x + width - 1;

    ft = current_single_line_input_box_theme->text_font;
    gui_set_font(ft);
    text_colr = MMI_fixed_icontext_menuitem.normal_text_color;
    gui_set_text_color(text_colr);  
    Get_StringWidthHeight(item->text_p, &text_width, &text_height);

    if(item->flags & INLINE_ITEM_RIGHT_JUSTIFY)
    {
        wgui_show_inline_text_edit_list_menuitem(x,
			y,
			width,
			height,
			item);
    }
    else
    {
        if(mmi_fe_get_r2l_state() == 0)
        {
        left_text_x = left_x;
            gui_move_text_cursor(left_text_x, y + (height - text_height)/2);
            gui_print_text((UI_string_type)(item->text_p));
    }

        if(mmi_fe_get_r2l_state() == 1)
        {
            right_text_x = right_x;
            gui_move_text_cursor(right_text_x, y + (height - text_height)/2);
    gui_print_text((UI_string_type)(item->text_p));
}
    }    
    
}

/*****************************************************************************
 * FUNCTION
 *  SetInlineItemDisplayOnly
 * DESCRIPTION
 *  Set the data of inline item display only 
 * PARAMETERS
 *  item        [IN]    inline item's pointer
 *  text_p      [IN]    item's text_p
 * RETURNS
 *  void
 *****************************************************************************/
void SetInlineItemDisplayOnly(InlineItem *item, U8 *text_p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_inline_item_text_edit *i;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_inline_mem_alloc_info[wgui_inline_mem_alloc_number] = item->item = wgui_inline_malloc(sizeof(wgui_inline_item_text_edit));
    wgui_inline_mem_alloc_number++;
    i = (wgui_inline_item_text_edit*) item->item;
    memset(i, 0, sizeof(wgui_inline_item_text_edit));
    i->buffer = text_p;
    item->text_p = text_p;
    item->handler = handle_inline_display_only;
    item->flags = INLINE_ITEM_TYPE_DISPLAY_ONLY;
}


/*****************************************************************************
 * FUNCTION
 *  ReConfigureInlineItemDisplayOnly
 * DESCRIPTION
 *  Re-configure the text_p of inline Display Only item
 * PARAMETERS
 *  item        [IN]    inline item's pointer
 *  text_p      [IN]    item's text_p   
 * RETURNS
 *  void
 *****************************************************************************/
void ReConfigureInlineItemDisplayOnly(InlineItem *item, U8 *text_p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if ((item->flags & 0xff) != INLINE_ITEM_TYPE_DISPLAY_ONLY)
    {
        return;
    }
    item->text_p = text_p;
}

#ifdef __MMI_INLINE_ITEM_BUTTON__

#if defined(__MMI_MAINLCD_320X480__)
#define INLINE_BUTTON_ITEM_WIDTH		(150)
#elif defined(__MMI_MAINLCD_320X240__)
#define INLINE_BUTTON_ITEM_WIDTH		(150)
#elif defined(__MMI_MAINLCD_240X320__)
#define INLINE_BUTTON_ITEM_WIDTH		(125)
#elif defined(__MMI_MAINLCD_240X400__)
#define INLINE_BUTTON_ITEM_WIDTH		(125)
#else
#define INLINE_BUTTON_ITEM_WIDTH		(0)
#endif
/*****************************************************************************
 * FUNCTION
 *  wgui_show_inline_button_item_unhighlight
 * DESCRIPTION
 *  activation function of inline button
 * PARAMETERS
 *  x                   [IN]        left corner's x coordinate
 *  y                   [IN]        left corner's y coordinate
 *  width               [IN]        width
 *  height              [IN]        height
 *  item                [IN]        inline item
 *  status_flag         [IN]
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_show_inline_button_item_unhighlight(
                S32 x,
                S32 y,
                S32 width,
                S32 height,
                wgui_inline_item *item,
                U8 status_flag)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 left_text_x= 0, right_text_x = 0, var = 0;
    S32 text_width = 0, text_height = 0;
    gdi_handle act_layer;
    PU8 image = NULL;
    wgui_inline_item_button *i = (wgui_inline_item_button *)item->item;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    i->x = x;
    i->y = y;
    i->width = width;
    i->height = height;
    i->status_flag = status_flag;
    
    gdi_layer_push_clip();
    gdi_layer_get_active(&act_layer);
    
    if (MMI_fixed_list_menu.act_layer_handle == act_layer)
    {
        gdi_layer_set_clip(
            MMI_fixed_list_menu.x, 
            MMI_fixed_list_menu.y, 
            MMI_fixed_list_menu.x + MMI_fixed_list_menu.width - 1,
            MMI_fixed_list_menu.y + MMI_fixed_list_menu.height - 1);
        gui_set_clip_preset(x, y, x + width - 1, y + height - 1);
    }
    else
    {
        gui_set_clip(x, y, x + width - 1, y + height - 1);
    }

    if(status_flag == 0)
    {
        image = (U8*) GetImage(IMG_INLINE_BUTTON_NORMAL_UP_BG);
    }
    else
    {
        image = (U8*) GetImage(IMG_INLINE_BUTTON_NORMAL_DOWN_BG);
    }
    gdi_image_draw_resized(x, y, width - 1, height - 1, image);
	
    gui_set_font(wgui_inline_singleline_inputbox_focussed_theme.text_font);
    gui_set_text_color(wgui_inline_singleline_inputbox_focussed_theme.normal_text_color);	
    Get_StringWidthHeight(item->text_p, &text_width, &text_height);

    left_text_x = x;
    right_text_x = x + width;
#if defined(__MMI_FTE_SUPPORT__)
    left_text_x += INLINE_FTE_SINGLELINE_TEXT_OFFSET;
    right_text_x -= INLINE_FTE_BUTTON_RIGHT_BOUNDARY;
#endif /* __MMI_FTE_SUPPORT__ */

#if defined(__MMI_FTE_SUPPORT__)
    var = INLINE_FTE_BUTTON_RIGHT_BOUNDARY + INLINE_FTE_SINGLELINE_TEXT_OFFSET;
#endif /* __MMI_FTE_SUPPORT__ */
    if (text_width > (width - var))
    {
        text_width = width - var;
    }
    else
    {
        left_text_x = left_text_x + ((width - var - text_width)>>1);
        right_text_x = right_text_x - ((width - var - text_width)>>1);
    }

    if(mmi_fe_get_r2l_state() == 0)
    {
        gui_print_truncated_text(left_text_x, y + (height - text_height)/2, text_width, (UI_string_type)(item->text_p));
    }
    else if(mmi_fe_get_r2l_state() == 1)
    {
        gui_print_truncated_text(right_text_x, y + (height - text_height)/2, text_width, (UI_string_type)(item->text_p));
    }
    
    gdi_layer_pop_clip();
    gdi_layer_blt_previous(x, y, x + width, y + height);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_show_inline_button_item_highlight
 * DESCRIPTION
 *  activation function of inline button
 * PARAMETERS
 *  x                   [IN]        left corner's x coordinate
 *  y                   [IN]        left corner's y coordinate
 *  width               [IN]        width
 *  height              [IN]        height
 *  item                [IN]        inline item
 *  status_flag         [IN]
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_show_inline_button_item_highlight(
                S32 x,
                S32 y,
                S32 width,
                S32 height,
                wgui_inline_item *item,
                U8 status_flag)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 left_text_x= 0, right_text_x = 0, var = 0;
    S32 text_width = 0, text_height = 0;
    color text_colr = gui_color(0, 0, 0);
    PU8 image = NULL;
    wgui_inline_item_button *i = (wgui_inline_item_button *)item->item;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    i->x = x;
    i->y = y;
    i->width = width;
    i->height = height;
    i->status_flag = status_flag;
    clear_inline_item_keys = wgui_inline_display_only_close;
	
    if(status_flag == 0)
    {
        image = (U8*) GetImage(IMG_INLINE_BUTTON_HIGHLIGHT_UP_BG);
    }
    else
    {
        image = (U8*) GetImage(IMG_INLINE_BUTTON_HIGHLIGHT_DOWN_BG);
    }
    gdi_image_draw_resized(x, y, width - 1, height - 1, image);
	
    gui_set_font(wgui_inline_singleline_inputbox_focussed_theme.text_font);
    text_colr = wgui_inline_singleline_inputbox_focussed_theme.normal_text_color;
    gui_set_text_color(text_colr);  
    
    Get_StringWidthHeight(item->text_p, &text_width, &text_height);
    left_text_x = x;
    right_text_x = x + width;
#if defined(__MMI_FTE_SUPPORT__)
    left_text_x += INLINE_FTE_SINGLELINE_TEXT_OFFSET;
    right_text_x -= INLINE_FTE_BUTTON_RIGHT_BOUNDARY;
    var = INLINE_FTE_BUTTON_RIGHT_BOUNDARY + INLINE_FTE_SINGLELINE_TEXT_OFFSET;
#endif /* __MMI_FTE_SUPPORT__ */
    if((text_width > (width - var)))
    {
        text_width = width - var;
        gui_create_scrolling_text(
            &wgui_inline_scroll_text, 
            left_text_x, 
            y + (height - text_height)/2, 
            text_width, 
            text_height, 
            (UI_string_type)(item->text_p), 
            wgui_inlinescrolling_timer, 
            wgui_scrolling_text_draw_background, 
            text_colr, 
            text_colr);
        gui_show_scrolling_text(&wgui_inline_scroll_text);
    }
    else
    {
        if(mmi_fe_get_r2l_state() == 0)
        {      
            left_text_x = left_text_x + ((width - var - text_width)>>1);
            gui_move_text_cursor(left_text_x, y + (height - text_height)/2);
            gui_print_text((UI_string_type)(item->text_p));
        }
        else if(mmi_fe_get_r2l_state() == 1)
        {
            right_text_x = right_text_x - ((width - var - text_width)>>1);
            gui_move_text_cursor(right_text_x, y + (height - text_height)/2);
            gui_print_text((UI_string_type)(item->text_p)); 
        }
    }
    gdi_layer_blt_previous(x, y, x + width, y + height);
}


/*****************************************************************************
 * FUNCTION
 *  handle_inline_button
 * DESCRIPTION
 *  activation function of inline button
 * PARAMETERS
 *  x                   [IN]        left corner's x coordinate
 *  y                   [IN]        left corner's y coordinate
 *  width               [IN]        width
 *  height              [IN]        height
 *  key_code            [IN]        key code
 *  key_event           [IN]        key event
 *  text_p              [IN]        text pointer
 *  item                [IN]        inline item
 *  flags               [IN]        flags
 *  history_buffer      [IN]        history buffer
 * RETURNS
 *  void
 *****************************************************************************/
void handle_inline_button(
		S32 x,
		S32 y,
		S32 width,
		S32 height,
		S32 key_code,
		S32 key_event,
		U8 **text_p,
		void *item,
		U32 flags,
		U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x1;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    x1 = x + ((width - INLINE_BUTTON_ITEM_WIDTH)>>1);
    wgui_show_inline_button_item_highlight(
        x1,
        y,
        INLINE_BUTTON_ITEM_WIDTH,
        height,
        &wgui_inline_items[wgui_inline_item_highlighted_index],
        0);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_show_inline_buttion_item
 * DESCRIPTION
 *  activation function of inline button
 * PARAMETERS
 *  x                   [IN]        left corner's x coordinate
 *  y                   [IN]        left corner's y coordinate
 *  width               [IN]        width
 *  height              [IN]        height
 *  item                [IN]        inline item
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_show_inline_buttion_item(
                S32 x,
                S32 y,
                S32 width,
                S32 height,
                wgui_inline_item *item)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x1;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    x1 = x + ((width - INLINE_BUTTON_ITEM_WIDTH)>>1);
	wgui_show_inline_button_item_unhighlight(
		x1,
		y,
		INLINE_BUTTON_ITEM_WIDTH,
		height,
		item,
		0);
}


/*****************************************************************************
 * FUNCTION
 *  SetInlineItemButton
 * DESCRIPTION
 *  Set the data of inline item button
 * PARAMETERS
 *  item        [IN]    inline item's pointer
 *  text_p      [IN]    item's text_p
 * RETURNS
 *  void
 *****************************************************************************/
void SetInlineItemButton(InlineItem *item, U8 *text_p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_inline_item_button *i;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_inline_mem_alloc_info[wgui_inline_mem_alloc_number] = item->item = wgui_inline_malloc(sizeof(wgui_inline_item_button));
    wgui_inline_mem_alloc_number++;
    i = (wgui_inline_item_button*) item->item;
    memset(i, 0, sizeof(wgui_inline_item_button));
    item->text_p = text_p;
    item->handler = handle_inline_button;
    item->flags = INLINE_ITEM_TYPE_BUTTON;
}


/*****************************************************************************
 * FUNCTION
 *  ReConfigureInlineItemButton
 * DESCRIPTION
 *  Re-configure the text_p of inline Button item
 * PARAMETERS
 *  item        [IN]    inline item's pointer
 *  text_p      [IN]    item's text_p   
 * RETURNS
 *  void
 *****************************************************************************/
void ReConfigureInlineItemButton(InlineItem *item, U8 *text_p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if ((item->flags & INLINE_ITEM_TYPE_MASK) != INLINE_ITEM_TYPE_BUTTON)
    {
        return;
    }
    item->text_p = text_p;
}


#if defined(__MMI_TOUCH_SCREEN__)
/*****************************************************************************
 * FUNCTION
 *  inline_button_item_pen_handler
 * DESCRIPTION
 *  
 * PARAMETERS

 * RETURNS
 *  void
 *****************************************************************************/
static BOOL inline_button_item_pen_handler( 
                mmi_pen_event_type_enum pen_event,
                S16 x,
                S16 y,
                gui_inline_pen_enum *inline_event,
                U16 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    BOOL ret = FALSE;
    wgui_inline_item_button * i = wgui_inline_items[index].item;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    *inline_event = GUI_INLINE_PEN_NONE;
    
    switch (pen_event)
    {
        case MMI_PEN_EVENT_DOWN:
        {
            if (PEN_CHECK_BOUND(x, y, (S32)(i->x), (S32)(i->y), (S32)(i->width), (S32)(i->height)))
            {
                if(index == wgui_inline_item_highlighted_index)
                {
                    wgui_show_inline_button_item_highlight(i->x, i->y, 
                        i->width, i->height, 
                        &wgui_inline_items[index], 
                        1);     
                }
                else
                {
                    wgui_show_inline_button_item_unhighlight(i->x, i->y, 
                        i->width, i->height, 
                        &wgui_inline_items[index], 
                        1);     
                }
                return TRUE;
            }
            else
            {
                return FALSE;
            }
        }       
        
        case MMI_PEN_EVENT_MOVE:
        {
            if (!PEN_CHECK_BOUND(x, y, (S32)(i->x), (S32)(i->y), (S32)(i->width), (S32)(i->height)))
            {
                if(index == wgui_inline_item_highlighted_index)
                {
                    wgui_show_inline_button_item_highlight(i->x, i->y, 
                        i->width, i->height, 
                        &wgui_inline_items[index], 
                        0);     
                }
                else
                {
                    wgui_show_inline_button_item_unhighlight(i->x, i->y, 
                        i->width, i->height, 
                        &wgui_inline_items[index], 
                        0);     
                }
                return FALSE; 
            }
            else 
            {
                return TRUE; 
            }
        }
        
        case MMI_PEN_EVENT_UP:
        {
            if (PEN_CHECK_BOUND(x, y, (S32)(i->x), (S32)(i->y), (S32)(i->width), (S32)(i->height)))
            {
                if(index == wgui_inline_item_highlighted_index)
                {
                    wgui_show_inline_button_item_highlight(i->x, i->y, 
                        i->width, i->height, 
                        &wgui_inline_items[index], 
                        0);     
                }
                else
                {
                    wgui_show_inline_button_item_unhighlight(i->x, i->y, 
                        i->width, i->height, 
                        &wgui_inline_items[index], 
                        0);     
                }
                return TRUE;
            }
            else if(wgui_inline_pen_down_item_index == index)
            {
                if(index == wgui_inline_item_highlighted_index)
                {
                    wgui_show_inline_button_item_highlight(i->x, i->y, 
                        i->width, i->height, 
                        &wgui_inline_items[index], 
                        0);     
                }
                else
                {
                    wgui_show_inline_button_item_unhighlight(i->x, i->y, 
                        i->width, i->height, 
                        &wgui_inline_items[index], 
                        0);     
                }
                return FALSE;
            }
            break;          
        }
        case MMI_PEN_EVENT_LONG_TAP:
        case MMI_PEN_EVENT_REPEAT:
        case MMI_PEN_EVENT_ABORT:
            /* Do Nothing */
            break;
        default:
            MMI_DBG_ASSERT(0);
    }
    
    return ret;
}
#endif

#endif
/***************************************************************************** 
 * Inline Caption   
 *
 * This is Caption Inline Item
 *****************************************************************************/

/***************************************************************************** 
 * Function Implementation
 *****************************************************************************/

/*****************************************************************************
 * FUNCTION
 *  handle_inline_caption
 * DESCRIPTION
 *  activation function of inline caption
 * PARAMETERS
 *  x                   [IN]        left corner's x coordinate
 *  y                   [IN]        left corner's y coordinate
 *  width               [IN]        width
 *  height              [IN]        height
 *  key_code            [IN]        key code
 *  key_event           [IN]        key event
 *  text_p              [IN]        text pointer
 *  item                [IN]        inline item
 *  flags               [IN]        flags
 *  history_buffer      [IN]        history buffer        
 * RETURNS
 *  void
 *****************************************************************************/
void handle_inline_caption(
        S32 x,
        S32 y,
        S32 width,
        S32 height,
        S32 key_code,
        S32 key_event,
        U8 **text_p,
        void *item,
        U32 flags,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(x);
    UI_UNUSED_PARAMETER(y);
    UI_UNUSED_PARAMETER(height);
    UI_UNUSED_PARAMETER(width);
    UI_UNUSED_PARAMETER(key_code);
    UI_UNUSED_PARAMETER(key_event);
    UI_UNUSED_PARAMETER(text_p);
    UI_UNUSED_PARAMETER(item);
    UI_UNUSED_PARAMETER(flags);
}


#ifdef __MMI_INLINE_HIGHLIGHT_CAPTION__
void wgui_show_inline_caption_item(
                S32 x,
                S32 y,
                S32 width,
                S32 height,
                wgui_inline_item *item)
{
   
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 left_x = 0, right_x= 0;
    S32 left_text_x= 0, right_text_x = 0;
    S32 text_width = 0, text_height = 0;
    UI_font_type ft = {0};
    color text_colr = gui_color(0, 0, 0);
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    if(MMI_fixed_list_menu.current_displayed_item == wgui_inline_should_hl_caption_index)
	{
	    S32 next_item_heigh;
		S32 x1, y1, x2, y2;
        UI_filled_area * f ;

		next_item_heigh = wgui_get_inline_item_height(MMI_fixed_list_menu.current_displayed_item + 1);
		x1 = x-2;
		y1 = y;
		x2 = width+2;
		y2 = y + next_item_heigh + height;

        f = wgui_inline_fixed_icontext_menuitem_theme.focussed_filler;
		gui_draw_filled_area(x1, y1, x2, y2, f);
           
	}

    left_x = x + MMI_fixed_icontext_menuitem.text_x ;
    right_x = x + width - 1;

    ft = current_single_line_input_box_theme->text_font;
    gui_set_font(ft);
    text_colr = MMI_fixed_icontext_menuitem.normal_text_color;
    gui_set_text_color(text_colr);  
    Get_StringWidthHeight(item->text_p, &text_width, &text_height);
     
    if(mmi_fe_get_r2l_state())
    {
        right_text_x = right_x;
        gui_move_text_cursor(right_text_x, y + (height - text_height)/2);
        gui_print_text((UI_string_type)(item->text_p));
    }
    else
    {
        left_text_x = left_x;
        gui_move_text_cursor(left_text_x, y + (height - text_height)/2);
        gui_print_text((UI_string_type)(item->text_p));
    }
}    
#endif

#if defined(__MMI_PHB_PHOTO_STICKER_SUPPORT__)
static PU8 wgui_inline_caption_thumbnail_buffer = NULL;
/*****************************************************************************
 * FUNCTION
 *  wgui_inline_thumbnail_decode_result_hdlr
 * DESCRIPTION
 *  Inline Editor decode callback from GDI.
 * PARAMETERS
 *  decode_result       [IN]    result code of decode
 *  handle              [IN]    GDI decode handle
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_inline_thumbnail_decode_result_hdlr(GDI_RESULT decode_result, gdi_handle handle)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i, end_index = MMI_fixed_list_menu.last_displayed_item;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_caption_thumbnail_struct_ptr == NULL)
    {
        return ;
    }
    
    if (g_caption_thumbnail_struct_ptr->decoding_layer != NULL)
    {
        gdi_layer_free(g_caption_thumbnail_struct_ptr->decoding_layer);
        g_caption_thumbnail_struct_ptr->decoding_layer = NULL;
    }

	g_caption_thumbnail_struct_ptr->IsFinished = MMI_TRUE;
    if (decode_result == GDI_JPEG_SUCCEED)
    {
		g_caption_thumbnail_struct_ptr->IsSuccessed = MMI_TRUE;
    }
	else
	{
	    g_caption_thumbnail_struct_ptr->IsSuccessed = MMI_FALSE;
	}
	
	if (!gui_screen_smooth_scrolling_moved_by_pen())
	{
		if (end_index + 2 < MMI_fixed_list_menu.n_items - 1)
		{
			end_index = end_index + 2;
		}
		else
		{
			end_index = MMI_fixed_list_menu.n_items - 1;
		}
		for (i = MMI_fixed_list_menu.first_displayed_item; i <= end_index; i++)
		{
			if ((wgui_inline_items[i].flags & 0xff) == INLINE_ITEM_TYPE_CAPTION)
			{
				if (wgui_inline_items[i].item)
				{
					show_fixed_list_specified_item(i);
				}
			}
		}
	}
}


/*****************************************************************************
 * FUNCTION
 *  wgui_inline_thumbnail_exit
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_inline_thumbnail_exit(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_caption_thumbnail_struct_ptr == NULL)
    {
        return ;
    }
    
    if (g_caption_thumbnail_struct_ptr->decoding_handle != NULL)
    {
        gdi_image_decoder_stop(g_caption_thumbnail_struct_ptr->decoding_handle);
    }
    if (g_caption_thumbnail_struct_ptr->decoding_layer != NULL)
    {
        gdi_layer_free(g_caption_thumbnail_struct_ptr->decoding_layer);
    }
    memset((CHAR*)g_caption_thumbnail_struct_ptr, 0, sizeof(Caption_thumbnail_struct));
    g_caption_thumbnail_struct_ptr = NULL;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_inline_thumbnail_delay_decode_timer
 * DESCRIPTION
 *  decode timer
 * PARAMETERS
 *  thumbnail_path			[IN]		
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_inline_thumbnail_delay_decode_timer(wgui_inline_item_caption_tn *item)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 img_width = 0, img_height = 0;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	wgui_inline_thumbnail_exit();
	g_caption_thumbnail_struct_ptr = item->thumbnail_struct;
    
    if (item->thumbnail_path)
    {
        g_caption_thumbnail_struct_ptr->thumbnail_path = item->thumbnail_path;
        g_caption_thumbnail_struct_ptr->t_buffer = item->buffer_p;
        if (g_caption_thumbnail_struct_ptr->t_buffer == NULL)
        {
            g_caption_thumbnail_struct_ptr->t_buffer = wgui_inline_caption_thumbnail_buffer;
        }
        gdi_image_decoder_create(
            INLINE_FTE_CAPTION_THUMBNAIL_WIDTH, 
            INLINE_FTE_CAPTION_THUMBNAIL_HEIGHT, 
            wgui_inline_thumbnail_decode_result_hdlr);
        gdi_image_get_dimension_file((PS8) item->thumbnail_path, &img_width, &img_height);
        /* Create layer and nb decode on the layer */
        gdi_layer_create_using_outside_memory(
            0,
            0,
            INLINE_FTE_CAPTION_THUMBNAIL_WIDTH,
            INLINE_FTE_CAPTION_THUMBNAIL_HEIGHT,
            &(g_caption_thumbnail_struct_ptr->decoding_layer),
            (PU8) g_caption_thumbnail_struct_ptr->t_buffer,
            INLINE_FTE_CAPTION_THUMBNAIL_SIZE);
        
        gdi_layer_push_and_set_active(g_caption_thumbnail_struct_ptr->decoding_layer);
        gdi_layer_set_source_key(TRUE, GDI_COLOR_TRANSPARENT);
    #ifdef __MMI_FTE_SUPPORT__
        gdi_layer_clear(GDI_COLOR_BLACK);
    #endif
        gdi_push_and_set_alpha_blending_source_layer(g_caption_thumbnail_struct_ptr->decoding_layer);

	    if ((img_width < INLINE_FTE_CAPTION_THUMBNAIL_WIDTH) && (img_height < INLINE_FTE_CAPTION_THUMBNAIL_HEIGHT))
	    {
	        g_caption_thumbnail_struct_ptr->x1 = ((INLINE_FTE_CAPTION_THUMBNAIL_WIDTH - img_width)>>1);
			g_caption_thumbnail_struct_ptr->y1 = ((INLINE_FTE_CAPTION_THUMBNAIL_HEIGHT - img_height)>>1);
			g_caption_thumbnail_struct_ptr->width = img_width;
			g_caption_thumbnail_struct_ptr->height = img_height;
	    }
		else if ((img_width > INLINE_FTE_CAPTION_THUMBNAIL_WIDTH) && (img_height > INLINE_FTE_CAPTION_THUMBNAIL_HEIGHT))
		{
		    gdi_util_fit_box(
				GDI_UTIL_MODE_SHORT_SIDE_FIT,
				INLINE_FTE_CAPTION_THUMBNAIL_WIDTH,
				INLINE_FTE_CAPTION_THUMBNAIL_HEIGHT,
				img_width,
				img_height,
				&g_caption_thumbnail_struct_ptr->x1,
				&g_caption_thumbnail_struct_ptr->y1,
				&g_caption_thumbnail_struct_ptr->width,
				&g_caption_thumbnail_struct_ptr->height);
		}
		else
		{
		    gdi_util_fit_box(
				GDI_UTIL_MODE_LONG_SIDE_FIT,
				INLINE_FTE_CAPTION_THUMBNAIL_WIDTH,
				INLINE_FTE_CAPTION_THUMBNAIL_HEIGHT,
				img_width,
				img_height,
				&g_caption_thumbnail_struct_ptr->x1,
				&g_caption_thumbnail_struct_ptr->y1,
				&g_caption_thumbnail_struct_ptr->width,
				&g_caption_thumbnail_struct_ptr->height);
		}

		if (g_caption_thumbnail_struct_ptr->x1 > 0)
		{
		    g_caption_thumbnail_struct_ptr->x1 = 0;
		}
		if (g_caption_thumbnail_struct_ptr->y1 > 0)
		{
		    g_caption_thumbnail_struct_ptr->y1 = 0;
		}		
                
        gdi_image_decoder_decode_file(
            g_caption_thumbnail_struct_ptr->x1,
            g_caption_thumbnail_struct_ptr->y1,
            g_caption_thumbnail_struct_ptr->width,
            g_caption_thumbnail_struct_ptr->height,
            FALSE,
            (CHAR*)item->thumbnail_path,
            &(g_caption_thumbnail_struct_ptr->decoding_handle));
        
        gdi_pop_and_restore_alpha_blending_source_layer();
        gdi_layer_pop_and_restore_active();
    }
}


/*****************************************************************************
 * FUNCTION
 *  SetInlineItemCaptionThumbnail
 * DESCRIPTION
 *  Set data of inline Caption item Thumbnail
 * PARAMETERS
 *  item        			[IN]			inline item's pointer
 *  text_p      			[IN]    		item's text_p  
 *  thumbnail_path      	[IN]			thumbnail path
 *  buffer_p			[IN]			thumbnail buffer for parser
 *  default_id			[IN]			default id
 *  style				[IN]			1 image id , 2 thumbnail
 * RETURNS
 *  void
 *****************************************************************************/
void SetInlineItemCaptionThumbnail(InlineItem *item, PU8 text_p, PU8 thumbnail_path, PU8 buffer_p, U16 default_id, U32 style)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_inline_item_caption_tn *i;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_inline_mem_alloc_info[wgui_inline_mem_alloc_number] = item->item = wgui_inline_malloc(sizeof(wgui_inline_item_caption_tn));
    wgui_inline_mem_alloc_number++;
    i = (wgui_inline_item_caption_tn*) item->item;
    memset(i, 0, sizeof(wgui_inline_item_caption_tn));
    i->default_id = default_id;
    i->style = style;
    i->text_p = text_p;
    i->thumbnail_path = thumbnail_path;
	i->buffer_p = buffer_p;
    item->text_p = text_p;
    item->handler = handle_inline_caption;
    item->flags = INLINE_ITEM_TYPE_CAPTION;
	i->thumbnail_struct = &g_caption_thumbnail_struct;
    wgui_inline_thumbnail_delay_decode_timer(i);
}


/*****************************************************************************
 * FUNCTION
 *  ReconfigureInlineItemCaptionThumbnail
 * DESCRIPTION
 *  Re-configure data of inline Caption item Thumbnail
 * PARAMETERS
 *  item        			[IN]			inline item's pointer
 *  text_p      			[IN]    		item's text_p   
 *  thumbnail_path      	[IN]			thumbnail path
 *  buffer_p			[IN]			thumbnail buffer for parser
 *  default_id			[IN]			default id
 *  style				[IN]			1 image id , 2 thumbnail
 * RETURNS
 *  void
 *****************************************************************************/
void ReconfigureInlineItemCaptionThumbnail(InlineItem *item, PU8 text_p, PU8 thumbnail_path, PU8 buffer_p, U16 default_id, U32 style)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_inline_item_caption_tn *i;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if ((item->flags & 0xff) != INLINE_ITEM_TYPE_CAPTION)
    {
        return;
    }
    i = (wgui_inline_item_caption_tn*) item->item;
    memset(i, 0, sizeof(wgui_inline_item_caption_tn));
    i->default_id = default_id;
    i->thumbnail_path = thumbnail_path;
    i->style = style;
    i->text_p = text_p;
	i->buffer_p = buffer_p;
    item->text_p = text_p;
    i->thumbnail_struct = &g_caption_thumbnail_struct;
    wgui_inline_thumbnail_delay_decode_timer(i);
}
#endif /* __MMI_PHB_PHOTO_STICKER_SUPPORT__ */


/*****************************************************************************
 * FUNCTION
 *  SetInlineItemCaption
 * DESCRIPTION
 *  Set data of inline Caption item
 * PARAMETERS
 *  item        [IN]    inline item's pointer
 *  text_p      [IN]    item's text_p      
 * RETURNS
 *  void
 *****************************************************************************/
void SetInlineItemCaption(InlineItem *item, U8 *text_p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    item->item = NULL;
    item->text_p = text_p;
    item->handler = handle_inline_caption;
    item->flags = INLINE_ITEM_TYPE_CAPTION;
}


/*****************************************************************************
 * FUNCTION
 *  ReconfigureInlineItemCaption
 * DESCRIPTION
 *  Re-configure inline Caption item
 * PARAMETERS
 *  item        [IN]    inline item's pointer
 *  text_p      [IN]    item's text_p      
 * RETURNS
 *  void
 *****************************************************************************/
void ReconfigureInlineItemCaption(InlineItem *item, U8 *text_p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if ((item->flags & 0xff) != INLINE_ITEM_TYPE_CAPTION)
    {
        return;
    }
    item->text_p = text_p;
}


/***************************************************************************** 
 * Inline Text Edit   
 *
 * This is Text Edit Inline Item
 *****************************************************************************/

/***************************************************************************** 
 * Define
 *****************************************************************************/
#define MAX_INLINE_TEXT_EDIT_ITEMS                   20

#define WGUI_INLINE_TEXT_EDIT_MULTITAP_NONE          0
#define WGUI_INLINE_TEXT_EDIT_MULTITAP_STAR          1
#define WGUI_INLINE_TEXT_EDIT_MULTITAP_ANY           2
#define WGUI_INLINE_TEXT_EDIT_MULTITAP_ZERO          3

/***************************************************************************** 
 * Typedef 
 *****************************************************************************/
typedef struct _inline_text_edit_history
{
    U16 history_ID;
    S16 text_length;
    S16 allocated_length;
    S16 available_length;
    S16 current_position;
    S16 text_offset_x;
    S16 dummy;  /* Added for history issue on hardware */
    U32 flags;
    mmi_imc_history ime_history;
} inline_text_edit_history;

/***************************************************************************** 
 * Local Variable
 *****************************************************************************/
static wgui_inline_item_text_edit *current_wgui_inline_text_edit_item;
static PU8 *current_wgui_inline_text_edit_text_p;
static S32 n_inline_text_edit_items = 0;
static UI_character_type inline_text_edit_mask_character = (UI_character_type) '*';
static U8 wgui_inline_singleline_inputbox_decimal_flag = 0;
static U8 wgui_inline_singleline_inputbox_decimal_input_mode_flag = 0;
static S32 wgui_inline_singleline_inputbox_buffer_size = 0;
void (*inline_singleline_inputbox_input_callback) (void) = UI_dummy_function;
static void (*inline_singleline_inputbox_navigate_callback) (void) = UI_dummy_function;
static void (*inline_text_edit_RSK_function) (void) = NULL;
static U8 inline_text_edit_RSK_label_clear = 0;
static UI_string_type inline_text_edit_RSK_label_string;
//static single_line_input_box wgui_inline_text_edit_display_inputbox;
static S32   g_inline_text_gap_with_list;

/* Because when calling redraw_fixed_list() the editor will be re-created, 
 * all the status will be reset, so we must keep some status and set them back to
 * the editor if we need*/
static mmi_editor_inputbox_sub_type_enum g_inline_current_inline_item_type = MMI_EDITOR_MAX_SUB_INPUT_BOX;
static MMI_BOOL g_is_item_info_kept = MMI_FALSE;
static void * g_inline_current_input_box_handler = NULL;
static void * g_inline_current_editor_handle = NULL;
static S16 g_inline_text_current_position = 0;
static S32 g_inline_text_text_offset_x = 0;
static MMI_BOOL g_inline_redraw_entered = MMI_FALSE;
static S32 g_inline_text_available_length = 0;
static UI_buffer_type g_inline_text_input_mode_cursor_p = NULL;
static UI_buffer_type g_inline_text_input_start_cursor_p = NULL;
static UI_buffer_type g_inline_text_input_highlight_start_position = NULL;
static UI_buffer_type g_inline_text_input_highlight_end_position = NULL;
static MMI_BOOL g_is_inline_text_highlighted = MMI_FALSE;
static U32 g_is_inline_text_flags = 0;
static U32 g_mmi_inline_singleinline_initial_width = 0;
static U32 g_mmi_inline_singleinline_initial_x = 0;
static S32 g_inline_text_input_last_cursor_offset = 0;
static S16 g_inline_time_current_focus = 0;
static S16 g_inline_time_current_position = 0;
static U32 g_inline_time_flags = 0;
static S16 g_inline_date_current_focus = 0;
static S16 g_inline_date_current_position = 0;
static U32 g_inline_date_flags = 0;
static S16 g_inline_time_period_current_focus = 0;
static S16 g_inline_time_period_current_position = 0;
static U32 g_inline_time_period_flags = 0;
#if defined(__MMI_INLINE_ITEM_IP4__)
static S16 g_inline_IP4_current_focus = 0;
static S16 g_inline_IP4_current_position = 0;
static U32 g_inline_IP4_flags = 0;
#endif /* __MMI_INLINE_ITEM_IP4__ */

#if defined(__MMI_INSCREEN_MULTILINE_TEXTBOX__)
#if defined( __MMI_INLINE_ITEM_MULTILINE_READ_ONLY__) || defined( __MMI_INLINE_ITEM_MULTILINE_EDIT__)
static S16 g_inline_multiline_current_position = 0;
static S32 g_inline_multiline_text_offset_x = 0;
static S32 g_inline_multiline_available_length = 0;
static S32 g_inline_multiline_last_cursor_offset = 0;
static MMI_BOOL g_is_inline_multiline_highlighted = MMI_FALSE;
static UI_buffer_type g_is_inline_multiline_highlight_start_position = NULL;
static UI_buffer_type g_is_inline_multiline_highlight_end_position = NULL;
static U32 g_is_inline_multiline_flags = 0;
static multi_line_input_box g_inline_multiline_backup_struct;
static UI_buffer_type g_inline_multiline_input_mode_cursor_p = NULL;
static UI_buffer_type g_inline_multiline_input_start_cursor_p = NULL;
#endif
#endif

#if((UI_ENABLE_FRAME_SKIPPING) && (ENABLE_INLINE_SINGLELINE_INPUTBOX_FRAME_SKIPPING))
static S32 wgui_inline_singleline_inputbox_frame_counter = 0;
#endif 
static UI_filled_area temp_inline_edit_background_filler = {UI_FILLED_AREA_TYPE_COLOR | UI_FILLED_AREA_SINGLE_BORDER,
    NULL,
    NULL,
#ifdef __MMI_DEFAULT_THEME_3__
    {206, 206, 206, 100},
#else 
    {167, 232, 93, 100},
#endif 
    {0, 0, 0, 0},
    {0, 0, 0, 100},
    {0, 0, 0, 0},
    0
};

static UI_filled_area temp_inline_edit_background_filler2 = {UI_FILLED_AREA_TYPE_COLOR | UI_FILLED_AREA_SINGLE_BORDER,
    NULL,
    NULL,
    {255, 255, 255, 100},
    {0, 0, 0, 0},
    {0, 0, 0, 100},
    {0, 0, 0, 0},
    0
};

static UI_filled_area temp_inline_edit_background_filler3 = {UI_FILLED_AREA_TYPE_COLOR,
    NULL,
    NULL,
    {167, 232, 93, 100},
    {0, 0, 0, 0},
    {0, 0, 0, 100},
    {0, 0, 0, 0},
    0
};


/***************************************************************************** 
 * Global Variable
 *****************************************************************************/
single_line_input_box MMI_inline_singleline_inputbox;

UI_string_type wgui_inline_text_edit_buffer;

/* Filler used for focussed inputbox   with boundary  */
UI_single_line_input_box_theme wgui_inline_singleline_inputbox_focussed_theme = { &temp_inline_edit_background_filler,
    &temp_inline_edit_background_filler,
    &temp_inline_edit_background_filler,
    {0, 0, 0, 100},
    {128, 128, 128, 100},
    {0, 0, 0, 100},
    {255, 255, 255, 100},
    {51, 88, 171, 100},
    {255, 0, 0, 100},
    &MMI_default_font,
    1,
    UI_SINGLE_LINE_INPUT_BOX_CENTER_Y,
    '*'
};

/* Filler used for unfocussed inputbox with boundary  */
UI_single_line_input_box_theme wgui_inline_singleline_inputbox_unfocussed_theme =
    { &temp_inline_edit_background_filler2,
    &temp_inline_edit_background_filler2,
    &temp_inline_edit_background_filler2,
    {0, 0, 0, 100},
    {128, 128, 128, 100},
    {0, 0, 0, 100},
    {255, 255, 255, 100},
    {51, 88, 171, 100},
    {255, 0, 0, 100},
    &MMI_default_font,
    1,
    UI_SINGLE_LINE_INPUT_BOX_CENTER_Y,
    '*'
};

/* Filler used for inputbox without boundary */
UI_single_line_input_box_theme wgui_inline_singleline_inputbox_no_boundary_theme =
    { &temp_inline_edit_background_filler3,
    &temp_inline_edit_background_filler3,
    &temp_inline_edit_background_filler3,
    {0, 0, 0, 100},
    {128, 128, 128, 100},
    {0, 0, 0, 100},
    {255, 255, 255, 100},
    {51, 88, 171, 100},
    {255, 0, 0, 100},
    &MMI_default_font,
    1,
    UI_SINGLE_LINE_INPUT_BOX_CENTER_Y,
    '*'
};



/***************************************************************************** 
 * Function Implementation
 *****************************************************************************/

#ifdef __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__
/*****************************************************************************
 * FUNCTION
 *  inline_item_default_text_show_background
 * DESCRIPTION
 *  show the background of the inline menu item in case of
 *  default text effect.
 * PARAMETERS
 *  x1      [IN]        Start x position
 *  y1      [IN]        Start y position
 *  x2      [IN]        End x position
 *  y2      [IN]        End y position
 * RETURNS
 *  void
 *****************************************************************************/
static void inline_item_default_text_show_background(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	gui_push_clip();
    gui_set_clip(x1, y1, x2, y2);
    gui_draw_filled_area(x1, y1, x2, y2, &temp_inline_edit_normal_filler);
    gui_pop_clip();
}


/*****************************************************************************
 * FUNCTION
 *  inline_text_edit_show_background
 * DESCRIPTION
 *  show the border of the inline text edit menu item with 3D
 *  effect.
 * PARAMETERS
 *  b       [IN]  context pointer of single line input box      
 * RETURNS
 *  void
 *****************************************************************************/
static void inline_text_edit_show_background(single_line_input_box *b)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x1, y1, x2, y2;
    color border_color1, border_color2;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    border_color1 = gui_blend_two_color(b->normal_filler->c, gui_color(255, 255, 255), 60, 100 - 60);
    border_color2 = gui_blend_two_color(b->normal_filler->c, gui_color(0, 0, 0), 75, 100 - 75);

    gdi_layer_reset_clip();
    x1 = b->x - 2;
    y1 = b->y - 2;
    x2 = b->x + b->width + 1;
    y2 = b->y + b->height + 1;

    /* draw the whitish rectangle */
      gui_draw_rectangle(x1, y1, x2, y2, b->normal_filler->c);

    /* draw the top left dark border */
      gui_draw_horizontal_line(x1 + 1, x2 - 1, y1 + 1, border_color2);
      gui_draw_vertical_line(y1 + 1, y2 - 1, x1 + 1, border_color2);

    /* draw the bottom right highlight color border */
      gui_draw_horizontal_line(x1 + 1, x2 - 1, y2 - 1, border_color1);
      gui_draw_vertical_line(y1 + 1, y2 - 1, x2 - 1, border_color1);

}
#endif /* __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__ */ 


/*****************************************************************************
 * FUNCTION
 *  UI_dummy_edit_complete_handler
 * DESCRIPTION
 *  Dummy edit complete handler
 * PARAMETERS
 *  buffer          [IN]    buffer pointer         
 *  buffer_size     [IN]    the size of buffer    
 * RETURNS
 *  void
 *****************************************************************************/
void UI_dummy_edit_complete_handler(U8 *buffer, S32 buffer_size)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(buffer);
    UI_UNUSED_PARAMETER(buffer_size);
}


/*****************************************************************************
 * FUNCTION
 *  inline_edit_prepare_mask_buffer
 * DESCRIPTION
 *  prepare mask buffer 
 * PARAMETERS
 *  buffer1     [IN]     input buffer 
 *  buffer2     [OUT]    output buffer with mask character 
 * RETURNS
 *  void
 *****************************************************************************/
static void inline_edit_prepare_mask_buffer(U8 *buffer1, U8 *buffer2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    UI_character_type c = (UI_character_type) - 1;
    U16 eos = '\0';

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    while (!UI_STRING_END_OF_STRING_CHARACTER(c))
    {
        UI_STRING_GET_NEXT_CHARACTER(buffer1, c);
        if (UI_STRING_END_OF_STRING_CHARACTER(c))
        {
            UI_STRING_INSERT_CHARACTER(buffer2, eos);
        }
        else
        {
            UI_STRING_INSERT_CHARACTER(buffer2, inline_text_edit_mask_character);
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  create_inline_edit_singleline_inputbox_set_buffer
 * DESCRIPTION
 *  wrapper function of create single line input box in line editor
 * PARAMETERS
 *  buffer              [IN]        Is the buffer the inputbox should use (pre-allocated)
 *  buffer_length       [IN]        Is the length of the buffer
 *  text_length         [IN]        Is the length of text
 *  edit_position       [IN]        Is the cursor_position
 * RETURNS
 *  void
 *****************************************************************************/
void create_inline_edit_singleline_inputbox_set_buffer(
        UI_string_type buffer,
        S32 buffer_length,
        S32 text_length,
        S32 edit_position)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    UI_single_line_input_box_theme *t = current_single_line_input_box_theme;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    current_single_line_input_box_theme = &wgui_inline_singleline_inputbox_focussed_theme;
    inline_singleline_inputbox_input_callback = UI_dummy_function;
    inline_singleline_inputbox_navigate_callback = UI_dummy_function;
#ifdef __UCS2_ENCODING
    gui_create_single_line_input_box_set_buffer(
        &MMI_inline_singleline_inputbox,
        MMI_singleline_inputbox_x,
        MMI_singleline_inputbox_y,
        MMI_singleline_inputbox_width,
        MMI_singleline_inputbox_height,
        buffer,
        buffer_length * 2,
        (text_length + 1) * 2,
        edit_position);
#endif /* __UCS2_ENCODING */ 
#ifdef __ASCII
    gui_create_single_line_input_box_set_buffer(
        &MMI_inline_singleline_inputbox,
        MMI_singleline_inputbox_x,
        MMI_singleline_inputbox_y,
        MMI_singleline_inputbox_width,
        MMI_singleline_inputbox_height,
        buffer,
        buffer_length,
        text_length + 1,
        edit_position);
#endif /* __ASCII */ 
    current_single_line_input_box_theme = t;
#if((UI_ENABLE_FRAME_SKIPPING) && (ENABLE_INLINE_SINGLELINE_INPUTBOX_FRAME_SKIPPING))
    wgui_inline_singleline_inputbox_frame_counter = 0;
#endif 
}


/*****************************************************************************
 * FUNCTION
 *  show_inline_singleline_inputbox
 * DESCRIPTION
 *  show function of inline single input box
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void show_inline_singleline_inputbox(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    UI_single_line_input_box_theme *t = current_single_line_input_box_theme;
    color normal_text_color = wgui_inline_singleline_inputbox_focussed_theme.normal_text_color;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    /* shows the border with 3D effect in case of inline text edit item, when the
       default text effect is enabled. */
#if defined(__MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__) && !(defined(__MMI_MAINLCD_128X128__) || defined(__MMI_MAINLCD_128X160__) || defined(__MMI_MAINLCD_176X220__) || defined(__MMI_MAINLCD_128X64__))       /* 122805 3D inline edit */
    if (IsInlineItemDefaultTextEnable())
    {
        inline_text_edit_show_background(&MMI_inline_singleline_inputbox);
    }
#endif /* defined(__MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__) && !(defined(__MMI_MAINLCD_128X128__) || defined(__MMI_MAINLCD_128X160__)) */ 

    current_single_line_input_box_theme = &wgui_inline_singleline_inputbox_focussed_theme;

#ifndef __MMI_FTE_SUPPORT__
    if(MMI_inline_singleline_inputbox.flags & UI_SINGLE_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW)
    {
        current_single_line_input_box_theme->normal_text_color = MMI_fixed_icontext_menuitem.focussed_text_color;
    }
#endif
       
    gui_set_single_line_input_box_current_theme(&MMI_inline_singleline_inputbox);
    /* currency convertor & unit convertor input box, set font to medium font */
    MMI_inline_singleline_inputbox.text_font = &MMI_medium_font;

    gui_show_single_line_input_box(&MMI_inline_singleline_inputbox);
    gdi_layer_blt_previous(
       inline_text_edit_get_control_x_coordinate(&MMI_inline_singleline_inputbox),
        inline_text_edit_get_control_y_coordinate(&MMI_inline_singleline_inputbox),
        inline_text_edit_get_control_x_coordinate(&MMI_inline_singleline_inputbox) + inline_text_edit_get_control_full_width(&MMI_inline_singleline_inputbox),
        inline_text_edit_get_control_y_coordinate(&MMI_inline_singleline_inputbox) + inline_text_edit_get_control_full_height(&MMI_inline_singleline_inputbox)
        );

    wgui_inline_singleline_inputbox_focussed_theme.normal_text_color = normal_text_color;
    current_single_line_input_box_theme = t;

}

#if((UI_ENABLE_FRAME_SKIPPING) && (ENABLE_INLINE_SINGLELINE_INPUTBOX_FRAME_SKIPPING))


/*****************************************************************************
 * FUNCTION
 *  wgui_inline_singleline_inputbox_end_frame
 * DESCRIPTION
 *  end frame for inline single line input box
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_inline_singleline_inputbox_end_frame(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (wgui_inline_singleline_inputbox_frame_counter >= 1)
    {
        gui_show_single_line_input_box(&MMI_inline_singleline_inputbox);
        gdi_layer_blt_previous(
            MMI_inline_singleline_inputbox.x,
            MMI_inline_singleline_inputbox.y,
            MMI_inline_singleline_inputbox.x + MMI_inline_singleline_inputbox.width,
            MMI_inline_singleline_inputbox.y + MMI_inline_singleline_inputbox.height);
        wgui_inline_singleline_inputbox_frame_counter = 0;
        gui_start_timer(UI_FRAME_SKIP_TIMEOUT, wgui_inline_singleline_inputbox_end_frame);
    }
}

#endif /* ((UI_ENABLE_FRAME_SKIPPING) && (ENABLE_INLINE_SINGLELINE_INPUTBOX_FRAME_SKIPPING)) */ 


/*****************************************************************************
 * FUNCTION
 *  redraw_inline_singleline_inputbox
 * DESCRIPTION
 *  redraw function of inline singleline inputbox
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void redraw_inline_singleline_inputbox(void)
{
#if((UI_ENABLE_FRAME_SKIPPING) && (ENABLE_INLINE_SINGLELINE_INPUTBOX_FRAME_SKIPPING))
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (wgui_inline_singleline_inputbox_frame_counter > 0)
    {
        wgui_inline_singleline_inputbox_frame_counter++;
    }
    else
    {
        wgui_inline_singleline_inputbox_frame_counter = 1;
        gui_start_timer(UI_FRAME_START_TIMEOUT, wgui_inline_singleline_inputbox_end_frame);
    }
#else /* ((UI_ENABLE_FRAME_SKIPPING) && (ENABLE_INLINE_SINGLELINE_INPUTBOX_FRAME_SKIPPING)) */ 

    /* shows the border with 3D effect in case of inline text edit item, when the
       default text effect is enabled. */
#if defined(__MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__) && !(defined(__MMI_MAINLCD_128X128__) || defined(__MMI_MAINLCD_128X160__)  || defined(__MMI_MAINLCD_176X220__) || defined(__MMI_MAINLCD_128X64__))       /* 122805 3D inline edit */
    if (IsInlineItemDefaultTextEnable())
    {
        gui_push_clip();
		gui_set_clip_preset(MMI_fixed_list_menu.x, MMI_fixed_list_menu.y, MMI_fixed_list_menu.x + MMI_fixed_list_menu.width - 1, MMI_fixed_list_menu.y + MMI_fixed_list_menu.height - 1);
        inline_text_edit_show_background(&MMI_inline_singleline_inputbox);
		gui_pop_clip();
    }
#endif /* defined(__MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__) && !(defined(__MMI_MAINLCD_128X128__) || defined(__MMI_MAINLCD_128X160__)) */ 

    gui_push_clip();
	gui_set_clip_preset(MMI_fixed_list_menu.x, MMI_fixed_list_menu.y, MMI_fixed_list_menu.x + MMI_fixed_list_menu.width - 1, MMI_fixed_list_menu.y + MMI_fixed_list_menu.height - 1);
    gui_show_single_line_input_box(&MMI_inline_singleline_inputbox);
	gui_pop_clip();

    gdi_layer_blt_previous(
        inline_text_edit_get_control_x_coordinate(&MMI_inline_singleline_inputbox),
        inline_text_edit_get_control_y_coordinate(&MMI_inline_singleline_inputbox),
        inline_text_edit_get_control_x_coordinate(&MMI_inline_singleline_inputbox) + inline_text_edit_get_control_full_width(&MMI_inline_singleline_inputbox),
        inline_text_edit_get_control_y_coordinate(&MMI_inline_singleline_inputbox) + inline_text_edit_get_control_full_height(&MMI_inline_singleline_inputbox)
        );

#endif /* ((UI_ENABLE_FRAME_SKIPPING) && (ENABLE_INLINE_SINGLELINE_INPUTBOX_FRAME_SKIPPING)) */ 
}


/*****************************************************************************
 * FUNCTION
 *  clear_inline_singleline_inputbox_keys
 * DESCRIPTION
 *  clear inline singleline inputbox key handlers
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void clear_inline_singleline_inputbox_keys(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ClearInputEventHandler(MMI_DEVICE_KEY);
    clear_keyboard_key_handler();
    clear_multitap_key_handlers();
    clear_MMI_key_input_handler();
    clear_key_down_handler();
    clear_keyboard_input_handler();
    clear_inline_item_keys = UI_dummy_function;
}


/*****************************************************************************
 * FUNCTION
 *  reset_inline_singleline_inputbox
 * DESCRIPTION
 *  reset frame skipping of  inline singleline inputbox 
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void reset_inline_singleline_inputbox(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if(UI_BLINKING_CURSOR_SUPPORT)
    StopTimer(BLINKING_CURSOR);
#endif
#if((UI_ENABLE_FRAME_SKIPPING) && (ENABLE_INLINE_SINGLELINE_INPUTBOX_FRAME_SKIPPING))
    gui_cancel_timer(wgui_inline_singleline_inputbox_end_frame);
    wgui_inline_singleline_inputbox_frame_counter = 0;
#endif /* ((UI_ENABLE_FRAME_SKIPPING) && (ENABLE_INLINE_SINGLELINE_INPUTBOX_FRAME_SKIPPING)) */ 
    clear_inline_singleline_inputbox_keys();
}


/*****************************************************************************
 * FUNCTION
 *  inline_edit_singleline_inputbox_is_not_valid
 * DESCRIPTION
 *  whether single line item is not valid because user change item or screen
 * PARAMETERS
 *  void
 * RETURNS
 *  if user not change and return true
 *****************************************************************************/
static MMI_BOOL inline_edit_singleline_inputbox_is_not_valid(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if ((current_wgui_inline_item != NULL) 
        && ((current_wgui_inline_item->flags & INLINE_ITEM_TYPE_MASK) == INLINE_ITEM_TYPE_TEXT_EDIT))
    {
        return MMI_TRUE;
    }
    return MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  inline_edit_singleline_inputbox_direct_input_in_pos
 * DESCRIPTION
 *  direct input character in position for inline singleline inputbox
 * PARAMETERS
 *  c         [IN]        input character
 *  pos       [IN]        position for insertion
 * RETURNS
 *  void
 *****************************************************************************/
void inline_edit_singleline_inputbox_direct_input_in_pos(UI_character_type c, S32 pos)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    single_line_input_box *b = &MMI_inline_singleline_inputbox;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if( (c == '+') && (b->text[0] != '+') 
        && b->current_text_p == b->text 
        && ((b->last_position_p - b->text) >= (b->available_length))
        && MMI_inline_singleline_inputbox.flags & UI_SINGLE_LINE_INPUT_BOX_PLUS_CHARACTER_HANDLING)
    {
        b->available_length =
            (wgui_inline_singleline_inputbox_buffer_size + 1) * ENCODING_LENGTH;
    }  
    gui_single_line_input_box_insert_character_in_pos(&MMI_inline_singleline_inputbox, c, pos);
    if (inline_edit_singleline_inputbox_is_not_valid())
    {
        wgui_inline_list_menu_changed = 1;
        redraw_inline_singleline_inputbox();
        inline_singleline_inputbox_input_callback();
    }
}


/*****************************************************************************
 * FUNCTION
 *  inline_edit_singleline_inputbox_delete_in_pos
 * DESCRIPTION
 *  delete one character in position
 * PARAMETERS
 *  pos       [IN]        position for deletion
 * RETURNS
 *  void
 *****************************************************************************/
void inline_edit_singleline_inputbox_delete_in_pos(S32 pos)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/ 
    gui_single_line_input_box_delete_character_in_pos(&MMI_inline_singleline_inputbox, pos);
    if (inline_edit_singleline_inputbox_is_not_valid())
    {
        wgui_inline_list_menu_changed = 1;
        redraw_inline_singleline_inputbox();
        inline_singleline_inputbox_input_callback();
    }
}


/*****************************************************************************
 * FUNCTION
 *  inline_edit_singleline_inputbox_delete_character
 * DESCRIPTION
 *  delete character of inline singleline inputbox
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void inline_edit_singleline_inputbox_delete_character(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (wgui_inline_singleline_inputbox_decimal_input_mode_flag)
    {
        if (wgui_inline_singleline_inputbox_decimal_flag)
        {
            UI_buffer_type p = MMI_inline_singleline_inputbox.current_text_p;
            UI_character_type c;

            if (p != MMI_inline_singleline_inputbox.text)
            {
                UI_STRING_GET_PREVIOUS_CHARACTER(p, c);
                if (c == (UI_character_type) '.')
                {
                    wgui_inline_singleline_inputbox_decimal_flag = 0;
                }
            }
        }
    }

    gui_single_line_input_box_delete_character(&MMI_inline_singleline_inputbox);
    if (inline_edit_singleline_inputbox_is_not_valid())
    {
        wgui_inline_list_menu_changed = 1;
        if (!gui_screen_smooth_scrolling_moved_by_pen())
        {
            redraw_inline_singleline_inputbox();
        }
        inline_singleline_inputbox_input_callback();
    }
}


/*****************************************************************************
 * FUNCTION
 *  inline_edit_singleline_inputbox_delete_character_no_draw
 * DESCRIPTION
 *  delete character of inline singleline inputbox with no draw
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void inline_edit_singleline_inputbox_delete_character_no_draw(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	if (wgui_inline_singleline_inputbox_decimal_input_mode_flag)
    {
        if (wgui_inline_singleline_inputbox_decimal_flag)
        {
            UI_buffer_type p = MMI_inline_singleline_inputbox.current_text_p;
            UI_character_type c;
			
            if (p != MMI_inline_singleline_inputbox.text)
            {
                UI_STRING_GET_PREVIOUS_CHARACTER(p, c);
                if (c == (UI_character_type) '.')
                {
                    wgui_inline_singleline_inputbox_decimal_flag = 0;
                }
            }
        }
    }
	
    gui_single_line_input_box_delete_character(&MMI_inline_singleline_inputbox);
    if (inline_edit_singleline_inputbox_is_not_valid())
    {
        wgui_inline_list_menu_changed = 1;
    }
}


/*****************************************************************************
 * FUNCTION
 *  inline_edit_singleline_inputbox_previous_character
 * DESCRIPTION
 *  Moves the cursor to the previous character
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void inline_edit_singleline_inputbox_previous_character(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(mmi_imc_is_connected())
    {
        gui_single_line_input_box_previous(&MMI_inline_singleline_inputbox);
        redraw_inline_singleline_inputbox();
        inline_singleline_inputbox_navigate_callback();
    }
    else
    {
        UI_editor_play_tone_cannot_navigate();
    }
}


/*****************************************************************************
 * FUNCTION
 *  inline_edit_singleline_inputbox_next_character
 * DESCRIPTION
 *  Moves the cursor to the next character
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void inline_edit_singleline_inputbox_next_character(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    UI_character_type c = 0, pre_c = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(mmi_imc_is_connected())
    {
        if (mmi_imc_is_append_one_more_space_input_mode(mmi_imm_get_curr_input_mode()) &&
            !mmi_imc_is_ime_state())
        {
            pre_c = 0;
            
            if (MMI_inline_singleline_inputbox.current_text_p > MMI_inline_singleline_inputbox.text)
            {
                pre_c = (UI_character_type)((*((MMI_inline_singleline_inputbox.current_text_p - ENCODING_LENGTH)+0))|((*((MMI_inline_singleline_inputbox.current_text_p - ENCODING_LENGTH)+1))<<8));
            }

            c = (UI_character_type)((*((MMI_inline_singleline_inputbox.current_text_p)+0))|((*((MMI_inline_singleline_inputbox.current_text_p)+1))<<8));

            if (c == 0 && pre_c != 0 && pre_c != L' ')
            {
                inline_edit_singleline_inputbox_direct_input((UI_character_type)' ');
                
                return;
            }
        }

        gui_single_line_input_box_next(&MMI_inline_singleline_inputbox);
        redraw_inline_singleline_inputbox();
        inline_singleline_inputbox_navigate_callback();
    }
    else
    {
        UI_editor_play_tone_cannot_navigate();
    }
}


/*****************************************************************************
 * FUNCTION
 *  set_inline_edit_singleline_inputbox_mask
 * DESCRIPTION
 *  set flag of UI_SINGLE_LINE_INPUT_BOX_MASK_CHARACTERS
 * PARAMETERS
 *  m       [IN]     mask or not   
 * RETURNS
 *  void
 *****************************************************************************/
void set_inline_edit_singleline_inputbox_mask(U8 m)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (m)
    {
        case 0:
            MMI_inline_singleline_inputbox.flags &= ~UI_SINGLE_LINE_INPUT_BOX_MASK_CHARACTERS;
            break;
        case 1:
            MMI_inline_singleline_inputbox.flags |= UI_SINGLE_LINE_INPUT_BOX_MASK_CHARACTERS;
            break;
    }

#ifdef __MMI_FTE_SUPPORT__
    if (mmi_imc_get_draw())
    {
        show_inline_singleline_inputbox();
    }
#endif
}


/*****************************************************************************
 * FUNCTION
 *  inline_edit_move_singleline_inputbox
 * DESCRIPTION
 *  inline edit move singleline inputbox
 * PARAMETERS
 *  x       [IN]        left corner's x coordinate
 *  y       [IN]        left corner's y coordinate
 * RETURNS
 *  void
 *****************************************************************************/
void inline_edit_move_singleline_inputbox(single_line_input_box *b, S32 x, S32 y)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_FTE_SUPPORT__
    gui_move_single_line_input_box(b, x, y);
    return;
#endif

#if defined(__MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__) && !(defined(__MMI_MAINLCD_128X128__) || defined(__MMI_MAINLCD_128X160__)  || defined(__MMI_MAINLCD_176X220__) || defined(__MMI_MAINLCD_128X64__))       /* 122805 3D inline edit */
    if (IsInlineItemDefaultTextEnable() == 1)
    {
        gui_move_single_line_input_box(b, x + INLINE_DEFAULT_TEXT_BORDAR + INLINE_DEFAULT_TEXT_BORDAR_GAP, y);
    }
    else
    {
        gui_move_single_line_input_box(b, x, y);
    }
#else
    gui_move_single_line_input_box(b, x, y);
#endif
    
}


/*****************************************************************************
 * FUNCTION
 *  inline_edit_singleline_inputbox_toggle_insert_mode
 * DESCRIPTION
 *  toggle inline singleline inputbox's insert mode
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void inline_edit_singleline_inputbox_toggle_insert_mode(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_single_line_input_box_toggle_insert_mode(&MMI_inline_singleline_inputbox);
    redraw_inline_singleline_inputbox();
}


/*****************************************************************************
 * FUNCTION
 *  inline_edit_singleline_inputbox_delete_all_characters
 * DESCRIPTION
 *  delete all characters in inline singleline inputbox
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void inline_edit_singleline_inputbox_delete_all_characters(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#if defined(__MMI_TOUCH_SCREEN__)
    kal_bool is_enabled, is_pen_down;
#endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(__MMI_TOUCH_SCREEN__)
    mmi_pen_get_state(&is_enabled, &is_pen_down);
    if (is_pen_down)
#endif
    {
        gui_touch_feedback_play(GUI_TOUCH_FEEDBACK_HOLD);
    }
    gui_single_line_input_box_delete_all(&MMI_inline_singleline_inputbox);
    if (inline_edit_singleline_inputbox_is_not_valid())
    {
        wgui_inline_list_menu_changed = 1;
        wgui_inline_singleline_inputbox_decimal_flag = 0;
        redraw_inline_singleline_inputbox();
        inline_singleline_inputbox_input_callback();
    }
}


/*****************************************************************************
 * FUNCTION
 *  inline_edit_singleline_inputbox_delete_current_character
 * DESCRIPTION
 *  delete current character in inline singleline inputbox
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void inline_edit_singleline_inputbox_delete_current_character(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_single_line_input_box_delete_current_character(&MMI_inline_singleline_inputbox);
    if (inline_edit_singleline_inputbox_is_not_valid())
    {
        wgui_inline_list_menu_changed = 1;
        redraw_inline_singleline_inputbox();
        inline_singleline_inputbox_input_callback();
    }
}

#ifdef __MMI_MULTIGRAPH_SUPPORT__
/*****************************************************************************
 * FUNCTION
 *  inline_edit_singleline_inputbox_multitap_input_string
 * DESCRIPTION
 *  multitap input for inline singleline inputbox
 * PARAMETERS
 *  str       [IN]        multitap string
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
S32 inline_edit_singleline_inputbox_multitap_input_string(PU8 str)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 ret = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    ret = gui_single_line_input_box_insert_multitap_string(&MMI_inline_singleline_inputbox, (UI_string_type)str);
    if (ret)
    {    
        wgui_inline_list_menu_changed = 1;
        if (!gui_screen_smooth_scrolling_moved_by_pen())
        {
            redraw_inline_singleline_inputbox();
        }
        inline_singleline_inputbox_input_callback();
    }
    
    return ret;
}
#endif
/*****************************************************************************
 * FUNCTION
 *  inline_edit_singleline_inputbox_multitap_input
 * DESCRIPTION
 *  multitap input for inline singleline inputbox
 * PARAMETERS
 *  c       [IN]        multitap character
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL inline_edit_singleline_inputbox_multitap_input(UI_character_type c)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    single_line_input_box *b = &MMI_inline_singleline_inputbox;
    MMI_BOOL ret = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if (MMI_inline_singleline_inputbox.flags & UI_SINGLE_LINE_INPUT_BOX_PLUS_CHARACTER_HANDLING)
    {
        b->available_length = (wgui_inline_singleline_inputbox_buffer_size + 1) * ENCODING_LENGTH;
        
        ret = gui_single_line_input_box_insert_multitap_character(&MMI_inline_singleline_inputbox, c);

        if (ret)
        {
            if (b->text_length == b->available_length)
            {
                if (b->text[0] != '+')
                {
                    if (MMI_inline_singleline_inputbox.flags & UI_SINGLE_LINE_INPUT_BOX_STATE_MULTITAP)
                    {
                        gui_single_line_input_box_confirm_multitap_character(b);
                    }

                    gui_single_line_input_box_delete_character(b);

                    UI_editor_play_tone_cannot_insert(); 

                    ret = MMI_FALSE;
                }
            }
        }
        
        if (b->text_length < ((wgui_inline_singleline_inputbox_buffer_size + 1) * ENCODING_LENGTH))
        {
            b->available_length = wgui_inline_singleline_inputbox_buffer_size * ENCODING_LENGTH;
        }
    }
    else
    {
        ret = gui_single_line_input_box_insert_multitap_character(&MMI_inline_singleline_inputbox, c);
        
    }

    if (ret)
    {    
        wgui_inline_list_menu_changed = 1;
        if (!gui_screen_smooth_scrolling_moved_by_pen())
        {
            redraw_inline_singleline_inputbox();
        }
        inline_singleline_inputbox_input_callback();
    }
    
    return ret;
}


/*****************************************************************************
 * FUNCTION
 *  inline_edit_singleline_inputbox_multitap_input_complete
 * DESCRIPTION
 *  multitap input complete function for inline singleline inputbox
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void inline_edit_singleline_inputbox_multitap_input_complete(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (MMI_inline_singleline_inputbox.flags & UI_SINGLE_LINE_INPUT_BOX_STATE_MULTITAP)
    {
        gui_single_line_input_box_confirm_multitap_character(&MMI_inline_singleline_inputbox);
        wgui_inline_list_menu_changed = 1;

        MMI_inline_singleline_inputbox.flags |= UI_SINGLE_LINE_INPUT_BOX_DISABLE_DRAW;
        gui_show_single_line_input_box(&MMI_inline_singleline_inputbox);          /* show single line input box */
        MMI_inline_singleline_inputbox.flags &= ~UI_SINGLE_LINE_INPUT_BOX_DISABLE_DRAW;
        gui_single_line_input_box_locate_cursor(&MMI_inline_singleline_inputbox);

        if (!gui_screen_smooth_scrolling_moved_by_pen())
        {
            redraw_inline_singleline_inputbox();
        }
        inline_singleline_inputbox_input_callback();
    }
}


/*****************************************************************************
 * FUNCTION
 *  inline_edit_singleline_inputbox_direct_input
 * DESCRIPTION
 *  direct input character into inline singleline inputbox
 * PARAMETERS
 *  c       [IN]        input character
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL inline_edit_singleline_inputbox_direct_input(UI_character_type c)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    single_line_input_box *b = &MMI_inline_singleline_inputbox;
    MMI_BOOL ret = MMI_FALSE;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
   
 if (MMI_inline_singleline_inputbox.flags & UI_SINGLE_LINE_INPUT_BOX_PLUS_CHARACTER_HANDLING)
    {
        b->available_length = (wgui_inline_singleline_inputbox_buffer_size + 1) * ENCODING_LENGTH;
        
        ret = gui_single_line_input_box_insert_character(&MMI_inline_singleline_inputbox, c);
        
        if (ret)
        {
            if (b->text_length == b->available_length)
            {
                 if (b->text[0] != '+')
                 {
                     if (MMI_inline_singleline_inputbox.flags & UI_SINGLE_LINE_INPUT_BOX_STATE_MULTITAP)
                     {
                          gui_single_line_input_box_confirm_multitap_character(b);
                     }
        
                    gui_single_line_input_box_delete_character(b);
                    
                    UI_editor_play_tone_cannot_insert();                                                                              
                    
                    ret = MMI_FALSE;
                  }
            }
        }
        
        if (b->text_length < ((wgui_inline_singleline_inputbox_buffer_size + 1) * ENCODING_LENGTH))
        {
            b->available_length = wgui_inline_singleline_inputbox_buffer_size * ENCODING_LENGTH;
        }
    }
    else if (c == '.')
    {
        if (wgui_inline_singleline_inputbox_decimal_input_mode_flag)
        {
            if (wgui_inline_singleline_inputbox_decimal_flag)
            {
                return MMI_FALSE;
            }
        }
        ret = gui_single_line_input_box_insert_character(&MMI_inline_singleline_inputbox, c);
        if (ret)
        {
            if (wgui_inline_singleline_inputbox_decimal_input_mode_flag)
            {
                wgui_inline_singleline_inputbox_decimal_flag = 1;
            }
        }
    }
    else
    {
        ret = gui_single_line_input_box_insert_character(&MMI_inline_singleline_inputbox, c);
    }
    if(ret != MMI_FALSE)
    {
        wgui_inline_list_menu_changed = 1;
    }   

    if (!gui_screen_smooth_scrolling_moved_by_pen())
    {
        redraw_inline_singleline_inputbox();
    }
    inline_singleline_inputbox_input_callback();
        
    return ret;
}


/*****************************************************************************
 * FUNCTION
 *  inline_edit_singleline_inputbox_direct_input_no_draw
 * DESCRIPTION
 *  direct input character into inline singleline inputbox with no draw
 * PARAMETERS
 *  c       [IN]        input character
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL inline_edit_singleline_inputbox_direct_input_no_draw(UI_character_type c)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    single_line_input_box *b = &MMI_inline_singleline_inputbox;
    MMI_BOOL ret = MMI_FALSE;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if (MMI_inline_singleline_inputbox.flags & UI_SINGLE_LINE_INPUT_BOX_PLUS_CHARACTER_HANDLING)
    {
        b->available_length = (wgui_inline_singleline_inputbox_buffer_size + 1) * ENCODING_LENGTH;
        
        ret = gui_single_line_input_box_insert_character(&MMI_inline_singleline_inputbox, c);
        
        if (ret)
        {
            if (b->text_length == b->available_length)
            {
                if (b->text[0] != '+')
                {
                    if (MMI_inline_singleline_inputbox.flags & UI_SINGLE_LINE_INPUT_BOX_STATE_MULTITAP)
                    {
                        gui_single_line_input_box_confirm_multitap_character(b);
                    }
                    
                    gui_single_line_input_box_delete_character(b);
                    
                    UI_editor_play_tone_cannot_insert(); 
                    
                    ret = MMI_FALSE;
                }
            }
        }

        if (b->text_length < ((wgui_inline_singleline_inputbox_buffer_size + 1) * ENCODING_LENGTH))
        {
            b->available_length = wgui_inline_singleline_inputbox_buffer_size * ENCODING_LENGTH;
        }
    }
    else if (c == '.')
    {
        if (wgui_inline_singleline_inputbox_decimal_input_mode_flag)
        {
            if (wgui_inline_singleline_inputbox_decimal_flag)
            {
                return MMI_FALSE;
            }
        }
        ret = gui_single_line_input_box_insert_character(&MMI_inline_singleline_inputbox, c);
        if (ret)
        {
            if (wgui_inline_singleline_inputbox_decimal_input_mode_flag)
            {
                wgui_inline_singleline_inputbox_decimal_flag = 1;
            }
        }
    }
    else
    {
        ret = gui_single_line_input_box_insert_character(&MMI_inline_singleline_inputbox, c);
    }

    if(ret != MMI_FALSE)
    {
        wgui_inline_list_menu_changed = 1;
    }   
        
    return ret;
}


/*****************************************************************************
 * FUNCTION
 *  inline_singleline_inputbox_key_handler
 * DESCRIPTION
 *  key handler of inline singleline inputbox
 * PARAMETERS
 *  vkey_code       [IN]      key code  
 *  key_state       [IN]      key state
 * RETURNS
 *  void
 *****************************************************************************/
void inline_singleline_inputbox_key_handler(S32 vkey_code, S32 key_state)
{
#if(MMI_BUILD_TYPE == BUILD_TYPE_X86WIN32)
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (key_state)
    {
        switch (vkey_code)
        {
            case 37:
                inline_edit_singleline_inputbox_previous_character();
                break;
            case 38:
                inline_text_edit_handle_up_arrow();
                break;
            case 39:
                inline_edit_singleline_inputbox_next_character();
                break;
            case 40:
                inline_text_edit_handle_down_arrow();
                break;
            case 45:
                inline_edit_singleline_inputbox_toggle_insert_mode();
                break;
            case 46:
                inline_edit_singleline_inputbox_delete_current_character();
                break;
        }
    }
#else /* (MMI_BUILD_TYPE == BUILD_TYPE_X86WIN32) */ 
    UI_UNUSED_PARAMETER(vkey_code);
    UI_UNUSED_PARAMETER(key_state);
#endif /* (MMI_BUILD_TYPE == BUILD_TYPE_X86WIN32) */ 
}


/*****************************************************************************
 * FUNCTION
 *  register_inline_singleline_inputbox_keys
 * DESCRIPTION
 *  register key handlers for inline singleline inputbox
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void register_inline_singleline_inputbox_keys(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if ((MMI_inline_singleline_inputbox.flags & UI_SINGLE_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW) == 0)
    {     
    SetKeyHandler(inline_edit_singleline_inputbox_previous_character, KEY_LEFT_ARROW, KEY_EVENT_DOWN);
    SetKeyHandler(inline_edit_singleline_inputbox_next_character, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
        /* key rule. 09.10.17 */
        SetKeyHandler(inline_edit_singleline_inputbox_previous_character, KEY_LEFT_ARROW, KEY_REPEAT);
        SetKeyHandler(inline_edit_singleline_inputbox_next_character, KEY_RIGHT_ARROW, KEY_REPEAT);

    SetKeyHandler(wgui_inputs_sl_inline_handle_left_arrow_repeat, KEY_LEFT_ARROW, KEY_REPEAT);
    SetKeyHandler(wgui_inputs_sl_inline_handle_right_arrow_repeat, KEY_RIGHT_ARROW, KEY_REPEAT);
    SetKeyHandler(wgui_inputs_fast_del_nav_reset_repeat_count, KEY_LEFT_ARROW, KEY_LONG_PRESS);
    SetKeyHandler(wgui_inputs_fast_del_nav_reset_repeat_count, KEY_RIGHT_ARROW, KEY_LONG_PRESS);

    register_keyboard_key_handler(inline_singleline_inputbox_key_handler);
}
    else
    {
         /* key rule. 09.10.17 */
        SetKeyHandler(MMI_dummy_function, KEY_LEFT_ARROW, KEY_EVENT_REPEAT);
        SetKeyHandler(MMI_dummy_function, KEY_RIGHT_ARROW, KEY_EVENT_REPEAT);
        SetKeyHandler(MMI_dummy_function, KEY_LEFT_ARROW, KEY_EVENT_DOWN);
        SetKeyHandler(MMI_dummy_function, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);

        SetKeyHandler(MMI_dummy_function, KEY_LEFT_ARROW, KEY_REPEAT);
        SetKeyHandler(MMI_dummy_function, KEY_RIGHT_ARROW, KEY_REPEAT);
        SetKeyHandler(MMI_dummy_function, KEY_LEFT_ARROW, KEY_LONG_PRESS);
        SetKeyHandler(MMI_dummy_function, KEY_RIGHT_ARROW, KEY_LONG_PRESS);

        clear_keyboard_key_handler();
    }
}


/*****************************************************************************
 * FUNCTION
 *  handle_inline_text_edit_complete
 * DESCRIPTION
 *  inline text edit complete function
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void handle_inline_text_edit_complete(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 input_type = current_wgui_inline_text_edit_item->input_type & INPUT_TYPE_MASK;


    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    reset_inline_singleline_inputbox();
    current_wgui_inline_text_edit_item->UCS2_count = MMI_inline_singleline_inputbox.UCS2_count;
    register_inline_fixed_list_keys();
    
    inline_text_edit_RSK_function = NULL;
    mmi_imc_disconnect();
    
    if ((input_type == IMM_INPUT_TYPE_NUMERIC_PASSWORD) || (input_type == IMM_INPUT_TYPE_ALPHANUMERIC_PASSWORD) ||
        (input_type == IMM_INPUT_TYPE_SAT_NUMERIC_PASSWORD) || (input_type == IMM_INPUT_TYPE_ASCII_PASSWORD))
    {
        inline_edit_prepare_mask_buffer(
            current_wgui_inline_text_edit_item->buffer,
            current_wgui_inline_text_edit_item->mask_buffer);
        *current_wgui_inline_text_edit_text_p = current_wgui_inline_text_edit_item->mask_buffer;
    }
    else
    {
    #ifdef __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__
    #ifdef __MMI_FTE_SUPPORT__
        if(gui_strlen((UI_string_type) current_wgui_inline_text_edit_item->buffer) == 0)
    #else        
        if ((IsInlineItemDefaultTextEnable()) &&
            (gui_strlen((UI_string_type) current_wgui_inline_text_edit_item->buffer) == 0))
    #endif        
        {
            *current_wgui_inline_text_edit_text_p = current_wgui_inline_text_edit_item->default_item_text;
        }
        else
    #endif /* __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__ */ 
            *current_wgui_inline_text_edit_text_p = current_wgui_inline_text_edit_item->buffer;

    #ifdef __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__
        MMI_fixed_icontext_menuitems[wgui_inline_item_highlighted_index].item_text =
            (UI_string_type) (*current_wgui_inline_text_edit_text_p);
    #endif /* __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__ */ 
    }

    g_inline_current_input_box_handler = NULL;
    clear_left_softkey();
    clear_right_softkey();

    wgui_inline_item_handled = 0;
    current_wgui_inline_text_edit_item->edit_complete_callback(
                                            current_wgui_inline_text_edit_item->buffer,
                                            current_wgui_inline_text_edit_item->buffer_size);
    redraw_current_inline_item = UI_dummy_function;
    wgui_inputbox_UCS2_count_function = NULL;
    wgui_inputbox_not_empty_callback = NULL;
    wgui_inputbox_empty_callback = NULL;
    wgui_inputbox_validation_callback = NULL;
    complete_inline_item_edit = UI_dummy_function;
    g_mmi_inline_singleinline_initial_width = 0;
    g_mmi_inline_singleinline_initial_x = 0;
    /*
     * MTK Elvis Because we use  wgui_current_inline_item_type(wgui_get_inline_history)
     * * to check which inline data struct(inline text edit or full screen edit) history
     * * will be stored in history, we have to reset it while switching to other inline item.
     * * Otherwise, if other inline item(INLINE_ITEM_TYPE_FULL_SCREEN_EDIT) is not set wgui_current_inline_item_type, then
     * * wgui_current_inline_item_type keeps the old setting and causes not required input box history be stored in history
     * * One example:
     * * 1. In PHB email inline editing box wgui_current_inline_item_type= INLINE_ITEM_TYPE_TEXT_EDIT   and input_type is abc
     * * 2. goto previous one item(full screen edit while pressing LSK"Edit")
     * * 3. At this momnet, charger in and cuase the INLINE_ITEM_TYPE_TEXT_EDIT(input method is abc) stored in history
     * * 4. goto previous item(home number editing box)
     * * 5. the history is re-stored into current inline text editing box
     * * 6. the input method is abc, but 123
     */
    //W05.33 Fix inline text edit history issue
    //wgui_current_inline_item_type = 0;
    //MTK end

    StopTimer(BLINKING_CURSOR);

    /* W05.36 Fix Vietnamese Tone Input Issue */
    set_current_input_box_type(EDITOR_NONE_INPUT_BOX);
    g_is_inline_text_highlighted = MMI_FALSE;

    /* INPUT_TYPE_EXT_NO_SHOW_NEW_LINE_SYMBOL is used in IME, can't clear it */
    MMI_current_input_ext_type &= INPUT_TYPE_EXT_NO_SHOW_NEW_LINE_SYMBOL; 

    set_leading_zero(1);

#ifdef __MMI_FTE_SUPPORT__
    gui_inputs_register_redraw_background_filler(NULL);
#endif

}


/*****************************************************************************
 * FUNCTION
 *  inline_text_edit_handle_up_arrow
 * DESCRIPTION
 *  inline text edit up arrow handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void inline_text_edit_handle_up_arrow(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (wgui_inline_edit_is_able_to_switch_highlight(0))
    {
#ifdef __MMI_FTE_SUPPORT__    
        wgui_inline_get_vk_status(&g_inline_vk_status);
#endif
        handle_inline_text_edit_complete();
        inline_fixed_list_goto_previous_item();
    }
    else
    {
        UI_editor_play_tone_cannot_navigate();
        redraw_inline_singleline_inputbox();
    }
    
}


/*****************************************************************************
 * FUNCTION
 *  inline_text_edit_handle_down_arrow
 * DESCRIPTION
 *  inline text edit down arrow handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void inline_text_edit_handle_down_arrow(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (wgui_inline_edit_is_able_to_switch_highlight(1))
    {
#ifdef __MMI_FTE_SUPPORT__    
        wgui_inline_get_vk_status(&g_inline_vk_status);
#endif
        handle_inline_text_edit_complete();
        inline_fixed_list_goto_next_item();
    }
    else
    {
        UI_editor_play_tone_cannot_navigate();
        redraw_inline_singleline_inputbox();
    }
}


/*****************************************************************************
 * FUNCTION
 *  handle_inline_text_edit_right_softkey_down
 * DESCRIPTION
 *  right softkey down handler of inline text edit
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void handle_inline_text_edit_right_softkey_down(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (gui_single_line_input_box_get_text_length(&MMI_inline_singleline_inputbox) > 0)
    {
        inline_edit_singleline_inputbox_delete_character();
    }
    else
    {
        if (!(MMI_inline_singleline_inputbox.flags & UI_SINGLE_LINE_INPUT_BOX_DISABLE_TONES))
        {
            UI_editor_play_tone_cannot_change();
            return;
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  handle_inline_text_edit_right_softkey_up
 * DESCRIPTION
 *  right softkey up handler of inline text edit
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void handle_inline_text_edit_right_softkey_up(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (inline_text_edit_RSK_function != NULL)
    {
        inline_text_edit_RSK_function();
    }
}


/*****************************************************************************
 * FUNCTION
 *  register_inline_text_edit_handle_right_softkey_up
 * DESCRIPTION
 *  register right softkey up handler for inline text edit
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void register_inline_text_edit_handle_right_softkey_up(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(cui_inline_is_current_cui())
    {
        set_right_softkey_function(cui_inline_rsk_function, KEY_EVENT_UP);
        return;
    }
    set_right_softkey_function(handle_inline_text_edit_right_softkey_up, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  register_inline_text_edit_handle_clear_key_up
 * DESCRIPTION
 *  register clear key up handler for inline text edit
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void register_inline_text_edit_handle_clear_key_up(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    SetKeyHandler(handle_inline_text_edit_right_softkey_up, KEY_CLEAR, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  handle_inline_text_edit_right_softkey_long_press
 * DESCRIPTION
 *  right softkey long press handler for inlin text edit
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void handle_inline_text_edit_right_softkey_long_press(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_wgui_inputs_repeat_count = 0;
    set_right_softkey_function(wgui_inputs_sl_inline_handle_right_softkey_touch_repeat, KEY_REPEAT);
    if (mmi_frm_kbd_is_key_supported(KEY_CLEAR))
    {
        SetKeyHandler(wgui_inputs_sl_inline_handle_right_softkey_repeat, KEY_CLEAR, KEY_REPEAT);
    }
    else
    {
        SetKeyHandler(wgui_inputs_sl_inline_handle_right_softkey_repeat, KEY_RSK, KEY_REPEAT);
    }
    
}


/*****************************************************************************
 * FUNCTION
 *  handle_inline_text_edit_input
 * DESCRIPTION
 *  input handler for inline text edit  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void handle_inline_text_edit_input(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (gui_single_line_input_box_get_text_length(&MMI_inline_singleline_inputbox) > 0)
    {
        if (mmi_frm_kbd_is_key_supported(KEY_CLEAR))
        {
            if (inline_text_edit_RSK_label_clear == 0)
            { 
                execute_wgui_inline_edit_text_not_empty();
                inline_text_edit_RSK_label_clear = 1;
                SetKeyHandler(handle_inline_text_edit_right_softkey_down, KEY_CLEAR, KEY_EVENT_DOWN);
                SetKeyHandler(UI_dummy_function, KEY_CLEAR, KEY_EVENT_UP);
                SetKeyHandler(handle_inline_text_edit_right_softkey_long_press, KEY_CLEAR, KEY_EVENT_LONG_PRESS);
                
                set_right_softkey_label((UI_string_type) get_string(STR_GLOBAL_BACK));
                set_right_softkey_function(wgui_inline_edit_register_BACK_function, KEY_EVENT_DOWN);
            }
        }
        else
        {
            if (inline_text_edit_RSK_label_clear == 0)
            {
                execute_wgui_inline_edit_text_not_empty();
                inline_text_edit_RSK_label_clear = 1;
                
                set_right_softkey_label((UI_string_type) get_string(STR_GLOBAL_CLEAR));
                register_right_softkey_handler();
                
                /* IME may be not redraw softkey in some case, ex: direct input char, so inline will redraw softkey. */
                if(!g_inline_is_no_redraw_status)
                {
                    redraw_right_softkey();
                }	 
                
                set_right_softkey_function(NULL, KEY_EVENT_UP);
                set_right_softkey_function(handle_inline_text_edit_right_softkey_down, KEY_EVENT_DOWN);
                set_right_softkey_function(handle_inline_text_edit_right_softkey_long_press, KEY_EVENT_LONG_PRESS);
                
            }
        }
    }
    else
    {
        if (inline_text_edit_RSK_label_clear == 1)
        {
            if (wgui_inline_list_menu_changed)
            {
             
                wgui_inline_text_edit_set_RSK_BACK_function();
                inline_text_edit_RSK_label_clear = 0;  
				execute_wgui_inline_edit_text_empty();
            }
            /* it seems blow code will not be executed forever. */
            else
            {
                if (mmi_frm_kbd_is_key_supported(KEY_CLEAR))
                {
                    execute_wgui_inline_edit_text_empty();
                    inline_text_edit_RSK_label_clear = 0;
                    SetKeyHandler(handle_inline_text_edit_right_softkey_down, KEY_CLEAR, KEY_EVENT_DOWN);
                    SetKeyHandler(UI_dummy_function, KEY_CLEAR, KEY_EVENT_UP);
                    SetKeyHandler(UI_dummy_function, KEY_CLEAR, KEY_EVENT_LONG_PRESS);
                }
                else
                {
                    set_right_softkey_label(inline_text_edit_RSK_label_string);
                    execute_wgui_inline_edit_text_empty();				  
                    register_right_softkey_handler();
                    redraw_right_softkey();
                    inline_text_edit_RSK_label_clear = 0;
                    set_right_softkey_function(register_inline_text_edit_handle_right_softkey_up, KEY_EVENT_UP);
                    set_right_softkey_function(UI_dummy_function, KEY_EVENT_DOWN);
                }
            }
        }
        else
        {
           wgui_inline_text_edit_set_RSK_BACK_function(); 
        }
            
    }
}


/*****************************************************************************
 * FUNCTION
 *  inline_text_edit_set_RSK_function
 * DESCRIPTION
 *  set RSK function of inline text edit
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void inline_text_edit_set_RSK_function(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (inline_edit_singleline_inputbox_is_not_valid())
    {
        inline_text_edit_RSK_function = wgui_inline_edit_BACK_function;
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_inline_singleline_inputbox_get_UCS2_count
 * DESCRIPTION
 *  get UCS2 count of inline singleline inputbox
 * PARAMETERS
 *  void
 * RETURNS
 *  UCS2 count
 *****************************************************************************/
S32 wgui_inline_singleline_inputbox_get_UCS2_count(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return (MMI_inline_singleline_inputbox.UCS2_count);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_inline_singleline_inputbox_validation_callback
 * DESCRIPTION
 *  validation callback for inline singleline inputbox
 * PARAMETERS
 *  text            [IN]        buffer
 *  cursor          [IN]        cursor position
 *  text_length     [IN]        text length
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_inline_singleline_inputbox_validation_callback(UI_buffer_type text, UI_buffer_type cursor, S32 text_length)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(cui_inline_is_current_cui())
    {
       cui_inline_evt_item_changed(); 
    }
    else
    {
        if (wgui_inputbox_validation_callback != NULL)
        {
            wgui_inputbox_validation_callback(text, cursor, text_length);
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  inline_text_edit_get_history
 * DESCRIPTION
 *  get history buffer of inline text edit
 * PARAMETERS
 *  history_buffer      [OUT]   history buffer      
 *  input_mode          [IN]    input mode        
 * RETURNS
 *  history buffer pointer
 *****************************************************************************/
U8 *inline_text_edit_get_history(U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (history_buffer != NULL)
    {
        U16 hID = (U16) (INLINE_TEXT_EDIT_HISTORY_ID | 0x8000);
        inline_text_edit_history *h = (inline_text_edit_history*) history_buffer;

        h->history_ID = hID;
        h->text_length = (S16) MMI_inline_singleline_inputbox.text_length;
        h->allocated_length = (S16) MMI_inline_singleline_inputbox.allocated_length;
        h->available_length = (S16) MMI_inline_singleline_inputbox.available_length;
        h->current_position =
            (S16) (MMI_inline_singleline_inputbox.current_text_p - MMI_inline_singleline_inputbox.text);
        h->text_offset_x = (S16) MMI_inline_singleline_inputbox.text_offset_x;
        h->flags = MMI_inline_singleline_inputbox.flags;

       if ((h->flags & UI_SINGLE_LINE_INPUT_BOX_STATE_MULTITAP) || (h->flags & UI_SINGLE_LINE_INPUT_BOX_INPUT_METHOD_MODE) ||
            mmi_imc_is_clipboard_state())
        {
            h->flags &= ~UI_SINGLE_LINE_INPUT_BOX_WORD_HIGHLIGHT;
        }
        h->flags &= ~UI_SINGLE_LINE_INPUT_BOX_STATE_MULTITAP;
        h->flags &= ~UI_SINGLE_LINE_INPUT_BOX_INPUT_METHOD_MODE;
        				
        mmi_imc_get_input_method_history(&(h->ime_history));

        h->ime_history.state = 0;
    }
    return (history_buffer);
}


/*****************************************************************************
 * FUNCTION
 *  inline_text_edit_set_history
 * DESCRIPTION
 *  set history into MMI_inline_singleline_inputbox
 * PARAMETERS
 *  history_ID          [IN]       history id 
 *  history_buffer      [IN]       history buffer  
 *  input_mode          [OUT]      input mode
 * RETURNS
 *  1-> success 0-> fail
 *****************************************************************************/
U8 inline_text_edit_set_history(U16 history_ID, U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (history_buffer != NULL)
    {
        inline_text_edit_history *h = (inline_text_edit_history*) history_buffer;

        if (history_valid(h->history_ID, history_ID))
        {
            /*
             * MTK Elvis 20040506--it is not required to restored the text length of current input box
             * *    because the text_length will be set correctly in handle_inline_text_edit->create_inline_edit_singleline_inputbox_set_buffer.
             * *    if restored it, will cause MMI_inline_single_line_inputbox have wrong text length(asyn with text buffer)
             * *    for example,
             * *       (1)in inline editor screen and highlighted at first item(first line will lead user to full screen editor, and second item is inline single input box)
             * *       (2)charger in --> popup a new window and add current screen related parameters into history including text_length
             * *       (3)and the text_length maybe not correct because text_length of input boxes(inline single, single, multi line, or EMS) will not be reset
             * *       (4)while popup dispeared, go back to (1)
             * *       (5)press arrow down to go to next item, inline single line input box
             * *       (6)handle_inline_text_edit->create_inline_edit_singleline_inputbox_set_buffer will calculate the length from text buffer
             * *       (7)inline_text_edit_set_history will restore the text length from history
             * *       (8)inline_text_edit_set_history caused text_length not sync with current input box text buffer
             * *            Therefore, comment out MMI_inline_singleline_inputbox.text_length=h->text_length;
             */
            /* W05.33 Fix inline text edit history issue */
            MMI_inline_singleline_inputbox.text_length = h->text_length;
            MMI_inline_singleline_inputbox.allocated_length = h->allocated_length;
            MMI_inline_singleline_inputbox.available_length = h->available_length;
            MMI_inline_singleline_inputbox.current_text_p =
                (UI_buffer_type) (MMI_inline_singleline_inputbox.text + h->current_position);
            MMI_inline_singleline_inputbox.text_offset_x = h->text_offset_x;
            /* MTK end */
            MMI_inline_singleline_inputbox.flags = h->flags;

            return (1);
        }
    }
    return (0);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_inline_show_icon_in_inlineitem
 * DESCRIPTION
 *  Draw icon in inlineitem.
 * PARAMETERS
 *  index           [IN]       index of item in list.Not used now. 
 *  x               [IN]       the x left top coordinate of icon. 
 *  y               [OUT]      the y left top coordinate of icon. 
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_inline_show_icon_in_inlineitem(S32 index, S32 x, S32 y)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 icon_width = 0, icon_height = 0;
    S32 m_gap = MMI_INLINE_ICON_RESERVED / 2;
    U32 x_cordinate = 0;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if(g_inline_text_gap_with_list == 0)
    {
        g_inline_text_gap_with_list = x;
        gui_measure_image(g_inline_picon, &icon_width, &icon_height);
        g_inline_text_gap_with_list = g_inline_text_gap_with_list + m_gap;
        if(g_inline_picon != NULL)
        {
            gui_show_image(g_inline_text_gap_with_list, y + m_gap, g_inline_picon);
        }
        if((MMI_fixed_list_menu.flags & UI_LIST_MENU_DISABLE_SCROLLBAR) ||
            ((MMI_fixed_list_menu.flags & UI_LIST_MENU_AUTO_DISABLE_SCROLLBAR) && (MMI_fixed_list_menu.displayed_items >= MMI_fixed_list_menu.n_items)))
        {
            g_inline_text_gap_with_list |= 0xff000000;
        }
    }
    else
    {
        if((MMI_fixed_list_menu.flags & UI_LIST_MENU_DISABLE_SCROLLBAR) ||
            ((MMI_fixed_list_menu.flags & UI_LIST_MENU_AUTO_DISABLE_SCROLLBAR) && (MMI_fixed_list_menu.displayed_items >= MMI_fixed_list_menu.n_items)))
        {
            if((g_inline_text_gap_with_list &0xff000000) == 0)
            {
                x_cordinate = x;
                gui_measure_image(g_inline_picon, &icon_width, &icon_height);
                x_cordinate = x_cordinate + m_gap;
                if(g_inline_picon != NULL)
                {
                    gui_show_image(x_cordinate, y + m_gap, g_inline_picon);
                }
    }
            else
            {    
                if(g_inline_picon != NULL)
                {
                    gui_show_image(g_inline_text_gap_with_list - 0xff000000, y + m_gap, g_inline_picon);
                }
            }
        }
        else
        {
            if((g_inline_text_gap_with_list &0xff000000))
            {
                x_cordinate = x;
                gui_measure_image(g_inline_picon, &icon_width, &icon_height);
                x_cordinate = x_cordinate + m_gap;
                if(g_inline_picon != NULL)
                {
                    gui_show_image(x_cordinate, y + m_gap, g_inline_picon);
                }
            }
            else
            {
    if(g_inline_picon != NULL)
    {
        gui_show_image(g_inline_text_gap_with_list, y + m_gap, g_inline_picon);
    }
            }
        }
    }

  
}

/*****************************************************************************
 * FUNCTION
 *  wgui_inline_show_icon_in_singleline
 * DESCRIPTION
 *  Draw icon in singleline.
 * PARAMETERS
 *  x               [IN]       the x left top coordinate of icon. 
 *  y               [OUT]      the y left top coordinate of icon. 
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_inline_show_icon_in_singleline(S32 x, S32 y, S32 clip_x1, S32 clip_y1, S32 clip_x2, S32 clip_y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 icon_width = 0, icon_height = 0;
    S32 m_gap = MMI_INLINE_ICON_RESERVED / 2;
    U8 ime_width = 0;
    U32 x_cordinate = 0;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_push_clip();
    gui_set_clip_preset(clip_x1, clip_y1, clip_x2, clip_y2);
    
    ime_width = mmi_imc_get_input_mode_hint_width();
    if(ime_width >0)
    {
        if(g_inline_picon != NULL)
        {
            gui_show_image(x + m_gap, y + m_gap, g_inline_picon);
        }
    }
    else
    {
        if(g_inline_text_gap_with_list == 0)
        {
            g_inline_text_gap_with_list = x;
            gui_measure_image(g_inline_picon, &icon_width, &icon_height);
            g_inline_text_gap_with_list = g_inline_text_gap_with_list + m_gap;
            if(g_inline_picon != NULL)
            {
                gui_show_image(g_inline_text_gap_with_list, y + m_gap, g_inline_picon);
        }
            if((MMI_fixed_list_menu.flags & UI_LIST_MENU_DISABLE_SCROLLBAR) ||
                ((MMI_fixed_list_menu.flags & UI_LIST_MENU_AUTO_DISABLE_SCROLLBAR) && (MMI_fixed_list_menu.displayed_items >= MMI_fixed_list_menu.n_items)))
            {
                g_inline_text_gap_with_list |= 0xff000000;
            }
        }
        else
        {
            if((MMI_fixed_list_menu.flags & UI_LIST_MENU_DISABLE_SCROLLBAR) ||
                ((MMI_fixed_list_menu.flags & UI_LIST_MENU_AUTO_DISABLE_SCROLLBAR) && (MMI_fixed_list_menu.displayed_items >= MMI_fixed_list_menu.n_items)))
            {
                if((g_inline_text_gap_with_list &0xff000000) == 0)
                {
                    x_cordinate = x;
                    gui_measure_image(g_inline_picon, &icon_width, &icon_height);
                    x_cordinate = x_cordinate + m_gap;
                    if(g_inline_picon != NULL)
                    {
                        gui_show_image(x_cordinate, y + m_gap, g_inline_picon);
                    }
                }
                else
                {    
                    if(g_inline_picon != NULL)
                    {
                        gui_show_image(g_inline_text_gap_with_list - 0xff000000, y + m_gap, g_inline_picon);
                    }
                }
            }
            else
            {
                if((g_inline_text_gap_with_list &0xff000000))
                {
                    x_cordinate = x;
                    gui_measure_image(g_inline_picon, &icon_width, &icon_height);
                    x_cordinate = x_cordinate + m_gap;
                    if(g_inline_picon != NULL)
                    {
                        gui_show_image(x_cordinate, y + m_gap, g_inline_picon);
                    }
                }
                else
                {
        if(g_inline_picon != NULL)
        {
            gui_show_image(g_inline_text_gap_with_list, y + m_gap, g_inline_picon);
        }
    } 
            }
        }
    } 
    gui_pop_clip();
   
}


/*****************************************************************************
 * FUNCTION
 *  SetInlineIconStyle
 * DESCRIPTION
 *  Set icon style for  inline item. just set for singleline and fullscreen items now.
 * PARAMETERS
 *  item                [IN]       Inline item pointer . 
 *  picon               [OUT]      The pointer of icon . 
 *  b                   [OUT]      flag to indicate whether set or reset.  1-> set 0-> reset. 
 * RETURNS
 *  void
 *****************************************************************************/
void SetInlineIconStyle(InlineItem *item, PU8 picon, BOOL b)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(((item->flags & 0xff) == INLINE_ITEM_TYPE_TEXT_EDIT)||
               ((item->flags & 0xff) == INLINE_ITEM_TYPE_FULL_SCREEN_EDIT)||
               ((item->flags & 0xff) == INLINE_ITEM_TYPE_CAPTION)||
               ((item->flags & 0xff) == INLINE_ITEM_TYPE_DISPLAY_ONLY)
              );
    if(b == TRUE && picon != NULL)
    {
        g_inline_picon = picon;
        item->flags |= INLINE_ITEM_ICON_IN_ITEM;
        wgui_fixed_list_register_indicator_display_callback(wgui_inline_show_icon_in_inlineitem);
    }
    else if(b == FALSE)
    {
        g_inline_picon = NULL;
        item->flags &= ~INLINE_ITEM_ICON_IN_ITEM;
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_inline_get_default_indicator_width
 * DESCRIPTION
 *  Get area size . 
 * PARAMETERS
 *  pwidth                [OUT]      The area width pointer . 
 *  pheight               [OUT]      The area height pointer . 
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_inline_get_default_indicator_width( S32 *pwidth, S32 *pheight)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 icon_width = 0, icon_height = 0;  
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/   
    if(g_inline_picon)
    {          
        gui_measure_image(g_inline_picon, &icon_width, &icon_height);
        *pwidth =  icon_width + MMI_INLINE_ICON_RESERVED;
        *pheight = icon_height + MMI_INLINE_ICON_RESERVED;
    }
    else
    {
        *pwidth = 0;
        *pheight = 0;
    }
}


/*****************************************************************************
 * FUNCTION
 *  handle_inline_text_edit
 * DESCRIPTION
 *  activation function of inline text edit
 * PARAMETERS
 *  x                   [IN]        left corner's x coordinate
 *  y                   [IN]        left corner's y coordinate
 *  width               [IN]        width
 *  height              [IN]        height
 *  key_code            [IN]        key code
 *  key_event           [IN]        key event
 *  text_p              [IN]        text pointer
 *  item                [IN]        inline item
 *  flags               [IN]        flags
 *  history_buffer      [IN]        history buffer        
 * RETURNS
 *  void
 *****************************************************************************/
void handle_inline_text_edit(
        S32 x,
        S32 y,
        S32 width,
        S32 height,
        S32 key_code,
        S32 key_event,
        U8 **text_p,
        void *item,
        U32 flags,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 l, xx;

#ifndef __MMI_FTE_SUPPORT__
    S32 ime_width;
#endif

    U32 input_type;
    U32 input_type_flags, list_filler_border = 0;
    U8 saved_MMI_current_input_mode;
    U32 saved_inputbox_flags;
    wgui_inline_item_text_edit *i = (wgui_inline_item_text_edit*) item;
    U8 plus_character_handling = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(key_event);
    UI_UNUSED_PARAMETER(key_code);
    UI_UNUSED_PARAMETER(flags);
    
    redraw_current_inline_item = UI_dummy_function;

#if defined(__MMI_INDIC_ALG__)
    /*set up required in indic engine when single-line editor is launched*/
    ire_set_use_multitap_inline_single_line();
#endif
    /* W05.36 Fix Vietnamese Tone Input Issue */
    set_current_input_box_type(EDITOR_INLINE_TEXT);
    wgui_inline_singleline_inputbox_buffer_size = i->buffer_size;
    if (i->input_type & INPUT_TYPE_PLUS_CHARACTER_HANDLING)
    {
        plus_character_handling = 1;
    }

    /* for 0x81 encoding for Phone Book */
    MMI_current_input_ext_type = i->input_ext_type;

    wgui_current_inline_item_type = INLINE_ITEM_TYPE_TEXT_EDIT;

    if (current_MMI_theme->list_selected_item_filler->flags & UI_FILLED_AREA_SINGLE_BORDER)
    {
        list_filler_border = 1;
    }

   // clear_inline_item_keys = clear_inline_singleline_inputbox_keys;
    register_default_hide_softkeys();
    complete_inline_item_edit = handle_inline_text_edit_complete;
    current_wgui_inline_text_edit_item = i;
    current_wgui_inline_text_edit_text_p = text_p;
    set_left_softkey_label(get_string(STR_GLOBAL_SAVE));
    l = gui_strlen((UI_string_type) i->buffer);
    create_inline_edit_singleline_inputbox_set_buffer(
        (UI_string_type) i->buffer,
        i->buffer_size,
        l,
        l);
        
#ifdef __MMI_FTE_SUPPORT__
        MMI_inline_singleline_inputbox.flags |= UI_SINGLE_LINE_INPUT_BOX_USE_PRESET_CLIPPING;
#ifdef __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__
        gui_single_line_input_box_set_default_text(&MMI_inline_singleline_inputbox, (UI_string_type)i->default_item_text);
#endif
        gui_inputs_register_redraw_background_filler(wgui_inline_brush_item_background);
#endif
   //hjf, xx should left shift single inputbox text_x, for alignment menu text
    if (mmi_fe_get_r2l_state())
        xx = MMI_fixed_icontext_menuitem.text_x;
    else
        xx = MMI_fixed_icontext_menuitem.text_x - MMI_inline_singleline_inputbox.text_x;

    if (xx<0) 
        xx = list_filler_border;
        
    if (flags & INLINE_ITEM_LEFT_ALIGN)
        xx = list_filler_border;

    if (xx < 1)
        xx = 1;

    switch (flags & INLINE_ITEM_JUSTIFY_MASK)
    {
        case INLINE_ITEM_RIGHT_JUSTIFY:
            MMI_inline_singleline_inputbox.flags |= UI_SINGLE_LINE_INPUT_BOX_RIGHT_JUSTIFY;
            break;

        case INLINE_ITEM_CENTER_JUSTIFY:
            MMI_inline_singleline_inputbox.flags |= UI_SINGLE_LINE_INPUT_BOX_CENTER_JUSTIFY;
            break;
    }
    
    if (flags & INLINE_ITEM_DISABLE_CURSOR_DISPLAY)
    {
        MMI_inline_singleline_inputbox.flags |= UI_SINGLE_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW;
    }

    if ((flags & INLINE_ITEM_BOUNDARY_MASK) == INLINE_ITEM_BOUNDARY_NEVER)
    {
        gui_set_single_line_input_box_theme(
            &MMI_inline_singleline_inputbox,
            &wgui_inline_singleline_inputbox_no_boundary_theme);
    }


    /* move the inputbox at correct location, in case of default text effect is enabled. */
#if defined(__MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__) && !(defined(__MMI_MAINLCD_128X128__) || defined(__MMI_MAINLCD_128X160__)  || defined(__MMI_MAINLCD_176X220__) || defined(__MMI_MAINLCD_128X64__))       /* 122805 3D inline edit */
    if (IsInlineItemDefaultTextEnable())
    {
        if (mmi_fe_get_r2l_state())
        {
            inline_edit_move_singleline_inputbox(&MMI_inline_singleline_inputbox, x, y + 2);
        }
        else
        {
            inline_edit_move_singleline_inputbox(&MMI_inline_singleline_inputbox, x + xx, y + 2);
        }
    }
    else
#endif /* defined(__MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__) && !(defined(__MMI_MAINLCD_128X128__) || defined(__MMI_MAINLCD_128X160__)) */ 
    {
        if (mmi_fe_get_r2l_state())
        {
            inline_edit_move_singleline_inputbox(&MMI_inline_singleline_inputbox, x + 1, y + list_filler_border);
        }
        else
        {
            inline_edit_move_singleline_inputbox(&MMI_inline_singleline_inputbox, x + xx, y + list_filler_border);
        }
    }
    g_mmi_inline_singleinline_initial_x = MMI_inline_singleline_inputbox.x;
    
    
    input_type_flags = (U32) (i->input_type & (~INPUT_TYPE_MASK));
    input_type = (U32) (i->input_type & INPUT_TYPE_MASK);

    if(flags & INLINE_ITEM_TEXT_EDIT_FIRST_CURSOR)
    {
        wgui_inline_text_edit_move_cursor_to_first(&MMI_inline_singleline_inputbox);
    }

    if(cui_inline_is_current_cui())
    {
        cui_inline_item_replace_gui_buffer(wgui_inline_item_highlighted_index, &wgui_inline_items[wgui_inline_item_highlighted_index], &history_buffer);
    }
    else
    {
        inline_text_edit_set_history(INLINE_TEXT_EDIT_HISTORY_ID, history_buffer);
    }
    

    /* set key handler is depend on  MMI_inline_singleline_inputbox.flags , so we call inline_text_edit_set_history before register key handler.*/
    register_inline_singleline_inputbox_keys();

    saved_inputbox_flags = MMI_inline_singleline_inputbox.flags;


    wgui_inline_singleline_inputbox_decimal_input_mode_flag = 0;
    wgui_inline_singleline_inputbox_decimal_flag = 0;
    
    wgui_inputbox_UCS2_count_function = wgui_inline_singleline_inputbox_get_UCS2_count;
    if (input_type_flags & INPUT_TYPE_USE_ENCODING_BASED_LENGTH)
    {
        MMI_inline_singleline_inputbox.flags |= UI_SINGLE_LINE_INPUT_BOX_USE_ENCODING_BASED_LENGTH;
        if (input_type_flags & INPUT_TYPE_ONE_LESS_CHARACTER)
        {
            MMI_inline_singleline_inputbox.flags |= UI_SINGLE_LINE_INPUT_BOX_ONE_LESS_CHARACTER;
            UI_TEST_UCS2_COUNT_SET_LENGTH_TYPE2(
                MMI_inline_singleline_inputbox.UCS2_count,
                MMI_inline_singleline_inputbox.allocated_length,
                MMI_inline_singleline_inputbox.available_length);
        }
        else
        {
            UI_TEST_UCS2_COUNT_SET_LENGTH(
                MMI_inline_singleline_inputbox.UCS2_count,
                MMI_inline_singleline_inputbox.allocated_length,
                MMI_inline_singleline_inputbox.available_length);
        }
    }
    
    if (MMI_current_input_ext_type & INPUT_TYPE_EXT_ASCII_ENCODING_BASE_LENGTH)
    {
        MMI_inline_singleline_inputbox.flags |= UI_SINGLE_LINE_INPUT_BOX_USE_ASCII_ENCODING_BASE_LENGTH;
        if (input_type_flags & INPUT_TYPE_ONE_LESS_CHARACTER)
        {
            MMI_multiline_inputbox.flags |= UI_SINGLE_LINE_INPUT_BOX_ONE_LESS_CHARACTER;
            UI_TEST_UCS2_COUNT_SET_LENGTH_TYPE2(
                MMI_inline_singleline_inputbox.non_ascii_count,
                MMI_inline_singleline_inputbox.allocated_length,
                MMI_inline_singleline_inputbox.available_length);
        }
        else
        {
            UI_TEST_UCS2_COUNT_SET_LENGTH(
                MMI_inline_singleline_inputbox.non_ascii_count,
                MMI_inline_singleline_inputbox.allocated_length,
                MMI_inline_singleline_inputbox.available_length);
        }
    }

    if (input_type_flags & INPUT_TYPE_GSM_EXTENDED_HANDLING)
    {
        MMI_inline_singleline_inputbox.flags |= UI_SINGLE_LINE_INPUT_BOX_CHECK_GSM_EXTENDED;
    }

    if (plus_character_handling)
    {
        MMI_inline_singleline_inputbox.flags |= UI_SINGLE_LINE_INPUT_BOX_PLUS_CHARACTER_HANDLING;
    }

    /* resize the inputbox so that the border can be drawn to have the
       3D effect in case of default text effect is enabled. */
#if defined(__MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__) && !(defined(__MMI_MAINLCD_128X128__) || defined(__MMI_MAINLCD_128X160__)  || defined(__MMI_MAINLCD_176X220__) || defined(__MMI_MAINLCD_128X64__))       /* 122805 3D inline edit */
    if (IsInlineItemDefaultTextEnable())
    {
        gui_resize_single_line_input_box(&MMI_inline_singleline_inputbox, width - xx - 4, height - 4);
        g_mmi_inline_singleinline_initial_width = MMI_inline_singleline_inputbox.width;
    }
    else
#endif /* defined(__MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__) && !(defined(__MMI_MAINLCD_128X128__) || defined(__MMI_MAINLCD_128X160__)) */ 
    {
        gui_resize_single_line_input_box(&MMI_inline_singleline_inputbox, width - xx - 1, height - (2*list_filler_border));
        g_mmi_inline_singleinline_initial_width = MMI_inline_singleline_inputbox.width;
    }

#ifdef __MMI_FTE_SUPPORT__
    inline_edit_move_singleline_inputbox(&MMI_inline_singleline_inputbox, x, y);
    gui_resize_single_line_input_box(&MMI_inline_singleline_inputbox, width , height);
    MMI_inline_singleline_inputbox.flags |= UI_SINGLE_LINE_INPUT_BOX_STATE_SELECTED;
#endif
#ifndef __MMI_FTE_SUPPORT__
    /* for IME hint */
    ime_width = mmi_imc_get_input_mode_hint_width();
    if (ime_width > 0)
    {
        flags |= INLINE_ITEM_IME_HINT;
    }
    else
    {
        flags &= ~INLINE_ITEM_IME_HINT;
    }

    if (flags & INLINE_ITEM_IME_HINT)
    {
        S32 hint_x1, hint_y1, hint_x2, hint_y2;

        gui_resize_single_line_input_box(&MMI_inline_singleline_inputbox, MMI_inline_singleline_inputbox.width - ime_width, MMI_inline_singleline_inputbox.height);
        if (mmi_fe_get_r2l_state())
        {   
            hint_x1 = inline_text_edit_get_control_x_coordinate(&MMI_inline_singleline_inputbox);
            hint_x2 = hint_x1 + ime_width - 1;
            hint_y1 = inline_text_edit_get_control_y_coordinate(&MMI_inline_singleline_inputbox);
            hint_y2 = hint_y1 + inline_text_edit_get_control_full_height(&MMI_inline_singleline_inputbox) -1;
            inline_edit_move_singleline_inputbox(&MMI_inline_singleline_inputbox, hint_x1 + ime_width, MMI_inline_singleline_inputbox.y);
        }
        else
        {
            hint_x1 = inline_text_edit_get_control_x_coordinate(&MMI_inline_singleline_inputbox) + inline_text_edit_get_control_full_width(&MMI_inline_singleline_inputbox);
            hint_x2 = x + width - 1; /* hint_x1 + ime_width - 1; */
            hint_y1 = inline_text_edit_get_control_y_coordinate(&MMI_inline_singleline_inputbox);
            hint_y2 = hint_y1 + inline_text_edit_get_control_full_height(&MMI_inline_singleline_inputbox) -1;
        }

        gdi_draw_solid_rect(hint_x1, hint_y1, hint_x2, hint_y2, GDI_COLOR_TRANSPARENT);
        mmi_imc_draw_input_mode_hint(hint_x1, hint_y1, hint_x2, hint_y2);
    }
#endif

    if ((saved_inputbox_flags & UI_SINGLE_LINE_INPUT_BOX_MASK_CHARACTERS))
    {
        MMI_inline_singleline_inputbox.flags |= UI_SINGLE_LINE_INPUT_BOX_MASK_CHARACTERS;
    }
    if(flags & INLINE_ITEM_ICON_IN_ITEM)
    {
        S32 temp_height = 0, temp_width = 0;
        wgui_inline_get_default_indicator_width(&temp_width, &temp_height);

        if (mmi_fe_get_r2l_state())
        {
            gui_single_line_input_box_set_callback_area(
                &MMI_inline_singleline_inputbox,
                temp_width,
                temp_height,
                wgui_inline_show_icon_in_singleline,
                0,
                0,
                NULL);
        }
        else
        {
            gui_single_line_input_box_set_callback_area(
                &MMI_inline_singleline_inputbox,
                0,
                0,
                NULL,
                temp_width,
                temp_height,
                wgui_inline_show_icon_in_singleline);
        }
    }
    MMI_inline_singleline_inputbox.flags |= UI_SINGLE_LINE_INPUT_BOX_DISABLE_DRAW;
    gui_show_single_line_input_box(&MMI_inline_singleline_inputbox);          /* show single line input box */
    MMI_inline_singleline_inputbox.flags &= ~UI_SINGLE_LINE_INPUT_BOX_DISABLE_DRAW;
    gui_single_line_input_box_locate_cursor(&MMI_inline_singleline_inputbox);
    if(!mmi_imc_is_connected() || mmi_imc_get_draw())
    {
        show_inline_singleline_inputbox();
    }
    /* Some  App want to set RSK label when disable done */
    if(cui_inline_is_current_cui())
            {
        U16 text_id = g_cui_inline_current_instance->cui_inline_items_softkey[wgui_inline_item_highlighted_index].softkey[MMI_RIGHT_SOFTKEY].string_id;
        if(text_id != CUI_INLINE_SOFTKEY_DEFAULT_VALUE)
        {
            inline_text_edit_APP_Assigned_RSK_label_string = (UI_string_type)GetString(text_id);
        }
    }
    
    inline_text_edit_RSK_label_clear = 0;
    if (inline_text_edit_APP_Assigned_RSK_label_string != NULL)
    {
        inline_text_edit_RSK_label_string = inline_text_edit_APP_Assigned_RSK_label_string;
    }
    set_right_softkey_label(inline_text_edit_RSK_label_string);
    register_right_softkey_handler();

    if (mmi_frm_kbd_is_key_supported(KEY_CLEAR))
    {
        SetKeyHandler(handle_inline_text_edit_right_softkey_down, KEY_CLEAR, KEY_EVENT_DOWN);
        SetKeyHandler(handle_inline_text_edit_right_softkey_long_press, KEY_CLEAR, KEY_LONG_PRESS);
        set_right_softkey_function(handle_inline_text_edit_right_softkey_up, KEY_EVENT_UP);
    }
    inline_singleline_inputbox_input_callback = handle_inline_text_edit_input;
    inline_text_edit_RSK_function = wgui_inline_edit_BACK_function;
    handle_inline_text_edit_input();
    if (gui_single_line_input_box_get_text_length(&MMI_inline_singleline_inputbox) <= 0)
    {
        set_right_softkey_function(register_inline_text_edit_handle_right_softkey_up, KEY_EVENT_DOWN);
		execute_wgui_inline_edit_text_empty();
    }
    else 
    {
        execute_wgui_inline_edit_text_not_empty();
    }
    wgui_inputbox_validation_callback = i->validation_callback;
    MMI_inline_singleline_inputbox.validation_callback = wgui_inline_singleline_inputbox_validation_callback;
    MMI_inline_singleline_inputbox.validation_callback(
                                    MMI_inline_singleline_inputbox.text,
                                    MMI_inline_singleline_inputbox.current_text_p,
                                    MMI_inline_singleline_inputbox.text_length);
    /* key rule. 09.10.17 */
    SetKeyHandler(inline_text_edit_handle_down_arrow, KEY_DOWN_ARROW, KEY_EVENT_REPEAT);
    SetKeyHandler(inline_text_edit_handle_up_arrow, KEY_UP_ARROW, KEY_EVENT_REPEAT);
    SetKeyHandler(inline_text_edit_handle_down_arrow, KEY_VOL_DOWN, KEY_EVENT_REPEAT);
    SetKeyHandler(inline_text_edit_handle_up_arrow, KEY_VOL_UP, KEY_EVENT_REPEAT);
    
    SetKeyHandler(inline_text_edit_handle_down_arrow, KEY_DOWN_ARROW, KEY_EVENT_DOWN);
    SetKeyHandler(inline_text_edit_handle_up_arrow, KEY_UP_ARROW, KEY_EVENT_DOWN);
    SetKeyHandler(inline_text_edit_handle_down_arrow, KEY_VOL_DOWN, KEY_EVENT_DOWN);
    SetKeyHandler(inline_text_edit_handle_up_arrow, KEY_VOL_UP, KEY_EVENT_DOWN);
    redraw_current_inline_item = redraw_inline_singleline_inputbox;
    current_wgui_inline_text_edit_item->UCS2_count = MMI_inline_singleline_inputbox.UCS2_count;

    if(cui_inline_is_current_cui())
    {
       cui_inline_evt_item_activate(); 
    }
    else
    {
        if (i->custom_setup_function != NULL)
        {
            i->custom_setup_function();
        }
    }

    if (input_type == IMM_INPUT_TYPE_DECIMAL_NUMERIC ||
        input_type == IMM_INPUT_TYPE_SIGNED_DECIMAL_NUMERIC)
    {
        wgui_inline_singleline_inputbox_decimal_input_mode_flag = 1;
        if (MMI_inline_singleline_inputbox.text_length > 2)
        {
            S32 i;
            UI_buffer_type t = MMI_inline_singleline_inputbox.text;
            UI_character_type c;
        
            for (i = 0; i < MMI_inline_singleline_inputbox.text_length / 2; i++)
            {
                UI_STRING_GET_NEXT_CHARACTER(t, c);
                if (c == (UI_character_type) '.')
                {
                    wgui_inline_singleline_inputbox_decimal_flag = 1;
                    break;
                }
            }
        }
    }
    MMI_current_input_ext_type |= INPUT_TYPE_EXT_NO_SHOW_NEW_LINE_SYMBOL;

    if (input_type & IMM_INPUT_TYPE_EXT_PASSWORD)
        set_inline_edit_singleline_inputbox_mask(1);
    
    if((flags & INLINE_ITEM_NO_LEADING_ZERO))
    {
        set_leading_zero(0);
    }
    
    UI_UNUSED_PARAMETER(input_type_flags);
    UI_UNUSED_PARAMETER(saved_MMI_current_input_mode);

    /*
     * For IME auto-capitalization, to update input mode by cursor 
     * position, because inline create editor after connecting IME
     */
    mmi_imc_update_input_mode_by_cursor_pos();

    mmi_imc_redraw_screen_by_state();

}

/*****************************************************************************
 * FUNCTION
 *  mmi_input_box_msg_call_back_inline_text
 * DESCRIPTION
 *  message call back for inline text 
 * PARAMETERS
 *  editor_ptr        [IN]         pointer of single_line_input_box
 *  msg_ptr           [IN]         message pointer
 * RETURNS
 *  U32
 *****************************************************************************/
static U32 mmi_input_box_msg_call_back_inline_text(single_line_input_box  * editor_ptr, mmi_imc_message_struct_p msg_ptr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    S32 i, str_len, total_len = 0;


    S32 hint_x1, hint_y1, hint_x2, hint_y2;


    U32 lresult = 0;
    UI_string_type temp_str;
    UI_character_type ch; 
#if defined(__MMI_TOUCH_SCREEN__)
    gui_single_line_input_box_pen_enum single_line_input_box_event;
    MMI_BOOL ret = MMI_FALSE;
#endif
    UI_character_type first_char;
    UI_character_type second_char;
    UI_buffer_type p;
    UI_character_type c;

    U32 old_show_action_flag;
#ifdef __MMI_CLIPBOARD__
    UI_buffer_type cut_cursor_p = NULL;
#endif /* __MMI_CLIPBOARD__ */

#ifdef __MMI_EDITOR_SSP_SUPPORT__
    MMI_BOOL is_ssp = MMI_FALSE;
#endif /* __MMI_EDITOR_SSP_SUPPORT__ */
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    MMI_ASSERT(editor_ptr == &MMI_inline_singleline_inputbox);

    switch(msg_ptr->message_id)
    {
    case MMI_IMC_MESSAGE_INSERT_CHAR:
        
        lresult = inline_edit_singleline_inputbox_direct_input((UI_character_type)msg_ptr->param_0);
        if (lresult == 0)
        {
            gui_single_line_input_box_locate_cursor(&MMI_inline_singleline_inputbox);
            redraw_inline_singleline_inputbox();
        }
        break;
        
    case MMI_IMC_MESSAGE_INSERT_STRING:
    case MMI_IMC_MESSAGE_INSERT_STRING_NO_DRAW:    
        /* Need to revise */
        temp_str = (UI_string_type)msg_ptr->param_0;
        
        str_len = (S32)mmi_ucs2strlen((const S8 *)temp_str);

        old_show_action_flag = editor_ptr->show_action_flag;
        
        editor_ptr->show_action_flag = 0;

        for (i = 0; i < str_len; i++)
        {
            if (inline_edit_singleline_inputbox_direct_input_no_draw((UI_character_type)temp_str[i]))
            {
                total_len ++;
            }
            else
            {
                break;
            }
        }

        editor_ptr->show_action_flag = old_show_action_flag;

        gui_single_line_input_box_locate_cursor(&MMI_inline_singleline_inputbox);

        if (!gui_screen_smooth_scrolling_moved_by_pen())
        {
        redraw_inline_singleline_inputbox();
        }
        inline_singleline_inputbox_input_callback();
    
        lresult = total_len;
        
        break;

    case MMI_IMC_MESSAGE_INSERT_PAIRED_SYMBOLS:
        temp_str = (UI_string_type)msg_ptr->param_0;
        
        str_len = (S32)mmi_ucs2strlen((const S8 *)temp_str);

        for (i = 0; i < str_len; i++)
        {
            if (inline_edit_singleline_inputbox_direct_input_no_draw((UI_character_type)temp_str[i]))
            {
                total_len ++;
            }
            else
            {
                break;
            }
        }
        
        if (!gui_screen_smooth_scrolling_moved_by_pen())
        {
        redraw_inline_singleline_inputbox();
        }
        inline_singleline_inputbox_input_callback();
        
        if (total_len == str_len)
        {
            inline_edit_singleline_inputbox_previous_character();
            lresult = MMI_TRUE;
        }
        else
        {
            lresult = MMI_FALSE;
        }    
        
        break;
        
    case MMI_IMC_MESSAGE_REPLACE_HIGHLIGHT_STRING:
        
        for (i = 0; i < (S32)msg_ptr->param_0; i ++)
        {
            inline_edit_singleline_inputbox_delete_character_no_draw();
        }
        
        temp_str = (UI_string_type)msg_ptr->param_1;
        
        str_len = (S32)mmi_ucs2strlen((const S8 *)temp_str);

        old_show_action_flag = editor_ptr->show_action_flag;

        editor_ptr->show_action_flag = 0;

        for (i = 0; i < str_len; i++)
        {
            if (inline_edit_singleline_inputbox_direct_input_no_draw((UI_character_type)temp_str[i]))
            {
                total_len ++;
            }
            else
            {
                break;
            }
        }

        editor_ptr->show_action_flag = old_show_action_flag;

        if (total_len)
        {
            g_is_inline_text_highlighted = MMI_TRUE;
            editor_ptr->flags |= UI_SINGLE_LINE_INPUT_BOX_WORD_HIGHLIGHT;
            gui_single_line_input_box_highlight_cursor_number(editor_ptr, (S32)total_len);
        }
        else
        {
            /* if no character gets inserted , no character will be highlighted*/
            editor_ptr->flags &= ~UI_SINGLE_LINE_INPUT_BOX_WORD_HIGHLIGHT;
            g_is_inline_text_highlighted = MMI_FALSE;
        }
        
		if (!gui_screen_smooth_scrolling_moved_by_pen())
        {
        redraw_inline_singleline_inputbox();
        }
        inline_singleline_inputbox_input_callback();
        
        lresult = total_len;
        
        break;

    case MMI_IMC_MESSAGE_INSERT_SPACE:
        inline_edit_singleline_inputbox_direct_input((UI_character_type)(0x20));
        break;                
    case MMI_IMC_MESSAGE_DELETE_STRING:
        old_show_action_flag = editor_ptr->show_action_flag;
        
        editor_ptr->show_action_flag = 0;

        for (i = 0; i < (S32)msg_ptr->param_0; i ++)
        {
            inline_edit_singleline_inputbox_delete_character_no_draw();
        }

        editor_ptr->show_action_flag = old_show_action_flag;

        if (!gui_screen_smooth_scrolling_moved_by_pen())
        {
        redraw_inline_singleline_inputbox();
        }
        inline_singleline_inputbox_input_callback();
        break;
        
    case MMI_IMC_MESSAGE_INSERT_MULTITAP_CHAR:
        ch = (UI_character_type)msg_ptr->param_0;
        lresult = inline_edit_singleline_inputbox_multitap_input(ch);
        break;
#ifdef __MMI_MULTIGRAPH_SUPPORT__
    case MMI_IMC_MESSAGE_INSERT_MULTITAP_STRING:
        temp_str = (UI_string_type)msg_ptr->param_0;
        /* Insert the string in editor */
        lresult = inline_edit_singleline_inputbox_multitap_input_string((PU8)temp_str);
        break;
#endif		

    case MMI_IMC_MESSAGE_RESET_MULTITAP_STATE:
        inline_edit_singleline_inputbox_multitap_input_complete();
        gui_single_line_input_box_stop_input(editor_ptr);
        break;

    case MMI_IMC_MESSAGE_GET_PREVIOUS_CHAR:
        lresult = gui_single_line_input_box_get_previous_character(editor_ptr, (UI_character_type *)msg_ptr->param_0);
        break;

    case MMI_IMC_MESSAGE_STOP_SMART_ALPHABETIC:
        gui_single_line_input_box_stop_input(editor_ptr);
        break;
    case MMI_IMC_MESSAGE_START_SMART_ALPHABETIC:
        gui_single_line_input_box_start_input(editor_ptr);
        break;
        
    case MMI_IMC_MESSAGE_MOVE_CURSOR_TO_HIGHLIGHT_START:
        if (editor_ptr->flags & UI_SINGLE_LINE_INPUT_BOX_WORD_HIGHLIGHT)
        {
            UI_buffer_type words_start_p = editor_ptr->highlight_start_position;
            UI_character_type c;
            
            editor_ptr->current_text_p = words_start_p;
            
            gui_single_line_input_box_locate_cursor(editor_ptr);
            
            while (words_start_p > editor_ptr->text) /* Go to the end of the previous word */
            {
                c = (UI_character_type)((*((words_start_p - 2)+0))|((*((words_start_p - 2)+1))<<8));

                if (c == 0x20) 
                {
                    gui_single_line_input_box_previous(editor_ptr);

                    words_start_p = editor_ptr->current_text_p;
                }
                else
                {
                    break;
                }
            }

            lresult = 1;
        }
        break;
        
    case MMI_IMC_MESSAGE_IS_OVERWRITE_MODE:
        if (editor_ptr->flags & UI_SINGLE_LINE_INPUT_BOX_MASK_CHARACTERS)
        {
            lresult = MMI_TRUE;
        }
        else
        {
            lresult = MMI_FALSE;
        }    
        break;
    case MMI_IMC_MESSAGE_IS_THERE_CURSOR:
        if (editor_ptr->flags & UI_SINGLE_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW)
        {
            lresult = MMI_FALSE;
        }
        else
        {
            lresult = MMI_TRUE;
        }
        break;    
    case MMI_IMC_MESSAGE_DELETE_CHAR:

        if (gui_single_line_input_box_get_text_length(editor_ptr) != 0)
        {
            U16 keyCode, keyType;
            mmi_frm_get_key_info(&keyCode, &keyType);
            if (keyType == KEY_REPEAT)
            {
                wgui_inputs_fast_del_nav_handler(WGUI_INPUTS_OPER_FAST_DEL, WGUI_INPUTS_EDITOR_INLINE_SL, WGUI_INPUTS_KPD_REPEAT_PERIOD);
            }
            else
            {
                for (i = 0; i < (S32)msg_ptr->param_0; i++)
                {
                    inline_edit_singleline_inputbox_delete_character_no_draw();
                }

                if (!gui_screen_smooth_scrolling_moved_by_pen())
                {
                redraw_inline_singleline_inputbox();
                }
                inline_singleline_inputbox_input_callback();
            }
        }
        else
        {
            UI_editor_play_tone_cannot_change();
        }
        break;
        
    case MMI_IMC_MESSAGE_GET_TEXT_LENGTH:
        lresult = (U32)(editor_ptr->text_length / ENCODING_LENGTH);
        break;

    case MMI_IMC_MESSAGE_DRAW_IME_HINT:
        {
            S32 ime_width;
            MMI_BOOL is_resized = MMI_FALSE;

            ime_width = mmi_imc_get_input_mode_hint_width();

            if (ime_width > 0)
            {
                if (g_mmi_inline_singleinline_initial_width - ime_width != (U32)(MMI_inline_singleline_inputbox.width))
                {
                    gui_resize_single_line_input_box(&MMI_inline_singleline_inputbox, g_mmi_inline_singleinline_initial_width - ime_width, MMI_inline_singleline_inputbox.height);
                    is_resized = MMI_TRUE; 
                }

            if (mmi_fe_get_r2l_state())
            {   
                MMI_inline_singleline_inputbox.x = g_mmi_inline_singleinline_initial_x;
                hint_x1 = inline_text_edit_get_control_x_coordinate(&MMI_inline_singleline_inputbox);
                    hint_x2 = hint_x1 + ime_width - 1;
                hint_y1 = inline_text_edit_get_control_y_coordinate(&MMI_inline_singleline_inputbox);
                hint_y2 = hint_y1 + inline_text_edit_get_control_full_height(&MMI_inline_singleline_inputbox) -1;
                inline_edit_move_singleline_inputbox(&MMI_inline_singleline_inputbox, hint_x1 + ime_width, MMI_inline_singleline_inputbox.y);
            }
            else
            {
                hint_x1 = inline_text_edit_get_control_x_coordinate(&MMI_inline_singleline_inputbox) + inline_text_edit_get_control_full_width(&MMI_inline_singleline_inputbox);
                hint_x2 = hint_x1 + ime_width - 1; /* hint_x1 + ime_width - 1; */
                hint_y1 = inline_text_edit_get_control_y_coordinate(&MMI_inline_singleline_inputbox);
                hint_y2 = hint_y1 + inline_text_edit_get_control_full_height(&MMI_inline_singleline_inputbox) -1;
            }
            
            gdi_draw_solid_rect(hint_x1, hint_y1, hint_x2, hint_y2, GDI_COLOR_TRANSPARENT);
            mmi_imc_draw_input_mode_hint(hint_x1, hint_y1, hint_x2, hint_y2);

                if (is_resized)
                {
                    redraw_inline_singleline_inputbox();
                }
            }

        }
        break;


    case MMI_IMC_MESSAGE_CLEAR_ALL:
    #ifdef __MMI_TOUCH_SCREEN__
        wgui_inputs_fast_del_pen_handler(WGUI_INPUTS_OPER_FAST_DEL, WGUI_INPUTS_EDITOR_INLINE_SL, MMI_PEN_EVENT_LONG_TAP);
    #else
        wgui_inputs_fast_del_nav_reset_repeat_count();
    #endif

        break;

    case MMI_IMC_MESSAGE_BACKSPACE_KEY_EVENT:
    #ifdef __MMI_TOUCH_SCREEN__
        wgui_inputs_fast_del_pen_handler(WGUI_INPUTS_OPER_FAST_DEL, WGUI_INPUTS_EDITOR_INLINE_SL, (mmi_pen_event_type_enum)msg_ptr->param_0);
    #endif
        break;
    
    case MMI_IMC_MESSAGE_IS_EDITOR_EMPTY:
        if (MMI_inline_singleline_inputbox.text_length <= 2)
        {
            lresult = MMI_TRUE;
        }
        else
        {
            lresult = MMI_FALSE;
        }
        break;
    case MMI_IMC_MESSAGE_REDRAW:
        
        MMI_inline_singleline_inputbox.flags = g_is_inline_text_flags;

        if (g_is_inline_text_highlighted)
        {
            editor_ptr->flags |= UI_SINGLE_LINE_INPUT_BOX_WORD_HIGHLIGHT;
        }
        else
            {
            editor_ptr->flags &= ~UI_SINGLE_LINE_INPUT_BOX_WORD_HIGHLIGHT;
            }
        
        editor_ptr->current_text_p = editor_ptr->text + g_inline_text_current_position;
        editor_ptr->text_offset_x = g_inline_text_text_offset_x;
        editor_ptr->available_length = g_inline_text_available_length;
        editor_ptr->input_start_cursor_p = g_inline_text_input_start_cursor_p;
        editor_ptr->input_mode_cursor_p = g_inline_text_input_mode_cursor_p;
        editor_ptr->highlight_start_position = g_inline_text_input_highlight_start_position;
        editor_ptr->highlight_end_position = g_inline_text_input_highlight_end_position;
        editor_ptr->last_cursor_offset = g_inline_text_input_last_cursor_offset;

        MMI_inline_singleline_inputbox.flags |= UI_SINGLE_LINE_INPUT_BOX_DISABLE_DRAW;
        gui_show_single_line_input_box(&MMI_inline_singleline_inputbox);          /* show single line input box */
        MMI_inline_singleline_inputbox.flags &= ~UI_SINGLE_LINE_INPUT_BOX_DISABLE_DRAW;
        gui_single_line_input_box_locate_cursor(&MMI_inline_singleline_inputbox);
        gui_push_clip();
        gui_set_clip_preset(MMI_fixed_list_menu.x, MMI_fixed_list_menu.y, MMI_fixed_list_menu.x + MMI_fixed_list_menu.width - 1, MMI_fixed_list_menu.y + MMI_fixed_list_menu.height - 1);
        show_inline_singleline_inputbox();
        gui_pop_clip();
        break;
        
    case MMI_IMC_MESSAGE_HILIGHT_BFCURSOR:
        g_is_inline_text_highlighted = MMI_TRUE;
        editor_ptr->flags |= UI_SINGLE_LINE_INPUT_BOX_WORD_HIGHLIGHT;
        gui_single_line_input_box_highlight_cursor_number(editor_ptr, (S32)msg_ptr->param_0);
        redraw_inline_singleline_inputbox();
        break;
        
    case MMI_IMC_MESSAGE_CLEAR_HILIGHT:
        editor_ptr->flags &= ~UI_SINGLE_LINE_INPUT_BOX_WORD_HIGHLIGHT;
        g_is_inline_text_highlighted = MMI_FALSE;
        redraw_inline_singleline_inputbox();
        break;
    
    case MMI_IMC_MESSAGE_GET_CURSOR_RECT:
        ((mmi_imc_rect_p)msg_ptr->param_0)->x = UI_cursor_x1;
        ((mmi_imc_rect_p)msg_ptr->param_0)->y = UI_cursor_y1;
        ((mmi_imc_rect_p)msg_ptr->param_0)->width = UI_cursor_x2 - UI_cursor_x1 + 1;
        ((mmi_imc_rect_p)msg_ptr->param_0)->height = UI_cursor_y2 - UI_cursor_y1 + 1;
        lresult = MMI_TRUE;
        break;
        
    case MMI_IMC_MESSAGE_MOVE_CURSOR:
        switch (msg_ptr->param_0)
        {
            case MMI_IMC_EDITOR_CURSOR_UP:
                for (i = 0; i <(S32)msg_ptr->param_1; i ++)
                {
                    inline_text_edit_handle_up_arrow();
                }
                break;
                
            case MMI_IMC_EDITOR_CURSOR_DOWN:
                for (i = 0; i <(S32)msg_ptr->param_1; i ++)
                {
                    inline_text_edit_handle_down_arrow();
                }
                break;
                
            case MMI_IMC_EDITOR_CURSOR_LEFT:
                for (i = 0; i <(S32)msg_ptr->param_1; i ++)
                {
                    inline_edit_singleline_inputbox_previous_character();
                }
                break;
            case MMI_IMC_EDITOR_CURSOR_RIGHT:
                for (i = 0; i <(S32)msg_ptr->param_1; i ++)
                {
                    inline_edit_singleline_inputbox_next_character();
                }
                break;
        }
        break;
        
#if defined(__MMI_TOUCH_SCREEN__)        
    case MMI_IMC_MESSAGE_PEN_EVENT:

#ifdef __MMI_EDITOR_SSP_SUPPORT__
        is_ssp = gui_input_box_ssp_is_scrolling();
#endif /* __MMI_EDITOR_SSP_SUPPORT__ */
        
        ret = (MMI_BOOL)gui_single_line_input_box_translate_pen_event(
                        editor_ptr,
                        ((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->mmi_pen_event,
                        ((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos.x,
                        ((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos.y,
                        &single_line_input_box_event);
        if (ret)
        {
            ((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->editor_pen_event = (mmi_imc_editor_pen_event_enum)single_line_input_box_event;
            
            if (((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->mmi_pen_event == MMI_PEN_EVENT_UP)
            {
#ifdef __MMI_EDITOR_SSP_SUPPORT__
                if (!is_ssp)
#endif /* __MMI_EDITOR_SSP_SUPPORT__ */
                {
                    gui_show_single_line_input_box_ext(editor_ptr, 
                                              ((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos.x, 
                                              ((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos.y);
            
                    gui_single_line_input_box_locate_cursor(editor_ptr);
					gui_push_clip();
					gui_set_clip_preset(MMI_fixed_list_menu.x, MMI_fixed_list_menu.y, MMI_fixed_list_menu.x + MMI_fixed_list_menu.width - 1, MMI_fixed_list_menu.y + MMI_fixed_list_menu.height - 1);
                    show_inline_singleline_inputbox();
					gui_pop_clip();
                }
            }
            else if (((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->mmi_pen_event == MMI_PEN_EVENT_LONG_TAP ||
                     ((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->mmi_pen_event == MMI_PEN_EVENT_DOWN)
            {
                *((U32 *)msg_ptr->param_1) = 1;
            }
        }
        
        lresult = ret;
        
        break;
#endif

    case MMI_IMC_MESSAGE_SET_MASK:
		gui_push_clip();
		gui_set_clip_preset(MMI_fixed_list_menu.x, MMI_fixed_list_menu.y, MMI_fixed_list_menu.x + MMI_fixed_list_menu.width - 1, MMI_fixed_list_menu.y + MMI_fixed_list_menu.height - 1);
        set_inline_edit_singleline_inputbox_mask(1);
		gui_pop_clip();
        break;    
    case MMI_IMC_MESSAGE_IS_EDITOR_IN_REPLACE_MODE:
    case MMI_IMC_MESSAGE_CHECK_MULTITAP_STATE:
        if (editor_ptr->flags & UI_SINGLE_LINE_INPUT_BOX_STATE_MULTITAP)
            lresult = MMI_TRUE;
        break;
    case MMI_IMC_MESSAGE_DECIMAL_INPUT:
        wgui_inline_singleline_inputbox_decimal_input_mode_flag = 1;
        break;
    case MMI_IMC_MESSAGE_INSERT_DECIMAL_SYMBOL:    
        first_char = editor_ptr->text[0] | (editor_ptr->text[1] << 8);
        second_char = editor_ptr->text[2] | (editor_ptr->text[3] << 8);
        if (wgui_inline_singleline_inputbox_decimal_flag)
        {
            UI_editor_play_tone_invalid_data();
            break;
        }
        
        if (gui_single_line_input_box_test_first_position(editor_ptr) ||
            (first_char == (UI_character_type)'-' && second_char == NULL))
        {
            if (gui_single_line_input_box_get_remaining_length(editor_ptr) < 2)
            {
                UI_editor_play_tone_invalid_data();
                break;
            }

               gdi_layer_lock_frame_buffer();

            inline_edit_singleline_inputbox_direct_input((UI_character_type) '.');
            if (!gui_single_line_input_box_test_first_position(editor_ptr))
            {
                gui_single_line_input_box_previous(editor_ptr);
                inline_edit_singleline_inputbox_direct_input((UI_character_type) '0');
                gui_single_line_input_box_next(editor_ptr);
            }

            gdi_layer_unlock_frame_buffer();
            redraw_inline_singleline_inputbox();
        }
        else
            inline_edit_singleline_inputbox_direct_input((UI_character_type) '.');
        
        p = editor_ptr->current_text_p;
        if (p != editor_ptr->text)
        {
            UI_STRING_GET_PREVIOUS_CHARACTER(p, c);
            if (c == (UI_character_type) '.')
            {
                wgui_inline_singleline_inputbox_decimal_flag = 1;
            }
        }        
        break;
    case MMI_IMC_MESSAGE_DECIAML_CHECK:
        wgui_inline_singleline_inputbox_decimal_flag = 0;
        if (editor_ptr->text_length > 2)
        {
            S32 i;
            UI_buffer_type t = editor_ptr->text;
            UI_character_type c;
        
            for (i = 0; i < editor_ptr->text_length; i++)
            {
                UI_STRING_GET_NEXT_CHARACTER(t, c);
                if (c == (UI_character_type) '.')
                {
                    wgui_inline_singleline_inputbox_decimal_flag = 1;
                    break;
                }
            }
        }
        break;
    case MMI_IMC_MESSAGE_SET_KEY:
        inline_text_edit_RSK_label_clear = 0;
        g_inline_is_no_redraw_status = 1;
        handle_inline_text_edit_input();
        g_inline_is_no_redraw_status = 0;
        register_inline_singleline_inputbox_keys();
         /* key rule. 09.10.17 */
        SetKeyHandler(inline_text_edit_handle_down_arrow, KEY_DOWN_ARROW, KEY_EVENT_REPEAT);
        SetKeyHandler(inline_text_edit_handle_up_arrow, KEY_UP_ARROW, KEY_EVENT_REPEAT);
         
        SetKeyHandler(inline_text_edit_handle_down_arrow, KEY_DOWN_ARROW, KEY_EVENT_DOWN);
        SetKeyHandler(inline_text_edit_handle_up_arrow, KEY_UP_ARROW, KEY_EVENT_DOWN);

        SetKeyHandler(inline_text_edit_handle_down_arrow, KEY_VOL_DOWN, KEY_EVENT_REPEAT);
        SetKeyHandler(inline_text_edit_handle_up_arrow, KEY_VOL_UP, KEY_EVENT_REPEAT);
        SetKeyHandler(inline_text_edit_handle_down_arrow, KEY_VOL_DOWN, KEY_EVENT_DOWN);
        SetKeyHandler(inline_text_edit_handle_up_arrow, KEY_VOL_UP, KEY_EVENT_DOWN);
        break;
    case MMI_IMC_MESSAGE_CHECK_CSK_ENABLE:
        lresult = MMI_TRUE;
        break;
    case MMI_IMC_MESSAGE_CHECK_INFO_BAR_ENABL:
        lresult = MMI_FALSE;
        break;
    case MMI_IMC_MESSAGE_CHECK_FLOAT:
            lresult = wgui_inline_singleline_inputbox_decimal_flag;
        break;
    case MMI_IMC_MESSAGE_SET_MULTITAP_STATE:
        editor_ptr->flags |= UI_SINGLE_LINE_INPUT_BOX_STATE_MULTITAP;
        break;
    case MMI_IMC_MESSAGE_WCSS_CHECK:
        lresult = MMI_FALSE;
        break;
    case MMI_IMC_MESSAGE_GET_HIGHLIGHT_WORD:
        if (editor_ptr->flags & UI_SINGLE_LINE_INPUT_BOX_WORD_HIGHLIGHT)
        {
            *((UI_buffer_type *)(msg_ptr->param_0)) = editor_ptr->highlight_start_position;
            *((UI_buffer_type *)(msg_ptr->param_1)) = editor_ptr->highlight_end_position;
            lresult = (U32)((editor_ptr->highlight_end_position - editor_ptr->highlight_start_position) / ENCODING_LENGTH);
        }
        else
        {
            *((UI_buffer_type *)(msg_ptr->param_0)) = 0;
            *((UI_buffer_type *)(msg_ptr->param_1)) = 0;
            lresult = 0;
        }
        break;
    case MMI_IMC_MESSAGE_GET_TEXT_PTR_BEFORE_CANDIDATE:
        
        if (editor_ptr->flags & UI_SINGLE_LINE_INPUT_BOX_STATE_MULTITAP)
        {
            *((U8 **)(msg_ptr->param_1)) = (U8 *)editor_ptr->current_text_p - 2;
        }
        else if (editor_ptr->flags & UI_SINGLE_LINE_INPUT_BOX_WORD_HIGHLIGHT)
        {
            *((U8 **)(msg_ptr->param_1)) = (U8 *)editor_ptr->highlight_start_position;
        }
        else
        {
            *((U8 **)(msg_ptr->param_1)) = (U8 *)editor_ptr->current_text_p;
        }

        *((U8 **)(msg_ptr->param_0)) = (U8 *)editor_ptr->text;
        break;
        
    case MMI_IMC_MESSAGE_GET_TEXT_PTR_BEFORE_CURSOR:
        *((U8 **)(msg_ptr->param_1)) = (U8 *)editor_ptr->current_text_p;

        *((U8 **)(msg_ptr->param_0)) = (U8 *)editor_ptr->text;
        break;
        
    case MMI_IMC_MESSAGE_GET_STRING_BEFORE_CANDIDATE:
        if (editor_ptr->flags & UI_SINGLE_LINE_INPUT_BOX_STATE_MULTITAP)
        {
            UI_string_type buf = (UI_string_type)msg_ptr->param_1;
            UI_buffer_type backup_cursor_p = editor_ptr->current_text_p;
            
            i = 0;
            
            editor_ptr->current_text_p = editor_ptr->input_start_cursor_p;
            while (msg_ptr->param_0 )
            {
                if (gui_single_line_input_box_get_previous_character(editor_ptr, (UI_character_type*)&buf[i]))
                {
                    msg_ptr->param_0 --;
                    i ++;
                    editor_ptr->current_text_p -= ENCODING_LENGTH;
                }
                else
                {
                    break;
                }
            }
            editor_ptr->current_text_p = backup_cursor_p;
            return i;
        }
        else if (editor_ptr->flags & UI_SINGLE_LINE_INPUT_BOX_WORD_HIGHLIGHT &&
            editor_ptr->flags & UI_SINGLE_LINE_INPUT_BOX_INPUT_METHOD_MODE)
        {
            UI_string_type buf = (UI_string_type)msg_ptr->param_1;
            UI_buffer_type cursor_backup_p = editor_ptr->current_text_p;
            /* move cursor to the begining of the highlight */
            editor_ptr->current_text_p = editor_ptr->highlight_start_position;
            i = 0;
            while (msg_ptr->param_0 )
            {
                if (gui_single_line_input_box_get_previous_character(editor_ptr, (UI_character_type *)&buf[i]))
                {
                    msg_ptr->param_0 --;
                    i ++;
                    editor_ptr->current_text_p -= ENCODING_LENGTH;
                }
                else
                {
                    break;
                }
            }
            /* restore cursor to the begining of the highlight */
            editor_ptr->current_text_p = cursor_backup_p;
            return i;
        }
        else
        {
            UI_string_type buf = (UI_string_type)msg_ptr->param_1;
            UI_buffer_type cursor_backup_p = editor_ptr->current_text_p;
            i = 0;
            while (msg_ptr->param_0 )
            {
                if (gui_single_line_input_box_get_previous_character(editor_ptr, (UI_character_type *)&buf[i]))
                {
                    msg_ptr->param_0 --;
                    i ++;
                    editor_ptr->current_text_p -= ENCODING_LENGTH;
                }
                else
                {
                    break;
                }
            }
            editor_ptr->current_text_p = cursor_backup_p;
            return i;
        }
    case MMI_IMC_MESSAGE_INSERT_CHAR_AT_DESIRED_POSITION:
        inline_edit_singleline_inputbox_direct_input_in_pos((UI_character_type)msg_ptr->param_1, msg_ptr->param_0);
        break;
    case MMI_IMC_MESSAGE_DELETE_CHAR_AT_DESIRED_POSITION:
        inline_edit_singleline_inputbox_delete_in_pos(msg_ptr->param_0);     
        break;
    case MMI_IMC_MESSAGE_GET_CHAR_AT_DESIRED_POSITION:
        lresult = editor_ptr->text[msg_ptr->param_0];
        break;
#ifdef __MMI_CLIPBOARD__

#if defined(__MMI_TOUCH_SCREEN__)
    case MMI_IMC_MESSAGE_CLIPBOARD_LOCATE_CURSOR_P_BY_POS:
        ret = (MMI_BOOL)gui_single_line_input_box_translate_pen_event(
                            editor_ptr,
                            ((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->mmi_pen_event,
                            ((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos.x,
                            ((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos.y,
                            &single_line_input_box_event);
        if (ret)
        {
            ((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->editor_pen_event = (mmi_imc_editor_pen_event_enum)single_line_input_box_event;
        //    if (GUI_SINGLE_LINE_INPUT_BOX_PEN_SCROLL_BAR != single_line_input_box_event)
            {
                gui_show_single_line_input_box_ext(editor_ptr, 
                                           ((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos.x, 
                                           ((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos.y);
                if (((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->mmi_pen_event == MMI_PEN_EVENT_LONG_TAP)
                {
                    ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_1)->ccp_start_cursor_p = editor_ptr->current_text_p;
                }
                else if (((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->mmi_pen_event == MMI_PEN_EVENT_MOVE)
                {
                    ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_1)->ccp_end_cursor_p = editor_ptr->current_text_p;
                    /* Caculate the highlight text length */
                    ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_1)->highlight_text_length =
                        (((mmi_imc_clipboard_data_struct_p)msg_ptr->param_1)->ccp_end_cursor_p -
                        ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_1)->ccp_start_cursor_p) / ENCODING_LENGTH;
                }
                else if (((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->mmi_pen_event == MMI_PEN_EVENT_UP &&
                         ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_1)->ccp_end_cursor_p)
                {
                    editor_ptr->current_text_p = ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_1)->ccp_end_cursor_p;
                }
            }

            if ((((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->mmi_pen_event != MMI_PEN_EVENT_LONG_TAP) &&
                (((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->mmi_pen_event != MMI_PEN_EVENT_UP))
            {
                /* Adjust editor view when out of boundary */
                if (((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos.x < (editor_ptr->x + WGUI_INPUTS_ADJUST_VIEW_OFFSET))
                {
                    editor_ptr->text_offset_x += WGUI_INPUTS_ADJUST_VIEW_OFFSET;
                }
                else if (((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos.x > (editor_ptr->x + editor_ptr->width - WGUI_INPUTS_ADJUST_VIEW_OFFSET))
                {
                    editor_ptr->text_offset_x -= WGUI_INPUTS_ADJUST_VIEW_OFFSET;
                }
                if (editor_ptr->text_offset_x > 0 || editor_ptr->width >= editor_ptr->text_width)
                {
                    editor_ptr->text_offset_x = 0;
                }
                else if (editor_ptr->text_offset_x < (editor_ptr->width - editor_ptr->text_width) && (editor_ptr->width < editor_ptr->text_width))
                {
                    editor_ptr->text_offset_x = editor_ptr->width - editor_ptr->text_width;
                }

                gui_single_line_input_box_locate_cursor(editor_ptr);
            }
        }
        break;

    case MMI_IMC_MESSAGE_CLIPBOARD_ADJUST_VIEW:
        if (((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos.x < editor_ptr->x)
        {
            gui_single_line_input_box_previous(editor_ptr);
            ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_1)->ccp_end_cursor_p = editor_ptr->current_text_p;
            ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_1)->highlight_text_length =
                (((mmi_imc_clipboard_data_struct_p)msg_ptr->param_1)->ccp_end_cursor_p -
                ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_1)->ccp_start_cursor_p) / ENCODING_LENGTH;
        }
        else if (((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos.x > (editor_ptr->x + editor_ptr->width))
        {
            gui_single_line_input_box_next(editor_ptr);
            ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_1)->ccp_end_cursor_p = editor_ptr->current_text_p;
            ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_1)->highlight_text_length =
                (((mmi_imc_clipboard_data_struct_p)msg_ptr->param_1)->ccp_end_cursor_p -
                ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_1)->ccp_start_cursor_p) / ENCODING_LENGTH;
        }
        break;
#endif /* __MMI_TOUCH_SCREEN__ */

    case MMI_IMC_MESSAGE_CLIPBOARD_INSERT_STRING_WITH_LENGTH:
        lresult = wgui_inline_sl_insert_string((UI_string_type)msg_ptr->param_0, (U32)msg_ptr->param_1, MMI_TRUE);
        break;

    case MMI_IMC_MESSAGE_CLIPBOARD_SET_START_CURSOR_P:
        ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_0)->ccp_start_cursor_p = editor_ptr->current_text_p;
        break;

    case MMI_IMC_MESSAGE_CLIPBOARD_MARK_TEXT:
        if (((mmi_imc_clipboard_data_struct_p)msg_ptr->param_0)->highlight_text_length > 0)
        {
            editor_ptr->highlight_start_position = ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_0)->ccp_start_cursor_p;
            editor_ptr->highlight_end_position = ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_0)->ccp_end_cursor_p;
            editor_ptr->flags |= UI_SINGLE_LINE_INPUT_BOX_WORD_HIGHLIGHT;
        #ifdef __MMI_CLIPBOARD_FLOATING_MENU__   
            dm_imui_window_hide();
        #else
		    gui_push_clip();
		    gui_set_clip_preset(MMI_fixed_list_menu.x, MMI_fixed_list_menu.y, MMI_fixed_list_menu.x + MMI_fixed_list_menu.width - 1, MMI_fixed_list_menu.y + MMI_fixed_list_menu.height - 1);
            show_inline_singleline_inputbox();
			gui_pop_clip();
        #endif
        }
        else if (((mmi_imc_clipboard_data_struct_p)msg_ptr->param_0)->highlight_text_length < 0)
        {
            editor_ptr->highlight_start_position = ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_0)->ccp_end_cursor_p;
            editor_ptr->highlight_end_position = ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_0)->ccp_start_cursor_p;
            editor_ptr->flags |= UI_SINGLE_LINE_INPUT_BOX_WORD_HIGHLIGHT;
        #ifdef __MMI_CLIPBOARD_FLOATING_MENU__   
            dm_imui_window_hide();
        #else
		    gui_push_clip();
		    gui_set_clip_preset(MMI_fixed_list_menu.x, MMI_fixed_list_menu.y, MMI_fixed_list_menu.x + MMI_fixed_list_menu.width - 1, MMI_fixed_list_menu.y + MMI_fixed_list_menu.height - 1);
            show_inline_singleline_inputbox();
			gui_pop_clip();
        #endif
        }
        else if ((((mmi_imc_clipboard_data_struct_p)msg_ptr->param_0)->ccp_start_cursor_p) ==
                 (((mmi_imc_clipboard_data_struct_p)msg_ptr->param_0)->ccp_end_cursor_p))
        {
            editor_ptr->highlight_start_position = ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_0)->ccp_start_cursor_p;
            editor_ptr->highlight_end_position = ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_0)->ccp_start_cursor_p;
        #ifdef __MMI_CLIPBOARD_FLOATING_MENU__   
            dm_imui_window_hide();
        #else
		    gui_push_clip();
		    gui_set_clip_preset(MMI_fixed_list_menu.x, MMI_fixed_list_menu.y, MMI_fixed_list_menu.x + MMI_fixed_list_menu.width - 1, MMI_fixed_list_menu.y + MMI_fixed_list_menu.height - 1);
            show_inline_singleline_inputbox();
			gui_pop_clip();
        #endif
        }

        break;

    case MMI_IMC_MESSAGE_CLIPBOARD_SAVE_STATUS:
        ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_0)->pre_highlight_start_cursor_p = editor_ptr->highlight_start_position;
        ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_0)->pre_highlight_end_cursor_p = editor_ptr->highlight_end_position;
        ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_0)->pre_flags = editor_ptr->flags;
        ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_0)->is_saved = 1;

        editor_ptr->flags |= UI_SINGLE_LINE_INPUT_BOX_WORD_HIGHLIGHT;
        editor_ptr->flags &= ~UI_SINGLE_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW;
        editor_ptr->highlight_start_position = NULL;
        editor_ptr->highlight_end_position = NULL;
        editor_ptr->state = GUI_INPUT_BOX_STATE_SELECTING_TEXT;

        g_is_inline_text_highlighted = MMI_TRUE;

        /* To disable Inline SSP when mark text */
    #if defined(__MMI_TOUCH_SCREEN__) && defined(__MMI_FTE_SUPPORT__)
        wgui_pen_reset_pre_hdlr();
    #endif

    #if defined(__MMI_TOUCH_SCREEN__) && defined(__MMI_GESTURES_FRAMEWORK__) 
        mmi_frm_gesture_disable(); 
    #endif

        mmi_imc_clipboard_save_keys();

        break;

    case MMI_IMC_MESSAGE_CLIPBOARD_RESTORE_STATUS:
        editor_ptr->highlight_start_position = ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_0)->pre_highlight_start_cursor_p;
        editor_ptr->highlight_end_position = ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_0)->pre_highlight_end_cursor_p;
        editor_ptr->flags = ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_0)->pre_flags;
        editor_ptr->state = GUI_INPUT_BOX_STATE_IDLE;

        g_is_inline_text_highlighted = MMI_FALSE;

        /* Restore Inline SSP */
    #if defined(__MMI_TOUCH_SCREEN__) && defined(__MMI_FTE_SUPPORT__)
        wgui_pen_restore_pre_hdlr();
    #endif

    #if defined(__MMI_TOUCH_SCREEN__) && defined(__MMI_GESTURES_FRAMEWORK__) 
        mmi_frm_gesture_enable(); 
    #endif
        break;

    case MMI_IMC_MESSAGE_CLIPBOARD_GET_ALL_TEXT:
        *((U8 **)(msg_ptr->param_0)) = editor_ptr->text;
        *((U32 *)msg_ptr->param_1) = editor_ptr->text_length - ENCODING_LENGTH;
        break;
    case MMI_IMC_MESSAGE_CLIPBOARD_GET_HIGHLIGHT_TEXT:
        if (((mmi_imc_clipboard_data_struct_p)msg_ptr->param_0)->highlight_text_length > 0)
        {
            *((U8 **)(msg_ptr->param_1)) = ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_0)->ccp_start_cursor_p;
        }
        else
        {
            *((U8 **)(msg_ptr->param_1)) = ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_0)->ccp_end_cursor_p;
        }
        break;
    case MMI_IMC_MESSAGE_CLIPBOARD_IS_TEXT_HIGHLIGHT:
        if (((mmi_imc_clipboard_data_struct_p)msg_ptr->param_0)->highlight_text_length != 0)
        {
            lresult = 1;
        }
        else
        {
            lresult = 0;
        }
        break;
    
    case MMI_IMC_MESSAGE_CLIPBOARD_GET_EDITOR_TYPE:

        ((mmi_imc_editor_menu_history_data_struct_p)msg_ptr->param_0)->is_read_only = MMI_FALSE;

        ((mmi_imc_editor_menu_history_data_struct_p)msg_ptr->param_0)->is_paging = MMI_FALSE;

        if (editor_ptr->text_length <= ENCODING_LENGTH)
        {
            ((mmi_imc_editor_menu_history_data_struct_p)msg_ptr->param_0)->is_empty = MMI_TRUE;
        }
        else
        {
            ((mmi_imc_editor_menu_history_data_struct_p)msg_ptr->param_0)->is_empty = MMI_FALSE;
        }

        ((mmi_imc_editor_menu_history_data_struct_p)msg_ptr->param_0)->is_wcss = MMI_FALSE;

        if (editor_ptr->flags & UI_SINGLE_LINE_INPUT_BOX_MASK_CHARACTERS)
        {
            ((mmi_imc_editor_menu_history_data_struct_p)msg_ptr->param_0)->is_password = MMI_TRUE;
        }
        else
        {
            ((mmi_imc_editor_menu_history_data_struct_p)msg_ptr->param_0)->is_password = MMI_FALSE;
        }

        lresult = MMI_TRUE;
        break;

    case MMI_IMC_MESSAGE_CLIPBOARD_CUT_HIGHLIGHT_STRING:
         if (msg_ptr->param_1 == 1)
         {
             editor_ptr->current_text_p = ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_0)->ccp_start_cursor_p;
             cut_cursor_p = ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_0)->ccp_end_cursor_p;
         }
         else if (msg_ptr->param_1 == 0)
         {
             cut_cursor_p = ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_0)->ccp_start_cursor_p;
         }
         else if (msg_ptr->param_1 == 3)
         {
             cut_cursor_p = ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_0)->ccp_end_cursor_p;
             editor_ptr->current_text_p = cut_cursor_p + WGUI_INPUTS_CLIPBOARD_MAX_SIZE;
         }
         else if (msg_ptr->param_1 == 2)
         {
             cut_cursor_p = ((mmi_imc_clipboard_data_struct_p)msg_ptr->param_0)->ccp_start_cursor_p;
             editor_ptr->current_text_p = cut_cursor_p + WGUI_INPUTS_CLIPBOARD_MAX_SIZE;
         }
 
         old_show_action_flag = editor_ptr->show_action_flag;
         editor_ptr->show_action_flag = 0;
         while ((editor_ptr->current_text_p) > cut_cursor_p && (cut_cursor_p != NULL))
         {
            wgui_inline_list_menu_changed = 1;
            if (wgui_inline_singleline_inputbox_decimal_input_mode_flag)
            {
                if (wgui_inline_singleline_inputbox_decimal_flag)
                {
                    UI_buffer_type p = MMI_inline_singleline_inputbox.current_text_p;
                    UI_character_type c;

                    if (p != MMI_inline_singleline_inputbox.text)
                    {
                        UI_STRING_GET_PREVIOUS_CHARACTER(p, c);
                        if (c == (UI_character_type) '.')
                        {
                            wgui_inline_singleline_inputbox_decimal_flag = 0;
                        }
                    }
                }
            }
            gui_single_line_input_box_delete_character(&MMI_inline_singleline_inputbox);
         }
         editor_ptr->show_action_flag = old_show_action_flag;
 
         gui_single_line_input_box_locate_cursor(&MMI_inline_singleline_inputbox);
         redraw_inline_singleline_inputbox();
         
         inline_singleline_inputbox_input_callback();
        break;

    case MMI_IMC_MESSAGE_CLIPBOARD_CUT_ALL:
         if (msg_ptr->param_0 == 0)
         {
             inline_edit_singleline_inputbox_delete_all_characters();
         }
         else if (msg_ptr->param_0 == 1)
         {
             old_show_action_flag = editor_ptr->show_action_flag;
             editor_ptr->show_action_flag = 0;
             editor_ptr->current_text_p = editor_ptr->text + WGUI_INPUTS_CLIPBOARD_MAX_SIZE;
             while (editor_ptr->current_text_p > editor_ptr->text)
             {
                 gui_single_line_input_box_delete_character(&MMI_inline_singleline_inputbox);
             }
             editor_ptr->show_action_flag = old_show_action_flag;
             redraw_inline_singleline_inputbox();
        }
        break;

    case MMI_IMC_MESSAGE_CLIPBOARD_IS_PASSWORD_EDITOR:
        if (editor_ptr->flags & UI_SINGLE_LINE_INPUT_BOX_MASK_CHARACTERS)
        {
            lresult = MMI_TRUE;
        }
        else
        {
            lresult = MMI_FALSE;
        }
        break;

#ifdef __MMI_CLIPBOARD_FLOATING_MENU__
    case MMI_IMC_MESSAGE_CLIPBOARD_GET_HILITE_RECT:
        if (editor_ptr->hilite_s_x == 0)
        {
            ((mmi_imc_clipboard_hilite_rect_p)msg_ptr->param_0)->s_x = 0;
        }
        else
        {
            ((mmi_imc_clipboard_hilite_rect_p)msg_ptr->param_0)->s_x = (editor_ptr->hilite_s_x > editor_ptr->x) ? editor_ptr->hilite_s_x : editor_ptr->x;
        }
        ((mmi_imc_clipboard_hilite_rect_p)msg_ptr->param_0)->s_y = editor_ptr->hilite_s_y;
        if (editor_ptr->hilite_e_x == 0)
        {
            ((mmi_imc_clipboard_hilite_rect_p)msg_ptr->param_0)->e_x = 0;
        }
        else
        {
            ((mmi_imc_clipboard_hilite_rect_p)msg_ptr->param_0)->e_x = (editor_ptr->hilite_e_x > (editor_ptr->x + editor_ptr->width)) ? (editor_ptr->x + editor_ptr->width) : editor_ptr->hilite_e_x;
        }
        ((mmi_imc_clipboard_hilite_rect_p)msg_ptr->param_0)->e_y = editor_ptr->hilite_e_y;
        break;
#endif

#endif /* __MMI_CLIPBOARD__ */
        
    case MMI_IMC_MESSAGE_HAS_SSP_ACTED:
#if defined(__MMI_EDITOR_SSP_SUPPORT__) && defined(__MMI_TOUCH_SCREEN__)
        lresult = gui_input_box_ssp_is_scrolling();
#endif
        break;

    default:
        break;
    }

    return lresult;
}


/*****************************************************************************
 * FUNCTION
 *  SetInlineTextEditCustomFunction
 * DESCRIPTION
 *  set custom function of inline text edit
 * PARAMETERS
 *  item        [IN]    inline item         
 *  f           [IN]    custom function    
 * RETURNS
 *  void
 *****************************************************************************/
void SetInlineTextEditCustomFunction(InlineItem *item, void (*f) (void))
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_inline_item_text_edit *i = (wgui_inline_item_text_edit*) item->item;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    i->custom_setup_function = f;
}


/*****************************************************************************
 * FUNCTION
 *  SetInlineItemTextEdit
 * DESCRIPTION
 *  Set date for inline text edit
 * PARAMETERS
 *  item            [IN]   inline item         
 *  buffer          [IN]   buffer      
 *  buffer_size     [IN]   size of buffer     
 *  input_type      [IN]   input type    
 * RETURNS
 *  void
 *****************************************************************************/
void SetInlineItemTextEdit(InlineItem *item, U8 *buffer, S32 buffer_size, U32 input_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    SetInlineItemTextEdit_ext(item, buffer, buffer_size, input_type, 0, NULL);
}   

/*****************************************************************************
 * FUNCTION
 *  SetInlineItemTextEdit_ext
 * DESCRIPTION
 *  Set date for inline text edit
 * PARAMETERS
 *  item            [IN]   inline item         
 *  buffer          [IN]   buffer      
 *  buffer_size     [IN]   size of buffer     
 *  input_type      [IN]   input type    
 * RETURNS
 *  void
 *****************************************************************************/
void SetInlineItemTextEdit_ext(InlineItem *item, U8 *buffer, S32 buffer_size, U32 input_type,S16 input_extended_type, mmi_imm_input_mode_enum *required_input_mode_set)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_inline_item_text_edit *i;
    UI_buffer_type mask_buffer;
    U32 t = input_type & INPUT_TYPE_MASK;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (n_inline_text_edit_items >= MAX_INLINE_TEXT_EDIT_ITEMS)
    {
        return;
    }
    wgui_inline_mem_alloc_info[wgui_inline_mem_alloc_number] = item->item = wgui_inline_malloc(sizeof(wgui_inline_item_text_edit));
    wgui_inline_mem_alloc_number++;
    item->flags = INLINE_ITEM_TYPE_TEXT_EDIT;
    n_inline_text_edit_items++;
    i = (wgui_inline_item_text_edit*) item->item;
    memset(i, 0, sizeof(wgui_inline_item_text_edit));
    i->mask_buffer = NULL;
    i->max_lines = 0;
    i->buffer = buffer;
    i->buffer_size = buffer_size;
    i->flags = 0;
    i->input_type = input_type;
    item->text_p = i->buffer;
    item->handler = handle_inline_text_edit;
    i->edit_complete_callback = UI_dummy_edit_complete_handler;
    i->validation_callback = UI_dummy_validation_function;
    i->custom_setup_function = NULL;
    if ((t == IMM_INPUT_TYPE_NUMERIC_PASSWORD) || (t == IMM_INPUT_TYPE_ALPHANUMERIC_PASSWORD) ||
        (t == IMM_INPUT_TYPE_SAT_NUMERIC_PASSWORD)|| (t == IMM_INPUT_TYPE_ASCII_PASSWORD))
    {
        wgui_inline_mem_alloc_info[wgui_inline_mem_alloc_number] = mask_buffer = (U8*)wgui_inline_malloc(MAX_INLINE_TEXT_EDIT_BUFFER_SIZE * sizeof(U8));
        wgui_inline_mem_alloc_number++;        
        inline_edit_prepare_mask_buffer(buffer, mask_buffer);
        i->mask_buffer = mask_buffer;
        item->text_p = mask_buffer;
    }
    /* UCS2_count==-1 means this field hasn't been edited */
    i->UCS2_count = -1;
    i->required_input_mode_set = required_input_mode_set;
    i->input_ext_type = input_extended_type;

    item->flags |= INLINE_ITEM_DISABLE_HIGHLIGHT;
}


/*****************************************************************************
 * FUNCTION
 *  ReConfigureInlineItemTextEdit_ext
 * DESCRIPTION
 *  re-configure inline text edit
 * PARAMETERS
 *  item            [IN]   inline item         
 *  buffer          [IN]   buffer      
 *  buffer_size     [IN]   size of buffer     
 *  input_type      [IN]   input type         
 * RETURNS
 *  void
 *****************************************************************************/
 void ReConfigureInlineItemTextEdit_ext(InlineItem *item, U8 *buffer, S32 buffer_size, U32 input_type,S16 input_extended_type, mmi_imm_input_mode_enum *required_input_mode_set)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_inline_item_text_edit *i;
    UI_buffer_type mask_buffer;
    U32 t = input_type & INPUT_TYPE_MASK;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if ((item->flags & 0xff) != INLINE_ITEM_TYPE_TEXT_EDIT)
    {
        return;
    }
    i = (wgui_inline_item_text_edit*) item->item;
    mask_buffer = i->mask_buffer;
    i->max_lines = 0;
    i->buffer = buffer;
    i->buffer_size = buffer_size;
    i->flags = 0;
    i->input_type = input_type;
    item->text_p = i->buffer;
    i->edit_complete_callback = UI_dummy_edit_complete_handler;
    i->custom_setup_function = NULL;
    if ((t == IMM_INPUT_TYPE_NUMERIC_PASSWORD) || (t == IMM_INPUT_TYPE_ALPHANUMERIC_PASSWORD) ||
        (t == IMM_INPUT_TYPE_SAT_NUMERIC_PASSWORD) || (t == IMM_INPUT_TYPE_ASCII_PASSWORD))
    {
        inline_edit_prepare_mask_buffer(buffer, mask_buffer);
        i->mask_buffer = mask_buffer;
        item->text_p = mask_buffer;
    }
    i->required_input_mode_set = required_input_mode_set;
    i->input_ext_type = input_extended_type;


}


#ifdef __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__
/*****************************************************************************
 * FUNCTION
 *  SetInlineItemTextEditDefaultItemNameIfEmpty
 * DESCRIPTION
 *  Sets the pointer item->text_p to point to default item text
 *  if the buffer is empty
 * PARAMETERS
 *  item                [IN]        Is the pointer to InlineItem structure.
 *  default_text_id     [IN]        Is the string Id of the default text.
 * RETURNS
 *  void
 *****************************************************************************/
void SetInlineItemTextEditDefaultItemNameIfEmpty_with_string(InlineItem *item, U8 *default_text)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_inline_item_text_edit *i;
    S32 nLen;


    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    i = (wgui_inline_item_text_edit*) item->item;
    nLen = mmi_ucs2strlen((const char*) i->buffer);
    
	i->default_item_text = (U8*) default_text;
    
#ifdef __MMI_FTE_SUPPORT__   
    if (nLen == 0)
    {
        if((item->flags & 0xff) != INLINE_ITEM_TYPE_TEXT_EDIT)
        {
            item->text_p = i->default_item_text;
        }
    }
#else  
    if ((IsInlineItemDefaultTextEnable()) && (nLen == 0))
    {
        item->text_p = i->default_item_text;
    }
#endif    
}


/*****************************************************************************
 * FUNCTION
 *  SetInlineItemTextEditDefaultItemNameIfEmpty
 * DESCRIPTION
 *  Sets the pointer item->text_p to point to default item text
 *  if the buffer is empty
 * PARAMETERS
 *  item                [IN]        Is the pointer to InlineItem structure.
 *  default_text_id     [IN]        Is the string Id of the default text.
 * RETURNS
 *  void
 *****************************************************************************/
void SetInlineItemTextEditDefaultItemNameIfEmpty(InlineItem *item, U16 default_text_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_inline_item_text_edit *i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    i = (wgui_inline_item_text_edit*) item->item;
    i->default_item_text = (U8*) get_string(default_text_id);

    SetInlineItemTextEditDefaultItemNameIfEmpty_with_string(item, i->default_item_text);
}



/*****************************************************************************
 * FUNCTION
 *  EnableInlineItemDefaultText
 * DESCRIPTION
 *  Sets the global flag variable to 1.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EnableInlineItemDefaultText(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_enable_inline_item_default_text = 1;
}


/*****************************************************************************
 * FUNCTION
 *  DisableInlineItemDefaultText
 * DESCRIPTION
 *  Sets the global flag variable to 0.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void DisableInlineItemDefaultText(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_enable_inline_item_default_text = 0;
}


/*****************************************************************************
 * FUNCTION
 *  IsInlineItemDefaultTextEnable
 * DESCRIPTION
 *  Check whether the global flag is on or off.
 * PARAMETERS
 *  void
 * RETURNS
 *  1 if the flag is set otherwise 0.
 *****************************************************************************/
U8 IsInlineItemDefaultTextEnable(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_FTE_SUPPORT__
    return 0;
#else
    return (U8)(wgui_enable_inline_item_default_text == 1);
#endif

}
#endif /* __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__ */ 


/*****************************************************************************
 * FUNCTION
 *  wgui_show_inline_text_edit_list_menuitem
 * DESCRIPTION
 *  Displaying inline text edit as a menu item in the fixed list menu
 * PARAMETERS
 *  x1          [IN]        x
 *  y1          [IN]        y
 *  width       [IN]        width
 *  height      [IN]        height
 *  item        [IN]        inline item         
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_show_inline_text_edit_list_menuitem(S32 x1, S32 y1, S32 width, S32 height, wgui_inline_item *item)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 l;
#ifndef __MMI_FTE_SUPPORT__
    S32 xx;
#endif
    wgui_inline_item_text_edit *i = (wgui_inline_item_text_edit*) item->item;
    single_line_input_box wgui_inline_text_edit_display_inputbox = {0};

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();
    /* add check to use mask buffer in case of passwords here   */
    l = gui_strlen((UI_string_type) i->buffer);
#ifdef __UCS2_ENCODING
    gui_create_single_line_input_box_set_buffer_first_position(
        &wgui_inline_text_edit_display_inputbox,
        MMI_singleline_inputbox_x,
        MMI_singleline_inputbox_y,
        MMI_singleline_inputbox_width,
        MMI_singleline_inputbox_height,
        (UI_string_type) i->buffer,
        i->buffer_size,
        (l + 1) * 2,
        0);
#endif /* __UCS2_ENCODING */ 
#ifdef __ASCII
    gui_create_single_line_input_box_set_buffer_first_position(
        &wgui_inline_text_edit_display_inputbox,
        MMI_singleline_inputbox_x,
        MMI_singleline_inputbox_y,
        MMI_singleline_inputbox_width,
        MMI_singleline_inputbox_height,
        (UI_string_type) i->buffer,
        i->buffer_size,
        l + 1,
        0);
#endif /* __ASCII */ 
#ifndef __MMI_FTE_SUPPORT__
    if (!mmi_fe_get_r2l_state())
    {
        if (MMI_fixed_icontext_menuitem.text_x == 2)  /* No icon. ? equal to  xx = MMI_fixed_icontext_menuitem.text_x - MMI_inline_singleline_inputbox.text_x; */
        {
            xx = 1;
        }
        else /* It is uncommon case. */
        {
            xx = MMI_fixed_icontext_menuitem.text_x - wgui_inline_text_edit_display_inputbox.x;
        }
    }
    else
    {
        //xx = -1;    
        xx = MMI_fixed_icontext_menuitem.text_x;
    }

    if (item->flags & INLINE_ITEM_LEFT_ALIGN)
    {
        //xx = -1; Modify at w10.11, unhighlight status left border is align to highlight status.
        if(mmi_fe_get_r2l_state())
        {
            xx = 1;
        }
        else
        {
            xx = 1;
        }       
    }
#endif
#ifdef __MMI_FTE_SUPPORT__
    wgui_inline_text_edit_display_inputbox.flags |= UI_SINGLE_LINE_INPUT_BOX_USE_PRESET_CLIPPING;
#ifdef __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__
    gui_single_line_input_box_set_default_text(&wgui_inline_text_edit_display_inputbox, (UI_string_type)i->default_item_text);
#endif
#endif
    wgui_inline_text_edit_display_inputbox.flags |= UI_SINGLE_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW;
    switch (i->input_type & INPUT_TYPE_MASK)
    {
        case IMM_INPUT_TYPE_NUMERIC_PASSWORD:
        case IMM_INPUT_TYPE_ALPHANUMERIC_PASSWORD:
        case IMM_INPUT_TYPE_ASCII_PASSWORD:
            wgui_inline_text_edit_display_inputbox.flags |= UI_SINGLE_LINE_INPUT_BOX_MASK_CHARACTERS;
            break;
    }
    switch (item->flags & INLINE_ITEM_JUSTIFY_MASK)
    {
        case INLINE_ITEM_RIGHT_JUSTIFY:
            wgui_inline_text_edit_display_inputbox.flags |= UI_SINGLE_LINE_INPUT_BOX_RIGHT_JUSTIFY;
            break;
        case INLINE_ITEM_CENTER_JUSTIFY:
            wgui_inline_text_edit_display_inputbox.flags |= UI_SINGLE_LINE_INPUT_BOX_CENTER_JUSTIFY;
            break;
        default:
            if (mmi_fe_get_r2l_state())
            {
                wgui_inline_text_edit_display_inputbox.flags |= UI_SINGLE_LINE_INPUT_BOX_RIGHT_JUSTIFY;
            }
            break;
    }

    wgui_inline_text_edit_display_inputbox.flags |= UI_SINGLE_LINE_INPUT_BOX_TRUNCATE_CONTENT_NO_BRIEF; /* 022405 Calvin added */

    if ((item->flags & INLINE_ITEM_BOUNDARY_MASK) == INLINE_ITEM_BOUNDARY_ALWAYS)
    {
        gui_set_single_line_input_box_theme(
            &wgui_inline_text_edit_display_inputbox,
            &wgui_inline_singleline_inputbox_unfocussed_theme);
        wgui_inline_text_edit_display_inputbox.text_font = &MMI_medium_font;
    }
    if(item->flags & INLINE_ITEM_ICON_IN_ITEM)
    {
        S32 temp_height = 0, temp_width = 0;
        wgui_inline_get_default_indicator_width(&temp_width, &temp_height);

        if (mmi_fe_get_r2l_state())
        {
            gui_single_line_input_box_set_callback_area(
                &wgui_inline_text_edit_display_inputbox,
                temp_width,
                temp_height,
                wgui_inline_show_icon_in_singleline,
                0,
                0,
                NULL);
        }
        else
        {
            gui_single_line_input_box_set_callback_area(
                &wgui_inline_text_edit_display_inputbox,
                0,
                0,
                NULL,
                temp_width,
                temp_height,
                wgui_inline_show_icon_in_singleline);
        }
    }
#ifndef __MMI_FTE_SUPPORT__
    if (!mmi_fe_get_r2l_state())
    {
        gui_resize_single_line_input_box(&wgui_inline_text_edit_display_inputbox, width - 1 - xx, height);
    }
    else 
    {
        gui_resize_single_line_input_box(&wgui_inline_text_edit_display_inputbox, width - xx - 1, height);
    }
    
    gui_move_single_line_input_box(&wgui_inline_text_edit_display_inputbox, x1 + xx, y1);

#else
    inline_edit_move_singleline_inputbox(&wgui_inline_text_edit_display_inputbox, x1, y1);
    gui_resize_single_line_input_box(&wgui_inline_text_edit_display_inputbox, width , height);
    wgui_inline_text_edit_display_inputbox.flags &= ~UI_SINGLE_LINE_INPUT_BOX_STATE_SELECTED;
    wgui_inline_text_edit_display_inputbox.normal_text_color = wgui_inline_singleline_inputbox_unfocussed_theme.normal_text_color;
#endif

    gui_show_single_line_input_box(&wgui_inline_text_edit_display_inputbox);
    gdi_layer_unlock_frame_buffer();
}


/***************************************************************************** 
 * FUNCTION
 *  inline_text_edit_get_control_full_width
 * DESCRIPTION
 *  Get area size . 
 * PARAMETERS
 * RETURNS
 *  void
 *****************************************************************************/
U32 inline_text_edit_get_control_full_width(single_line_input_box *b)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if((b != NULL) && (b->width > 0))
    {
#if defined(__MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__) && !(defined(__MMI_MAINLCD_128X128__) || defined(__MMI_MAINLCD_128X160__) || defined(__MMI_MAINLCD_176X220__) || defined(__MMI_MAINLCD_128X64__))       /* 122805 3D inline edit */
        if (IsInlineItemDefaultTextEnable())
        {
            return (b->width + (INLINE_DEFAULT_TEXT_BORDAR + INLINE_DEFAULT_TEXT_BORDAR_GAP) * 2);
        }
        else
        {
            return b->width;
        }
#else
        return b->width;
#endif
    }
    return 0;
}

/***************************************************************************** 
 * FUNCTION
 *  inline_text_edit_get_control_full_width
 * DESCRIPTION
 *  Get area size . 
 * PARAMETERS
 * RETURNS
 *  void
 *****************************************************************************/
U32 inline_text_edit_get_control_full_height(single_line_input_box *b)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if((b != NULL) && (b->width > 0))
    {
#if defined(__MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__) && !(defined(__MMI_MAINLCD_128X128__) || defined(__MMI_MAINLCD_128X160__)  || defined(__MMI_MAINLCD_176X220__) || defined(__MMI_MAINLCD_128X64__))       /* 122805 3D inline edit */
        if (IsInlineItemDefaultTextEnable())
        {
            return (b->height + (INLINE_DEFAULT_TEXT_BORDAR + INLINE_DEFAULT_TEXT_BORDAR_GAP) * 2);
        }
        else
        {
            return b->height; 
        }
#else
        return b->height;
#endif
    }
    return 0;
}

/*****************************************************************************
 * FUNCTION
 *  inline_text_edit_get_control_full_width
 * DESCRIPTION
 *  Get area size . 
 * PARAMETERS
 * RETURNS
 *  void
 *****************************************************************************/
U32 inline_text_edit_get_control_x_coordinate(single_line_input_box *b)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(b != NULL)
    {
#if defined(__MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__) && !(defined(__MMI_MAINLCD_128X128__) || defined(__MMI_MAINLCD_128X160__)  || defined(__MMI_MAINLCD_176X220__) || defined(__MMI_MAINLCD_128X64__))       /* 122805 3D inline edit */
        if (IsInlineItemDefaultTextEnable())
        {
            return (b->x - (INLINE_DEFAULT_TEXT_BORDAR + INLINE_DEFAULT_TEXT_BORDAR_GAP));
        }
        else
        {
            return b->x;
        }
#else
        return b->x;
#endif
    }

    MMI_ASSERT(0);
    return NULL;

}

/*****************************************************************************
 * FUNCTION
 *  inline_text_edit_get_control_full_width
 * DESCRIPTION
 *  Get area size . 
 * PARAMETERS
 * RETURNS
 *  void
 *****************************************************************************/
U32 inline_text_edit_get_control_y_coordinate(single_line_input_box *b)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(b != NULL)
    {
#if defined(__MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__) && !(defined(__MMI_MAINLCD_128X128__) || defined(__MMI_MAINLCD_128X160__)  || defined(__MMI_MAINLCD_176X220__) || defined(__MMI_MAINLCD_128X64__))       /* 122805 3D inline edit */
        if (IsInlineItemDefaultTextEnable())
        {
            return (b->y - (INLINE_DEFAULT_TEXT_BORDAR + INLINE_DEFAULT_TEXT_BORDAR_GAP));
        }
        else
        {
            return b->y;
        }
#else
        return b->y;
#endif
    }

    MMI_ASSERT(0);
    return NULL;
}

/***************************************************************************** 
 * FUNCTION
 *  set_leading_zero
 * DESCRIPTION
 *  set the flag whether zero is allowed as first number or not
 * PARAMETERS
 *  operation      [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_inline_set_leading_zero_style(wgui_inline_item *item, MMI_BOOL operation)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                 */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if((item->flags & 0xff ) == INLINE_ITEM_TYPE_TEXT_EDIT)
    {
        if(operation == 1)
        {
            item->flags &= ~INLINE_ITEM_NO_LEADING_ZERO;
        }
        else if(operation == 0)
        {
            item->flags |= INLINE_ITEM_NO_LEADING_ZERO;
        }
    }
}


/***************************************************************************** 
 * Inline Full Screen Edit   
 *
 * This is Inline Full Screen Edit  
 *****************************************************************************/

/***************************************************************************** 
 * Define
 *****************************************************************************/
#define MAX_INLINE_FULL_SCREEN_TEXT_EDIT_BUFFER_SIZE 512

/***************************************************************************** 
 * Typedef 
 *****************************************************************************/
typedef multiline_inputbox_category_history inline_full_screen_edit_history;


/***************************************************************************** 
 * Local Variable
 *****************************************************************************/
#if !defined(GUI_EDITOR_SHOW_TITLE)
static S32 full_screen_edit_open = 0;
#endif /* !defined(GUI_EDITOR_SHOW_TITLE) */
static UI_string_type inline_full_screen_edit_saved_title = (UI_string_type) NULL;
static UI_string_type inline_full_screen_edit_saved_LSK_label = (UI_string_type) NULL;
static UI_string_type inline_full_screen_edit_saved_RSK_label = (UI_string_type) NULL;
static PU8 inline_full_screen_edit_saved_title_icon = (PU8) NULL;

/***************************************************************************** 
 * Global Variable
 *****************************************************************************/
U8 inline_full_screen_edit_changed = 0;
PU8 wgui_inline_full_screen_text_edit_buffer;


/***************************************************************************** 
 * Extern Global Function
 *****************************************************************************/
extern void wgui_handle_inputbox_input(void);


/***************************************************************************** 
 * Function Implementation
 *****************************************************************************/
 
/*****************************************************************************
 * FUNCTION
 *  inline_full_screen_edit_get_history
 * DESCRIPTION
 *  get history buffer for inline full screen edit
 * PARAMETERS
 *  history_buffer      [OUT]   history buffer         
 *  input_mode          [IN]    input mode    
 * RETURNS
 *  history buffer
 *****************************************************************************/
U8 *inline_full_screen_edit_get_history(U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    get_multiline_inputbox_category_history(INLINE_FULL_SCREEN_EDIT_HISTORY_ID, history_buffer);
    return (history_buffer);
}


/*****************************************************************************
 * FUNCTION
 *  inline_full_screen_edit_set_history
 * DESCRIPTION
 *  set history buffer into MMI_multiline_inputbox
 * PARAMETERS
 *  history_ID          [IN]     history id   
 *  history_buffer      [IN]     history buffer    
 *  input_mode          [OUT]    input mode     
 * RETURNS
 *  1->success 0->fail
 *****************************************************************************/
U8 inline_full_screen_edit_set_history(U16 history_ID, U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return (set_multiline_inputbox_category_history(INLINE_FULL_SCREEN_EDIT_HISTORY_ID, history_buffer));
}



/*****************************************************************************
 * FUNCTION
 *  inline_multi_line_edit_get_history
 * DESCRIPTION
 *  get history buffer for inline multi line edit
 * PARAMETERS
 *  history_buffer      [OUT]       history buffer  
 *  input_mode          [IN]        input mode
 * RETURNS
 *  history buffer
 *****************************************************************************/
U8 *inline_multi_line_edit_get_history(U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    get_multiline_inputbox_category_history(INLINE_MULTI_LINE_EDIT_HISTORY_ID, history_buffer);
    return (history_buffer);
}


/*****************************************************************************
 * FUNCTION
 *  redraw_inline_full_screen_edit
 * DESCRIPTION
 *  redraw function of inline full screen edit
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void redraw_inline_full_screen_edit(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    /* micha1111, #219 */
#ifdef __MMI_DEFAULT_THEME_3__
    color c = {206, 206, 206, 100};
#endif 

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();

    /* stop the scroll text for horizontal tab bar */
    if ((g_dm_data.s32CatId == MMI_CATEGORY657_ID) && dm_check_control_exist(g_dm_data.s32CatId, DM_HORIZONTAL_TAB_BAR))
    {
        wgui_close_horizontal_tab_bar();
    }

    /* micha1111 Chicago Feature */
#ifdef __MMI_DEFAULT_THEME_3__
    gdi_layer_reset_clip();
    gui_fill_rectangle(0, 0, UI_device_width - 1, UI_device_height - 1, c);
#else /* __MMI_DEFAULT_THEME_3__ */ 
    if (wgui_is_wallpaper_on_bottom() == MMI_TRUE)
    {
        gdi_draw_solid_rect(0, 0, UI_device_width - 1, UI_device_height - 1, GDI_COLOR_TRANSPARENT);
    }
    else
    {
        clear_screen();
    }
#endif /* __MMI_DEFAULT_THEME_3__ */ 

#ifdef GUI_COMMON_SHOW_STATUS_ICON
#ifdef __MMI_SCREEN_ROTATE__
    if (mmi_frm_is_screen_width_height_swapped())
    {
       //show_title_status_icon();
    }
    else
#endif
    {
        show_title_status_icon();
    }
#endif

#if defined(GUI_EDITOR_SHOW_TITLE)
    draw_title();
#endif

    wgui_show_inputbox();

    show_softkey_background();
    show_left_softkey();
    show_right_softkey();
#if defined(__MMI_TOUCH_SCREEN__)
    /* W05.36 Add Center Soft Key for switching Input Method */
    show_softkey(MMI_CENTER_SOFTKEY);
#endif /* defined(__MMI_TOUCH_SCREEN__) */ 
    gdi_layer_unlock_frame_buffer();
    gdi_layer_blt_previous(0, 0, UI_device_width - 1, UI_device_height - 1);
    /* for redrawing spelling or candidate boxes */
    if (RedrawSpellingOrCandidateBoxesFunction)
    {
        RedrawSpellingOrCandidateBoxesFunction();
    }


}


/*****************************************************************************
 * FUNCTION
 *  wgui_inline_get_full_screen_changed
 * DESCRIPTION
 *  get current full screen edit changed status
 * PARAMETERS
 *  void
 * RETURNS
 *  return status
 *****************************************************************************/
U8 wgui_inline_get_full_screen_changed(void)
{
    return inline_full_screen_edit_changed;
}


/*****************************************************************************
 * FUNCTION
 *  handle_inline_full_screen_edit_opacity_reset
 * DESCRIPTION
 *  full screen is show a edit screen and reset screen background opacity
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void handle_inline_full_screen_edit_opacity_reset(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_WALLPAPER_ON_BOTTOM__
    if (inline_opacity_changed)
    {
        dm_set_scr_bg_opacity(inline_edit_scr_bg_opacity);
        inline_opacity_changed = FALSE;
    }
#endif /* __MMI_WALLPAPER_ON_BOTTOM__ */ 
}


/*****************************************************************************
 * FUNCTION
 *  handle_inline_full_screen_edit_opacity_set
 * DESCRIPTION
 *  full screen is show a edit screen and set screen background opacity
 * PARAMETERS
 *  opacity		[IN]		
 * RETURNS
 *  void
 *****************************************************************************/
static void handle_inline_full_screen_edit_opacity_set(U8 opacity)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_WALLPAPER_ON_BOTTOM__
    if (!inline_opacity_changed)
    {
        dm_get_scr_bg_opacity(&inline_edit_scr_bg_opacity);
        dm_set_scr_bg_opacity(opacity);    
        inline_opacity_changed = TRUE;
    }
#endif /* __MMI_WALLPAPER_ON_BOTTOM__ */ 
}


/*****************************************************************************
 * FUNCTION
 *  handle_inline_full_screen_edit_delete_title
 * DESCRIPTION
 *  delete title show
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void handle_inline_full_screen_edit_delete_title(void)
{
#if !defined(GUI_EDITOR_SHOW_TITLE)
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 dm_flag;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    dm_get_dm_data_flag(&dm_flag);
    dm_flag &= ~DM_NO_TITLE;
    dm_set_dm_data_flag(dm_flag);
    full_screen_edit_open = 0;
#endif /* !defined(GUI_EDITOR_SHOW_TITLE) */
}


/*****************************************************************************
 * FUNCTION
 *  handle_inline_full_screen_edit_insert_title
 * DESCRIPTION
 *  insert title show
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void handle_inline_full_screen_edit_insert_title(void)
{
#if !defined(GUI_EDITOR_SHOW_TITLE)
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 dm_flag;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/			
    dm_get_dm_data_flag(&dm_flag);
    dm_flag |= DM_NO_TITLE;
    dm_set_dm_data_flag(dm_flag);
    full_screen_edit_open = 1;
    close_scrolling_title();	/* stop scrolling title from prev screen */
#if defined (MMI_SHOW_STATUS_ICON_IN_TITLE)    
    wgui_status_icon_bar_register_integrated_redraw(NULL);
#endif    
#endif /* !defined(GUI_EDITOR_SHOW_TITLE) */
}

extern fixed_icontext_menuitem *GUI_current_fixed_icontext_menuitem_common_data;
extern fixed_icontext_menuitem_type *GUI_current_fixed_icontext_menuitem_data;


/*****************************************************************************
 * FUNCTION
 *  handle_inline_full_screen_edit_back_for_resize
 * DESCRIPTION
 *  resize list menu when back from full screen to list menu
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void handle_inline_full_screen_edit_back_for_resize(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(__MMI_TOUCH_SCREEN__)
#ifdef __MMI_VIRTUAL_KEYBOARD__
#ifdef __MMI_UI_VIRTUAL_KEYBOARD_DEFAULT_VERSION_1__
    if (GUI_VIRTUAL_KEYBOARD_EMPTY_TRAY != MMI_virtual_keyboard.lang_type)
#else
    if (GUI_VIRTUAL_KEYBOARD_EMPTY_TRAY != g_wgui_virtual_keyboard_lang_type)
#endif
    {
    #ifdef __MMI_UI_VIRTUAL_KEYBOARD_DEFAULT_VERSION_1__
        resize_fixed_list(MMI_content_width, MMI_content_height - MMI_virtual_keyboard.height - 1);
    #else
        S32 vk_width, vk_height;
        wgui_virtual_keyboard_get_dimension(&vk_width, &vk_height);
        resize_fixed_list(MMI_content_width, MMI_content_height - vk_height - 1);
    #endif
    }
    else
#endif
    {
        if ((g_dm_data.s32CatId == MMI_CATEGORY657_ID) && dm_check_control_exist(g_dm_data.s32CatId, DM_HORIZONTAL_TAB_BAR))
        {            
            if (dm_check_control_exist(g_dm_data.s32CatId, DM_STATUS_BAR1))
            {
#ifdef __MMI_ICON_BAR_SUPPORT__
            #ifdef __MMI_FTE_SUPPORT__                    
                if(wgui_icon_bar_is_created())
                {
                    resize_fixed_list(MMI_content_width, UI_device_height - 
                        MMI_status_bar_height - MMI_softkey_height - MMI_HORIZONTAL_TAB_BAR_TAB_AREA_HEIGHT - 
                        MMI_HORIZONTAL_TAB_BAR_HINT_AREA_HEIGHT - MMI_ICON_BAR_HEIGHT);
                }
                else
            #endif             
#endif /*__MMI_ICON_BAR_SUPPORT__*/			
                {
                    resize_fixed_list(MMI_content_width, UI_device_height - 
                        MMI_status_bar_height - MMI_softkey_height - 
                        MMI_HORIZONTAL_TAB_BAR_TAB_AREA_HEIGHT - MMI_HORIZONTAL_TAB_BAR_HINT_AREA_HEIGHT);
                }
            }
            else
            {
#ifdef __MMI_ICON_BAR_SUPPORT__
            #ifdef __MMI_FTE_SUPPORT__                    
                if(wgui_icon_bar_is_created())
                {
                    resize_fixed_list(MMI_content_width, UI_device_height - 
                        MMI_softkey_height - MMI_HORIZONTAL_TAB_BAR_TAB_AREA_HEIGHT - 
                        MMI_HORIZONTAL_TAB_BAR_HINT_AREA_HEIGHT - MMI_ICON_BAR_HEIGHT);
                }
                else
            #endif  
#endif			
                {
                    resize_fixed_list(MMI_content_width, UI_device_height - 
						MMI_softkey_height - MMI_HORIZONTAL_TAB_BAR_TAB_AREA_HEIGHT - MMI_HORIZONTAL_TAB_BAR_HINT_AREA_HEIGHT);
                }
            }
        }
        else
        {
#ifdef __MMI_ICON_BAR_SUPPORT__
        #ifdef __MMI_FTE_SUPPORT__            
            if(wgui_icon_bar_is_created())
            {
                resize_fixed_list(MMI_content_width, MMI_content_height - MMI_ICON_BAR_HEIGHT);
            }
            else
        #endif                
#endif /*__MMI_ICON_BAR_SUPPORT__*/		
            {
                resize_fixed_list(MMI_content_width, MMI_content_height);
            }
        }
    }
#endif /* defined(__MMI_TOUCH_SCREEN__) */ 
}


/*****************************************************************************
 * FUNCTION
 *  handle_inline_full_screen_edit_reset
 * DESCRIPTION
 *  reset some var of inline full screen edit
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void handle_inline_full_screen_edit_reset(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    handle_inline_full_screen_edit_opacity_reset();
    handle_inline_full_screen_edit_delete_title();
    
    wgui_inline_item_handled = 0;
    
    redraw_current_inline_item = UI_dummy_function;
    wgui_inputbox_UCS2_count_function = NULL;
    wgui_inputbox_not_empty_callback = NULL;
    wgui_inputbox_empty_callback = NULL;
    wgui_inputbox_validation_callback = NULL;
    complete_inline_item_edit = UI_dummy_function;
    
#ifdef __MMI_SCREEN_ROTATE__
    if (mmi_frm_is_screen_width_height_swapped())
    {
        MMI_multitap_x = MMI_MULTITAP_X;
        MMI_multitap_y = (UI_device_height - MMI_BUTTON_BAR_HEIGHT - MMI_multitap_height);/* MMI_MULTITAP_Y*/;
        MMI_multitap_width = UI_device_width - 4;
    }
#endif
}


/*****************************************************************************
 * FUNCTION
 *  handle_inline_full_screen_edit_complete
 * DESCRIPTION
 *  complete function of inline full screen edit
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void handle_inline_full_screen_edit_complete(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 input_type = current_wgui_inline_text_edit_item->input_type & INPUT_TYPE_MASK;
    S32 index = -1;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    ClearAllKeyHandler(); // clear all key to avoid inline edit screen use editor key handle
    
    /* Set Current Inline Method To Zero After Full Screen Editing Is Complete - Gurinder 3/27/2004 */
    wgui_current_inline_item_type = 0;
    current_wgui_inline_item->flags &= ~INLINE_ITEM_OPEN;
    if (inline_full_screen_edit_changed && current_wgui_inline_text_edit_item->buffer_size > 1)
    {
        wgui_inline_list_menu_changed = 1;
	#if defined(__MMI_INLINE_ITEM_IMAGETEXT__)
		if (inline_image_text_edit_flag == 0)
	#endif /* __MMI_INLINE_ITEM_IMAGETEXT__ */
		{
			if (current_wgui_inline_item->flags & INLINE_ITEM_CHANGED)
			{
				set_wgui_inline_list_menu_changed();
			}
		}
    }

    if (current_wgui_inline_text_edit_item->buffer_size <= 1)
    {
        current_wgui_inline_item->flags &= ~INLINE_ITEM_CHANGED;
    }

#if defined(__MMI_INLINE_ITEM_IMAGETEXT__)
	if (inline_image_text_edit_flag == 1)
	{
		if (current_wgui_inline_item->flags & INLINE_ITEM_CHANGED)
		{
			set_wgui_inline_list_menu_changed();
		}
	}
#endif /* __MMI_INLINE_ITEM_IMAGETEXT__ */

    current_wgui_inline_text_edit_item->UCS2_count = MMI_multiline_inputbox.UCS2_count;
    gui_strcpy(
        (UI_string_type) current_wgui_inline_text_edit_item->buffer,
        (UI_string_type) wgui_inline_full_screen_text_edit_buffer);
    if ((input_type == IMM_INPUT_TYPE_ALPHANUMERIC_PASSWORD) || (input_type == IMM_INPUT_TYPE_ALPHANUMERIC_PASSWORD) ||
        (input_type == IMM_INPUT_TYPE_SAT_NUMERIC_PASSWORD) || (input_type == IMM_INPUT_TYPE_ASCII_PASSWORD))
    {
        inline_edit_prepare_mask_buffer(
            current_wgui_inline_text_edit_item->buffer,
            current_wgui_inline_text_edit_item->mask_buffer);
        *current_wgui_inline_text_edit_text_p = current_wgui_inline_text_edit_item->mask_buffer;
    }
    else
    {
    #ifdef __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__
#ifdef __MMI_FTE_SUPPORT__
        if (gui_strlen((UI_string_type) current_wgui_inline_text_edit_item->buffer) == 0)
#else
        if ((IsInlineItemDefaultTextEnable()) &&
            (gui_strlen((UI_string_type) current_wgui_inline_text_edit_item->buffer) == 0))
#endif
        {
            *current_wgui_inline_text_edit_text_p = current_wgui_inline_text_edit_item->default_item_text;
        }
        else
    #endif /* __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__ */ 
            *current_wgui_inline_text_edit_text_p = current_wgui_inline_text_edit_item->buffer;

    #ifdef __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__
        MMI_fixed_icontext_menuitems[wgui_inline_item_highlighted_index].item_text =
            (UI_string_type) (*current_wgui_inline_text_edit_text_p);
    #endif /* __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__ */ 

    }
    reset_softkeys();
    wgui_close_inputbox();

#if defined (__MMI_INLINE_ITEM_IMAGETEXT__)
    inline_image_text_edit_flag = 0;
#endif
    register_inline_fixed_list_keys();
    inline_text_edit_RSK_function = NULL;
    clear_left_softkey();
    clear_right_softkey();
    /* MTK Terry for RSK Long Press in inline full screen exit */
    set_right_softkey_function(UI_dummy_function, KEY_EVENT_LONG_PRESS);
    set_left_softkey_label(inline_full_screen_edit_saved_LSK_label);
    set_right_softkey_label(inline_full_screen_edit_saved_RSK_label);
    register_left_softkey_handler();
    register_right_softkey_handler();
    /* For let list recalculate scroll text. */
    MMI_fixed_icontext_menuitems[wgui_inline_item_highlighted_index].text_width = 0;
    GUI_current_fixed_icontext_menuitem_data = &(MMI_fixed_icontext_menuitems[MMI_fixed_list_menu.highlighted_item]);
    GUI_current_fixed_icontext_menuitem_common_data = MMI_fixed_list_menu.common_item_data;

    wgui_text_menuitem_restart_scrolling();
    /* if title is changed, we should redraw title */
    if (MMI_title_icon != inline_full_screen_edit_saved_title_icon ||
        MMI_title_string != inline_full_screen_edit_saved_title)
    {
        MMI_title_icon = inline_full_screen_edit_saved_title_icon;
        MMI_title_string = inline_full_screen_edit_saved_title;
 
    }
    index = wgui_inline_item_highlighted_index;
    wgui_inline_item_highlighted_index = -1;
    if (MMI_fixed_list_menu.item_highlighted)
    {
        MMI_fixed_list_menu.item_highlighted(index);
    }

    inline_full_screen_edit_changed = 0;
	handle_inline_full_screen_edit_reset();
	handle_inline_full_screen_edit_back_for_resize();
    StopTimer(BLINKING_CURSOR);    
#ifdef __MMI_TOUCH_SCREEN__
    if ((g_dm_data.s32CatId == MMI_CATEGORY657_ID) &&
        dm_check_control_exist(g_dm_data.s32CatId, DM_HORIZONTAL_TAB_BAR))
    {
        wgui_horizontal_tab_bar_reset_disable_reset_offset();
    }
#endif /* __MMI_TOUCH_SCREEN__ */ 


    dm_set_scr_bg_redraw(MMI_TRUE); 
    RedrawCategoryFunction();

    current_wgui_inline_text_edit_item->edit_complete_callback(
        current_wgui_inline_text_edit_item->buffer,
        current_wgui_inline_text_edit_item->buffer_size);
}


/*****************************************************************************
 * FUNCTION
 *  handle_inline_full_screen_edit_close
 * DESCRIPTION
 *  close function of inline full screen edit
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void handle_inline_full_screen_edit_close(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* MTK Terry for G12C#392 RSK Long Press roll back for side effect */
    current_wgui_inline_item->flags |= INLINE_ITEM_OPEN;
#if defined(__MMI_INLINE_ITEM_IMAGETEXT__)
    if (inline_image_text_edit_flag == 1)
    {
		if (inline_full_screen_edit_changed)
		{
			current_wgui_inline_item->flags |= INLINE_ITEM_CHANGED;
		}
    }
#endif /* __MMI_INLINE_ITEM_IMAGETEXT__ */
    wgui_close_inputbox();
    reset_softkeys();

    //MTK Elvis 20040609 it is wrong to reset wgui_current_inline_item_type
    // it will cause the inline full(multiline input box parameters) screen's history not be stored
    //wgui_current_inline_item_type = 0;
    //MTK end
    //W05.36 Temp Solution for Pop Screen in Full Screen Editor to check if any side effect or not
#if defined(__MMI_INLINE_ITEM_IMAGETEXT__)
    if (inline_image_text_edit_flag == 1)
    {
        inline_full_screen_edit_changed = 0;
    }
#endif /* __MMI_INLINE_ITEM_IMAGETEXT__ */

    handle_inline_full_screen_edit_reset();

#ifdef __MMI_FTE_SUPPORT__	
	mmi_imc_set_vk_present(MMI_IMC_VK_DEFAULT_ENLARGE);
#endif
    StopTimer(BLINKING_CURSOR);
}


/*****************************************************************************
 * FUNCTION
 *  handle_inline_full_screen_edit_cancel
 * DESCRIPTION
 *  cancel function of inline full screen edit
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void handle_inline_full_screen_edit_cancel(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 index;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();
#if defined(__MMI_INLINE_ITEM_IMAGETEXT__)
	if (inline_image_text_edit_flag == 0)
#endif /* __MMI_INLINE_ITEM_IMAGETEXT__ */
	{
	    inline_full_screen_edit_changed = 0;
	}
    current_wgui_inline_item->flags &= ~INLINE_ITEM_OPEN;

    ClearAllKeyHandler(); // clear all key to avoid inline edit screen use editor key handle

    reset_softkeys();
    wgui_close_inputbox();

#if defined (__MMI_INLINE_ITEM_IMAGETEXT__)
    inline_image_text_edit_flag = 0;
#endif

    register_inline_fixed_list_keys();
    inline_text_edit_RSK_function = NULL;

    clear_left_softkey();
    clear_right_softkey();
    if (!mmi_frm_kbd_is_key_supported(KEY_CLEAR))
    {
        ClearKeyHandler(KEY_RSK, KEY_LONG_PRESS);
    }

    set_left_softkey_label(inline_full_screen_edit_saved_LSK_label);
    set_right_softkey_label(inline_full_screen_edit_saved_RSK_label);
    register_left_softkey_handler();
    register_right_softkey_handler();
    wgui_current_inline_item_type = 0;
    wgui_text_menuitem_restart_scrolling();
    /* if title is changed, we should redraw title */
    if (MMI_title_icon != inline_full_screen_edit_saved_title_icon ||
        MMI_title_string != inline_full_screen_edit_saved_title)
    {
        MMI_title_icon = inline_full_screen_edit_saved_title_icon;
        MMI_title_string = inline_full_screen_edit_saved_title;
    }

    index = wgui_inline_item_highlighted_index;
    wgui_inline_item_highlighted_index = -1;
    if (MMI_fixed_list_menu.item_highlighted)
    {
        MMI_fixed_list_menu.item_highlighted(index);
    }
    
    inline_full_screen_edit_changed = 0;

    StopTimer(BLINKING_CURSOR);

    handle_inline_full_screen_edit_reset();

#ifdef __MMI_TOUCH_SCREEN__
    if ((g_dm_data.s32CatId == MMI_CATEGORY657_ID) &&
        dm_check_control_exist(g_dm_data.s32CatId, DM_HORIZONTAL_TAB_BAR))
    {
        wgui_horizontal_tab_bar_reset_disable_reset_offset();
    }
#endif /* __MMI_TOUCH_SCREEN__ */ 

    dm_set_scr_bg_redraw(MMI_TRUE); 
    gdi_layer_unlock_frame_buffer();
    RedrawCategoryFunction();
#ifdef __MMI_FTE_SUPPORT__	
	mmi_imc_set_vk_present(MMI_IMC_VK_DEFAULT_ENLARGE);
#endif
}


/*****************************************************************************
 * FUNCTION
 *  wgui_inline_edit_handle_multiline_inputbox_input
 * DESCRIPTION
 *  input handler for inline multiline inputbox
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_inline_edit_handle_multiline_inputbox_input(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_handle_inputbox_input();
    inline_full_screen_edit_changed = 1;
#if defined(__MMI_INSCREEN_MULTILINE_TEXTBOX__)
#if defined( __MMI_INLINE_ITEM_MULTILINE_READ_ONLY__) || defined( __MMI_INLINE_ITEM_MULTILINE_EDIT__)
    if (wgui_current_inline_item_type == INLINE_ITEM_TYPE_MULTI_LINE_EDIT)
    {
        if (wgui_inline_list_menu_changed)
        {
            if (gui_multi_line_input_box_get_text_length(&MMI_multiline_inputbox) <= 0)
            {
                wgui_inline_text_edit_set_RSK_BACK_function();
                inline_text_edit_RSK_label_clear = 0;
				execute_wgui_inline_edit_text_empty();
            }
        }
    }
#endif /* #if defined( __MMI_INLINE_ITEM_MULTILINE_READ_ONLY__) || defined( __MMI_INLINE_ITEM_MULTILINE_EDIT__) */
#endif /* defined(__MMI_INSCREEN_MULTILINE_TEXTBOX__) */ 
}


/*****************************************************************************
 * FUNCTION
 *  handle_inline_full_screen_edit
 * DESCRIPTION
 *  activation function of inline full screen edit
 * PARAMETERS
 *  x                   [IN]        left corner's x coordinate
 *  y                   [IN]        left corner's y coordinate
 *  width               [IN]        width
 *  height              [IN]        height
 *  key_code            [IN]        key code
 *  key_event           [IN]        key event
 *  text_p              [IN]        text pointer
 *  item                [IN]        inline item
 *  flags               [IN]        flags
 *  history_buffer      [IN]        history buffer          
 * RETURNS
 *  void
 *****************************************************************************/
static void handle_inline_full_screen_edit(
        S32 x,
        S32 y,
        S32 width,
        S32 height,
        S32 key_code,
        S32 key_event,
        U8 **text_p,
        void *item,
        U32 flags,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 input_type;
    wgui_inline_item_text_edit *i = (wgui_inline_item_text_edit*) item;

    S32 inputbox_x, inputbox_y, inputbox_width, inputbox_height;
    S32 vk_height = 0; 
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
/* In FTE, stop scrolling when enter fullscreen edit. */    
#ifdef __MMI_FTE_SUPPORT__
    wgui_inline_display_only_close();
#endif

#if !defined(GUI_EDITOR_SHOW_TITLE)
    inputbox_x = MMI_COMMON_CONTENT_X;
    inputbox_y = MMI_COMMON_CONTENT_Y - MMI_COMMON_TITLE_HEIGHT;
    inputbox_width = MMI_COMMON_CONTENT_WIDTH;
    inputbox_height = MMI_COMMON_CONTENT_HEIGHT + MMI_COMMON_TITLE_HEIGHT;
#else 
    inputbox_x = MMI_COMMON_CONTENT_X;
    inputbox_y = MMI_COMMON_CONTENT_Y;
    inputbox_width = MMI_COMMON_CONTENT_WIDTH;
    inputbox_height = MMI_COMMON_CONTENT_HEIGHT;
#endif 

#ifdef __MMI_SCREEN_ROTATE__
    if (mmi_frm_is_screen_width_height_swapped())
    {
        inputbox_x = MMI_ROTATED_CONTENT_X;
        inputbox_y = MMI_ROTATED_CONTENT_Y;
        inputbox_width = MMI_ROTATED_CONTENT_WIDTH;
        inputbox_height = MMI_ROTATED_CONTENT_HEIGHT;   

        MMI_multitap_x = MMI_ROTATED_CONTENT_X;
        MMI_multitap_y = MMI_ROTATED_CONTENT_Y + MMI_ROTATED_CONTENT_HEIGHT - MMI_multitap_height;
        MMI_multitap_width = MMI_ROTATED_CONTENT_WIDTH;

    }
#endif
    
    MMI_current_input_ext_type = 0;
    UI_UNUSED_PARAMETER(x);
    UI_UNUSED_PARAMETER(y);
    UI_UNUSED_PARAMETER(width);
    UI_UNUSED_PARAMETER(height);
    UI_UNUSED_PARAMETER(key_code);
    UI_UNUSED_PARAMETER(key_event);
    UI_UNUSED_PARAMETER(flags);

    gdi_layer_lock_frame_buffer();
    wgui_text_menuitem_reset_scrolling();

    wgui_current_inline_item_type = INLINE_ITEM_TYPE_FULL_SCREEN_EDIT;
    current_wgui_inline_text_edit_item = i;
    current_wgui_inline_text_edit_text_p = text_p;
    input_type = i->input_type;

    if (!(flags & INLINE_ITEM_OPEN))
    {
        gui_strcpy((UI_string_type) wgui_inline_full_screen_text_edit_buffer, (UI_string_type) i->buffer);
        history_buffer = NULL;
    }

    if(cui_inline_is_current_cui())
    {
        cui_inline_item_replace_gui_buffer(wgui_inline_item_highlighted_index, &wgui_inline_items[wgui_inline_item_highlighted_index], &history_buffer);
    }

	if (history_buffer)
	{
		if (flags & INLINE_ITEM_CHANGED)
		{
			inline_full_screen_edit_changed = 1;
		}
		else
		{
			inline_full_screen_edit_changed = 0;
		}
	}
    
    i->flags &= ~INLINE_ITEM_OPEN;
    inline_full_screen_edit_saved_title = MMI_title_string;
    inline_full_screen_edit_saved_title_icon = MMI_title_icon;
    inline_full_screen_edit_saved_LSK_label = MMI_softkeys[MMI_LEFT_SOFTKEY].text;
    inline_full_screen_edit_saved_RSK_label = MMI_softkeys[MMI_RIGHT_SOFTKEY].text;
    change_left_softkey(STR_GLOBAL_OK, IMG_GLOBAL_OK);
    change_right_softkey(STR_GLOBAL_BACK, IMG_GLOBAL_BACK);
    wgui_title_set_menu_shortcut_number(-1);
    wgui_title_disable_menu_shortcut_display(MMI_TRUE);
    clear_key_handlers();
    change_left_softkey(STR_GLOBAL_OK, IMG_GLOBAL_OK);
    change_right_softkey(STR_GLOBAL_BACK, IMG_GLOBAL_BACK);
    clear_left_softkey();
    clear_right_softkey();
    register_left_softkey_handler();
    register_right_softkey_handler();
    register_default_hide_softkeys();
    MMI_title_string = get_string(i->title);
    MMI_title_icon = get_image(i->title_icon);
    wgui_inputbox_validation_callback = i->validation_callback;

    if(cui_inline_is_current_cui())
    {
       cui_inline_evt_item_activate(); 
       register_softkey_handler(MMI_CENTER_SOFTKEY);
       set_softkey_function(handle_inline_full_screen_edit_complete, KEY_EVENT_UP, MMI_CENTER_SOFTKEY); 
      mmi_imc_key_setup_csk_function(handle_inline_full_screen_edit_complete);
    }

    if (i->custom_setup_function != NULL)
    {
        i->custom_setup_function();
    }
    /* MTK Add By Elvis for third party input module */

#ifdef __MMI_FTE_SUPPORT__
	if(history_buffer == NULL)
	{
            mmi_imc_set_vk_present(MMI_IMC_VK_PRESENT_DEFAULT);
	}	
#endif

    wgui_setup_inputbox_ext(
        inputbox_x,
        inputbox_y,
        inputbox_width,
        inputbox_height,
        wgui_inline_full_screen_text_edit_buffer,
        i->buffer_size,
        INLINE_FULL_SCREEN_EDIT_HISTORY_ID,
        get_string(STR_GLOBAL_BACK),
        get_image(IMG_GLOBAL_BACK),
        (U32) input_type,
        history_buffer,
        i->required_input_mode_set,
    #ifdef __MMI_FTE_SUPPORT__        
        0,
    #else
        1,
    #endif  
        0,
        0,
        0,
        0,
        0,
        NULL
        );
    /* Fix bug: When pop up is disappeared and fullscreen is show again,
        if height of (fullscreen + virtual keyboard) > height of text > height of fullscreen,
        scroll bar location will be different from that before.
    */
    vk_height = wgui_inputs_get_current_imui_height(MMI_EDITOR_MULTILINE_INPUT_BOX);
    wgui_inputs_ml_resize(WGUI_INPUTS_STYLE_DEFAULT, inputbox_height - vk_height);

    /* MTK Terry for 0x81 encoding for Phone Book */
    MMI_current_input_ext_type = i->input_ext_type;

    wgui_inputs_ml_handle_input_ext_type(input_type);

    /* Ailsa for remove new line symbol from password input type */
    if (((i->input_type & INPUT_TYPE_MASK) == IMM_INPUT_TYPE_NUMERIC_PASSWORD) ||
        ((i->input_type & INPUT_TYPE_MASK) == IMM_INPUT_TYPE_ALPHANUMERIC_PASSWORD) ||
        ((i->input_type & INPUT_TYPE_MASK) == IMM_INPUT_TYPE_SAT_NUMERIC_PASSWORD) ||
        ((i->input_type & INPUT_TYPE_MASK) == IMM_INPUT_TYPE_SIGNED_DECIMAL_NUMERIC_PASSWORD) ||
        ((i->input_type & INPUT_TYPE_MASK) == IMM_INPUT_TYPE_SIGNED_NUMERIC_PASSWORD) ||
        ((i->input_type & INPUT_TYPE_MASK) == IMM_INPUT_TYPE_ASCII_PASSWORD))
    {
        MMI_current_input_ext_type |= INPUT_TYPE_EXT_NO_SHOW_NEW_LINE_SYMBOL;
    }

    register_multiline_inputbox_input_callback(wgui_inline_edit_handle_multiline_inputbox_input);
    wgui_inputbox_RSK_function = handle_inline_full_screen_edit_cancel;
    redraw_current_inline_item = redraw_inline_full_screen_edit;


#ifdef __MMI_WALLPAPER_ON_BOTTOM__
    if (!inline_opacity_changed)
    {
        MMI_multiline_inputbox.flags |= UI_MULTI_LINE_INPUT_BOX_TRANSPARENT_BACKGROUND;
        handle_inline_full_screen_edit_opacity_set((U8)(current_MMI_theme->bg_opacity_low));
    }
#endif /* __MMI_WALLPAPER_ON_BOTTOM__ */ 

    handle_inline_full_screen_edit_insert_title();

#ifdef __MMI_TOUCH_SCREEN__
    if ((g_dm_data.s32CatId == MMI_CATEGORY657_ID) &&
        dm_check_control_exist(g_dm_data.s32CatId, DM_HORIZONTAL_TAB_BAR))
    {
        wgui_horizontal_tab_bar_set_disable_reset_offset();
    }
#endif /* __MMI_TOUCH_SCREEN__ */ 

    gdi_layer_unlock_frame_buffer();

    dm_set_scr_bg_redraw(MMI_TRUE); 
    RedrawCategoryFunction();

    complete_inline_item_edit = handle_inline_full_screen_edit_close;

}


/*****************************************************************************
 * FUNCTION
 *  SetInlineItemFullScreenEdit_ext2
 * DESCRIPTION
 *  set data for inline full screen edit
 * PARAMETERS
 *  item                     [IN]      inline item   
 *  title                    [IN]      title string  
 *  title_icon               [IN]      title icon  
 *  buffer                   [IN]      buffer   
 *  buffer_size              [IN]      size of buffer  
 *  input_type               [IN]      input type      
 *  input_extended_type      [IN]      input extended type 
 *  required_input_mode_set  [IN]      requried input mode set
 * RETURNS
 *  void
 *****************************************************************************/
void SetInlineItemFullScreenEdit_ext2(
        InlineItem *item,
        U16 title,
        U16 title_icon,
        U8 *buffer,
        S32 buffer_size,
        U32 input_type,
        S16 input_extended_type,
        mmi_imm_input_mode_enum *required_input_mode_set
        )
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_inline_item_text_edit *i;
    UI_buffer_type mask_buffer;
    U32 t = input_type & INPUT_TYPE_MASK;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (n_inline_text_edit_items >= MAX_INLINE_TEXT_EDIT_ITEMS)
    {
        return;
    }
    wgui_inline_mem_alloc_info[wgui_inline_mem_alloc_number] = item->item = wgui_inline_malloc(sizeof(wgui_inline_item_text_edit));
    wgui_inline_mem_alloc_number++; 
    item->flags = INLINE_ITEM_TYPE_FULL_SCREEN_EDIT;
    n_inline_text_edit_items++;
    i = (wgui_inline_item_text_edit*) item->item;
    memset(i, 0, sizeof(wgui_inline_item_text_edit));
    i->mask_buffer = NULL;
    i->max_lines = 0;
    i->title = title;
    i->title_icon = title_icon;
    i->buffer = buffer;
    i->buffer_size = buffer_size;
    i->flags = 0;
    i->input_type = input_type;
    i->input_ext_type = input_extended_type;
    item->text_p = i->buffer;
    item->handler = handle_inline_full_screen_edit;
    i->edit_complete_callback = UI_dummy_edit_complete_handler;
    i->custom_setup_function = NULL;
    i->validation_callback = UI_dummy_validation_function;
    if ((t == IMM_INPUT_TYPE_NUMERIC_PASSWORD) || (t == IMM_INPUT_TYPE_ALPHANUMERIC_PASSWORD) ||
        (t == IMM_INPUT_TYPE_SAT_NUMERIC_PASSWORD) || (t == IMM_INPUT_TYPE_ASCII_PASSWORD))
    {
        wgui_inline_mem_alloc_info[wgui_inline_mem_alloc_number] = mask_buffer = (U8*)wgui_inline_malloc(MAX_INLINE_TEXT_EDIT_BUFFER_SIZE * sizeof(U8));
        wgui_inline_mem_alloc_number++; 
        inline_edit_prepare_mask_buffer(buffer, mask_buffer);
        i->mask_buffer = mask_buffer;
        item->text_p = mask_buffer;
    }
    /* UCS2_count==-1 means this field hasn't been edited */
    i->UCS2_count = -1;
    i->required_input_mode_set = required_input_mode_set;
}



/*****************************************************************************
 * FUNCTION
 *  SetInlineItemFullScreenEdit
 * DESCRIPTION
 *  Set data for inline full screen edit
 * PARAMETERS
 *  item            [IN]      inline item   
 *  title           [IN]      title string  
 *  title_icon      [IN]      title icon  
 *  buffer          [IN]      buffer   
 *  buffer_size     [IN]      size of buffer  
 *  input_type      [IN]      input type  
 * RETURNS
 *  void
 *****************************************************************************/
void SetInlineItemFullScreenEdit(
        InlineItem *item,
        U16 title,
        U16 title_icon,
        U8 *buffer,
        S32 buffer_size,
        U32 input_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    SetInlineItemFullScreenEdit_ext2(item, title, title_icon, buffer, buffer_size, input_type, 0, NULL);
}


/*****************************************************************************
 * FUNCTION
 *  SetInlineItemFullScreenEdit_ext
 * DESCRIPTION
 *  set data for inline full screen edit
 * PARAMETERS
 *  item                     [IN]      inline item   
 *  title                    [IN]      title string  
 *  title_icon               [IN]      title icon  
 *  buffer                   [IN]      buffer   
 *  buffer_size              [IN]      size of buffer  
 *  input_type               [IN]      input type      
 *  input_extended_type      [IN]      input extended type      
 * RETURNS
 *  void
 *****************************************************************************/
void SetInlineItemFullScreenEdit_ext(
        InlineItem *item,
        U16 title,
        U16 title_icon,
        U8 *buffer,
        S32 buffer_size,
        U32 input_type,
        S16 input_extended_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/


    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    SetInlineItemFullScreenEdit_ext2(item, title, title_icon, buffer, buffer_size, input_type, input_extended_type, NULL);

}


/*****************************************************************************
 * FUNCTION
 *  ReConfigureInlineItemFullScreenEdit_ext
 * DESCRIPTION
 *  re-configure inline full screen edit
 * PARAMETERS
 *  item            [IN]      inline item   
 *  title           [IN]      title string  
 *  title_icon      [IN]      title icon  
 *  buffer          [IN]      buffer   
 *  buffer_size     [IN]      size of buffer  
 *  input_type      [IN]      input type         
 * RETURNS
 *  void
 *****************************************************************************/
void ReConfigureInlineItemFullScreenEdit_ext(
        InlineItem *item,
        U16 title,
        U16 title_icon,
        U8 *buffer,
        S32 buffer_size,
           U32 input_type,
           S16 input_extended_type,
           mmi_imm_input_mode_enum *required_input_mode_set)
{

    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_inline_item_text_edit *i;
    UI_buffer_type mask_buffer;
    U32 t = input_type & INPUT_TYPE_MASK;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if ((item->flags & 0xff) != INLINE_ITEM_TYPE_FULL_SCREEN_EDIT)
    {
        return;
    }
    i = (wgui_inline_item_text_edit*) item->item;
    mask_buffer = i->mask_buffer;
    i->max_lines = 0;
    i->title = title;
    i->title_icon = title_icon;
    i->buffer = buffer;
    i->buffer_size = buffer_size;
    i->flags = 0;
    i->input_type = input_type;
    item->text_p = i->buffer;
    i->edit_complete_callback = UI_dummy_edit_complete_handler;
    i->custom_setup_function = NULL;
    if ((t == IMM_INPUT_TYPE_NUMERIC_PASSWORD) || (t == IMM_INPUT_TYPE_ALPHANUMERIC_PASSWORD) ||
        (t == IMM_INPUT_TYPE_SAT_NUMERIC_PASSWORD) || (t ==IMM_INPUT_TYPE_ASCII_PASSWORD))
    {
        inline_edit_prepare_mask_buffer(buffer, mask_buffer);
        i->mask_buffer = mask_buffer;
        item->text_p = mask_buffer;
    }
    i->input_ext_type = input_extended_type;
    i->required_input_mode_set = required_input_mode_set;
}


/*****************************************************************************
 * FUNCTION
 *  SetInlineFullScreenEditCustomFunction
 * DESCRIPTION
 *  set custom function of inline full screen edit
 * PARAMETERS
 *  item        [IN]    inline item         
 *  f           [IN]    custom function    
 * RETURNS
 *  void
 *****************************************************************************/
void SetInlineFullScreenEditCustomFunction(InlineItem *item, void (*f) (void))
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_inline_item_text_edit *i = (wgui_inline_item_text_edit*) item->item;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    i->custom_setup_function = f;
}


#if defined __MMI_PLUTO_GPRS__
/***************************************************************************** 
 * Inline Image Text 
 *
 * This is Image Text Inline item
 *****************************************************************************/

/***************************************************************************** 
 * Define
 *****************************************************************************/
#define  MAX_INLINE_IMAGE_TEXT_ITEMS      10
#define  IMAGE_TEXT_CONTROL_TEXT_X        26
#define  IMAGE_TEXT_CONTROL_TEXT_WIDTH    83


/***************************************************************************** 
 * Local Variable
 *****************************************************************************/
static PU8 inline_last_image = NULL;
static S32 inline_y_pos_image = 0;
static wgui_inline_image_text *current_image_text_control = NULL;
static S32 n_inline_image_text = 0;


/***************************************************************************** 
 * Local Function
 *****************************************************************************/
static void draw_image_text_control(
        wgui_inline_image_text *control,
        S32 x1,
        S32 y1,
        S32 iwidth,
        S32 iheight,
        PU8 image1,
        PU8 image2,
        PU8 image3,
        U8 *text,
        U8 highlight_flag);
static void handle_inline_full_screen_imagetext_edit(
        S32 x,
        S32 y,
        S32 width,
        S32 height,
        S32 key_code,
        S32 key_event,
        U8 **text_p,
        void *item,
        U32 flags,
        U8 *history_buffer);

#if defined (__MMI_INLINE_ITEM_IMAGETEXT__)
/***************************************************************************** 
 * Function Implementation
 *****************************************************************************/
 
/*****************************************************************************
 * FUNCTION
 *  SetInlineFullScreenEditCustomFunctionImageText
 * DESCRIPTION
 *  set custom function for inline imagetext full screen edit
 * PARAMETERS
 *  item        [IN]    inline item         
 *  f           [IN]    custom function    
 * RETURNS
 *  void
 *****************************************************************************/
void SetInlineFullScreenEditCustomFunctionImageText(InlineItem *item, void (*f) (void))
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_inline_image_text *image_item = (wgui_inline_image_text*) item->item;
    wgui_inline_item_text_edit *i = (wgui_inline_item_text_edit*) image_item->inline_full_text;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    i->custom_setup_function = f;
}


#ifdef __MMI_TOUCH_SCREEN__
/*****************************************************************************
 * FUNCTION
 *  inline_image_text_redraw_image_by_pen
 * DESCRIPTION
 *  redraw inline imagetext's image for pen event 
 * PARAMETERS
 *  i       [IN]    inline image text    
 * RETURNS
 *  void
 *****************************************************************************/
void inline_image_text_redraw_image_by_pen(wgui_inline_image_text *i)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 index = i->pen_down_image_index;
    PU8 image = NULL;   /* 111605 warning Calvin */
    S32 image_y_offset = 0;
    S32 x1, y1, x2, y2;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (index < 0)
    {
        return;
    }

    gdi_layer_push_clip();
    gdi_layer_reset_clip();
    gdi_layer_lock_frame_buffer();

    x1 = i->image_left_top[index].x;
    y1 = i->image_left_top[index].y;
    x2 = i->image_right_bottom[index].x;
    y2 = i->image_right_bottom[index].y;

#ifdef __MMI_FTE_SUPPORT__
    {
        UI_filled_area *f = current_MMI_theme->inline_item_textedit_highlighted_bg_filler;
        gui_draw_filled_area(i->x, i->y, i->x + i->width - 1, i->y + i->height - 1, f);
    }
#else
    gui_draw_filled_area(x1, y1, x2, y2 + 1, wgui_inline_select_fixed_text_menuitem_theme.selected_filler);
#endif

    if (index == i->pen_curr_pressed_image_index)
    {
        image_y_offset++;
    }

    if (index == 0)
    {
        image = i->image2;
    }
    else if (index == 1)
    {
        image = i->image3;
    }
    else
    {
        MMI_ASSERT(0);
    }

    gui_show_transparent_image(x1, y1 + image_y_offset, image, 0);

    gui_pop_clip();

    gdi_layer_unlock_frame_buffer();
    gdi_layer_blt_previous(x1, y1, x2, y2 + 1);
}


/*****************************************************************************
 * FUNCTION
 *  inline_image_text_pen_handler
 * DESCRIPTION
 *  pen handler of inline image text
 * PARAMETERS
 *  pen_event       [IN]    pen event    
 *  x               [IN]    pen x position    
 *  y               [IN]    pen y position    
 *  item_event      [IN]    inline pen enum     
 * RETURNS
 *  ret
 *****************************************************************************/
BOOL inline_image_text_pen_handler(
        mmi_pen_event_type_enum pen_event,
        S16 x,
        S16 y,
        gui_inline_item_pen_enum *item_event)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    BOOL ret = MMI_TRUE;
    wgui_inline_image_text *i = current_image_text_control;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    *item_event = GUI_INLINE_ITEM_PEN_NONE;

    if (!i)
    {
        MMI_DBG_ASSERT(0);
        return MMI_FALSE;
    }

    switch (pen_event)
    {
        case MMI_PEN_EVENT_DOWN:
            i->pen_down_image_index = -1;
            if (i->image2 && i->image_callback[0] && x >= i->image_left_top[0].x && y >= i->image_left_top[0].y &&
                x <= i->image_right_bottom[0].x && y <= i->image_right_bottom[0].y)
            {
                i->pen_down_image_index = 0;
                i->pen_curr_pressed_image_index = 0;
                inline_image_text_redraw_image_by_pen(i);
            }
            else if (i->image3 && i->image_callback[1] && x >= i->image_left_top[1].x && y >= i->image_left_top[1].y &&
                     x <= i->image_right_bottom[1].x && y <= i->image_right_bottom[1].y)
            {
                i->pen_down_image_index = 1;
                i->pen_curr_pressed_image_index = 1;
                inline_image_text_redraw_image_by_pen(i);
            }
            else
            {
                ret = MMI_FALSE;
            }
            break;

        case MMI_PEN_EVENT_MOVE:
            if (i->pen_down_image_index >= 0)
            {
                S32 index = i->pen_down_image_index;

                if (i->pen_curr_pressed_image_index == i->pen_down_image_index)
                {
                    if (!(x >= i->image_left_top[index].x && y >= i->image_left_top[index].y &&
                          x <= i->image_right_bottom[index].x && y <= i->image_right_bottom[index].y))
                    {
                        i->pen_curr_pressed_image_index = -1;
                        inline_image_text_redraw_image_by_pen(i);
                    }
                }
                else
                {
                    if (x >= i->image_left_top[index].x && y >= i->image_left_top[index].y &&
                        x <= i->image_right_bottom[index].x && y <= i->image_right_bottom[index].y)
                    {
                        i->pen_curr_pressed_image_index = index;
                        inline_image_text_redraw_image_by_pen(i);
                    }
                }
            }
            break;

        case MMI_PEN_EVENT_UP:
            if (i->pen_down_image_index >= 0 && i->pen_curr_pressed_image_index >= 0)
            {
                i->pen_curr_pressed_image_index = -1;
                inline_image_text_redraw_image_by_pen(i);

                if (i->image_callback[i->pen_down_image_index])
                {
                   // (i->image_callback[i->pen_down_image_index]) ();
                    mmi_event_struct evt;

                    MMI_FRM_INIT_EVENT(&evt, EVT_ID_INLINE_IMAGETEXT_PEN_UP);
                    evt.user_data = (void *)i->image_callback[i->pen_down_image_index];

                    MMI_FRM_CB_EMIT_POST_EVENT(&evt);
                }
            }
            break;

        case MMI_PEN_EVENT_ABORT:
            if (i->pen_down_image_index >= 0 && i->pen_curr_pressed_image_index >= 0)
            {
                i->pen_curr_pressed_image_index = -1;
                inline_image_text_redraw_image_by_pen(i);
            }
            break;

    }

    return ret;
}

#endif /* __MMI_TOUCH_SCREEN__ */ 


/*****************************************************************************
 * FUNCTION
 *  SetInlineItemImageText
 * DESCRIPTION
 *  set data of linline image text
 * PARAMETERS
 *  item            [IN]      inline item   
 *  text            [IN]      buffer   
 *  image1          [IN]      image 1   
 *  image2          [IN]      image 2  
 *  image3          [IN]      image 3  
 *  buf_size        [IN]      size of buffer  
 *  title           [IN]      title string  
 *  title_icon      [IN]      title icon  
 *  input_type      [IN]      input type  
 * RETURNS
 *  void
 *****************************************************************************/
void SetInlineItemImageText(
        InlineItem *item,
        U8 *text,
        PU8 image1,
        PU8 image2,
        PU8 image3,
        S32 buf_size,
        U16 title,
        U16 title_icon,
        U32 input_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_inline_image_text *image_item;
    wgui_inline_item_text_edit *i;
    UI_buffer_type mask_buffer;
    U32 t = input_type & INPUT_TYPE_MASK;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (n_inline_image_text >= MAX_INLINE_IMAGE_TEXT_ITEMS)
    {
        return;
    }
    if (n_inline_text_edit_items >= MAX_INLINE_TEXT_EDIT_ITEMS)
    {
        return;
    }
    wgui_inline_mem_alloc_info[wgui_inline_mem_alloc_number] = item->item = wgui_inline_malloc(sizeof(wgui_inline_image_text));
    wgui_inline_mem_alloc_number++; 
    item->flags = INLINE_ITEM_IMAGE_TEXT_TYPE;
    item->show_img_flag = FALSE;
    n_inline_image_text++;
    image_item = (wgui_inline_image_text*) item->item;
    image_item->flags = 0;
    image_item->buffer_size = buf_size;
    image_item->image1 = image1;
    image_item->image2 = image2;
    image_item->image3 = image3;
    image_item->text = text;
    item->handler = handle_inline_full_screen_imagetext_edit;
#ifdef __MMI_TOUCH_SCREEN__
    memset(image_item->image_callback, 0, sizeof(image_item->image_callback));
    memset(image_item->image_left_top, 0, sizeof(image_item->image_left_top));
    memset(image_item->image_right_bottom, 0, sizeof(image_item->image_right_bottom));
    image_item->pen_down_image_index = -1;
    image_item->pen_curr_pressed_image_index = -1;
#endif /* __MMI_TOUCH_SCREEN__ */ 

    wgui_inline_mem_alloc_info[wgui_inline_mem_alloc_number] = image_item->inline_full_text = wgui_inline_malloc(sizeof(wgui_inline_item_text_edit)); 
    wgui_inline_mem_alloc_number++; 
    n_inline_text_edit_items++;
    i = (wgui_inline_item_text_edit*) image_item->inline_full_text;
    i->mask_buffer = NULL;
    i->title = title;
    i->title_icon = title_icon;
    i->buffer = text;
    i->buffer_size = buf_size;
    i->flags = 0;
    i->input_type = input_type;
    item->text_p = i->buffer;
    i->edit_complete_callback = UI_dummy_edit_complete_handler;
    i->custom_setup_function = NULL;
    i->validation_callback = UI_dummy_validation_function;
    if ((t == IMM_INPUT_TYPE_NUMERIC_PASSWORD) || (t == IMM_INPUT_TYPE_ALPHANUMERIC_PASSWORD) ||
        (t == IMM_INPUT_TYPE_SAT_NUMERIC_PASSWORD) || (t ==IMM_INPUT_TYPE_ASCII_PASSWORD))
    {
        wgui_inline_mem_alloc_info[wgui_inline_mem_alloc_number] = mask_buffer = (U8*)wgui_inline_malloc(MAX_INLINE_TEXT_EDIT_BUFFER_SIZE * sizeof(U8));
        wgui_inline_mem_alloc_number++;       
        inline_edit_prepare_mask_buffer(text, mask_buffer);
        i->mask_buffer = mask_buffer;
        item->text_p = mask_buffer;
    }
    /* UCS2_count==-1 means this field hasn't been edited */
    i->UCS2_count = -1;

}


#ifdef __MMI_TOUCH_SCREEN__
/*****************************************************************************
 * FUNCTION
 *  SetInlineImageTextPenHandler
 * DESCRIPTION
 *  set pen handlers of inline image text
 * PARAMETERS
 *  item                [IN]    inline item         
 *  image2_callback     [IN]    image2 callback function    
 *  image3_callback     [IN]    image3 callback function    
 * RETURNS
 *  void
 *****************************************************************************/
void SetInlineImageTextPenHandler(InlineItem *item, FuncPtr image2_callback, FuncPtr image3_callback)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_inline_image_text *image_item = (wgui_inline_image_text*) item->item;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    image_item->image_callback[0] = image2_callback;
    image_item->image_callback[1] = image3_callback;
}
#endif /* __MMI_TOUCH_SCREEN__ */ 

typedef struct
{
    U16 history_ID;
    U8 is_open;
} inline_image_text_history_struct;

/*****************************************************************************
 * FUNCTION
 *  inline_image_text_get_history
 * DESCRIPTION
 *  get history buffer for inline image text edit
 * PARAMETERS
 *  history_buffer      [OUT]       history buffer  
 * RETURNS
 *  history buffer
 *****************************************************************************/
U8 *inline_image_text_get_history(U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (history_buffer != NULL)
    {
        U16 hID = (U16) (INLINE_IMAGE_TEXT_HISTORY_ID | 0x8000);
        inline_image_text_history_struct *h = (inline_image_text_history_struct*) history_buffer;

        h->history_ID = hID;
        h->is_open = inline_image_text_edit_flag;
    }
    return (history_buffer);
}


/*****************************************************************************
 * FUNCTION
 *  inline_image_text_set_history
 * DESCRIPTION
 *  get history buffer for inline image text edit
 * PARAMETERS
 *  history_ID          [IN]        category id
 *  history_buffer      [OUT]       history buffer
 * RETURNS
 *  history buffer
 *****************************************************************************/
U8 inline_image_text_set_history(U16 history_ID, U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
   
    if (history_buffer != NULL)
    {
        inline_image_text_history_struct *h = (inline_image_text_history_struct*) history_buffer;

        if (history_valid(h->history_ID, history_ID))
        {
            inline_image_text_edit_flag = h->is_open;
            return (1);
        }
    }
    return (0);

}
#endif /*__MMI_TOUCH_SCREEN__*/


/*****************************************************************************
 * FUNCTION
 *  wgui_inlinescrolling_timer
 * DESCRIPTION
 *  inline scrolling timer function
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_inlinescrolling_timer(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_handle_scrolling_text(&wgui_inline_scroll_text);
    if (inline_last_image)
    {
        gui_show_transparent_image(103, inline_y_pos_image, inline_last_image, 0);
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_scrolling_text_draw_background
 * DESCRIPTION
 *  draw background of scrolling text
 * PARAMETERS
 *  x1      [IN]        left-top corner x1 coordinate      
 *  y1      [IN]        left-top corner y1 coordinate
 *  x2      [IN]        right-bottom corner x2 coordinate
 *  y2      [IN]        right-bottom corner y2 coordinate
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_scrolling_text_draw_background(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 * image = NULL;
    UI_filled_area *bg_filler = NULL;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_FTE_SUPPORT__
    if(((wgui_inline_items[wgui_inline_item_highlighted_index].flags & 0xff) == INLINE_ITEM_TYPE_DISPLAY_ONLY) ||
       ((wgui_inline_items[wgui_inline_item_highlighted_index].flags & 0xff) == INLINE_ITEM_TYPE_FULL_SCREEN_EDIT))  
    {
       wgui_inline_item_text_edit *i = (wgui_inline_item_text_edit*) wgui_inline_items[wgui_inline_item_highlighted_index].item;
        if(wgui_inline_items[wgui_inline_item_highlighted_index].flags & INLINE_ITEM_DISPLAY_ONLY_SHOW)
        {
            image = (U8*) GetImage(IMG_INLINE_DISPLAY_ONLY_HIGHLIGHT_BG);
            gdi_image_draw_resized(i->x, i->y, i->width, i->height, image);
        }
        else
        {
            if(i->status_flag == 0)
            {
                bg_filler = current_MMI_theme->inline_item_button_highlighted_normal_bg_filler;         
            }
            else
            {
                bg_filler = current_MMI_theme->inline_item_button_highlighted_pressed_bg_filler;    
            }

            gui_draw_filled_area(i->x, i->y, i->x + i->width - 1, i->y + i->height - 1, bg_filler);
        }    
             
    }
    else if((wgui_inline_items[wgui_inline_item_highlighted_index].flags & 0xff) == INLINE_ITEM_IMAGE_TEXT_TYPE)
    {
       wgui_inline_image_text  *i = (wgui_inline_image_text*) wgui_inline_items[wgui_inline_item_highlighted_index].item;
       bg_filler = current_MMI_theme->inline_item_textedit_highlighted_bg_filler;
       gui_draw_filled_area(i->x, i->y, i->x + i->width - 1, i->y + i->height - 1, bg_filler);   
    }
#else
    gui_draw_filled_area(x1, y1, x2, y2, (wgui_inline_select_fixed_text_menuitem_theme.selected_filler));
#endif
}


#ifdef __MMI_INLINE_ITEM_IMAGETEXT__
/*****************************************************************************
 * FUNCTION
 *  wgui_show_image_text_control
 * DESCRIPTION
 *  show image text control
 * PARAMETERS
 *  i       [IN]    inline image text     
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_show_image_text_control(wgui_inline_image_text *i)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    //S32 y1 = i->y ;
    //S32 height = 0;
    wgui_inline_item_text_edit *i_edit = (wgui_inline_item_text_edit*) i->inline_full_text;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    draw_image_text_control(i, i->x, i->y, i->width, i->height, i->image1, i->image2, i->image3, i_edit->buffer, 1);

}


/*****************************************************************************
 * FUNCTION
 *  redraw_image_text_control
 * DESCRIPTION
 *  redraw image text control
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void redraw_image_text_control(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();
    wgui_show_image_text_control(current_image_text_control);
    gdi_layer_unlock_frame_buffer();
    gdi_layer_blt_previous(
        current_image_text_control->x,
        current_image_text_control->y,
        current_image_text_control->x + current_image_text_control->width - 1,
        current_image_text_control->y + current_image_text_control->height - 1);
}



/*****************************************************************************
 * FUNCTION
 *  draw_image_text_control
 * DESCRIPTION
 *  draw image text control
 * PARAMETERS
 *  control             [IN]    inline image text         
 *  x1                  [IN]    left-top corner x1 coordinate    
 *  y1                  [IN]    left-top corner y1 coordinate    
 *  iwidth              [IN]    width    
 *  iheight             [IN]    height    
 *  image1              [IN]    image 1    
 *  image2              [IN]    image 2    
 *  image3              [IN]    image 3    
 *  text                [?]     buffer    
 *  highlight_flag      [IN]    highlight flag    
 * RETURNS
 *  void
 *****************************************************************************/
static void draw_image_text_control(
        wgui_inline_image_text *control,
        S32 x1,
        S32 y1,
        S32 iwidth,
        S32 iheight,
        PU8 image1,
        PU8 image2,
        PU8 image3,
        U8 *text,
        U8 highlight_flag)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 width = 0, height = 0, char_height = 0, img_y1 = 0, text_y;
    color text_colr = gui_color(0, 0, 0);
    S32 temp_x = x1 + 1;
    S32 text_x = 0, text_width = 0, text_height = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_push_clip();
    gdi_layer_reset_clip();
    gui_reset_text_clip();

    gui_set_font(MMI_fixed_icontext_menuitem.text_font);
    
#ifdef __MMI_FTE_SUPPORT__
    if (highlight_flag)
    {
        UI_filled_area *f = current_MMI_theme->inline_item_textedit_highlighted_bg_filler;
        gui_draw_filled_area(x1, y1, x1 + iwidth - 1, y1 + iheight - 1, f);
    }
    else
    {
        UI_filled_area *f = current_MMI_theme->inline_item_textedit_unhighlighted_bg_filler;
        gui_draw_filled_area(x1, y1, x1 + iwidth - 1, y1 + iheight - 1, f);
    }

    temp_x = x1 + INLINE_FTE_SINGLELINE_TEXT_OFFSET;
    if(image2)
    {
        gui_measure_image((PU8) image1, &width, &height);
        img_y1 = (iheight >> 1) - (height >> 1);
        gui_show_transparent_image(temp_x, (y1 + img_y1), image1, 0);
	#if defined(__MMI_TOUCH_SCREEN__)
        if (control)
        {
            control->image_left_top[0].x = temp_x;
            control->image_left_top[0].y = y1 + img_y1;
            control->image_right_bottom[0].x = temp_x + width - 1;
            control->image_right_bottom[0].y = y1 + img_y1 + height - 1;
        }
	#endif /* __MMI_TOUCH_SCREEN__ */
        temp_x +=  width + GUI_COLOR_SELECT_FTE_BOX_BETWEEN_GAP;
        text_x = temp_x;
    }
    else
    {
        text_x = temp_x;
    }

    temp_x = x1 + iwidth -1 - INLINE_FTE_SINGLELINE_TEXT_OFFSET;
    if(image3)
    {
        gui_measure_image(image3, &width, &height);
        temp_x -= width;
        img_y1 = (iheight >> 1) - (height >> 1);
        gui_show_transparent_image(temp_x, (y1 + img_y1), image3, 0);
	#if defined(__MMI_TOUCH_SCREEN__)
        if (control)
        {
            control->image_left_top[1].x = temp_x;
            control->image_left_top[1].y = y1 + img_y1;
            control->image_right_bottom[1].x = temp_x + width - 1;
            control->image_right_bottom[1].y = y1 + img_y1 + height - 1;
        }
	#endif /* __MMI_TOUCH_SCREEN__ */
        temp_x -= GUI_COLOR_SELECT_FTE_BOX_BETWEEN_GAP;
    }
    text_width = temp_x - text_x;
    
    char_height = gui_get_character_height();

    gui_measure_string((UI_string_type) text, &width, &height);
    text_height = height;
    text_y = y1 + (iheight >> 1) - (height >> 1);
    if (highlight_flag)
    {
        text_colr = wgui_inline_singleline_inputbox_focussed_theme.normal_text_color;
        if (width > text_width)
        {
            gui_create_scrolling_text(&wgui_inline_scroll_text, text_x, text_y, text_width + 1, text_height, (UI_string_type) text, wgui_inlinescrolling_timer, wgui_scrolling_text_draw_background, text_colr, text_colr);     /* 031205 Calvin modified */
            gui_show_scrolling_text(&wgui_inline_scroll_text);
        }
        else
        {
            gdi_layer_set_clip(text_x, text_y - 1, text_x + text_width, text_y + text_height + 1);
            gui_move_text_cursor(text_x, text_y);
            gui_set_line_height(text_height);
            gui_set_text_color(text_colr);
            gui_print_text((UI_string_type) text);
        }
    }
    else
    {
        text_colr = wgui_inline_singleline_inputbox_focussed_theme.normal_text_color;
        gdi_layer_set_clip(text_x, text_y - 1, text_x + text_width, text_y + text_height + 1);
        gui_move_text_cursor(text_x, text_y);
        gui_set_line_height(text_height);
        gui_set_text_color(text_colr);
        gui_print_text((UI_string_type) text);
    }
#else
    /* MTK Elvis for R2L characters */
    if (!mmi_fe_get_r2l_state())
    {
        if (image1)
        {
            gui_measure_image((PU8) image1, &width, &height);
            img_y1 = (MMI_INLINE_EDIT_MENUITEM_HEIGHT >> 1) - (height >> 1);
           // gui_show_transparent_image(temp_x, (y1 + img_y1), image1, 0);
            temp_x = x1 + width + 4;
        }
        else

    #ifdef __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__
        if (!IsInlineItemDefaultTextEnable())
    #endif 

            temp_x = x1 + MMI_fixed_icontext_menuitem.text_x;
        if (image2)
        {
            gui_measure_image(image2, &width, &height);
            img_y1 = (MMI_INLINE_EDIT_MENUITEM_HEIGHT >> 1) - (height >> 1);
            gui_show_transparent_image(temp_x, (y1 + img_y1), image2, 0);
            text_x = temp_x + width + 2;
            text_width = iwidth - text_x;
        #ifdef __MMI_TOUCH_SCREEN__
            if (control)
            {
                control->image_left_top[0].x = temp_x;
                control->image_left_top[0].y = y1 + img_y1;
                control->image_right_bottom[0].x = temp_x + width - 1;
                control->image_right_bottom[0].y = y1 + img_y1 + height - 1;
            }
        #endif /* __MMI_TOUCH_SCREEN__ */ 
        }
        else
        {
            text_x = temp_x;
            text_width = iwidth - text_x - x1 - 4;
        }
        if (image3)
        {
            gui_measure_image(image3, &width, &height);
            temp_x = x1 + 1 + iwidth - width - 2;
            img_y1 = (MMI_INLINE_EDIT_MENUITEM_HEIGHT >> 1) - (height >> 1);
            gui_show_transparent_image(temp_x, (y1 + img_y1), image3, 0);
            text_width = temp_x - text_x - 2;
        #ifdef __MMI_TOUCH_SCREEN__
            if (control)
            {
                control->image_left_top[1].x = temp_x;
                control->image_left_top[1].y = y1 + img_y1;
                control->image_right_bottom[1].x = temp_x + width - 1;
                control->image_right_bottom[1].y = y1 + img_y1 + height - 1;
            }
        #endif /* __MMI_TOUCH_SCREEN__ */ 
        }

    }
    else
    {
        temp_x = x1 + iwidth - 1;
        if (image1)
        {
            gui_measure_image((PU8) image1, &width, &height);
            //img_y1 = (MMI_INLINE_EDIT_MENUITEM_HEIGHT >> 1) - (height >> 1);
            temp_x -= width;
            gui_show_transparent_image(temp_x, (y1 + img_y1), image1, 0);

        }
        else
        {
            temp_x = x1 + iwidth - MMI_fixed_icontext_menuitem.text_x;
        }

        if (image3)
        {
            gui_measure_image(image3, &width, &height);
            img_y1 = (MMI_INLINE_EDIT_MENUITEM_HEIGHT >> 1) - (height >> 1);
            temp_x -= (width + 2);
            gui_show_transparent_image(temp_x, (y1 + img_y1), image3, 0);
            text_x = temp_x - 2;
            text_width = iwidth - (UI_device_width - text_x);
        #ifdef __MMI_TOUCH_SCREEN__
            if (control)
            {
                control->image_left_top[1].x = temp_x;
                control->image_left_top[1].y = y1 + img_y1;
                control->image_right_bottom[1].x = temp_x + width - 1;
                control->image_right_bottom[1].y = y1 + img_y1 + height - 1;
            }
        #endif /* __MMI_TOUCH_SCREEN__ */ 
        }
        else
        {
            text_x = temp_x - 1;
            text_width = iwidth - (UI_device_width - text_x) - 2;
        }

        if (image2)
        {
            gui_measure_image(image2, &width, &height);
            img_y1 = (MMI_INLINE_EDIT_MENUITEM_HEIGHT >> 1) - (height >> 1);
            temp_x = (UI_device_width - 1) - iwidth + 2;
            gui_show_transparent_image(temp_x, (y1 + img_y1), image2, 0);
            text_width = text_x - temp_x - 2 - width;
        #ifdef __MMI_TOUCH_SCREEN__
            if (control)
            {
                control->image_left_top[0].x = temp_x;
                control->image_left_top[0].y = y1 + img_y1;
                control->image_right_bottom[0].x = temp_x + width - 1;
                control->image_right_bottom[0].y = y1 + img_y1 + height - 1;
            }
        #endif /* __MMI_TOUCH_SCREEN__ */ 
        }

    }

    char_height = gui_get_character_height();

    if (highlight_flag)
    {
        gui_set_font((UI_font_type)gui_font_get_type(GUI_FONT_SIZE_LIST_HIGHLIGHT));
    }
    gui_measure_string((UI_string_type) text, &width, &height);
    text_height = height;
    text_y = y1 + (MMI_INLINE_EDIT_MENUITEM_HEIGHT >> 1) - (height >> 1);
    if (highlight_flag)
    {
        text_colr = MMI_fixed_icontext_menuitem.focussed_text_color;
        if (width > text_width)
        {
            if (mmi_fe_get_r2l_state())
            {
                gui_create_scrolling_text(&wgui_inline_scroll_text, text_x - text_width + 1, text_y, text_width, text_height, (UI_string_type) text, wgui_inlinescrolling_timer, wgui_scrolling_text_draw_background, text_colr, text_colr);        /* 031205 Calvin modified */
            }
            else
            {
                gui_create_scrolling_text(&wgui_inline_scroll_text, text_x, text_y, text_width + 1, text_height, (UI_string_type) text, wgui_inlinescrolling_timer, wgui_scrolling_text_draw_background, text_colr, text_colr);     /* 031205 Calvin modified */
            }
            gui_show_scrolling_text(&wgui_inline_scroll_text);
        }
        else
        {
            if (mmi_fe_get_r2l_state())
            {
                gdi_layer_set_clip(text_x - text_width, text_y - 1, text_x, text_y + text_height + 1);
            }
            else
            {
                gdi_layer_set_clip(text_x, text_y - 1, text_x + text_width, text_y + text_height + 1);
            }
            gui_move_text_cursor(text_x, text_y);
            gui_set_line_height(text_height);
            gui_set_text_color(text_colr);
            gui_print_text((UI_string_type) text);
        }
    }
    else
    {
        text_colr = MMI_fixed_icontext_menuitem.normal_text_color;
        if (mmi_fe_get_r2l_state())
        {
            gdi_layer_set_clip(text_x - text_width + 1, text_y - 1, text_x, text_y + text_height + 1);
        }
        else
        {
            gdi_layer_set_clip(text_x, text_y - 1, text_x + text_width, text_y + text_height + 1);
        }
        gui_move_text_cursor(text_x, text_y);
        gui_set_line_height(text_height);
        gui_set_text_color(text_colr);
        gui_print_text((UI_string_type) text);
    }
#endif    
    gui_pop_clip();
    UI_UNUSED_PARAMETER(char_height);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_show_image_text_item
 * DESCRIPTION
 *  show image text item
 * PARAMETERS
 *  x1                  [IN]    left-top corner x1 coordinate    
 *  y1                  [IN]    left-top corner y1 coordinate    
 *  iwidth              [IN]    width    
 *  iheight             [IN]    height          
 *  item                [IN]    inline item         
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_show_image_text_item(S32 x1, S32 y1, S32 iwidth, S32 iheight, wgui_inline_item *item)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    wgui_inline_image_text *i = (wgui_inline_image_text*) item->item;
    wgui_inline_item_text_edit *i_edit = (wgui_inline_item_text_edit*) i->inline_full_text;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    draw_image_text_control(i, x1, y1, iwidth, iheight, i->image1, i->image2, i->image3, i_edit->buffer, 0);

}


/*****************************************************************************
 * FUNCTION
 *  clear_inline_image_text_item
 * DESCRIPTION
 *  clear inline image text
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void clear_inline_image_text_item(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_scrolling_text_stop(&wgui_inline_scroll_text);
    memset(&wgui_inline_scroll_text, 0, sizeof(wgui_inline_scroll_text));
    clear_inline_item_keys = UI_dummy_function;
    redraw_current_inline_item = UI_dummy_function;
#ifdef __MMI_TOUCH_SCREEN__
    wgui_current_inline_item_pen_function = UI_dummy_inline_item_pen_function;
#endif 
}


/*****************************************************************************
 * FUNCTION
 *  wgui_show_image_text_item_highlight
 * DESCRIPTION
 *  show image text item highlight
 * PARAMETERS
 *  x1                  [IN]    left-top corner x1 coordinate    
 *  y1                  [IN]    left-top corner y1 coordinate    
 *  iwidth              [IN]    width    
 *  iheight             [IN]    height          
 *  item                [IN]    inline item        
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_show_image_text_item_highlight(S32 x1, S32 y1, S32 iwidth, S32 iheight, wgui_inline_item *item)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_inline_image_text *i = (wgui_inline_image_text*) item->item;
    wgui_inline_item_text_edit *i_edit = (wgui_inline_item_text_edit*) i->inline_full_text;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    i->x = x1;
    i->y = y1;
    i->width = iwidth;
    i->height = iheight;

    clear_inline_item_keys = clear_inline_image_text_item;
    redraw_current_inline_item = redraw_image_text_control;
#ifdef __MMI_TOUCH_SCREEN__
    wgui_current_inline_item_pen_function = inline_image_text_pen_handler;
#endif 
    current_image_text_control = i;
    draw_image_text_control(i, x1, y1, iwidth, iheight, i->image1, i->image2, i->image3, i_edit->buffer, 1);

}


/*****************************************************************************
 * FUNCTION
 *  handle_inline_full_screen_imagetext_edit
 * DESCRIPTION
 *  activation of inline full screen imagetext edit
 * PARAMETERS
 *  x                   [IN]        left corner's x coordinate
 *  y                   [IN]        left corner's y coordinate
 *  width               [IN]        width
 *  height              [IN]        height
 *  key_code            [IN]        key code
 *  key_event           [IN]        key event
 *  text_p              [IN]        text pointer
 *  item                [IN]         inline item
 *  flags               [IN]        flags
 *  history_buffer      [IN]         history buffer        
 * RETURNS
 *  void
 *****************************************************************************/
static void handle_inline_full_screen_imagetext_edit(
        S32 x,
        S32 y,
        S32 width,
        S32 height,
        S32 key_code,
        S32 key_event,
        U8 **text_p,
        void *item,
        U32 flags,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 input_type;
    wgui_inline_image_text *image_type = (wgui_inline_image_text*) item;

    wgui_inline_item_text_edit *i = (wgui_inline_item_text_edit*) image_type->inline_full_text;
    
    S32 inputbox_x, inputbox_y, inputbox_width, inputbox_height;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if !defined(GUI_EDITOR_SHOW_TITLE)
    inputbox_x = MMI_COMMON_CONTENT_X;
    inputbox_y = MMI_COMMON_CONTENT_Y - MMI_COMMON_TITLE_HEIGHT;
    inputbox_width = MMI_COMMON_CONTENT_WIDTH;
    inputbox_height = MMI_COMMON_CONTENT_HEIGHT + MMI_COMMON_TITLE_HEIGHT;
#else 
    inputbox_x = MMI_COMMON_CONTENT_X;
    inputbox_y = MMI_COMMON_CONTENT_Y;
    inputbox_width = MMI_COMMON_CONTENT_WIDTH;
    inputbox_height = MMI_COMMON_CONTENT_HEIGHT;
#endif 
    UI_UNUSED_PARAMETER(x);
    UI_UNUSED_PARAMETER(y);
    UI_UNUSED_PARAMETER(width);
    UI_UNUSED_PARAMETER(height);
    UI_UNUSED_PARAMETER(key_code);
    UI_UNUSED_PARAMETER(key_event);
    UI_UNUSED_PARAMETER(flags);

    if(cui_inline_is_current_cui())
    {
        cui_inline_evt_item_activate(); 
        return;
    }
    else
    {
        if (i->custom_setup_function != NULL)
        {
            i->custom_setup_function();
            return;
        }
    }

    gdi_layer_lock_frame_buffer();
    wgui_text_menuitem_reset_scrolling();
    clear_inline_image_text_item();

    if (i->flags & INLINE_ITEM_CHANGED)
    {
        inline_full_screen_edit_changed = 1;
    }
    else
    {
        inline_full_screen_edit_changed = 0;
    }
    wgui_current_inline_item_type = INLINE_ITEM_TYPE_FULL_SCREEN_EDIT;
    current_wgui_inline_text_edit_item = i;

    current_wgui_inline_text_edit_text_p = text_p;

    input_type = i->input_type;
    if (inline_image_text_edit_flag == 0)
    {
        if (!(flags & INLINE_ITEM_OPEN))
        {
            gui_strcpy((UI_string_type) wgui_inline_full_screen_text_edit_buffer, (UI_string_type) i->buffer);
            history_buffer = NULL;
        }
    }
    inline_image_text_edit_flag = 1;

    i->flags &= ~INLINE_ITEM_OPEN;
    inline_full_screen_edit_saved_title = MMI_title_string;
    inline_full_screen_edit_saved_title_icon = MMI_title_icon;
    inline_full_screen_edit_saved_LSK_label = MMI_softkeys[MMI_LEFT_SOFTKEY].text;
    inline_full_screen_edit_saved_RSK_label = MMI_softkeys[MMI_RIGHT_SOFTKEY].text;
    change_left_softkey(STR_GLOBAL_OK, IMG_GLOBAL_OK);
    change_right_softkey(STR_GLOBAL_BACK, IMG_GLOBAL_BACK);
    wgui_title_set_menu_shortcut_number(-1);
    wgui_title_disable_menu_shortcut_display(MMI_TRUE);
    clear_key_handlers();
    change_left_softkey(STR_GLOBAL_OK, IMG_GLOBAL_OK);
    change_right_softkey(STR_GLOBAL_BACK, IMG_GLOBAL_BACK);
    clear_left_softkey();
    clear_right_softkey();
    register_left_softkey_handler();
    register_right_softkey_handler();
    register_default_hide_softkeys();
    MMI_title_string = get_string(i->title);
    MMI_title_icon = get_image(i->title_icon);
    wgui_inputbox_validation_callback = i->validation_callback;
    wgui_setup_inputbox(
        inputbox_x,
        inputbox_y,
        inputbox_width,
        inputbox_height,
        wgui_inline_full_screen_text_edit_buffer,
        i->buffer_size,
        INLINE_FULL_SCREEN_EDIT_HISTORY_ID,
        get_string(STR_GLOBAL_BACK),
        get_image(IMG_GLOBAL_BACK),
        (S16) input_type,
        history_buffer,
    #ifdef __MMI_FTE_SUPPORT__        
        0
    #else
        1
    #endif    
        );
    inputbox_height = MMI_content_height - MMI_multitap_height - wgui_inputbox_information_bar_height;
    if (MMI_multiline_inputbox.height > inputbox_height)
    {
        gui_resize_multi_line_input_box(&MMI_multiline_inputbox, MMI_multiline_inputbox.width, inputbox_height);
    }


#ifdef __MMI_WALLPAPER_ON_BOTTOM__
    if (!inline_opacity_changed)
    {
        MMI_multiline_inputbox.flags |= UI_MULTI_LINE_INPUT_BOX_TRANSPARENT_BACKGROUND;
        handle_inline_full_screen_edit_opacity_set((U8)(current_MMI_theme->bg_opacity_low));    
    }
#endif /* __MMI_WALLPAPER_ON_BOTTOM__ */ 

    handle_inline_full_screen_edit_insert_title();

    register_multiline_inputbox_input_callback(wgui_inline_edit_handle_multiline_inputbox_input);
    wgui_inputbox_RSK_function = handle_inline_full_screen_edit_cancel;
    redraw_current_inline_item = redraw_inline_full_screen_edit;
    set_left_softkey_function(handle_inline_full_screen_edit_complete, KEY_EVENT_UP);
    mmi_imc_key_setup_lsk_function(handle_inline_full_screen_edit_complete);

    gdi_layer_unlock_frame_buffer();
    redraw_inline_full_screen_edit();
    complete_inline_item_edit = handle_inline_full_screen_edit_close;

}

#endif  /* defined (__MMI_INLINE_ITEM_IMAGETEXT__) */
#endif /* defined __MMI_PLUTO_GPRS__ */ 


/***************************************************************************** 
 * Inline Select    
 *
 * This is Inline Select Item
 *****************************************************************************/

/***************************************************************************** 
 * Define
 *****************************************************************************/
#define  MAX_INLINE_SELECT_MENU_ITEMS  60

#ifdef __MMI_DOWNLOADABLE_THEMES_SUPPORT__
#define MAX_INLINE_SELECT_ITEMS        25
#elif !defined(LOW_COST_SUPPORT)
#define MAX_INLINE_SELECT_ITEMS        16
#else
#define MAX_INLINE_SELECT_ITEMS        11
#endif


/***************************************************************************** 
 * Local Variable
 *****************************************************************************/
static gui_horizontal_select_item_struct *wgui_inline_select_items;


static S32 n_inline_select_items = 0;
static wgui_inline_item_select *current_wgui_inline_select_item = NULL;
static S32 *current_wgui_inline_select_highlighted_item = NULL;
static PU8 *current_wgui_inline_select_text_p = NULL;

/***************************************************************************** 
 * Global Variable
 *****************************************************************************/
gui_horizontal_select_struct g_wgui_inline_select_item;


/***************************************************************************** 
 * Function Implementation
 *****************************************************************************/

#ifdef __MMI_FTE_SUPPORT__

/*****************************************************************************
 * FUNCTION
 *  wgui_show_fte_select_item_unhighlight
 * DESCRIPTION
 *  show inline select item when fte style and unhighlight it.
 * PARAMETERS
 *  x1          [IN]  the left-top corner x1 coordinate      
 *  y1          [IN]  the left-top corner y1 coordinate      
 *  iwidth      [IN]  width      
 *  iheight     [IN]  height      
 *  item        [IN]  inline item      
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_show_fte_select_item_unhighlight(S32 x1, S32 y1, S32 iwidth, S32 iheight, wgui_inline_item *item)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    /* For unwanted arrow images */
    gui_horizontal_select_item_struct inline_select_display_items = {0};
    gui_horizontal_select_struct inline_select_display = {0};

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    inline_select_display_items.text = (UI_string_type)item->text_p;

    gui_horizontal_select_create(
        &inline_select_display, 
        x1, 
        y1, 
        iwidth, 
        iheight,
	UI_HORIZONTAL_SELECT_LOOP | UI_HORIZONTAL_SELECT_NORMAL_STATE,
        0,
        NULL,
        &inline_select_display_items,
        1);

    inline_select_display.flags |= UI_HORIZONTAL_SELECT_USE_PRESET_CLIP;

    gui_horizontal_select_show(&inline_select_display);
    gdi_layer_blt_previous(
        inline_select_display.x,
        inline_select_display.y,
        inline_select_display.x + inline_select_display.width - 1,
        inline_select_display.y + inline_select_display.height - 1);
}

#endif

/*****************************************************************************
 * FUNCTION
 *  wgui_show_inline_select_arrow
 * DESCRIPTION
 *  show inline select arrow
 * PARAMETERS
 *  x1          [IN]  the left-top corner x1 coordinate      
 *  y1          [IN]  the left-top corner y1 coordinate      
 *  iwidth      [IN]  width      
 *  iheight     [IN]  height      
 *  item        [IN]   inline item      
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_show_inline_select_arrow(S32 x1, S32 y1, S32 iwidth, S32 iheight, wgui_inline_item *item)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    /* For unwanted arrow images */
#ifndef __MMI_FTE_SUPPORT__
    fixed_icontext_menuitem_type *t = (fixed_icontext_menuitem_type*) item;
#endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifndef __MMI_FTE_SUPPORT__
	/* Sometimes, selector maybe located below title bar tightly, so we should left 1 pixel. */
	if(MMI_fixed_list_menu.current_displayed_item == MMI_fixed_list_menu.first_displayed_item)
	{
		y1++;
        iheight--;
	}
#endif

#ifdef  __MMI_FTE_SUPPORT__
    {
        wgui_show_fte_select_item_unhighlight(x1, y1, iwidth, iheight, item);
        return;
    }
#endif
//for non FTE, wgui_show_inline_select_arrow will not be used
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #ifdef __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #endif /* __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__ */ 
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
}


/*****************************************************************************
 * FUNCTION
 *  initialize_inline_select_menu_items
 * DESCRIPTION
 *  initialize inline select menu items
 * PARAMETERS
 *  x                       [IN]  the left-top corner x coordinate      
 *  y                       [IN]  the left-top corner y coordinate      
 *  width                   [IN]  width      
 *  height                  [IN]  height        
 *  n_items                 [IN]  item number      
 *  list_of_items           [IN]  list of items      
 *  highlighted_item        [OUT] highlighted item      
 *  f                       [IN]  item highlighted callback      
 * RETURNS
 *  void
 *****************************************************************************/
void initialize_inline_select_menu_items(
        S32 x,
        S32 y,
        S32 width,
        S32 height,
        S32 n_items,
        U8 **list_of_items,
        S32 *highlighted_item,
        void (*f) (S32 item_index))
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_setup_inline_edit_themes();
    for (i = 0; i < n_items; i++)
    {
        wgui_inline_select_items[i].text = (UI_string_type) list_of_items[i];
    }
#ifdef __MMI_INLINE_HIGHLIGHT_CAPTION__
    gui_horizontal_select_create(
         &g_wgui_inline_select_item, 
         x, 
         y, 
         width, 
         height,
     UI_HORIZONTAL_SELECT_LOOP | UI_HORIZONTAL_SELECT_FOCUSED_STATE | UI_HORIZONTAL_SELECT_NOT_CLEAR_BACKGROUND,  
         *highlighted_item,
	     f,
         wgui_inline_select_items,
         n_items);
#else
    gui_horizontal_select_create(
        &g_wgui_inline_select_item, 
        x, 
        y, 
        width, 
        height,
	UI_HORIZONTAL_SELECT_LOOP | UI_HORIZONTAL_SELECT_FOCUSED_STATE  ,// UI_HORIZONTAL_SELECT_REGISTER_KEY_HANDLER
        *highlighted_item,
        f,
        wgui_inline_select_items,
        n_items);
#endif
}


/*****************************************************************************
 * FUNCTION
 *  show_inline_select_menu_ext
 * DESCRIPTION
 *  show inline select menu
 * PARAMETERS
 *  IsShow		[IN]		whether show horizontal select 
 * RETURNS
 *  void
 *****************************************************************************/
static void show_inline_select_menu_ext(MMI_BOOL IsShow)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#ifndef __MMI_FTE_SUPPORT__
    S32 x = 0, width = 0, height = 0, img_y1 = 0;
    PU8 image;
#endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
#ifdef __MMI_UI_TRANSPARENT_EFFECT__
    /* 
     * disable transparency effect
     *
     * See gui_set_fixed_text_menuitem_current_theme() for details.
     */
    fixed_icontext_menuitem_transparent_filled_area.flags &= ~UI_FILLED_AREA_TYPE_TRANSPARENT_COLOR;
#endif /* __MMI_UI_TRANSPARENT_EFFECT__ */

    if (IsShow)
    {
        gui_horizontal_select_set_current_theme(&g_wgui_inline_select_item);
        gui_horizontal_select_show(&g_wgui_inline_select_item);
    }
#ifndef __MMI_FTE_SUPPORT__    
    if (wgui_inline_items[wgui_inline_item_highlighted_index].show_img_flag == TRUE)
    {
        image = wgui_inline_items[wgui_inline_item_highlighted_index].side_img;
        if (image)
        {
            gui_measure_image(image, &width, &height);
            img_y1 = (MMI_INLINE_EDIT_MENUITEM_HEIGHT >> 1) - (height >> 1);
            if (mmi_fe_get_r2l_state())
            {
                /*
                When select item is set to UI_MENUITEM_INLINE_EDIT_OBJECT, we need to draw icon by ourselves either in highlight
                unhighlight case.
                In unhighlight case, we call draw_image_text_control() to draw icon.
                To compatible with unhighlight case, we set x coordinate of icon to UI_device_width - 1 - width "-1". 
                */
                gui_show_transparent_image(
                    UI_device_width - 1 - width - 1,
                    (g_wgui_inline_select_item.y + img_y1),
                    image,
                    0);
            }
            else
            {
                if((MMI_fixed_icontext_menuitems[wgui_inline_item_highlighted_index].flags 
                    && UI_MENUITEM_INLINE_EDIT_OBJECT) != 0)
                {
                    gui_show_transparent_image(g_select_unhighlight_x_corrdinate, (g_wgui_inline_select_item.y + img_y1), image, 0);
                }
                /*
                When select item is set to UI_MENUITEM_INLINE_EDIT_OBJECT, we need to draw icon by ourselves either in highlight
                unhighlight case.
                In unhighlight case, we call draw_image_text_control() to draw icon.
                To compatible with unhighlight case, we set x coordinate of icon to 4. 
                */
                else
                {
                gui_show_transparent_image(4, (g_wgui_inline_select_item.y + img_y1), image, 0);
            }
            }
            x = 2;
        }

    }
    else
    {
        x = g_wgui_inline_select_item.x;
    }
#endif
    gdi_layer_blt_previous(
        g_wgui_inline_select_item.x,
        g_wgui_inline_select_item.y,
        g_wgui_inline_select_item.x + g_wgui_inline_select_item.width - 1,
        g_wgui_inline_select_item.y + g_wgui_inline_select_item.height - 1);

#ifdef __IV_TTS__
	if(NPR_TTS_get_menu_read_enble()){
	gui_horizontal_select_struct *m = &g_wgui_inline_select_item;
	NPR_TTS_menu_read( m->items[m->highlighted_item].text );
	}
#endif
}


/*****************************************************************************
 * FUNCTION
 *  inline_select_menu_previous_item
 * DESCRIPTION
 *  go to previous item for inline select menu
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void inline_select_menu_previous_item(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    show_inline_select_menu_ext(MMI_TRUE);
    if (((wgui_inline_item_select*)current_wgui_inline_item->item)->n_items > 1)
    {
        set_wgui_inline_list_menu_changed();
    }
}


/*****************************************************************************
 * FUNCTION
 *  inline_select_menu_next_item
 * DESCRIPTION
 *  go to next item for inline select menu
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void inline_select_menu_next_item(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    show_inline_select_menu_ext(MMI_TRUE);
    if (((wgui_inline_item_select*)current_wgui_inline_item->item)->n_items > 1)
    {
        set_wgui_inline_list_menu_changed();
    }
}


/*****************************************************************************
 * FUNCTION
 *  inline_select_left_arrow_up_handler
 * DESCRIPTION
 *  select left arrow up handler.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void inline_select_left_arrow_up_handler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL change_flag;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    change_flag = gui_horizontal_select_left_key_up_handler(&g_wgui_inline_select_item);
	show_inline_select_menu_ext(MMI_FALSE);
    if(change_flag == MMI_TRUE)
    {
        if (((wgui_inline_item_select*)current_wgui_inline_item->item)->n_items > 1)
        {
            set_wgui_inline_list_menu_changed();
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  inline_select_left_arrow_up_handler
 * DESCRIPTION
 *  select left arrow up handler.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void inline_select_left_arrow_down_handler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL change_flag;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    change_flag = gui_horizontal_select_left_key_down_handler(&g_wgui_inline_select_item);
	show_inline_select_menu_ext(MMI_FALSE);
    if(change_flag == MMI_TRUE)
    {
        if (((wgui_inline_item_select*)current_wgui_inline_item->item)->n_items > 1)
        {
            set_wgui_inline_list_menu_changed();
        }
    }
}

/*****************************************************************************
 * FUNCTION
 *  inline_select_right_arrow_up_handler
 * DESCRIPTION
 *  select left arrow up handler.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void inline_select_right_arrow_down_handler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL change_flag;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    change_flag = gui_horizontal_select_right_key_down_handler(&g_wgui_inline_select_item);
	show_inline_select_menu_ext(MMI_FALSE);
    if(change_flag == MMI_TRUE)
    {
        if (((wgui_inline_item_select*)current_wgui_inline_item->item)->n_items > 1)
        {
            set_wgui_inline_list_menu_changed();
        }
    }
}

/*****************************************************************************
 * FUNCTION
 *  inline_select_right_arrow_up_handler
 * DESCRIPTION
 *  select left arrow up handler.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
 void inline_select_right_arrow_up_handler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL change_flag;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    change_flag = gui_horizontal_select_right_key_up_handler(&g_wgui_inline_select_item);
	show_inline_select_menu_ext(MMI_FALSE);
    if(change_flag == MMI_TRUE)
    {
        if (((wgui_inline_item_select*)current_wgui_inline_item->item)->n_items > 1)
        {
            set_wgui_inline_list_menu_changed();
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  initialize_inline_user_defined_select_menu_items
 * DESCRIPTION
 *  initialize inline user defined select menu items
 * PARAMETERS
 *  x           [IN]    left-top x coordinate       
 *  y           [IN]    left-top y coordinate    
 *  width       [IN]    width    
 *  height      [IN]    height    
 *  text        [IN]    item text         
 * RETURNS
 *  void
 *****************************************************************************/
void initialize_inline_user_defined_select_menu_items(S32 x, S32 y, S32 width, S32 height, U8 *text)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_inline_select_items[0].text = (UI_string_type)text;
    gui_horizontal_select_create(
        &g_wgui_inline_select_item, 
        x, 
        y, 
        width, 
        height,
		UI_HORIZONTAL_SELECT_LOOP | UI_HORIZONTAL_SELECT_FOCUSED_STATE,
        0,
        NULL,
        wgui_inline_select_items,
        1);
}


/*****************************************************************************
 * FUNCTION
 *  show_inline_user_defined_select_menu
 * DESCRIPTION
 *  show inline user defined select menu
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void show_inline_user_defined_select_menu(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_horizontal_select_set_current_theme(&g_wgui_inline_select_item);

#ifdef __MMI_UI_TRANSPARENT_EFFECT__
    /* 
     * disable transparency effect
     *
     * See gui_set_fixed_text_menuitem_current_theme() for details.
     */
    fixed_icontext_menuitem_transparent_filled_area.flags &= ~UI_FILLED_AREA_TYPE_TRANSPARENT_COLOR;
#endif /* __MMI_UI_TRANSPARENT_EFFECT__ */

    gui_horizontal_select_show(&g_wgui_inline_select_item);
    gdi_layer_blt_previous(
        g_wgui_inline_select_item.x,
        g_wgui_inline_select_item.y,
        g_wgui_inline_select_item.x + g_wgui_inline_select_item.width - 1,
        g_wgui_inline_select_item.y + g_wgui_inline_select_item.height - 1);
}


/*****************************************************************************
 * FUNCTION
 *  clear_inline_select_menu_keys
 * DESCRIPTION
 *  clear inline select menu key handlers
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void clear_inline_select_menu_keys(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    /* key rule. 09.10.17 */
    ClearKeyHandler(KEY_LEFT_ARROW, KEY_EVENT_REPEAT);
    ClearKeyHandler(KEY_RIGHT_ARROW, KEY_EVENT_REPEAT);
    
    ClearKeyHandler(KEY_LEFT_ARROW, KEY_EVENT_DOWN);
    ClearKeyHandler(KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
    ClearKeyHandler(KEY_LEFT_ARROW, KEY_EVENT_UP);
    ClearKeyHandler(KEY_RIGHT_ARROW, KEY_EVENT_UP);
    
    clear_keyboard_key_handler();
    clear_inline_item_keys = UI_dummy_function;
    UI_text_menuitem_scroll_time = UI_TEXT_MENUITEM_SCROLL_TIME;
}


/*****************************************************************************
 * FUNCTION
 *  inline_select_menu_change_complete
 * DESCRIPTION
 *  change complete function for inline select menu
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void inline_select_menu_change_complete(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_text_menuitem_reset_scrolling();
    wgui_text_menuitem_reset_scrolling = gui_fixed_icontext_menuitem_stop_scroll;
    wgui_text_menuitem_restart_scrolling = gui_fixed_icontext_menuitem_start_scroll;
    clear_inline_select_menu_keys();
    *(current_wgui_inline_select_item->highlighted_item) = g_wgui_inline_select_item.highlighted_item;
    *current_wgui_inline_select_text_p =
        current_wgui_inline_select_item->list_of_strings[*(current_wgui_inline_select_item->highlighted_item)];
    MMI_fixed_icontext_menuitems[wgui_inline_item_highlighted_index].item_text =
        (UI_string_type) current_wgui_inline_select_item->
        list_of_strings[*(current_wgui_inline_select_item->highlighted_item)];
    *current_wgui_inline_select_highlighted_item = g_wgui_inline_select_item.highlighted_item;
    redraw_current_inline_item = UI_dummy_function;
#ifdef __MMI_TOUCH_SCREEN__
    wgui_current_inline_item_pen_function = UI_dummy_inline_item_pen_function;
#endif 
    current_wgui_inline_select_highlighted_item = NULL;
    wgui_inline_item_handled = 0;
    complete_inline_item_edit = UI_dummy_function;
    current_wgui_inline_select_item = NULL;

    gui_horizontal_select_close(&g_wgui_inline_select_item);

}


/*****************************************************************************
 * FUNCTION
 *  inline_select_menu_handle_up_arrow
 * DESCRIPTION
 *  up arrow key handler of inline select menu
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void inline_select_menu_handle_up_arrow(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (wgui_inline_edit_is_able_to_switch_highlight(0))
    {
        inline_select_menu_change_complete();
        inline_fixed_list_goto_previous_item();
    }
}


/*****************************************************************************
 * FUNCTION
 *  inline_select_menu_handle_down_arrow
 * DESCRIPTION
 *  down arrow handler for inline select menu
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void inline_select_menu_handle_down_arrow(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (wgui_inline_edit_is_able_to_switch_highlight(1))
    {
        inline_select_menu_change_complete();
        inline_fixed_list_goto_next_item();
    }
}


/*****************************************************************************
 * FUNCTION
 *  inline_select_menu_keyboard_key_handler
 * DESCRIPTION
 *  keyboard key handler of inline select menu
 * PARAMETERS
 *  vkey_code       [IN]        key code
 *  key_state       [IN]        key state
 * RETURNS
 *  void
 *****************************************************************************/
void inline_select_menu_keyboard_key_handler(S32 vkey_code, S32 key_state)
{
#if(MMI_BUILD_TYPE == BUILD_TYPE_X86WIN32)
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (key_state)
    {
        switch (vkey_code)
        {
            case 37:
                inline_select_menu_previous_item();
                break;
            case 38:
                inline_select_menu_handle_up_arrow();
                break;
            case 39:
                inline_select_menu_next_item();
                break;
            case 40:
                inline_select_menu_handle_down_arrow();
                break;
        }
    }
#else /* (MMI_BUILD_TYPE == BUILD_TYPE_X86WIN32) */ 
    UI_UNUSED_PARAMETER(vkey_code);
    UI_UNUSED_PARAMETER(key_state);
#endif /* (MMI_BUILD_TYPE == BUILD_TYPE_X86WIN32) */ 
}


/*****************************************************************************
 * FUNCTION
 *  register_inline_select_menu_keys
 * DESCRIPTION
 *  register key handlers for inline select menu
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void register_inline_select_menu_keys(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

     /* key rule. 09.10.17 */
    SetKeyHandler(inline_select_left_arrow_down_handler, KEY_LEFT_ARROW, KEY_EVENT_REPEAT);
    SetKeyHandler(inline_select_right_arrow_down_handler, KEY_RIGHT_ARROW, KEY_EVENT_REPEAT);
    SetKeyHandler(inline_select_menu_handle_up_arrow, KEY_UP_ARROW, KEY_EVENT_REPEAT);
    SetKeyHandler(inline_select_menu_handle_down_arrow, KEY_DOWN_ARROW, KEY_EVENT_REPEAT);
    SetKeyHandler(inline_select_menu_handle_up_arrow, KEY_VOL_UP, KEY_EVENT_REPEAT);
    SetKeyHandler(inline_select_menu_handle_down_arrow, KEY_VOL_DOWN, KEY_EVENT_REPEAT);
    
    SetKeyHandler(inline_select_left_arrow_down_handler, KEY_LEFT_ARROW, KEY_EVENT_DOWN);
    SetKeyHandler(inline_select_right_arrow_down_handler, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
    SetKeyHandler(inline_select_menu_handle_up_arrow, KEY_UP_ARROW, KEY_EVENT_DOWN);
    SetKeyHandler(inline_select_menu_handle_down_arrow, KEY_DOWN_ARROW, KEY_EVENT_DOWN);
    SetKeyHandler(inline_select_menu_handle_up_arrow, KEY_VOL_UP, KEY_EVENT_DOWN);
    SetKeyHandler(inline_select_menu_handle_down_arrow, KEY_VOL_DOWN, KEY_EVENT_DOWN);

    SetKeyHandler(inline_select_left_arrow_up_handler, KEY_LEFT_ARROW, KEY_EVENT_UP);
    SetKeyHandler(inline_select_right_arrow_up_handler, KEY_RIGHT_ARROW, KEY_EVENT_UP);
    
    register_keyboard_key_handler(inline_select_menu_keyboard_key_handler);
}


/*****************************************************************************
 * FUNCTION
 *  redraw_inline_select
 * DESCRIPTION
 *  redraw inline select menu
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void redraw_inline_select(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    show_inline_select_menu_ext(MMI_TRUE);
}

#ifdef __MMI_TOUCH_SCREEN__


/*****************************************************************************
 * FUNCTION
 *  inline_select_pen_handler
 * DESCRIPTION
 *  pen handler for inline select
 * PARAMETERS
 *  pen_event       [IN]     pen event   
 *  x               [IN]     pen x position   
 *  y               [IN]     pen y position   
 *  item_event      [OUT]      inline pen enum   
 * RETURNS
 *  BOOL
 *****************************************************************************/
BOOL inline_select_pen_handler(mmi_pen_event_type_enum pen_event, S16 x, S16 y, gui_inline_item_pen_enum *item_event)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    BOOL ret;
    gui_horizontal_select_pen_enum select_event;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	gui_push_clip();
	gui_set_clip_preset(MMI_fixed_list_menu.x, MMI_fixed_list_menu.y, MMI_fixed_list_menu.x + MMI_fixed_list_menu.width - 1, MMI_fixed_list_menu.y + MMI_fixed_list_menu.height - 1);
	ret = gui_horizontal_select_translate_pen_event(&g_wgui_inline_select_item, pen_event, x, y, &select_event);
	gui_pop_clip();

    if (ret)
    {
        switch (select_event)
        {
            case GUI_HORIZONTAL_SELECT_PEN_NONE:
                /* Do nothing */
                break;
            case GUI_HORIZONTAL_SELECT_PEN_PREV:
            {
                inline_select_menu_previous_item();
                break;
            }
            case GUI_HORIZONTAL_SELECT_PEN_NEXT:
            {
                inline_select_menu_next_item();
                break;
            }     
	    case GUI_HORIZONTAL_SELECT_PEN_CENTER_AREA:
            {
	        break;
            }
            default:
            MMI_ASSERT(0);
        }
    }

    *item_event = GUI_INLINE_ITEM_PEN_NONE;
    return ret;
}

#endif /* __MMI_TOUCH_SCREEN__ */ 


/*****************************************************************************
 * FUNCTION
 *  current_inline_select_highlight_handler
 * DESCRIPTION
 *  highlight handler for current inline select
 * PARAMETERS
 *  index       [IN]        hightlight index
 * RETURNS
 *  void
 *****************************************************************************/
void current_inline_select_highlight_handler(S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(cui_inline_is_current_cui())
    {
        cui_inline_selector_update_old_index(*current_wgui_inline_select_highlighted_item);
    }
    *current_wgui_inline_select_highlighted_item = index;
    current_wgui_inline_select_item->item_highlighted(index);
}


/*****************************************************************************
 * FUNCTION
 *  handle_inline_select
 * DESCRIPTION
 *  activation function of inline select
 * PARAMETERS
 *  x                   [IN]        left corner's x coordinate
 *  y                   [IN]        left corner's y coordinate
 *  width               [IN]        width
 *  height              [IN]        height
 *  key_code            [IN]        key code
 *  key_event           [IN]        key event
 *  text_p              [IN]        text pointer
 *  item                [IN]         inline item
 *  flags               [IN]        flags
 *  history_buffer      [IN]         history buffer          
 * RETURNS
 *  void
 *****************************************************************************/
void handle_inline_select(
        S32 x,
        S32 y,
        S32 width,
        S32 height,
        S32 key_code,
        S32 key_event,
        U8 **text_p,
        void *item,
        U32 flags,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_inline_item_select *i = (wgui_inline_item_select*) item;
    S32 xx;
#ifndef __MMI_FTE_SUPPORT__    
    S32 img_width = 0, img_height = 0, left_width;
#endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(key_event);
    UI_UNUSED_PARAMETER(key_code);
    UI_UNUSED_PARAMETER(flags);


    if(current_wgui_inline_select_item != NULL)
    {
         gui_horizontal_select_close(&g_wgui_inline_select_item); 
    }

#ifndef __MMI_FTE_SUPPORT__
	/* Sometimes, selector maybe located below title bar tightly, so we should left 1 pixel. */
	if(wgui_inline_item_highlighted_index == MMI_fixed_list_menu.first_displayed_item)
	{
		y++;
		height--;
	}
#endif
    UI_text_menuitem_scroll_time = 300;
    redraw_current_inline_item = UI_dummy_function;
    
    if (!mmi_fe_get_r2l_state())
    {
        if (MMI_fixed_icontext_menuitem.text_x == 2)
        {
            xx = 0;
        }
        else
        {
            xx = MMI_fixed_icontext_menuitem.text_x;
        }
    }
    else
    {
        xx = 1;
    }

    if (flags & INLINE_ITEM_LEFT_ALIGN)
    {
        xx = -1;
    }
    clear_inline_item_keys = clear_inline_select_menu_keys;
    current_wgui_inline_select_item = i;
    current_wgui_inline_select_text_p = text_p;
#ifdef __MMI_FTE_SUPPORT__

    initialize_inline_select_menu_items(
            x,
            y,
            width,
            height,
            i->n_items,
            i->list_of_strings,
            i->highlighted_item,
            current_inline_select_highlight_handler);

#else

    if (!mmi_fe_get_r2l_state())
    {
        initialize_inline_select_menu_items(
            x + xx,
            y,
            width - xx,
            height,
            i->n_items,
            i->list_of_strings,
            i->highlighted_item,
            current_inline_select_highlight_handler);
    }
    else
    {

        if (wgui_inline_items[wgui_inline_item_highlighted_index].show_img_flag == TRUE)
        {
            gui_measure_image(wgui_inline_items[wgui_inline_item_highlighted_index].side_img, &img_width, &img_height);
            left_width = img_width + 1;
        }
        else
            left_width = MMI_fixed_icontext_menuitem.text_x + 1;
        
        if (flags & INLINE_ITEM_LEFT_ALIGN)
        {
            initialize_inline_select_menu_items(
                x + xx,
                y,
                width - 1 - xx,
                height,
                i->n_items,
                i->list_of_strings,
                i->highlighted_item,
                current_inline_select_highlight_handler);
        }
        else
        {
            initialize_inline_select_menu_items(
                x + xx,
                y,
                width - left_width,
                height,
                i->n_items,
                i->list_of_strings,
                i->highlighted_item,
                current_inline_select_highlight_handler);
        }
    }

    if((flags & INLINE_ITEM_SELECTOR_NO_LOOP))
    {
        U32 selector_flag = gui_horizontal_select_get_flag(&g_wgui_inline_select_item);
        selector_flag &= ~UI_HORIZONTAL_SELECT_LOOP;
        gui_horizontal_select_set_flag(&g_wgui_inline_select_item, selector_flag);
    }

    /* Because x coodinate = x + 1 in unhighlight show . */
    g_select_unhighlight_x_corrdinate = x + 1;    
#endif
    UI_UNUSED_PARAMETER(xx);
	g_wgui_inline_select_item.flags |= UI_HORIZONTAL_SELECT_USE_PRESET_CLIP;
    register_inline_select_menu_keys();

/* current_wgui_inline_select_highlighted_item is not null means this function is reentry, Ex: enter
dummy screen and goback history, because current_wgui_inline_select_highlighted_item is not clear. */
    if (current_wgui_inline_select_highlighted_item == NULL)
    {
        current_wgui_inline_select_highlighted_item = i->highlighted_item;
        current_inline_select_highlight_handler(*i->highlighted_item);
    }
    else
    {
        current_wgui_inline_select_highlighted_item = i->highlighted_item;
    }
    show_inline_select_menu_ext(MMI_TRUE);
    complete_inline_item_edit = inline_select_menu_change_complete;
    redraw_current_inline_item = redraw_inline_select;
#ifdef __MMI_TOUCH_SCREEN__
    wgui_current_inline_item_pen_function = inline_select_pen_handler;
#endif 
}


/*****************************************************************************
 * FUNCTION
 *  SetInlineItemSelect
 * DESCRIPTION
 *  set data for inine select
 * PARAMETERS
 *  item                    [IN]    inline item         
 *  n_items                 [IN]    item number    
 *  list_of_items           [IN]    list of items    
 *  highlighted_item        [IN]    highlighted item index     
 * RETURNS
 *  void
 *****************************************************************************/
void SetInlineItemSelect(InlineItem *item, S32 n_items, U8 **list_of_items, S32 *highlighted_item)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_inline_item_select *i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (n_inline_select_items >= MAX_INLINE_SELECT_ITEMS)
    {
        return;
    }
    wgui_inline_mem_alloc_info[wgui_inline_mem_alloc_number] = item->item = wgui_inline_malloc(sizeof(wgui_inline_item_select));
    wgui_inline_mem_alloc_number++; 
    item->flags = INLINE_ITEM_TYPE_SELECT;
    n_inline_select_items++;
    i = (wgui_inline_item_select*) item->item;
    i->flags = 0;
    i->list_of_strings = list_of_items;
    i->n_items = n_items;
    i->item_highlighted = UI_dummy_function_s32;
    if (highlighted_item == NULL)
    {
        i->highlighted_item = NULL;
        item->text_p = list_of_items[0];
    }
    else
    {
        if (*highlighted_item < 0 || *highlighted_item >= n_items)
        {
            MMI_DBG_ASSERT(0);
            *highlighted_item = 0;
        }
        i->highlighted_item = highlighted_item;
        item->text_p = list_of_items[*highlighted_item];
    }
    item->handler = handle_inline_select;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_inline_set_item_selector_by_string_id
 * DESCRIPTION
 *  set data for inine select by string id
 * PARAMETERS
 *  item                    [IN]    inline item         
 *  n_items                 [IN]    item number    
 *  list_of_string_id       [IN]    list of string id    
 *  highlighted_item        [IN]    highlighted item index     
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_inline_set_item_selector_by_string_id(InlineItem *item, S32 n_items, U16 *list_of_string_id, S32 *highlighted_item)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i;
    PU8 *string_id_list = NULL;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (n_inline_select_items >= MAX_INLINE_SELECT_ITEMS)
    {
        return;
    }
    wgui_inline_mem_alloc_info[wgui_inline_mem_alloc_number] = string_id_list = (PU8 *)wgui_inline_malloc(sizeof(U8 *) * n_items );
    wgui_inline_mem_alloc_number++; 

    if(list_of_string_id != NULL)
    {
        for (i = 0; i < n_items; i++)
        {
            string_id_list[i] = (PU8) GetString(list_of_string_id[i]);
        }
    }
    SetInlineItemSelect(item, n_items, string_id_list, highlighted_item);
}

     
/*****************************************************************************
 * FUNCTION
 *  ReConfigureInlineItemSelect
 * DESCRIPTION
 *  re-configure of inline select
 * PARAMETERS
 *  item                    [IN]    inline item         
 *  n_items                 [IN]    item number    
 *  list_of_items           [IN]    list of items    
 *  highlighted_item        [IN]    highlighted item index          
 * RETURNS
 *  void
 *****************************************************************************/
void ReConfigureInlineItemSelect(InlineItem *item, S32 n_items, U8 **list_of_items, S32 *highlighted_item)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_inline_item_select *i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if ((item->flags & 0xff) != INLINE_ITEM_TYPE_SELECT)
    {
        return;
    }
    i = (wgui_inline_item_select*) item->item;
    i->flags = 0;
    i->list_of_strings = list_of_items;
    i->n_items = n_items;
    i->item_highlighted = UI_dummy_function_s32;
    if (highlighted_item == NULL)
    {
        i->highlighted_item = NULL;
        item->text_p = list_of_items[0];
    }
    else
    {
        if (*highlighted_item < 0 || *highlighted_item >= n_items)
        {
            MMI_DBG_ASSERT(0);
            *highlighted_item = 0;
        }
        i->highlighted_item = highlighted_item;
        item->text_p = list_of_items[*highlighted_item];
    }
}


/*****************************************************************************
 * FUNCTION
 *  RegisterInlineSelectHighlightHandler
 * DESCRIPTION
 *  register inline select highlight handler
 * PARAMETERS
 *  item        [IN]    inline item         
 *  f           [IN]    highlight handler    
 * RETURNS
 *  void
 *****************************************************************************/
void RegisterInlineSelectHighlightHandler(InlineItem *item, void (*f) (S32 item_index))
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_inline_item_select *i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    i = (wgui_inline_item_select*) item->item;
    if (f != NULL)
    {
        i->item_highlighted = f;
    }
}

#ifdef __MMI_INLINE_ITEM_RADIO__
/***************************************************************************** 
 * Inline Radio Item   
 *
 * This is Inline Date Radio Item
 *****************************************************************************/
static S32 n_inline_radio_items = 0;
#define MAX_INLINE_RADIO_ITEMS	12

typedef struct
{
    S32 x, y, width, height;
    U16 sel_icon, unsel_icon;
    MMI_BOOL *IsSelected;
    MMI_BOOL IsFocused;
    UI_filled_area *bg_area;
    PU8 *text_p;
    color text_color;
    stFontAttribute *text_font;
} wgui_twostatus_item;

static scrolling_text twostatus_item_scrolling_text;

static wgui_twostatus_item wgui_inline_twostatus_item;
static wgui_twostatus_item *wgui_inline_twostatus_item_p = &wgui_inline_twostatus_item;


/*****************************************************************************
 * FUNCTION
 *  wgui_cate_twostatus_scrolling_text_handler
 * DESCRIPTION
 *  cate twostatus menuitem scroll text handler
 * PARAMETERS
 *  void                    
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cate_twostatus_scrolling_text_handler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_handle_scrolling_text(&twostatus_item_scrolling_text);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cate_twostatus_show_background
 * DESCRIPTION
 *  cate twostatus menuitem scroll text background
 * PARAMETERS
 *  x1		[IN]
 *  y1		[IN]
 *  x2		[IN]
 *  y2		[IN]
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cate_twostatus_show_background(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (wgui_is_wallpaper_on_bottom() == MMI_TRUE)
    {
        gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_TRANSPARENT);
    }
    if (wgui_inline_twostatus_item_p->bg_area)
    {
        gui_draw_filled_area(x1, y1, x2, y2, wgui_inline_twostatus_item_p->bg_area);
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cate_show_twostatus_menuitem
 * DESCRIPTION
 *  cate twostatus menuitem show handler
 * PARAMETERS
 *  item		[IN]		twostatus menuitem struct
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cate_show_twostatus_menuitem(wgui_twostatus_item *item)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 w, h, x1, y1, x2, y2;
    PU8 icon_p, text_p;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();
    
    //draw background
    if (wgui_is_wallpaper_on_bottom() == MMI_TRUE)
    {
        gdi_draw_solid_rect(
            item->x, 
            item->y, 
            item->x + item->width - 1, 
            item->y + item->height - 1, 
            GDI_COLOR_TRANSPARENT);
    }
    if (item->bg_area)
    {
        gui_draw_filled_area(
            item->x, 
            item->y, 
            item->x + item->width - 1, 
            item->y + item->height - 1, 
            item->bg_area);
    }
    
    //draw icon
    if (*item->IsSelected)
    {
        icon_p = get_image(item->sel_icon);
    }
    else
    {
        icon_p = get_image(item->unsel_icon);
    }
    gui_measure_image(icon_p, &w, &h);
    x1 = item->x + GUI_ICONTEXT_MENUITEM_ICON_X;
    x2 = x1 + w;
    y1 = item->y + (item->height - h)/2;
    y2 = y1 + h;
    gui_push_clip();
    gui_set_clip_preset(x1, y1, x2, y2);
    gdi_image_draw(x1, y1, icon_p);
    gui_pop_clip();
    
    //draw text
    text_p = (PU8)(*(item->text_p));
    if (text_p)
    {
        gui_measure_string((UI_string_type)text_p, &w, &h);
        x1 = item->x + GUI_ICONTEXT_MENUITEM_TEXT_X;
        x2 = item->x + item->width;
        y1 = item->y + (item->height - h)/2;
        y2 = y1 + h;
        gui_push_clip();
        gui_set_clip_preset(x1, y1, x2, y2);
        gui_set_font(item->text_font);
        if ((w > (x2 - x1)) && (item->IsFocused))
        {
            gui_create_scrolling_text(
                &twostatus_item_scrolling_text,
                x1,
                y1,
                x2 - x1,
                h,
                (UI_string_type)text_p,
                wgui_cate_twostatus_scrolling_text_handler,
                wgui_cate_twostatus_show_background,
                item->text_color,
                item->text_color);
            gui_show_scrolling_text(&twostatus_item_scrolling_text);
        }
        else
        {
            gui_set_text_color(item->text_color);
            gui_move_text_cursor(x1, y1);
            gui_print_truncated_text(x1, y1, x2 - x1 + 1, (UI_string_type)text_p);
        }
        gui_pop_clip();
    }
    
    gdi_layer_unlock_frame_buffer();
    gdi_layer_blt_previous(
        item->x,
        item->y,
        item->x + item->width - 1,
        item->y + item->height - 1);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cate_redraw_twostatus_menuitem
 * DESCRIPTION
 *  cate twostatus menuitem redraw handler
 * PARAMETERS
 *  void		
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cate_redraw_twostatus_menuitem(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_scrolling_text_stop(&twostatus_item_scrolling_text);
    wgui_cate_show_twostatus_menuitem(wgui_inline_twostatus_item_p);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cate_create_twostatus_menuitem
 * DESCRIPTION
 *  cate twostatus menuitem create handler
 * PARAMETERS
 *  m			[IN]		twostatus item struct
 *  x				[IN]
 *  y				[IN]
 *  width			[IN]
 *  height		[IN]
 *  sel_icon		[IN]		selected status icon
 *  unsel_icon		[IN]		unselected status icon
 *  IsSelected		[IN]		the flag for select
 *  text_p		[IN]		twostatus menuitem text
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cate_create_twostatus_menuitem(
               wgui_twostatus_item *m, 
               S32 x, 
               S32 y, 
               S32 width,
               S32 height,
               U16 sel_icon, 
               U16 unsel_icon,
               MMI_BOOL *IsSelected,
               PU8 *text_p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    m->x = x;
    m->y = y;
    m->width = width;
    m->height = height;
    m->sel_icon = sel_icon;
    m->unsel_icon = unsel_icon;
    m->IsSelected = IsSelected;
    m->text_p = text_p;
}


/*****************************************************************************
 * FUNCTION
 *  inline_twostatus_change_complete
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void inline_twostatus_change_complete(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_scrolling_text_stop(&twostatus_item_scrolling_text);
    memset((char*)wgui_inline_twostatus_item_p, 0, sizeof(wgui_twostatus_item));
    redraw_current_inline_item = UI_dummy_function;
    complete_inline_item_edit = UI_dummy_function;
}


/*****************************************************************************
 * FUNCTION
 *  inline_twostatus_handle_up_arrow
 * DESCRIPTION
 *  up arrow key handler of inline twostatus
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void inline_twostatus_handle_up_arrow(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (wgui_inline_edit_is_able_to_switch_highlight(0))
    {
        inline_twostatus_change_complete();
        inline_fixed_list_goto_previous_item();
    }
}


/*****************************************************************************
 * FUNCTION
 *  inline_twostatus_handle_down_arrow
 * DESCRIPTION
 *  down arrow handler for inline twostatus
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void inline_twostatus_handle_down_arrow(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (wgui_inline_edit_is_able_to_switch_highlight(1))
    {
        inline_twostatus_change_complete();
        inline_fixed_list_goto_next_item();
    }
}


/*****************************************************************************
 * FUNCTION
 *  inline_twostatus_keyboard_key_handler
 * DESCRIPTION
 *  keyboard key handler of inline twostatus
 * PARAMETERS
 *  vkey_code       [IN]        key code
 *  key_state       [IN]        key state
 * RETURNS
 *  void
 *****************************************************************************/
static void inline_twostatus_keyboard_key_handler(S32 vkey_code, S32 key_state)
{
#if(MMI_BUILD_TYPE == BUILD_TYPE_X86WIN32)
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (key_state)
    {
        switch (vkey_code)
        {
            case 38:
                inline_twostatus_handle_up_arrow();
                break;
            case 40:
                inline_twostatus_handle_down_arrow();
                break;
        }
    }
#else /* (MMI_BUILD_TYPE == BUILD_TYPE_X86WIN32) */ 
    UI_UNUSED_PARAMETER(vkey_code);
    UI_UNUSED_PARAMETER(key_state);
#endif /* (MMI_BUILD_TYPE == BUILD_TYPE_X86WIN32) */ 
}


/*****************************************************************************
 * FUNCTION
 *  register_inline_twostatus_keys
 * DESCRIPTION
 *  register key handlers for inline twostatus
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void register_inline_twostatus_keys(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    SetKeyHandler(inline_twostatus_handle_up_arrow, KEY_UP_ARROW, KEY_EVENT_REPEAT);
    SetKeyHandler(inline_twostatus_handle_down_arrow, KEY_DOWN_ARROW, KEY_EVENT_REPEAT);
    SetKeyHandler(inline_twostatus_handle_up_arrow, KEY_VOL_UP, KEY_EVENT_REPEAT);
    SetKeyHandler(inline_twostatus_handle_down_arrow, KEY_VOL_DOWN, KEY_EVENT_REPEAT);
    
    SetKeyHandler(inline_twostatus_handle_up_arrow, KEY_UP_ARROW, KEY_EVENT_DOWN);
    SetKeyHandler(inline_twostatus_handle_down_arrow, KEY_DOWN_ARROW, KEY_EVENT_DOWN);
    SetKeyHandler(inline_twostatus_handle_up_arrow, KEY_VOL_UP, KEY_EVENT_DOWN);
    SetKeyHandler(inline_twostatus_handle_down_arrow, KEY_VOL_DOWN, KEY_EVENT_DOWN);

    register_keyboard_key_handler(inline_twostatus_keyboard_key_handler);
}


/*****************************************************************************
 * FUNCTION
 *  handle_inline_radio
 * DESCRIPTION
 *  activation function of inline radio
 * PARAMETERS
 *  x                   [IN]        left corner's x coordinate
 *  y                   [IN]        left corner's y coordinate
 *  width               [IN]        width
 *  height              [IN]        height
 *  key_code            [IN]        key code
 *  key_event           [IN]        key event
 *  text_p              [IN]        text pointer
 *  item                [IN]         inline item
 *  flags               [IN]        flags
 *  history_buffer      [IN]         history buffer          
 * RETURNS
 *  void
 *****************************************************************************/
static void handle_inline_radio(
	            S32 x,
	            S32 y,
	            S32 width,
	            S32 height,
	            S32 key_code,
	            S32 key_event,
	            U8 **text_p,
	            void *item,
	            U32 flags,
	            U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_inline_item_radio *i = (wgui_inline_item_radio*)item;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_current_inline_item_type = INLINE_ITEM_TYPE_RADIO;
    wgui_cate_create_twostatus_menuitem(
        wgui_inline_twostatus_item_p,
        x,
        y,
        width,
        height,
        RADIO_ON_IMAGE_ID,
        RADIO_OFF_IMAGE_ID,
        &(i->IsSeld),
        &(i->text_p));
    wgui_inline_twostatus_item_p->bg_area = wgui_inline_fixed_icontext_menuitem_theme.focussed_filler;
    wgui_inline_twostatus_item_p->text_color = wgui_inline_fixed_icontext_menuitem_theme.focussed_text_color;
    wgui_inline_twostatus_item_p->text_font = &MMI_medium_font;
    wgui_inline_twostatus_item_p->IsFocused = MMI_TRUE;
    wgui_cate_show_twostatus_menuitem(wgui_inline_twostatus_item_p);
    
    register_inline_twostatus_keys();
    redraw_current_inline_item = wgui_cate_redraw_twostatus_menuitem;
    complete_inline_item_edit = inline_twostatus_change_complete;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_show_inline_radio_menuitem
 * DESCRIPTION
 *  show inline radio list menuitem
 * PARAMETERS
 *  x1          [IN]  the left-top corner x1 coordinate      
 *  y1          [IN]  the left-top corner y1 coordinate      
 *  width       [IN]  width      
 *  height      [IN]  height      
 *  item        [IN]  inline item         
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_show_inline_radio_menuitem(S32 x1, S32 y1, S32 iwidth, S32 iheight, wgui_inline_item *item)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_twostatus_item radio_item;
    wgui_inline_item_radio *i = (wgui_inline_item_radio*)item->item;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_cate_create_twostatus_menuitem(
        &radio_item,
        x1,
        y1, 
        iwidth,
        iheight,
        RADIO_ON_IMAGE_ID,
        RADIO_OFF_IMAGE_ID,
        &(i->IsSeld),
        &(i->text_p));
    radio_item.bg_area = NULL;
    radio_item.text_color = wgui_inline_fixed_icontext_menuitem_theme.normal_text_color;
    radio_item.text_font = &MMI_medium_font;
    radio_item.IsFocused = MMI_FALSE;
    wgui_cate_show_twostatus_menuitem(&radio_item);
}


/*****************************************************************************
 * FUNCTION
 *  SetInlineItemRadio
 * DESCRIPTION
 *  set data for inine radio
 * PARAMETERS
 *  item                    [IN]    inline item      
 *  first_item			[IN]	  first item index in list menu
 *  n_items                 [IN]    item number    
 *  IsSeld		           [IN]    the selected item number in radio list   
 *  text_p	        [IN]    current item text     
 * RETURNS
 *  void
 *****************************************************************************/
void SetInlineItemRadio(InlineItem *item, S32 first_item, S32 n_items, S32 IsSeld, PU8 text_p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_inline_item_radio *i;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (n_inline_radio_items >= MAX_INLINE_RADIO_ITEMS)
    {
        return;
    }
    wgui_inline_mem_alloc_info[wgui_inline_mem_alloc_number] = item->item = wgui_inline_malloc(sizeof(wgui_inline_item_radio));
    wgui_inline_mem_alloc_number++; 
    item->flags = INLINE_ITEM_TYPE_RADIO;
    n_inline_radio_items++;
    i = (wgui_inline_item_radio*) item->item;
    i->flags = 0;
    i->first_item = first_item;
    i->n_items = n_items;
    i->IsSeld = (MMI_BOOL)IsSeld;
    i->text_p = text_p;
    i->selected_callback = NULL;
    item->text_p = text_p;
    item->handler = handle_inline_radio;
}


/*****************************************************************************
 * FUNCTION
 *  ReconfigureInlineItemRadio
 * DESCRIPTION
 *  recongigure data for inine radio
 * PARAMETERS
 *  item                    [IN]    inline item      
 *  first_item			[IN]	  first item index in list menu
 *  n_items                 [IN]    item number    
 *  IsSeld		           [IN]    the selected item number in radio list   
 *  text_p	        [IN]    current item text     
 * RETURNS
 *  void
 *****************************************************************************/
void ReconfigureInlineItemRadio(InlineItem *item, S32 first_item, S32 n_items, S32 IsSeld, PU8 text_p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_inline_item_radio *i;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if ((item->flags & 0xff) != INLINE_ITEM_TYPE_RADIO)
    {
        return;
    }
    i = (wgui_inline_item_radio*) item->item;
    i->flags = 0;
    i->first_item = first_item;
    i->n_items = n_items;
    i->IsSeld = (MMI_BOOL)IsSeld;
    i->text_p = text_p;
    i->selected_callback = NULL;
    item->text_p = text_p;
}


/*****************************************************************************
 * FUNCTION
 *  SetInlineRadioSelectFunction
 * DESCRIPTION
 *  for focus change callback function
 * PARAMETERS
 *  item                    [IN]    inline item      
 *  cb				[IN]	  focus change call back function
 * RETURNS
 *  void
 *****************************************************************************/
void SetInlineRadioSelectFunction(InlineItem *item, radio_selected cb)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_inline_item_radio *i = (wgui_inline_item_radio*)item->item;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    i->selected_callback = cb;
}


/*****************************************************************************
 * FUNCTION
 *  inline_radio_change_select
 * DESCRIPTION
 *  change select item for radio list
 * PARAMETERS
 *  item_index                    [IN]    item index in list menu      
 *  selected_item				[IN]	  item index in radio list
 * RETURNS
 *  return 0 or 1
 *****************************************************************************/
static S32 inline_radio_change_select(S32 item_index, S32 selected_item)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_inline_item_radio *curr_item;
    S32 first_index, n_items, i, curr_index;
    S32 ret = 1;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    curr_item = (wgui_inline_item_radio*)wgui_inline_items[item_index].item;
    first_index = curr_item->first_item;
    n_items = curr_item->n_items;
    for (i = 0; i < n_items; i++)
    {
        curr_index = i + first_index;
        if ((wgui_inline_items[curr_index].flags & INLINE_ITEM_TYPE_MASK) != INLINE_ITEM_TYPE_RADIO)
        {
            break;
        }
        curr_item = (wgui_inline_item_radio*)wgui_inline_items[curr_index].item;
        if (i == selected_item)
        {
            if (curr_item->IsSeld == MMI_FALSE)
            {
                curr_item->IsSeld = MMI_TRUE;
                redraw_current_inline_item();
            }
            else
            {
                ret = 0;
                break;
            }
        }
        else if (curr_item->IsSeld)
        {
            curr_item->IsSeld = MMI_FALSE;
            show_fixed_list_specified_item(curr_index);
        }
    }
    
    return ret;
}


/*****************************************************************************
 * FUNCTION
 *  inline_radio_select_handler
 * DESCRIPTION
 *  select handler function
 * PARAMETERS
 *  void                    
 * RETURNS
 *  void
 *****************************************************************************/
static void inline_radio_select_handler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 first_index = 0;
    S32 curr_index = 0;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    curr_index = wgui_inline_item_highlighted_index;
    if (cui_inline_is_current_cui())
    {
        U16 item_id = 0;
        
        item_id = g_cui_inline_current_instance->cui_inline_items[curr_index].common_data.item_id;
        first_index = g_cui_inline_current_instance->cui_inline_items[curr_index].special_data.radio_data.first_item;
        
        cui_inline_set_item_radio_select(g_cui_inline_current_instance->gid, item_id, (curr_index - first_index));
    }
    else
    {
        wgui_inline_item_radio *item;
        item = (wgui_inline_item_radio*)wgui_inline_items[curr_index].item;
        first_index = item->first_item;
        inline_radio_change_select(curr_index, (curr_index - first_index));
    }

    {
        /* selected callback */
        wgui_inline_item_radio *item;
        item = (wgui_inline_item_radio*)wgui_inline_items[curr_index].item;
        if (item->selected_callback)
        {
            item->selected_callback((curr_index - item->first_item));
        }
    }
}

#endif


#ifdef __MMI_INLINE_ITEM_CHECKBOX__
/***************************************************************************** 
 * Inline CheckBox 
 *
 * This is Inline CheckBox Item
 *****************************************************************************/

static S32 n_inline_checkbox_items = 0;
#define MAX_INLINE_CHECKBOX_ITEMS	12


/*****************************************************************************
 * FUNCTION
 *  handle_inline_checkbox
 * DESCRIPTION
 *  activation function of inline checkbox
 * PARAMETERS
 *  x                   [IN]        left corner's x coordinate
 *  y                   [IN]        left corner's y coordinate
 *  width               [IN]        width
 *  height              [IN]        height
 *  key_code            [IN]        key code
 *  key_event           [IN]        key event
 *  text_p              [IN]        text pointer
 *  item                [IN]         inline item
 *  flags               [IN]        flags
 *  history_buffer      [IN]         history buffer          
 * RETURNS
 *  void
 *****************************************************************************/
static void handle_inline_checkbox(
	            S32 x,
	            S32 y,
	            S32 width,
	            S32 height,
	            S32 key_code,
	            S32 key_event,
	            U8 **text_p,
	            void *item,
	            U32 flags,
	            U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_inline_item_checkbox *i = (wgui_inline_item_checkbox*)item;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_current_inline_item_type = INLINE_ITEM_TYPE_CHECKBOX;
    wgui_cate_create_twostatus_menuitem(
        wgui_inline_twostatus_item_p,
        x,
        y,
        width,
        height,
        CHECKBOX_ON_IMAGE_ID,
        CHECKBOX_OFF_IMAGE_ID,
        &(i->IsSeld),
        &(i->text_p));
    wgui_inline_twostatus_item_p->bg_area = wgui_inline_fixed_icontext_menuitem_theme.focussed_filler;
    wgui_inline_twostatus_item_p->text_color = wgui_inline_fixed_icontext_menuitem_theme.focussed_text_color;
    wgui_inline_twostatus_item_p->text_font = &MMI_medium_font;
    wgui_inline_twostatus_item_p->IsFocused = MMI_TRUE;
    wgui_cate_show_twostatus_menuitem(wgui_inline_twostatus_item_p);

    if (i->IsSeld)
    {
        change_left_softkey(STR_GLOBAL_UNMARK, 0);
    }
    else
    {
        change_left_softkey(STR_GLOBAL_MARK, 0);
    }
    redraw_softkey(MMI_LEFT_SOFTKEY);
    
    register_inline_twostatus_keys();
    redraw_current_inline_item = wgui_cate_redraw_twostatus_menuitem;
    complete_inline_item_edit = inline_twostatus_change_complete;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_show_inline_checkbox_menuitem
 * DESCRIPTION
 *  show inline checkbox menuitem
 * PARAMETERS
 *  x1          [IN]  the left-top corner x1 coordinate      
 *  y1          [IN]  the left-top corner y1 coordinate      
 *  width       [IN]  width      
 *  height      [IN]  height      
 *  item        [IN]  inline item         
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_show_inline_checkbox_menuitem(S32 x1, S32 y1, S32 iwidth, S32 iheight, wgui_inline_item *item)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_twostatus_item checkbox_item;
    wgui_inline_item_checkbox *i = (wgui_inline_item_checkbox*)item->item;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_cate_create_twostatus_menuitem(
        &checkbox_item,
        x1,
        y1,
        iwidth,
        iheight,
        CHECKBOX_ON_IMAGE_ID,
        CHECKBOX_OFF_IMAGE_ID,
        &(i->IsSeld),
        &(i->text_p));
    checkbox_item.bg_area = NULL;
    checkbox_item.text_color = wgui_inline_fixed_icontext_menuitem_theme.normal_text_color;
    checkbox_item.text_font = &MMI_medium_font;
    checkbox_item.IsFocused = MMI_FALSE;
    wgui_cate_show_twostatus_menuitem(&checkbox_item);
}


/*****************************************************************************
 * FUNCTION
 *  SetInlineItemCheckBox
 * DESCRIPTION
 *  set data for inine checkbox
 * PARAMETERS
 *  item                    [IN]    inline item      
 *  text_p	        [IN]    current item text     
 *  IsSeld		           [IN]    the selected flag  
 * RETURNS
 *  void
 *****************************************************************************/
void SetInlineItemCheckBox(InlineItem *item, PU8 text_p, MMI_BOOL IsSeld)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_inline_item_checkbox *i;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (n_inline_checkbox_items >= MAX_INLINE_CHECKBOX_ITEMS)
    {
        return;
    }
    wgui_inline_mem_alloc_info[wgui_inline_mem_alloc_number] = item->item = wgui_inline_malloc(sizeof(wgui_inline_item_checkbox));
    wgui_inline_mem_alloc_number++; 
    item->flags = INLINE_ITEM_TYPE_CHECKBOX;
    n_inline_checkbox_items++;
    i = (wgui_inline_item_checkbox*) item->item;
    i->flags = 0;
    i->IsSeld = IsSeld;
    i->text_p = text_p;
    item->text_p = text_p;
    item->handler = handle_inline_checkbox;
}


/*****************************************************************************
 * FUNCTION
 *  ReconfigureInlineItemCheckBox
 * DESCRIPTION
 *  reconfigure data for inine checkbox
 * PARAMETERS
 *  item                    [IN]    inline item      
 *  text_p	        [IN]    current item text     
 *  IsSeld		           [IN]    the selected flag  
 * RETURNS
 *  void
 *****************************************************************************/
void ReconfigureInlineItemCheckBox(InlineItem *item, PU8 text_p, MMI_BOOL IsSeld)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_inline_item_checkbox *i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if ((item->flags & 0xff) != INLINE_ITEM_TYPE_CHECKBOX)
    {
        return;
    }
    i = (wgui_inline_item_checkbox*) item->item;
    i->flags = 0;
    i->IsSeld = IsSeld;
    i->text_p = text_p;
    item->text_p = text_p;
}


void SetInlineCheckboxChangeFunction(InlineItem *item, checkbox_change cb)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	wgui_inline_item_checkbox *i = (wgui_inline_item_checkbox*)item->item;
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	i->checkbox_change_callback = cb;
}


static void inline_checkbox_lsk_function(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	S32 curr_index = 0;
	MMI_BOOL vResult;
	U16 left_softkey_label;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	curr_index = wgui_inline_item_highlighted_index;
	if (cui_inline_is_current_cui())
	{
		U16 item_id = 0;
		
        item_id = g_cui_inline_current_instance->cui_inline_items[curr_index].common_data.item_id;
		vResult = g_cui_inline_current_instance->cui_inline_items[curr_index].special_data.checkbox_data.IsSeld;
		if (vResult)
		{
		    vResult = MMI_FALSE;
			left_softkey_label = STR_GLOBAL_MARK;
		}
		else
		{
		    vResult = MMI_TRUE;
			left_softkey_label = STR_GLOBAL_UNMARK;
		}
		cui_inline_set_value(g_cui_inline_current_instance->gid, item_id, (void*)vResult);
	}
	else
	{
	    wgui_inline_item_checkbox *item;
		item = (wgui_inline_item_checkbox*)wgui_inline_items[curr_index].item;
		if (item->IsSeld)
		{
		    vResult = MMI_FALSE;
			left_softkey_label = STR_GLOBAL_MARK;
		}
		else
		{
		    vResult = MMI_TRUE;
			left_softkey_label = STR_GLOBAL_UNMARK;
		}
		item->IsSeld = vResult;
	    redraw_current_inline_item();
	}

	change_left_softkey(left_softkey_label, 0);
	redraw_softkey(MMI_LEFT_SOFTKEY);

	{
	    /* checkbox change */
		wgui_inline_item_checkbox *item;
		item = (wgui_inline_item_checkbox*)wgui_inline_items[curr_index].item;
		if (item->checkbox_change_callback)
		{
		    item->checkbox_change_callback(vResult);
		}
	}
}

#endif

#if defined (__MMI_INLINE_ITEM_DATE__)
/***************************************************************************** 
 * Inline Date Edit    
 *
 * This is Inline Date Edit Item
 *****************************************************************************/

/***************************************************************************** 
 * Define
 *****************************************************************************/
#define MAX_INLINE_DATE_ITEMS                   4
#define MAX_INLINE_DATE_DISPLAY_STRING_SIZE     48 // 23 chars with null terminator */


/***************************************************************************** 
 * Typedef 
 *****************************************************************************/
typedef struct _inline_date_edit_history
{
    U16 history_ID;
    S16 current_focus;
    S16 current_position;
    S16 dummy;  /* Added for history issue on hardware */
    U32 flags;
    mmi_imc_history ime_history;
} inline_date_edit_history;


/***************************************************************************** 
 * Local Variable
 *****************************************************************************/
static S32 n_inline_date_items = 0;
static wgui_inline_item_date *current_wgui_inline_date_item;
static PU8 *current_wgui_inline_date_text_p;

date_input wgui_inline_date_input;

/* Displaying date edit as a menu item in the fixed list menu  */
//static date_input wgui_inline_date_input_display;


/***************************************************************************** 
 * Function Implementation
 *****************************************************************************/

/*****************************************************************************
 * FUNCTION
 *  handle_inline_date_edit_complete
 * DESCRIPTION
 *  complete function of inline date edit
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void handle_inline_date_edit_complete(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    register_inline_fixed_list_keys();
    current_wgui_inline_date_item->string_construct_callback(
                                    *current_wgui_inline_date_text_p,
                                    current_wgui_inline_date_item->day_buffer,
                                    current_wgui_inline_date_item->month_buffer,
                                    current_wgui_inline_date_item->year_buffer);
    MMI_fixed_icontext_menuitems[wgui_inline_item_highlighted_index].item_text =
        (UI_string_type) * current_wgui_inline_date_text_p;

    register_left_softkey_handler();
    register_right_softkey_handler();
    wgui_inline_item_handled = 0;
    wgui_text_menuitem_restart_scrolling();
    redraw_current_inline_item = UI_dummy_function;
    complete_inline_item_edit = UI_dummy_function;
    set_current_date_input(NULL);
    clear_date_input_callback();
    mmi_imc_disconnect();
    g_inline_current_input_box_handler = NULL;
}


/*****************************************************************************
 * FUNCTION
 *  redraw_inline_date_edit
 * DESCRIPTION
 *  redraw inline date edit
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void redraw_inline_date_edit(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    date_input_show_background(&wgui_inline_date_input);
    show_date_input(&wgui_inline_date_input);
}


/*****************************************************************************
 * FUNCTION
 *  inline_date_edit_handle_down_arrow
 * DESCRIPTION
 *  down arrow handler of inline date edit
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void inline_date_edit_handle_down_arrow(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(wgui_inline_edit_is_able_to_switch_highlight(1))
    {
#ifdef __MMI_FTE_SUPPORT__    
        wgui_inline_get_vk_status(&g_inline_vk_status);
#endif
        handle_inline_date_edit_complete();
        inline_fixed_list_goto_next_item();
    }
}


/*****************************************************************************
 * FUNCTION
 *  inline_date_edit_handle_up_arrow
 * DESCRIPTION
 *  up arrow handler of inline date edit
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void inline_date_edit_handle_up_arrow(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(wgui_inline_edit_is_able_to_switch_highlight(0))
    {
#ifdef __MMI_FTE_SUPPORT__    
        wgui_inline_get_vk_status(&g_inline_vk_status);
#endif
        handle_inline_date_edit_complete();
        inline_fixed_list_goto_previous_item();
    }
}


/*****************************************************************************
 * FUNCTION
 *  inline_date_input_key_handler
 * DESCRIPTION
 *  key handler of inline date for PC
 * PARAMETERS
 *  vkey_code       [IN]    key code    
 *  key_state       [IN]    key state    
 * RETURNS
 *  void
 *****************************************************************************/
void inline_date_input_key_handler(S32 vkey_code, S32 key_state)
{
#if(MMI_BUILD_TYPE == BUILD_TYPE_X86WIN32)
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (key_state)
    {
        switch (vkey_code)
        {
            case 37:
                date_input_previous_character();
                break;
            case 38:
                inline_date_edit_handle_up_arrow();
                break;
            case 39:
                date_input_next_character();
                break;
            case 40:
                inline_date_edit_handle_down_arrow();
                break;
            case 36:    /* home */
                break;
            case 35:    /* end */
                break;
            case 33:    /* page up */
                break;
            case 34:    /* page down */
                break;
            case 45:
                date_input_toggle_insert_mode();
                break;
            case 46:
                date_input_delete_current_character();
                break;
        }
    }
#else /* (MMI_BUILD_TYPE == BUILD_TYPE_X86WIN32) */ 
    UI_UNUSED_PARAMETER(vkey_code);
    UI_UNUSED_PARAMETER(key_state);
#endif /* (MMI_BUILD_TYPE == BUILD_TYPE_X86WIN32) */ 
}



/*****************************************************************************
 * FUNCTION
 *  inline_date_edit_get_history
 * DESCRIPTION
 *  get history buffer of inline date edit
 * PARAMETERS
 *  history_buffer      [OUT]   history buffer     
 * RETURNS
 *  history buffer
 *****************************************************************************/
U8 *inline_date_edit_get_history(U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (history_buffer != NULL)
    {
        U16 hID = (U16) (INLINE_DATE_HISTORY_ID | 0x8000);
        inline_date_edit_history *h = (inline_date_edit_history*) history_buffer;

        h->history_ID = hID;
        h->current_focus = (S16) wgui_inline_date_input.current_focus;
        if (wgui_inline_date_input.focus_input_box != NULL)
        {
            h->current_position =
                (S16) (wgui_inline_date_input.focus_input_box->current_text_p -
                       wgui_inline_date_input.focus_input_box->text);
        }
        h->flags = wgui_inline_date_input.input.flags;
        mmi_imc_get_input_method_history(&(h->ime_history));
    }
    return (history_buffer);
}


/*****************************************************************************
 * FUNCTION
 *  inline_date_edit_set_history
 * DESCRIPTION
 *  set history buffer into wgui_inline_date_input
 * PARAMETERS
 *  history_ID          [IN]    history id        
 *  history_buffer      [IN]    history buffer         
 * RETURNS
 *  1->success 0->fail
 *****************************************************************************/
U8 inline_date_edit_set_history(U16 history_ID, U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (history_buffer != NULL)
    {
        inline_date_edit_history *h = (inline_date_edit_history*) history_buffer;

        if (history_valid(h->history_ID, history_ID))
        {
            wgui_inline_date_input.current_focus = h->current_focus;
            date_input_reset_focus((void *)&wgui_inline_date_input);
            date_input_set_focus((void *)&wgui_inline_date_input);
            if (wgui_inline_date_input.focus_input_box != NULL)
            {
                wgui_inline_date_input.focus_input_box->current_text_p =
                    wgui_inline_date_input.focus_input_box->text + h->current_position;
            }
            wgui_inline_date_input.input.flags = h->flags;
            return (1);
        }
    }
    return (0);
}


/*****************************************************************************
 * FUNCTION
 *  inline_date_edit_set_seperator
 * DESCRIPTION
 *  set the mask of date input box for inline date edit
 * PARAMETERS
 *  d               [IN]        Date input box
 * RETURNS
 *  void
 *****************************************************************************/
static void inline_date_edit_set_seperator(date_input *d)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 seperator = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (PhnsetGetDateSeperatorFormat())
    {
        case 0:
            seperator = '.';
            break;

        case 1:
            seperator = ':';
            break;

        case 2:
            seperator = '/';
            break;

        case 3:
            seperator = '-';
            break;

        default:
            seperator = '.';
            break;
    }

	date_input_set_seperator(d, (UI_character_type)seperator);
}


/*****************************************************************************
 * FUNCTION
 *  handle_inline_date_edit
 * DESCRIPTION
 *  activation function of inline date edit
 * PARAMETERS
 *  x                   [IN]        left corner's x coordinate
 *  y                   [IN]        left corner's y coordinate
 *  width               [IN]        width
 *  height              [IN]        height
 *  key_code            [IN]        key code
 *  key_event           [IN]        key event
 *  text_p              [IN]        text pointer
 *  item                [IN]        inline item
 *  flags               [IN]        flags
 *  history_buffer      [IN]        history buffer         
 * RETURNS
 *  void
 *****************************************************************************/
void handle_inline_date_edit(
        S32 x,
        S32 y,
        S32 width,
        S32 height,
        S32 key_code,
        S32 key_event,
        U8 **text_p,
        void *item,
        U32 flags,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_inline_item_date *i = (wgui_inline_item_date*) item;
#ifndef __MMI_FTE_SUPPORT__
    S32 xx;
#endif
    U32 dtflags = DATE_INPUT_TYPE_YYYY_MM_DD;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(key_code);
    UI_UNUSED_PARAMETER(key_event);
    UI_UNUSED_PARAMETER(flags);
    wgui_current_inline_item_type = INLINE_ITEM_TYPE_DATE;

#ifndef __MMI_FTE_SUPPORT__
    if (!mmi_fe_get_r2l_state())
    {
        if (MMI_fixed_icontext_menuitem.text_x == 2)
        {
            xx = -1;
        }
        else
        {
            xx = MMI_fixed_icontext_menuitem.text_x;
        }
    }
    else
    {
        xx = 1;
    }

    if (flags & INLINE_ITEM_LEFT_ALIGN)
    {
        xx = -1;
    }
#endif
    switch (flags & INLINE_ITEM_JUSTIFY_MASK)
    {
        case INLINE_ITEM_RIGHT_JUSTIFY:
            dtflags |= DATE_INPUT_RIGHT_JUSTIFY;
            break;
        case INLINE_ITEM_CENTER_JUSTIFY:
            dtflags |= DATE_INPUT_CENTER_JUSTIFY;
            break;
    }
    complete_inline_item_edit = handle_inline_date_edit_complete;
    current_wgui_inline_date_item = i;
    current_wgui_inline_date_text_p = text_p;
    
#ifndef __MMI_FTE_SUPPORT__  
    if (!mmi_fe_get_r2l_state())
    {
        create_date_input(
            &wgui_inline_date_input,
            x + xx,
            y,
            width - xx,
            height,
            dtflags,
            i->day_buffer,
            i->month_buffer,
            i->year_buffer);
    }
    else
    {
        if (flags & INLINE_ITEM_LEFT_ALIGN)
        {
            create_date_input(
                &wgui_inline_date_input,
                x + xx,
                y,
                width - xx,
                height,
                dtflags,
                i->day_buffer,
                i->month_buffer,
                i->year_buffer);
        }
        else
        {
            create_date_input(
                &wgui_inline_date_input,
                x + xx,
                y,
                width - MMI_fixed_icontext_menuitem.text_x,
                height,
                dtflags,
                i->day_buffer,
                i->month_buffer,
                i->year_buffer);
        }
    }
#else 
    create_date_input(
                &wgui_inline_date_input,
                x,
                y,
                width,
                height,
                dtflags,
                i->day_buffer,
                i->month_buffer,
                i->year_buffer);
#endif

#ifdef __MMI_FTE_SUPPORT__
    wgui_inline_date_input.input.flags |= DATE_INPUT_USE_PRESET_CLIP;
#endif

    if(cui_inline_is_current_cui())
    {
        cui_inline_item_replace_gui_buffer(wgui_inline_item_highlighted_index, &wgui_inline_items[wgui_inline_item_highlighted_index], &history_buffer);
    }
    else
    {
        inline_date_edit_set_history(INLINE_DATE_HISTORY_ID, history_buffer);
    }
	inline_date_edit_set_seperator(&wgui_inline_date_input);
    date_input_show_background(&wgui_inline_date_input);
    show_date_input(&wgui_inline_date_input);
    set_current_date_input(&wgui_inline_date_input);
    date_input_register_keys();
    mmi_imc_key_register_ime_keys();
    register_keyboard_key_handler(inline_date_input_key_handler);

    /* key rule. 09.10.17 */
    SetKeyHandler(inline_date_edit_handle_down_arrow, KEY_DOWN_ARROW, KEY_EVENT_REPEAT);
    SetKeyHandler(inline_date_edit_handle_up_arrow, KEY_UP_ARROW, KEY_EVENT_REPEAT);
    SetKeyHandler(inline_date_edit_handle_down_arrow, KEY_VOL_DOWN, KEY_EVENT_REPEAT);
    SetKeyHandler(inline_date_edit_handle_up_arrow, KEY_VOL_UP, KEY_EVENT_REPEAT);
    
    SetKeyHandler(inline_date_edit_handle_down_arrow, KEY_DOWN_ARROW, KEY_EVENT_DOWN);
    SetKeyHandler(inline_date_edit_handle_up_arrow, KEY_UP_ARROW, KEY_EVENT_DOWN);
    SetKeyHandler(inline_date_edit_handle_down_arrow, KEY_VOL_DOWN, KEY_EVENT_DOWN);
    SetKeyHandler(inline_date_edit_handle_up_arrow, KEY_VOL_UP, KEY_EVENT_DOWN);
    redraw_current_inline_item = redraw_inline_date_edit;
    register_date_input_callback(set_wgui_inline_list_menu_changed);
    mmi_imc_redraw_screen_by_state();
}


/*****************************************************************************
 * FUNCTION
 *  SetInlineItemDate
 * DESCRIPTION
 *  set data for inline date
 * PARAMETERS
 *  item                [IN]    inline item     
 *  day_buffer          [IN]    day buffer     
 *  month_buffer        [IN]    month buffer     
 *  year_buffer         [IN]    year buffer     
 *  f                   [IN]    string construct callback    
 * RETURNS
 *  void
 *****************************************************************************/
void SetInlineItemDate(
        InlineItem *item,
        U8 *day_buffer,
        U8 *month_buffer,
        U8 *year_buffer,
        void (*f) (U8 *string_buffer, U8 *day_buffer, U8 *month_buffer, U8 *year_buffer))
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_inline_item_date *i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (n_inline_date_items >= MAX_INLINE_DATE_ITEMS)
    {
        return;
    }

    wgui_inline_mem_alloc_info[wgui_inline_mem_alloc_number] = item->item = wgui_inline_malloc(sizeof(wgui_inline_item_date));
    wgui_inline_mem_alloc_number++; 
    item->flags = INLINE_ITEM_TYPE_DATE;
    wgui_inline_mem_alloc_info[wgui_inline_mem_alloc_number] = item->text_p = (U8*)wgui_inline_malloc(MAX_INLINE_DATE_DISPLAY_STRING_SIZE * sizeof(U8));
    wgui_inline_mem_alloc_number++;  
    n_inline_date_items++;
    i = (wgui_inline_item_date*) item->item;
    i->day_buffer = day_buffer;
    i->month_buffer = month_buffer;
    i->year_buffer = year_buffer;
    i->flags = INLINE_ITEM_LEFT_JUSTIFY;
    i->string_construct_callback = f;
    i->string_construct_callback(item->text_p, i->day_buffer, i->month_buffer, i->year_buffer);
    item->handler = handle_inline_date_edit;
}


/*****************************************************************************
 * FUNCTION
 *  ReConfigureInlineItemDate
 * DESCRIPTION
 *  re-configure of inline date
 * PARAMETERS
 *  item                [IN]    inline item     
 *  day_buffer          [IN]    day buffer     
 *  month_buffer        [IN]    month buffer     
 *  year_buffer         [IN]    year buffer     
 *  f                   [IN]    string construct callback        
 * RETURNS
 *  void
 *****************************************************************************/
void ReConfigureInlineItemDate(
        InlineItem *item,
        U8 *day_buffer,
        U8 *month_buffer,
        U8 *year_buffer,
        void (*f) (U8 *string_buffer, U8 *day_buffer, U8 *month_buffer, U8 *year_buffer))
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_inline_item_date *i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if ((item->flags & 0xff) != INLINE_ITEM_TYPE_DATE)
    {
        return;
    }
    i = (wgui_inline_item_date*) item->item;
    i->day_buffer = day_buffer;
    i->month_buffer = month_buffer;
    i->year_buffer = year_buffer;
    i->flags = 0;
    i->string_construct_callback = f;
    i->string_construct_callback(item->text_p, i->day_buffer, i->month_buffer, i->year_buffer);
}
#endif /* __MMI_INLINE_ITEM_DATE__ */


/*****************************************************************************
 * FUNCTION
 *  wgui_set_date_time_input_focussed_theme
 * DESCRIPTION
 *  set focussed theme for inline date input
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_set_date_time_input_focussed_theme(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    date_time_input_theme.disabled_filler = &date_time_input_field_filler;
    date_time_input_theme.disabled_filler->c = current_MMI_theme->inline_datatime_focussed_filler->c;
    date_time_input_theme.normal_filler = &date_time_input_field_filler;
    date_time_input_theme.normal_filler->c = current_MMI_theme->inline_datatime_focussed_filler->c;    
    date_time_input_theme.selected_filler = &date_time_input_field_filler;
    date_time_input_theme.selected_filler->c = current_MMI_theme->inline_datatime_focussed_filler->c;
    date_time_input_theme.disabled_text_color = wgui_inline_singleline_inputbox_focussed_theme.disabled_text_color;
    date_time_input_theme.normal_text_color = wgui_inline_singleline_inputbox_focussed_theme.normal_text_color;
    date_time_input_theme.selected_text_color = wgui_inline_singleline_inputbox_focussed_theme.selected_text_color;
    date_time_input_background_filler = *current_MMI_theme->inline_datatime_focussed_filler;
#ifdef  __MMI_FTE_SUPPORT__
    date_time_input_background_filler = *(current_MMI_theme->inline_item_textedit_highlighted_bg_filler);
    date_time_input_theme.selection_text_color = wgui_inline_singleline_inputbox_focussed_theme.selection_text_color;
    date_time_input_theme.selection_color = wgui_inline_singleline_inputbox_focussed_theme.selection_color;
    date_time_input_theme.normal_text_color = wgui_inline_singleline_inputbox_focussed_theme.normal_text_color;
#endif   
    date_time_input_theme.cursor_color = *current_MMI_theme->inline_edit_cursor_color;
    date_time_input_theme.selection_text_color = *current_MMI_theme->inline_edit_selected_text_color;
    date_time_input_theme.selection_color = *current_MMI_theme->inline_edit_selector_color;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_set_date_time_input_unfocussed_theme
 * DESCRIPTION
 *  set unfocussed theme for inline date input
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_set_date_time_input_unfocussed_theme(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    date_time_input_theme.disabled_filler = current_MMI_theme->inline_datatime_unfocussed_filler;

    /* changed the date time normal filler in case of default text effect is enabled. */
#ifdef __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__
    if (IsInlineItemDefaultTextEnable())
    {
        date_time_input_theme.normal_filler = &temp_inline_edit_normal_filler;
    }
    else
#endif /* __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__ */ 

    date_time_input_theme.normal_filler = &date_time_input_field_filler;
    date_time_input_theme.normal_filler->c = current_MMI_theme->inline_datatime_unfocussed_filler->c;
    date_time_input_theme.selected_filler = current_MMI_theme->inline_datatime_unfocussed_filler;
    date_time_input_theme.disabled_text_color = wgui_inline_singleline_inputbox_unfocussed_theme.disabled_text_color;
    date_time_input_theme.normal_text_color = wgui_inline_singleline_inputbox_unfocussed_theme.normal_text_color;
    date_time_input_theme.selected_text_color = wgui_inline_singleline_inputbox_unfocussed_theme.selected_text_color;
    date_time_input_background_filler = *current_MMI_theme->inline_datatime_unfocussed_filler;
#ifdef  __MMI_FTE_SUPPORT__
    date_time_input_background_filler = *(current_MMI_theme->inline_item_textedit_unhighlighted_bg_filler);
    date_time_input_theme.selection_text_color= wgui_inline_singleline_inputbox_focussed_theme.selection_text_color;
    date_time_input_theme.selection_color = wgui_inline_singleline_inputbox_focussed_theme.selection_color;
    date_time_input_theme.normal_text_color = wgui_inline_singleline_inputbox_focussed_theme.normal_text_color;
#endif 
    time_period_input_background_filler = MMI_inputbox_normal_filler;   
    date_time_input_theme.cursor_color = *current_MMI_theme->inline_edit_cursor_color;
    date_time_input_theme.selection_text_color = *current_MMI_theme->inline_edit_selected_text_color;
    date_time_input_theme.selection_color = *current_MMI_theme->inline_edit_selector_color;
}


#if defined (__MMI_INLINE_ITEM_DATE__)
/*****************************************************************************
 * FUNCTION
 *  wgui_show_inline_date_list_menuitem
 * DESCRIPTION
 *  show inline date list menuitem
 * PARAMETERS
 *  x1          [IN]  the left-top corner x1 coordinate      
 *  y1          [IN]  the left-top corner y1 coordinate      
 *  width       [IN]  width      
 *  height      [IN]  height      
 *  item        [IN]  inline item         
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_show_inline_date_list_menuitem(S32 x1, S32 y1, S32 width, S32 height, wgui_inline_item *item)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_inline_item_date *i = (wgui_inline_item_date*) item->item;
#ifndef __MMI_FTE_SUPPORT__
    S32 xx;
#endif
    U32 dtflags = DATE_INPUT_TYPE_YYYY_MM_DD;
    date_input wgui_inline_date_input_display = {0};

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();
#ifndef __MMI_FTE_SUPPORT__
    if (MMI_fixed_icontext_menuitem.text_x == 2)
    {
        xx = -1;
    }
    else
    {
        xx = MMI_fixed_icontext_menuitem.text_x;
    }
    if (item->flags & INLINE_ITEM_LEFT_ALIGN)
    {
        xx = -1;
    }
#endif
    switch (item->flags & INLINE_ITEM_JUSTIFY_MASK)
    {
        case INLINE_ITEM_RIGHT_JUSTIFY:
            dtflags |= DATE_INPUT_RIGHT_JUSTIFY;
            break;
        case INLINE_ITEM_CENTER_JUSTIFY:
            dtflags |= DATE_INPUT_CENTER_JUSTIFY;
            break;
    }
    wgui_set_date_time_input_unfocussed_theme();

#ifndef __MMI_FTE_SUPPORT__    
    create_date_input(
        &wgui_inline_date_input_display,
        x1 + xx,
        y1,
        width - xx,
        height,
        dtflags,
        i->day_buffer,
        i->month_buffer,
        i->year_buffer);
#else
    create_date_input(
        &wgui_inline_date_input_display,
        x1,
        y1,
        width,
        height,
        dtflags,
        i->day_buffer,
        i->month_buffer,
        i->year_buffer);
#endif    
    inline_date_edit_set_seperator(&wgui_inline_date_input_display);

#ifdef __MMI_FTE_SUPPORT__
    wgui_inline_date_input_display.input.flags |= DATE_INPUT_USE_PRESET_CLIP;
#endif
    /* show the different background in case of default text effect is enabled
       for the inline item type Date. */
#ifdef __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__
    if (IsInlineItemDefaultTextEnable())
    {
        inline_item_default_text_show_background(
            wgui_inline_date_input_display.input.x,
            wgui_inline_date_input_display.input.y,
            wgui_inline_date_input_display.input.x + wgui_inline_date_input_display.input.width - 1,
            wgui_inline_date_input_display.input.y + wgui_inline_date_input_display.input.height - 1);
    }
    else
#endif /* __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__ */ 

        date_input_show_background(&wgui_inline_date_input_display);
    date_input_reset_focus((void *)&wgui_inline_date_input_display);
    show_date_input(&wgui_inline_date_input_display);
    wgui_set_date_time_input_focussed_theme();
    gdi_layer_unlock_frame_buffer();
}

/*****************************************************************************
 * FUNCTION
 *  mmi_input_box_msg_call_back_inline_date
 * DESCRIPTION
 *  message call back function of inline date for IME
 * PARAMETERS
 *  editor_ptr      [IN]    date input pointer
 *  msg_ptr         [IN]    message pointer
 * RETURNS
 *  U32
 *****************************************************************************/
static U32 mmi_input_box_msg_call_back_inline_date(date_input  * editor_ptr, mmi_imc_message_struct_p msg_ptr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL is_last = MMI_FALSE;
    S32 i, str_len;
    U32 lresult = 0;
    UI_string_type temp_str;
    UI_character_type ch; 
#ifdef __MMI_TOUCH_SCREEN__
    MMI_BOOL ret = MMI_FALSE;
#endif /* __MMI_TOUCH_SCREEN__ */

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    MMI_ASSERT(editor_ptr == &wgui_inline_date_input);

    switch(msg_ptr->message_id)
    {
    case MMI_IMC_MESSAGE_INSERT_CHAR:
        
        date_input_direct_input_nodraw((UI_character_type)msg_ptr->param_0);

        redraw_inline_date_edit();

        lresult = MMI_TRUE;

        break;
        
    case MMI_IMC_MESSAGE_INSERT_STRING:
    case MMI_IMC_MESSAGE_INSERT_STRING_NO_DRAW:    
        /* Need to revise */
        temp_str = (UI_string_type)msg_ptr->param_0;
        
        str_len = (S32)mmi_ucs2strlen((const S8 *)temp_str);

        
        if (msg_ptr->param_1 == MMI_TRUE)
        {
            if (date_input_test_last_position(editor_ptr))
            {
                is_last = MMI_TRUE;
            }
            
            date_input_direct_input_nodraw((UI_character_type)temp_str[0]);
            
            if (!is_last)
            {
                date_input_previous_character();
            }
            
            show_date_input(editor_ptr);
            }
        else
        {
            date_input_direct_input((UI_character_type)temp_str[0]);
        }
        
        redraw_inline_date_edit();
        
        lresult = str_len;
        break;
    case MMI_IMC_MESSAGE_REPLACE_HIGHLIGHT_STRING:  
        temp_str = (UI_string_type)msg_ptr->param_1;
        
        str_len = (S32)mmi_ucs2strlen((const S8 *)temp_str);

            if (date_input_test_last_position(editor_ptr))
            {
                is_last = MMI_TRUE;
            }
            
            date_input_direct_input_nodraw((UI_character_type)temp_str[0]);
            
            if (!is_last)
            {
                date_input_previous_character();
            }
            
            show_date_input(editor_ptr);
        
            redraw_inline_date_edit();
        
        lresult = str_len;
        break;

        
    case MMI_IMC_MESSAGE_CLEAR_HILIGHT:
        if (msg_ptr->param_0 == MMI_TRUE)
        {
            date_input_next_character();
        }
        break;
        
    case MMI_IMC_MESSAGE_IS_LAST_POSITION:
        lresult = (U32)date_input_test_last_position(editor_ptr);
        break;
        
    case MMI_IMC_MESSAGE_DELETE_STRING:
        
        break;
        
    case MMI_IMC_MESSAGE_INSERT_MULTITAP_CHAR:
        ch = (UI_character_type)msg_ptr->param_0;
        lresult = date_input_direct_input_nodraw(ch);
        break;

    case MMI_IMC_MESSAGE_RESET_MULTITAP_STATE:
        date_input_next_character();
        break;
        
    case MMI_IMC_MESSAGE_DELETE_CHAR:

        for (i = 0; i < (S32)msg_ptr->param_0; i++)
        {
            date_input_previous_character();
        }

        break;
    case MMI_IMC_MESSAGE_CLEAR_ALL:    
        date_input_first_character();
        break;
       
    case MMI_IMC_MESSAGE_REDRAW:
        
        wgui_inline_date_input.current_focus = g_inline_date_current_focus;

        date_input_reset_focus((void *)&wgui_inline_date_input);

        date_input_set_focus((void *)&wgui_inline_date_input);

        if (wgui_inline_date_input.focus_input_box != NULL)
        {
            wgui_inline_date_input.focus_input_box->current_text_p =
                wgui_inline_date_input.focus_input_box->text + g_inline_date_current_position;
        }

        wgui_inline_date_input.input.flags = g_inline_date_flags;
        
        redraw_inline_date_edit();
        
        break;
    case MMI_IMC_MESSAGE_SET_KEY:
        date_input_register_keys();
        mmi_imc_key_register_ime_keys();
        register_keyboard_key_handler(inline_date_input_key_handler);

        /* key rule. 09.10.17 */
        SetKeyHandler(inline_date_edit_handle_down_arrow, KEY_DOWN_ARROW, KEY_EVENT_REPEAT);
        SetKeyHandler(inline_date_edit_handle_up_arrow, KEY_UP_ARROW, KEY_EVENT_REPEAT);
        
        SetKeyHandler(inline_date_edit_handle_down_arrow, KEY_DOWN_ARROW, KEY_EVENT_DOWN);
        SetKeyHandler(inline_date_edit_handle_up_arrow, KEY_UP_ARROW, KEY_EVENT_DOWN);
        set_right_softkey_label(wgui_inline_edit_get_RSK_string());
        register_right_softkey_handler();
        set_right_softkey_function(register_inline_edit_handle_right_softkey_up, KEY_EVENT_DOWN);
        break;
    case MMI_IMC_MESSAGE_CHECK_CSK_ENABLE:
        lresult = MMI_FALSE;
        break;
    case MMI_IMC_MESSAGE_CHECK_INFO_BAR_ENABL:
        lresult = MMI_FALSE;
        break;

    case MMI_IMC_MESSAGE_GET_CURSOR_RECT:
        if (editor_ptr->focus_input_box->flags & UI_SINGLE_LINE_INPUT_BOX_SHOW_BLOCK_CURSOR)
        {
            ((mmi_imc_rect_p)msg_ptr->param_0)->x = editor_ptr->focus_input_box->hilite_s_x;
            ((mmi_imc_rect_p)msg_ptr->param_0)->y = editor_ptr->focus_input_box->hilite_s_y;
            ((mmi_imc_rect_p)msg_ptr->param_0)->width = editor_ptr->focus_input_box->hilite_e_x - editor_ptr->focus_input_box->hilite_s_x + 1;
            ((mmi_imc_rect_p)msg_ptr->param_0)->height = editor_ptr->focus_input_box->hilite_e_y - editor_ptr->focus_input_box->hilite_s_y + 1;
        }
        else
        {
            ((mmi_imc_rect_p)msg_ptr->param_0)->x = UI_cursor_x1;
            ((mmi_imc_rect_p)msg_ptr->param_0)->y = UI_cursor_y1;
            ((mmi_imc_rect_p)msg_ptr->param_0)->width = UI_cursor_x2 - UI_cursor_x1 + 1;
            ((mmi_imc_rect_p)msg_ptr->param_0)->height = UI_cursor_y2 - UI_cursor_y1 + 1;
        }
        lresult = MMI_TRUE;
        break;

    case MMI_IMC_MESSAGE_MOVE_CURSOR:
        switch (msg_ptr->param_0)
        {
            case MMI_IMC_EDITOR_CURSOR_UP:
                for (i = 0; i <(S32)msg_ptr->param_1; i ++)
                {
                    inline_date_edit_handle_up_arrow();
                }
                break;
                
            case MMI_IMC_EDITOR_CURSOR_DOWN:
                for (i = 0; i <(S32)msg_ptr->param_1; i ++)
                {
                    inline_date_edit_handle_down_arrow();
                }
                break;
                
            case MMI_IMC_EDITOR_CURSOR_LEFT:
                for (i = 0; i <(S32)msg_ptr->param_1; i ++)
                {
                    date_input_previous_character();
                }
                break;
            case MMI_IMC_EDITOR_CURSOR_RIGHT:
                for (i = 0; i <(S32)msg_ptr->param_1; i ++)
                {
                    date_input_next_character();
                }
                break;
        }
        break;
        
    case MMI_IMC_MESSAGE_IS_BACKSPACE_DISABLED:
        lresult = MMI_TRUE;
        break;
        
#if defined(__MMI_TOUCH_SCREEN__)        
    case MMI_IMC_MESSAGE_PEN_EVENT:
        if (((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->mmi_pen_event == MMI_PEN_EVENT_DOWN)
        {
            if (PEN_CHECK_BOUND(((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos.x, 
                                ((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos.y, 
                                editor_ptr->input.x, editor_ptr->input.y, 
                                editor_ptr->input.width,
                                editor_ptr->input.height))
            {
                *((U32 *)msg_ptr->param_1) = 1;
                ret = MMI_TRUE;
            }
            else
            {
                ret = MMI_FALSE;
            }
        }
        else if (((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->mmi_pen_event == MMI_PEN_EVENT_UP)
        {
            if (PEN_CHECK_BOUND(((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos.x, 
                                ((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos.y, 
                                editor_ptr->input.x, editor_ptr->input.y, 
                                editor_ptr->input.width,
                                editor_ptr->input.height))
            {
                date_input_move_to_x_y(editor_ptr, 
                                   ((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos.x, 
                                   ((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos.y);
                ret = MMI_TRUE;
            }
            else
            {
                ret = MMI_FALSE;
            }
            
        }
        
        lresult = ret;
        
        break;
#endif

    default:
        break;
    }

    return lresult;
}
#endif /* __MMI_INLINE_ITEM_DATE__ */

#if defined (__MMI_INLINE_ITEM_TIME__)
/***************************************************************************** 
 * Inline Time Edit    
 *
 * This is Inline Time Edit Item
 *****************************************************************************/

/***************************************************************************** 
 * Define
 *****************************************************************************/
#define MAX_INLINE_TIME_ITEMS                         4
#define MAX_INLINE_TIME_DISPLAY_STRING_SIZE           24


/***************************************************************************** 
 * Typedef 
 *****************************************************************************/ 
typedef struct _inline_time_edit_history
{
    U16 history_ID;
    S16 current_focus;
    S16 current_position;
    S16 dummy;  /* Added for history issue on hardware */
    U32 flags;
    mmi_imc_history ime_history;
} inline_time_edit_history;


/***************************************************************************** 
 * Local Variable
 *****************************************************************************/
static S32 n_inline_time_items = 0;
static wgui_inline_item_time *current_wgui_inline_time_item;
static PU8 *current_wgui_inline_time_text_p;

time_input wgui_inline_time_input;
/* Displaying time edit as a menu item in the fixed list menu  */
//static time_input wgui_inline_time_input_display;
static U8 dummy_second[2];

/***************************************************************************** 
 * Function Implementation
 *****************************************************************************/

/*****************************************************************************
 * FUNCTION
 *  handle_inline_time_edit_complete
 * DESCRIPTION
 *  complete function for inline time edit
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void handle_inline_time_edit_complete(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    register_inline_fixed_list_keys();

    current_wgui_inline_time_item->string_construct_callback(
                                    *current_wgui_inline_time_text_p,
                                    current_wgui_inline_time_item->hours_buffer,
                                    current_wgui_inline_time_item->minutes_buffer,
                                    current_wgui_inline_time_item->AM_PM_flag);
    MMI_fixed_icontext_menuitems[wgui_inline_item_highlighted_index].item_text =
        (UI_string_type) * current_wgui_inline_time_text_p;
   // clear_left_softkey();
   // clear_right_softkey();
    register_left_softkey_handler();
    register_right_softkey_handler();

    wgui_inline_item_handled = 0;
    wgui_text_menuitem_restart_scrolling();
    redraw_current_inline_item = UI_dummy_function;
    complete_inline_item_edit = UI_dummy_function;
    set_current_time_input(NULL);
    clear_time_input_callback();
    mmi_imc_disconnect();
    g_inline_current_input_box_handler = NULL;
}


/*****************************************************************************
 * FUNCTION
 *  redraw_inline_time_edit
 * DESCRIPTION
 *  redraw inine time edit
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void redraw_inline_time_edit(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    time_input_show_background(&wgui_inline_time_input);
    show_time_input(&wgui_inline_time_input);
}


/*****************************************************************************
 * FUNCTION
 *  inline_time_edit_handle_down_arrow
 * DESCRIPTION
 *  down arrow handler of inline time edit
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void inline_time_edit_handle_down_arrow(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_FTE_SUPPORT__    
    wgui_inline_get_vk_status(&g_inline_vk_status);
#endif
    handle_inline_time_edit_complete();
    inline_fixed_list_goto_next_item();
}


/*****************************************************************************
 * FUNCTION
 *  inline_time_edit_handle_up_arrow
 * DESCRIPTION
 *  up arrow handler of inline time edit
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void inline_time_edit_handle_up_arrow(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_FTE_SUPPORT__    
    wgui_inline_get_vk_status(&g_inline_vk_status);
#endif
    handle_inline_time_edit_complete();
    inline_fixed_list_goto_previous_item();
}


/*****************************************************************************
 * FUNCTION
 *  inline_time_input_key_handler
 * DESCRIPTION
 *  key handler of inilne time input for PC
 * PARAMETERS
 *  vkey_code       [IN]     key code   
 *  key_state       [IN]     key state   
 * RETURNS
 *  void
 *****************************************************************************/
void inline_time_input_key_handler(S32 vkey_code, S32 key_state)
{
#if(MMI_BUILD_TYPE == BUILD_TYPE_X86WIN32)
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (key_state)
    {
        switch (vkey_code)
        {
            case 37:
                time_input_previous_character();
                break;
            case 38:
                inline_time_edit_handle_up_arrow();
                break;
            case 39:
                time_input_next_character();
                break;
            case 40:
                inline_time_edit_handle_down_arrow();
                break;
            case 36:    /* home */
                break;
            case 35:    /* end */
                break;
            case 33:    /* page up */
                break;
            case 34:    /* page down */
                break;
            case 45:
                time_input_toggle_insert_mode();
                break;
            case 46:
                time_input_delete_current_character();
                break;
        }
    }
#else /* (MMI_BUILD_TYPE == BUILD_TYPE_X86WIN32) */ 
    UI_UNUSED_PARAMETER(vkey_code);
    UI_UNUSED_PARAMETER(key_state);
#endif /* (MMI_BUILD_TYPE == BUILD_TYPE_X86WIN32) */ 
}


/*****************************************************************************
 * FUNCTION
 *  inline_time_edit_get_history
 * DESCRIPTION
 *  get history buffer for inline time edit
 * PARAMETERS
 *  history_buffer      [OUT]   history buffer     
 * RETURNS
 *  history buffer
 *****************************************************************************/
U8 *inline_time_edit_get_history(U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (history_buffer != NULL)
    {
        U16 hID = (U16) (INLINE_TIME_HISTORY_ID | 0x8000);
        inline_time_edit_history *h = (inline_time_edit_history*) history_buffer;

        h->history_ID = hID;
        h->current_focus = (S16) wgui_inline_time_input.current_focus;
        if (wgui_inline_time_input.focus_input_box != NULL)
        {
            h->current_position =
                (S16) (wgui_inline_time_input.focus_input_box->current_text_p -
                       wgui_inline_time_input.focus_input_box->text);
        }
        h->flags = wgui_inline_time_input.input.flags;
        mmi_imc_get_input_method_history(&(h->ime_history));
    }
    return (history_buffer);
}


/*****************************************************************************
 * FUNCTION
 *  inline_time_edit_set_history
 * DESCRIPTION
 *  set history buffer for inline time edit
 * PARAMETERS
 *  history_ID          [IN]   history id     
 *  history_buffer      [IN]   history buffer      
 * RETURNS
 *  1->success 0->fail
 *****************************************************************************/
U8 inline_time_edit_set_history(U16 history_ID, U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (history_buffer != NULL)
    {
        inline_time_edit_history *h = (inline_time_edit_history*) history_buffer;

        if (history_valid(h->history_ID, history_ID))
        {
            wgui_inline_time_input.current_focus = h->current_focus;
            time_input_reset_focus((void *)&wgui_inline_time_input);
            time_input_set_focus((void *)&wgui_inline_time_input);
            if (wgui_inline_time_input.focus_input_box != NULL)
            {
                wgui_inline_time_input.focus_input_box->current_text_p =
                    wgui_inline_time_input.focus_input_box->text + h->current_position;
            }
            wgui_inline_time_input.input.flags = h->flags;
            return (1);
        }
    }
    return (0);
}


/*****************************************************************************
 * FUNCTION
 *  handle_inline_time_edit
 * DESCRIPTION
 *  activation function of inline time edit
 * PARAMETERS
 *  x                   [IN]        left corner's x coordinate
 *  y                   [IN]        left corner's y coordinate
 *  width               [IN]        width
 *  height              [IN]        height
 *  key_code            [IN]        key code
 *  key_event           [IN]        key event
 *  text_p              [IN]        text pointer
 *  item                [IN]        inline item
 *  flags               [IN]        flags
 *  history_buffer      [IN]        history buffer      
 * RETURNS
 *  void
 *****************************************************************************/
void handle_inline_time_edit(
        S32 x,
        S32 y,
        S32 width,
        S32 height,
        S32 key_code,
        S32 key_event,
        U8 **text_p,
        void *item,
        U32 flags,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_inline_item_time *i = (wgui_inline_item_time*) item;
#ifndef __MMI_FTE_SUPPORT__
    S32 xx;
#endif
    U32 dtflags = TIME_INPUT_TYPE_HH_MM; 

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(key_event);
    UI_UNUSED_PARAMETER(key_code);
    UI_UNUSED_PARAMETER(flags);
    wgui_current_inline_item_type = INLINE_ITEM_TYPE_TIME;
#ifndef __MMI_FTE_SUPPORT__
    if (!mmi_fe_get_r2l_state())
    {
        if (MMI_fixed_icontext_menuitem.text_x == 2)
        {
            xx = -1;
        }
        else
        {
            xx = MMI_fixed_icontext_menuitem.text_x;
        }
    }
    else
    {
        xx = 1;
    }


    if (flags & INLINE_ITEM_LEFT_ALIGN)
    {
        xx = -1;
    }
#endif
    switch (flags & INLINE_ITEM_JUSTIFY_MASK)
    {
        case INLINE_ITEM_RIGHT_JUSTIFY:
            dtflags |= TIME_INPUT_RIGHT_JUSTIFY;
            break;
        case INLINE_ITEM_CENTER_JUSTIFY:
            dtflags |= TIME_INPUT_CENTER_JUSTIFY;
            break;
    }
    complete_inline_item_edit = handle_inline_time_edit_complete;
    current_wgui_inline_time_item = i;
    current_wgui_inline_time_text_p = text_p;
    
#ifndef __MMI_FTE_SUPPORT__
    if (!mmi_fe_get_r2l_state())
    {
        create_time_input(
            &wgui_inline_time_input,
            x + xx,
            y,
            width - xx,
            height,
            dtflags,
            i->hours_buffer,
            i->minutes_buffer,
            i->seconds_buffer);
    }
    else
    {
        if (flags & INLINE_ITEM_LEFT_ALIGN)
        {
            create_time_input(
                &wgui_inline_time_input,
                x + xx,
                y,
                width - xx,
                height,
                dtflags,
                i->hours_buffer,
                i->minutes_buffer,
                i->seconds_buffer);
        }
        else
        {
            create_time_input(
                &wgui_inline_time_input,
                x + xx,
                y,
                width - MMI_fixed_icontext_menuitem.text_x,
                height,
                dtflags,
                i->hours_buffer,
                i->minutes_buffer,
                i->seconds_buffer);
        }
    }

#else

    create_time_input(
                &wgui_inline_time_input,
                x,
                y,
                width,
                height,
                dtflags,
                i->hours_buffer,
                i->minutes_buffer,
                i->seconds_buffer);
#endif

#ifdef __MMI_FTE_SUPPORT__
    wgui_inline_time_input.input.flags |= TIME_INPUT_USE_PRESET_CLIP;
#endif

    if(cui_inline_is_current_cui())
    {
        cui_inline_item_replace_gui_buffer(wgui_inline_item_highlighted_index, &wgui_inline_items[wgui_inline_item_highlighted_index], &history_buffer);
    }
    else
    {
        inline_time_edit_set_history(INLINE_TIME_HISTORY_ID, history_buffer);
    }
    
    time_input_set_seperator(&wgui_inline_time_input, (UI_character_type) ':');
    time_input_show_background(&wgui_inline_time_input);
    show_time_input(&wgui_inline_time_input);
    set_current_time_input(&wgui_inline_time_input);
    time_input_register_keys();
    mmi_imc_key_register_ime_keys();
    register_keyboard_key_handler(inline_time_input_key_handler);

    /* key rule. 09.10.17 */
    SetKeyHandler(inline_time_edit_handle_down_arrow, KEY_DOWN_ARROW, KEY_EVENT_REPEAT);
    SetKeyHandler(inline_time_edit_handle_up_arrow, KEY_UP_ARROW, KEY_EVENT_REPEAT);
    SetKeyHandler(inline_time_edit_handle_down_arrow, KEY_VOL_DOWN, KEY_EVENT_REPEAT);
    SetKeyHandler(inline_time_edit_handle_up_arrow, KEY_VOL_UP, KEY_EVENT_REPEAT);
    
    SetKeyHandler(inline_time_edit_handle_down_arrow, KEY_DOWN_ARROW, KEY_EVENT_DOWN);
    SetKeyHandler(inline_time_edit_handle_up_arrow, KEY_UP_ARROW, KEY_EVENT_DOWN);
    SetKeyHandler(inline_time_edit_handle_down_arrow, KEY_VOL_DOWN, KEY_EVENT_DOWN);
    SetKeyHandler(inline_time_edit_handle_up_arrow, KEY_VOL_UP, KEY_EVENT_DOWN);
    register_time_input_callback(set_wgui_inline_list_menu_changed);
    redraw_current_inline_item = redraw_inline_time_edit;
    mmi_imc_redraw_screen_by_state();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_input_box_msg_call_back_inline_time
 * DESCRIPTION
 *  message call back function of inine time for IME
 * PARAMETERS
 *  editor_ptr          [IN]     time input pointer   
 *  msg_ptr             [IN]     message pointer        
 * RETURNS
 *  U32
 *****************************************************************************/
static U32 mmi_input_box_msg_call_back_inline_time(time_input  * editor_ptr, mmi_imc_message_struct_p msg_ptr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL is_last = MMI_FALSE;
    S32 i, str_len;
    U32 lresult = 0;
    UI_string_type temp_str;
    UI_character_type ch; 
#ifdef __MMI_TOUCH_SCREEN__
    MMI_BOOL ret = MMI_FALSE;
#endif /* __MMI_TOUCH_SCREEN__ */

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    MMI_ASSERT(editor_ptr == &wgui_inline_time_input);

    switch(msg_ptr->message_id)
    {
    case MMI_IMC_MESSAGE_INSERT_CHAR:
        
        time_input_direct_input_nodraw((UI_character_type)msg_ptr->param_0);

        redraw_inline_time_edit();

        lresult = MMI_TRUE;

        break;
        
    case MMI_IMC_MESSAGE_INSERT_STRING:
    case MMI_IMC_MESSAGE_INSERT_STRING_NO_DRAW:    
        /* Need to revise */
        temp_str = (UI_string_type)msg_ptr->param_0;
        
        str_len = (S32)mmi_ucs2strlen((const S8 *)temp_str);

        if (msg_ptr->param_1 == MMI_TRUE)
        {
            if (time_input_test_last_position(editor_ptr))
            {
                is_last = MMI_TRUE;
            }
            
            time_input_direct_input_nodraw((UI_character_type)temp_str[0]);
            
            if (!is_last)
            {
                time_input_previous_character();
            }
            
            show_time_input(editor_ptr);
        }
        else
        {
            time_input_direct_input((UI_character_type)temp_str[0]);
        }
        
        redraw_inline_time_edit();
        
        lresult = str_len;
        
        break;
        case MMI_IMC_MESSAGE_REPLACE_HIGHLIGHT_STRING:
    
        temp_str = (UI_string_type)msg_ptr->param_1;
        
        str_len = (S32)mmi_ucs2strlen((const S8 *)temp_str);

            if (time_input_test_last_position(editor_ptr))
            {
                is_last = MMI_TRUE;
            }
            
            time_input_direct_input_nodraw((UI_character_type)temp_str[0]);
            
            if (!is_last)
            {
                time_input_previous_character();
            }
            
            show_time_input(editor_ptr);
        
    redraw_inline_time_edit();
        
        lresult = str_len;
        
        break;
        
        
    case MMI_IMC_MESSAGE_CLEAR_HILIGHT:
        if (msg_ptr->param_0 == MMI_TRUE)
        {
            time_input_next_character();
        }
        break;
        
    case MMI_IMC_MESSAGE_IS_LAST_POSITION:
        lresult = (U32)time_input_test_last_position(editor_ptr);
        break;
        
    case MMI_IMC_MESSAGE_DELETE_STRING:
        
        break;
        
    case MMI_IMC_MESSAGE_INSERT_MULTITAP_CHAR:
        ch = (UI_character_type)msg_ptr->param_0;
        lresult = time_input_direct_input_nodraw(ch);
        break;

    case MMI_IMC_MESSAGE_RESET_MULTITAP_STATE:
        time_input_next_character();
        break;
        
    case MMI_IMC_MESSAGE_DELETE_CHAR:

        for (i = 0; i < (S32)msg_ptr->param_0; i++)
        {
            time_input_previous_character();
        }

        break;

    case MMI_IMC_MESSAGE_CLEAR_ALL:
       time_input_first_character();
       break;
    case MMI_IMC_MESSAGE_REDRAW:
        
        wgui_inline_time_input.current_focus = g_inline_time_current_focus;

        time_input_reset_focus((void *)&wgui_inline_time_input);
        time_input_set_focus((void *)&wgui_inline_time_input);
        
        if (wgui_inline_time_input.focus_input_box != NULL)
        {
            wgui_inline_time_input.focus_input_box->current_text_p =
                wgui_inline_time_input.focus_input_box->text + g_inline_time_current_position;
        }
        
        wgui_inline_time_input.input.flags = g_inline_time_flags;

        redraw_inline_time_edit();
        
        break;
    case MMI_IMC_MESSAGE_SET_KEY:
        time_input_register_keys();
        mmi_imc_key_register_ime_keys();
        register_keyboard_key_handler(inline_time_input_key_handler);

        /* key rule. 09.10.17 */
        SetKeyHandler(inline_time_edit_handle_down_arrow, KEY_DOWN_ARROW, KEY_EVENT_REPEAT);
        SetKeyHandler(inline_time_edit_handle_up_arrow, KEY_UP_ARROW, KEY_EVENT_REPEAT);
        SetKeyHandler(inline_time_edit_handle_down_arrow, KEY_DOWN_ARROW, KEY_EVENT_DOWN);
        SetKeyHandler(inline_time_edit_handle_up_arrow, KEY_UP_ARROW, KEY_EVENT_DOWN);
        set_right_softkey_label(wgui_inline_edit_get_RSK_string());
        register_right_softkey_handler();
        set_right_softkey_function(register_inline_edit_handle_right_softkey_up, KEY_EVENT_DOWN);
        break;
    case MMI_IMC_MESSAGE_CHECK_CSK_ENABLE:
        lresult = MMI_FALSE;
        break;
    case MMI_IMC_MESSAGE_CHECK_INFO_BAR_ENABL:
        lresult = MMI_FALSE;
        break;
    
    case MMI_IMC_MESSAGE_GET_CURSOR_RECT:
        if (editor_ptr->focus_input_box->flags & UI_SINGLE_LINE_INPUT_BOX_SHOW_BLOCK_CURSOR)
        {
            ((mmi_imc_rect_p)msg_ptr->param_0)->x = editor_ptr->focus_input_box->hilite_s_x;
            ((mmi_imc_rect_p)msg_ptr->param_0)->y = editor_ptr->focus_input_box->hilite_s_y;
            ((mmi_imc_rect_p)msg_ptr->param_0)->width = editor_ptr->focus_input_box->hilite_e_x - editor_ptr->focus_input_box->hilite_s_x + 1;
            ((mmi_imc_rect_p)msg_ptr->param_0)->height = editor_ptr->focus_input_box->hilite_e_y - editor_ptr->focus_input_box->hilite_s_y + 1;
        }
        else
        {
            ((mmi_imc_rect_p)msg_ptr->param_0)->x = UI_cursor_x1;
            ((mmi_imc_rect_p)msg_ptr->param_0)->y = UI_cursor_y1;
            ((mmi_imc_rect_p)msg_ptr->param_0)->width = UI_cursor_x2 - UI_cursor_x1 + 1;
            ((mmi_imc_rect_p)msg_ptr->param_0)->height = UI_cursor_y2 - UI_cursor_y1 + 1;
        }
        lresult = MMI_TRUE;
        break;
        
    case MMI_IMC_MESSAGE_MOVE_CURSOR:
        switch (msg_ptr->param_0)
        {
            case MMI_IMC_EDITOR_CURSOR_UP:
                for (i = 0; i <(S32)msg_ptr->param_1; i ++)
                {
                    inline_time_edit_handle_up_arrow();
                }
                break;
                
            case MMI_IMC_EDITOR_CURSOR_DOWN:
                for (i = 0; i <(S32)msg_ptr->param_1; i ++)
                {
                    inline_time_edit_handle_down_arrow();
                }
                break;
                
            case MMI_IMC_EDITOR_CURSOR_LEFT:
                for (i = 0; i <(S32)msg_ptr->param_1; i ++)
                {
                    time_input_previous_character();
                }
                break;
            case MMI_IMC_EDITOR_CURSOR_RIGHT:
                for (i = 0; i <(S32)msg_ptr->param_1; i ++)
                {
                    time_input_next_character();
                }
                break;
        }
        break;
        
    case MMI_IMC_MESSAGE_IS_BACKSPACE_DISABLED:
        lresult = MMI_TRUE;
        break;
        
#if defined(__MMI_TOUCH_SCREEN__)        
    case MMI_IMC_MESSAGE_PEN_EVENT:
        if (((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->mmi_pen_event == MMI_PEN_EVENT_DOWN)
        {
            if (PEN_CHECK_BOUND(((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos.x, 
                                ((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos.y, 
                                editor_ptr->input.x, editor_ptr->input.y, 
                                editor_ptr->input.width,
                                editor_ptr->input.height))
            {
                *((U32 *)msg_ptr->param_1) = 1;
                ret = MMI_TRUE;
            }
            else
            {
                ret = MMI_FALSE;
            }
        }
        else if (((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->mmi_pen_event == MMI_PEN_EVENT_UP)
        {
            if (PEN_CHECK_BOUND(((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos.x, 
                                ((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos.y, 
                                editor_ptr->input.x, editor_ptr->input.y, 
                                editor_ptr->input.width,
                                editor_ptr->input.height))
            {
                time_input_move_to_x_y(editor_ptr, 
                                   ((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos.x, 
                                   ((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos.y);
                ret = MMI_TRUE;
            }
            else
            {
                ret = MMI_FALSE;
            }
            
        }
        
        lresult = ret;
        
        break;
#endif

    default:
        break;
    }

    return lresult;
}


/*****************************************************************************
 * FUNCTION
 *  SetInlineItemTime
 * DESCRIPTION
 *  set data for inline time edit
 * PARAMETERS
 *  item                [IN]       inline item         
 *  hours_buffer        [IN]       hours buffer  
 *  minutes_buffer      [IN]       minutes buffer  
 *  AM_PM_flag          [IN]       flag for AM_PM  
 *  f                   [IN]       string construct callback 
 * RETURNS
 *  void
 *****************************************************************************/
void SetInlineItemTime(
        InlineItem *item,
        U8 *hours_buffer,
        U8 *minutes_buffer,
        U8 *AM_PM_flag,
        void (*f) (U8 *string_buffer, U8 *hours_buffer, U8 *minutes_buffer, U8 *AM_PM_flag))
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_inline_item_time *i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (n_inline_time_items >= MAX_INLINE_TIME_ITEMS)
    {
        return;
    }
    wgui_inline_mem_alloc_info[wgui_inline_mem_alloc_number] = item->item = wgui_inline_malloc(sizeof(wgui_inline_item_time));
    wgui_inline_mem_alloc_number++;  
    item->flags = INLINE_ITEM_TYPE_TIME;
    wgui_inline_mem_alloc_info[wgui_inline_mem_alloc_number] = item->text_p = (U8*)wgui_inline_malloc(MAX_INLINE_TIME_DISPLAY_STRING_SIZE * sizeof(U8));
    wgui_inline_mem_alloc_number++; 
    n_inline_time_items++;
    i = (wgui_inline_item_time*) item->item;
    i->hours_buffer = hours_buffer;
    i->minutes_buffer = minutes_buffer;
    i->seconds_buffer = dummy_second;
    i->AM_PM_flag = AM_PM_flag;
    i->flags = INLINE_ITEM_LEFT_JUSTIFY;
    i->string_construct_callback = f;
    i->string_construct_callback(item->text_p, i->hours_buffer, i->minutes_buffer, i->AM_PM_flag);
    item->handler = handle_inline_time_edit;
}


/*****************************************************************************
 * FUNCTION
 *  ReConfigureInlineItemTime
 * DESCRIPTION
 *  re-configure for inline time edit
 * PARAMETERS
 *  item                [IN]       inline item         
 *  hours_buffer        [IN]       hours buffer  
 *  minutes_buffer      [IN]       minutes buffer  
 *  AM_PM_flag          [IN]       flag for AM_PM  
 *  f                   [IN]       string construct callback       
 * RETURNS
 *  void
 *****************************************************************************/
void ReConfigureInlineItemTime(
        InlineItem *item,
        U8 *hours_buffer,
        U8 *minutes_buffer,
        U8 *AM_PM_flag,
        void (*f) (U8 *string_buffer, U8 *hours_buffer, U8 *minutes_buffer, U8 *AM_PM_flag))
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_inline_item_time *i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if ((item->flags & 0xff) != INLINE_ITEM_TYPE_TIME)
    {
        return;
    }
    i = (wgui_inline_item_time*) item->item;
    i->hours_buffer = hours_buffer;
    i->minutes_buffer = minutes_buffer;
    i->AM_PM_flag = AM_PM_flag;
    i->flags = 0;
    i->string_construct_callback = f;
    i->string_construct_callback(item->text_p, i->hours_buffer, i->minutes_buffer, i->AM_PM_flag);
}




/*****************************************************************************
 * FUNCTION
 *  wgui_show_inline_time_list_menuitem
 * DESCRIPTION
 *  show inline time list menuitem
 * PARAMETERS
 *  x1          [IN]  the left-top corner x1 coordinate      
 *  y1          [IN]  the left-top corner y1 coordinate      
 *  width       [IN]  width      
 *  height      [IN]  height      
 *  item        [IN]  inline item          
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_show_inline_time_list_menuitem(S32 x1, S32 y1, S32 width, S32 height, wgui_inline_item *item)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_inline_item_time *i = (wgui_inline_item_time*) item->item;
#ifndef __MMI_FTE_SUPPORT__
    S32 xx;
#endif
    U32 dtflags = TIME_INPUT_TYPE_HH_MM;
    time_input wgui_inline_time_input_display = {0};

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();
#ifndef __MMI_FTE_SUPPORT__
    if (MMI_fixed_icontext_menuitem.text_x == 2)
    {
        xx = -1;
    }
    else
    {
        xx = MMI_fixed_icontext_menuitem.text_x;
    }
    if (item->flags & INLINE_ITEM_LEFT_ALIGN)
    {
        xx = -1;
    }
#endif
    switch (item->flags & INLINE_ITEM_JUSTIFY_MASK)
    {
        case INLINE_ITEM_RIGHT_JUSTIFY:
            dtflags |= DATE_INPUT_RIGHT_JUSTIFY;
            break;
        case INLINE_ITEM_CENTER_JUSTIFY:
            dtflags |= DATE_INPUT_CENTER_JUSTIFY;
            break;
    }
    wgui_set_date_time_input_unfocussed_theme();

#ifndef __MMI_FTE_SUPPORT__    
    create_time_input(
        &wgui_inline_time_input_display,
        x1 + xx,
        y1,
        width - xx,
        height,
        dtflags,
        i->hours_buffer,
        i->minutes_buffer,
        i->seconds_buffer);
    time_input_set_seperator(&wgui_inline_time_input_display, (UI_character_type) ':');

#else
    
    create_time_input(
        &wgui_inline_time_input_display,
        x1 ,
        y1,
        width,
        height,
        dtflags,
        i->hours_buffer,
        i->minutes_buffer,
        i->seconds_buffer);  
#endif

#ifdef __MMI_FTE_SUPPORT__
    wgui_inline_time_input_display.input.flags |= TIME_INPUT_USE_PRESET_CLIP;
#endif

    time_input_set_seperator(&wgui_inline_time_input_display, (UI_character_type) ':');
    /* show the different background in case of default text effect is enabled
       for the inline item type Time. */
#ifdef __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__
    if (IsInlineItemDefaultTextEnable())
    {
        inline_item_default_text_show_background(
            wgui_inline_time_input_display.input.x,
            wgui_inline_time_input_display.input.y,
            wgui_inline_time_input_display.input.x + wgui_inline_time_input_display.input.width - 1,
            wgui_inline_time_input_display.input.y + wgui_inline_time_input_display.input.height - 1);
    }
    else
#endif /* __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__ */ 
        time_input_show_background(&wgui_inline_time_input_display);
    time_input_reset_focus((void *)&wgui_inline_time_input_display);
    show_time_input(&wgui_inline_time_input_display);
    wgui_set_date_time_input_focussed_theme();
    gdi_layer_unlock_frame_buffer();
}
#endif /* __MMI_INLINE_ITEM_TIME__ */


/***************************************************************************** 
 * Inline User Defined Select    
 *
 * This is Inline User Defined Select Item
 *****************************************************************************/

/***************************************************************************** 
 * Define
 *****************************************************************************/
#define MAX_INLINE_USER_DEFINED_SELECT_ITEMS       4


/***************************************************************************** 
 * Local Variable
 *****************************************************************************/
static S32 n_inline_user_defined_select_items = 0;
static wgui_inline_item_user_defined_select *current_wgui_inline_user_defined_select_item;
static PU8 *current_wgui_inline_user_defined_select_text_p;


/***************************************************************************** 
 * Function Implementation
 *****************************************************************************/

/*****************************************************************************
 * FUNCTION
 *  inline_user_defined_select_menu_previous_item
 * DESCRIPTION
 *  goto previous item for inline user defined select menu
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void inline_user_defined_select_menu_previous_item(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if(cui_inline_is_current_cui())
    {
        current_wgui_inline_user_defined_select_item->current_text_p = 
        cui_inline_evt_item_user_defined_select_focus_changed(CUI_INLINE_USERDEFINEDSELECT_PRE, (S16)g_cui_inline_current_instance->highlight_item);
    }
    else
    {
        current_wgui_inline_user_defined_select_item->current_text_p =
        current_wgui_inline_user_defined_select_item->previous_item_callback();
    }
    *current_wgui_inline_user_defined_select_text_p = current_wgui_inline_user_defined_select_item->current_text_p;
    wgui_inline_select_items[0].text = (UI_string_type) * current_wgui_inline_user_defined_select_text_p;
    show_inline_user_defined_select_menu();
    set_wgui_inline_list_menu_changed();
}


/*****************************************************************************
 * FUNCTION
 *  inline_user_defined_select_menu_next_item
 * DESCRIPTION
 *  goto next item for inline user defined select menu
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void inline_user_defined_select_menu_next_item(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(cui_inline_is_current_cui())
    {
        current_wgui_inline_user_defined_select_item->current_text_p = 
        cui_inline_evt_item_user_defined_select_focus_changed(CUI_INLINE_USERDEFINEDSELECT_NEXT, (S16)g_cui_inline_current_instance->highlight_item);
    }
    else
    {
        current_wgui_inline_user_defined_select_item->current_text_p =
        current_wgui_inline_user_defined_select_item->next_item_callback();
    }
    *current_wgui_inline_user_defined_select_text_p = current_wgui_inline_user_defined_select_item->current_text_p;
    wgui_inline_select_items[0].text = (UI_string_type) * current_wgui_inline_user_defined_select_text_p;
    show_inline_user_defined_select_menu();
    set_wgui_inline_list_menu_changed();
}


/*****************************************************************************
 * FUNCTION
 *  inline_select_left_arrow_up_handler
 * DESCRIPTION
 *  select left arrow up handler.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void inline_user_defined_selector_left_arrow_up_handler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL change_flag;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    change_flag = gui_horizontal_select_left_key_up_handler(&g_wgui_inline_select_item);
    if(change_flag == MMI_TRUE)
    {
        inline_user_defined_select_menu_previous_item();
    }
    show_inline_user_defined_select_menu();
}


/*****************************************************************************
 * FUNCTION
 *  inline_select_left_arrow_up_handler
 * DESCRIPTION
 *  select left arrow up handler.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void inline_user_defined_selector_left_arrow_down_handler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL change_flag;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    change_flag = gui_horizontal_select_left_key_down_handler(&g_wgui_inline_select_item);
    if(change_flag == MMI_TRUE)
    {
        inline_user_defined_select_menu_previous_item();
    }
    show_inline_user_defined_select_menu();

}

/*****************************************************************************
 * FUNCTION
 *  inline_select_right_arrow_up_handler
 * DESCRIPTION
 *  select left arrow up handler.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void inline_user_defined_selector_right_arrow_down_handler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL change_flag;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    change_flag = gui_horizontal_select_right_key_down_handler(&g_wgui_inline_select_item);
    if(change_flag == MMI_TRUE)
    {
        inline_user_defined_select_menu_next_item();
    }
    show_inline_user_defined_select_menu();
}

/*****************************************************************************
 * FUNCTION
 *  inline_select_right_arrow_up_handler
 * DESCRIPTION
 *  select left arrow up handler.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
 void inline_user_defined_selector_right_arrow_up_handler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL change_flag;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    change_flag = gui_horizontal_select_right_key_up_handler(&g_wgui_inline_select_item);
    if(change_flag == MMI_TRUE)
    {
        inline_user_defined_select_menu_next_item();
    }
    show_inline_user_defined_select_menu();
 }


/*****************************************************************************
 * FUNCTION
 *  inline_user_defined_select_menu_change_complete
 * DESCRIPTION
 *  change complete function of inline user defined select menu
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void inline_user_defined_select_menu_change_complete(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_text_menuitem_reset_scrolling();
    wgui_text_menuitem_reset_scrolling = gui_fixed_icontext_menuitem_stop_scroll;
    wgui_text_menuitem_restart_scrolling = gui_fixed_icontext_menuitem_start_scroll;
    clear_inline_select_menu_keys();
    MMI_fixed_icontext_menuitems[wgui_inline_item_highlighted_index].item_text =
        (UI_string_type) * current_wgui_inline_user_defined_select_text_p;
    redraw_current_inline_item = UI_dummy_function;
#ifdef __MMI_TOUCH_SCREEN__
    wgui_current_inline_item_pen_function = UI_dummy_inline_item_pen_function;
#endif 
    complete_inline_item_edit = UI_dummy_function;
    wgui_inline_item_handled = 0;
    gui_horizontal_select_close(&g_wgui_inline_select_item);
    current_wgui_inline_user_defined_select_item = NULL;
}


/*****************************************************************************
 * FUNCTION
 *  inline_user_defined_select_menu_handle_up_arrow
 * DESCRIPTION
 *  up arrow handler of inline user defined slect menu
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void inline_user_defined_select_menu_handle_up_arrow(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (wgui_inline_edit_is_able_to_switch_highlight(0))
    {
        inline_user_defined_select_menu_change_complete();
        inline_fixed_list_goto_previous_item();
    }
}


/*****************************************************************************
 * FUNCTION
 *  inline_user_defined_select_menu_handle_down_arrow
 * DESCRIPTION
 *  down arrow handler of inline user defined slect menu
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void inline_user_defined_select_menu_handle_down_arrow(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (wgui_inline_edit_is_able_to_switch_highlight(1))
    {
        inline_user_defined_select_menu_change_complete();
        inline_fixed_list_goto_next_item();
    }
}


/*****************************************************************************
 * FUNCTION
 *  inline_user_defined_select_menu_keyboard_key_handler
 * DESCRIPTION
 *  keyboard key handler of inline user defined select menu
 * PARAMETERS
 *  vkey_code       [IN]     key code   
 *  key_state       [IN]     key state   
 * RETURNS
 *  void
 *****************************************************************************/
void inline_user_defined_select_menu_keyboard_key_handler(S32 vkey_code, S32 key_state)
{
#if(MMI_BUILD_TYPE == BUILD_TYPE_X86WIN32)
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (key_state)
    {
        switch (vkey_code)
        {
            case 37:
                inline_user_defined_select_menu_previous_item();
                break;
            case 38:
                inline_user_defined_select_menu_handle_up_arrow();
                break;
            case 39:
                inline_user_defined_select_menu_next_item();
                break;
            case 40:
                inline_user_defined_select_menu_handle_down_arrow();
                break;
        }
    }
#else /* (MMI_BUILD_TYPE == BUILD_TYPE_X86WIN32) */ 
    UI_UNUSED_PARAMETER(vkey_code);
    UI_UNUSED_PARAMETER(key_state);
#endif /* (MMI_BUILD_TYPE == BUILD_TYPE_X86WIN32) */ 
}


/*****************************************************************************
 * FUNCTION
 *  register_inline_user_defined_select_menu_keys
 * DESCRIPTION
 *  register key handlers for inline user defined select menu
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void register_inline_user_defined_select_menu_keys(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    /* key rule. 09.10.17 */
    SetKeyHandler(inline_user_defined_selector_left_arrow_down_handler, KEY_LEFT_ARROW, KEY_EVENT_REPEAT);
    SetKeyHandler(inline_user_defined_selector_right_arrow_down_handler, KEY_RIGHT_ARROW, KEY_EVENT_REPEAT);
    SetKeyHandler(inline_user_defined_select_menu_handle_up_arrow, KEY_UP_ARROW, KEY_EVENT_REPEAT);
    SetKeyHandler(inline_user_defined_select_menu_handle_down_arrow, KEY_DOWN_ARROW, KEY_EVENT_REPEAT);
    SetKeyHandler(inline_user_defined_select_menu_handle_up_arrow, KEY_VOL_UP, KEY_EVENT_REPEAT);
    SetKeyHandler(inline_user_defined_select_menu_handle_down_arrow, KEY_VOL_DOWN, KEY_EVENT_REPEAT);
    
    SetKeyHandler(inline_user_defined_selector_left_arrow_down_handler, KEY_LEFT_ARROW, KEY_EVENT_DOWN);
    SetKeyHandler(inline_user_defined_selector_right_arrow_down_handler, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
    SetKeyHandler(inline_user_defined_select_menu_handle_up_arrow, KEY_UP_ARROW, KEY_EVENT_DOWN);
    SetKeyHandler(inline_user_defined_select_menu_handle_down_arrow, KEY_DOWN_ARROW, KEY_EVENT_DOWN);
    SetKeyHandler(inline_user_defined_select_menu_handle_up_arrow, KEY_VOL_UP, KEY_EVENT_DOWN);
    SetKeyHandler(inline_user_defined_select_menu_handle_down_arrow, KEY_VOL_DOWN, KEY_EVENT_DOWN);
    register_keyboard_key_handler(inline_user_defined_select_menu_keyboard_key_handler);

    SetKeyHandler(inline_user_defined_selector_left_arrow_up_handler, KEY_LEFT_ARROW, KEY_EVENT_UP);
    SetKeyHandler(inline_user_defined_selector_right_arrow_up_handler, KEY_RIGHT_ARROW, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  redraw_inline_user_defined_select
 * DESCRIPTION
 *  redraw inline user defined select
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void redraw_inline_user_defined_select(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    show_inline_user_defined_select_menu();
}

#ifdef __MMI_TOUCH_SCREEN__


/*****************************************************************************
 * FUNCTION
 *  inline_user_defined_select_pen_handler
 * DESCRIPTION
 *  pen handler for inline user defined select
 * PARAMETERS
 *  pen_event       [IN]        pen event
 *  x               [IN]        pen x position
 *  y               [IN]        pen y position
 *  item_event      [IN]        inline pen enum         
 * RETURNS
 *  BOOL
 *****************************************************************************/
BOOL inline_user_defined_select_pen_handler(
        mmi_pen_event_type_enum pen_event,
        S16 x,
        S16 y,
        gui_inline_item_pen_enum *item_event)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    BOOL ret;
    gui_horizontal_select_pen_enum select_event;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ret = gui_horizontal_select_translate_pen_event(&g_wgui_inline_select_item, pen_event, x, y, &select_event);

    if (ret)
    {
        switch (select_event)
        {
            case GUI_HORIZONTAL_SELECT_PEN_NONE:
                /* Do nothing */
                break;
            case GUI_HORIZONTAL_SELECT_PEN_PREV:
                inline_user_defined_select_menu_previous_item();
                break;
            case GUI_HORIZONTAL_SELECT_PEN_NEXT:
                inline_user_defined_select_menu_next_item();
                break;
            default:
                MMI_ASSERT(0);
        }
    }

    *item_event = GUI_INLINE_ITEM_PEN_NONE;
    return ret;
}

#endif /* __MMI_TOUCH_SCREEN__ */ 


/*****************************************************************************
 * FUNCTION
 *  handle_inline_user_defined_select
 * DESCRIPTION
 *  activation function of inline user defined select
 * PARAMETERS
 *  x                   [IN]        left corner's x coordinate
 *  y                   [IN]        left corner's y coordinate
 *  width               [IN]        width
 *  height              [IN]        height
 *  key_code            [IN]        key code
 *  key_event           [IN]        key event
 *  text_p              [IN]        text pointer
 *  item                [IN]        inline item
 *  flags               [IN]        flags
 *  history_buffer      [IN]        history buffer           
 * RETURNS
 *  void
 *****************************************************************************/
void handle_inline_user_defined_select(
        S32 x,
        S32 y,
        S32 width,
        S32 height,
        S32 key_code,
        S32 key_event,
        U8 **text_p,
        void *item,
        U32 flags,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_inline_item_user_defined_select *i = (wgui_inline_item_user_defined_select*) item;
#ifndef __MMI_FTE_SUPPORT__
    S32 xx;
#endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(key_event);
    UI_UNUSED_PARAMETER(key_code);
    UI_UNUSED_PARAMETER(flags);

#ifdef __MMI_FTE_SUPPORT__
    if(current_wgui_inline_user_defined_select_item != NULL)
    {
	gui_horizontal_select_close(&g_wgui_inline_select_item); 
    }
#endif

    redraw_current_inline_item = UI_dummy_function;
#ifndef __MMI_FTE_SUPPORT__
    if (!mmi_fe_get_r2l_state())
    {
        if (MMI_fixed_icontext_menuitem.text_x == 2)
        {
            xx = -1;
        }
        else
        {
            xx = MMI_fixed_icontext_menuitem.text_x;
        }
    }
    else
    {
        xx = 1;
    }

    if (flags & INLINE_ITEM_LEFT_ALIGN)
    {
        xx = -1;
    }
#endif
    clear_inline_item_keys = clear_inline_select_menu_keys;
    current_wgui_inline_user_defined_select_item = i;
    current_wgui_inline_user_defined_select_text_p = text_p;

#ifdef __MMI_FTE_SUPPORT__
        initialize_inline_user_defined_select_menu_items(x, y, width, height, i->current_text_p);
        g_wgui_inline_select_item.flags |= UI_HORIZONTAL_SELECT_FOCUSED_STATE;
#else   
    if (!mmi_fe_get_r2l_state())
        initialize_inline_user_defined_select_menu_items(x + xx, y, width - xx, height, i->current_text_p);
    else
    {
        if (flags & INLINE_ITEM_LEFT_ALIGN)
            initialize_inline_user_defined_select_menu_items(x + xx, y, width - 1 - xx, height, i->current_text_p);
        else
            initialize_inline_user_defined_select_menu_items(x + xx, y, width - 1 - MMI_fixed_icontext_menuitem.text_x, height, i->current_text_p);
    }
#endif    
    show_inline_user_defined_select_menu();
    register_inline_user_defined_select_menu_keys();
    redraw_current_inline_item = redraw_inline_user_defined_select;
    complete_inline_item_edit = inline_user_defined_select_menu_change_complete;
#ifdef __MMI_TOUCH_SCREEN__
    wgui_current_inline_item_pen_function = inline_user_defined_select_pen_handler;
#endif 
}


/*****************************************************************************
 * FUNCTION
 *  dummy_inline_item_user_defined_select_callback
 * DESCRIPTION
 *  dummy callback for inine user defined select
 * PARAMETERS
 *  void
 * RETURNS
 *  U8 *
 *****************************************************************************/
U8 *dummy_inline_item_user_defined_select_callback(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return (NULL);
}


/*****************************************************************************
 * FUNCTION
 *  SetInlineItemUserDefinedSelect_ext
 * DESCRIPTION
 *  set data for inline user defined select
 * PARAMETERS
 *  item                        [IN]    inline item         
 *  current_item_callback       [IN]    current item callback function    
 *  previous_item_callback      [IN]    previous item callback function    
 *  next_item_callback          [IN]    next item callback function    
 * RETURNS
 *  void
 *****************************************************************************/
void SetInlineItemUserDefinedSelect_ext(
        InlineItem *item,
        S16 item_index,
        U8 *(*current_item_callback) (void),
        U8 *(*previous_item_callback) (void),
        U8 *(*next_item_callback) (void))
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_inline_item_user_defined_select *i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (n_inline_user_defined_select_items >= MAX_INLINE_USER_DEFINED_SELECT_ITEMS)
    {
        return;
    }
    wgui_inline_mem_alloc_info[wgui_inline_mem_alloc_number] = item->item = wgui_inline_malloc(sizeof(wgui_inline_item_user_defined_select));
    wgui_inline_mem_alloc_number++; 
    item->flags = INLINE_ITEM_TYPE_USER_DEFINED_SELECT;
    n_inline_user_defined_select_items++;
    i = (wgui_inline_item_user_defined_select*) item->item;
    i->flags = 0;
    if (current_item_callback == NULL)
    {
        i->current_item_callback = dummy_inline_item_user_defined_select_callback;
    }
    else
    {
        i->current_item_callback = current_item_callback;
    }
    if (previous_item_callback == NULL)
    {
        i->previous_item_callback = dummy_inline_item_user_defined_select_callback;
    }
    else
    {
        i->previous_item_callback = previous_item_callback;
    }
    if (next_item_callback == NULL)
    {
        i->next_item_callback = dummy_inline_item_user_defined_select_callback;
    }
    else
    {
        i->next_item_callback = next_item_callback;
    }
    
    if(cui_inline_is_current_cui())
    {
        if(item_index != -1)
        {
            i->current_text_p = cui_inline_evt_item_user_defined_select_focus_changed(CUI_INLINE_USERDEFINEDSELECT_CUR, (S16)item_index); 
        }        
    }
    else
    {
        if(current_item_callback != NULL)
        {
           i->current_text_p = current_item_callback();
        }
    } 
    item->text_p = i->current_text_p;
    item->handler = handle_inline_user_defined_select;
}


/*****************************************************************************
 * FUNCTION
 *  ReConfigureInlineItemUserDefinedSelect
 * DESCRIPTION
 *  re-configure inline user defined select
 * PARAMETERS
 *  item                        [IN]    inline item         
 *  current_item_callback       [IN]    current item callback function    
 *  previous_item_callback      [IN]    previous item callback function    
 *  next_item_callback          [IN]    next item callback function        
 * RETURNS
 *  void
 *****************************************************************************/
void ReConfigureInlineItemUserDefinedSelect_ext(
        InlineItem *item,
        S16 item_index,
        U8 *(*current_item_callback) (void),
        U8 *(*previous_item_callback) (void),
        U8 *(*next_item_callback) (void))
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_inline_item_user_defined_select *i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if ((item->flags & 0xff) != INLINE_ITEM_TYPE_USER_DEFINED_SELECT)
    {
        return;
    }
    i = (wgui_inline_item_user_defined_select*) item->item;
    i->flags = 0;
    if (current_item_callback == NULL)
    {
        i->current_item_callback = dummy_inline_item_user_defined_select_callback;
    }
    else
    {
        i->current_item_callback = current_item_callback;
    }
    if (previous_item_callback == NULL)
    {
        i->previous_item_callback = dummy_inline_item_user_defined_select_callback;
    }
    else
    {
        i->previous_item_callback = previous_item_callback;
    }
    if (next_item_callback == NULL)
    {
        i->next_item_callback = dummy_inline_item_user_defined_select_callback;
    }
    else
    {
        i->next_item_callback = next_item_callback;
    }
    if(cui_inline_is_current_cui())
    {
        if(item_index != -1)
        {
            i->current_text_p = cui_inline_evt_item_user_defined_select_focus_changed(CUI_INLINE_USERDEFINEDSELECT_CUR, (S16)item_index); 
        }        
    }
    else
    {
    if(current_item_callback != NULL)
    {
    i->current_text_p = current_item_callback();
    }
    } 

    item->text_p = i->current_text_p;

}


#ifdef __MMI_INLINE_ITEM_DOW__
/***************************************************************************** 
 * Inline Day Of Week Select    
 *
 * This is Inline Day Of Week Select Item
 *****************************************************************************/

/***************************************************************************** 
 * Define
 *****************************************************************************/
#define MAX_INLINE_DOW_SELECT_ITEMS       2


/***************************************************************************** 
 * Typedef 
 *****************************************************************************/ 
typedef struct _inline_DOW_select_history
{
    U16 history_ID;
    S16 highlight_index;
    U32 flags;
} inline_DOW_select_history;


/***************************************************************************** 
 * Local Variable
 *****************************************************************************/
static S32 n_inline_DOW_items = 0;
static PU8 current_wgui_inline_DOW_states = NULL;
static PU8 *current_wgui_inline_DOW_text_p = NULL;
DOW_select MMI_inline_DOW_select;

/***************************************************************************** 
 * Function Implementation
 *****************************************************************************/

/*****************************************************************************
 * FUNCTION
 *  clear_inline_DOW_select_keys
 * DESCRIPTION
 *  clear key handlers for inline DOW select
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void clear_inline_DOW_select_keys(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    /* key rule. 09.10.17 */
    ClearKeyHandler(KEY_LEFT_ARROW, KEY_EVENT_REPEAT);
    ClearKeyHandler(KEY_RIGHT_ARROW, KEY_EVENT_REPEAT);
    ClearKeyHandler(KEY_LEFT_ARROW, KEY_EVENT_DOWN);
    ClearKeyHandler(KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
    clear_keyboard_key_handler();
    clear_inline_item_keys = UI_dummy_function;
}


/*****************************************************************************
 * FUNCTION
 *  inline_DOW_select_change_complete
 * DESCRIPTION
 *  change complete function for inline DOW select
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void inline_DOW_select_change_complete(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    clear_inline_DOW_select_keys();
    *current_wgui_inline_DOW_text_p = (U8*) "";
    MMI_fixed_icontext_menuitems[wgui_inline_item_highlighted_index].item_text = (UI_string_type) "";
    for (i = 0; i < 7; i++)
    {
        current_wgui_inline_DOW_states[i] = MMI_inline_DOW_select.states[i];
    }
    redraw_current_inline_item = UI_dummy_function;
    complete_inline_item_edit = UI_dummy_function;
#ifdef __MMI_TOUCH_SCREEN__
    wgui_current_inline_item_pen_function = UI_dummy_inline_item_pen_function;
#endif 
    clear_left_softkey();
    clear_right_softkey();
    wgui_inline_item_handled = 0;
}


/*****************************************************************************
 * FUNCTION
 *  inline_DOW_select_handle_up_arrow
 * DESCRIPTION
 *  up arrow handler of inline DOW select
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void inline_DOW_select_handle_up_arrow(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    inline_DOW_select_change_complete();
    inline_fixed_list_goto_previous_item();
}


/*****************************************************************************
 * FUNCTION
 *  inline_DOW_select_handle_down_arrow
 * DESCRIPTION
 *  down arrow handler of inline DOW select
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void inline_DOW_select_handle_down_arrow(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    inline_DOW_select_change_complete();
    inline_fixed_list_goto_next_item();
}


/*****************************************************************************
 * FUNCTION
 *  show_inline_DOW_select
 * DESCRIPTION
 *  show inline DOW select
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void show_inline_DOW_select(DOW_select *b)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    /* don't call the function to show background from here, call it from the
       function, which is calling this function, in case of default text effect
       is enabled. */
#ifdef __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__
    if (!(IsInlineItemDefaultTextEnable()))
#endif 

        show_DOW_select_background(b);
    show_DOW_select(b);
    // chnage by Leo, code revise. BLT_DOW_select(&MMI_inline_DOW_select);
    gdi_layer_blt_previous(
        b->x,
        b->y,
        b->x + b->width - 1,
        b->y + b->height - 1);
}


/*****************************************************************************
 * FUNCTION
 *  handle_inline_DOW_select_LSK_display
 * DESCRIPTION
 *  LSK display handler of inline DOW select
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void handle_inline_DOW_select_LSK_display(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (MMI_inline_DOW_select.states[MMI_inline_DOW_select.highlighted_cell])
    {
        set_left_softkey_label(get_string(STR_GLOBAL_OFF));
    }
    else
    {
        set_left_softkey_label(get_string(WGUI_CATEGORY_ON_STRING_ID));
    }
    redraw_left_softkey();
}


/*****************************************************************************
 * FUNCTION
 *  handle_inline_DOW_select_LSK_up
 * DESCRIPTION
 *  LSK up handler of inline DOW select
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void handle_inline_DOW_select_LSK_up(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    DOW_select_toggle_item(&MMI_inline_DOW_select);

#ifdef __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__
    if (IsInlineItemDefaultTextEnable())
    {
        show_DOW_select_background(&MMI_inline_DOW_select);
    }
#endif /* __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__ */ 

    show_inline_DOW_select(&MMI_inline_DOW_select);
    handle_inline_DOW_select_LSK_display();
    set_wgui_inline_list_menu_changed();
}


/*****************************************************************************
 * FUNCTION
 *  inline_DOW_select_previous_item
 * DESCRIPTION
 *  goto previous item for inline DOW select
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void inline_DOW_select_previous_item(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    DOW_select_previous(&MMI_inline_DOW_select);

#ifdef __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__
    if (IsInlineItemDefaultTextEnable())
    {
        show_DOW_select_background(&MMI_inline_DOW_select);
    }
#endif /* __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__ */ 

    show_inline_DOW_select(&MMI_inline_DOW_select);
    handle_inline_DOW_select_LSK_display();
}


/*****************************************************************************
 * FUNCTION
 *  inline_DOW_select_next_item
 * DESCRIPTION
 *  goto next item for inline DOW select
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void inline_DOW_select_next_item(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    DOW_select_next(&MMI_inline_DOW_select);

#ifdef __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__
    if (IsInlineItemDefaultTextEnable())
    {
        show_DOW_select_background(&MMI_inline_DOW_select);
    }
#endif /* __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__ */ 

    show_inline_DOW_select(&MMI_inline_DOW_select);
    handle_inline_DOW_select_LSK_display();
}


/*****************************************************************************
 * FUNCTION
 *  inline_DOW_select_keyboard_key_handler
 * DESCRIPTION
 *  keyboard key handler of inline DOW select
 * PARAMETERS
 *  vkey_code       [IN]       key code 
 *  key_state       [IN]       key state 
 * RETURNS
 *  void
 *****************************************************************************/
void inline_DOW_select_keyboard_key_handler(S32 vkey_code, S32 key_state)
{
#if(MMI_BUILD_TYPE == BUILD_TYPE_X86WIN32)
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (key_state)
    {
        switch (vkey_code)
        {
            case 37:
                inline_DOW_select_previous_item();
                break;
            case 38:
                inline_DOW_select_handle_up_arrow();
                break;
            case 39:
                inline_DOW_select_next_item();
                break;
            case 40:
                inline_DOW_select_handle_down_arrow();
                break;
        }
    }
#else /* (MMI_BUILD_TYPE == BUILD_TYPE_X86WIN32) */ 
    UI_UNUSED_PARAMETER(vkey_code);
    UI_UNUSED_PARAMETER(key_state);
#endif /* (MMI_BUILD_TYPE == BUILD_TYPE_X86WIN32) */ 
}


/*****************************************************************************
 * FUNCTION
 *  register_inline_DOW_select_keys
 * DESCRIPTION
 *  register key handlers of inline DOW select
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void register_inline_DOW_select_keys(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

     /* key rule. 09.10.17 */
    SetKeyHandler(inline_DOW_select_previous_item, KEY_LEFT_ARROW, KEY_EVENT_REPEAT);
    SetKeyHandler(inline_DOW_select_next_item, KEY_RIGHT_ARROW, KEY_EVENT_REPEAT);
    SetKeyHandler(inline_DOW_select_handle_up_arrow, KEY_UP_ARROW, KEY_EVENT_REPEAT);
    SetKeyHandler(inline_DOW_select_handle_down_arrow, KEY_DOWN_ARROW, KEY_EVENT_REPEAT);
    SetKeyHandler(inline_DOW_select_handle_up_arrow, KEY_VOL_UP, KEY_EVENT_REPEAT);
    SetKeyHandler(inline_DOW_select_handle_down_arrow, KEY_VOL_DOWN, KEY_EVENT_REPEAT);
    
    SetKeyHandler(inline_DOW_select_previous_item, KEY_LEFT_ARROW, KEY_EVENT_DOWN);
    SetKeyHandler(inline_DOW_select_next_item, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
    SetKeyHandler(inline_DOW_select_handle_up_arrow, KEY_UP_ARROW, KEY_EVENT_DOWN);
    SetKeyHandler(inline_DOW_select_handle_down_arrow, KEY_DOWN_ARROW, KEY_EVENT_DOWN);
    SetKeyHandler(inline_DOW_select_handle_up_arrow, KEY_VOL_UP, KEY_EVENT_DOWN);
    SetKeyHandler(inline_DOW_select_handle_down_arrow, KEY_VOL_DOWN, KEY_EVENT_DOWN);
    register_keyboard_key_handler(inline_DOW_select_keyboard_key_handler);
}


/*****************************************************************************
 * FUNCTION
 *  redraw_inline_DOW_select
 * DESCRIPTION
 *  redraw inline DOW select
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void redraw_inline_DOW_select(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

#ifdef __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__
    if (IsInlineItemDefaultTextEnable())
    {
        show_DOW_select_background(&MMI_inline_DOW_select);
    }
#endif /* __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__ */ 

    show_inline_DOW_select(&MMI_inline_DOW_select);
}


/*****************************************************************************
 * FUNCTION
 *  inline_DOW_select_get_history
 * DESCRIPTION
 *  get history buffer of inline DOW select
 * PARAMETERS
 *  history_buffer      [OUT]   history buffer     
 * RETURNS
 *  history buffer
 *****************************************************************************/
U8 *inline_DOW_select_get_history(U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (history_buffer != NULL)
    {
        U16 hID = (U16) (INLINE_DOW_SELECT_HISTORY_ID | 0x8000);
        inline_DOW_select_history *h = (inline_DOW_select_history*) history_buffer;

        h->history_ID = hID;
        h->highlight_index = (S16) MMI_inline_DOW_select.highlighted_cell;
        h->flags = MMI_inline_DOW_select.flags;
    }
    return (history_buffer);
}


/*****************************************************************************
 * FUNCTION
 *  inline_DOW_select_set_history
 * DESCRIPTION
 *  set history buffer into MMI_inline_DOW_select 
 * PARAMETERS
 *  history_ID          [IN]   history id     
 *  history_buffer      [IN]   history buffer         
 * RETURNS
 *  1->success 0->fail
 *****************************************************************************/
U8 inline_DOW_select_set_history(U16 history_ID, U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (history_buffer != NULL)
    {
        inline_DOW_select_history *h = (inline_DOW_select_history*) history_buffer;

        if (history_valid(h->history_ID, history_ID))
        {
            MMI_inline_DOW_select.flags = h->flags;
            MMI_inline_DOW_select.highlighted_cell = (U8) h->highlight_index;
            return (1);
        }
    }
    return (0);
}


/*****************************************************************************
 * FUNCTION
 *  initialize_inline_DOW_select
 * DESCRIPTION
 *  initialize inline DOW select
 * PARAMETERS
 *  x                   [IN]       left-top x coordinate 
 *  y                   [IN]       left-top y coordinate 
 *  width               [IN]       width 
 *  height              [IN]       height 
 *  list_of_states      [IN]       list of states  
 *  history_buffer      [IN]       history buffer  
 * RETURNS
 *  void
 *****************************************************************************/
void initialize_inline_DOW_select(DOW_select *b, S32 x, S32 y, S32 width, S32 height, U8 *list_of_states, U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    create_DOW_select(b, x, y, width, height);
    for (i = 0; i < 7; i++)
    {
        b->states[i] = list_of_states[i];
    }
    current_wgui_inline_DOW_states = list_of_states;
    
    if(cui_inline_is_current_cui())
    {
        cui_inline_item_replace_gui_buffer(wgui_inline_item_highlighted_index, &wgui_inline_items[wgui_inline_item_highlighted_index], &history_buffer);
    }
    else
    {
        inline_DOW_select_set_history(INLINE_DOW_SELECT_HISTORY_ID, history_buffer);
    }

}


#ifdef __MMI_TOUCH_SCREEN__
/*****************************************************************************
 * FUNCTION
 *  inline_DOW_select_pen_handler
 * DESCRIPTION
 *  pen handler of inline DOW select
 * PARAMETERS
 *  pen_event       [IN]        pen event
 *  x               [IN]        pen x position
 *  y               [IN]        pen y pisition
 *  item_event      [IN]         inline pen enum
 * RETURNS
 *  BOOL
 *****************************************************************************/
BOOL inline_DOW_select_pen_handler(
        mmi_pen_event_type_enum pen_event,
        S16 x,
        S16 y,
        gui_inline_item_pen_enum *item_event)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    BOOL ret;
    DOW_pen_event_enum DOW_event;
    gui_pen_event_param_struct DOW_param;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ret = DOW_translate_pen_event(&MMI_inline_DOW_select, pen_event, x, y, &DOW_event, &DOW_param);

    if (ret)
    {
        switch (DOW_event)
        {
            case DOW_PEN_CHANGE_HIGHLIGHT_AND_TOGGLE_I:
                DOW_select_highlight_item(&MMI_inline_DOW_select, DOW_param._u.i);
                /* FALLTHROUGH no break */
            case DOW_PEN_TOGGLE_CURRENT_ITEM:
                DOW_select_toggle_item(&MMI_inline_DOW_select);

        #ifdef __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__
                if (IsInlineItemDefaultTextEnable())
                {
                    show_DOW_select_background(&MMI_inline_DOW_select);
                }
        #endif /* __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__ */ 

                show_inline_DOW_select(&MMI_inline_DOW_select);
                handle_inline_DOW_select_LSK_display();
                set_wgui_inline_list_menu_changed();
                break;
            case DOW_PEN_NONE:
                /* Do nothing */
                break;
            default:
                MMI_ASSERT(0);
        }
    }

    *item_event = GUI_INLINE_ITEM_PEN_NONE;
    return ret;
}

#endif /* __MMI_TOUCH_SCREEN__ */ 


/*****************************************************************************
 * FUNCTION
 *  handle_inline_DOW_select
 * DESCRIPTION
 *  activation function of inline DOW select
 * PARAMETERS
 *  x                   [IN]        left corner's x coordinate
 *  y                   [IN]        left corner's y coordinate
 *  width               [IN]        width
 *  height              [IN]        height
 *  key_code            [IN]        key code
 *  key_event           [IN]        key event
 *  text_p              [IN]        text pointer
 *  item                [IN]        inline item
 *  flags               [IN]        flags
 *  history_buffer      [IN]        history buffer        
 * RETURNS
 *  void
 *****************************************************************************/
void handle_inline_DOW_select(
        S32 x,
        S32 y,
        S32 width,
        S32 height,
        S32 key_code,
        S32 key_event,
        U8 **text_p,
        void *item,
        U32 flags,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_inline_item_DOW_select *i = (wgui_inline_item_DOW_select*) item;
#ifndef __MMI_FTE_SUPPORT__
    S32 xx;
#endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(key_event);
    UI_UNUSED_PARAMETER(key_code);
    UI_UNUSED_PARAMETER(flags);
    wgui_current_inline_item_type = INLINE_ITEM_TYPE_DOW_SELECT;
#ifndef __MMI_FTE_SUPPORT__
    if (MMI_fixed_icontext_menuitem.text_x == 2)
    {
        xx = -1;
    }
    else
    {
        xx = MMI_fixed_icontext_menuitem.text_x;
    }
    if (flags & INLINE_ITEM_LEFT_ALIGN)
    {
        xx = -1;
    }
#endif
    clear_inline_item_keys = clear_inline_DOW_select_keys;
    current_wgui_inline_DOW_text_p = text_p;


#ifdef __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__
    if (IsInlineItemDefaultTextEnable())
    {
        initialize_inline_DOW_select(&MMI_inline_DOW_select, x, y, width, height, i->list_of_states, history_buffer);
    }
    else
#endif /* __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__ */ 

#ifdef __MMI_FTE_SUPPORT__
        initialize_inline_DOW_select(&MMI_inline_DOW_select, x, y, width, height, i->list_of_states, history_buffer);
        set_DOW_select_flags(&MMI_inline_DOW_select, DOW_SELECT_STATE_FOCUSED);   
        MMI_inline_DOW_select.flags |= DOW_SELECT_USE_PRESET_CLIP;
#else
        initialize_inline_DOW_select(&MMI_inline_DOW_select, x + xx, y, width - xx, height, i->list_of_states, history_buffer);
#endif

#ifdef __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__
    if (IsInlineItemDefaultTextEnable())
    {
        show_DOW_select_background(&MMI_inline_DOW_select);
    }
#endif /* __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__ */ 

#ifdef __MMI_FTE_SUPPORT__
    /* When SSP, it will call DOW complete function which will reset softkey function; but it will not
    call default_highlight_handler(), so we must call register_default_hide_softkey() by DOW self.*/
    register_default_hide_softkeys();
#endif

    handle_inline_DOW_select_LSK_display();
    
    register_left_softkey_handler();
    set_left_softkey_function(handle_inline_DOW_select_LSK_up, KEY_EVENT_UP);
    set_right_softkey_label(wgui_inline_edit_get_RSK_string());
    register_right_softkey_handler();
    set_right_softkey_function(execute_wgui_inline_edit_RSK_function, KEY_EVENT_UP);

    show_inline_DOW_select(&MMI_inline_DOW_select);
    register_inline_DOW_select_keys();
    complete_inline_item_edit = inline_DOW_select_change_complete;
    redraw_current_inline_item = redraw_inline_DOW_select;
#ifdef __MMI_TOUCH_SCREEN__
    wgui_current_inline_item_pen_function = inline_DOW_select_pen_handler;
#endif 

}


/*****************************************************************************
 * FUNCTION
 *  SetInlineItemDOWSelect
 * DESCRIPTION
 *  set data for inline DOW select
 * PARAMETERS
 *  item                [IN]    inline item         
 *  item_index          [IN]    item index    
 *  list_of_states      [IN]    list of states     
 * RETURNS
 *  void
 *****************************************************************************/
void SetInlineItemDOWSelect(InlineItem *item, S32 item_index, U8 *list_of_states)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_inline_item_DOW_select *i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (n_inline_DOW_items >= MAX_INLINE_DOW_SELECT_ITEMS)
    {
        return;
    }

    wgui_inline_mem_alloc_info[wgui_inline_mem_alloc_number] = item->item = wgui_inline_malloc(sizeof(wgui_inline_item_DOW_select));
    wgui_inline_mem_alloc_number++; 
    item->flags = INLINE_ITEM_TYPE_DOW_SELECT;
    n_inline_DOW_items++;
    i = (wgui_inline_item_DOW_select*) item->item;
    i->flags = 0;
    i->list_of_states = list_of_states;
    item->handler = handle_inline_DOW_select;
    MMI_fixed_icontext_menuitems[item_index].flags |= UI_MENUITEM_INLINE_EDIT_OBJECT;
}


/*****************************************************************************
 * FUNCTION
 *  ReConfigureInlineItemDOWSelect
 * DESCRIPTION
 *  re-configure inline DOW select
 * PARAMETERS
 *  item                [IN]    inline item         
 *  item_index          [IN]    item index    
 *  list_of_states      [IN]    list of states           
 * RETURNS
 *  void
 *****************************************************************************/
void ReConfigureInlineItemDOWSelect(InlineItem *item, S32 item_index, U8 *list_of_states)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_inline_item_DOW_select *i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if ((item->flags & 0xff) != INLINE_ITEM_TYPE_DOW_SELECT)
    {
        return;
    }
    i = (wgui_inline_item_DOW_select*) item->item;
    i->flags = 0;
    i->list_of_states = list_of_states;
}

/* Displaying DOW select as a menu item in the fixed list menu */


/*****************************************************************************
 * FUNCTION
 *  wgui_show_DOW_list_menuitem
 * DESCRIPTION
 *  show DOW list menuitem
 * PARAMETERS
 *  x1          [IN]  the left-top corner x1 coordinate      
 *  y1          [IN]  the left-top corner y1 coordinate      
 *  width       [IN]  width      
 *  height      [IN]  height      
 *  item        [IN]   inline item          
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_show_DOW_list_menuitem(S32 x1, S32 y1, S32 width, S32 height, wgui_inline_item *item)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#ifndef __MMI_FTE_SUPPORT__
    S32 xx;
#endif
    wgui_inline_item_DOW_select *i = (wgui_inline_item_DOW_select*) item->item;
    DOW_select inline_dow_select_display = {0};

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifndef __MMI_FTE_SUPPORT__
    if (MMI_fixed_icontext_menuitem.text_x == 2)
    {
        xx = -1;
    }
    else
    {
        xx = MMI_fixed_icontext_menuitem.text_x;
    }
    if (i->flags & INLINE_ITEM_LEFT_ALIGN)
    {
        xx = -1;
    }
#endif
    gdi_layer_lock_frame_buffer();

#ifdef __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__
    if (IsInlineItemDefaultTextEnable())
    {
        initialize_inline_DOW_select(&inline_dow_select_display, x1, y1, width, height, i->list_of_states, NULL);
    }
    else
#endif /* __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__ */ 

#ifdef __MMI_FTE_SUPPORT__
    initialize_inline_DOW_select(&inline_dow_select_display, x1, y1, width, height, i->list_of_states, NULL);
/*
    if((item->flags & INLINE_ITEM_DISABLED) != 0)
    {
        set_DOW_select_flags(&inline_dow_select_display, DOW_SELECT_STATE_DISABLED);  
    }
    else
*/    
    {
       set_DOW_select_flags(&inline_dow_select_display, DOW_SELECT_STATE_NORMAL);   
    }   
#else
        initialize_inline_DOW_select(&inline_dow_select_display, x1 + xx, y1, width - xx, height, i->list_of_states, NULL);
#endif

    inline_dow_select_display.flags |= DOW_SELECT_USE_PRESET_CLIP;

    set_DOW_select_list_menu_theme(&inline_dow_select_display);

#ifdef __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__
    if (IsInlineItemDefaultTextEnable())
    {
        inline_item_default_text_show_background((x1 - 1), y1, (x1 - 1) + (width - 1), y1 + height - 1);
    }
#endif /* __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__ */ 
   
    show_inline_DOW_select(&inline_dow_select_display);
    gdi_layer_unlock_frame_buffer();
}

#endif

#if defined (__MMI_INLINE_ITEM_TIME_PEROID__)
/***************************************************************************** 
 * Inline Time Period Edit    
 *
 * This is Inline Time Period Edit Item
 *****************************************************************************/

/***************************************************************************** 
 * Define
 *****************************************************************************/
#define MAX_INLINE_TIME_PERIOD_ITEMS                        2
#define MAX_INLINE_TIME_PERIOD_DISPLAY_STRING_SIZE          32

/***************************************************************************** 
 * Typedef 
 *****************************************************************************/  
typedef struct _inline_time_period_edit_history
{
    U16 history_ID;
    S16 current_focus;
    S16 current_position;
    S16 dummy;  /* Added for history issue on hardware */
    U32 flags;
    mmi_imc_history ime_history;
} inline_time_period_edit_history;


/***************************************************************************** 
 * Local Variable
 *****************************************************************************/
static S32 n_inline_time_period_items = 0;
static wgui_inline_item_time_period *current_wgui_inline_time_period_item;
static PU8 *current_wgui_inline_time_period_text_p;

time_period_input wgui_inline_time_period_input;

/* Displaying time period edit as a menu item in the fixed list menu */

//time_period_input wgui_inline_time_period_input_display;

/***************************************************************************** 
 * Extern Global Variable
 *****************************************************************************/
extern UI_filled_area time_period_input_background_filler;


/***************************************************************************** 
 * Function Implementation
 *****************************************************************************/

/*****************************************************************************
 * FUNCTION
 *  handle_inline_time_period_edit_complete
 * DESCRIPTION
 *  complete function of inline time period edit
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void handle_inline_time_period_edit_complete(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    register_inline_fixed_list_keys();

    current_wgui_inline_time_period_item->string_construct_callback(
                                            *current_wgui_inline_time_period_text_p,
                                            current_wgui_inline_time_period_item->hours_buffer1,
                                            current_wgui_inline_time_period_item-> minutes_buffer1,
                                            current_wgui_inline_time_period_item->AM_PM_flag1,
                                            current_wgui_inline_time_period_item->hours_buffer2,
                                            current_wgui_inline_time_period_item-> minutes_buffer2,
                                            current_wgui_inline_time_period_item->AM_PM_flag2);
    MMI_fixed_icontext_menuitems[wgui_inline_item_highlighted_index].item_text =
        (UI_string_type) * current_wgui_inline_time_period_text_p;
    clear_left_softkey();
    clear_right_softkey();
    register_left_softkey_handler();
    register_right_softkey_handler();

    wgui_inline_item_handled = 0;
    wgui_text_menuitem_restart_scrolling();
    redraw_current_inline_item = UI_dummy_function;
    complete_inline_item_edit = UI_dummy_function;
    set_current_time_period_input(NULL);
    clear_time_period_input_callback();
    mmi_imc_disconnect();
    g_inline_current_input_box_handler = NULL;
}


/*****************************************************************************
 * FUNCTION
 *  redraw_inline_time_period_edit
 * DESCRIPTION
 *  redraw inine time period edit
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void redraw_inline_time_period_edit(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    time_period_input_show_background(&wgui_inline_time_period_input);
    show_time_period_input(&wgui_inline_time_period_input);
}


/*****************************************************************************
 * FUNCTION
 *  inline_time_period_edit_handle_down_arrow
 * DESCRIPTION
 *  down arrow handler of inline time period edit
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void inline_time_period_edit_handle_down_arrow(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_FTE_SUPPORT__    
    wgui_inline_get_vk_status(&g_inline_vk_status);
#endif
    handle_inline_time_period_edit_complete();
    inline_fixed_list_goto_next_item();
}


/*****************************************************************************
 * FUNCTION
 *  inline_time_period_edit_handle_up_arrow
 * DESCRIPTION
 *  up arrow handler of inline time period edit
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void inline_time_period_edit_handle_up_arrow(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_FTE_SUPPORT__    
    wgui_inline_get_vk_status(&g_inline_vk_status);
#endif
    handle_inline_time_period_edit_complete();
    inline_fixed_list_goto_previous_item();
}


/*****************************************************************************
 * FUNCTION
 *  inline_time_period_input_key_handler
 * DESCRIPTION
 *  input key handler of inline time period for PC
 * PARAMETERS
 *  vkey_code       [IN]    key code    
 *  key_state       [IN]    key state    
 * RETURNS
 *  void
 *****************************************************************************/
void inline_time_period_input_key_handler(S32 vkey_code, S32 key_state)
{
#if(MMI_BUILD_TYPE == BUILD_TYPE_X86WIN32)
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (key_state)
    {
        switch (vkey_code)
        {
            case 37:
                time_period_input_previous_character();
                break;
            case 38:
                inline_time_period_edit_handle_up_arrow();
                break;
            case 39:
                time_period_input_next_character();
                break;
            case 40:
                inline_time_period_edit_handle_down_arrow();
                break;
            case 36:    /* home */
                break;
            case 35:    /* end */
                break;
            case 33:    /* page up */
                break;
            case 34:    /* page down */
                break;
            case 45:
                time_period_input_toggle_insert_mode();
                break;
            case 46:
                time_period_input_delete_current_character();
                break;
        }
    }
#else /* (MMI_BUILD_TYPE == BUILD_TYPE_X86WIN32) */ 
    UI_UNUSED_PARAMETER(vkey_code);
    UI_UNUSED_PARAMETER(key_state);
#endif /* (MMI_BUILD_TYPE == BUILD_TYPE_X86WIN32) */ 
}


/*****************************************************************************
 * FUNCTION
 *  inline_time_period_edit_get_history
 * DESCRIPTION
 *  get history buffer of inline time period edit
 * PARAMETERS
 *  history_buffer      [OUT]   history buffer     
 * RETURNS
 *  History buffer
 *****************************************************************************/
U8 *inline_time_period_edit_get_history(U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (history_buffer != NULL)
    {
        U16 hID = (U16) (INLINE_TIME_PERIOD_HISTORY_ID | 0x8000);
        inline_time_period_edit_history *h = (inline_time_period_edit_history*) history_buffer;

        h->history_ID = hID;
        h->current_focus = (S16) wgui_inline_time_period_input.current_focus;
        if (wgui_inline_time_period_input.focus_input_box != NULL)
        {
            h->current_position =
                (S16) (wgui_inline_time_period_input.focus_input_box->current_text_p -
                       wgui_inline_time_period_input.focus_input_box->text);
        }
        h->flags = wgui_inline_time_period_input.input.flags;
        mmi_imc_get_input_method_history(&(h->ime_history));
    }
    return (history_buffer);
}


/*****************************************************************************
 * FUNCTION
 *  inline_time_period_edit_set_history
 * DESCRIPTION
 *  set history buffer into wgui_inline_time_period_input
 * PARAMETERS
 *  history_ID          [IN]    history id        
 *  history_buffer      [IN]    history buffer     
 * RETURNS
 *  1->success 0->fail
 *****************************************************************************/
U8 inline_time_period_edit_set_history(U16 history_ID, U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (history_buffer != NULL)
    {
        inline_time_period_edit_history *h = (inline_time_period_edit_history*) history_buffer;

        if (history_valid(h->history_ID, history_ID))
        {
            wgui_inline_time_period_input.current_focus = h->current_focus;
            time_period_input_reset_focus((void *)&wgui_inline_time_period_input);
            time_period_input_set_focus((void *)&wgui_inline_time_period_input);
            if (wgui_inline_time_period_input.focus_input_box != NULL)
            {
                wgui_inline_time_period_input.focus_input_box->current_text_p =
                    wgui_inline_time_period_input.focus_input_box->text + h->current_position;
            }
            wgui_inline_time_period_input.input.flags = h->flags;
            return (1);
        }
    }
    return (0);
}


/*****************************************************************************
 * FUNCTION
 *  handle_inline_time_period_edit
 * DESCRIPTION
 *  activation function of inline time period edit
 * PARAMETERS
 *  x                   [IN]        left corner's x coordinate
 *  y                   [IN]        left corner's y coordinate
 *  width               [IN]        width
 *  height              [IN]        height
 *  key_code            [IN]        key code
 *  key_event           [IN]        key event
 *  text_p              [IN]        text pointer
 *  item                [IN]        inline item
 *  flags               [IN]        flags
 *  history_buffer      [IN]        history buffer         
 * RETURNS
 *  void
 *****************************************************************************/
void handle_inline_time_period_edit(
        S32 x,
        S32 y,
        S32 width,
        S32 height,
        S32 key_code,
        S32 key_event,
        U8 **text_p,
        void *item,
        U32 flags,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_inline_item_time_period *i = (wgui_inline_item_time_period*) item;
#ifndef __MMI_FTE_SUPPORT__
    S32 xx;
#endif
    U32 dtflags = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(key_code);
    UI_UNUSED_PARAMETER(key_event);
    UI_UNUSED_PARAMETER(flags);
    wgui_current_inline_item_type = INLINE_ITEM_TYPE_TIME_PERIOD;
    /* MTK Elvis for R2L characters */
#ifndef __MMI_FTE_SUPPORT__
    if (!mmi_fe_get_r2l_state())
    {
        if (MMI_fixed_icontext_menuitem.text_x == 2)
        {
            xx = -1;
        }
        else
        {
            xx = MMI_fixed_icontext_menuitem.text_x;
        }
    }
    else
    {
        xx = 6;
    }
    /* MTK end */
    if (flags & INLINE_ITEM_LEFT_ALIGN)
    {
        xx = -1;
    }
#endif
    switch (flags & INLINE_ITEM_JUSTIFY_MASK)
    {
        case INLINE_ITEM_RIGHT_JUSTIFY:
            dtflags |= TIME_PERIOD_INPUT_RIGHT_JUSTIFY;
            break;
        case INLINE_ITEM_CENTER_JUSTIFY:
            dtflags |= TIME_PERIOD_INPUT_CENTER_JUSTIFY;
            break;
    }
    if (flags & INLINE_ITEM_DISABLE_HIGHLIGHT)
    {
        time_period_input_background_filler = MMI_inputbox_normal_filler;       /* *MMI_fixed_list_menu.normal_filler; */
        time_period_input_background_filler.flags &= 0x00000fff;
    }
    else
    {
        time_period_input_background_filler = MMI_inputbox_normal_filler;       /* *MMI_fixed_icontext_menuitem.focussed_filler; */
        time_period_input_background_filler.flags &= 0x00000fff;
    }
    complete_inline_item_edit = handle_inline_time_period_edit_complete;
    current_wgui_inline_time_period_item = i;
    current_wgui_inline_time_period_text_p = text_p;

#ifndef __MMI_FTE_SUPPORT__
    if (!mmi_fe_get_r2l_state())
    {
        create_time_period_input(
            &wgui_inline_time_period_input,
            x + xx,
            y,
            width - 1 - xx,
            height,
            dtflags,
            i->hours_buffer1,
            i->minutes_buffer1,
            i->hours_buffer2,
            i->minutes_buffer2);
    }
    else
    {
        create_time_period_input(
            &wgui_inline_time_period_input,
            x + xx,
            y,
            width - 1 - MMI_fixed_icontext_menuitem.text_x,
            height,
            dtflags,
            i->hours_buffer1,
            i->minutes_buffer1,
            i->hours_buffer2,
            i->minutes_buffer2);
    }

#else

    create_time_period_input(
            &wgui_inline_time_period_input,
            x,
            y,
            width,
            height,
            dtflags,
            i->hours_buffer1,
            i->minutes_buffer1,
            i->hours_buffer2,
            i->minutes_buffer2);
#endif

#ifdef __MMI_FTE_SUPPORT__
    wgui_inline_time_period_input.input.flags |= TIME_PERIOD_INPUT_USE_PRESET_CLIP;
#endif

    if(cui_inline_is_current_cui())
    {
        cui_inline_item_replace_gui_buffer(wgui_inline_item_highlighted_index, &wgui_inline_items[wgui_inline_item_highlighted_index], &history_buffer);
    }
    else
    {
        inline_time_period_edit_set_history(INLINE_TIME_PERIOD_HISTORY_ID, history_buffer);
    }
    
    time_period_input_set_seperators(&wgui_inline_time_period_input, (UI_character_type) ':', (UI_character_type) '-');
    time_period_input_show_background(&wgui_inline_time_period_input);
    show_time_period_input(&wgui_inline_time_period_input);
    set_current_time_period_input(&wgui_inline_time_period_input);
    time_period_input_register_keys();
    mmi_imc_key_register_ime_keys();
    register_keyboard_key_handler(inline_time_period_input_key_handler);

    /* key rule. 09.10.17 */
    SetKeyHandler(inline_time_period_edit_handle_down_arrow, KEY_DOWN_ARROW, KEY_EVENT_REPEAT);
    SetKeyHandler(inline_time_period_edit_handle_up_arrow, KEY_UP_ARROW, KEY_EVENT_REPEAT);
    SetKeyHandler(inline_time_period_edit_handle_down_arrow, KEY_VOL_DOWN, KEY_EVENT_REPEAT);
    SetKeyHandler(inline_time_period_edit_handle_up_arrow, KEY_VOL_UP, KEY_EVENT_REPEAT);
    
    SetKeyHandler(inline_time_period_edit_handle_down_arrow, KEY_DOWN_ARROW, KEY_EVENT_DOWN);
    SetKeyHandler(inline_time_period_edit_handle_up_arrow, KEY_UP_ARROW, KEY_EVENT_DOWN);
    SetKeyHandler(inline_time_period_edit_handle_down_arrow, KEY_VOL_DOWN, KEY_EVENT_DOWN);
    SetKeyHandler(inline_time_period_edit_handle_up_arrow, KEY_VOL_UP, KEY_EVENT_DOWN);
    register_time_period_input_callback(set_wgui_inline_list_menu_changed);
    redraw_current_inline_item = redraw_inline_time_period_edit;
    mmi_imc_redraw_screen_by_state();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_input_box_msg_call_back_inline_time_period
 * DESCRIPTION
 *  message callback function of inline time period for IME
 * PARAMETERS
 *  editor_ptr          [IN]      time period input pointer  
 *  msg_ptr             [IN]      message pointer       
 * RETURNS
 *  U32
 *****************************************************************************/
static U32 mmi_input_box_msg_call_back_inline_time_period(time_period_input  * editor_ptr, mmi_imc_message_struct_p msg_ptr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL is_last = MMI_FALSE;
    S32 i, str_len;
    U32 lresult = 0;
    UI_string_type temp_str;
    UI_character_type ch; 
#ifdef __MMI_TOUCH_SCREEN__
    MMI_BOOL ret = MMI_FALSE;
#endif
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    MMI_ASSERT(editor_ptr == &wgui_inline_time_period_input);

    switch(msg_ptr->message_id)
    {
    case MMI_IMC_MESSAGE_INSERT_CHAR:
        
        time_period_input_direct_input_nodraw((UI_character_type)msg_ptr->param_0);

        redraw_inline_time_period_edit();

        lresult = MMI_TRUE;
        
        break;
        
    case MMI_IMC_MESSAGE_INSERT_STRING:
    case MMI_IMC_MESSAGE_INSERT_STRING_NO_DRAW:    
        /* Need to revise */
        temp_str = (UI_string_type)msg_ptr->param_0;
        
        str_len = (S32)mmi_ucs2strlen((const S8 *)temp_str);

        if (msg_ptr->param_1 == MMI_TRUE)
        {
            if (time_period_input_test_last_position(editor_ptr))
            {
                is_last = MMI_TRUE;
            }
            
            time_period_input_direct_input_nodraw((UI_character_type)temp_str[0]);
            
            if (!is_last)
            {
                time_period_input_previous_character();
            }
            
            show_time_period_input(editor_ptr);
        }
        else
        {
            time_period_input_direct_input((UI_character_type)temp_str[0]);
        }

        redraw_inline_time_period_edit();

        lresult = str_len;
        break;
    case MMI_IMC_MESSAGE_REPLACE_HIGHLIGHT_STRING:
    
        temp_str = (UI_string_type)msg_ptr->param_1;
        
        str_len = (S32)mmi_ucs2strlen((const S8 *)temp_str);

            if (time_period_input_test_last_position(editor_ptr))
            {
                is_last = MMI_TRUE;
            }
            
            time_period_input_direct_input_nodraw((UI_character_type)temp_str[0]);
            
            if (!is_last)
            {
                time_period_input_previous_character();
            }
            
            show_time_period_input(editor_ptr);

        redraw_inline_time_period_edit();

        lresult = str_len;
        break;

    case MMI_IMC_MESSAGE_CLEAR_HILIGHT:
        if (msg_ptr->param_0 == MMI_TRUE)
        {
            time_period_input_next_character();
        }
        break;
        
    case MMI_IMC_MESSAGE_IS_LAST_POSITION:
        lresult = (U32)time_period_input_test_last_position(editor_ptr);
        break;
        
    case MMI_IMC_MESSAGE_DELETE_STRING:
        
        break;
        
    case MMI_IMC_MESSAGE_INSERT_MULTITAP_CHAR:
        ch = (UI_character_type)msg_ptr->param_0;
        lresult = time_period_input_direct_input_nodraw(ch);
        break;

    case MMI_IMC_MESSAGE_RESET_MULTITAP_STATE:
        time_period_input_next_character();
        break;
        
    case MMI_IMC_MESSAGE_DELETE_CHAR:

        for (i = 0; i < (S32)msg_ptr->param_0; i++)
        {
            time_period_input_previous_character();
        }

        break;
    case MMI_IMC_MESSAGE_CLEAR_ALL:
    
        time_period_input_first_character();
    
        break;
       
    case MMI_IMC_MESSAGE_REDRAW:
        
        wgui_inline_time_period_input.current_focus = g_inline_time_period_current_focus;

        time_period_input_reset_focus((void *)&wgui_inline_time_period_input);
        time_period_input_set_focus((void *)&wgui_inline_time_period_input);

        if (wgui_inline_time_period_input.focus_input_box != NULL)
        {
            wgui_inline_time_period_input.focus_input_box->current_text_p =
                wgui_inline_time_period_input.focus_input_box->text + g_inline_time_period_current_position;
        }
        
        wgui_inline_time_period_input.input.flags = g_inline_time_period_flags;
        
        redraw_inline_time_period_edit();
        
        break;
        
    case MMI_IMC_MESSAGE_SET_KEY:
        time_period_input_register_keys();
        mmi_imc_key_register_ime_keys();
        register_keyboard_key_handler(inline_time_period_input_key_handler);

        /* key rule. 09.10.17  KEY_EVENT_REPEAT */
        SetKeyHandler(inline_time_period_edit_handle_down_arrow, KEY_DOWN_ARROW, KEY_EVENT_REPEAT);
        SetKeyHandler(inline_time_period_edit_handle_up_arrow, KEY_UP_ARROW, KEY_EVENT_REPEAT);
        SetKeyHandler(inline_time_period_edit_handle_down_arrow, KEY_DOWN_ARROW, KEY_EVENT_DOWN);
        SetKeyHandler(inline_time_period_edit_handle_up_arrow, KEY_UP_ARROW, KEY_EVENT_DOWN);
        set_right_softkey_label(wgui_inline_edit_get_RSK_string());
        register_right_softkey_handler();
        set_right_softkey_function(register_inline_edit_handle_right_softkey_up, KEY_EVENT_DOWN);
        break;
    case MMI_IMC_MESSAGE_CHECK_CSK_ENABLE:
        lresult = MMI_FALSE;
        break;
    case MMI_IMC_MESSAGE_CHECK_INFO_BAR_ENABL:
        lresult = MMI_FALSE;
        break;
        
    case MMI_IMC_MESSAGE_GET_CURSOR_RECT:
        if (editor_ptr->focus_input_box->flags & UI_SINGLE_LINE_INPUT_BOX_SHOW_BLOCK_CURSOR)
        {
            ((mmi_imc_rect_p)msg_ptr->param_0)->x = editor_ptr->focus_input_box->hilite_s_x;
            ((mmi_imc_rect_p)msg_ptr->param_0)->y = editor_ptr->focus_input_box->hilite_s_y;
            ((mmi_imc_rect_p)msg_ptr->param_0)->width = editor_ptr->focus_input_box->hilite_e_x - editor_ptr->focus_input_box->hilite_s_x + 1;
            ((mmi_imc_rect_p)msg_ptr->param_0)->height = editor_ptr->focus_input_box->hilite_e_y - editor_ptr->focus_input_box->hilite_s_y + 1;
        }
        else
        {
            ((mmi_imc_rect_p)msg_ptr->param_0)->x = UI_cursor_x1;
            ((mmi_imc_rect_p)msg_ptr->param_0)->y = UI_cursor_y1;
            ((mmi_imc_rect_p)msg_ptr->param_0)->width = UI_cursor_x2 - UI_cursor_x1 + 1;
            ((mmi_imc_rect_p)msg_ptr->param_0)->height = UI_cursor_y2 - UI_cursor_y1 + 1;
        }
        lresult = MMI_TRUE;
        break;
        
    case MMI_IMC_MESSAGE_MOVE_CURSOR:
        switch (msg_ptr->param_0)
        {
            case MMI_IMC_EDITOR_CURSOR_UP:
                for (i = 0; i <(S32)msg_ptr->param_1; i ++)
                {
                    inline_time_period_edit_handle_up_arrow();
                }
                break;
                
            case MMI_IMC_EDITOR_CURSOR_DOWN:
                for (i = 0; i <(S32)msg_ptr->param_1; i ++)
                {
                    inline_time_period_edit_handle_down_arrow();
                }
                break;
                
            case MMI_IMC_EDITOR_CURSOR_LEFT:
                for (i = 0; i <(S32)msg_ptr->param_1; i ++)
                {
                    time_period_input_previous_character();
                }
                break;
            case MMI_IMC_EDITOR_CURSOR_RIGHT:
                for (i = 0; i <(S32)msg_ptr->param_1; i ++)
                {
                    time_period_input_next_character();
                }
                break;
        }
        break;
        
    case MMI_IMC_MESSAGE_IS_BACKSPACE_DISABLED:
        lresult = MMI_TRUE;
        break;
        
#if defined(__MMI_TOUCH_SCREEN__)        
    case MMI_IMC_MESSAGE_PEN_EVENT:
        if (((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->mmi_pen_event == MMI_PEN_EVENT_DOWN)
        {
            if (PEN_CHECK_BOUND(((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos.x, 
                                ((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos.y, 
                                editor_ptr->input.x, editor_ptr->input.y, 
                                editor_ptr->input.width,
                                editor_ptr->input.height))
            {
                *((U32 *)msg_ptr->param_1) = 1;
                ret = MMI_TRUE;
            }
            else
            {
                ret = MMI_FALSE;
            }
        }
        else if (((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->mmi_pen_event == MMI_PEN_EVENT_UP)
        {
            if (PEN_CHECK_BOUND(((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos.x, 
                                ((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos.y, 
                                editor_ptr->input.x, editor_ptr->input.y, 
                                editor_ptr->input.width,
                                editor_ptr->input.height))
            {
                time_period_input_move_to_x_y(editor_ptr, 
                                   ((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos.x, 
                                   ((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos.y);
                ret = MMI_TRUE;
            }
            else
            {
                ret = MMI_FALSE;
            }
            
        }
        
        lresult = ret;
        
        break;
#endif

    default:
        break;
    }

    return lresult;
}


/*****************************************************************************
 * FUNCTION
 *  SetInlineItemTimePeriod
 * DESCRIPTION
 *  set data of inline timer period edit
 * PARAMETERS
 *  item                [IN]      inine item   
 *  hours_buffer1       [IN]      hours buffer1   
 *  minutes_buffer1     [IN]      minutes buffer1   
 *  AM_PM_flag1         [IN]      flag1 of AM_PM   
 *  hours_buffer2       [IN]      hours buffer2   
 *  minutes_buffer2     [IN]      minutes buffer2   
 *  AM_PM_flag2         [IN]      flag2 of AM_PM   
 *  f                   [IN]      string construct callback  
 * RETURNS
 *  void
 *****************************************************************************/
void SetInlineItemTimePeriod(
        InlineItem *item,
        U8 *hours_buffer1,
        U8 *minutes_buffer1,
        U8 *AM_PM_flag1,
        U8 *hours_buffer2,
        U8 *minutes_buffer2,
        U8 *AM_PM_flag2,
        void (*f) (U8 *string_buffer, U8 *hours_buffer1, U8 *minutes_buffer1, U8 *AM_PM_flag1, U8 *hours_buffer2, U8 *minutes_buffer2, U8 *AM_PM_flag2))
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_inline_item_time_period *i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (n_inline_time_period_items >= MAX_INLINE_TIME_PERIOD_ITEMS)
    {
        return;
    }
    wgui_inline_mem_alloc_info[wgui_inline_mem_alloc_number] = item->item = wgui_inline_malloc(sizeof(wgui_inline_item_time_period));
    wgui_inline_mem_alloc_number++; 
    item->flags = INLINE_ITEM_TYPE_TIME_PERIOD;
    wgui_inline_mem_alloc_info[wgui_inline_mem_alloc_number] = item->text_p = (U8*)wgui_inline_malloc(MAX_INLINE_TIME_PERIOD_DISPLAY_STRING_SIZE * sizeof(U8));
    wgui_inline_mem_alloc_number++; 
    n_inline_time_period_items++;
    i = (wgui_inline_item_time_period*) item->item;
    i->hours_buffer1 = hours_buffer1;
    i->minutes_buffer1 = minutes_buffer1;
    i->AM_PM_flag1 = AM_PM_flag1;
    i->hours_buffer2 = hours_buffer2;
    i->minutes_buffer2 = minutes_buffer2;
    i->AM_PM_flag2 = AM_PM_flag2;
    i->flags = INLINE_ITEM_LEFT_JUSTIFY;
    i->string_construct_callback = f;
    i->string_construct_callback(
        item->text_p,
        i->hours_buffer1,
        i->minutes_buffer1,
        i->AM_PM_flag1,
        i->hours_buffer2,
        i->minutes_buffer2,
        i->AM_PM_flag2);
    item->handler = handle_inline_time_period_edit;
}


/*****************************************************************************
 * FUNCTION
 *  ReConfigureInlineItemTimePeriod
 * DESCRIPTION
 *  re-configure data of inline time period
 * PARAMETERS
 *  item                [IN]      inine item   
 *  hours_buffer1       [IN]      hours buffer1   
 *  minutes_buffer1     [IN]      minutes buffer1   
 *  AM_PM_flag1         [IN]      flag1 of AM_PM   
 *  hours_buffer2       [IN]      hours buffer2   
 *  minutes_buffer2     [IN]      minutes buffer2   
 *  AM_PM_flag2         [IN]      flag2 of AM_PM   
 *  f                   [IN]      string construct callback        
 * RETURNS
 *  void
 *****************************************************************************/
void ReConfigureInlineItemTimePeriod(
        InlineItem *item,
        U8 *hours_buffer1,
        U8 *minutes_buffer1,
        U8 *AM_PM_flag1,
        U8 *hours_buffer2,
        U8 *minutes_buffer2,
        U8 *AM_PM_flag2,
        void (*f) (U8 *string_buffer, U8 *hours_buffer1, U8 *minutes_buffer1, U8 *AM_PM_flag1, U8 *hours_buffer2, U8 *minutes_buffer2, U8 *AM_PM_flag2))
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_inline_item_time_period *i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if ((item->flags & 0xff) != INLINE_ITEM_TYPE_TIME_PERIOD)
    {
        return;
    }
    i = (wgui_inline_item_time_period*) item->item;
    i->hours_buffer1 = hours_buffer1;
    i->minutes_buffer1 = minutes_buffer1;
    i->AM_PM_flag1 = AM_PM_flag1;
    i->hours_buffer2 = hours_buffer2;
    i->minutes_buffer2 = minutes_buffer2;
    i->AM_PM_flag2 = AM_PM_flag2;
    i->flags = 0;
    i->string_construct_callback = f;
    i->string_construct_callback(
        item->text_p,
        i->hours_buffer1,
        i->minutes_buffer1,
        i->AM_PM_flag1,
        i->hours_buffer2,
        i->minutes_buffer2,
        i->AM_PM_flag2);
}



/*****************************************************************************
 * FUNCTION
 *  wgui_show_inline_time_period_list_menuitem
 * DESCRIPTION
 *  show inline time period list menuitem
 * PARAMETERS
 *  x1          [IN]       left-top corner x1 coordinate 
 *  y1          [IN]       left-top corner y1 coordinate 
 *  width       [IN]       width 
 *  height      [IN]       height 
 *  item        [IN]       inline item  
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_show_inline_time_period_list_menuitem(S32 x1, S32 y1, S32 width, S32 height, wgui_inline_item *item)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_inline_item_time_period *i = (wgui_inline_item_time_period*) item->item;
#ifndef __MMI_FTE_SUPPORT__
    S32 xx;
#endif
    U32 dtflags = TIME_INPUT_TYPE_HH_MM;
    time_period_input wgui_inline_time_period_input_display = {0};

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();
#ifndef __MMI_FTE_SUPPORT__
    if (MMI_fixed_icontext_menuitem.text_x == 2)
    {
        xx = -1;
    }
    else
    {
        xx = MMI_fixed_icontext_menuitem.text_x;
    }
    if (item->flags & INLINE_ITEM_LEFT_ALIGN)
    {
        xx = -1;
    }
#endif
    switch (item->flags & INLINE_ITEM_JUSTIFY_MASK)
    {
        case INLINE_ITEM_RIGHT_JUSTIFY:
            dtflags |= DATE_INPUT_RIGHT_JUSTIFY;
            break;
        case INLINE_ITEM_CENTER_JUSTIFY:
            dtflags |= DATE_INPUT_CENTER_JUSTIFY;
            break;
    }
    wgui_set_date_time_input_unfocussed_theme();
#ifndef __MMI_FTE_SUPPORT__    
    create_time_period_input(
        &wgui_inline_time_period_input_display,
        x1 + xx,
        y1,
        width - 1 - xx,
        height,
        dtflags,
        i->hours_buffer1,
        i->minutes_buffer1,
        i->hours_buffer2,
        i->minutes_buffer2);
    
#else

     create_time_period_input(
        &wgui_inline_time_period_input_display,
        x1,
        y1,
        width,
        height,
        dtflags,
        i->hours_buffer1,
        i->minutes_buffer1,
        i->hours_buffer2,
        i->minutes_buffer2);
#endif
    
#ifdef __MMI_FTE_SUPPORT__
    wgui_inline_time_period_input_display.input.flags |= TIME_PERIOD_INPUT_USE_PRESET_CLIP;
#endif

    time_period_input_set_seperators(
        &wgui_inline_time_period_input_display,
        (UI_character_type) ':',
        (UI_character_type) '-');
    time_period_input_show_background(&wgui_inline_time_period_input_display);
    time_period_input_reset_focus((void *)&wgui_inline_time_period_input_display);
    show_time_period_input(&wgui_inline_time_period_input_display);
    wgui_set_date_time_input_focussed_theme();
    gdi_layer_unlock_frame_buffer();
}

#endif


#if defined(__MMI_INLINE_ITEM_IP4__)
/***************************************************************************** 
 * Inline IP4 Edit    
 *
 * This is Inline IP4 Edit Item
 *****************************************************************************/

/***************************************************************************** 
 * Define
 *****************************************************************************/
#ifdef LOW_COST_SUPPORT
#define MAX_INLINE_IP4_ITEMS                    5
#else
#define MAX_INLINE_IP4_ITEMS                    5 /* wireless lan need 5 items */
#endif
#define MAX_INLINE_IP4_DISPLAY_STRING_SIZE      48


/***************************************************************************** 
 * Typedef 
 *****************************************************************************/  
typedef struct _inline_IP4_edit_history
{
    U16 history_ID;
    S16 current_focus;
    S16 current_position;
    S16 dummy;  /* Added for history issue on hardware */
    U32 flags;
    mmi_imc_history ime_history;
} inline_IP4_edit_history;


/***************************************************************************** 
 * Local Variable
 *****************************************************************************/
static S32 n_inline_IP4_items = 0;
static wgui_inline_item_IP4 *current_wgui_inline_IP4_item;
static PU8 *current_wgui_inline_IP4_text_p;
IP4_input wgui_inline_IP4_input;

/* Displaying IP address edit as a menu item in the fixed list menu  */
//static IP4_input wgui_inline_IP4_input_display;

/***************************************************************************** 
 * Function Implementation
 *****************************************************************************/

/*****************************************************************************
 * FUNCTION
 *  handle_inline_IP4_edit_complete
 * DESCRIPTION
 *  complete function of inline IP4 edit
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void handle_inline_IP4_edit_complete(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    register_inline_fixed_list_keys();
    current_wgui_inline_IP4_item->string_construct_callback(
                                    *current_wgui_inline_IP4_text_p,
                                    current_wgui_inline_IP4_item->b1,
                                    current_wgui_inline_IP4_item->b2,
                                    current_wgui_inline_IP4_item->b3,
                                    current_wgui_inline_IP4_item->b4);
    MMI_fixed_icontext_menuitems[wgui_inline_item_highlighted_index].item_text =
        (UI_string_type) * current_wgui_inline_IP4_text_p;
   // clear_left_softkey();
    //clear_right_softkey();
    register_left_softkey_handler();
    register_right_softkey_handler();

    wgui_inline_item_handled = 0;
    wgui_text_menuitem_restart_scrolling();
    redraw_current_inline_item = UI_dummy_function;
    complete_inline_item_edit = UI_dummy_function;
    set_current_IP4_input(NULL);
    clear_IP4_input_callback();
    mmi_imc_disconnect();
    g_inline_current_input_box_handler = NULL;
}


/*****************************************************************************
 * FUNCTION
 *  redraw_inline_IP4_edit
 * DESCRIPTION
 *  redraw inline IP4 edit
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void redraw_inline_IP4_edit(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    IP4_input_show_background(&wgui_inline_IP4_input);
    show_IP4_input(&wgui_inline_IP4_input);
}


/*****************************************************************************
 * FUNCTION
 *  inline_IP4_edit_handle_down_arrow
 * DESCRIPTION
 *  down arrow handler onf inline IP4 edit
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void inline_IP4_edit_handle_down_arrow(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (wgui_inline_edit_is_able_to_switch_highlight(1))
    {
#ifdef __MMI_FTE_SUPPORT__    
        wgui_inline_get_vk_status(&g_inline_vk_status);
#endif
        handle_inline_IP4_edit_complete();
        inline_fixed_list_goto_next_item();
    }

}


/*****************************************************************************
 * FUNCTION
 *  inline_IP4_edit_handle_up_arrow
 * DESCRIPTION
 *  up arrow handler onf inline IP4 edit
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void inline_IP4_edit_handle_up_arrow(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (wgui_inline_edit_is_able_to_switch_highlight(0))
    {
#ifdef __MMI_FTE_SUPPORT__    
        wgui_inline_get_vk_status(&g_inline_vk_status);
#endif
        handle_inline_IP4_edit_complete();
        inline_fixed_list_goto_previous_item();
    }
}


/*****************************************************************************
 * FUNCTION
 *  inline_IP4_input_key_handler
 * DESCRIPTION
 *  input key handler of inline IP4 for PC
 * PARAMETERS
 *  vkey_code       [IN]      key code  
 *  key_state       [IN]      key state  
 * RETURNS
 *  void
 *****************************************************************************/
void inline_IP4_input_key_handler(S32 vkey_code, S32 key_state)
{
#if(MMI_BUILD_TYPE == BUILD_TYPE_X86WIN32)
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (key_state)
    {
        switch (vkey_code)
        {
            case 37:
                IP4_input_previous_character();
                break;
            case 38:
                inline_IP4_edit_handle_up_arrow();
                break;
            case 39:
                IP4_input_next_character();
                break;
            case 40:
                inline_IP4_edit_handle_down_arrow();
                break;
            case 36:    /* home */
                break;
            case 35:    /* end */
                break;
            case 33:    /* page up */
                break;
            case 34:    /* page down */
                break;
            case 45:
                IP4_input_toggle_insert_mode();
                break;
            case 46:
                IP4_input_delete_current_character();
                break;
        }
    }
#else /* (MMI_BUILD_TYPE == BUILD_TYPE_X86WIN32) */ 
    UI_UNUSED_PARAMETER(vkey_code);
    UI_UNUSED_PARAMETER(key_state);
#endif /* (MMI_BUILD_TYPE == BUILD_TYPE_X86WIN32) */ 
}


/*****************************************************************************
 * FUNCTION
 *  inline_IP4_edit_get_history
 * DESCRIPTION
 *  get history buffer of inline IP4 edit
 * PARAMETERS
 *  history_buffer      [OUT]   history buffer     
 * RETURNS
 *  history buffer
 *****************************************************************************/
U8 *inline_IP4_edit_get_history(U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (history_buffer != NULL)
    {
        U16 hID = (U16) (INLINE_IP4_HISTORY_ID | 0x8000);
        inline_IP4_edit_history *h = (inline_IP4_edit_history*) history_buffer;

        h->history_ID = hID;
        h->current_focus = (S16) wgui_inline_IP4_input.current_focus;
        if (wgui_inline_IP4_input.focus_input_box != NULL)
        {
            h->current_position =
                (S16) (wgui_inline_IP4_input.focus_input_box->current_text_p -
                       wgui_inline_IP4_input.focus_input_box->text);
        }
        h->flags = wgui_inline_IP4_input.input.flags;
        mmi_imc_get_input_method_history(&(h->ime_history));
    }
    return (history_buffer);
}


/*****************************************************************************
 * FUNCTION
 *  inline_IP4_edit_set_history
 * DESCRIPTION
 *  set history buffer into wgui_inline_IP4_input
 * PARAMETERS
 *  history_ID          [IN]    history id    
 *  history_buffer      [IN]    history buffer         
 * RETURNS
 *  1->success 0->fail
 *****************************************************************************/
U8 inline_IP4_edit_set_history(U16 history_ID, U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (history_buffer != NULL)
    {
        inline_IP4_edit_history *h = (inline_IP4_edit_history*) history_buffer;

        if (history_valid(h->history_ID, history_ID))
        {
            wgui_inline_IP4_input.current_focus = h->current_focus;
            IP4_input_reset_focus((void *)&wgui_inline_IP4_input);
            IP4_input_set_focus((void *)&wgui_inline_IP4_input);
            if (wgui_inline_IP4_input.focus_input_box != NULL)
            {
                wgui_inline_IP4_input.focus_input_box->current_text_p =
                    wgui_inline_IP4_input.focus_input_box->text + h->current_position;
            }
            wgui_inline_IP4_input.input.flags = h->flags;
            return (1);
        }
    }
    return (0);
}


/*****************************************************************************
 * FUNCTION
 *  handle_inline_IP4_edit
 * DESCRIPTION
 *  activation function of inline IP4 edit
 * PARAMETERS
 *  x                   [IN]        left corner's x coordinate
 *  y                   [IN]        left corner's y coordinate
 *  width               [IN]        width
 *  height              [IN]        height
 *  key_code            [IN]        key code
 *  key_event           [IN]        key event
 *  text_p              [IN]        text pointer
 *  item                [IN]        inline item
 *  flags               [IN]        flags
 *  history_buffer      [IN]        history buffer           
 * RETURNS
 *  void
 *****************************************************************************/
void handle_inline_IP4_edit(
        S32 x,
        S32 y,
        S32 width,
        S32 height,
        S32 key_code,
        S32 key_event,
        U8 **text_p,
        void *item,
        U32 flags,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_inline_item_IP4 *i = (wgui_inline_item_IP4*) item;
    S32 xx;
    U32 dtflags = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(key_event);
    UI_UNUSED_PARAMETER(key_code);
    UI_UNUSED_PARAMETER(flags);
    wgui_current_inline_item_type = INLINE_ITEM_TYPE_IP4_EDIT;
    /* MTK Elvis for R2L characters */
    if (!mmi_fe_get_r2l_state())
    {
        if (MMI_fixed_icontext_menuitem.text_x == 2)
        {
            xx = -1;
        }
        else
        {
            xx = MMI_fixed_icontext_menuitem.text_x;
        }
    }
    else
    {
        xx = 1;
    }
    /* MTK end */
    if (flags & INLINE_ITEM_LEFT_ALIGN)
    {
        xx = -1;
    }
    switch (flags & INLINE_ITEM_JUSTIFY_MASK)
    {
        case INLINE_ITEM_RIGHT_JUSTIFY:
            dtflags |= IP4_INPUT_RIGHT_JUSTIFY;
            break;
        case INLINE_ITEM_CENTER_JUSTIFY:
            dtflags |= IP4_INPUT_CENTER_JUSTIFY;
            break;
    }
    complete_inline_item_edit = handle_inline_IP4_edit_complete;
    current_wgui_inline_IP4_item = i;
    current_wgui_inline_IP4_text_p = text_p;

    /* Ignore mmi_fe_get_r2l_state() */
    create_IP4_input(
        &wgui_inline_IP4_input,
        x,
        y,
        width,
        height,
        dtflags,
        i->b1,
        i->b2,
        i->b3,
        i->b4);

#ifdef __MMI_FTE_SUPPORT__
    wgui_inline_IP4_input.input.flags |= IP4_INPUT_USE_PRESET_CLIP;
#endif

    if(cui_inline_is_current_cui())
    {
        cui_inline_item_replace_gui_buffer(wgui_inline_item_highlighted_index, &wgui_inline_items[wgui_inline_item_highlighted_index], &history_buffer);
    }
    else
    {
        inline_IP4_edit_set_history(INLINE_IP4_HISTORY_ID, history_buffer);
    }
    
    IP4_input_set_seperator(&wgui_inline_IP4_input, (UI_character_type) '.');
    IP4_input_show_background(&wgui_inline_IP4_input);
    show_IP4_input(&wgui_inline_IP4_input);
    set_current_IP4_input(&wgui_inline_IP4_input);
    IP4_input_register_keys();
    mmi_imc_key_register_ime_keys();
    register_keyboard_key_handler(inline_IP4_input_key_handler);

    /* key rule. 09.10.17  KEY_EVENT_REPEAT */

    SetKeyHandler(inline_IP4_edit_handle_down_arrow, KEY_DOWN_ARROW, KEY_EVENT_REPEAT);
    SetKeyHandler(inline_IP4_edit_handle_up_arrow, KEY_UP_ARROW, KEY_EVENT_REPEAT);
    SetKeyHandler(inline_IP4_edit_handle_down_arrow, KEY_VOL_DOWN, KEY_EVENT_REPEAT);
    SetKeyHandler(inline_IP4_edit_handle_up_arrow, KEY_VOL_UP, KEY_EVENT_REPEAT);
    SetKeyHandler(inline_IP4_edit_handle_down_arrow, KEY_DOWN_ARROW, KEY_EVENT_DOWN);
    SetKeyHandler(inline_IP4_edit_handle_up_arrow, KEY_UP_ARROW, KEY_EVENT_DOWN);
    SetKeyHandler(inline_IP4_edit_handle_down_arrow, KEY_VOL_DOWN, KEY_EVENT_DOWN);
    SetKeyHandler(inline_IP4_edit_handle_up_arrow, KEY_VOL_UP, KEY_EVENT_DOWN);
    register_IP4_input_callback(set_wgui_inline_list_menu_changed);
    redraw_current_inline_item = redraw_inline_IP4_edit;
    UI_UNUSED_PARAMETER(xx);
    
    mmi_imc_redraw_screen_by_state();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_input_box_msg_call_back_inline_ip4
 * DESCRIPTION
 *  message callback function of inline IP4 for IME
 * PARAMETERS
 *  editor_ptr        [IN]         IP4 input pointer
 *  msg_ptr           [IN]         message pointer
 * RETURNS
 *  U32
 *****************************************************************************/
static U32 mmi_input_box_msg_call_back_inline_ip4(IP4_input  * editor_ptr, mmi_imc_message_struct_p msg_ptr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL is_last = MMI_FALSE;
    S32 i, str_len;
    U32 lresult = 0;
    UI_string_type temp_str;
    UI_character_type ch;
#ifdef __MMI_TOUCH_SCREEN__
    MMI_BOOL ret = MMI_FALSE;
#endif /* __MMI_TOUCH_SCREEN__ */ 
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    MMI_ASSERT(editor_ptr == &wgui_inline_IP4_input);

    switch(msg_ptr->message_id)
    {
    case MMI_IMC_MESSAGE_INSERT_CHAR:
        
        IP4_input_direct_input_nodraw((UI_character_type)msg_ptr->param_0);

        redraw_inline_IP4_edit();

        lresult = MMI_FALSE;
        break;
        
    case MMI_IMC_MESSAGE_INSERT_STRING:
    case MMI_IMC_MESSAGE_INSERT_STRING_NO_DRAW:     
        /* Need to revise */
        temp_str = (UI_string_type)msg_ptr->param_0;
        
        str_len = (S32)mmi_ucs2strlen((const S8 *)temp_str);

        if (msg_ptr->param_1 == MMI_TRUE)
        {
            if (IP4_input_test_last_position(editor_ptr))
            {
                is_last = MMI_TRUE;
            }
            
            IP4_input_direct_input_nodraw((UI_character_type)temp_str[0]);
            
            if (!is_last)
            {
                IP4_input_previous_character();
            }
            
            show_IP4_input(editor_ptr);
        }
        else
        {
            IP4_input_direct_input((UI_character_type)temp_str[0]);
        }

        redraw_inline_IP4_edit();

        lresult = str_len;
        break;

        case MMI_IMC_MESSAGE_REPLACE_HIGHLIGHT_STRING:     
        /* Need to revise */
        temp_str = (UI_string_type)msg_ptr->param_1;
        
        str_len = (S32)mmi_ucs2strlen((const S8 *)temp_str);

            if (IP4_input_test_last_position(editor_ptr))
            {
                is_last = MMI_TRUE;
            }
            
            IP4_input_direct_input_nodraw((UI_character_type)temp_str[0]);
            
            if (!is_last)
            {
                IP4_input_previous_character();
            }
            
            show_IP4_input(editor_ptr);

        redraw_inline_IP4_edit();

        lresult = str_len;
        break;  

    case MMI_IMC_MESSAGE_CLEAR_HILIGHT:
        if (msg_ptr->param_0 == MMI_TRUE)
        {
            IP4_input_next_character();
        }
        break;
        
    case MMI_IMC_MESSAGE_IS_LAST_POSITION:
        lresult = (U32)IP4_input_test_last_position(editor_ptr);
        break;
        
    case MMI_IMC_MESSAGE_DELETE_STRING:
        
        break;
        
    case MMI_IMC_MESSAGE_INSERT_MULTITAP_CHAR:
        ch = (UI_character_type)msg_ptr->param_0;
        lresult = IP4_input_direct_input_nodraw(ch);
        break;

    case MMI_IMC_MESSAGE_RESET_MULTITAP_STATE:
        IP4_input_next_character();
        break;
        
    case MMI_IMC_MESSAGE_DELETE_CHAR:

        for (i = 0; i < (S32)msg_ptr->param_0; i++)
        {
            IP4_input_previous_character();
        }

        break;
    case MMI_IMC_MESSAGE_CLEAR_ALL:    
        IP4_input_first_character();    
        break;
    case MMI_IMC_MESSAGE_SET_KEY:
        IP4_input_register_keys();
        mmi_imc_key_register_ime_keys();
        register_keyboard_key_handler(inline_IP4_input_key_handler);

        /* key rule. 09.10.17  KEY_EVENT_REPEAT */
        SetKeyHandler(inline_IP4_edit_handle_down_arrow, KEY_DOWN_ARROW, KEY_EVENT_REPEAT);
        SetKeyHandler(inline_IP4_edit_handle_up_arrow, KEY_UP_ARROW, KEY_EVENT_REPEAT);
        SetKeyHandler(inline_IP4_edit_handle_down_arrow, KEY_DOWN_ARROW, KEY_EVENT_DOWN);
        SetKeyHandler(inline_IP4_edit_handle_up_arrow, KEY_UP_ARROW, KEY_EVENT_DOWN);
        set_right_softkey_label(wgui_inline_edit_get_RSK_string());
        register_right_softkey_handler();
        set_right_softkey_function(register_inline_edit_handle_right_softkey_up, KEY_EVENT_DOWN);
        break;
        
    case MMI_IMC_MESSAGE_CHECK_CSK_ENABLE:
        lresult = MMI_FALSE;
        break;
        
    case MMI_IMC_MESSAGE_CHECK_INFO_BAR_ENABL:
        lresult = MMI_FALSE;
        break;
    case MMI_IMC_MESSAGE_REDRAW:
        
        wgui_inline_IP4_input.current_focus = g_inline_IP4_current_focus;

        IP4_input_reset_focus((void *)&wgui_inline_IP4_input);
        IP4_input_set_focus((void *)&wgui_inline_IP4_input);

        if (wgui_inline_IP4_input.focus_input_box != NULL)
        {
            wgui_inline_IP4_input.focus_input_box->current_text_p =
                wgui_inline_IP4_input.focus_input_box->text + g_inline_IP4_current_position;
        }

        wgui_inline_IP4_input.input.flags = g_inline_IP4_flags;
        
        redraw_inline_IP4_edit();
        
        break;

    case MMI_IMC_MESSAGE_GET_CURSOR_RECT:
        if (editor_ptr->focus_input_box->flags & UI_SINGLE_LINE_INPUT_BOX_SHOW_BLOCK_CURSOR)
        {
            ((mmi_imc_rect_p)msg_ptr->param_0)->x = editor_ptr->focus_input_box->hilite_s_x;
            ((mmi_imc_rect_p)msg_ptr->param_0)->y = editor_ptr->focus_input_box->hilite_s_y;
            ((mmi_imc_rect_p)msg_ptr->param_0)->width = editor_ptr->focus_input_box->hilite_e_x - editor_ptr->focus_input_box->hilite_s_x + 1;
            ((mmi_imc_rect_p)msg_ptr->param_0)->height = editor_ptr->focus_input_box->hilite_e_y - editor_ptr->focus_input_box->hilite_s_y + 1;
        }
        else
        {
            ((mmi_imc_rect_p)msg_ptr->param_0)->x = UI_cursor_x1;
            ((mmi_imc_rect_p)msg_ptr->param_0)->y = UI_cursor_y1;
            ((mmi_imc_rect_p)msg_ptr->param_0)->width = UI_cursor_x2 - UI_cursor_x1 + 1;
            ((mmi_imc_rect_p)msg_ptr->param_0)->height = UI_cursor_y2 - UI_cursor_y1 + 1;
        }
        lresult = MMI_TRUE;
        break;

    case MMI_IMC_MESSAGE_MOVE_CURSOR:
        switch (msg_ptr->param_0)
        {
            case MMI_IMC_EDITOR_CURSOR_UP:
                for (i = 0; i <(S32)msg_ptr->param_1; i ++)
                {
                    inline_IP4_edit_handle_up_arrow();
                }
                break;
                
            case MMI_IMC_EDITOR_CURSOR_DOWN:
                for (i = 0; i <(S32)msg_ptr->param_1; i ++)
                {
                    inline_IP4_edit_handle_down_arrow();
                }
                break;
                
            case MMI_IMC_EDITOR_CURSOR_LEFT:
                for (i = 0; i <(S32)msg_ptr->param_1; i ++)
                {
                    IP4_input_previous_character();
                }
                break;
            case MMI_IMC_EDITOR_CURSOR_RIGHT:
                for (i = 0; i <(S32)msg_ptr->param_1; i ++)
                {
                    IP4_input_next_character();
                }
                break;
        }
        break;
        
    case MMI_IMC_MESSAGE_IS_BACKSPACE_DISABLED:
        lresult = MMI_TRUE;
        break;
        
#if defined(__MMI_TOUCH_SCREEN__)        
    case MMI_IMC_MESSAGE_PEN_EVENT:
        if (((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->mmi_pen_event == MMI_PEN_EVENT_DOWN)
        {
            if (PEN_CHECK_BOUND(((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos.x, 
                                ((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos.y, 
                                editor_ptr->input.x, editor_ptr->input.y, 
                                editor_ptr->input.width,
                                editor_ptr->input.height))
            {
                *((U32 *)msg_ptr->param_1) = 1;
                ret = MMI_TRUE;
            }
            else
            {
                ret = MMI_FALSE;
            }
        }
        else if (((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->mmi_pen_event == MMI_PEN_EVENT_UP)
        {
            if (PEN_CHECK_BOUND(((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos.x, 
                                ((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos.y, 
                                editor_ptr->input.x, editor_ptr->input.y, 
                                editor_ptr->input.width,
                                editor_ptr->input.height))
            {
                IP4_input_move_to_x_y(editor_ptr, 
                                   ((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos.x, 
                                   ((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos.y);
                ret = MMI_TRUE;
            }
            else
            {
                ret = MMI_FALSE;
            }
            
        }
        
        lresult = ret;
        
        break;
#endif

    default:
        break;
    }

    return lresult;
}


/*****************************************************************************
 * FUNCTION
 *  SetInlineItemIP4
 * DESCRIPTION
 *  set data of inline IP4 edit
 * PARAMETERS
 *  item        [IN]    inline item         
 *  b1          [IN]    address part 1     
 *  b2          [IN]    address part 2     
 *  b3          [IN]    address part 3     
 *  b4          [IN]    address part 4     
 *  f           [IN]    string construct callback    
 * RETURNS
 *  void
 *****************************************************************************/
void SetInlineItemIP4(
        InlineItem *item,
        U8 *b1,
        U8 *b2,
        U8 *b3,
        U8 *b4,
        void (*f) (U8 *string_buffer, U8 *b1, U8 *b2, U8 *b3, U8 *b4))
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_inline_item_IP4 *i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (n_inline_IP4_items >= MAX_INLINE_IP4_ITEMS)
    {
        return;
    }
    wgui_inline_mem_alloc_info[wgui_inline_mem_alloc_number] = item->item = wgui_inline_malloc(sizeof(wgui_inline_item_IP4));
    wgui_inline_mem_alloc_number++; 
    item->flags = INLINE_ITEM_TYPE_IP4_EDIT;
    wgui_inline_mem_alloc_info[wgui_inline_mem_alloc_number] = item->text_p = (U8*)wgui_inline_malloc(MAX_INLINE_IP4_DISPLAY_STRING_SIZE * sizeof(U8));
    wgui_inline_mem_alloc_number++; 
    n_inline_IP4_items++;
    i = (wgui_inline_item_IP4*) item->item;
    i->b1 = b1;
    i->b2 = b2;
    i->b3 = b3;
    i->b4 = b4;
    i->flags = INLINE_ITEM_LEFT_JUSTIFY;
    i->string_construct_callback = f;
    i->string_construct_callback(item->text_p, i->b1, i->b2, i->b3, i->b4);
    item->handler = handle_inline_IP4_edit;
}


/*****************************************************************************
 * FUNCTION
 *  ReConfigureInlineItemIP4
 * DESCRIPTION
 *  re-configure data of inline IP4 edit
 * PARAMETERS
 *  item        [IN]    inline item         
 *  b1          [IN]    address part 1     
 *  b2          [IN]    address part 2     
 *  b3          [IN]    address part 3     
 *  b4          [IN]    address part 4     
 *  f           [IN]    string construct callback        
 * RETURNS
 *  void
 *****************************************************************************/
void ReConfigureInlineItemIP4(
        InlineItem *item,
        U8 *b1,
        U8 *b2,
        U8 *b3,
        U8 *b4,
        void (*f) (U8 *string_buffer, U8 *b1, U8 *b2, U8 *b3, U8 *b4))
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_inline_item_IP4 *i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if ((item->flags & 0xff) != INLINE_ITEM_TYPE_IP4_EDIT)
    {
        return;
    }
    i = (wgui_inline_item_IP4*) item->item;
    i->b1 = b1;
    i->b2 = b2;
    i->b3 = b3;
    i->b4 = b4;
    i->flags = 0;
    i->string_construct_callback = f;
    i->string_construct_callback(item->text_p, i->b1, i->b2, i->b3, i->b4);
}



/*****************************************************************************
 * FUNCTION
 *  wgui_show_inline_IP4_list_menuitem
 * DESCRIPTION
 *  show inline IP4 list menuitem
 * PARAMETERS
 *  x1                  [IN]    left-top corner x1 coordinate    
 *  y1                  [IN]    left-top corner y1 coordinate    
 *  width               [IN]    width    
 *  height              [IN]    height          
 *  item                [IN]    inline item      
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_show_inline_IP4_list_menuitem(S32 x1, S32 y1, S32 width, S32 height, wgui_inline_item *item)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_inline_item_IP4 *i = (wgui_inline_item_IP4*) item->item;
#ifndef __MMI_FTE_SUPPORT__
    S32 xx;
#endif
    U32 dtflags = 0;
    IP4_input wgui_inline_IP4_input_display = {0};

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();
#ifndef __MMI_FTE_SUPPORT__
    if (MMI_fixed_icontext_menuitem.text_x == 2)
    {
        xx = -1;
    }
    else
    {
        xx = MMI_fixed_icontext_menuitem.text_x;
    }
    if (item->flags & INLINE_ITEM_LEFT_ALIGN)
    {
        xx = -1;
    }
#endif
    switch (item->flags & INLINE_ITEM_JUSTIFY_MASK)
    {
        case INLINE_ITEM_RIGHT_JUSTIFY:
            dtflags |= DATE_INPUT_RIGHT_JUSTIFY;
            break;
        case INLINE_ITEM_CENTER_JUSTIFY:
            dtflags |= DATE_INPUT_CENTER_JUSTIFY;
            break;
    }

    wgui_set_date_time_input_unfocussed_theme();
    
#ifndef __MMI_FTE_SUPPORT__    
    create_IP4_input(
        &wgui_inline_IP4_input_display,
        x1 - 1,
        y1,
        width + 1,
        height,
        dtflags,
        i->b1,
        i->b2,
        i->b3,
        i->b4);
    
#else
    create_IP4_input(
        &wgui_inline_IP4_input_display,
        x1,
        y1,
        width,
        height,
        dtflags,
        i->b1,
        i->b2,
        i->b3,
        i->b4);
#endif

#ifdef __MMI_FTE_SUPPORT__
    wgui_inline_IP4_input_display.input.flags |= IP4_INPUT_USE_PRESET_CLIP;
#endif

    IP4_input_set_seperator(&wgui_inline_IP4_input_display, (UI_character_type) '.');

    /* show the different background in case of default text effect is enabled
       for the inline item type IP4 Edit. */
#ifdef __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__
    if (IsInlineItemDefaultTextEnable())
    {
        inline_item_default_text_show_background(
            wgui_inline_IP4_input_display.input.x,
            wgui_inline_IP4_input_display.input.y,
            wgui_inline_IP4_input_display.input.x + wgui_inline_IP4_input_display.input.width - 1,
            wgui_inline_IP4_input_display.input.y + wgui_inline_IP4_input_display.input.height - 1);
    }
    else
#endif /* __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__ */ 

        IP4_input_show_background(&wgui_inline_IP4_input_display);
    IP4_input_reset_focus((void *)&wgui_inline_IP4_input_display);
    show_IP4_input(&wgui_inline_IP4_input_display);
    wgui_set_date_time_input_focussed_theme();
    gdi_layer_unlock_frame_buffer();
}
#endif /* __MMI_INLINE_ITEM_IP4__ */

#if defined (__MMI_INLINE_ITEM_COLOR_SELECT__)

/***************************************************************************** 
 * Inline Color Select    
 *
 * This is Inline Color Select Item
 *****************************************************************************/

/***************************************************************************** 
 * Define
 *****************************************************************************/
#define MAX_INLINE_COLOR_SELECT_ITEMS        4

/***************************************************************************** 
 * Local Variable
 *****************************************************************************/
static U16 n_inline_color_select_items = 0;

static gui_color_select_struct g_wgui_inline_cs_item;

static wgui_inline_item_color_select *current_wgui_inline_color_select_item = NULL;

/***************************************************************************** 
 * Function Implementation
 *****************************************************************************/
 
/*****************************************************************************
* FUNCTION
*  gui_color_select_create
* DESCRIPTION
*  create color select item
* PARAMETERS
*  cs					[IN]		color select item handle
*  x					[IN]
*  y					[IN]
*  width				[IN]
*  height				[IN]
*  n_color			[IN]		color sub item number
*  highlighted_index	[IN]		highlighted sub item index
*  start_index			[IN]		sub item start index
*  list_of_color		[IN]		sub item list
*  color_highlighted	[IN]		sub item highlight call back function
*  offset				[IN]		
*  flags				[IN]
* RETURNS
*  void
*****************************************************************************/
void gui_color_select_create(
        gui_color_select_struct *cs,
        U16 x,
        U16 y,
        U16 width,
        U16 height,
        U16 n_color,
        U16 highlighted_index,
        U16 start_index,
        color *list_of_color,
        void (*color_highlighted) (U16 index),
        U16 offset,
        U32 flags)
{
	/*----------------------------------------------------------------*/
	/* Local Variables												  */
	/*----------------------------------------------------------------*/
	S32 icon_width, icon_height, region_spacing;
#ifndef __MMI_FTE_SUPPORT__
    S32 icon_spacing;
#endif
	S32 used_width, region_width;

	/*----------------------------------------------------------------*/
	/* Code Body													  */
	/*----------------------------------------------------------------*/
	MMI_ASSERT(cs);
	cs->x = x;
	cs->y = y;
	cs->width = width;
	cs->height = height;
	cs->n_color = n_color;
	cs->highlighted_index = highlighted_index;
	cs->start_index = start_index;
	cs->list_of_color = list_of_color;
	cs->color_highlighted = color_highlighted;
	cs->flags = flags;

#ifndef __MMI_FTE_SUPPORT__
	cs->box_spacing = GUI_COLOR_SELECT_HEIGHT_SPACING;
	icon_spacing = GUI_COLOR_SELECT_ICON_SPACING;
	gui_measure_image((PU8)GetImage(IMG_H_SELECT_LEFT), &icon_width, &icon_height);
	region_spacing = icon_width + (2 * icon_spacing);

	if (mmi_fe_get_r2l_state())
	{
		cs->region_x1 = x + region_spacing - 4;
		cs->region_x2 = x + width - offset - region_spacing;
	}
	else
	{
		cs->region_x1 = x + offset + region_spacing - 4;
		cs->region_x2 = x + width - region_spacing;
	}

#ifdef __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__
	if (IsInlineItemDefaultTextEnable())
	{
		cs->region_x1 = x + region_spacing;
		cs->region_x2 = x + width - region_spacing;
	}
#endif 

	cs->region_y1 = y + cs->box_spacing;
	cs->region_y2 = y + height - cs->box_spacing;

	cs->icon1_x2 = cs->region_x1 - icon_spacing - 1;
	cs->icon1_x1 = cs->icon1_x2 - icon_width + 1;
	cs->icon2_x1 = cs->region_x2 + icon_spacing + 1;
	cs->icon2_x2 = cs->icon2_x1 + icon_width - 1;

    cs->icon_y = y + (height - icon_height)/2; //icon in middle

	cs->icon1_pressed = 0;
	cs->icon2_pressed = 0;

	cs->box_size = cs->region_y2 - cs->region_y1;
	cs->box_count = (U16)((cs->region_x2 - cs->region_x1 + 1 + cs->box_spacing) / (cs->box_size + cs->box_spacing));
	used_width = cs->box_size *cs->box_count + (cs->box_count - 1)*cs->box_spacing;
	region_width = cs->region_x2 - cs->region_x1 + 1;
	cs->region_x1 += (U16)((region_width - used_width) >> 1);
	cs->region_x2 -= (U16)((region_width - used_width) >> 1);

	if (cs->box_count > cs->n_color)
	{
		cs->box_count = cs->n_color;
		used_width = cs->box_size * cs->box_count + (cs->box_count - 1)*cs->box_spacing;
		region_width = cs->region_x2 - cs->region_x1 + 1;
		cs->region_x1 += (U16)((region_width - used_width) >> 1);
#ifdef __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__
		if (IsInlineItemDefaultTextEnable())
		{
			cs->region_x2 -= (U16) ((region_width - used_width) >> 1);
		}
#endif /* __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__ */ 
	}
#else
	cs->box_spacing = GUI_COLOR_SELECT_FTE_BOX_VERTICAL_GAP;
	gui_measure_image((PU8)(current_MMI_theme->inline_item_select_right_arrow_push_image), &icon_width, &icon_height);
	region_spacing = icon_width + GUI_COLOR_SELECT_FTE_BOX_BETWEEN_GAP;
	cs->region_x1 = x + region_spacing;
	cs->region_x2 = x + width - region_spacing - 1;
	cs->region_y1 = y + GUI_COLOR_SELECT_FTE_CONTROL_BORDER_WIDTH + GUI_COLOR_SELECT_FTE_BOX_VERTICAL_GAP;
	cs->region_y2 = y + height - GUI_COLOR_SELECT_FTE_CONTROL_BORDER_WIDTH - GUI_COLOR_SELECT_FTE_BOX_VERTICAL_GAP - 1;

	cs->icon1_x1 = x + GUI_COLOR_SELECT_FTE_CONTROL_BORDER_WIDTH;
	cs->icon1_x2 = cs->icon1_x1 + icon_width - 1;
	cs->icon2_x1 = x + width - icon_width - GUI_COLOR_SELECT_FTE_CONTROL_BORDER_WIDTH;
	cs->icon2_x2 = cs->icon2_x1 + icon_width - 1;
	cs->icon_y = y;
	cs->icon1_pressed = 0;
	cs->icon2_pressed = 0;
	cs->box_size = cs->region_y2 - cs->region_y1;
	cs->box_count = (U16)((cs->region_x2 - cs->region_x1 + 1 + cs->box_spacing) / (cs->box_size + cs->box_spacing));
	used_width = cs->box_size *cs->box_count + (cs->box_count - 1)*cs->box_spacing;
	region_width = cs->region_x2 - cs->region_x1 + 1;
	cs->region_x1 += (U16) ((region_width - used_width) >> 1);
	cs->region_x2 -= (U16) ((region_width - used_width) >> 1);
	if (cs->box_count > cs->n_color)
	{
		cs->box_count = cs->n_color;
		used_width = cs->box_size * cs->box_count + (cs->box_count - 1) *cs->box_spacing;
		region_width = cs->region_x2 - cs->region_x1 + 1;
		cs->region_x1 += (U16) ((region_width - used_width) >> 1);
#ifdef __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__
		if (IsInlineItemDefaultTextEnable())
		{
			cs->region_x2 -= (U16) ((region_width - used_width) >> 1);
		}
#endif /* __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__ */ 
	}
#endif
}


/*****************************************************************************
* FUNCTION
*  gui_color_select_show
* DESCRIPTION
*  show color select item
* PARAMETERS
*  cs				[IN]		color select item handle
* RETURNS
*  void
*****************************************************************************/
void gui_color_select_show(gui_color_select_struct *cs)
{
	/*----------------------------------------------------------------*/
	/* Local Variables												  */
	/*----------------------------------------------------------------*/
	S32 i;
	S32 box_x1;
	S32 box_x2;
	U16 start_index;
	U16 color_index;

	/*----------------------------------------------------------------*/
	/* Code Body													  */
	/*----------------------------------------------------------------*/
	/* pixtel name is too long, hard to read, set to local variable first */
	start_index = cs->start_index;

	/* need adjst start index */
	if (start_index == GUI_COLOR_SELECT_INIT_START_VALUE)
	{
		/* total color is less then box, always start at 0 */
		if (cs->box_count > cs->n_color)
		{
			start_index = 0;
		}
		else
		{
			if (cs->n_color - cs->highlighted_index >= cs->box_count)
			{
				/* remain color is more than box count */
				start_index = cs->highlighted_index;
			}
			else
			{
				/* remain color not enough */
				start_index = cs->n_color - cs->box_count;
			}

			cs->start_index = start_index;
		}
	}

	if (start_index + cs->box_count <= cs->highlighted_index)
	{
		start_index = cs->highlighted_index - cs->box_count + 1;
		cs->start_index = start_index;
	}

	/* fill the background of the focussed Color Select menu item with modified
	   parameters. */
#ifdef __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__
	if (IsInlineItemDefaultTextEnable())
		/* fill region with selected background color */
	{
		gui_draw_filled_area(
			cs->region_x1 - cs->box_spacing,
			cs->region_y1 - cs->box_spacing,
			cs->region_x2 + cs->box_spacing,
			cs->region_y2 + cs->box_spacing,
			current_MMI_theme->list_selected_item_filler);
	}
	else
#endif /* __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__ */ 

#ifndef __MMI_FTE_SUPPORT__
    if (cs->flags & UI_COLOR_SELECT_FOCUSED_STATE)
	{
		/* fill region with selected background color */
		gui_draw_filled_area(
			cs->icon1_x1 - 2,
			cs->region_y1 - 2,
			cs->icon2_x2 + 2,
			cs->region_y2 + 2,
			current_MMI_theme->list_selected_item_filler);
	}
#else
	{
		U8 *image = NULL;
		if (cs->flags & UI_COLOR_SELECT_FOCUSED_STATE)
		{
			image = current_MMI_theme->inline_item_color_select_highlighted_bg_image;
		}
		else
		{
			image = current_MMI_theme->inline_item_color_select_unhighlighted_bg_image;
		}
		gdi_image_draw_resized(
			cs->x, 
			cs->y, 
			cs->width, 
			cs->height, 
			image);
	}		 
#endif
	for (i = 0; i < cs->box_count; i++)
	{
		box_x1 = cs->region_x1 + (cs->box_size + cs->box_spacing) * i;
		box_x2 = box_x1 + cs->box_size;

		color_index = (U16) (start_index + i);

		if (color_index >= cs->n_color)
		{
			/* no more, get from firsr */
			color_index = color_index - cs->n_color;
		}
#ifdef __MMI_FTE_SUPPORT__
		if (color_index == cs->highlighted_index)
		{
			U8 *image = current_MMI_theme->inline_item_color_select_highlighted_index_image;
			gdi_handle active_layer;
			gdi_layer_get_active(&active_layer);
			gdi_push_and_set_alpha_blending_source_layer(active_layer);
			gdi_image_draw_resized(
				box_x1 - GUI_COLOR_SELECT_FTE_SELECTOR_BORDER, 
				cs->y, 
				box_x2 - box_x1 + (2 *	GUI_COLOR_SELECT_FTE_SELECTOR_BORDER) + 1,
				INLINE_FTE_CONTROL_HEIGHT,
				image);
		   gdi_pop_and_restore_alpha_blending_source_layer();
		}
#endif         
		gui_fill_rectangle(box_x1, cs->region_y1, box_x2, cs->region_y2, cs->list_of_color[color_index]);

		/* if is pure blue, draw cross */
		if (cs->list_of_color[color_index].r == 0 && cs->list_of_color[color_index].g == 0 && cs->list_of_color[color_index].b == 255)
		{
			gui_fill_rectangle(box_x1, cs->region_y1, box_x2, cs->region_y2, gui_color(255, 255, 255));
			gui_line(box_x1, cs->region_y1, box_x2, cs->region_y2, gui_color(0, 0, 0));
			gui_line(box_x2, cs->region_y1, box_x1, cs->region_y2, gui_color(0, 0, 0));
		}
		else
		{
			gui_fill_rectangle(box_x1, cs->region_y1, box_x2, cs->region_y2, cs->list_of_color[color_index]);
		}

		gui_draw_rectangle(box_x1 + 1, cs->region_y1 + 1, box_x2 - 1, cs->region_y2 - 1, gui_color(255, 255, 255));

		if (color_index == cs->highlighted_index)
		{
#ifndef __MMI_FTE_SUPPORT__            
			gui_draw_rectangle(box_x1, cs->region_y1, box_x2, cs->region_y2, gui_color(255, 0, 0));
			gui_draw_rectangle(box_x1 - 1, cs->region_y1 - 1, box_x2 + 1, cs->region_y2 + 1, gui_color(255, 0, 0));
#endif
		}
		else
		{
			gui_draw_rectangle(box_x1, cs->region_y1, box_x2, cs->region_y2, gui_color(0, 0, 0));
		}
	}

#ifdef __MMI_FTE_SUPPORT__
	{
		gdi_handle active_layer;
		U8 *image1;
		U8 *image2;
		S32 icon_width, icon_height;

		gui_measure_image((PU8)(current_MMI_theme->inline_item_select_right_arrow_push_image), &icon_width, &icon_height);
		if(cs->icon1_pressed == 0)
		{
			image1 = current_MMI_theme->inline_edit_left_arrow_image;
		}
		else
		{
			image1 = current_MMI_theme->inline_item_select_left_arrow_push_image;
		}
		if(cs->icon2_pressed == 0)
		{
			image2 = current_MMI_theme->inline_edit_right_arrow_image;
		}
		else
		{
			image2 = current_MMI_theme->inline_item_select_right_arrow_push_image;
		}
		gdi_layer_get_active(&active_layer);
		gdi_push_and_set_alpha_blending_source_layer(active_layer);
		gdi_image_draw_resized(
			cs->icon1_x1, 
			cs->y, 
			icon_width, 
			icon_height, 
			image1);
		gdi_image_draw_resized(
			cs->icon2_x1, 
			cs->y, 
			icon_width, 
			icon_height, 
			image2);	 
		gdi_pop_and_restore_alpha_blending_source_layer();
		
		gdi_layer_blt_previous(
			cs->x, 
			cs->y, 
			cs->width + cs->x, 
			cs->height + cs->y);		
	}
#else
	gui_show_image(
		cs->icon1_x1,
		cs->icon_y + cs->icon1_pressed,
		(PU8) GetImage(IMG_H_SELECT_LEFT));
	gui_show_image(
		cs->icon2_x1,
		cs->icon_y + cs->icon2_pressed,
		(PU8) GetImage(IMG_H_SELECT_RIGHT));

	gdi_layer_blt_previous(
		cs->icon1_x1 - 2,
		cs->region_y1 - 2,
		cs->icon2_x2 + 2,
		cs->region_y2 + 2);
#endif
}


/*****************************************************************************
* FUNCTION
*  gui_color_select_previous_item
* DESCRIPTION
*  go to previous item
* PARAMETERS
*  cs				[IN]		color select item handle
* RETURNS
*  void
*****************************************************************************/
void gui_color_select_previous_item(gui_color_select_struct *cs)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (cs->highlighted_index == 0)
    {
        cs->highlighted_index = cs->n_color - 1;

        cs->start_index = cs->n_color - cs->box_count;
    }
    else
    {
        cs->highlighted_index--;
        if (cs->highlighted_index < cs->start_index)
        {
            cs->start_index--;
        }
    }

	gui_color_select_show(cs);
    if (cs->color_highlighted != NULL)
    {
        cs->color_highlighted(cs->highlighted_index);
    }
}


/*****************************************************************************
* FUNCTION
*  gui_color_select_next_item
* DESCRIPTION
*  go to next item
* PARAMETERS
*  cs				[IN]		color select item handle
* RETURNS
*  void
*****************************************************************************/
void gui_color_select_next_item(gui_color_select_struct *cs)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (cs->highlighted_index >= cs->n_color - 1)
    {
        cs->highlighted_index = 0;
        cs->start_index = 0;
    }
    else
    {
        cs->highlighted_index++;

        if (cs->highlighted_index >= cs->start_index + cs->box_count)
        {
            cs->start_index++;
        }
    }

	gui_color_select_show(cs);
    if (cs->color_highlighted != NULL)
    {
        cs->color_highlighted(cs->highlighted_index);
    }
}


/*****************************************************************************
* FUNCTION
*  gui_color_select_left_up_handler
* DESCRIPTION
*  left select arrow pen up handler
* PARAMETERS
*  cs				[IN]		color select item handle
* RETURNS
*  void
*****************************************************************************/
void gui_color_select_left_up_handler(gui_color_select_struct *cs)
{
	/*----------------------------------------------------------------*/
	/* Local Variables												  */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body													  */
	/*----------------------------------------------------------------*/
	if (cs->key_icon1)
	{
		gui_color_select_previous_item(cs);
	}
	if (cs->icon1_pressed == 1)
	{
		cs->icon1_pressed = 0;
		gui_color_select_show(cs);
	}
}


/*****************************************************************************
* FUNCTION
*  gui_color_select_left_down_handler
* DESCRIPTION
*  left select arrow pen down handler
* PARAMETERS
*  cs				[IN]		color select item handle
* RETURNS
*  void
*****************************************************************************/
void gui_color_select_left_down_handler(gui_color_select_struct *cs)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    cs->key_icon1 = 1;
    cs->icon1_pressed = 1;
    gui_color_select_show(cs);
}


/*****************************************************************************
* FUNCTION
*  gui_color_select_right_up_handler
* DESCRIPTION
*  right select arrow pen up handler
* PARAMETERS
*  cs				[IN]		color select item handle
* RETURNS
*  void
*****************************************************************************/
void gui_color_select_right_up_handler(gui_color_select_struct *cs)
{
	/*----------------------------------------------------------------*/
	/* Local Variables												  */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body													  */
	/*----------------------------------------------------------------*/
	if (cs->key_icon2)
	{
		gui_color_select_next_item(cs);
	}
	if (cs->icon2_pressed == 1)
	{
		cs->icon2_pressed = 0;
		gui_color_select_show(cs);
	}
}


/*****************************************************************************
* FUNCTION
*  gui_color_select_right_down_handler
* DESCRIPTION
*  right select arrow pen down handler
* PARAMETERS
*  cs				[IN]		color select item handle
* RETURNS
*  void
*****************************************************************************/
void gui_color_select_right_down_handler(gui_color_select_struct *cs)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    cs->key_icon2 = 1;
    cs->icon2_pressed = 1;
    gui_color_select_show(cs);
}

#if defined(__MMI_TOUCH_SCREEN__)
/*****************************************************************************
 * FUNCTION
 *  inline_color_select_pen_handler
 * DESCRIPTION
 *  Pen handler of color picker
 * PARAMETERS
 *  cs				[IN]
 *  pen_event           	[IN]      pen event 
 *  x                   		[IN]      pen x position  
 *  y                   		[IN]      pen y pisition  
 * RETURNS
 *  void
 *****************************************************************************/
BOOL gui_color_select_pen_event(
        gui_color_select_struct *cs,
    	mmi_pen_event_type_enum pen_event,
    	S16 x,
    	S16 y)
{
	/*----------------------------------------------------------------*/
	/* Local Variables												  */
	/*----------------------------------------------------------------*/
	BOOL ret;
	S32 i;
	S32 box_xoffset, box_width;
	S32 x1, y1, x2, y2, region_width, region_height;
	BOOL in_left_arrow, in_right_arrow;

	/*----------------------------------------------------------------*/
	/* Code Body													  */
	/*----------------------------------------------------------------*/
	ret = MMI_TRUE;

	x1 = cs->region_x1;
	y1 = cs->region_y1;
	x2 = cs->region_x2;
	y2 = cs->region_y2;
	region_width = x2 - x1 + 1;
	region_height = y2 - y1 + 1;

	in_left_arrow = MMI_FALSE;
	in_right_arrow = MMI_FALSE;

	if (x >= cs->icon1_x1
		&& x <= cs->icon1_x2
		&& y >= cs->region_y1 && y <= cs->region_y2)
	{
		in_left_arrow = MMI_TRUE;
	}
	else if (x >= cs->icon2_x1
			 && x <= cs->icon2_x2
			 && y >= cs->region_y1 && y <= cs->region_y2)
	{
		in_right_arrow = MMI_TRUE;
	}

	switch (pen_event)
	{
		case MMI_PEN_EVENT_DOWN:
			cs->icon1_pressed = 0;
			cs->icon2_pressed = 0;
			cs->pen_on_icon1 = 0;
			cs->pen_on_icon2 = 0;

			if (in_left_arrow)
			{
				cs->pen_on_icon1 = 1;
				cs->icon1_pressed = 1;
				gui_color_select_show(cs);
			}
			else if (in_right_arrow)
			{
				cs->pen_on_icon2 = 1;
				cs->icon2_pressed = 1;
				gui_color_select_show(cs);
			}
			else if (PEN_CHECK_BOUND(x, y, x1, y1, region_width, region_height))
			{
				box_width = cs->box_size + cs->box_spacing;
				box_xoffset = x1 + box_width - 1;
				for (i = 0; i < cs->box_count; i++)
				{
					if (box_xoffset > x)
					{
						cs->highlighted_index =	i + cs->start_index;
						gui_color_select_show(cs);
						if (cs->color_highlighted != NULL)
						{
							cs->color_highlighted(cs->highlighted_index);
						}

						break;
					}

					box_xoffset += box_width;
				}
			}
			break;

		case MMI_PEN_EVENT_UP:
			if (cs->pen_on_icon1 && in_left_arrow)
			{
				gui_color_select_previous_item(cs);
			}
			else if (cs->pen_on_icon2 && in_right_arrow)
			{
				gui_color_select_next_item(cs);
			}

			if (cs->icon1_pressed || cs->icon2_pressed)
			{
				cs->icon1_pressed = 0;
				cs->icon2_pressed = 0;
				gui_color_select_show(cs);
			}
			break;

		case MMI_PEN_EVENT_MOVE:
			if (cs->pen_on_icon1)
			{
				if (in_left_arrow)
				{
					if (!cs->icon1_pressed)
					{
						cs->icon1_pressed = 1;
						gui_color_select_show(cs);
					}
				}
				else
				{
					if (cs->icon1_pressed)
					{
						cs->icon1_pressed = 0;
						gui_color_select_show(cs);
					}
				}
			}
			else if (cs->pen_on_icon2)
			{
				if (in_right_arrow)
				{
					if (!cs->icon2_pressed)
					{
						cs->icon2_pressed = 1;
						gui_color_select_show(cs);
					}
				}
				else
				{
					if (cs->icon2_pressed)
					{
						cs->icon2_pressed = 0;
						gui_color_select_show(cs);
					}
				}
			}
			break;

		case MMI_PEN_EVENT_LONG_TAP:
		case MMI_PEN_EVENT_REPEAT:
			break;

		case MMI_PEN_EVENT_ABORT:
			if (cs->icon1_pressed || cs->icon2_pressed)
			{
				cs->icon1_pressed = 0;
				cs->icon2_pressed = 0;
				gui_color_select_show(cs);
			}
			break;

		default:
			MMI_ASSERT(0);
	}

	return ret;
}
#endif


/*****************************************************************************
 * FUNCTION
 *  clear_inline_color_select_menu_keys
 * DESCRIPTION
 *  clear color inline select key handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void clear_inline_color_select_menu_keys(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    /* key rule. 09.10.17  KEY_EVENT_REPEAT */
    ClearKeyHandler(KEY_LEFT_ARROW, KEY_EVENT_REPEAT);
    ClearKeyHandler(KEY_RIGHT_ARROW, KEY_EVENT_REPEAT);
    ClearKeyHandler(KEY_LEFT_ARROW, KEY_EVENT_DOWN);
    ClearKeyHandler(KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
	ClearKeyHandler(KEY_LEFT_ARROW, KEY_EVENT_UP);
	ClearKeyHandler(KEY_RIGHT_ARROW, KEY_EVENT_UP);

    clear_keyboard_key_handler();
    clear_inline_item_keys = UI_dummy_function;
    UI_text_menuitem_scroll_time = UI_TEXT_MENUITEM_SCROLL_TIME;
}


/*****************************************************************************
 * FUNCTION
 *  inline_color_select_menu_change_complete
 * DESCRIPTION
 *  move out from inline color select
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void inline_color_select_menu_change_complete(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	if (current_wgui_inline_color_select_item)
	{
	    current_wgui_inline_color_select_item->start_index = g_wgui_inline_cs_item.start_index;
		current_wgui_inline_color_select_item->highlighted_index = g_wgui_inline_cs_item.highlighted_index;
	}
    clear_inline_color_select_menu_keys();
    wgui_inline_item_handled = 0;
    redraw_current_inline_item = UI_dummy_function;
    complete_inline_item_edit = UI_dummy_function;
#ifdef __MMI_TOUCH_SCREEN__
    wgui_current_inline_item_pen_function = UI_dummy_inline_item_pen_function;
#endif 

}


/*****************************************************************************
 * FUNCTION
 *  inline_color_select_menu_handle_up_arrow
 * DESCRIPTION
 *  inline color select up arrow handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void inline_color_select_menu_handle_up_arrow(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    inline_color_select_menu_change_complete();
    inline_fixed_list_goto_previous_item();
}


/*****************************************************************************
 * FUNCTION
 *  inline_color_select_menu_handle_down_arrow
 * DESCRIPTION
 *  inline color select down arrow handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void inline_color_select_menu_handle_down_arrow(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    inline_color_select_menu_change_complete();
    inline_fixed_list_goto_next_item();
}


/*****************************************************************************
 * FUNCTION
 *  inline_color_select_redraw
 * DESCRIPTION
 *  redraw color select item.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void inline_color_select_redraw(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_color_select_show(&g_wgui_inline_cs_item);
}


/*****************************************************************************
 * FUNCTION
 *  inline_color_select_left_arrow_up_handler
 * DESCRIPTION
 *  color select left arrow up handler.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void inline_color_select_left_arrow_up_handler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	gui_color_select_left_up_handler(&g_wgui_inline_cs_item);
}


/*****************************************************************************
 * FUNCTION
 *  inline_color_select_left_arrow_down_handler
 * DESCRIPTION
 *  color select left arrow up handler.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void inline_color_select_left_arrow_down_handler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	gui_color_select_left_down_handler(&g_wgui_inline_cs_item);
}


/*****************************************************************************
 * FUNCTION
 *  inline_color_select_right_arrow_down_handler
 * DESCRIPTION
 *  color select left arrow up handler.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void inline_color_select_right_arrow_down_handler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	gui_color_select_right_down_handler(&g_wgui_inline_cs_item);
}


/*****************************************************************************
 * FUNCTION
 *  inline_color_select_right_arrow_up_handler
 * DESCRIPTION
 *  color select left arrow up handler.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void inline_color_select_right_arrow_up_handler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	gui_color_select_right_up_handler(&g_wgui_inline_cs_item);
}

/*****************************************************************************
 * FUNCTION
 *  register_inline_color_select_menu_keys
 * DESCRIPTION
 *  register key handler when highlighted on inline color selection
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void register_inline_color_select_menu_keys(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* key rule. 09.10.17  KEY_EVENT_REPEAT */
    SetKeyHandler(inline_color_select_left_arrow_down_handler, KEY_LEFT_ARROW, KEY_EVENT_REPEAT);
    SetKeyHandler(inline_color_select_right_arrow_down_handler, KEY_RIGHT_ARROW, KEY_EVENT_REPEAT);
    SetKeyHandler(inline_color_select_menu_handle_up_arrow, KEY_UP_ARROW, KEY_EVENT_REPEAT);
    SetKeyHandler(inline_color_select_menu_handle_down_arrow, KEY_DOWN_ARROW, KEY_EVENT_REPEAT);
    SetKeyHandler(inline_color_select_menu_handle_up_arrow, KEY_VOL_UP, KEY_EVENT_REPEAT);
    SetKeyHandler(inline_color_select_menu_handle_down_arrow, KEY_VOL_DOWN, KEY_EVENT_REPEAT);
    
    SetKeyHandler(inline_color_select_left_arrow_down_handler, KEY_LEFT_ARROW, KEY_EVENT_DOWN);
    SetKeyHandler(inline_color_select_right_arrow_down_handler, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
    SetKeyHandler(inline_color_select_menu_handle_up_arrow, KEY_UP_ARROW, KEY_EVENT_DOWN);
    SetKeyHandler(inline_color_select_menu_handle_down_arrow, KEY_DOWN_ARROW, KEY_EVENT_DOWN);
    SetKeyHandler(inline_color_select_menu_handle_up_arrow, KEY_VOL_UP, KEY_EVENT_DOWN);
    SetKeyHandler(inline_color_select_menu_handle_down_arrow, KEY_VOL_DOWN, KEY_EVENT_DOWN);

	SetKeyHandler(inline_color_select_left_arrow_up_handler, KEY_LEFT_ARROW, KEY_EVENT_UP);
	SetKeyHandler(inline_color_select_right_arrow_up_handler, KEY_RIGHT_ARROW, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  inline_color_select_pen_handler
 * DESCRIPTION
 *  Pen handler of color picker
 * PARAMETERS
 *  pen_event           [IN]      pen event 
 *  x                   [IN]      pen x position  
 *  y                   [IN]      pen y pisition  
 *  inline_event        [IN]       inine pen enum       
 * RETURNS
 *  void
 *****************************************************************************/
#ifdef __MMI_TOUCH_SCREEN__
static BOOL inline_color_select_pen_handler(
                mmi_pen_event_type_enum pen_event,
                S16 x,
                S16 y,
                gui_inline_item_pen_enum *inline_event)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    BOOL ret;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    *inline_event = GUI_INLINE_ITEM_PEN_NONE;
    ret = gui_color_select_pen_event(
            &g_wgui_inline_cs_item,
            pen_event,
            x,
            y);
    return ret;
}

#endif /* __MMI_TOUCH_SCREEN__ */ 


/*****************************************************************************
 * FUNCTION
 *  handle_inline_color_select
 * DESCRIPTION
 *  activation function of inline color select
 * PARAMETERS
 *  x                   [IN]        Menuitem start position x
 *  y                   [IN]        Menuitem start position y
 *  width               [IN]        Menuitem width
 *  height              [IN]        Menuitem height
 *  key_code            [IN]        Not used
 *  key_event           [IN]        Not used
 *  text_p              [IN]        Not used
 *  item                [IN]        Selected item pointer
 *  flags               [IN]        Not used
 *  history_buffer      [IN]        Not used
 * RETURNS
 *  void
 *****************************************************************************/
static void handle_inline_color_select(
                S32 x,
                S32 y,
                S32 width,
                S32 height,
                S32 key_code,
                S32 key_event,
                U8 **text_p,
                void *item,
                U32 flags,
                U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    current_wgui_inline_color_select_item = (wgui_inline_item_color_select*) item;
    gui_color_select_create(
        &g_wgui_inline_cs_item,
        x,
        y,
        width,
        height,
        current_wgui_inline_color_select_item->n_color,
        current_wgui_inline_color_select_item->highlighted_index,
        current_wgui_inline_color_select_item->start_index,
        current_wgui_inline_color_select_item->list_of_color,
        current_wgui_inline_color_select_item->color_highlighted,
        MMI_fixed_icontext_menuitem.text_x,
        UI_COLOR_SELECT_FOCUSED_STATE);
    
    current_wgui_inline_color_select_item->color_highlighted(current_wgui_inline_color_select_item->highlighted_index);
    
    gui_color_select_show(&g_wgui_inline_cs_item);
    register_inline_color_select_menu_keys();
    
    clear_inline_item_keys = clear_inline_select_menu_keys;
    complete_inline_item_edit = inline_color_select_menu_change_complete;
    redraw_current_inline_item = inline_color_select_redraw;
#ifdef __MMI_TOUCH_SCREEN__
    wgui_current_inline_item_pen_function = inline_color_select_pen_handler;
#endif 
}


/*****************************************************************************
 * FUNCTION
 *  wgui_show_inline_color_select_list_menuitem
 * DESCRIPTION
 *  show inline color select list menuitem
 * PARAMETERS
 *  x1                  [IN]    left-top corner x1 coordinate    
 *  y1                  [IN]    left-top corner y1 coordinate    
 *  width               [IN]    width    
 *  height              [IN]    height          
 *  item                [IN]    inline item      
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_show_inline_color_select_list_menuitem(
                S32 x,
                S32 y,
                S32 width,
                S32 height,
                wgui_inline_item *item)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gui_color_select_struct wgui_inline_color_select_display;
	wgui_inline_item_color_select *item_ptr;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    item_ptr = (wgui_inline_item_color_select*) item->item;
	gui_color_select_create(
		&wgui_inline_color_select_display,
		x,
		y,
		width,
		height,
		item_ptr->n_color,
		item_ptr->highlighted_index,
		item_ptr->start_index,
		item_ptr->list_of_color,
		item_ptr->color_highlighted,
		MMI_fixed_icontext_menuitem.text_x,
		0);

	gui_color_select_show(&wgui_inline_color_select_display);
}


/*****************************************************************************
 * FUNCTION
 *  SetInlineItemColorSelect
 * DESCRIPTION
 *  Set color inline selection
 * PARAMETERS
 *  item                    [IN]        Inline item pointer
 *  n_color                 [IN]        Number of color
 *  hilighted_index         [IN]        Highlighed color index
 *  list_of_color           [IN]        Array of colors
 *  color_highlighted       [IN]        Color highlighted callback function
 * RETURNS
 *  void
 *****************************************************************************/
void SetInlineItemColorSelect(
        InlineItem *item,
        S32 n_color,
        U16 hilighted_index,
        color *list_of_color,
        void (*color_highlighted) (U16 index))
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_inline_item_color_select *i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* check if still have room for another item */
    MMI_ASSERT(n_inline_color_select_items < MAX_INLINE_COLOR_SELECT_ITEMS);
    MMI_ASSERT(hilighted_index < n_color);

    wgui_inline_mem_alloc_info[wgui_inline_mem_alloc_number] = item->item = wgui_inline_malloc(sizeof(wgui_inline_item_color_select));
    wgui_inline_mem_alloc_number++; 
    item->flags = INLINE_ITEM_TYPE_COLOR_SELECT;

    i = (wgui_inline_item_color_select*) item->item;

    i->flags = 0;
    i->list_of_color = list_of_color;
    i->highlighted_index = hilighted_index;
    i->n_color = (U16) n_color;
    i->color_highlighted = color_highlighted;

    item->handler = handle_inline_color_select;

    /* notify start index need re-adjust */
    i->start_index = GUI_COLOR_SELECT_INIT_START_VALUE;

    n_inline_color_select_items++;
}

#endif

#if defined(__MMI_INSCREEN_MULTILINE_TEXTBOX__)
#if defined( __MMI_INLINE_ITEM_MULTILINE_READ_ONLY__) || defined( __MMI_INLINE_ITEM_MULTILINE_EDIT__)
/***************************************************************************** 
 * Inline Multiline Edit & Inline Multiline Edit Read Only  
 *
 * This is Multiline Edit Item
 *****************************************************************************/
typedef struct
{
    MMI_BOOL IsUse;
    S32 text_offset_y;
    UI_buffer_type cursor_p;
}ml_cursor_history;

static ml_cursor_history curr_cursor_history;
static S32 reset_pre_hdlr = 0;

/***************************************************************************** 
 * Local Variable
 *****************************************************************************/
static U8 inscreen_multi_line_change_flag = 0;
static U8 wgui_inline_inputbox_information_flag;
static S8 MMI_inline_multi_line_inputbox_present;
/***************************************************************************** 
 * Extern Global Function
 *****************************************************************************/
extern void wgui_redraw_input_information_background(void);


/***************************************************************************** 
 * Function Implementation
 *****************************************************************************/
/*****************************************************************************
 * FUNCTION
 *  SetInlineItemMultiLineHeight
 * DESCRIPTION
 *  Set inline multiline height
 * PARAMETERS
 *  item        [IN]
 *  n_item      [IN]    
 * RETURNS
 *  void
 *****************************************************************************/
void SetInlineItemMultiLineHeight(InlineItem *item, S32 n_item)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_inline_item_text_edit *i;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    i = (wgui_inline_item_text_edit*) item->item;
    ASSERT(i != NULL);
    if((item->flags && INLINE_ITEM_TYPE_MULTI_LINE_EDIT) ||
       (item->flags && INLINE_ITEM_TYPE_MULTI_LINE_RD_ONLY)
      )
    {
        i->height_of_item = (U8)n_item;
        i->max_lines= (U8)n_item; 
    }   
}

/*****************************************************************************
 * FUNCTION
 *  SetInlineItemMultiLineCursor_p
 * DESCRIPTION
 *  Set inline multiline Cursor p
 * PARAMETERS
 *  item        [IN]
 *  Cursor_p      [IN]    Current cursor postion
 * RETURNS
 *  void
 *****************************************************************************/
void SetInlineItemMultiLineCursor_p(InlineItem *item, PU8 Cursor_p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_inline_item_text_edit *i;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    i = (wgui_inline_item_text_edit*) item->item;
    ASSERT(i != NULL);
    if(item->flags && INLINE_ITEM_TYPE_MULTI_LINE_EDIT)
    {
        i->cursor_p = (PU8)Cursor_p;
    }   
}


/*****************************************************************************
 * FUNCTION
 *  SetInlineItemMultiLineEdit
 * DESCRIPTION
 *  set data of inline multi line edit
 * PARAMETERS
 *  item            [IN]    inline item         
 *  buffer          [IN]    buffer      
 *  title           [IN]    title string     
 *  buffer_size     [IN]    size of buffer    
 *  input_type      [IN]    input type    
 * RETURNS
 *  void
 *****************************************************************************/
void SetInlineItemMultiLineEdit(InlineItem *item, U8 *buffer, U8 *title, S32 buffer_size, U32 input_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_inline_item_text_edit *i;
    UI_buffer_type mask_buffer;
    U32 t = input_type & INPUT_TYPE_MASK;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (n_inline_text_edit_items >= MAX_INLINE_TEXT_EDIT_ITEMS)
    {
        return;
    }
    wgui_inline_mem_alloc_info[wgui_inline_mem_alloc_number] = item->item = wgui_inline_malloc(sizeof(wgui_inline_item_text_edit));
    wgui_inline_mem_alloc_number++; 
    item->flags = INLINE_ITEM_TYPE_MULTI_LINE_EDIT;
    n_inline_text_edit_items++;
    i = (wgui_inline_item_text_edit*) item->item;
    i->mask_buffer = NULL;
    i->max_lines = 0;
    i->title = 0;
    i->title_icon = 0;
    i->buffer = buffer;
    i->buffer_size = buffer_size;
	i->cursor_p = NULL;
    i->flags = 0;
    i->input_type = input_type;
    item->text_p = i->buffer;
    i->height_of_item = 3;

    item->handler = handle_inline_multi_line_edit;
    i->edit_complete_callback = UI_dummy_edit_complete_handler;
    i->custom_setup_function = NULL;
    i->validation_callback = UI_dummy_validation_function;

    if ((t == IMM_INPUT_TYPE_NUMERIC_PASSWORD) || (t == IMM_INPUT_TYPE_ALPHANUMERIC_PASSWORD) ||
        (t == IMM_INPUT_TYPE_SAT_NUMERIC_PASSWORD) || (t ==IMM_INPUT_TYPE_ASCII_PASSWORD))
    {
        wgui_inline_mem_alloc_info[wgui_inline_mem_alloc_number] =  mask_buffer = (U8*)wgui_inline_malloc(MAX_INLINE_TEXT_EDIT_BUFFER_SIZE * sizeof(U8));          
        wgui_inline_mem_alloc_number++; 
        inline_edit_prepare_mask_buffer(buffer, mask_buffer);
        i->mask_buffer = mask_buffer;
        item->text_p = mask_buffer;
    }
    i->UCS2_count = -1;
    MMI_multi_line_inputbox_present = 1;

    MMI_multiline_inputbox.flags = 0;
}


#if defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN)
extern gui_list_smooth_scrolling_by_pen_state_enum g_gui_ssp_state;
#endif /* GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN */

#if defined(__MMI_TOUCH_SCREEN__)
/*****************************************************************************
 * FUNCTION
 *  inline_multiline_edit_pen_handler
 * DESCRIPTION
 *  pen handler of inline multiline edit
 * PARAMETERS
 *  pen_event       [IN]    pen event    
 *  x               [IN]    pen x position    
 *  y               [IN]    pen y pisition    
 *  item_event      [?]     inline pen enum    
 * RETURNS
 *  BOOL
 *****************************************************************************/
static BOOL inline_multi_line_edit_pen_handler(
                mmi_pen_event_type_enum pen_event,
                S16 x,
                S16 y,
                gui_inline_item_pen_enum *item_event)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    BOOL ret = TRUE;
    static S32 down_x = -1, down_y = -1;
    static S32 maybe_list_ssp = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	*item_event = GUI_INLINE_ITEM_PEN_NONE;
	    
    gdi_layer_set_clip(
        MMI_fixed_list_menu.x, 
        MMI_fixed_list_menu.y, 
        MMI_fixed_list_menu.x + MMI_fixed_list_menu.width - 1,
        MMI_fixed_list_menu.y + MMI_fixed_list_menu.height - 1);
    
    if(pen_event == MMI_PEN_EVENT_DOWN)
    {
        if(!PEN_CHECK_BOUND(
            x,
            y,
            MMI_multiline_inputbox.x,
            MMI_multiline_inputbox.y,
            MMI_multiline_inputbox.width,
            MMI_multiline_inputbox.height))
        {
            return MMI_FALSE;
        }
        down_x = x;
        down_y = y;
    }
    
#ifdef __MMI_EDITOR_SSP_SUPPORT__

    switch (pen_event)
    {
        case MMI_PEN_EVENT_DOWN:
        {
            maybe_list_ssp = 0;
            if ((gui_input_box_ssp_get_state() != GUI_INPUT_BOX_SSP_STATE_UNFOCUS) && (reset_pre_hdlr == 0)) 
            {
                wgui_pen_reset_pre_hdlr();
                reset_pre_hdlr = 1;
            }
            if(MMI_multiline_inputbox.text_offset_y == 0)
            {
                maybe_list_ssp = 1;
            }
            break;
        }    
        case MMI_PEN_EVENT_UP:
        case MMI_PEN_EVENT_ABORT:
        {   
            if (reset_pre_hdlr)
            {
                wgui_pen_restore_pre_hdlr();
                reset_pre_hdlr = 0;
            }
            break;
        }
        case MMI_PEN_EVENT_MOVE:
        {
            if((maybe_list_ssp) &&(reset_pre_hdlr == 1) && (!mmi_imc_is_clipboard_state()))
            {
                if(y > down_y)
                {
                    wgui_pen_restore_pre_hdlr();
                #if defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN)
                    g_gui_ssp_state = GUI_LIST_SMOOTH_SCROLLING_BY_PEN_STATE_FOCUS;
                #endif /* GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN */
                    reset_pre_hdlr = 0;
                }
                else
                {
                    maybe_list_ssp = 0;
                }
            }
			break;
        }
        default:
            /* ignored events */
            break;
    }
#endif /* __MMI_EDITOR_SSP_SUPPORT__ */
    return ret;
}
#endif /* __MMI_TOUCH_SCREEN__ */

/*****************************************************************************
 * FUNCTION
 *  handle_inline_multi_line_edit
 * DESCRIPTION
 *  activation function of inline multi line edit
 * PARAMETERS
 *  x                   [IN]        left corner's x coordinate
 *  y                   [IN]        left corner's y coordinate
 *  width               [IN]        width
 *  height              [IN]        height
 *  key_code            [IN]        key code
 *  key_event           [IN]        key event
 *  text_p              [IN]        text pointer
 *  item                [IN]        inline item
 *  flags               [IN]        flags
 *  history_buffer      [IN]        history buffer          
 * RETURNS
 *  void
 *****************************************************************************/
void handle_inline_multi_line_edit(
        S32 x,
        S32 y,
        S32 width,
        S32 height,
        S32 key_code,
        S32 key_event,
        U8 **text_p,
        void *item,
        U32 flags,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 input_type;
    wgui_inline_item_text_edit *i = (wgui_inline_item_text_edit*) item;
    S32 inputbox_x = x;
    S32 inputbox_y = y;
    S32 inputbox_width = width + 2;
#ifndef __MMI_FTE_SUPPORT__    
       S32 inputbox_height  = i->height_of_item * MMI_MENUITEM_HEIGHT;
#else
    S32 inputbox_height = height;
#endif
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	/*
	 * when multiline is redraw, we not hope to create new multiline and show, but maybe there is a resize for VK.
	*/
    if ((g_inline_redraw_entered) && (current_wgui_inline_text_edit_item == i))
    {
        S32 temp_height = inputbox_height;
		/* Information Bar For Inline Multiline */
#if !defined(__MMI_FTE_SUPPORT__)
		/* Inline Multiline Control Information Bar Height Change */
		wgui_inputbox_information_bar_height = INFORMATION_BAR_HEIGHT;
		wgui_inputs_setup_input_information(inputbox_x + 2, inputbox_y + 1, inputbox_width - 5, wgui_inputbox_information_bar_height);
		/* Inline Multiline Control Information Bar Height Change */
		wgui_inputs_ml_move(inputbox_x, inputbox_y + wgui_inputbox_information_bar_height + 2);
#else /* __MMI_FTE_SUPPORT__ */
		wgui_inputs_ml_move(inputbox_x, inputbox_y);
#endif /* __MMI_FTE_SUPPORT__ */
#if !defined(__MMI_TOUCH_SCREEN__)
        temp_height -= wgui_inputbox_information_bar_height - 2;
		if (MMI_multiline_inputbox.height != temp_height)
		{
		    wgui_inputs_ml_resize(inputbox_width - 2, temp_height);
		}
#else 
		if (MMI_multiline_inputbox.height != temp_height)
		{
		    wgui_inputs_ml_resize(inputbox_width - 2, temp_height);
		}
#endif 
		return ;
    }

    MMI_multi_line_inputbox_present = 1;
    wgui_current_inline_item_type = INLINE_ITEM_TYPE_MULTI_LINE_EDIT;   /* Should Be Present. */

    UI_UNUSED_PARAMETER(key_code);
    UI_UNUSED_PARAMETER(key_event);
    UI_UNUSED_PARAMETER(flags);

    gdi_layer_lock_frame_buffer();
    wgui_text_menuitem_reset_scrolling();
    wgui_current_inline_item_type = INLINE_ITEM_TYPE_MULTI_LINE_EDIT;
    current_wgui_inline_text_edit_item = i;
    current_wgui_inline_text_edit_text_p = text_p;
    input_type = i->input_type;
    if (!(flags & INLINE_ITEM_OPEN))
    {
        history_buffer = NULL;
    }
    if(cui_inline_is_current_cui())
    {
        cui_inline_item_replace_gui_buffer(wgui_inline_item_highlighted_index, &wgui_inline_items[wgui_inline_item_highlighted_index], &history_buffer);
    }
    i->flags &= ~INLINE_ITEM_OPEN;

    wgui_inputbox_validation_callback = i->validation_callback;
    wgui_multiline_setup_inputbox(
        inputbox_x,
        inputbox_y,
        inputbox_width,
        inputbox_height,
        i->buffer,
        i->buffer_size,
        INLINE_MULTI_LINE_EDIT_HISTORY_ID,
        inline_text_edit_RSK_label_string,
        0,
        (S16) input_type,
        history_buffer,
#ifdef __MMI_FTE_SUPPORT__
        0
#else
        1
#endif
        );


	/*****************************************************************************
	*  if first enter ml edit, set user cursor position
	*  else if have gui history, set gui history
	*  else if have cursor history, set cursor history
	*  else nothing
	*****************************************************************************/
    if (history_buffer == NULL)
    {
		if ((!mmi_frm_scrn_get_active_gui_buf()) && (i->cursor_p))
		{
		    MMI_multiline_inputbox.cursor_p = (PU8)i->cursor_p;
			i->cursor_p = NULL;
		}
        else if (curr_cursor_history.IsUse)
        {
			MMI_multiline_inputbox.cursor_p = curr_cursor_history.cursor_p;
			MMI_multiline_inputbox.text_offset_y = curr_cursor_history.text_offset_y;
        }
    }
	curr_cursor_history.IsUse = MMI_FALSE;

    MMI_multiline_inputbox.flags |= UI_MULTI_LINE_INPUT_BOX_USE_PRESET_CLIPPING;

#if defined(__MMI_MULTITAP_FOR_STAR_AND_POUND__)
    set_left_softkey_label((UI_string_type) get_string(STR_GLOBAL_OPTIONS));
    SetLeftSoftkeyFunction(EntryInLineMultilineEditorOption, KEY_EVENT_UP);
    if(cui_inline_is_current_cui())
    {
        set_softkey_function(EntryInLineMultilineEditorOption, KEY_EVENT_UP, MMI_CENTER_SOFTKEY);
    }
#endif /* defined(__MMI_MULTITAP_FOR_STAR_AND_POUND__) */ 
    register_left_softkey_handler();
    register_right_softkey_handler();
    register_multiline_inputbox_input_callback(wgui_inline_edit_handle_multiline_inputbox_input);
    wgui_inputbox_RSK_function = wgui_inline_edit_BACK_function;
    redraw_current_inline_item = wgui_show_inputbox;    
	
	wgui_inputs_ml_set_RSK();
	if (gui_multi_line_input_box_get_text_length(&MMI_multiline_inputbox) > 0)
	{
        if (mmi_frm_kbd_is_key_supported(KEY_CLEAR))
        {
            set_right_softkey_label((UI_string_type) get_string(STR_GLOBAL_BACK));
            set_right_softkey_function(wgui_inline_edit_register_BACK_function, KEY_EVENT_DOWN);
        }
	}
	else
	{
		wgui_inline_text_edit_set_RSK_BACK_function();
	}
	
    if(cui_inline_is_current_cui())
    {
       cui_inline_evt_item_activate(); 
    }
    else
    {
        if (i->custom_setup_function != NULL)
        {
            i->custom_setup_function();
        }
    }

    wgui_show_inputbox();
#ifdef __MMI_TOUCH_SCREEN__
    wgui_current_inline_item_pen_function = inline_multi_line_edit_pen_handler;
#endif
    complete_inline_item_edit = handle_inline_multi_line_edit_complete;

    /*
     * For IME auto-capitalization, to update input mode by cursor 
     * position, because inline create editor after connecting IME
     */
    mmi_imc_update_input_mode_by_cursor_pos();
    
    mmi_imc_redraw_screen_by_state();
    gdi_layer_unlock_frame_buffer();
    gdi_lcd_repaint_all();
}


/*****************************************************************************
 * FUNCTION
 *	inline_multiline_edit_get_cursor_history
 * DESCRIPTION
 *	get edit cursor history
 *	if first enter ml edit, set user cursor position
 *	else if have gui history, set gui history
 *	else if have cursor history, set cursor history
 *	else nothing
 * PARAMETERS
 *	void	   
 * RETURNS
 *	void
 *****************************************************************************/
static void inline_multiline_edit_get_cursor_history(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables												  */
	/*----------------------------------------------------------------*/
	
	/*----------------------------------------------------------------*/
	/* Code Body													  */
	/*----------------------------------------------------------------*/
	curr_cursor_history.cursor_p = MMI_multiline_inputbox.cursor_p;
	curr_cursor_history.text_offset_y = MMI_multiline_inputbox.text_offset_y;
	curr_cursor_history.IsUse = MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *	inline_multiline_edit_clear_cursor_history
 * DESCRIPTION
 *	clear edit cursor history
 *	if first enter ml edit, set user cursor position
 *	else if have gui history, set gui history
 *	else if have cursor history, set cursor history
 *	else nothing
 * PARAMETERS
 *	void	   
 * RETURNS
 *	void
 *****************************************************************************/
void inline_multiline_edit_clear_cursor_history(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables												  */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body													  */
    /*----------------------------------------------------------------*/
    curr_cursor_history.cursor_p = NULL;
    curr_cursor_history.text_offset_y = 0;
    curr_cursor_history.IsUse = MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  handle_inline_multi_line_edit_complete
 * DESCRIPTION
 *  complete function of inline multi line edit
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void handle_inline_multi_line_edit_complete(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 input_type;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    handle_inline_full_screen_edit_close();
	inline_multiline_edit_get_cursor_history();
    input_type = current_wgui_inline_text_edit_item->input_type & INPUT_TYPE_MASK;
    current_wgui_inline_item->flags &= ~INLINE_ITEM_OPEN;
    if (inline_full_screen_edit_changed)
    {
		current_wgui_inline_item->flags |= INLINE_ITEM_CHANGED;
    }
    current_wgui_inline_text_edit_item->UCS2_count = MMI_multiline_inputbox.UCS2_count;
    if ((input_type == IMM_INPUT_TYPE_NUMERIC_PASSWORD) || (input_type == IMM_INPUT_TYPE_ALPHANUMERIC_PASSWORD) ||
        (input_type == IMM_INPUT_TYPE_SAT_NUMERIC_PASSWORD) || (input_type ==IMM_INPUT_TYPE_ASCII_PASSWORD))
    {
        inline_edit_prepare_mask_buffer(
            current_wgui_inline_text_edit_item->buffer,
            current_wgui_inline_text_edit_item->mask_buffer);
        *current_wgui_inline_text_edit_text_p = current_wgui_inline_text_edit_item->mask_buffer;
    }
    else
    {
        *current_wgui_inline_text_edit_text_p = current_wgui_inline_text_edit_item->buffer;
    }

    reset_softkeys();
    /* W06.05 Temp Solution Do not draw fixed list in category57 because of virtual keyboard */
#if !defined(__MMI_TOUCH_SCREEN__)
    wgui_close_inputbox();
#endif 
    mmi_imc_disconnect();
    clear_left_softkey();
    clear_right_softkey();

    register_left_softkey_handler();
    register_right_softkey_handler();

    wgui_inline_item_handled = 0;

    current_wgui_inline_text_edit_item->edit_complete_callback(
                                            current_wgui_inline_text_edit_item->buffer,
                                            current_wgui_inline_text_edit_item->buffer_size);

    redraw_current_inline_item = UI_dummy_function;
    wgui_inputbox_UCS2_count_function = NULL;
    wgui_inputbox_not_empty_callback = NULL;
    wgui_inputbox_empty_callback = NULL;
    wgui_inputbox_validation_callback = NULL;
    inline_full_screen_edit_changed = 0;
    complete_inline_item_edit = UI_dummy_function;
    StopTimer(BLINKING_CURSOR);
    g_is_inline_multiline_highlighted = MMI_FALSE;

#ifdef __MMI_FTE_SUPPORT__	
	mmi_imc_set_vk_present(MMI_IMC_VK_DEFAULT_ENLARGE);
#endif	
}


/*****************************************************************************
 * FUNCTION
 *  mmi_input_box_msg_call_back_inline_multiline
 * DESCRIPTION
 *  message callback function of inline multiline for IME
 * PARAMETERS
 *  editor_ptr          [IN]      multiline input pointer  
 *  msg_ptr             [IN]      message pointer       
 * RETURNS
 *  U32
 *****************************************************************************/
static U32 mmi_input_box_msg_call_back_inline_multiline(void * input_box_handle, mmi_imc_message_struct_p msg_ptr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    multi_line_input_box * editor_ptr;
    U32 lresult = 0;
    
    
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    editor_ptr = (multi_line_input_box *)((mmi_editor_handler_struct *)input_box_handle)->input_box_handler;
    
    MMI_ASSERT(editor_ptr == &MMI_multiline_inputbox);

    switch (msg_ptr->message_id)
    {
    case MMI_IMC_MESSAGE_REDRAW:

        //memcpy(editor_ptr, &g_inline_multiline_backup_struct, sizeof(multi_line_input_box));
        
        editor_ptr->flags = g_is_inline_multiline_flags;

        if (g_is_inline_multiline_highlighted)
        {
            editor_ptr->flags |= UI_MULTI_LINE_INPUT_BOX_WORD_HIGHLIGHT;
        }
        else
        {
            editor_ptr->flags &= ~UI_MULTI_LINE_INPUT_BOX_WORD_HIGHLIGHT;
        }
        editor_ptr->cursor_p = editor_ptr->text + g_inline_multiline_current_position;
        editor_ptr->last_cursor_offset = g_inline_multiline_last_cursor_offset;
        editor_ptr->text_offset_x = g_inline_multiline_text_offset_x;
        editor_ptr->available_length = g_inline_multiline_available_length;
        editor_ptr->highlight_start_position = g_is_inline_multiline_highlight_start_position;
        editor_ptr->highlight_end_position = g_is_inline_multiline_highlight_end_position;
        editor_ptr->input_mode_cursor_p = g_inline_multiline_input_mode_cursor_p;
        editor_ptr->input_start_cursor_p = g_inline_multiline_input_start_cursor_p;

        editor_ptr->flags |= UI_MULTI_LINE_INPUT_BOX_DISABLE_DRAW;
        gui_show_multi_line_input_box(editor_ptr);          /* show multi line input box */
        editor_ptr->flags &= ~UI_MULTI_LINE_INPUT_BOX_DISABLE_DRAW;
        show_multiline_inputbox();
        
        break;
        
    case MMI_IMC_MESSAGE_HILIGHT_BFCURSOR:
        g_is_inline_multiline_highlighted = MMI_TRUE;
        editor_ptr->flags |= UI_MULTI_LINE_INPUT_BOX_WORD_HIGHLIGHT;
        gui_multi_line_input_box_highlight_cursor_number(editor_ptr, (S32)msg_ptr->param_0);
        wgui_inputs_ml_redraw();
        break;
        
    case MMI_IMC_MESSAGE_CLEAR_HILIGHT:
        editor_ptr->flags &= ~UI_MULTI_LINE_INPUT_BOX_WORD_HIGHLIGHT;
        g_is_inline_multiline_highlighted = MMI_FALSE;
        
        break;

    case MMI_IMC_MESSAGE_SET_KEY:
        wgui_inputs_ml_set_RSK();
		if (gui_multi_line_input_box_get_text_length(&MMI_multiline_inputbox) > 0)
		{
            if (mmi_frm_kbd_is_key_supported(KEY_CLEAR))
            {
                set_right_softkey_label((UI_string_type) get_string(STR_GLOBAL_BACK));
                set_right_softkey_function(wgui_inline_edit_register_BACK_function, KEY_EVENT_DOWN);
            }
		}
		else
        {
            wgui_inline_text_edit_set_RSK_BACK_function();
        }
        wgui_inputs_ml_register_keys();
        break;

    case MMI_IMC_MESSAGE_REPLACE_HIGHLIGHT_STRING:

        lresult = mmi_input_box_msg_call_back_multiline(input_box_handle, msg_ptr);
        
        if (lresult > 0)
        {
            g_is_inline_multiline_highlighted = MMI_TRUE; 
        }
        break;


    case MMI_IMC_MESSAGE_HAS_SSP_ACTED:
    {
        if(gui_screen_smooth_scrolling_moved_by_pen())
        {
            lresult = MMI_TRUE;
        }
        else
        {
            lresult = mmi_input_box_msg_call_back_multiline(input_box_handle, msg_ptr);
        }
        break;
    }
    
    case MMI_IMC_MESSAGE_CLIPBOARD_SAVE_STATUS:
    {
#if defined(__MMI_TOUCH_SCREEN__) && defined(__MMI_FTE_SUPPORT__)
        if(reset_pre_hdlr == 0)
        {
            wgui_pen_reset_pre_hdlr();
            reset_pre_hdlr = 1;
        }       
#endif
        g_is_inline_multiline_highlighted = MMI_TRUE; 
        lresult = mmi_input_box_msg_call_back_multiline(input_box_handle, msg_ptr);
        break;
    }
    case MMI_IMC_MESSAGE_CLIPBOARD_RESTORE_STATUS:
    {
#if defined(__MMI_TOUCH_SCREEN__) && defined(__MMI_FTE_SUPPORT__)
        if(reset_pre_hdlr == 1)
        {
            wgui_pen_restore_pre_hdlr();
            reset_pre_hdlr = 0;
        }       
        
#endif
        g_is_inline_multiline_highlighted = MMI_FALSE; 
        lresult = mmi_input_box_msg_call_back_multiline(input_box_handle, msg_ptr);
        break;
    }
        
    default:
        return mmi_input_box_msg_call_back_multiline(input_box_handle, msg_ptr);
    }

    return lresult;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_show_inline_inscreen_multi_line_edit
 * DESCRIPTION
 *  show inline inscreen multi line edit
 * PARAMETERS
 *  x1                  [IN]    left-top corner x1 coordinate    
 *  y1                  [IN]    left-top corner y1 coordinate    
 *  width               [IN]    width    
 *  height              [IN]    height          
 *  item                [IN]    inline item          
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_show_inline_inscreen_multi_line_edit(S32 x1, S32 y1, S32 width, S32 height, wgui_inline_item *item)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_inline_item_text_edit *i = (wgui_inline_item_text_edit*) item->item;
    S32 inputbox_x = x1;
    S32 inputbox_y = y1;
    S32 inputbox_width = width;
    multi_line_input_box *MMI_inline_multiline_inputbox;

#ifndef __MMI_FTE_SUPPORT__
    S32 inputbox_height  = i->height_of_item * MMI_MENUITEM_HEIGHT;
#else
    S32 inputbox_height = height;
#endif
    S32 fh;
    S32 l;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    
    wgui_inline_inputbox_information_flag = wgui_inputbox_information_flag;
    MMI_inline_multi_line_inputbox_present = MMI_multi_line_inputbox_present;
    if (wgui_current_inline_item_type == INLINE_ITEM_TYPE_FULL_SCREEN_EDIT)
    {
        return;
    }

    MMI_inline_multiline_inputbox = (multi_line_input_box *)mmi_frm_asm_alloc_anonymous(sizeof(multi_line_input_box));

    l = gui_strlen((UI_string_type) i->buffer);

    gui_create_multi_line_input_box_set_buffer(
         MMI_inline_multiline_inputbox,
         MMI_multiline_inputbox_x,
         MMI_multiline_inputbox_y,
         MMI_multiline_inputbox_width,
         MMI_multiline_inputbox_height,
         (UI_string_type) i->buffer,
         l * 2,
         (l + 1) * 2,
         0);

    MMI_inline_multiline_inputbox->flags |= UI_MULTI_LINE_INPUT_BOX_USE_PRESET_CLIPPING;
    
    MMI_inline_multiline_inputbox->ext_flags |= GUI_MULTI_LINE_INPUT_BOX_SEMITRANSPARENT_BACKGROUND;
    
    gui_set_font((MMI_inline_multiline_inputbox->text_font));
    fh = gui_get_character_height();
    inputbox_height = (inputbox_height / (fh + 1)) * (fh + 1);

#if(INSCREEN_MUTLILINE_TITLE_ENABLE)
    gui_move_multi_line_input_box(MMI_inline_multiline_inputbox, inputbox_x, inputbox_y);
    gui_resize_multi_line_input_box(MMI_inline_multiline_inputbox, inputbox_width, inputbox_height + 4 + 2);
    wgui_inputbox_information_flag = 0;
#else /* (INSCREEN_MUTLILINE_TITLE_ENABLE) */ 
    {
        S32 t_height = 0;
        gui_move_multi_line_input_box(MMI_inline_multiline_inputbox, inputbox_x, inputbox_y);
        
        t_height = (fh + 1) - (INFORMATION_BAR_HEIGHT + 2);
        gui_resize_multi_line_input_box(MMI_inline_multiline_inputbox, inputbox_width, inputbox_height + 4 - t_height);

        
    }
#endif /* (INSCREEN_MUTLILINE_TITLE_ENABLE) */ 

    MMI_inline_multiline_inputbox->flags |=
        (UI_MULTI_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW | UI_MULTI_LINE_INPUT_BOX_VIEW_MODE |
         UI_MULTI_LINE_INPUT_BOX_DISABLE_SCROLLBAR);

    MMI_multi_line_inputbox_present = 3;

    gui_show_multi_line_input_box(MMI_inline_multiline_inputbox);
#if(UI_DOUBLE_BUFFER_SUPPORT)
        gui_BLT_double_buffer(
            MMI_inline_multiline_inputbox->x,
            MMI_inline_multiline_inputbox->y,
            MMI_inline_multiline_inputbox->x + MMI_inline_multiline_inputbox->width,
            MMI_inline_multiline_inputbox->y + MMI_inline_multiline_inputbox->height);
#endif /* (UI_DOUBLE_BUFFER_SUPPORT) */ 

     wgui_inputbox_information_flag = wgui_inline_inputbox_information_flag;
     MMI_multi_line_inputbox_present = MMI_inline_multi_line_inputbox_present;

     mmi_frm_asm_free_anonymous(MMI_inline_multiline_inputbox);

}


/*****************************************************************************
 * FUNCTION
 *  inline_multiline_edit_complete
 * DESCRIPTION
 *  complete function of inline multiline edit
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void inline_multiline_edit_complete(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (MMI_multi_line_inputbox_present)
    {
        handle_inline_multi_line_edit_complete();
    }
    MMI_multi_line_inputbox_present = 0;
}


/*****************************************************************************
 * FUNCTION
 *  gui_draw_inscreen_multi_line_input_box_title
 * DESCRIPTION
 *  draw inline multi line input box title
 * PARAMETERS
 *  x1                  [IN]    left-top corner x1 coordinate    
 *  y1                  [IN]    left-top corner y1 coordinate          
 *  x2                  [IN]    right-bottom corner x2 coordinate    
 *  y2                  [IN]    right-bottom corner y2 coordinate           
 * RETURNS
 *  void
 *****************************************************************************/
void gui_draw_inscreen_multi_line_input_box_title(S32 x1, S32 y1, S32 x2, S32 y2)
{
#if(INSCREEN_MULTILINE_SHOW_TITLE)
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (wgui_inputbox_information_flag)
    {
        wgui_redraw_input_information_background();
    }
#else /* (INSCREEN_MULTILINE_SHOW_TITLE) */ 
    if (wgui_inputbox_information_flag)
    {
        wgui_redraw_input_information_bar();
    }
#endif /* (INSCREEN_MULTILINE_SHOW_TITLE) */ 
}


/*****************************************************************************
 * FUNCTION
 *  wgui_show_inline_multi_line_rd_only
 * DESCRIPTION
 *  show inline multi line read only
 * PARAMETERS
 *  x1                  [IN]    left-top corner x1 coordinate    
 *  y1                  [IN]    left-top corner y1 coordinate    
 *  width               [IN]    width    
 *  height              [IN]    height          
 *  item                [IN]    inline item          
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_show_inline_multi_line_rd_only(S32 x1, S32 y1, S32 width, S32 height, wgui_inline_item *item)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_inline_item_text_edit *i = (wgui_inline_item_text_edit*) item->item;
    S32 l;

    S32 inputbox_x = x1;
    S32 inputbox_y = y1;
    S32 inputbox_width = width;
    S32 inputbox_height = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (wgui_current_inline_item_type == INLINE_ITEM_TYPE_FULL_SCREEN_EDIT)
    {
        return;
    }
    l = gui_strlen((UI_string_type) i->buffer);
    create_multiline_inputbox_set_buffer((UI_string_type) i->buffer, l, l, 0);
    move_multiline_inputbox(inputbox_x, inputbox_y);
    MMI_multiline_inputbox.flags |=
        (UI_MULTI_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW | UI_MULTI_LINE_INPUT_BOX_VIEW_MODE |
         UI_MULTI_LINE_INPUT_BOX_DISABLE_SCROLLBAR | UI_MULTI_LINE_INPUT_BOX_USE_PRESET_CLIPPING);

#ifndef __MMI_FTE_SUPPORT__
    /*we limit the height of multilinerdonly so that it can be shown total in screen.*/
    inputbox_height = height * (i->height_of_item);
#else
    inputbox_height = height; 
#endif
    MMI_multiline_inputbox.ext_flags |= GUI_MULTI_LINE_INPUT_BOX_SEMITRANSPARENT_BACKGROUND;
    MMI_multiline_inputbox.trans_color = *(current_MMI_theme->inline_multiline_readonly_bg_color);
    MMI_multiline_inputbox.trans_alpha = current_MMI_theme->inline_multiline_readonly_bg_alpha;
    
    resize_multiline_inputbox(inputbox_width, inputbox_height);

    if(g_inline_ml_rdly_highlight_list.hilite_list)
    {
        gui_inputs_ml_set_hilite_list(
            &MMI_multiline_inputbox,
            g_inline_ml_rdly_highlight_list.hilite_list,
            g_inline_ml_rdly_highlight_list.count,
            0,
            NULL,
            NULL
            ); 
    }
    
    show_multiline_inputbox();
}


/*****************************************************************************
 * FUNCTION
 *  SetInlineMultiLineRdOnly
 * DESCRIPTION
 *  set data of inline multiline read only
 * PARAMETERS
 *  item            [IN]    inline item     
 *  buffer          [IN]    buffer      
 *  buffer_size     [IN]    size of buffer    
 *  input_type      [IN]    input type    
 *  max_lines       [IN]    max lines    
 * RETURNS
 *  void
 *****************************************************************************/
void SetInlineMultiLineRdOnly(InlineItem *item, U8 *buffer, S32 buffer_size, U32 input_type, U8 max_lines)    /* input_type :- Other items are hilightable or not. */
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_inline_item_text_edit *i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (n_inline_text_edit_items >= MAX_INLINE_TEXT_EDIT_ITEMS)
    {
        return;
    }
    wgui_inline_mem_alloc_info[wgui_inline_mem_alloc_number] = item->item = wgui_inline_malloc(sizeof(wgui_inline_item_text_edit));
    wgui_inline_mem_alloc_number++; 
    item->flags = INLINE_ITEM_TYPE_MULTI_LINE_RD_ONLY;
    item->flags |= INLINE_ITEM_DISABLE_HIGHLIGHT;
    MMI_multiline_inputbox.flags |= UI_MULTI_LINE_INPUT_BOX_VIEW_MODE;

    n_inline_text_edit_items++;

    i = (wgui_inline_item_text_edit*) item->item;
  
    i->height_of_item = max_lines;

    i->title = 0;
    i->title_icon = 0;
    i->buffer = buffer;
    i->buffer_size = buffer_size;
    i->flags = 0;
    i->input_type = input_type;

    item->text_p = i->buffer;
    item->handler = handle_inline_multi_line_rd_only;

    i->edit_complete_callback = NULL;
    i->custom_setup_function = NULL;
    i->validation_callback = NULL;

    i->UCS2_count = -1;
    MMI_multi_line_inputbox_present = 2;
}


/*****************************************************************************
 * FUNCTION
 *  menu_item_inline_multiline_box
 * DESCRIPTION
 *  is INLINE_ITEM_TYPE_MULTI_LINE_RD_ONLY
 * PARAMETERS
 *  void
 * RETURNS
 *  1->yes 0->no
 *****************************************************************************/
S32 menu_item_inline_multiline_box()
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if ((wgui_inline_items[MMI_fixed_list_menu.n_items - 1].flags & 0xff) == INLINE_ITEM_TYPE_MULTI_LINE_RD_ONLY)
    {
        return 1;
    }
    else
    {
        return 0;
    }
}


/*****************************************************************************
 * FUNCTION
 *  redraw_multiline_rd_only
 * DESCRIPTION
 *  redraw inline multiline rd only
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void redraw_multiline_rd_only(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_push_clip();
    gui_set_clip(MMI_fixed_list_menu.x, MMI_fixed_list_menu.y, MMI_fixed_list_menu.x + MMI_fixed_list_menu.width - 1, MMI_fixed_list_menu.y + MMI_fixed_list_menu.height - 1);
    register_multiline_inputbox_viewer_keys();
    show_multiline_inputbox();
    gui_pop_clip();
}


/*****************************************************************************
 * FUNCTION
 *  handle_multi_line_rd_only_close
 * DESCRIPTION
 *  close function of inline multi line rd only
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void handle_multi_line_rd_only_close(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    reset_multiline_inputbox_vertical_scroll();
    reset_multiline_inputbox();
    complete_inline_item_edit = UI_dummy_function;
    redraw_current_inline_item = UI_dummy_function;
#ifdef __MMI_TOUCH_SCREEN__
    wgui_current_inline_item_pen_function = UI_dummy_inline_item_pen_function;
#endif 
}


/*****************************************************************************
 * FUNCTION
 *  inscreen_multi_line_input_box_changed
 * DESCRIPTION
 *  is inline multi line input box changed
 * PARAMETERS
 *  void
 * RETURNS
 *  inscreen_multi_line_change_flag
 *****************************************************************************/
S32 inscreen_multi_line_input_box_changed()
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return inscreen_multi_line_change_flag;
}


/*****************************************************************************
 * FUNCTION
 *  set_inscreen_multi_line_input_box_changed
 * DESCRIPTION
 *  set inscreen_multi_line_change_flag
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void set_inscreen_multi_line_input_box_changed()
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    inscreen_multi_line_change_flag = 1;
}


/*****************************************************************************
 * FUNCTION
 *  reset_inscreen_multi_line_input_box_changed
 * DESCRIPTION
 *  reset inscreen_multi_line_change_flag
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void reset_inscreen_multi_line_input_box_changed()
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    inscreen_multi_line_change_flag = 0;
}

#if defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN)
extern gui_list_smooth_scrolling_by_pen_state_enum g_gui_ssp_state;
#endif /* GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN */


#ifdef __MMI_TOUCH_SCREEN__
/*****************************************************************************
 * FUNCTION
 *  inline_multiline_rd_only_pen_handler
 * DESCRIPTION
 *  pen handler of inline rd only
 * PARAMETERS
 *  pen_event       [IN]    pen event    
 *  x               [IN]    pen x position    
 *  y               [IN]    pen y pisition    
 *  item_event      [?]     inline pen enum    
 * RETURNS
 *  BOOL
 *****************************************************************************/
BOOL inline_multiline_rd_only_pen_handler(
        mmi_pen_event_type_enum pen_event,
        S16 x,
        S16 y,
        gui_inline_item_pen_enum *item_event)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gui_multi_line_input_box_pen_enum multi_line_input_box_event;
    BOOL ret = MMI_TRUE;
    U16 idx = 0;
    static S32 pen_down_hilite_index = -1;
    static S32 reset_pre_hdlr = 0;
    static S32 down_x = -1, down_y = -1;
    static S32 maybe_list_ssp = 0;
    static S32 maybe_list_up_ssp = 0;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    *item_event = GUI_INLINE_ITEM_PEN_NONE;

    gdi_layer_set_clip(
        MMI_fixed_list_menu.x, 
        MMI_fixed_list_menu.y, 
        MMI_fixed_list_menu.x + MMI_fixed_list_menu.width - 1,
        MMI_fixed_list_menu.y + MMI_fixed_list_menu.height - 1);

    if(pen_event == MMI_PEN_EVENT_DOWN)
    {
        if(!PEN_CHECK_BOUND(
            x,
            y,
            MMI_multiline_inputbox.x,
            MMI_multiline_inputbox.y,
            MMI_multiline_inputbox.width,
            MMI_multiline_inputbox.height))
        {
            return MMI_FALSE;
        }
        down_x = x;
        down_y = y;
    }

    MMI_multiline_inputbox.flags |= UI_MULTI_LINE_INPUT_BOX_DISABLE_DRAW;
    gui_show_multi_line_input_box_ext(&MMI_multiline_inputbox, x, y);
    MMI_multiline_inputbox.flags &= ~UI_MULTI_LINE_INPUT_BOX_DISABLE_DRAW;
    if (((pen_event == MMI_PEN_EVENT_DOWN) || (pen_event == MMI_PEN_EVENT_UP)) &&
        /*gui_multi_line_input_box_is_pen_down_in_hilite(&MMI_multiline_inputbox)*/
        gui_multi_line_input_box_is_pos_inside_hilite_ext(&MMI_multiline_inputbox, MMI_multiline_inputbox.cursor_p, &idx))
    {
        switch (pen_event)
    {
            case MMI_PEN_EVENT_DOWN:
                MMI_multiline_inputbox.current_hilite_idx = idx;
                wgui_inputs_ml_set_pen_down_flag();
                gui_push_clip();
                gui_set_clip(MMI_fixed_list_menu.x, MMI_fixed_list_menu.y, MMI_fixed_list_menu.x + MMI_fixed_list_menu.width - 1, MMI_fixed_list_menu.y + MMI_fixed_list_menu.height - 1);
                gui_multi_line_input_box_go_to_hilite(
                    &MMI_multiline_inputbox,
                    MMI_multiline_inputbox.current_hilite_idx,
                    MMI_FALSE);
                gui_pop_clip();
                wgui_inputs_ml_clear_pen_down_flag();
                pen_down_hilite_index = MMI_multiline_inputbox.current_hilite_idx;
                break;
            case MMI_PEN_EVENT_UP:
            {
                if (pen_down_hilite_index == idx &&
                    MMI_multiline_inputbox.hilite_click_cb)
                {
                    MMI_multiline_inputbox.hilite_click_cb(MMI_multiline_inputbox.current_hilite_idx);
                }
                break;
            }
        }
    }
    else
    {
         switch (pen_event)
         {
             case MMI_PEN_EVENT_DOWN:
             {
                pen_down_hilite_index = -1;
                break;
             }
            case MMI_PEN_EVENT_UP:
            {
#ifdef __MMI_FTE_SUPPORT__
                if (gui_input_box_ssp_get_state() == GUI_INPUT_BOX_SSP_STATE_FOCUS)
                {
                    *item_event = GUI_INLINE_ITEM_PEN_SELECTED;
                }
#endif
                break;
            }
        }
    }
#ifdef __MMI_FTE_SUPPORT__
    gui_multi_line_input_box_translate_pen_event(&MMI_multiline_inputbox,
        pen_event, x, y, &multi_line_input_box_event);

    switch (pen_event)
    {
    case MMI_PEN_EVENT_DOWN:
        {
            maybe_list_ssp = 0;
            maybe_list_up_ssp = 0;
            if ((gui_input_box_ssp_get_state() != GUI_INPUT_BOX_SSP_STATE_UNFOCUS) &&
                (reset_pre_hdlr == 0)
               ) 
        {
            wgui_pen_reset_pre_hdlr();
            reset_pre_hdlr = 1;
        }
            if(MMI_multiline_inputbox.text_offset_y == 0)
            {
                maybe_list_ssp = 1;
            }
            if(wgui_inputs_ml_is_last_line())
            {
                maybe_list_up_ssp = 1;
            }
        break;
        }    
    case MMI_PEN_EVENT_UP:
    case MMI_PEN_EVENT_ABORT:
        {   
        if (reset_pre_hdlr)
        {
            wgui_pen_restore_pre_hdlr();
                reset_pre_hdlr = 0;
        }
        break;
        }
        case MMI_PEN_EVENT_MOVE:
        {
            if((maybe_list_ssp) &&
               (reset_pre_hdlr == 1)
              )
            {
                if(y > down_y)
                {
                    wgui_pen_restore_pre_hdlr();
#if defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN)
                    g_gui_ssp_state = GUI_LIST_SMOOTH_SCROLLING_BY_PEN_STATE_FOCUS;
#endif /* GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN */
                    reset_pre_hdlr = 0;
                }
                else
                {
                    maybe_list_ssp = 0;
                }
            }
            if((maybe_list_up_ssp) &&
               (reset_pre_hdlr == 1)
              )
            {
                if(y < down_y)
                {
                    wgui_pen_restore_pre_hdlr();
#if defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN)
                    g_gui_ssp_state = GUI_LIST_SMOOTH_SCROLLING_BY_PEN_STATE_FOCUS;
#endif /* GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN */
                    reset_pre_hdlr = 0;
                }
                else
                {
                    maybe_list_up_ssp = 0;
                }
            }
        }
    default:
        /* ignored events */
        break;
    }
#endif   

    return ret;
}
#endif


/*****************************************************************************
 * FUNCTION
 *  handle_inline_multi_line_rd_only
 * DESCRIPTION
 *  activation function of inline multi line rd only
 * PARAMETERS
 *  x                   [IN]        left corner's x coordinate
 *  y                   [IN]        left corner's y coordinate
 *  width               [IN]        width
 *  height              [IN]        height
 *  key_code            [IN]        key code
 *  key_event           [IN]        key event
 *  text_p              [IN]        text pointer
 *  item                [IN]        inline item
 *  flags               [IN]        flags
 *  history_buffer      [IN]        history buffer         
 * RETURNS
 *  void
 *****************************************************************************/
void handle_inline_multi_line_rd_only(
        S32 x,
        S32 y,
        S32 width,
        S32 height,
        S32 key_code,
        S32 key_event,
        U8 **text_p,
        void *item,
        U32 flags,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_inline_item_text_edit *i = (wgui_inline_item_text_edit*) item;
    S32 l = 0;

    S32 inputbox_x = x;
    S32 inputbox_y = y;
    S32 inputbox_width = width;
    S32 inputbox_height = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_current_inline_item_type = INLINE_ITEM_TYPE_MULTI_LINE_RD_ONLY;

    l = gui_strlen((UI_string_type) i->buffer);
    if (history_buffer == NULL || inscreen_multi_line_input_box_changed())
    {
        create_multiline_inputbox_set_buffer((UI_string_type) i->buffer, l, l, 0);
        reset_inscreen_multi_line_input_box_changed();
    }
    else
    {
        create_multiline_inputbox_set_buffer_no_text_reset((UI_string_type) i->buffer, l, l, 0);
    }

    move_multiline_inputbox(inputbox_x, inputbox_y);
#ifdef __MMI_FTE_SUPPORT__
    MMI_multiline_inputbox.flags |=
        (UI_MULTI_LINE_INPUT_BOX_VIEW_MODE |
        UI_MULTI_LINE_INPUT_BOX_DISABLE_SCROLLBAR | UI_MULTI_LINE_INPUT_BOX_INSIDE_INLINE_MENU
          |UI_MULTI_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW | UI_MULTI_LINE_INPUT_BOX_USE_PRESET_CLIPPING);
#else
    MMI_multiline_inputbox.flags |=
        (/* UI_MULTI_LINE_INPUT_BOX_AUTO_VERTICAL_SCROLL | */ UI_MULTI_LINE_INPUT_BOX_VIEW_MODE |
         UI_MULTI_LINE_INPUT_BOX_DISABLE_SCROLLBAR | UI_MULTI_LINE_INPUT_BOX_INSIDE_INLINE_MENU
          |UI_MULTI_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW | UI_MULTI_LINE_INPUT_BOX_USE_PRESET_CLIPPING);
#endif


    inputbox_height = height;

    resize_multiline_inputbox(inputbox_width, inputbox_height);
    register_multiline_inputbox_viewer_keys();
    MMI_multiline_inputbox.vertical_scroll_on = 0;

    if(g_inline_ml_rdly_highlight_list.hilite_list)
    {
        gui_inputs_ml_set_hilite_list(
                &MMI_multiline_inputbox,
                g_inline_ml_rdly_highlight_list.hilite_list,
                g_inline_ml_rdly_highlight_list.count,
                0,
                g_inline_ml_rdly_highlight_list.hilite_cb,
                g_inline_ml_rdly_highlight_list.click_cb
                );
    }

    if(history_buffer != NULL)
    {
        wgui_inputs_ml_set_category_history(INLINE_MULTI_LINE_EDIT_HISTORY_ID, history_buffer);
        if (g_inline_ml_rdly_highlight_list.hilite_list)
        {
            gui_multi_line_input_box_go_to_hilite(
                        &MMI_multiline_inputbox,
                        MMI_multiline_inputbox.current_hilite_idx,
                        MMI_FALSE);
        }
    }

    show_multiline_inputbox();

#ifdef __MMI_TOUCH_SCREEN__
    wgui_current_inline_item_pen_function = inline_multiline_rd_only_pen_handler;
#endif
    redraw_current_inline_item = redraw_multiline_rd_only;
    complete_inline_item_edit = handle_multi_line_rd_only_close;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_inline_multiline_append_string
 * DESCRIPTION
 *  append string into inline multiline
 * PARAMETERS
 *  input_type               [IN]        input type
 *  buffer                   [IN]        buffer pointer
 *  buffer_size              [IN]        buffer size
 *  string                   [IN]        String
 *  history_buffer           [IN]        history buffer 
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_inline_multiline_append_string(
                    U32 input_type, 
                    U8 *buffer, 
                    S32 buffer_size, 
                    U8 *string, 
                    U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 start_offset = 0, s = 0;
    U8 *h_ptr = NULL;


    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    s = sizeof(list_menu_category_history);
    s = (s + 3) / 4;
    s *= 4;
    start_offset = s + sizeof(U32);
    h_ptr = history_buffer + start_offset;
    wgui_inputs_ml_append_string(
        input_type,
        buffer,
        buffer_size,
        string,
        h_ptr,
        INLINE_MULTI_LINE_EDIT_HISTORY_ID,
        NULL);
}


/*****************************************************************************
* FUNCTION
*  wgui_inline_ml_rdly_set_hilite_list
* DESCRIPTION
*  Set highlight list for multiline readonly item.
* PARAMETERS
* RETURNS
*  characters inserted
*****************************************************************************/
void wgui_inline_ml_rdly_set_hilite_list( 
	wgui_inline_item  *item,
  	wgui_inline_ml_rdly_highlight_list_struct *highlight_list)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	 
	/*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if((item->flags & 0xff) == INLINE_ITEM_TYPE_MULTI_LINE_RD_ONLY)
    {
        memcpy(
            (void *)&g_inline_ml_rdly_highlight_list, 
            (void *)highlight_list, 
            sizeof(wgui_inline_ml_rdly_highlight_list_struct));  
    }
}


#endif /*defined( __MMI_INLINE_ITEM_MULTILINE_READ_ONLY__) || defined( __MMI_INLINE_ITEM_MULTILINE_EDIT__)*/
#endif /* defined(__MMI_INSCREEN_MULTILINE_TEXTBOX__) */ 

/*****************************************************************************
 * FUNCTION
 *  wgui_get_inline_item_height
 * DESCRIPTION
 *  get inline multiline height
 * PARAMETERS
 *  item_index  [IN]    
 * RETURNS
 *  S32
 *****************************************************************************/
S32 wgui_get_inline_item_height(S32 item_index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_inline_item_text_edit *i;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
#ifndef __MMI_FTE_SUPPORT__    
#if defined( __MMI_INLINE_ITEM_MULTILINE_READ_ONLY__) || defined( __MMI_INLINE_ITEM_MULTILINE_EDIT__)
    if(((wgui_inline_items[item_index].flags & 0xFF) == INLINE_ITEM_TYPE_MULTI_LINE_EDIT) ||
       ((wgui_inline_items[item_index].flags & 0xFF) == INLINE_ITEM_TYPE_MULTI_LINE_RD_ONLY)
      )
    {
    i = (wgui_inline_item_text_edit*)wgui_inline_items[item_index].item;
        return (i->height_of_item) * MMI_MENUITEM_HEIGHT; 
    } 
    else 
#endif
    {
        return  MMI_MENUITEM_HEIGHT; 
    }
#else
#if defined( __MMI_INLINE_ITEM_MULTILINE_READ_ONLY__) || defined( __MMI_INLINE_ITEM_MULTILINE_EDIT__)
    if((wgui_inline_items[item_index].flags & 0xFF) == INLINE_ITEM_TYPE_MULTI_LINE_EDIT)
    {
        i = (wgui_inline_item_text_edit*)wgui_inline_items[item_index].item;
        return (i->height_of_item) * MMI_MENUITEM_HEIGHT + (MMI_fixed_list_menu.height % MMI_fixed_icontext_menuitem.height); 
    } 

    if((wgui_inline_items[item_index].flags & 0xFF) == INLINE_ITEM_TYPE_MULTI_LINE_RD_ONLY)
    {
        i = (wgui_inline_item_text_edit*)wgui_inline_items[item_index].item;
            
        return (i->height_of_item) * MMI_MENUITEM_HEIGHT;
    } 
    else 
#endif
    if((wgui_inline_items[item_index].flags & 0xFF) == INLINE_ITEM_TYPE_CAPTION)
    {
    #if defined(__MMI_PHB_PHOTO_STICKER_SUPPORT__)
        if (wgui_inline_items[item_index].item)
        {
            return INLINE_FTE_CAPTION_THUMBNAIL_ITEM_HEIGHT;
        }
	#endif /* __MMI_PHB_PHOTO_STICKER_SUPPORT__ */
        return INLINE_FTE_TWO_LINE_1_HEIGHT;
    }
    else if(g_inline_fte_item_height_table[item_index] == INLINE_LINE_STYLE_ONE_LINE)
    {
        return INLINE_FTE_ONE_LINE_HEIGHT;
    }
    else if(g_inline_fte_item_height_table[item_index] == INLINE_LINE_STYLE_TWO_LINE)
    {
        return INLINE_FTE_TWO_LINE_2_HEIGHT;
    }
#endif

    return 0;
}

/***************************************************************************** 
 * Some Utility function for Inline Editor 
 *
 * This is Utility function related to history and themes
 *****************************************************************************/

/***************************************************************************** 
 * Define
 *****************************************************************************/
#define INLINE_ITEM_DATA_ID_LENGTH                    2
#define INLINE_ITEM_DATA_SIZE_LENGTH                  2
#define INLINE_ITEM_CAPTION_DATA_ID                   0x0001
#define INLINE_ITEM_DISPLAY_ONLY_DATA_ID              0x0002
#define INLINE_ITEM_USER_DEFINED_SELECT_DATA_ID       0x0003
#define INLINE_ITEM_TEXT_EDIT_DATA_ID                 0x0004
#define INLINE_ITEM_FULL_SCREEN_EDIT_DATA_ID          0x0005
#define INLINE_ITEM_SELECT_DATA_ID                    0x0006
#define INLINE_ITEM_DATE_DATA_ID                      0x0007
#define INLINE_ITEM_TIME_DATA_ID                      0x0008
#define INLINE_ITEM_TIME_PERIOD_DATA_ID               0x0009
#define INLINE_ITEM_IP4_EDIT_DATA_ID                  0x0010
#define INLINE_ITEM_DOW_SELECT_DATA_ID                0x0011
#define INLINE_ITEM_ATTACH_IMAGE_DATA_ID              0x0012
#define INLINE_ITEM_TYPE_MULTI_LINE_DATA_ID           0x0013
#define INLINE_ITEM_COLOR_SELECT_DATA_ID              0x0014

#define reverse_pixtel_UI_memcpy(b1,b2,n) gui_memcpy((b2),(b1),(n))
#define reverse_pixtel_UI_strcpy(s1,s2)   gui_strcpy(s2,s1)

/***************************************************************************** 
 * Local Variable
 *****************************************************************************/
#ifdef __MMI_UI_LIST_GRID_LINE__
static MMI_BOOL wgui_inline_separator_table[MAX_INLINE_ITEMS];
#endif /* __MMI_UI_LIST_GRID_LINE__ */

/***************************************************************************** 
 * Function Implementation
 *****************************************************************************/

/*****************************************************************************
 * FUNCTION
 *  wgui_get_inline_history_size
 * DESCRIPTION
 *  get current inline item's history size
 * PARAMETERS
 *  void
 * RETURNS
 *  history size
 *****************************************************************************/
S32 wgui_get_inline_history_size(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 inline_history_size = 0, s;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (wgui_current_inline_item_type)
    {
        case INLINE_ITEM_TYPE_TEXT_EDIT:
            inline_history_size = sizeof(inline_text_edit_history);
            break;
        case INLINE_ITEM_TYPE_FULL_SCREEN_EDIT:
            inline_history_size = sizeof(inline_full_screen_edit_history);
            break;
        case INLINE_ITEM_TYPE_DATE:
#if defined (__MMI_INLINE_ITEM_DATE__)
            inline_history_size = sizeof(inline_date_edit_history);
#endif /* __MMI_INLINE_ITEM_DATE__ */
            break;
        case INLINE_ITEM_TYPE_TIME:
#if defined (__MMI_INLINE_ITEM_TIME__)
            inline_history_size = sizeof(inline_time_edit_history);
#endif /* __MMI_INLINE_ITEM_TIME__ */
            break;
#if defined (__MMI_INLINE_ITEM_TIME_PEROID__)            
        case INLINE_ITEM_TYPE_TIME_PERIOD:
            inline_history_size = sizeof(inline_time_period_edit_history);
            break;
#endif            
#if defined (__MMI_INLINE_ITEM_IP4__)
		case INLINE_ITEM_TYPE_IP4_EDIT:
            inline_history_size = sizeof(inline_IP4_edit_history);
            break;
#endif /* __MMI_INLINE_ITEM_IP4__ */

#if defined (__MMI_INLINE_ITEM_DOW__)
        case INLINE_ITEM_TYPE_DOW_SELECT:
            inline_history_size = sizeof(inline_DOW_select_history);
            break;
#endif
#if defined( __MMI_INLINE_ITEM_MULTILINE_READ_ONLY__) || defined( __MMI_INLINE_ITEM_MULTILINE_EDIT__)
        case INLINE_ITEM_TYPE_MULTI_LINE_EDIT:
        case INLINE_ITEM_TYPE_MULTI_LINE_RD_ONLY: 
            inline_history_size = sizeof(multiline_inputbox_category_history);
            break;
#endif			
    }
    s = sizeof(list_menu_category_history);
    s = (s + 3) / 4;
    s *= 4;
    return (s + inline_history_size + sizeof(U32));
}

/* Current structure:
   history = <list menu history> + <4 bytes for flags> + <inline edit specific history>
   flags = 1: Content has been changed by user
   flags = 0: Content has not been changed by user       */


/*****************************************************************************
 * FUNCTION
 *  wgui_get_inline_history
 * DESCRIPTION
 *  get current inline item's history buffer
 * PARAMETERS
 *  history_ID          [IN]        history id
 *  history_buffer      [OUT]        history buffer         
 * RETURNS
 *  history buffer
 *****************************************************************************/
U8 *wgui_get_inline_history(U16 history_ID, U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 *flags;
    S32 start_offset, s;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    get_list_menu_category_history(history_ID, history_buffer);
    s = sizeof(list_menu_category_history);
    s = (s + 3) / 4;
    s *= 4;
    start_offset = s + sizeof(U32);
    if(cui_inline_is_current_cui() == MMI_FALSE)
    {
        flags = (U32*) (history_buffer + s);
        *flags = wgui_inline_list_menu_changed;
    }
    else
    {
        /* when insert item or delete item, we should update h->num_items,
        ande when h->last_displayed_item > (h->num_items - 1), we should update last and first
        item. 
        */
        list_menu_category_history *h = (list_menu_category_history*) history_buffer;
        h->num_items = g_cui_inline_current_instance->item_count;
        if(h->last_displayed_item > (h->num_items - 1))
        {
            h->last_displayed_item = h->num_items - 1;
            if(h->first_displayed_item > 0)
            {
                h->first_displayed_item --;     
            }
        }
        /*And highlight item of list hisory is invalid when CUI. */
        cui_inline_item_save_gui_buffer(wgui_inline_item_highlighted_index, 
                        &wgui_inline_items[wgui_inline_item_highlighted_index],
                        (U8*)(history_buffer + start_offset));      
    }

    switch (wgui_current_inline_item_type)
    {
        case INLINE_ITEM_TYPE_TEXT_EDIT:
            inline_text_edit_get_history((U8*) (history_buffer + start_offset));
            break;
        case INLINE_ITEM_TYPE_FULL_SCREEN_EDIT:
            inline_full_screen_edit_get_history((U8*) (history_buffer + start_offset));
            break;
        case INLINE_ITEM_TYPE_DATE:
#if defined (__MMI_INLINE_ITEM_DATE__)
            inline_date_edit_get_history((U8*) (history_buffer + start_offset));
#endif /* __MMI_INLINE_ITEM_DATE__ */
            break;
        case INLINE_ITEM_TYPE_TIME:
#if defined (__MMI_INLINE_ITEM_TIME__)
            inline_time_edit_get_history((U8*) (history_buffer + start_offset));
#endif /* __MMI_INLINE_ITEM_TIME__ */
            break;
#if defined (__MMI_INLINE_ITEM_TIME_PEROID__)               
        case INLINE_ITEM_TYPE_TIME_PERIOD:
            inline_time_period_edit_get_history((U8*) (history_buffer + start_offset));
            break;
#endif
#if defined (__MMI_INLINE_ITEM_IP4__)
        case INLINE_ITEM_TYPE_IP4_EDIT:
            inline_IP4_edit_get_history((U8*) (history_buffer + start_offset));
            break;
#endif /* __MMI_INLINE_ITEM_IP4__ */
#if defined (__MMI_INLINE_ITEM_DOW__)
        case INLINE_ITEM_TYPE_DOW_SELECT:
            inline_DOW_select_get_history((U8*) (history_buffer + start_offset));
            break;
#endif
#if defined( __MMI_INLINE_ITEM_MULTILINE_READ_ONLY__) || defined( __MMI_INLINE_ITEM_MULTILINE_EDIT__)
        case INLINE_ITEM_TYPE_MULTI_LINE_EDIT:
        case INLINE_ITEM_TYPE_MULTI_LINE_RD_ONLY: 
            inline_multi_line_edit_get_history((U8*) (history_buffer + start_offset));
            break;
#endif
#if defined (__MMI_INLINE_ITEM_IMAGETEXT__)
        case INLINE_ITEM_IMAGE_TEXT_TYPE:
            inline_image_text_get_history((U8*) (history_buffer + start_offset));
            break;
#endif			

    }
    return (history_buffer);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_inline_edit_get_current_item_history
 * DESCRIPTION
 *  get current inline item history buffer
 * PARAMETERS
 *  history_buffer      [OUT]   history buffer     
 * RETURNS
 *  history buffer
 *****************************************************************************/
U8 *wgui_inline_edit_get_current_item_history(U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (wgui_current_inline_item_type)
    {
        case INLINE_ITEM_TYPE_TEXT_EDIT:
            inline_text_edit_get_history((U8*) (history_buffer));
            break;
        case INLINE_ITEM_TYPE_FULL_SCREEN_EDIT:
            inline_full_screen_edit_get_history((U8*) (history_buffer));
            break;
        case INLINE_ITEM_TYPE_DATE:
#if defined (__MMI_INLINE_ITEM_DATE__)
            inline_date_edit_get_history((U8*) (history_buffer));
#endif /* __MMI_INLINE_ITEM_DATE__ */
            break;
        case INLINE_ITEM_TYPE_TIME:
#if defined (__MMI_INLINE_ITEM_TIME__)
            inline_time_edit_get_history((U8*) (history_buffer));
#endif /* __MMI_INLINE_ITEM_TIME__ */
            break;
#if defined (__MMI_INLINE_ITEM_TIME_PEROID__)  
        case INLINE_ITEM_TYPE_TIME_PERIOD:
            inline_time_period_edit_get_history((U8*) (history_buffer));
            break;
#endif
#if defined (__MMI_INLINE_ITEM_IP4__)
        case INLINE_ITEM_TYPE_IP4_EDIT:
            inline_IP4_edit_get_history((U8*) (history_buffer));
            break;
#endif /* __MMI_INLINE_ITEM_IP4__ */
#if defined (__MMI_INLINE_ITEM_DOW__)
        case INLINE_ITEM_TYPE_DOW_SELECT:
            inline_DOW_select_get_history((U8*) (history_buffer));
            break;
#endif
#if defined( __MMI_INLINE_ITEM_MULTILINE_EDIT__)
        case INLINE_ITEM_TYPE_MULTI_LINE_EDIT:
            inline_multi_line_edit_get_history((U8*) (history_buffer));
            break;
#endif			
    }
    wgui_current_history_buffer = history_buffer;
    return (history_buffer);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_get_inline_data_size
 * DESCRIPTION
 *  get inline data size
 * PARAMETERS
 *  void
 * RETURNS
 *  inlie data size
 *****************************************************************************/
S32 wgui_get_inline_data_size(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i, total_size = 0, size;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(cui_inline_is_current_cui())
    {
        return 1;
    }

    for (i = 0; i < wgui_n_inline_items; i++)
    {
        size = 0;
        switch (wgui_inline_items[i].flags & 0xff)
        {
            case INLINE_ITEM_TYPE_CAPTION:
            case INLINE_ITEM_TYPE_DISPLAY_ONLY:
            case INLINE_ITEM_TYPE_USER_DEFINED_SELECT:
                break;

            case INLINE_ITEM_TYPE_TEXT_EDIT:
            {
                S32 l;
                wgui_inline_item_text_edit *ii = (wgui_inline_item_text_edit*) wgui_inline_items[i].item;

                l = ii->buffer_size * ENCODING_LENGTH;
                if (ii->input_type & INPUT_TYPE_PLUS_CHARACTER_HANDLING)
                {
                    l += ENCODING_LENGTH;
                }
                size = INLINE_ITEM_DATA_ID_LENGTH + INLINE_ITEM_DATA_SIZE_LENGTH + sizeof(S32) + l;
            }
                break;

            case INLINE_ITEM_TYPE_FULL_SCREEN_EDIT:
            {
                S32 l;
                wgui_inline_item_text_edit *ii = (wgui_inline_item_text_edit*) wgui_inline_items[i].item;

                l = ii->buffer_size * ENCODING_LENGTH;
                if (ii->input_type & INPUT_TYPE_PLUS_CHARACTER_HANDLING)
                {
                    l += ENCODING_LENGTH;
                }
                size = INLINE_ITEM_DATA_ID_LENGTH + INLINE_ITEM_DATA_SIZE_LENGTH + sizeof(U32) + sizeof(S32) + (l << 1);
            }
                break;

            case INLINE_ITEM_TYPE_SELECT:
            {
                size = INLINE_ITEM_DATA_ID_LENGTH + 2;
            }
                break;

            case INLINE_ITEM_TYPE_DATE:
            {
                size = INLINE_ITEM_DATA_ID_LENGTH + 5 * ENCODING_LENGTH + 3 * ENCODING_LENGTH + 3 * ENCODING_LENGTH;
            }
                break;

            case INLINE_ITEM_TYPE_TIME:
            {
                size = INLINE_ITEM_DATA_ID_LENGTH + 3 * ENCODING_LENGTH + 3 * ENCODING_LENGTH;
            }
                break;
#if defined (__MMI_INLINE_ITEM_TIME_PEROID__)   
            case INLINE_ITEM_TYPE_TIME_PERIOD:
            {
                size =
                    INLINE_ITEM_DATA_ID_LENGTH + 3 * ENCODING_LENGTH + 3 * ENCODING_LENGTH + 3 * ENCODING_LENGTH +
                    3 * ENCODING_LENGTH;
            }
                break;
#endif
#if defined (__MMI_INLINE_ITEM_IP4__)
            case INLINE_ITEM_TYPE_IP4_EDIT:
            {
                size =
                    INLINE_ITEM_DATA_ID_LENGTH + 4 * ENCODING_LENGTH + 4 * ENCODING_LENGTH + 4 * ENCODING_LENGTH +
                    4 * ENCODING_LENGTH;
            }
                break;
#endif
#if defined (__MMI_INLINE_ITEM_DOW__)
            case INLINE_ITEM_TYPE_DOW_SELECT:
            {
                size = INLINE_ITEM_DATA_ID_LENGTH + 7;
            }
                break;
#endif				
        #if defined(__MMI_INSCREEN_MULTILINE_TEXTBOX__) /* 4/5 */
        #if defined( __MMI_INLINE_ITEM_MULTILINE_READ_ONLY__) || defined( __MMI_INLINE_ITEM_MULTILINE_EDIT__)
            case INLINE_ITEM_TYPE_MULTI_LINE_EDIT:
            case INLINE_ITEM_TYPE_MULTI_LINE_RD_ONLY:
            {
                size = INLINE_ITEM_DATA_ID_LENGTH + 4 + sizeof(multiline_inputbox_category_history);
            }
                break;
        #endif /* defined( __MMI_INLINE_ITEM_MULTILINE_READ_ONLY__) || defined( __MMI_INLINE_ITEM_MULTILINE_EDIT__) */        
        #endif /* defined(__MMI_INSCREEN_MULTILINE_TEXTBOX__) */ 
#if defined (__MMI_INLINE_ITEM_COLOR_SELECT__)
            case INLINE_ITEM_TYPE_COLOR_SELECT:
            {
                size = INLINE_ITEM_DATA_ID_LENGTH + 4;
            }
                break;
#endif				
        }
        total_size += size;
        total_size = (total_size + 3)&~3;
    }
    return (total_size);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_get_inline_data
 * DESCRIPTION
 *  get inline data
 * PARAMETERS
 *  data        [OUT]   inline data     
 * RETURNS
 *  data
 *****************************************************************************/
U8 *wgui_get_inline_data(U8 *data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i, offset = 0, size;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(cui_inline_is_current_cui())
    {
        cui_inline_item_save_input_buffer();
        return data;
    }

    for (i = 0; i < wgui_n_inline_items; i++)
    {
        size = 0;
        switch (wgui_inline_items[i].flags & 0xff)
        {
            case INLINE_ITEM_TYPE_CAPTION:
            case INLINE_ITEM_TYPE_DISPLAY_ONLY:
            case INLINE_ITEM_TYPE_USER_DEFINED_SELECT:
                break;

            case INLINE_ITEM_TYPE_TEXT_EDIT:
            {
                S32 l;
                U16 ID = INLINE_ITEM_TEXT_EDIT_DATA_ID;
                wgui_inline_item_text_edit *ii = (wgui_inline_item_text_edit*) wgui_inline_items[i].item;

                l = ii->buffer_size * ENCODING_LENGTH;
                if (ii->input_type & INPUT_TYPE_PLUS_CHARACTER_HANDLING)
                {
                    l += ENCODING_LENGTH;
                }
                size = INLINE_ITEM_DATA_ID_LENGTH + INLINE_ITEM_DATA_SIZE_LENGTH + sizeof(S32) + l;
                gui_memcpy((U8*) & data[offset], (U8*) & ID, INLINE_ITEM_DATA_ID_LENGTH);
                gui_memcpy(
                    (U8*) & data[offset + INLINE_ITEM_DATA_ID_LENGTH],
                    (U8*) & l,
                    INLINE_ITEM_DATA_SIZE_LENGTH);
                gui_memcpy(
                    (U8*) & data[offset + INLINE_ITEM_DATA_ID_LENGTH + INLINE_ITEM_DATA_SIZE_LENGTH],
                    (U8*) & (ii->UCS2_count),
                    sizeof(S32));
                gui_memcpy(
                    (U8*) & data[offset + INLINE_ITEM_DATA_ID_LENGTH + INLINE_ITEM_DATA_SIZE_LENGTH + sizeof(S32)],
                    (U8*) ii->buffer,
                    l);
            }
                break;

            case INLINE_ITEM_TYPE_FULL_SCREEN_EDIT:
            {
                S32 l;
                U16 ID = INLINE_ITEM_FULL_SCREEN_EDIT_DATA_ID;
                wgui_inline_item_text_edit *ii = (wgui_inline_item_text_edit*) wgui_inline_items[i].item;
                U32 flags = 0;
                S32 flags_size = sizeof(U32);
				
				if ((inline_full_screen_edit_changed)
					&& (wgui_inline_item_highlighted_index == i))
				{
					wgui_inline_items[i].flags |= INLINE_ITEM_CHANGED;
				}
                flags = (U32) (wgui_inline_items[i].flags >> 8);
                l = ii->buffer_size * ENCODING_LENGTH;
                if (ii->input_type & INPUT_TYPE_PLUS_CHARACTER_HANDLING)
                {
                    l += ENCODING_LENGTH;
                }
                size = INLINE_ITEM_DATA_ID_LENGTH + INLINE_ITEM_DATA_SIZE_LENGTH + flags_size + (l << 1) + sizeof(S32);
                gui_memcpy((U8*) & data[offset], (U8*) & ID, INLINE_ITEM_DATA_ID_LENGTH);
                gui_memcpy((U8*) & data[offset + INLINE_ITEM_DATA_ID_LENGTH], (U8*) & flags, flags_size);
                gui_memcpy(
                    (U8*) & data[offset + INLINE_ITEM_DATA_ID_LENGTH + flags_size],
                    (U8*) & l,
                    INLINE_ITEM_DATA_SIZE_LENGTH);
                gui_memcpy(
                    (U8*) & data[offset + INLINE_ITEM_DATA_ID_LENGTH + flags_size + INLINE_ITEM_DATA_SIZE_LENGTH],
                    (U8*) & (ii->UCS2_count),
                    sizeof(S32));
                gui_memcpy(
                    (U8*) & data[offset + INLINE_ITEM_DATA_ID_LENGTH + INLINE_ITEM_DATA_SIZE_LENGTH + flags_size + sizeof(S32)],
                    (U8*) wgui_inline_full_screen_text_edit_buffer,
                    l);
                gui_memcpy(
                    (U8*) & data[offset + INLINE_ITEM_DATA_ID_LENGTH + INLINE_ITEM_DATA_SIZE_LENGTH + flags_size + sizeof(S32) + l],
                    (U8*) ii->buffer,
                    l);
            }
                break;

            case INLINE_ITEM_TYPE_SELECT:
            {
                U16 ID = INLINE_ITEM_SELECT_DATA_ID;
                S32 highlighted_item;
                wgui_inline_item_select *ii = (wgui_inline_item_select*) wgui_inline_items[i].item;

                size = INLINE_ITEM_DATA_ID_LENGTH + 2;
                highlighted_item = *ii->highlighted_item;
                gui_memcpy((U8*) & data[offset], (U8*) & ID, INLINE_ITEM_DATA_ID_LENGTH);
                gui_memcpy((U8*) & data[offset + INLINE_ITEM_DATA_ID_LENGTH], (U8*) & highlighted_item, 2);
            }
                break;

            case INLINE_ITEM_TYPE_DATE:
            {
#if defined (__MMI_INLINE_ITEM_DATE__)
                U16 ID = INLINE_ITEM_DATE_DATA_ID;
                wgui_inline_item_date *ii = (wgui_inline_item_date*) wgui_inline_items[i].item;

                size = INLINE_ITEM_DATA_ID_LENGTH + 5 * ENCODING_LENGTH + 3 * ENCODING_LENGTH + 3 * ENCODING_LENGTH;
                gui_memcpy((U8*) & data[offset], (U8*) & ID, INLINE_ITEM_DATA_ID_LENGTH);
                gui_strcpy(
                    (UI_string_type) & data[offset + INLINE_ITEM_DATA_ID_LENGTH],
                    (UI_string_type) ii->year_buffer);
                gui_strcpy(
                    (UI_string_type) & data[offset + INLINE_ITEM_DATA_ID_LENGTH + 5 * ENCODING_LENGTH],
                    (UI_string_type) ii->month_buffer);
                gui_strcpy(
                    (UI_string_type) & data[offset + INLINE_ITEM_DATA_ID_LENGTH + 5 * ENCODING_LENGTH + 3 * ENCODING_LENGTH],
                    (UI_string_type) ii->day_buffer);
#endif /* __MMI_INLINE_ITEM_DATE__ */
            }
                break;

            case INLINE_ITEM_TYPE_TIME:
            {
#if defined (__MMI_INLINE_ITEM_TIME__)
                U16 ID = INLINE_ITEM_TIME_DATA_ID;
                wgui_inline_item_time *ii = (wgui_inline_item_time*) wgui_inline_items[i].item;

                size = INLINE_ITEM_DATA_ID_LENGTH + 3 * ENCODING_LENGTH + 3 * ENCODING_LENGTH;
                gui_memcpy((U8*) & data[offset], (U8*) & ID, INLINE_ITEM_DATA_ID_LENGTH);
                gui_strcpy(
                    (UI_string_type) & data[offset + INLINE_ITEM_DATA_ID_LENGTH],
                    (UI_string_type) ii->hours_buffer);
                gui_strcpy(
                    (UI_string_type) & data[offset + INLINE_ITEM_DATA_ID_LENGTH + 3 * ENCODING_LENGTH],
                    (UI_string_type) ii->minutes_buffer);
#endif /* __MMI_INLINE_ITEM_TIME__ */
            }
                break;
#if defined (__MMI_INLINE_ITEM_TIME_PEROID__)   
            case INLINE_ITEM_TYPE_TIME_PERIOD:
            {
                U16 ID = INLINE_ITEM_TIME_PERIOD_DATA_ID;
                wgui_inline_item_time_period *ii = (wgui_inline_item_time_period*) wgui_inline_items[i].item;

                size =
                    INLINE_ITEM_DATA_ID_LENGTH + 3 * ENCODING_LENGTH + 3 * ENCODING_LENGTH + 3 * ENCODING_LENGTH +
                    3 * ENCODING_LENGTH;
                gui_memcpy((U8*) & data[offset], (U8*) & ID, INLINE_ITEM_DATA_ID_LENGTH);
                gui_strcpy(
                    (UI_string_type) & data[offset + INLINE_ITEM_DATA_ID_LENGTH],
                    (UI_string_type) ii->hours_buffer1);
                gui_strcpy(
                    (UI_string_type) & data[offset + INLINE_ITEM_DATA_ID_LENGTH + 3 * ENCODING_LENGTH],
                    (UI_string_type) ii->minutes_buffer1);
                gui_strcpy(
                    (UI_string_type) & data[offset + INLINE_ITEM_DATA_ID_LENGTH + 3 * ENCODING_LENGTH + 3 * ENCODING_LENGTH],
                    (UI_string_type) ii->hours_buffer2);
                gui_strcpy(
                    (UI_string_type) & data[offset + INLINE_ITEM_DATA_ID_LENGTH + 3 * ENCODING_LENGTH + 3 * ENCODING_LENGTH + 3 * ENCODING_LENGTH],
                    (UI_string_type) ii->minutes_buffer2);
            }
                break;
#endif

#if defined (__MMI_INLINE_ITEM_IP4__)
			case INLINE_ITEM_TYPE_IP4_EDIT:
            {
                U16 ID = INLINE_ITEM_IP4_EDIT_DATA_ID;
                wgui_inline_item_IP4 *ii = (wgui_inline_item_IP4*) wgui_inline_items[i].item;

                size =
                    INLINE_ITEM_DATA_ID_LENGTH + 4 * ENCODING_LENGTH + 4 * ENCODING_LENGTH + 4 * ENCODING_LENGTH +
                    4 * ENCODING_LENGTH;
                gui_memcpy((U8*) & data[offset], (U8*) & ID, INLINE_ITEM_DATA_ID_LENGTH);
                gui_strcpy((UI_string_type) & data[offset + INLINE_ITEM_DATA_ID_LENGTH], (UI_string_type) ii->b1);
                gui_strcpy(
                    (UI_string_type) & data[offset + INLINE_ITEM_DATA_ID_LENGTH + 4 * ENCODING_LENGTH],
                    (UI_string_type) ii->b2);
                gui_strcpy(
                    (UI_string_type) & data[offset + INLINE_ITEM_DATA_ID_LENGTH + 4 * ENCODING_LENGTH + 4 * ENCODING_LENGTH],
                    (UI_string_type) ii->b3);
                gui_strcpy(
                    (UI_string_type) & data[offset + INLINE_ITEM_DATA_ID_LENGTH + 4 * ENCODING_LENGTH + 4 * ENCODING_LENGTH + 4 * ENCODING_LENGTH],
                    (UI_string_type) ii->b4);
            }
                break;
#endif /* __MMI_INLINE_ITEM_IP4__ */				

#if defined (__MMI_INLINE_ITEM_DOW__)
            case INLINE_ITEM_TYPE_DOW_SELECT:
            {
                U16 ID = INLINE_ITEM_DOW_SELECT_DATA_ID;
                wgui_inline_item_DOW_select *ii = (wgui_inline_item_DOW_select*) wgui_inline_items[i].item;

                size = INLINE_ITEM_DATA_ID_LENGTH + 7;
                gui_memcpy((U8*) & data[offset], (U8*) & ID, INLINE_ITEM_DATA_ID_LENGTH);
                gui_memcpy((U8*) & data[offset + INLINE_ITEM_DATA_ID_LENGTH], (U8*) ii->list_of_states, 7);
            }
                break;
#endif				
        #if defined(__MMI_INSCREEN_MULTILINE_TEXTBOX__)
        #if defined( __MMI_INLINE_ITEM_MULTILINE_READ_ONLY__) || defined( __MMI_INLINE_ITEM_MULTILINE_EDIT__)
            case INLINE_ITEM_TYPE_MULTI_LINE_RD_ONLY:
            {
                U32 m;

                m = (offset + INLINE_ITEM_DATA_ID_LENGTH+3)&~3;

                size = INLINE_ITEM_DATA_ID_LENGTH + 4 + sizeof(multiline_inputbox_category_history);
                
                get_multiline_inputbox_category_history(
                    MMI_INLINE_BOX_HISTORY_ID,
                    &data[m]);
            }
                break;
        #endif        
        #endif /* defined(__MMI_INSCREEN_MULTILINE_TEXTBOX__) */
#if defined (__MMI_INLINE_ITEM_COLOR_SELECT__)		
            case INLINE_ITEM_TYPE_COLOR_SELECT:
            {                
                U16 ID = INLINE_ITEM_COLOR_SELECT_DATA_ID;
                S32 highlighted_index;
                S32 start_index;

                wgui_inline_item_color_select *ii = (wgui_inline_item_color_select*) wgui_inline_items[i].item;

                size = INLINE_ITEM_DATA_ID_LENGTH + 4;

                highlighted_index = ii->highlighted_index;
                start_index = ii->start_index;

                gui_memcpy((U8*) & data[offset], (U8*) & ID, INLINE_ITEM_DATA_ID_LENGTH);
                gui_memcpy((U8*) & data[offset + INLINE_ITEM_DATA_ID_LENGTH], (U8*) & highlighted_index, 2);
                gui_memcpy((U8*) & data[offset + INLINE_ITEM_DATA_ID_LENGTH + 2], (U8*) & start_index, 2);
            }
                break;
#endif				
        }
        offset += size;
        offset = (offset + 3)&~3;
    }
    return (data);
}



/*****************************************************************************
 * FUNCTION
 *  wgui_set_inline_data
 * DESCRIPTION
 *  set inline data
 * PARAMETERS
 *  inline_items        [IN]    inline item     
 *  n_items             [IN]    item number        
 *  data                [IN]    data     
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_set_inline_data(wgui_inline_item *inline_items, S32 n_items, U8 *data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i, offset = 0, size;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (data == NULL)
    {
        return;
    }
    for (i = 0; i < n_items; i++)
    {
        size = 0;
        switch (inline_items[i].flags & 0xff)
        {
            case INLINE_ITEM_TYPE_CAPTION:
            case INLINE_ITEM_TYPE_DISPLAY_ONLY:
            case INLINE_ITEM_TYPE_USER_DEFINED_SELECT:
                break;

            case INLINE_ITEM_TYPE_TEXT_EDIT:
            {
                S32 l;
                U16 ID = INLINE_ITEM_TEXT_EDIT_DATA_ID;
                wgui_inline_item_text_edit *ii = (wgui_inline_item_text_edit*) inline_items[i].item;

                l = ii->buffer_size * ENCODING_LENGTH;
                if (ii->input_type & INPUT_TYPE_PLUS_CHARACTER_HANDLING)
                {
                    l += ENCODING_LENGTH;
                }
                size = INLINE_ITEM_DATA_ID_LENGTH + INLINE_ITEM_DATA_SIZE_LENGTH + sizeof(S32) + l;
                reverse_pixtel_UI_memcpy((U8*) & data[offset], (U8*) & ID, INLINE_ITEM_DATA_ID_LENGTH);
                reverse_pixtel_UI_memcpy(
                    (U8*) & data[offset + INLINE_ITEM_DATA_ID_LENGTH],
                    (U8*) & l,
                    INLINE_ITEM_DATA_SIZE_LENGTH);
                reverse_pixtel_UI_memcpy(
                    (U8*) & data[offset + INLINE_ITEM_DATA_ID_LENGTH + INLINE_ITEM_DATA_SIZE_LENGTH],
                    (U8*) & (ii->UCS2_count),
                    sizeof(S32));
                reverse_pixtel_UI_memcpy(
                    (U8*) & data[offset + INLINE_ITEM_DATA_ID_LENGTH + INLINE_ITEM_DATA_SIZE_LENGTH + sizeof(S32)],
                    (U8*) ii->buffer,
                    l);
            }
                break;

            case INLINE_ITEM_TYPE_FULL_SCREEN_EDIT:
            {
                S32 l;
                U16 ID = INLINE_ITEM_FULL_SCREEN_EDIT_DATA_ID;
                U32 flags;
                S32 flags_size = sizeof(U32);
                wgui_inline_item_text_edit *ii = (wgui_inline_item_text_edit*) inline_items[i].item;

                l = ii->buffer_size * ENCODING_LENGTH;
                if (ii->input_type & INPUT_TYPE_PLUS_CHARACTER_HANDLING)
                {
                    l += ENCODING_LENGTH;
                }
                size = INLINE_ITEM_DATA_ID_LENGTH + INLINE_ITEM_DATA_SIZE_LENGTH + flags_size + (l << 1) + sizeof(S32);
                reverse_pixtel_UI_memcpy((U8*) & data[offset], (U8*) & ID, INLINE_ITEM_DATA_ID_LENGTH);
                reverse_pixtel_UI_memcpy(
                    (U8*) & data[offset + INLINE_ITEM_DATA_ID_LENGTH],
                    (U8*) & flags,
                    flags_size);
                reverse_pixtel_UI_memcpy(
                    (U8*) & data[offset + INLINE_ITEM_DATA_ID_LENGTH + flags_size],
                    (U8*) & l,
                    INLINE_ITEM_DATA_SIZE_LENGTH);
                reverse_pixtel_UI_memcpy(
                    (U8*) & data[offset + INLINE_ITEM_DATA_ID_LENGTH + flags_size + INLINE_ITEM_DATA_SIZE_LENGTH],
                    (U8*) & (ii->UCS2_count),
                    sizeof(S32));
                reverse_pixtel_UI_memcpy(
                    (U8*) & data[offset + INLINE_ITEM_DATA_ID_LENGTH + INLINE_ITEM_DATA_SIZE_LENGTH + flags_size + sizeof(S32)],
                    (U8*) wgui_inline_full_screen_text_edit_buffer,
                    l);
                reverse_pixtel_UI_memcpy(
                    (U8*) & data[offset + INLINE_ITEM_DATA_ID_LENGTH + INLINE_ITEM_DATA_SIZE_LENGTH + flags_size + sizeof(S32) + l],
                    (U8*) ii->buffer,
                    l);
                inline_items[i].flags &= 0x000000ff;
                inline_items[i].flags |= flags << 8;
                ii->flags |= (inline_items[i].flags & 0xffffff00);
            }
                break;

            case INLINE_ITEM_TYPE_SELECT:
            {
                U16 ID = INLINE_ITEM_SELECT_DATA_ID;
                S32 highlighted_item = 0;
                wgui_inline_item_select *ii = (wgui_inline_item_select*) inline_items[i].item;

                size = INLINE_ITEM_DATA_ID_LENGTH + 2;
                reverse_pixtel_UI_memcpy((U8*) & data[offset], (U8*) & ID, INLINE_ITEM_DATA_ID_LENGTH);
                reverse_pixtel_UI_memcpy(
                    (U8*) & data[offset + INLINE_ITEM_DATA_ID_LENGTH],
                    (U8*) & highlighted_item,
                    2);
                *ii->highlighted_item = highlighted_item;
                if ((highlighted_item >= 0) && (highlighted_item < ii->n_items))
                {
                    inline_items[i].text_p = ii->list_of_strings[highlighted_item];
                }
            }
                break;

            case INLINE_ITEM_TYPE_DATE:
            {
#if defined (__MMI_INLINE_ITEM_DATE__)
                U16 ID = INLINE_ITEM_DATE_DATA_ID;
                wgui_inline_item_date *ii = (wgui_inline_item_date*) inline_items[i].item;

                size = INLINE_ITEM_DATA_ID_LENGTH + 5 * ENCODING_LENGTH + 3 * ENCODING_LENGTH + 3 * ENCODING_LENGTH;
                reverse_pixtel_UI_memcpy((U8*) & data[offset], (U8*) & ID, INLINE_ITEM_DATA_ID_LENGTH);
                reverse_pixtel_UI_strcpy(
                    (UI_string_type) & data[offset + INLINE_ITEM_DATA_ID_LENGTH],
                    (UI_string_type) ii->year_buffer);
                reverse_pixtel_UI_strcpy(
                    (UI_string_type) & data[offset + INLINE_ITEM_DATA_ID_LENGTH + 5 * ENCODING_LENGTH],
                    (UI_string_type) ii->month_buffer);
                reverse_pixtel_UI_strcpy(
                    (UI_string_type) & data[offset + INLINE_ITEM_DATA_ID_LENGTH + 5 * ENCODING_LENGTH + 3 * ENCODING_LENGTH],
                    (UI_string_type) ii->day_buffer);
                ii->string_construct_callback(
                        inline_items[i].text_p,
                        ii->day_buffer,
                        ii->month_buffer,
                        ii->year_buffer);
#endif /* __MMI_INLINE_ITEM_DATE__ */
            }
                break;

            case INLINE_ITEM_TYPE_TIME:
            {
#if defined (__MMI_INLINE_ITEM_TIME__)
                U16 ID = INLINE_ITEM_TIME_DATA_ID;
                wgui_inline_item_time *ii = (wgui_inline_item_time*) inline_items[i].item;

                size = INLINE_ITEM_DATA_ID_LENGTH + 3 * ENCODING_LENGTH + 3 * ENCODING_LENGTH;
                reverse_pixtel_UI_memcpy((U8*) & data[offset], (U8*) & ID, INLINE_ITEM_DATA_ID_LENGTH);
                reverse_pixtel_UI_strcpy(
                    (UI_string_type) & data[offset + INLINE_ITEM_DATA_ID_LENGTH],
                    (UI_string_type) ii->hours_buffer);
                reverse_pixtel_UI_strcpy(
                    (UI_string_type) & data[offset + INLINE_ITEM_DATA_ID_LENGTH + 3 * ENCODING_LENGTH],
                    (UI_string_type) ii->minutes_buffer);
                ii->string_construct_callback(
                        inline_items[i].text_p,
                        ii->hours_buffer,
                        ii->minutes_buffer,
                        ii->AM_PM_flag);
#endif /* __MMI_INLINE_ITEM_TIME__ */
            }
                break;
#if defined (__MMI_INLINE_ITEM_TIME_PEROID__)   
            case INLINE_ITEM_TYPE_TIME_PERIOD:
            {
                U16 ID = INLINE_ITEM_TIME_PERIOD_DATA_ID;
                wgui_inline_item_time_period *ii = (wgui_inline_item_time_period*) inline_items[i].item;

                size =
                    INLINE_ITEM_DATA_ID_LENGTH + 3 * ENCODING_LENGTH + 3 * ENCODING_LENGTH + 3 * ENCODING_LENGTH +
                    3 * ENCODING_LENGTH;
                reverse_pixtel_UI_memcpy((U8*) & data[offset], (U8*) & ID, INLINE_ITEM_DATA_ID_LENGTH);
                reverse_pixtel_UI_strcpy(
                    (UI_string_type) & data[offset + INLINE_ITEM_DATA_ID_LENGTH],
                    (UI_string_type) ii->hours_buffer1);
                reverse_pixtel_UI_strcpy(
                    (UI_string_type) & data[offset + INLINE_ITEM_DATA_ID_LENGTH + 3 * ENCODING_LENGTH],
                    (UI_string_type) ii->minutes_buffer1);
                reverse_pixtel_UI_strcpy(
                    (UI_string_type) & data[offset + INLINE_ITEM_DATA_ID_LENGTH + 3 * ENCODING_LENGTH + 3 * ENCODING_LENGTH],
                    (UI_string_type) ii->hours_buffer2);
                reverse_pixtel_UI_strcpy(
                    (UI_string_type) & data[offset + INLINE_ITEM_DATA_ID_LENGTH + 3 * ENCODING_LENGTH + 3 * ENCODING_LENGTH + 3 * ENCODING_LENGTH],
                    (UI_string_type) ii->minutes_buffer2);
                ii->string_construct_callback(
                        inline_items[i].text_p,
                        ii->hours_buffer1,
                        ii->minutes_buffer1,
                        ii->AM_PM_flag1,
                        ii->hours_buffer2,
                        ii->minutes_buffer2,
                        ii->AM_PM_flag2);
            }
                break;
#endif         
#if defined (__MMI_INLINE_ITEM_IP4__)
            case INLINE_ITEM_TYPE_IP4_EDIT:
            {
                U16 ID = INLINE_ITEM_IP4_EDIT_DATA_ID;
                wgui_inline_item_IP4 *ii = (wgui_inline_item_IP4*) inline_items[i].item;

                size =
                    INLINE_ITEM_DATA_ID_LENGTH + 4 * ENCODING_LENGTH + 4 * ENCODING_LENGTH + 4 * ENCODING_LENGTH +
                    4 * ENCODING_LENGTH;
                reverse_pixtel_UI_memcpy((U8*) & data[offset], (U8*) & ID, INLINE_ITEM_DATA_ID_LENGTH);
                reverse_pixtel_UI_strcpy(
                    (UI_string_type) & data[offset + INLINE_ITEM_DATA_ID_LENGTH],
                    (UI_string_type) ii->b1);
                reverse_pixtel_UI_strcpy(
                    (UI_string_type) & data[offset + INLINE_ITEM_DATA_ID_LENGTH + 4 * ENCODING_LENGTH],
                    (UI_string_type) ii->b2);
                reverse_pixtel_UI_strcpy(
                    (UI_string_type) & data[offset + INLINE_ITEM_DATA_ID_LENGTH + 4 * ENCODING_LENGTH + 4 * ENCODING_LENGTH],
                    (UI_string_type) ii->b3);
                reverse_pixtel_UI_strcpy(
                    (UI_string_type) & data[offset + INLINE_ITEM_DATA_ID_LENGTH + 4 * ENCODING_LENGTH + 4 * ENCODING_LENGTH + 4 * ENCODING_LENGTH],
                    (UI_string_type) ii->b4);
                ii->string_construct_callback(inline_items[i].text_p, ii->b1, ii->b2, ii->b3, ii->b4);
            }
                break;
#endif /* __MMI_INLINE_ITEM_IP4__ */

#if defined (__MMI_INLINE_ITEM_DOW__)
            case INLINE_ITEM_TYPE_DOW_SELECT:
            {
                U16 ID = INLINE_ITEM_DOW_SELECT_DATA_ID;
                wgui_inline_item_DOW_select *ii = (wgui_inline_item_DOW_select*) inline_items[i].item;

                size = INLINE_ITEM_DATA_ID_LENGTH + 7;
                reverse_pixtel_UI_memcpy((U8*) & data[offset], (U8*) & ID, INLINE_ITEM_DATA_ID_LENGTH);
                reverse_pixtel_UI_memcpy(
                    (U8*) & data[offset + INLINE_ITEM_DATA_ID_LENGTH],
                    (U8*) ii->list_of_states,
                    7);
            }
                break;
#endif				
        #if defined(__MMI_INSCREEN_MULTILINE_TEXTBOX__)
        #if defined( __MMI_INLINE_ITEM_MULTILINE_READ_ONLY__) || defined( __MMI_INLINE_ITEM_MULTILINE_EDIT__)
            case INLINE_ITEM_TYPE_MULTI_LINE_RD_ONLY:
            {
                U32 m;
                m = (offset + INLINE_ITEM_DATA_ID_LENGTH+3)&~3;

                size = INLINE_ITEM_DATA_ID_LENGTH + 4 + sizeof(multiline_inputbox_category_history);
                set_multiline_inputbox_category_history(MMI_INLINE_BOX_HISTORY_ID, &data[m]);
            }
                break;
        #endif        
        #endif /* defined(__MMI_INSCREEN_MULTILINE_TEXTBOX__) */
#if defined (__MMI_INLINE_ITEM_COLOR_SELECT__) 		
            case INLINE_ITEM_TYPE_COLOR_SELECT:
            {               
                U16 ID = INLINE_ITEM_SELECT_DATA_ID;
                S32 highlighted_index = 0;
                S32 start_index = 0;

                wgui_inline_item_color_select *ii = (wgui_inline_item_color_select*) inline_items[i].item;

                size = INLINE_ITEM_DATA_ID_LENGTH + 4;

                reverse_pixtel_UI_memcpy((U8*) & data[offset], (U8*) & ID, INLINE_ITEM_DATA_ID_LENGTH);
                reverse_pixtel_UI_memcpy(
                    (U8*) & data[offset + INLINE_ITEM_DATA_ID_LENGTH],
                    (U8*) & highlighted_index,
                    2);
                reverse_pixtel_UI_memcpy(
                    (U8*) & data[offset + INLINE_ITEM_DATA_ID_LENGTH + 2],
                    (U8*) & start_index,
                    2);

                ii->highlighted_index = (U16) (highlighted_index);
                ii->start_index = (U16) (start_index);                
            }
                break;
#endif				
        }
        offset += size;
        offset = (offset + 3)&~3;
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_inline_set_items_csk
 * DESCRIPTION
 *  Default highlight handler used for inline editing menu
 * PARAMETERS
 *  item_index      [IN]        item index
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_inline_set_items_csk(S32 item_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
  
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    switch(item_type)
    {
        case INLINE_ITEM_TYPE_TEXT_EDIT:
        {
            set_softkey_icon(get_image(IMG_GLOBAL_COMMON_CSK), MMI_CENTER_SOFTKEY);
            register_softkey_handler(MMI_CENTER_SOFTKEY);
            set_softkey_function(get_left_softkey_function(KEY_EVENT_UP), KEY_EVENT_UP, MMI_CENTER_SOFTKEY);
            mmi_imc_key_setup_csk_function(get_left_softkey_function(KEY_EVENT_UP));
            break;
        }
#ifdef __MMI_INLINE_ITEM_MULTILINE_EDIT__
        case INLINE_ITEM_TYPE_MULTI_LINE_EDIT:
        {

            set_softkey_icon(get_image(IMG_GLOBAL_COMMON_CSK), MMI_CENTER_SOFTKEY);
            register_softkey_handler(MMI_CENTER_SOFTKEY);
            set_softkey_function(get_left_softkey_function(KEY_EVENT_UP), KEY_EVENT_UP, MMI_CENTER_SOFTKEY);
            mmi_imc_key_setup_csk_function(get_left_softkey_function(KEY_EVENT_UP));
            break;
        }
#endif		
        case INLINE_ITEM_TYPE_FULL_SCREEN_EDIT:
        {
             set_softkey_icon(get_image(IMG_GLOBAL_COMMON_CSK), MMI_CENTER_SOFTKEY);
             register_softkey_handler(MMI_CENTER_SOFTKEY);
             set_softkey_function(wgui_inline_item_key_handler, KEY_EVENT_UP, MMI_CENTER_SOFTKEY);
            mmi_imc_key_setup_csk_function(wgui_inline_item_key_handler);  
             break;
        }
#ifdef __MMI_INLINE_ITEM_IMAGETEXT__
        case INLINE_ITEM_IMAGE_TEXT_TYPE:
        {
            set_softkey_icon(get_image(IMG_GLOBAL_COMMON_CSK), MMI_CENTER_SOFTKEY);
            register_softkey_handler(MMI_CENTER_SOFTKEY);
            set_softkey_function(wgui_inline_item_key_handler, KEY_EVENT_UP, MMI_CENTER_SOFTKEY);
            mmi_imc_key_setup_csk_function(wgui_inline_item_key_handler); 
            break;
        }
#endif
#ifdef __MMI_INLINE_ITEM_DOW__
        case INLINE_ITEM_TYPE_DOW_SELECT:
        {
            set_softkey_icon(get_image(IMG_GLOBAL_COMMON_CSK), MMI_CENTER_SOFTKEY);
            register_softkey_handler(MMI_CENTER_SOFTKEY);
            set_softkey_function(handle_inline_DOW_select_LSK_up, KEY_EVENT_UP, MMI_CENTER_SOFTKEY);
            break;
        }
#endif		
    }
}

/*****************************************************************************
 * FUNCTION
 *  wgui_inline_reset_items_csk
 * DESCRIPTION
 *  reset csk
 * PARAMETERS
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_inline_reset_items_csk(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
  
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    clear_softkey_handler(MMI_CENTER_SOFTKEY);
    set_softkey_label(NULL, MMI_CENTER_SOFTKEY);
    set_softkey_icon(NULL, MMI_CENTER_SOFTKEY);
}

/*****************************************************************************
 * FUNCTION
 *  wgui_inline_edit_default_list_unhighlight_handler
 * DESCRIPTION
 *  Default unhighlight handler used for inline editing menu
 * PARAMETERS
 *  item_index      [IN]        item index
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_inline_edit_default_list_unhighlight_handler(S32 item_index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (wgui_inline_item_highlighted_index != item_index)
        return;
    
    /* Finalize current editing. */
    complete_inline_item_edit();
    
    /* W05.33 Fix inline text edit history issue */
    wgui_current_inline_item_type = 0;
    if (item_index > 0 &&
        ((wgui_inline_items[item_index].flags & INLINE_ITEM_TYPE_MULTI_LINE_EDIT) == INLINE_ITEM_TYPE_MULTI_LINE_EDIT))
    {
        reset_multiline_inputbox_vertical_scroll();
    }
    
#ifdef __MMI_INLINE_EDITOR_PRESS_ANY_KEY_ENTER_FULL_SCREEN__
    wgui_inline_key_enter_clear_key_handler();
#endif /* __MMI_INLINE_EDITOR_PRESS_ANY_KEY_ENTER_FULL_SCREEN__ */

    wgui_inline_reset_items_csk();


}

/*----------------------------------------------------------------------------
   Default highlight handler used for inline editing menu
----------------------------------------------------------------------------*/

static void wgui_inline_edit_default_list_goto_valid_item()
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if ((wgui_inline_edit_arrow_key_flag == CATEGORY57_UP_ARROW_KEY_FLAG) && (wgui_inline_edit_is_able_to_switch_highlight(0)))
    {
        gui_fixed_list_menu_goto_previous_item(&MMI_fixed_list_menu);
    }
    else if ((wgui_inline_edit_arrow_key_flag == CATEGORY57_DOWN_ARROW_KEY_FLAG) && (wgui_inline_edit_is_able_to_switch_highlight(1)))
    {
        gui_fixed_list_menu_goto_next_item(&MMI_fixed_list_menu);
    }
    else if((wgui_inline_edit_arrow_key_flag == CATEGORY57_DOWN_ARROW_KEY_FLAG))
    {
        gui_fixed_list_menu_goto_previous_item(&MMI_fixed_list_menu);
    }
    else
    {
        gui_fixed_list_menu_goto_next_item(&MMI_fixed_list_menu);
    }
}


static S32 wgui_inline_edit_default_list_get_caption_index(S32 item_index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 index = item_index - 1;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    while(index >= 0)
    {
        if (INLINE_GET_ITEM_TYPE(index) != INLINE_ITEM_TYPE_CAPTION)
        {
            break;
        }
        index--;
    }
    if (index != item_index - 1)
    {
        index = item_index - 1;
        if (index >= 0)
        {
            return index;
        }
    }
    return -1;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_inline_edit_default_list_is_valid_item
 * DESCRIPTION
 *  whether current item is right item, or go to right item
 * PARAMETERS
 *  item_index			[IN]		current item index
 * RETURNS
 *  if true, go to valid item and able to continue to handler highlight action
 *****************************************************************************/
static MMI_BOOL wgui_inline_edit_default_list_is_valid_item(S32 item_index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 item_type = 0;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (wgui_inline_item_highlighted_index == item_index)
    {
        return MMI_FALSE;
    }
    wgui_inline_item_highlighted_index = item_index;
    if(cui_inline_is_current_cui())
    {
        g_cui_inline_current_instance->highlight_item = item_index; 
    }
    item_type = INLINE_GET_ITEM_TYPE(item_index);
    if (wgui_inline_items[item_index].flags & INLINE_ITEM_DISABLED)
    {
        wgui_inline_edit_default_list_goto_valid_item();
        return MMI_FALSE;
    }
    
    if(item_type != INLINE_ITEM_TYPE_CAPTION)
    {
        if ((item_index > 0) && (wgui_inline_edit_arrow_key_flag == CATEGORY57_UP_ARROW_KEY_FLAG))
        {
            S32 ret_val = wgui_inline_edit_default_list_get_caption_index(item_index);
            if (ret_val >= 0)
            {
                wgui_inline_edit_arrow_key_flag = CATEGORY57_NO_KEY_FLAG;
                MMI_fixed_list_menu.highlighted_item = -1;
                gui_fixed_list_menu_goto_item(&MMI_fixed_list_menu, ret_val);
                return MMI_FALSE;
            }
        }
    }
    else
    {
        wgui_inline_edit_default_list_goto_valid_item();
        return MMI_FALSE;
    }
    return MMI_TRUE;
}



/*****************************************************************************
 * FUNCTION
 *  wgui_inline_edit_resize_multiline_height
 * DESCRIPTION
 *  reset multiline edit or multiline rd only item height according to list menu height
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_inline_edit_resize_multiline_height(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 item_type = 0, item_index = wgui_n_inline_items - 1;
    wgui_inline_item_text_edit *item = NULL;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    item_type = INLINE_GET_ITEM_TYPE(item_index);
    item = (wgui_inline_item_text_edit*)wgui_inline_items[item_index].item;
    if(item_type == INLINE_ITEM_TYPE_MULTI_LINE_RD_ONLY)
    {
        /*we limit the height of multilinerdonly so that it can be shown total in screen.*/
        item->height_of_item = MMI_fixed_list_menu.height / MMI_fixed_icontext_menuitem.height;	  
    }    
    if(item_type == INLINE_ITEM_TYPE_MULTI_LINE_EDIT)
    {
        if(item->max_lines >=  3)
        {
            /*we limit the height of multilinerdonly so that it can be shown total in screen.*/
            item->height_of_item = MMI_fixed_list_menu.height / MMI_fixed_icontext_menuitem.height;	  
        } 
    }
    gui_fixed_list_menu_locate_highlighted_item(&MMI_fixed_list_menu);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_inline_edit_default_resize_list_menu
 * DESCRIPTION
 *  resize inline list menu width and height
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_inline_edit_default_resize_list_menu(void)
{
#if defined(__MMI_TOUCH_SCREEN__)
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 width = 0, height = 0;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    height = mmi_imc_get_inline_editor_full_height();
    width = MMI_content_width;
    if (height)
    {
#ifdef __MMI_ICON_BAR_SUPPORT__
    #if defined(__MMI_FTE_SUPPORT__)
        if (wgui_icon_bar_is_created())
        {
            height -= MMI_ICON_BAR_HEIGHT;
        }
    #endif /* __MMI_FTE_SUPPORT__ */
#endif	
    #if defined(__MMI_SCREEN_ROTATE__)
        if (mmi_frm_is_screen_width_height_swapped())
        {
            width = MMI_ROTATED_CONTENT_WIDTH;
        }	 
    #endif /* __MMI_SCREEN_ROTATE__ */
    }

	
#if defined(__MMI_VIRTUAL_KEYBOARD__)
#ifdef __MMI_UI_VIRTUAL_KEYBOARD_DEFAULT_VERSION_1__
    if ((GUI_VIRTUAL_KEYBOARD_EMPTY_TRAY != MMI_virtual_keyboard.lang_type)
        && mmi_imc_is_connected() && (mmi_imc_get_current_imui_height() > 0 )
        && (!((current_wgui_inline_item->flags & INLINE_ITEM_TYPE_MASK) == INLINE_ITEM_TYPE_FULL_SCREEN_EDIT)))
#else
    if ((GUI_VIRTUAL_KEYBOARD_EMPTY_TRAY != g_wgui_virtual_keyboard_lang_type)
    && mmi_imc_is_connected() && (mmi_imc_get_current_imui_height() > 0 )
        && (!((current_wgui_inline_item->flags & INLINE_ITEM_TYPE_MASK) == INLINE_ITEM_TYPE_FULL_SCREEN_EDIT)))
#endif 
#else /* __MMI_VIRTUAL_KEYBOARD__ */
    if (mmi_imc_is_connected() && (mmi_imc_get_current_imui_height() > 0 )
        && (!((current_wgui_inline_item->flags & INLINE_ITEM_TYPE_MASK) == INLINE_ITEM_TYPE_FULL_SCREEN_EDIT)))
#endif
    {
    #ifdef __MMI_FTE_SUPPORT__  
        height = UI_device_height - MMI_fixed_list_menu.y - mmi_imc_get_current_imui_height();
    #else
        height = mmi_imc_get_inline_editor_full_height() - mmi_imc_get_current_imui_height();
    #endif
    }
    resize_fixed_list(width, height);
    wgui_inline_edit_resize_multiline_height();
#endif /* defined(__MMI_TOUCH_SCREEN__) */ 
}

/*****************************************************************************
 * FUNCTION
 *  wgui_inline_edit_default_list_highlight_handler
 * DESCRIPTION
 *  Default highlight handler used for inline editing menu
 * PARAMETERS
 *  item_index      [IN]        item index
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_inline_edit_default_list_highlight_handler(S32 item_index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 item_type = 0;
#if defined(__MMI_TOUCH_SCREEN__)
    const gui_virtual_keyboard_pen_enum disable_backspace_list[] = {GUI_VKBD_PEN_ALPHANUMERIC_KEY_0, GUI_VKBD_PEN_BAKSPACE, GUI_VKBD_PEN_NONE};
#endif /* defined(__MMI_TOUCH_SCREEN__) */ 

  
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!wgui_inline_edit_default_list_is_valid_item(item_index))
    {
        return ;
    }

    wgui_title_set_menu_shortcut_number(item_index + 1);
    MMI_highlighted_item_text = get_item_text(item_index);
    wgui_inline_item_handled = 0;
    register_default_hide_softkeys();
    complete_inline_item_edit = UI_dummy_function;
    current_wgui_inline_item = &wgui_inline_items[item_index];
	g_inline_lsk_functions = NULL;
	g_inline_lsk_string = NULL;
    
    mmi_imc_disconnect();

	item_type = INLINE_GET_ITEM_TYPE(item_index);
    switch (item_type)
    {
#if defined (__MMI_INLINE_ITEM_BUTTON__)
		case INLINE_ITEM_TYPE_BUTTON:
        {
            clear_left_softkey_handler();
            set_left_softkey_label(get_string(STR_GLOBAL_OK));
            register_left_softkey_handler();
            set_right_softkey_label(wgui_inline_edit_get_RSK_string());
            register_right_softkey_handler();
            set_right_softkey_function(execute_wgui_inline_edit_RSK_function, KEY_EVENT_UP);
        }
        break;
#endif

#if defined (__MMI_INLINE_ITEM_RADIO__) || defined (__MMI_INLINE_ITEM_CHECKBOX__)
        case INLINE_ITEM_TYPE_RADIO:
        case INLINE_ITEM_TYPE_CHECKBOX:
        {
            set_right_softkey_label(wgui_inline_edit_get_RSK_string());
            register_right_softkey_handler();
            set_right_softkey_function(execute_wgui_inline_edit_RSK_function, KEY_EVENT_UP);
        }
        break;
#endif		
        case INLINE_ITEM_TYPE_CAPTION:
        {
            return;
        }

        case INLINE_ITEM_TYPE_DISPLAY_ONLY:
        {
            clear_left_softkey_handler();
            set_left_softkey_label(NULL);
            set_right_softkey_label(wgui_inline_edit_get_RSK_string());
            register_right_softkey_handler();
            set_right_softkey_function(execute_wgui_inline_edit_RSK_function, KEY_EVENT_UP);

        }
            break;
        case INLINE_ITEM_TYPE_TEXT_EDIT:
        {
            set_left_softkey_label(get_string(STR_GLOBAL_SAVE));
            register_left_softkey_handler();
            /* Modified for LSK calling "Back" or "Done" functions based on dirty flag          */
            /* set_left_softkey_function(execute_wgui_inline_edit_DONE_function,KEY_EVENT_UP);     */
            /* set_left_softkey_function(execute_wgui_inline_edit_RSK_function,KEY_EVENT_UP); */
            /* MTK Terry Temp solution for in line LSK issue */
            
            /* Revise lsk function, regardless of done or disable done. */
            if(cui_inline_is_current_cui())
            {
                set_left_softkey_function(cui_inline_lsk_function, KEY_EVENT_UP);
                mmi_imc_key_setup_lsk_function(cui_inline_lsk_function);   
            }
            else
            {
                set_left_softkey_function(execute_wgui_inline_edit_DONE_function, KEY_EVENT_UP);
                mmi_imc_key_setup_lsk_function(execute_wgui_inline_edit_DONE_function);
            }

            {
                /* W06.18 Check history id before setting the type of virtual keyboard */
                inline_text_edit_history *h = (inline_text_edit_history*) wgui_current_history_buffer;
                wgui_inline_item_text_edit *i = (wgui_inline_item_text_edit*) wgui_inline_items[item_index].item;

                if (wgui_current_history_buffer && history_valid(h->history_ID, INLINE_TEXT_EDIT_HISTORY_ID))
                {
                    mmi_imc_set_input_method_history(&(h->ime_history));
                }

                mmi_imm_set_required_mode_list(i->input_type & INPUT_TYPE_MASK, i->required_input_mode_set, IMM_INPUT_MODE_NONE);
                g_mmi_editor_hanler.input_box_type = MMI_EDITOR_INLINE_INPUT_BOX;
                g_mmi_editor_hanler.input_box_sub_type = MMI_EDITOR_NORMAL_INPUT_BOX;
                g_mmi_editor_hanler.input_box_handler = &MMI_inline_singleline_inputbox;
                mmi_imc_editor_is_not_ready_when_connecting();
                mmi_imc_connect((void *)&g_mmi_editor_hanler, mmi_input_box_msg_call_back_inline);
            }
        }
            break;
#if defined (__MMI_INLINE_ITEM_MULTILINE_EDIT__)			
        case INLINE_ITEM_TYPE_MULTI_LINE_EDIT:
        {
        
        #if defined(__MMI_MULTITAP_FOR_STAR_AND_POUND__)
            set_left_softkey_label((UI_string_type) get_string(STR_GLOBAL_OPTIONS));
        #else /* defined(__MMI_MULTITAP_FOR_STAR_AND_POUND__) */ 
            set_left_softkey_label(get_string(STR_GLOBAL_OK));
        #endif /* defined(__MMI_MULTITAP_FOR_STAR_AND_POUND__) */ 
            register_left_softkey_handler();
            if(cui_inline_is_current_cui())
            {
                set_left_softkey_function(cui_inline_lsk_function, KEY_EVENT_UP);
                mmi_imc_key_setup_lsk_function(cui_inline_lsk_function);
                set_softkey_function(cui_inline_lsk_function, KEY_EVENT_UP, MMI_CENTER_SOFTKEY);
            }
            else
            {
                set_left_softkey_function(execute_wgui_inline_edit_RSK_function, KEY_EVENT_UP);
                mmi_imc_key_setup_lsk_function(execute_wgui_inline_edit_RSK_function);
            }
			
            if (wgui_inline_list_menu_changed)
            {
                inline_text_edit_RSK_label_string = (UI_string_type) get_string(STR_GLOBAL_BACK);
            }
            else
            {
                inline_text_edit_RSK_label_string = wgui_inline_edit_get_RSK_string();
            }
            set_right_softkey_label(inline_text_edit_RSK_label_string);
            
            {
                multiline_inputbox_category_history *h = (multiline_inputbox_category_history*) wgui_current_history_buffer;
                wgui_inline_item_text_edit *i = (wgui_inline_item_text_edit*) wgui_inline_items[item_index].item;
                
                if (wgui_current_history_buffer && history_valid(h->history_ID, INLINE_MULTI_LINE_EDIT_HISTORY_ID))
                {
                    mmi_imc_set_input_method_history(&(h->ime_history));
                }
                
                mmi_imm_set_required_mode_list(i->input_type & INPUT_TYPE_MASK, NULL, IMM_INPUT_MODE_NONE);
                g_mmi_editor_hanler.input_box_type = MMI_EDITOR_INLINE_INPUT_BOX;
                g_mmi_editor_hanler.input_box_sub_type = MMI_EDITOR_INLINE_MULTILINE_INPUT_BOX;
                g_mmi_editor_hanler.input_box_handler = &MMI_multiline_inputbox;
                mmi_imc_editor_is_not_ready_when_connecting();
                mmi_imc_connect((void *)&g_mmi_editor_hanler, mmi_input_box_msg_call_back_inline);
            }
        }
            break;
#endif
        case INLINE_ITEM_TYPE_FULL_SCREEN_EDIT:
        {
            set_left_softkey_label(get_string(STR_GLOBAL_EDIT));
            register_left_softkey_handler();
            set_right_softkey_label(wgui_inline_edit_get_RSK_string());
            register_right_softkey_handler();
            set_right_softkey_function(execute_wgui_inline_edit_RSK_function, KEY_EVENT_UP);
            
        #if defined(__MMI_TOUCH_SCREEN__)
            /* W06.08 Reset wgui_current_history_buffer if !INLINE_ITEM_OPEN to avoid incorrect use */
            if (!(wgui_inline_items[item_index].flags & INLINE_ITEM_OPEN))
            {
                wgui_current_history_buffer = NULL;
            }
        #endif /* defined(__MMI_TOUCH_SCREEN__) */ 
        }
            break;
#if defined (__MMI_INLINE_ITEM_IMAGETEXT__)
        case INLINE_ITEM_IMAGE_TEXT_TYPE:
        {
            set_left_softkey_label(get_string(STR_GLOBAL_EDIT));
            register_left_softkey_handler();
            set_right_softkey_label(wgui_inline_edit_get_RSK_string());
            register_right_softkey_handler();
            set_right_softkey_function(execute_wgui_inline_edit_RSK_function, KEY_EVENT_UP);
        }
            break;
#endif 

#if defined (__MMI_INLINE_ITEM_MULTILINE_READ_ONLY__)
        case INLINE_ITEM_TYPE_MULTI_LINE_RD_ONLY:
        {
            set_right_softkey_label(wgui_inline_edit_get_RSK_string());
            register_right_softkey_handler();
            set_right_softkey_function(execute_wgui_inline_edit_RSK_function, KEY_EVENT_UP);
        }
            break;
#endif			
        case INLINE_ITEM_TYPE_SELECT:
        {
            clear_left_softkey_handler();
            set_left_softkey_label(NULL);
            set_right_softkey_label(wgui_inline_edit_get_RSK_string());
            register_right_softkey_handler();
            set_right_softkey_function(execute_wgui_inline_edit_RSK_function, KEY_EVENT_UP);
        }
            break;
        case INLINE_ITEM_TYPE_USER_DEFINED_SELECT:
        {
            clear_left_softkey_handler();
            set_left_softkey_label(NULL);
            set_right_softkey_label(wgui_inline_edit_get_RSK_string());
            register_right_softkey_handler();
            set_right_softkey_function(execute_wgui_inline_edit_RSK_function, KEY_EVENT_UP);
        }
            break;
        case INLINE_ITEM_TYPE_DATE:
        {
#if defined (__MMI_INLINE_ITEM_DATE__)
            set_left_softkey_label(NULL);
            register_left_softkey_handler();
            set_right_softkey_label(wgui_inline_edit_get_RSK_string());
            register_right_softkey_handler();
            set_right_softkey_function(execute_wgui_inline_edit_RSK_function, KEY_EVENT_UP);
            
            {
                inline_date_edit_history *h = (inline_date_edit_history*) wgui_current_history_buffer;
                if (wgui_current_history_buffer && history_valid(h->history_ID, INLINE_DATE_HISTORY_ID))
                {
                    mmi_imc_set_input_method_history(&(h->ime_history));
                }
            }

		#if defined(__MMI_TOUCH_SCREEN__)
			mmi_imm_set_events(MMI_FALSE, disable_backspace_list);
		#endif /* __MMI_TOUCH_SCREEN__ */
            mmi_imm_set_required_mode_list(IMM_INPUT_TYPE_NUMERIC, NULL, IMM_INPUT_MODE_NONE);
            g_mmi_editor_hanler.input_box_type = MMI_EDITOR_INLINE_INPUT_BOX;
            g_mmi_editor_hanler.input_box_sub_type = MMI_EDITOR_DATE;
            g_mmi_editor_hanler.input_box_handler = &wgui_inline_date_input;
            mmi_imc_connect((void *)&g_mmi_editor_hanler, mmi_input_box_msg_call_back_inline);
#endif /* __MMI_INLINE_ITEM_DATE__ */
        }
            break;
        case INLINE_ITEM_TYPE_TIME:
        {
#if defined (__MMI_INLINE_ITEM_TIME__)
            set_left_softkey_label(NULL);
            register_left_softkey_handler();
            set_right_softkey_label(wgui_inline_edit_get_RSK_string());
            register_right_softkey_handler();
            set_right_softkey_function(execute_wgui_inline_edit_RSK_function, KEY_EVENT_UP);
            
            {
                inline_time_edit_history *h = (inline_time_edit_history*) wgui_current_history_buffer;
                if (wgui_current_history_buffer && history_valid(h->history_ID, INLINE_TIME_HISTORY_ID))
                {
                    mmi_imc_set_input_method_history(&(h->ime_history));
                }  
            }

		#if defined(__MMI_TOUCH_SCREEN__)
			mmi_imm_set_events(MMI_FALSE, disable_backspace_list);
		#endif /* __MMI_TOUCH_SCREEN__ */
            mmi_imm_set_required_mode_list(IMM_INPUT_TYPE_NUMERIC, NULL, IMM_INPUT_MODE_NONE);
            g_mmi_editor_hanler.input_box_type = MMI_EDITOR_INLINE_INPUT_BOX;
            g_mmi_editor_hanler.input_box_sub_type = MMI_EDITOR_TIME;
            g_mmi_editor_hanler.input_box_handler = &wgui_inline_time_input;
            mmi_imc_connect((void *)&g_mmi_editor_hanler, mmi_input_box_msg_call_back_inline);
#endif /* __MMI_INLINE_ITEM_TIME__ */
        }
            break;
#if defined (__MMI_INLINE_ITEM_TIME_PEROID__)               
        case INLINE_ITEM_TYPE_TIME_PERIOD:
        {
            set_left_softkey_label(NULL);
            register_left_softkey_handler();
            set_right_softkey_label(wgui_inline_edit_get_RSK_string());
            register_right_softkey_handler();
            set_right_softkey_function(execute_wgui_inline_edit_RSK_function, KEY_EVENT_UP);
            
            {
                inline_time_period_edit_history *h = (inline_time_period_edit_history*) wgui_current_history_buffer;
                if (wgui_current_history_buffer && history_valid(h->history_ID, INLINE_TIME_PERIOD_HISTORY_ID))
                {
                    mmi_imc_set_input_method_history(&(h->ime_history));
                }   
            }
            
            mmi_imm_set_required_mode_list(IMM_INPUT_TYPE_NUMERIC, NULL, IMM_INPUT_MODE_NONE);
            g_mmi_editor_hanler.input_box_type = MMI_EDITOR_INLINE_INPUT_BOX;
            g_mmi_editor_hanler.input_box_sub_type = MMI_EDITOR_TIME_PERIOD;
            g_mmi_editor_hanler.input_box_handler = &wgui_inline_time_period_input;
            mmi_imc_connect((void *)&g_mmi_editor_hanler, mmi_input_box_msg_call_back_inline);
        }
            break;
#endif            
#if defined (__MMI_INLINE_ITEM_DOW__)
		case INLINE_ITEM_TYPE_DOW_SELECT:
        {
        }
            break;
#endif	
#if defined (__MMI_INLINE_ITEM_IP4__)
        case INLINE_ITEM_TYPE_IP4_EDIT:
        {
            set_left_softkey_label(NULL);
            register_left_softkey_handler();
            set_right_softkey_label(wgui_inline_edit_get_RSK_string());
            register_right_softkey_handler();
            set_right_softkey_function(execute_wgui_inline_edit_RSK_function, KEY_EVENT_UP);
            
            {
                inline_IP4_edit_history *h = (inline_IP4_edit_history*) wgui_current_history_buffer;
                if (wgui_current_history_buffer && history_valid(h->history_ID, INLINE_IP4_HISTORY_ID))
                {
                    mmi_imc_set_input_method_history(&(h->ime_history));
                } 
            }

		#if defined(__MMI_TOUCH_SCREEN__)
			mmi_imm_set_events(MMI_FALSE, disable_backspace_list);
		#endif /* __MMI_TOUCH_SCREEN__ */
            mmi_imm_set_required_mode_list(IMM_INPUT_TYPE_NUMERIC, NULL, IMM_INPUT_MODE_NONE);
            g_mmi_editor_hanler.input_box_type = MMI_EDITOR_INLINE_INPUT_BOX;
            g_mmi_editor_hanler.input_box_sub_type = MMI_EDITOR_IP4;
            g_mmi_editor_hanler.input_box_handler = &wgui_inline_IP4_input;
            mmi_imc_connect((void *)&g_mmi_editor_hanler, mmi_input_box_msg_call_back_inline);
        }
            break;
#endif /* __MMI_INLINE_ITEM_IP4__ */	
#if defined (__MMI_INLINE_ITEM_COLOR_SELECT__)  
        case INLINE_ITEM_TYPE_COLOR_SELECT:
        {          
            clear_left_softkey_handler();
            set_left_softkey_label(NULL);
            set_right_softkey_label(wgui_inline_edit_get_RSK_string());
            register_right_softkey_handler();
            set_right_softkey_function(execute_wgui_inline_edit_RSK_function, KEY_EVENT_UP);

        }
            break;
#endif		
#if defined (__MMI_INLINE_ITEM_PROGRESS_BAR__)
        case INLINE_ITEM_TYPE_PROGRESS_BAR:
        {
            clear_left_softkey_handler();
            set_left_softkey_label(NULL);
            set_right_softkey_label(wgui_inline_edit_get_RSK_string());
            register_right_softkey_handler();
            set_right_softkey_function(execute_wgui_inline_edit_RSK_function, KEY_EVENT_UP);
            break;  
        }
#endif
    }
    
#ifdef __MMI_INLINE_HIGHLIGHT_CAPTION__
    //if current highlight item has caption, get the caption index
    if((item_index>0) && ( (wgui_inline_items[item_index-1].flags & 0xff) == INLINE_ITEM_TYPE_CAPTION))
	{
		wgui_inline_should_hl_caption_index = item_index-1;
	}
	else
	{
        wgui_inline_should_hl_caption_index = -1;
	}
#endif 

    if(cui_inline_is_current_cui())
    {
        cui_inline_lock_draw_softkey(MMI_TRUE);
        cui_inline_set_item_default_softkey_attribute(item_index);
		cui_inline_lock_draw_softkey(MMI_FALSE);
        if((item_type != INLINE_ITEM_TYPE_DOW_SELECT) &&
           (item_type != INLINE_ITEM_TYPE_FULL_SCREEN_EDIT) &&
           (item_type != INLINE_ITEM_IMAGE_TEXT_TYPE)
           )
        {
            register_left_softkey_handler();
            set_left_softkey_function(cui_inline_lsk_function, KEY_EVENT_UP);
            mmi_imc_key_setup_lsk_function(cui_inline_lsk_function);

            if (wgui_inline_list_menu_rsk_back)
            {
                register_softkey_handler(MMI_CENTER_SOFTKEY);
                set_softkey_function(cui_inline_lsk_function, KEY_EVENT_UP, MMI_CENTER_SOFTKEY);
                mmi_imc_key_setup_csk_function(cui_inline_lsk_function);
            }
        }
    }
    else
    {
        wgui_inline_set_items_csk(item_type);
    }
    
#ifdef __MMI_INLINE_EDITOR_PRESS_ANY_KEY_ENTER_FULL_SCREEN__
    wgui_inline_key_enter_register_key_handler(item_index);
#endif /* __MMI_INLINE_EDITOR_PRESS_ANY_KEY_ENTER_FULL_SCREEN__ */

#if defined(__MMI_TOUCH_SCREEN__)
    if (!mmi_pen_editor_is_closecategory57)
    {
        wgui_inline_edit_default_resize_list_menu();
    }
#endif

    gdi_layer_lock_frame_buffer();
    cui_inline_lock_draw_softkey(MMI_TRUE);
	MMI_user_highlight_handler_Ext((U8)eListhighlight, item_index);
	cui_inline_lock_draw_softkey(MMI_FALSE);
#if defined(__MMI_TOUCH_SCREEN__)
    redraw_softkey(MMI_CENTER_SOFTKEY);
#endif /* defined(__MMI_TOUCH_SCREEN__) */ 
    
#ifdef __MMI_ICON_BAR_SUPPORT__
#if defined(__MMI_FTE_SUPPORT__)
    if(MMI_TRUE == wgui_icon_bar_is_created())
    {
        wgui_icon_bar_move(0, UI_device_height - MMI_softkey_height - MMI_ICON_BAR_HEIGHT);
        wgui_icon_bar_resize(UI_device_width, MMI_ICON_BAR_HEIGHT);
        wgui_icon_bar_show();
    }
#endif
#endif
    gdi_layer_unlock_frame_buffer();
    gdi_layer_blt_previous(0, UI_device_height - MMI_button_bar_height, UI_device_width - 1, UI_device_height - 1);
}


/*****************************************************************************
 * FUNCTION
 *  category_inline_edit_menuitem_flags
 * DESCRIPTION
 *  set flags as ~UI_MENUITEM_INLINE_EDIT_OBJECT
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void category_inline_edit_menuitem_flags(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (i = 0; i < MAX_INLINE_ITEMS; i++)
    {
        MMI_fixed_icontext_menuitems[i].flags &= ~UI_MENUITEM_INLINE_EDIT_OBJECT;
    }
}



/*****************************************************************************
 * FUNCTION
 *  wgui_show_inline_edit_menuitem
 * DESCRIPTION
 *  show inline edit menuitem
 * PARAMETERS
 *  x                  [IN]    left-top corner x coordinate    
 *  y                  [IN]    left-top corner y coordinate    
 *  width              [IN]    width    
 *  height             [IN]    height                 
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_show_inline_edit_menuitem(S32 x, S32 y, S32 width, S32 height)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if ((MMI_fixed_list_menu.current_displayed_item < 0) ||
        (MMI_fixed_list_menu.current_displayed_item > (MMI_fixed_list_menu.n_items - 1)))
    {
        return;
    }

    wgui_inline_edit_menuitem_adjust_layout(MMI_fixed_list_menu.current_displayed_item, &x, &y, &width, &height);    

    if (y > MMI_fixed_list_menu.y + MMI_fixed_list_menu.height)
    {
        return ;
    }
    
    switch (wgui_inline_items[MMI_fixed_list_menu.current_displayed_item].flags & 0xff)
    {
#if defined (__MMI_INLINE_ITEM_CHECKBOX__)    
        case INLINE_ITEM_TYPE_CHECKBOX:
			wgui_show_inline_checkbox_menuitem(
				x,
				y,
				width,
				height,
				&wgui_inline_items[MMI_fixed_list_menu.current_displayed_item]);
			break;
#endif
#if defined (__MMI_INLINE_ITEM_RADIO__)
        case INLINE_ITEM_TYPE_RADIO:
			wgui_show_inline_radio_menuitem(
				x,
				y,
				width,
				height,
				&wgui_inline_items[MMI_fixed_list_menu.current_displayed_item]);
			break;
#endif

#if defined (__MMI_INLINE_ITEM_DOW__)
        case INLINE_ITEM_TYPE_DOW_SELECT:
            wgui_show_DOW_list_menuitem(
                x,
                y,
                width,
                height,
                &wgui_inline_items[MMI_fixed_list_menu.current_displayed_item]);
            break;
#endif			
        case INLINE_ITEM_TYPE_TEXT_EDIT:
            wgui_show_inline_text_edit_list_menuitem(
                x,
                y,
                width,
                height,
                &wgui_inline_items[MMI_fixed_list_menu.current_displayed_item]);
            break;
        case INLINE_ITEM_TYPE_DATE:
#if defined (__MMI_INLINE_ITEM_DATE__)
            wgui_show_inline_date_list_menuitem(
                x,
                y,
                width,
                height,
                &wgui_inline_items[MMI_fixed_list_menu.current_displayed_item]);
#endif /* __MMI_INLINE_ITEM_DATE__ */
            break;
        case INLINE_ITEM_TYPE_TIME:
#if defined (__MMI_INLINE_ITEM_TIME__)
            wgui_show_inline_time_list_menuitem(
                x,
                y,
                width,
                height,
                &wgui_inline_items[MMI_fixed_list_menu.current_displayed_item]);
#endif /* __MMI_INLINE_ITEM_TIME__ */
            break;
#if defined (__MMI_INLINE_ITEM_TIME_PEROID__)             
        case INLINE_ITEM_TYPE_TIME_PERIOD:
            wgui_show_inline_time_period_list_menuitem(
                x,
                y,
                width,
                height,
                &wgui_inline_items[MMI_fixed_list_menu.current_displayed_item]);
            break;
#endif   
#if defined (__MMI_INLINE_ITEM_IP4__)
        case INLINE_ITEM_TYPE_IP4_EDIT:
            wgui_show_inline_IP4_list_menuitem(
                x,
                y,
                width,
                height,
                &wgui_inline_items[MMI_fixed_list_menu.current_displayed_item]);
            break;
#endif /* __MMI_INLINE_ITEM_IP4__ */		
#if defined (__MMI_INLINE_ITEM_IMAGETEXT__)
        case INLINE_ITEM_IMAGE_TEXT_TYPE:
            wgui_show_image_text_item(
                x,
                y,
                width,
                height,
                &wgui_inline_items[MMI_fixed_list_menu.current_displayed_item]);
            break;
#endif   
#ifdef  __MMI_FTE_SUPPORT__
        case INLINE_ITEM_TYPE_SELECT:
            wgui_show_inline_select_arrow(
                x,
                y,
                width,
                height,
                &wgui_inline_items[MMI_fixed_list_menu.current_displayed_item]);
            break;
#endif			
    #if defined(__MMI_INSCREEN_MULTILINE_TEXTBOX__)
    #if defined( __MMI_INLINE_ITEM_MULTILINE_READ_ONLY__) || defined( __MMI_INLINE_ITEM_MULTILINE_EDIT__)
        case INLINE_ITEM_TYPE_MULTI_LINE_EDIT:
            wgui_show_inline_inscreen_multi_line_edit(
                x,
                y,
                width,
                height,
                &wgui_inline_items[MMI_fixed_list_menu.current_displayed_item]);
            break;
        case INLINE_ITEM_TYPE_MULTI_LINE_RD_ONLY:
            wgui_show_inline_multi_line_rd_only(
                x,
                y,
                width,
                height,
                &wgui_inline_items[MMI_fixed_list_menu.current_displayed_item]);
            break;
    #endif        
    #endif /* defined(__MMI_INSCREEN_MULTILINE_TEXTBOX__) */ 
#if defined (__MMI_INLINE_ITEM_COLOR_SELECT__)	
        case INLINE_ITEM_TYPE_COLOR_SELECT:            
            wgui_show_inline_color_select_list_menuitem(
                x,
                y,
                width,
                height,
                &wgui_inline_items [MMI_fixed_list_menu.current_displayed_item]);
            break;
#endif			
        case INLINE_ITEM_TYPE_DISPLAY_ONLY:
        case INLINE_ITEM_TYPE_FULL_SCREEN_EDIT:
#ifdef __MMI_FTE_SUPPORT__
            wgui_show_inline_fte_displayonly_item_unhighlight(
                x,
                y,
                width,
                height,
                &wgui_inline_items[MMI_fixed_list_menu.current_displayed_item]);
            break;
        case INLINE_ITEM_TYPE_CAPTION:
            wgui_show_inline_fte_caption_item(
                x,
                y,
                width,
                height,
                &wgui_inline_items[MMI_fixed_list_menu.current_displayed_item]);
            break;
        case INLINE_ITEM_TYPE_USER_DEFINED_SELECT:
            wgui_show_inline_select_arrow(
                x,
                y,
                width,
                height,
                &wgui_inline_items[MMI_fixed_list_menu.current_displayed_item]);
            break;      
#else
#ifdef __MMI_INLINE_HIGHLIGHT_CAPTION__
        case INLINE_ITEM_TYPE_CAPTION:
            wgui_show_inline_caption_item(
                x,
                y,
                width,
                height,
                &wgui_inline_items[MMI_fixed_list_menu.current_displayed_item]);
        case INLINE_ITEM_TYPE_SELECT:
#endif
			wgui_show_inline_displayonly_item(
                x,
                y,
                width,
                height,
                &wgui_inline_items[MMI_fixed_list_menu.current_displayed_item]);
            break;
#endif
#if defined (__MMI_INLINE_ITEM_BUTTON__)
        case INLINE_ITEM_TYPE_BUTTON:
            wgui_show_inline_buttion_item(
                x,
                y,
                width,
                height,
                &wgui_inline_items[MMI_fixed_list_menu.current_displayed_item]);
            break;
#endif		
#if defined (__MMI_INLINE_ITEM_PROGRESS_BAR__)
        case INLINE_ITEM_TYPE_PROGRESS_BAR:
            wgui_show_inline_progress_bar_list_menuitem(
                x,
                y,
                width,
                height,
                &wgui_inline_items[MMI_fixed_list_menu.current_displayed_item]);
            break;
#endif            

    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_setup_inline_edit_themes
 * DESCRIPTION
 *  setup inline edit themes
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_setup_inline_edit_themes(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_set_date_time_input_focussed_theme();
#if defined (__MMI_INLINE_ITEM_PROGRESS_BAR__)    
    wgui_inline_set_unfocussed_progress_bar_theme();
    wgui_inline_set_focussed_progress_bar_theme();
#endif    
    temp_inline_edit_background_filler = date_time_input_background_filler;
    temp_inline_edit_background_filler3 = date_time_input_background_filler;
    temp_inline_edit_background_filler3.flags &= 0x00000fff;
    wgui_inline_select_fixed_text_menuitem_theme.normal_filler =
        wgui_inline_fixed_icontext_menuitem_theme.normal_filler;
    wgui_inline_select_fixed_text_menuitem_theme.disabled_filler =
        wgui_inline_fixed_icontext_menuitem_theme.disabled_filler;
    wgui_inline_select_fixed_text_menuitem_theme.selected_filler =
        wgui_inline_fixed_icontext_menuitem_theme.selected_filler;
    wgui_inline_select_fixed_text_menuitem_theme.focussed_filler =
        wgui_inline_fixed_icontext_menuitem_theme.focussed_filler;
    wgui_inline_select_fixed_text_menuitem_theme.focussed_without_sc_filler =
        wgui_inline_fixed_icontext_menuitem_theme.focussed_without_sc_filler;
    wgui_inline_select_fixed_text_menuitem_theme.normal_text_color =
        wgui_inline_fixed_icontext_menuitem_theme.normal_text_color;
    wgui_inline_select_fixed_text_menuitem_theme.disabled_text_color =
        wgui_inline_fixed_icontext_menuitem_theme.disabled_text_color;
    wgui_inline_select_fixed_text_menuitem_theme.selected_text_color =
        wgui_inline_fixed_icontext_menuitem_theme.selected_text_color;
    wgui_inline_select_fixed_text_menuitem_theme.focussed_text_color =
        wgui_inline_fixed_icontext_menuitem_theme.focussed_text_color;
#ifdef __MMI_FTE_SUPPORT__    
    /* For highlight selector text color */
    wgui_inline_select_fixed_text_menuitem_theme.focussed_text_color =
     wgui_inline_singleline_inputbox_focussed_theme.normal_text_color;
    /* For unhighlight selector text color */
    wgui_inline_select_fixed_text_menuitem_theme.normal_text_color = 
       wgui_inline_singleline_inputbox_focussed_theme.normal_text_color; 
    wgui_inline_select_fixed_text_menuitem_theme.selected_filler = 
        current_MMI_theme->inline_list_selected_item_filler;
#endif
}


/*****************************************************************************
 * FUNCTION
 *  RegisterInlineItemChangedNotification
 * DESCRIPTION
 *  Register inline item changed notification callback
 * PARAMETERS
 *  callback        [IN]        Callback function to application
 * RETURNS
 *  void
 *****************************************************************************/
void RegisterInlineItemChangedNotification(void (*callback) (U16 index))
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    inline_item_changed_handler = callback;
}


/*****************************************************************************
 * FUNCTION
 *  ResetInlineItemChangedNotification
 * DESCRIPTION
 *  Reset inline item changed notification callback
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ResetInlineItemChangedNotification(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    inline_item_changed_handler = NULL;
}


/*****************************************************************************
* FUNCTION
*  wgui_inline_malloc
* DESCRIPTION
*  allocate memory from inline editor ADM
* PARAMETERS
*  size      [IN]          wanted size
* RETURNS
*  memory pointer
*****************************************************************************/
static void *wgui_inline_malloc(U16 size)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    void *ptr = NULL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_DBG_ASSERT(inline_adm_id);
    MMI_DBG_ASSERT(size > 0);
    
    ptr = kal_adm_alloc(inline_adm_id, size);
    
    if (ptr == NULL)
    {
        /* run out of memory: ADM problem or buffer too small ?? */
        kal_uint32 left_size;

        left_size = kal_adm_get_total_left_size(inline_adm_id);

    #ifndef __MTK_TARGET__
        kal_printf("ADM: buffer not enough, left size:%d\n", left_size);
    #endif 
        MMI_DBG_ASSERT(0);/* Inline editor ADM buffer is not enough */


        if (left_size >= size)
        {
            kal_adm_print_log(inline_adm_id);    /* fragmentation */
            MMI_DBG_ASSERT(0);
        }
    }

    return ptr;

}


/*****************************************************************************
* FUNCTION
*  wgui_inline_alloc_mem
* DESCRIPTION
*  allocate memory for inline editor
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void wgui_inline_alloc_mem(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_wgui_inine_items_buffer = (U8*) mmi_frm_scrmem_alloc(WGUI_INLINE_EDITOR_SCR_MEM_SIZE);

    MMI_ASSERT(g_wgui_inine_items_buffer);

#if defined(__MMI_PHB_PHOTO_STICKER_SUPPORT__)
    wgui_inline_caption_thumbnail_buffer = (U8*)mmi_frm_scrmem_alloc_framebuffer(INLINE_FTE_CAPTION_THUMBNAIL_SIZE);
    MMI_ASSERT(wgui_inline_caption_thumbnail_buffer);
#endif /* __MMI_PHB_PHOTO_STICKER_SUPPORT__ */
    
    memset(g_wgui_inine_items_buffer, 0, WGUI_INLINE_EDITOR_SCR_MEM_SIZE);
    
    inline_adm_id = NULL;
    inline_adm_id = kal_adm_create(
                        g_wgui_inine_items_buffer,
                        WGUI_INLINE_EDITOR_SCR_MEM_SIZE,
                        NULL,
                        KAL_FALSE);

    if (inline_adm_id == NULL)
    {
        /* ADM creation : Fail */
        MMI_DBG_ASSERT(0);
    }

    wgui_inline_full_screen_text_edit_buffer = wgui_inline_malloc(MAX_INLINE_FULL_SCREEN_TEXT_EDIT_BUFFER_SIZE * sizeof(U8));
    wgui_inline_select_items = wgui_inline_malloc(MAX_INLINE_SELECT_MENU_ITEMS * sizeof(gui_horizontal_select_item_struct));
}


/*****************************************************************************
* FUNCTION
*  decuma_mfree
* DESCRIPTION
*  free memory for inline editor ADM
* PARAMETERS
*  ptr      [IN]          address of free-space
* RETURNS
*  void
*****************************************************************************/
static void wgui_inline_mfree(void *ptr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_DBG_ASSERT(ptr != NULL);
    MMI_DBG_ASSERT(inline_adm_id);
    kal_adm_free(inline_adm_id, ptr);
}

/*****************************************************************************
* FUNCTION
*  wgui_inline_items_free_mem
* DESCRIPTION
*  free inline items' ADM memory 
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void wgui_inline_items_free_mem(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (i=0; i< wgui_inline_mem_alloc_number; i++)
    {
        wgui_inline_mfree(wgui_inline_mem_alloc_info[i]);
    }
}


/*****************************************************************************
* FUNCTION
*  wgui_inline_free_mem
* DESCRIPTION
*  free inline editor's memory
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void wgui_inline_free_mem(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    kal_int16 ret;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_DBG_ASSERT(inline_adm_id);
    
    wgui_inline_items_free_mem();
   // wgui_inline_mfree(wgui_inline_text_edit_buffer);
    wgui_inline_mfree(wgui_inline_full_screen_text_edit_buffer);
    wgui_inline_mfree(wgui_inline_select_items);
    
    ret = kal_adm_delete(inline_adm_id);

    MMI_DBG_ASSERT(ret == KAL_SUCCESS);

    inline_adm_id = NULL;

#if defined(__MMI_PHB_PHOTO_STICKER_SUPPORT__)
    if (wgui_inline_caption_thumbnail_buffer)
    {
        mmi_frm_scrmem_free((void*)wgui_inline_caption_thumbnail_buffer);
    }
#endif /* __MMI_PHB_PHOTO_STICKER_SUPPORT__ */

    if (g_wgui_inine_items_buffer)
    {
        mmi_frm_scrmem_free((void*)g_wgui_inine_items_buffer);
    }
    UI_UNUSED_PARAMETER(ret);
    
}


/*****************************************************************************
 * FUNCTION
 *  mmi_input_box_msg_call_back_inline_to_other
 * DESCRIPTION
 *  translate event to other msg call back function
 * PARAMETERS     
 *
 * RETURNS
 *  U32
 *****************************************************************************/
static U32 mmi_input_box_msg_call_back_inline_to_other(void * input_box_handle, mmi_imc_message_struct_p msg_ptr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 lresult = 0;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/	
    switch (((mmi_editor_handler_struct *)input_box_handle)->input_box_sub_type)
    {
        case MMI_EDITOR_NORMAL_INPUT_BOX:
            lresult = mmi_input_box_msg_call_back_inline_text((single_line_input_box *)((mmi_editor_handler_struct *)input_box_handle)->input_box_handler, msg_ptr);
            break;
        
        case MMI_EDITOR_DATE:
        #if defined (__MMI_INLINE_ITEM_DATE__)
            lresult = mmi_input_box_msg_call_back_inline_date((date_input  *)((mmi_editor_handler_struct *)input_box_handle)->input_box_handler, msg_ptr);
        #endif /* __MMI_INLINE_ITEM_DATE__ */
            break;
        
        case MMI_EDITOR_IP4:
        #if defined (__MMI_INLINE_ITEM_IP4__)
            lresult = mmi_input_box_msg_call_back_inline_ip4((IP4_input*)((mmi_editor_handler_struct *)input_box_handle)->input_box_handler, msg_ptr);
        #endif /* __MMI_INLINE_ITEM_IP4__ */
            break;
        
        case MMI_EDITOR_TIME:
        #if defined (__MMI_INLINE_ITEM_TIME__)
            lresult = mmi_input_box_msg_call_back_inline_time((time_input *)((mmi_editor_handler_struct *)input_box_handle)->input_box_handler, msg_ptr);
        #endif /* __MMI_INLINE_ITEM_TIME__ */
            break;
		
    #if defined (__MMI_INLINE_ITEM_TIME_PEROID__)                  
        case MMI_EDITOR_TIME_PERIOD:
            lresult = mmi_input_box_msg_call_back_inline_time_period((time_period_input *)((mmi_editor_handler_struct *)input_box_handle)->input_box_handler, msg_ptr);
            break;
    #endif
        
    #if defined(__MMI_INSCREEN_MULTILINE_TEXTBOX__)
    #if defined( __MMI_INLINE_ITEM_MULTILINE_READ_ONLY__) || defined( __MMI_INLINE_ITEM_MULTILINE_EDIT__)
        case MMI_EDITOR_INLINE_MULTILINE_INPUT_BOX:
            lresult = mmi_input_box_msg_call_back_inline_multiline(input_box_handle, msg_ptr);
            break;
    #endif
    #endif
        
        default: 
            break;
    }
    return lresult;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_input_box_msg_call_back_inline_redraw
 * DESCRIPTION
 *  redraw event call back function
 * PARAMETERS     
 *
 * RETURNS
 *  U32
 *****************************************************************************/
static U32 mmi_input_box_msg_call_back_inline_redraw(void * input_box_handle, mmi_imc_message_struct_p msg_ptr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/	
    if (g_inline_redraw_entered ) 
    {
        wgui_inline_item_handled = 1;
        return 0;
    }	 
    else 
    {
        g_inline_redraw_entered = MMI_TRUE;
    }
    
    
#if((UI_ENABLE_FRAME_SKIPPING) && (ENABLE_LIST_MENU_FRAME_SKIPPING))
    wgui_fixed_list_register_skipping_handler(mmi_input_box_keep_current_item_info, mmi_input_box_resume_current_item_info);
#else
    mmi_input_box_keep_current_item_info();
#endif
    mmi_imc_config_update_input_mode_by_cursor_pos(MMI_FALSE);
    
    gui_inputs_set_cursor_change_event_state(MMI_FALSE);
    
    if (msg_ptr->param_0 == 1)
    {
        /*
        * when multiline is redraw, we not hope to redraw multiline.
        */
        if (((mmi_editor_handler_struct *)input_box_handle)->input_box_sub_type == MMI_EDITOR_INLINE_MULTILINE_INPUT_BOX)
        {
            redraw_current_inline_item = UI_dummy_function;
        }
        dm_imui_window_hide();
        if (((mmi_editor_handler_struct *)input_box_handle)->input_box_sub_type == MMI_EDITOR_INLINE_MULTILINE_INPUT_BOX)
        {
            redraw_current_inline_item = wgui_show_inputbox;
        }
    }
    else if (!wgui_inline_item_handled)
    {
        gui_push_clip();
        gui_set_clip_preset(MMI_fixed_list_menu.x, MMI_fixed_list_menu.y, MMI_fixed_list_menu.x + MMI_fixed_list_menu.width - 1, MMI_fixed_list_menu.y + MMI_fixed_list_menu.height - 1);
        redraw_fixed_list();
        gui_pop_clip();
    }
    
    gui_inputs_set_cursor_change_event_state(MMI_TRUE);
    
    mmi_imc_config_update_input_mode_by_cursor_pos(MMI_TRUE);
    g_inline_redraw_entered = MMI_FALSE;
#if(!(UI_ENABLE_FRAME_SKIPPING) || !(ENABLE_LIST_MENU_FRAME_SKIPPING))
    mmi_input_box_resume_current_item_info();
#endif
    return 1;
}



/*****************************************************************************
 * FUNCTION
 *  mmi_input_box_msg_call_back
 * DESCRIPTION
 *
 * PARAMETERS     
 *
 * RETURNS
 *  U32
 *****************************************************************************/
static U32 mmi_input_box_msg_call_back_inline(void * input_box_handle, mmi_imc_message_struct_p msg_ptr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 lresult = 0;
    static U8 pen_down = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    g_inline_current_inline_item_type = ((mmi_editor_handler_struct *)input_box_handle)->input_box_sub_type;

    g_inline_current_input_box_handler = ((mmi_editor_handler_struct *)input_box_handle)->input_box_handler;

    g_inline_current_editor_handle = input_box_handle;

    switch (msg_ptr->message_id)
    {    
    case MMI_IMC_MESSAGE_GET_INPUT_BOX_RECT:
		{
			((mmi_imc_rect_p)msg_ptr->param_0)->x = MMI_fixed_list_menu.x;
			((mmi_imc_rect_p)msg_ptr->param_0)->y = MMI_fixed_list_menu.y;
        #if defined(__MMI_INSCREEN_MULTILINE_TEXTBOX__)
        #if defined( __MMI_INLINE_ITEM_MULTILINE_READ_ONLY__) || defined( __MMI_INLINE_ITEM_MULTILINE_EDIT__)
		    if (g_inline_current_inline_item_type == MMI_EDITOR_INLINE_MULTILINE_INPUT_BOX)
		    {
		        ((mmi_imc_rect_p)msg_ptr->param_0)->width = MMI_multiline_inputbox.width;
		    }
			else
        #endif /* __MMI_INLINE_ITEM_MULTILINE_READ_ONLY__ || __MMI_INLINE_ITEM_MULTILINE_EDIT__ */
        #endif /* __MMI_INSCREEN_MULTILINE_TEXTBOX__ */
			{
			    ((mmi_imc_rect_p)msg_ptr->param_0)->width = MMI_fixed_list_menu.width;
			}
			((mmi_imc_rect_p)msg_ptr->param_0)->height = MMI_fixed_list_menu.height;
		}
        break;
       
    case MMI_IMC_MESSAGE_RESIZE:
        
        if ((S32)msg_ptr->param_0 == MMI_fixed_list_menu.width &&
            (S32)msg_ptr->param_1 == MMI_fixed_list_menu.height)
        {
            break;
        }
        
        resize_fixed_list((S32)MMI_fixed_list_menu.width, (S32)msg_ptr->param_1);
        wgui_inline_edit_resize_multiline_height();
        wgui_inline_item_handled = 0;
		
        switch (current_wgui_inline_item->flags & INLINE_ITEM_TYPE_MASK)
        {            
        case INLINE_ITEM_TYPE_TIME:
#if defined (__MMI_INLINE_ITEM_TIME__)
            current_wgui_inline_time_item->string_construct_callback(
                *current_wgui_inline_time_text_p,
                current_wgui_inline_time_item->hours_buffer,
                current_wgui_inline_time_item->minutes_buffer,
                current_wgui_inline_time_item->AM_PM_flag);
#endif /* __MMI_INLINE_ITEM_TIME__ */
            break;
        
        case INLINE_ITEM_TYPE_DATE:
#if defined (__MMI_INLINE_ITEM_DATE__)
            current_wgui_inline_date_item->string_construct_callback(
                *current_wgui_inline_date_text_p,
                current_wgui_inline_date_item->day_buffer,
                current_wgui_inline_date_item->month_buffer,
                current_wgui_inline_date_item->year_buffer);
#endif /* __MMI_INLINE_ITEM_DATE__ */
            break;
#if defined (__MMI_INLINE_ITEM_TIME_PEROID__)               
        case INLINE_ITEM_TYPE_TIME_PERIOD:
            
            current_wgui_inline_time_period_item->string_construct_callback(
                *current_wgui_inline_time_period_text_p,
                current_wgui_inline_time_period_item->hours_buffer1,
                current_wgui_inline_time_period_item-> minutes_buffer1,
                current_wgui_inline_time_period_item->AM_PM_flag1,
                current_wgui_inline_time_period_item->hours_buffer2,
                current_wgui_inline_time_period_item-> minutes_buffer2,
                current_wgui_inline_time_period_item->AM_PM_flag2);

            break;
#endif
        case INLINE_ITEM_TYPE_IP4_EDIT:
#if defined (__MMI_INLINE_ITEM_IP4__)                    
            current_wgui_inline_IP4_item->string_construct_callback(
                *current_wgui_inline_IP4_text_p,
                current_wgui_inline_IP4_item->b1,
                current_wgui_inline_IP4_item->b2,
                current_wgui_inline_IP4_item->b3,
                current_wgui_inline_IP4_item->b4);
#endif /* __MMI_INLINE_ITEM_IP4__ */
            break;

        default:
            break;
        }

        break;
    
    case MMI_IMC_MESSAGE_UPDATE_SOFTKEY:
        break;
    case MMI_IMC_MESSAGE_KEY_EVENT:
        break;
    case MMI_IMC_MESSAGE_MODE_CHANGED:
        break;
#if defined(__MMI_TOUCH_SCREEN__)

    case MMI_IMC_MESSAGE_GET_HANDWRITING_RECT:

    #if defined(__MMI_INSCREEN_MULTILINE_TEXTBOX__)
    #if defined( __MMI_INLINE_ITEM_MULTILINE_READ_ONLY__) || defined( __MMI_INLINE_ITEM_MULTILINE_EDIT__)
        if (((mmi_editor_handler_struct *)input_box_handle)->input_box_sub_type == MMI_EDITOR_INLINE_MULTILINE_INPUT_BOX)
        {
            return mmi_input_box_msg_call_back_multiline(input_box_handle, msg_ptr);
        }
        else
    #endif
    #endif /* __MMI_INSCREEN_MULTILINE_TEXTBOX__ */ 
        {
            if (mmi_fe_get_r2l_state())
            {
                ((mmi_imc_rect_p)msg_ptr->param_0)->x = MMI_content_x + MMI_fixed_list_menu.vbar.width;
                ((mmi_imc_rect_p)msg_ptr->param_0)->width = MMI_content_width;
            }
            else
            {
                ((mmi_imc_rect_p)msg_ptr->param_0)->x = MMI_content_x;
                ((mmi_imc_rect_p)msg_ptr->param_0)->width = MMI_content_width - MMI_fixed_list_menu.vbar.width;
            }
            ((mmi_imc_rect_p)msg_ptr->param_0)->y = MMI_content_y;
            
            ((mmi_imc_rect_p)msg_ptr->param_0)->height = MMI_fixed_list_menu.y + MMI_fixed_list_menu.height - MMI_content_y;
        }
        break;
        
    case MMI_IMC_MESSAGE_GET_HANDWRITING_STYLE:
#if defined(__MMI_FTE_SUPPORT__) && defined(__MMI_HANDWRITING_MULTI_BLOCK__)
        lresult = MMI_IMC_PEN_HANDWRITING_STYLE_MULTI_BLOCK;
#else
        lresult = MMI_IMC_PEN_HANDWRITING_STYLE_FULL_SCREEN;
#endif
        break;
#endif
  //  case MMI_IMC_MESSAGE_INSERT_NEW_LINE:
 //       break;

    case MMI_IMC_MESSAGE_HIDE_MULTITAP_CANDIDATE_BOX:

        lresult = MMI_TRUE;

        break;
        
    case MMI_IMC_MESSAGE_GET_EDITOR_SCROLL_BAR_WIDTH:
        lresult = (U32)MMI_fixed_list_menu.vbar.width;
        break;
        
    case MMI_IMC_MESSAGE_REDRAW:
        if (!mmi_input_box_msg_call_back_inline_redraw(input_box_handle, msg_ptr))
        {
            return 0;
        }
        break;
        
    case MMI_IMC_MESSAGE_FLOATING_UI_APPEAR_INDICATION:
        dm_imui_window_display();
        break;
		
#if defined(__MMI_TOUCH_SCREEN__)   
#ifdef __MMI_FTE_SUPPORT__
    case MMI_IMC_MESSAGE_PEN_EVENT:
        if (((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->mmi_pen_event == MMI_PEN_EVENT_DOWN) 
        {
            lresult = mmi_input_box_msg_call_back_inline_to_other(input_box_handle, msg_ptr);

            if (lresult)
            {
                pen_down = 1;
                wgui_general_pen_down_hdlr(((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos);
            }

            return lresult;
        }
        else if (((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->mmi_pen_event == MMI_PEN_EVENT_MOVE)
        {
            if (pen_down == 1)
            {
                wgui_general_pen_move_hdlr(((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos);
                if (gui_screen_smooth_scrolling_moved_by_pen())
                {
                    ((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->mmi_pen_event = MMI_PEN_EVENT_ABORT;
                }
            }
        }
        else if (((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->mmi_pen_event == MMI_PEN_EVENT_UP)
        {
            if (pen_down == 1)
            {
                if (gui_screen_smooth_scrolling_moved_by_pen())
                {
                    ((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->mmi_pen_event = MMI_PEN_EVENT_ABORT;
                }
                wgui_general_pen_up_hdlr(((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos);

                pen_down = 0;
            }
        } 
        else if (((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->mmi_pen_event == MMI_PEN_EVENT_ABORT)
        {
            if (pen_down == 1)
            {
                wgui_general_pen_abort_hdlr(((mmi_imc_editor_pen_event_struct_p)msg_ptr->param_0)->pos);

                pen_down = 0;
            }
        }
#endif /* __MMI_FTE_SUPPORT__ */
#endif /**/

        default:
            lresult = mmi_input_box_msg_call_back_inline_to_other(input_box_handle, msg_ptr);
            break;
    }

    return lresult;
        
}


/*****************************************************************************
 * FUNCTION
 *  mmi_input_box_keep_current_item_info
 * DESCRIPTION
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_input_box_keep_current_item_info(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if (!g_inline_current_input_box_handler)
    {
        return;
    }

    switch(g_inline_current_inline_item_type)
    {
        case MMI_EDITOR_NORMAL_INPUT_BOX:

             g_inline_text_current_position = (S16)(((single_line_input_box *)g_inline_current_input_box_handler)->current_text_p
                                                   - ((single_line_input_box *)g_inline_current_input_box_handler)->text);
            
             g_inline_text_text_offset_x = ((single_line_input_box *)g_inline_current_input_box_handler)->text_offset_x;
            
             g_is_inline_text_flags = ((single_line_input_box *)g_inline_current_input_box_handler)->flags;

             g_inline_text_available_length = ((single_line_input_box *)g_inline_current_input_box_handler)->available_length;
             
             g_inline_text_input_mode_cursor_p = ((single_line_input_box *)g_inline_current_input_box_handler)->input_mode_cursor_p;

             g_inline_text_input_start_cursor_p = ((single_line_input_box *)g_inline_current_input_box_handler)->input_start_cursor_p;

             g_inline_text_input_highlight_start_position = ((single_line_input_box *)g_inline_current_input_box_handler)->highlight_start_position;
 
             g_inline_text_input_highlight_end_position = ((single_line_input_box *)g_inline_current_input_box_handler)->highlight_end_position;
 
             g_inline_text_input_last_cursor_offset = ((single_line_input_box *)g_inline_current_input_box_handler)->last_cursor_offset;

             g_is_item_info_kept = MMI_TRUE;
             break;
             
    #if defined(__MMI_INSCREEN_MULTILINE_TEXTBOX__)
    #if defined( __MMI_INLINE_ITEM_MULTILINE_READ_ONLY__) || defined( __MMI_INLINE_ITEM_MULTILINE_EDIT__)
        case MMI_EDITOR_INLINE_MULTILINE_INPUT_BOX:

             memcpy(&g_inline_multiline_backup_struct, (multi_line_input_box *)g_inline_current_input_box_handler, sizeof(multi_line_input_box));

             g_inline_multiline_current_position = (S16)(((multi_line_input_box *)g_inline_current_input_box_handler)->cursor_p
                                                         - ((multi_line_input_box *)g_inline_current_input_box_handler)->text);

             g_inline_multiline_text_offset_x = ((multi_line_input_box *)g_inline_current_input_box_handler)->text_offset_x;

             g_is_inline_multiline_flags = ((multi_line_input_box *)g_inline_current_input_box_handler)->flags;

             g_inline_multiline_available_length = ((multi_line_input_box *)g_inline_current_input_box_handler)->available_length;

             g_is_inline_multiline_highlight_start_position = ((multi_line_input_box *)g_inline_current_input_box_handler)->highlight_start_position;

             g_is_inline_multiline_highlight_end_position = ((multi_line_input_box *)g_inline_current_input_box_handler)->highlight_end_position;
   
             g_inline_multiline_input_mode_cursor_p = ((multi_line_input_box *)g_inline_current_input_box_handler)->input_mode_cursor_p;

             g_inline_multiline_input_start_cursor_p = ((multi_line_input_box *)g_inline_current_input_box_handler)->input_start_cursor_p;

             g_inline_multiline_last_cursor_offset = ((multi_line_input_box *)g_inline_current_input_box_handler)->last_cursor_offset;
             
             g_is_item_info_kept = MMI_TRUE;
            
             break;
    #endif
    #endif
#if defined (__MMI_INLINE_ITEM_TIME__)
        case MMI_EDITOR_TIME:
             g_inline_time_current_focus = (S16) wgui_inline_time_input.current_focus;

             if (wgui_inline_time_input.focus_input_box != NULL)
             {
                g_inline_time_current_position = (S16) (wgui_inline_time_input.focus_input_box->current_text_p -
                                                     wgui_inline_time_input.focus_input_box->text);
             }
            
             g_inline_time_flags = wgui_inline_time_input.input.flags;

             g_is_item_info_kept = MMI_TRUE;

             break;
#endif /* __MMI_INLINE_ITEM_TIME__ */
#if defined (__MMI_INLINE_ITEM_DATE__)
        case MMI_EDITOR_DATE:    
             g_inline_date_current_focus = (S16) wgui_inline_date_input.current_focus;

             if (wgui_inline_date_input.focus_input_box != NULL)
             {
                 g_inline_date_current_position =
                    (S16) (wgui_inline_date_input.focus_input_box->current_text_p -
                    wgui_inline_date_input.focus_input_box->text);
             }

             g_inline_date_flags = wgui_inline_date_input.input.flags;

             g_is_item_info_kept = MMI_TRUE;

             break;
#endif /* __MMI_INLINE_ITEM_DATE__ */
#if defined (__MMI_INLINE_ITEM_TIME_PEROID__)   
        case MMI_EDITOR_TIME_PERIOD:    

            g_inline_time_period_current_focus = (S16) wgui_inline_time_period_input.current_focus;

            if (wgui_inline_time_period_input.focus_input_box != NULL)
            {
                g_inline_time_period_current_position =
                    (S16) (wgui_inline_time_period_input.focus_input_box->current_text_p -
                    wgui_inline_time_period_input.focus_input_box->text);
            }

            g_inline_time_period_flags = wgui_inline_time_period_input.input.flags;

            g_is_item_info_kept = MMI_TRUE;

            break;
#endif
        case MMI_EDITOR_IP4:
#if defined (__MMI_INLINE_ITEM_IP4__)
            g_inline_IP4_current_focus = (S16) wgui_inline_IP4_input.current_focus;

            if (wgui_inline_IP4_input.focus_input_box != NULL)
            {
                g_inline_IP4_current_position =
                    (S16) (wgui_inline_IP4_input.focus_input_box->current_text_p -
                    wgui_inline_IP4_input.focus_input_box->text);
            }

            g_inline_IP4_flags = wgui_inline_IP4_input.input.flags;

            g_is_item_info_kept = MMI_TRUE;
#endif /* __MMI_INLINE_ITEM_IP4__ */
            break;
            
        default:
            break;
    }
        
}

        
/*****************************************************************************
 * FUNCTION
 *  mmi_input_box_resume_current_item_info
 * DESCRIPTION
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_input_box_resume_current_item_info(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_imc_message_struct msg;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if((UI_ENABLE_FRAME_SKIPPING) && (ENABLE_LIST_MENU_FRAME_SKIPPING))
    wgui_fixed_list_register_skipping_handler(NULL, NULL);
#endif

    if (!g_inline_current_input_box_handler)
    {
        return;
    }

    if (g_is_item_info_kept == MMI_FALSE)
    {
        mmi_input_box_keep_current_item_info();
    }

    msg.message_id = MMI_IMC_MESSAGE_REDRAW;

    switch(g_inline_current_inline_item_type)
    {
    case MMI_EDITOR_NORMAL_INPUT_BOX:
        mmi_input_box_msg_call_back_inline_text((single_line_input_box *)g_inline_current_input_box_handler, &msg);
        break;
        
    case MMI_EDITOR_DATE:
#if defined (__MMI_INLINE_ITEM_DATE__)
        mmi_input_box_msg_call_back_inline_date((date_input  *)g_inline_current_input_box_handler, &msg);
#endif /* __MMI_INLINE_ITEM_DATE__ */
		break;
        
    case MMI_EDITOR_IP4:
#if defined (__MMI_INLINE_ITEM_IP4__)
        mmi_input_box_msg_call_back_inline_ip4((IP4_input*)g_inline_current_input_box_handler, &msg);
#endif /* __MMI_INLINE_ITEM_IP4__ */
        break;
        
    case MMI_EDITOR_TIME:
#if defined (__MMI_INLINE_ITEM_TIME__)
        mmi_input_box_msg_call_back_inline_time((time_input *)g_inline_current_input_box_handler, &msg);
#endif /* __MMI_INLINE_ITEM_TIME__ */
		break;
 #if defined (__MMI_INLINE_ITEM_TIME_PEROID__)          
    case MMI_EDITOR_TIME_PERIOD:
        mmi_input_box_msg_call_back_inline_time_period((time_period_input *)g_inline_current_input_box_handler, &msg);
        break;
#endif
        
#if defined(__MMI_INSCREEN_MULTILINE_TEXTBOX__)
#if defined( __MMI_INLINE_ITEM_MULTILINE_READ_ONLY__) || defined( __MMI_INLINE_ITEM_MULTILINE_EDIT__)
    case MMI_EDITOR_INLINE_MULTILINE_INPUT_BOX:
        mmi_input_box_msg_call_back_inline_multiline((void *)g_inline_current_editor_handle, &msg);
        break;
#endif
#endif
    default:
        break;
    }

    g_is_item_info_kept = MMI_FALSE;
}

#ifdef __MMI_UI_LIST_GRID_LINE__
/*****************************************************************************
 * FUNCTION
 *  wgui_inline_editor_generate_separator_table
 * DESCRIPTION
 *  generate separator index table for inline editor
 * PARAMETERS
 *  list_of_items        [IN]    list of inline items
 *  number_of_items        [IN]    number of inline items
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_inline_editor_generate_separator_table(InlineItem *list_of_items, S32 number_of_items)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i = 0;
    BOOL first_item_is_caption = MMI_TRUE;
    BOOL flag = MMI_TRUE, auto_parse = MMI_FALSE;
    S32 first_enabled_item_idx = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(wgui_inline_separator_table, 0, sizeof(wgui_inline_separator_table));

    if (wgui_inline_list_of_icons != NULL)
    {
        for (i = 0; i < number_of_items; i++)
        {
            /* if have icon list, then judge separator by icon */
            if ((i != 0) && (wgui_inline_list_of_icons[i] != NULL))
            {
                wgui_inline_separator_table[i - 1] = MMI_TRUE;
            }
            /* If found Caption has no icon, than judge by Caption. */
            else if (wgui_inline_list_of_icons[i] == NULL
                && (list_of_items[i].flags & 0xff) == INLINE_ITEM_TYPE_CAPTION)
            {
                auto_parse = MMI_TRUE;
                memset(wgui_inline_separator_table, 0, sizeof(wgui_inline_separator_table));
                break;
            }
        }
    }
    else
    {
        auto_parse = MMI_TRUE;
    }
    
    if (auto_parse)
    {
        for (i = 0; i < number_of_items; i++)
        {
            
            if ((list_of_items[i].flags & 0xff) != INLINE_ITEM_DISABLED)
            {
                if (flag)
                {
                    first_enabled_item_idx = i;
                    flag = MMI_FALSE;
                }

                /*  First enabled item is not Caption 
                 *  we need to add separator line until meet first Caption 
                    first_item_is_caption means whether find first Caption.
                 */
                if ((i == first_enabled_item_idx) && ((list_of_items[i].flags & 0xff) != INLINE_ITEM_TYPE_CAPTION))
                {
                    first_item_is_caption = MMI_FALSE;
                }
                /* Meet normal item. Not find first Caption, so draw line. if found first caption, will not execute this branch. */
                if (!first_item_is_caption && ((list_of_items[i].flags & 0xff) != INLINE_ITEM_TYPE_CAPTION))
                {
                     wgui_inline_separator_table[i] = MMI_TRUE;             
                }
                /* Meet First Caption. Will not execute this branch anymore. */
                else if (!first_item_is_caption && ((list_of_items[i].flags & 0xff) == INLINE_ITEM_TYPE_CAPTION))
                {
                    first_item_is_caption = MMI_TRUE;
                }
                /* Meet Caption, so draw line above it. */
                else if ((list_of_items[i].flags & 0xff) == INLINE_ITEM_TYPE_CAPTION)
                {
                    if (i > 0)
                    {
                       wgui_inline_separator_table[i - 1] = MMI_TRUE;             
                    }
                }
            }
        }
    }
#ifndef __MMI_FTE_SUPPORT__
    if((list_of_items[number_of_items - 1].flags & 0xff) != INLINE_ITEM_TYPE_MULTI_LINE_RD_ONLY)
    {
    wgui_inline_separator_table[number_of_items - 1] = MMI_TRUE;
    }
#else
    wgui_inline_separator_table[number_of_items - 1] = MMI_TRUE;
#endif
   
}


/*****************************************************************************
 * FUNCTION
 *  wgui_inline_editor_if_need_draw_separator_line
 * DESCRIPTION
 *  query if needed to draw separator line by item index
 * PARAMETERS
 *  item_index        [IN]    index of inline item
 * RETURNS
 *  MMI_BOOL  MMI_TURE --> need to draw ; MMI_FALSE  --> no need
 *****************************************************************************/
MMI_BOOL wgui_inline_editor_if_need_draw_separator_line(S32 item_index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return (wgui_inline_separator_table[item_index]);
}
#endif  /* __MMI_UI_LIST_GRID_LINE__ */

/***************************************************************************** 
 * Categories  for inline editor
 *
 * These are Category blocks related to Inline editor
 *****************************************************************************/

/***************************************************************************** 
 * Define
 *****************************************************************************/
#define CAT57_APPEND_NONE                    0x00000000
#define CAT57_APPEND_TOP_INFO_BOX            0x00000001
#define CAT57_APPEND_BUTTOM_INFO_BOX         0x00000002 /* no implement */
#define CAT57_APPEND_TOP_MULTILINE_BOX       0x00000003 /* no implement */
#define CAT57_APPEND_BUTTOM_MULTILINE_BOX    0x00000004 /* no implement */


/***************************************************************************** 
 * Local Variable
 *****************************************************************************/
/* parameter from caller */
static U16 cat57_append_type = CAT57_APPEND_NONE;
static void (*cat57_draw_info_callback) (S32 idx, S32 x1, S32 y1, S32 x2, S32 y2) = NULL;
static void (*cat57_hide_info_callback) (S32 idx) = NULL;
static BOOL cat57_is_draw_once; /* will one callback once */
static U16 cat57_info_row_count;

/* inner parameters */
static S32 cat57_pos_x1;
static S32 cat57_pos_y1;
static S32 cat57_pos_x2;
static S32 cat57_pos_y2;

static UI_font_type cat57_f1;
static UI_font_type cat57_f2;

static S32 cat657_tab_num = 0;
/***************************************************************************** 
 * Extern Global Function
 *****************************************************************************/
extern void UI_dummy_menuitem_displayed_function(S32 index, S32 x1, S32 y1, S32 x2, S32 y2);

/***************************************************************************** 
 * Function Implementation
 *****************************************************************************/


/*****************************************************************************
 * FUNCTION
 *  wgui_inline_menu_disable_looping
 * DESCRIPTION
 *  disable inline editor menu looping
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_inline_menu_disable_looping(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_inline_menu_disable_loop = MMI_TRUE;
}

/*****************************************************************************
 * FUNCTION
 *  wgui_inline_menu_disable_looping
 * DESCRIPTION
 *  disable inline editor menu looping
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_inline_menu_enable_looping(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_inline_menu_disable_loop = MMI_FALSE;
}

/*****************************************************************************
 * FUNCTION
 *  InitializeCategory57Screen
 * DESCRIPTION
 *  Initialize inline edit related context data
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void InitializeCategory57Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    n_inline_text_edit_items = 0;
#if defined (__MMI_INLINE_ITEM_RADIO__)
	n_inline_radio_items = 0;
#endif
#if defined (__MMI_INLINE_ITEM_CHECKBOX__)
	n_inline_checkbox_items = 0;
#endif
    n_inline_select_items = 0;
#if defined (__MMI_INLINE_ITEM_DATE__)
    n_inline_date_items = 0;
#endif /* __MMI_INLINE_ITEM_DATE__ */
#if defined (__MMI_INLINE_ITEM_TIME__)
    n_inline_time_items = 0;
#endif /* __MMI_INLINE_ITEM_TIME__ */
    n_inline_user_defined_select_items = 0;
#if defined (__MMI_INLINE_ITEM_IP4__)
    n_inline_IP4_items = 0;
#endif /* __MMI_INLINE_ITEM_IP4__ */
#if defined (__MMI_INLINE_ITEM_DOW__)
    n_inline_DOW_items = 0;
#endif
#if defined (__MMI_INLINE_ITEM_TIME_PEROID__)   
    n_inline_time_period_items = 0;
#endif
    wgui_n_inline_items = 0;
#if defined (__MMI_INLINE_ITEM_IMAGETEXT__)         
    n_inline_image_text = 0;
#endif

#if defined (__MMI_INLINE_ITEM_COLOR_SELECT__)
    n_inline_color_select_items = 0;
#endif
    wgui_inline_item_highlighted_index = -1;
    wgui_inline_edit_DONE_function = NULL;
    wgui_inline_edit_BACK_function = NULL;
    wgui_inline_list_menu_changed = 0;
    current_wgui_inline_item = NULL;
    wgui_inline_edit_arrow_key_flag = CATEGORY57_NO_KEY_FLAG;
    /* Added to enable the scoll bar in sent or insent items */
    flag_scroll = FALSE;
    /* end */ 

    /* added to clean up wgui_inline_items */
    memset(wgui_inline_items, 0, sizeof(wgui_inline_item) * MAX_INLINE_ITEMS);
    /* end */

    /* for sending inline items' change notify to application */
    inline_item_changed_handler = NULL;
    /* end */

            
    wgui_inline_mem_alloc_number = 0; 

    wgui_inline_alloc_mem();
    

}


/*****************************************************************************
 * FUNCTION
 *  SetCategory57RightSoftkeyFunctions
 * DESCRIPTION
 *  set Category57 Right Softkey functions
 * PARAMETERS
 *  done_function       [IN]    done function    
 *  back_function       [IN]    back function    
 * RETURNS
 *  void
 *****************************************************************************/
void SetCategory57RightSoftkeyFunctions(void (*done_function) (void), void (*back_function) (void))
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_inline_edit_DONE_function = done_function;
    wgui_inline_edit_BACK_function = back_function;
    inline_text_edit_set_RSK_function();
}


/*****************************************************************************
 * FUNCTION
 *  SetCategory57LeftSoftkeyFunction
 * DESCRIPTION
 *  set Category57 LSK function
 * PARAMETERS
 *  LSK_function        [IN]   LSK function     
 * RETURNS
 *  void
 *****************************************************************************/
void SetCategory57LeftSoftkeyFunction(void (*LSK_function) (void))
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    register_left_softkey_handler();
    set_left_softkey_function(execute_wgui_inline_edit_LSK_function, KEY_EVENT_UP);
    mmi_imc_key_setup_lsk_function(execute_wgui_inline_edit_LSK_function);
    wgui_inline_edit_LSK_function = LSK_function;
}


/*****************************************************************************
 * FUNCTION
 *  DisableCategory57ScreenDone
 * DESCRIPTION
 *  Diable Done for Cateogry57Screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void DisableCategory57ScreenDone(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_inline_list_menu_disable_done = 1;
}


/*****************************************************************************
 * FUNCTION
 *  EnableCategory57ScreenDone
 * DESCRIPTION
 *  Enable Done for Cateogry57Screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EnableCategory57ScreenDone(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_inline_list_menu_disable_done = 0;
}


/*****************************************************************************
 * FUNCTION
 *  DisableCategory57ScreenRskBack
 * DESCRIPTION
 *  Diable FTE Back for Cateogry57Screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void DisableCategory57ScreenRskBack(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_inline_list_menu_rsk_back = 0;
}


/*****************************************************************************
 * FUNCTION
 *  EnableCategory57ScreenRskBack
 * DESCRIPTION
 *  Enable FTE Back for Cateogry57Screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EnableCategory57ScreenRskBack(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_inline_list_menu_rsk_back = 1;
}


/* Max: set RSK to "Clear" */

/*****************************************************************************
 * FUNCTION
 *  SetCategory57ScreenRSKClear
 * DESCRIPTION
 *  Set Category57 Screen RSK Clear
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void SetCategory57ScreenRSKClear(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_inline_list_menu_disable_done = 2; /* clear */
}


/*****************************************************************************
 * FUNCTION
 *  cat257_virtual_keypad_callback
 * DESCRIPTION
 *  virtual keypad callback for cat257
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void cat257_virtual_keypad_callback(void)
{
#if defined(__MMI_TOUCH_SCREEN__)
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_imc_redraw_screen_by_state();
#endif /* defined(__MMI_TOUCH_SCREEN__) */ 
}


/*****************************************************************************
 * FUNCTION
 *  ShowCategory257Screen
 * DESCRIPTION
 *  ShowCategory257Screen
 * PARAMETERS
 *  title                   [IN]        Title for the screen
 *  title_icon              [IN]        Icon shown with the title
 *  left_softkey            [IN]        Left softkey label
 *  left_softkey_icon       [IN]        Icon for the left softkey
 *  right_softkey           [IN]        Right softkey label
 *  right_softkey_icon      [IN]        Icon for the right softkey
 *  ImgId                   [IN]        Image ID
 *  number_of_items         [IN]        Number of items
 *  list_of_icons           [IN]        List of icons
 *  list_of_items           [IN]        See InlineItem structure.
 *  highlighted_item        [IN]        Default item to be highlighted (if there is no history)
 *  history_buffer          [IN]        History buffer       
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory257Screen(
        U16 title,
        U16 title_icon,
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        U16 ImgId,
        S32 number_of_items,
        U16 *list_of_icons,
        InlineItem *list_of_items,
        S32 highlighted_item,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;
    dm_coordinates gui_list_get_coordinates;
#ifndef __MMI_FTE_SUPPORT__    
#ifdef __MMI_WALLPAPER_ON_BOTTOM__
    color c = {0, 0, 255, 100}; /* transparent color  */
#else 
    color c = {255, 255, 255, 100};
#endif
#endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();
    gui_setup_common_layout();
    
    dm_get_control_coordinates_from_category(
                -1,
                MMI_CATEGORY257_ID,
                DM_INLINE_FIXED_LIST1,
                -1,
                &gui_list_get_coordinates);
            
    resize_fixed_list(gui_list_get_coordinates.s16Width, gui_list_get_coordinates.s16Height);
#if defined(__MMI_TOUCH_SCREEN__)
    mmi_imc_set_inline_editor_full_height(MMI_fixed_list_menu.height);
#endif

    ShowCommonCategoryInlineEdit(
        (UI_string_type) get_string(title),
        title_icon,
        left_softkey,
        left_softkey_icon,
        right_softkey,
        right_softkey_icon,
        number_of_items,
        list_of_icons,
        list_of_items,
        highlighted_item,
        history_buffer,
        wgui_inline_edit_default_list_highlight_handler,
        wgui_inline_edit_default_list_unhighlight_handler,
        MMI_CATEGORY57_ID);

    /* scrollbar is disable*/
    resize_fixed_icontext_menuitems(
        MMI_fixed_list_menu.width - GUI_MENUITEM_X1_GAP - GUI_MENUITEM_X2_GAP,
        get_menu_item_height());
    
    gdi_layer_unlock_frame_buffer();

    if (list_of_icons == NULL)
    {
        set_fixed_icontext_positions(4, 0, 1, 0);
    }
    else
    {
        set_fixed_icontext_positions(MMI_INLINE_EDIT_MENUITEM_HEIGHT + 2, 0, 1, 0);
    }
#ifndef __MMI_FTE_SUPPORT__
    MMI_fixed_list_menu.flags |= UI_LIST_MENU_DISABLE_SCROLLBAR | UI_LIST_MENU_DISABLE_BACKGROUND;
#else
    MMI_fixed_list_menu.flags |= UI_LIST_MENU_DISABLE_SCROLLBAR;
#endif


    SetCategory57ScreenRSKClear();
    SetCategory57RightSoftkeyFunctions(NULL, mmi_frm_scrn_close_active_id);
    ExitCategoryFunction = ExitCategory57Screen;
    GetCategoryHistory = GetCategory57History;
    GetCategoryHistorySize = GetCategory57HistorySize;
    RedrawCategoryFunction = dm_redraw_category_screen;
#ifndef __MMI_FTE_SUPPORT__
    dm_add_image(get_image(ImgId), NULL, NULL);
    dm_add_rectangle(c, DM_RECTANGLE_FILL_COLOR);
#endif
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32CatId = MMI_CATEGORY257_ID;
    dm_data.s32flags = DM_SHOW_VKPAD;

#if !defined(GUI_EDITOR_SHOW_TITLE)
    if (full_screen_edit_open)
    {
        dm_data.s32flags |= DM_NO_TITLE;
    }
#endif /* !defined(GUI_EDITOR_SHOW_TITLE) */

    dm_setup_data(&dm_data);
    dm_register_vkpad_callback(cat57_virtual_keypad_callback);
    dm_redraw_category_screen();
}

/*****************************************************************************
*
* Category 57
*
*****************************************************************************/

#ifdef __MMI_INLINE_TOP_INFO_BOX__
/*****************************************************************************
 * FUNCTION
 *  Cat57DrawTopInfoBox
 * DESCRIPTION
 *  draw top info box of Category57Screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void Cat57DrawTopInfoBox(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_push_clip();
    gui_set_clip(cat57_pos_x1, cat57_pos_y1, cat57_pos_x2, cat57_pos_y2);

    gdi_draw_solid_rect(cat57_pos_x1, cat57_pos_y1, cat57_pos_x2, cat57_pos_y2, GDI_COLOR_WHITE);

    gui_pop_clip();
}
#endif

/*****************************************************************************
 * FUNCTION
 *  RedrawCategory57Screen
 * DESCRIPTION
 *  Category57 redraw function
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void RedrawCategory57Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    dm_redraw_category_screen();
}


/*****************************************************************************
 * FUNCTION
 *  dm_category57_controlled_area
 * DESCRIPTION
 *  Category 57 controlled area callback called by draw manager
 * PARAMETERS
 *  coordinate      [IN/OUT]        It specifies the area in which the category will start the drawing. Also modifies it.
 * RETURNS
 *  void
 *****************************************************************************/
void dm_category57_controlled_area(dm_coordinates *coordinate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (cat57_append_type == CAT57_APPEND_TOP_INFO_BOX)
    {
        coordinate->s16Y = MMI_title_y + MMI_title_height;
        coordinate->s16Height = MMI_menuitem_height * cat57_info_row_count;
#ifdef __MMI_INLINE_TOP_INFO_BOX__
		/* draw top info box */
        Cat57DrawTopInfoBox();
#endif
        if (cat57_draw_info_callback != NULL)
        {
            cat57_draw_info_callback(
                MMI_fixed_list_menu.highlighted_item,
                cat57_pos_x1,
                cat57_pos_y1,
                cat57_pos_x2,
                cat57_pos_y2);
        }
    }
    else
    {
        coordinate->s16Width = 0;
        coordinate->s16Height = 0;
    }
}


/*****************************************************************************
 * FUNCTION
 *  Cat57HighlightHandler
 * DESCRIPTION
 *  Highlight handler of Category57
 * PARAMETERS
 *  item_index      [IN]    item index    
 * RETURNS
 *  void
 *****************************************************************************/
static void Cat57HighlightHandler(S32 item_index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();
    wgui_inline_edit_default_list_highlight_handler(item_index);

    if (cat57_append_type == CAT57_APPEND_TOP_INFO_BOX)
    {
        if (!(wgui_inline_items[item_index].flags & INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT))
        {
            if (cat57_draw_info_callback != NULL && cat57_is_draw_once == FALSE)
            {
#ifdef __MMI_INLINE_TOP_INFO_BOX__
                Cat57DrawTopInfoBox();
#endif
                cat57_draw_info_callback(item_index, cat57_pos_x1, cat57_pos_y1, cat57_pos_x2, cat57_pos_y2);
            }
        }
    }

    gdi_layer_unlock_frame_buffer();
    gdi_layer_blt_previous(0, 0, UI_device_width - 1, UI_device_height - 1);
}


/*****************************************************************************
 * FUNCTION
 *  Cat57UnHighlightHandler
 * DESCRIPTION
 *  unhighlight handler of Category57
 * PARAMETERS
 *  item_index      [IN]    item index    
 * RETURNS
 *  void
 *****************************************************************************/
static void Cat57UnHighlightHandler(S32 item_index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_inline_edit_default_list_unhighlight_handler(item_index);

    if (cat57_hide_info_callback != NULL && cat57_is_draw_once == FALSE)
    {
        cat57_hide_info_callback(item_index);
    }

}


/*****************************************************************************
 * FUNCTION
 *  cat57_virtual_keypad_callback
 * DESCRIPTION
 *  virtual keypad callback for cat57
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void cat57_virtual_keypad_callback(void)
{
#if defined(__MMI_TOUCH_SCREEN__)
    mmi_imc_redraw_screen_by_state();
#endif /* defined(__MMI_TOUCH_SCREEN__) */ 
}


#if defined (__MMI_WALLPAPER_ON_BOTTOM__)
/*****************************************************************************
 * FUNCTION
 *  ShowCategory357Screen
 * DESCRIPTION
 *  ShowCategory357Screen
 * PARAMETERS
 *  title                   [IN]        Title for the screen
 *  title_icon              [IN]        Icon shown with the title
 *  left_softkey            [IN]        Left softkey label
 *  left_softkey_icon       [IN]        Icon for the left softkey
 *  right_softkey           [IN]        Right softkey label
 *  right_softkey_icon      [IN]        Icon for the right softkey
 *  ImgId                   [IN]        Image shown on top of list
 *  number_of_items         [IN]        Number of items
 *  list_of_icons           [IN]        List of icons
 *  list_of_items           [IN]        See InlineItem structure.
 *  highlighted_item        [IN]        Default item to be highlighted (if there is no history)
 *  history_buffer          [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory357Screen(
        U16 title,
        U16 title_icon,
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        U16 ImgId,
        S32 number_of_items,
        U16 *list_of_icons,
        InlineItem *list_of_items,
        S32 highlighted_item,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();
    gui_setup_common_layout();
    
    ShowCommonCategoryInlineEdit(
        (UI_string_type) get_string(title),
        title_icon,
        left_softkey,
        left_softkey_icon,
        right_softkey,
        right_softkey_icon,
        number_of_items,
        list_of_icons,
        list_of_items,
        highlighted_item,
        history_buffer,
        Cat57HighlightHandler,
        Cat57UnHighlightHandler,
        MMI_CATEGORY57_ID);

    if (flag_scroll)
    {
        MMI_fixed_list_menu.flags |= UI_LIST_MENU_DISABLE_SCROLLBAR;
    }

    dm_add_image(get_image(ImgId), NULL, NULL);
    handle_inline_full_screen_edit_opacity_set((U8)(current_MMI_theme->bg_opacity_low)); 

    gdi_layer_unlock_frame_buffer();

    ExitCategoryFunction = ExitCategory57Screen;
    RedrawCategoryFunction = dm_redraw_category_screen;
    GetCategoryHistory = GetCategory57History;
    GetCategoryHistorySize = GetCategory57HistorySize;
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32CatId = MMI_CATEGORY357_ID;
    dm_data.s32flags = 0;
    dm_data.s32flags |= DM_SHOW_VKPAD;
#if !defined(GUI_EDITOR_SHOW_TITLE)
    if (full_screen_edit_open)
    {
        dm_data.s32flags |= DM_NO_TITLE;
    }
#endif /* !defined(GUI_EDITOR_SHOW_TITLE) */
    dm_setup_data(&dm_data);
    dm_register_category_controlled_callback(dm_category57_controlled_area);
    dm_register_vkpad_callback(cat57_virtual_keypad_callback);
    dm_redraw_category_screen();
}
#endif /* defined (__MMI_WALLPAPER_ON_BOTTOM__) */ 


/*****************************************************************************
 * FUNCTION
 *  ShowCategory657Screen
 * DESCRIPTION
 *  ShowCategory657Screen
 * PARAMETERS
 *  title                   [IN]        Title for the screen
 *  title_icon              [IN]        Icon shown with the title
 *  left_softkey            [IN]        Left softkey label
 *  left_softkey_icon       [IN]        Icon for the left softkey
 *  right_softkey           [IN]        Right softkey label
 *  right_softkey_icon      [IN]        Icon for the right softkey
 *  number_of_items         [IN]        Number of items
 *  list_of_icons           [IN]        List of icons
 *  list_of_items           [IN]        See InlineItem structure.
 *  highlighted_item        [IN]        Default item to be highlighted (if there is no history)
 *  n_tabs                  [IN]        number of tabs
 *  highlighted_tab         [IN]        highlighted tab
 *  tab_items               [IN]        tab items
 *  history_buffer          [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory657Screen(
        U16 title,
        U16 title_icon,
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        S32 number_of_items,
        U16 *list_of_icons,
        InlineItem *list_of_items,
        S32 highlighted_item,
        S8 highlighted_tab,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;
    S8 n_tabs;
    dm_coordinates gui_list_get_coordinates;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_setup_common_layout();
    
    gdi_layer_lock_frame_buffer();

    /* Show Tab bars */
    mmi_frm_get_tab_bar_items(MMI_tab_bar_items, &n_tabs);
    cat657_tab_num = n_tabs;
    
    if (n_tabs)
    {
        wgui_create_horizontal_tab_bar(TRUE, (UI_string_type)GetString(title), n_tabs, highlighted_tab, MMI_FALSE);
    }


    dm_get_control_coordinates_from_category(
        -1,
        MMI_CATEGORY657_ID,
        DM_INLINE_FIXED_LIST1,
        -1,
        &gui_list_get_coordinates);

    resize_fixed_list(gui_list_get_coordinates.s16Width, gui_list_get_coordinates.s16Height);
    
#if defined(__MMI_TOUCH_SCREEN__)
    mmi_imc_set_inline_editor_full_height(gui_list_get_coordinates.s16Height);
#endif
    /* Show Inline */

    ShowCommonCategoryInlineEdit(
        (UI_string_type) get_string(title),
        title_icon,
        left_softkey,
        left_softkey_icon,
        right_softkey,
        right_softkey_icon,
        number_of_items,
        list_of_icons,
        list_of_items,
        highlighted_item,
        history_buffer,
        Cat57HighlightHandler,
        Cat57UnHighlightHandler,
        MMI_CATEGORY57_ID);

    if (flag_scroll)
    {
        MMI_fixed_list_menu.flags |= UI_LIST_MENU_DISABLE_SCROLLBAR;
    }

    if (history_buffer == NULL)
    {
#ifdef __MMI_FTE_SUPPORT__
	/* In category657screen, resize fixed list will lead to  list height error, so we set wgui_inline_item_highlighted_index to -1
	to execute highlight item function manipulately. */
	wgui_inline_item_highlighted_index = -1;
#endif
        fixed_list_goto_item_no_redraw(highlighted_item);
    }

    gdi_layer_unlock_frame_buffer();

    ExitCategoryFunction = ExitCategory657Screen;
    RedrawCategoryFunction = dm_redraw_category_screen;
    GetCategoryHistory = GetCategory57History;
    GetCategoryHistorySize = GetCategory57HistorySize;
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32CatId = MMI_CATEGORY657_ID;
    dm_data.s32flags = 0;
    dm_data.s32flags |= DM_SHOW_VKPAD;
    dm_setup_data(&dm_data);
    dm_register_category_controlled_callback(dm_category57_controlled_area);
    dm_register_vkpad_callback(cat57_virtual_keypad_callback);
    dm_redraw_category_screen();
#ifdef __MMI_FTE_SUPPORT__	
    mmi_imc_set_vk_present(MMI_IMC_VK_DEFAULT_ENLARGE);
#endif	

#ifdef __MMI_FTE_SUPPORT__
    wgui_icon_bar_register_pause_interactive_UI_callback(wgui_inline_stop_scroll);
    wgui_icon_bar_register_resume_interactive_UI_callback(wgui_inline_start_scroll);
#endif

}


/*****************************************************************************
 * FUNCTION
 *  ShowCategory57Screen
 * DESCRIPTION
 *  Redraws the category57 screen
 * PARAMETERS
 *  title                   [IN]        Title for the screen
 *  title_icon              [IN]        Icon shown with the title
 *  left_softkey            [IN]        Left softkey label
 *  left_softkey_icon       [IN]        Icon for the left softkey
 *  right_softkey           [IN]        Right softkey label
 *  right_softkey_icon      [IN]        Icon for the right softkey
 *  number_of_items         [IN]        Number of items
 *  list_of_icons           [IN]        List of icons
 *  list_of_items           [IN]        See InlineItem structure.
 *  highlighted_item        [IN]        Default item to be highlighted (if there is no history)
 *  history_buffer          [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory57Screen(
        U16 title,
        U16 title_icon,
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        S32 number_of_items,
        U16 *list_of_icons,
        InlineItem *list_of_items,
        S32 highlighted_item,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ShowCategory57Screen_for_title(
	(PU8) get_string(title),
        title_icon,
        left_softkey,
        left_softkey_icon,
        right_softkey,
        right_softkey_icon,
        number_of_items,
        list_of_icons,
        list_of_items,
        highlighted_item,
	    history_buffer);
        
}

/*****************************************************************************
 * FUNCTION
   ShowCategory57Screen_for_title
 * DESCRIPTION
 *  showcategory57 with a string pointer
 * PARAMETERS
 *  title_string            [IN]        Title for the screen
 *  title_icon              [IN]        Icon shown with the title
 *  left_softkey            [IN]        Left softkey label
 *  left_softkey_icon       [IN]        Icon for the left softkey
 *  right_softkey           [IN]        Right softkey label
 *  right_softkey_icon      [IN]        Icon for the right softkey
 *  number_of_items         [IN]        Number of items
 *  list_of_icons           [IN]        List of icons
 *  list_of_items           [IN]        See InlineItem structure.
 *  highlighted_item        [IN]        Default item to be highlighted (if there is no history)
 *  history_buffer          [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory57Screen_for_title(
        PU8 title_string,
        U16 title_icon,
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        S32 number_of_items,
        U16 *list_of_icons,
        InlineItem *list_of_items,
        S32 highlighted_item,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;
    dm_coordinates gui_list_get_coordinates;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

#ifdef __MMI_SCREEN_ROTATE__
    if (!mmi_frm_is_screen_width_height_swapped())
    {
        gui_setup_common_layout();
    }
#endif
    
    /* init append related parameters */
    if (cat57_append_type == CAT57_APPEND_TOP_INFO_BOX)
    {
        cat57_pos_x1 = 0;
        cat57_pos_y1 = MMI_title_y + MMI_title_height;
        cat57_pos_x2 = UI_device_width - 1;
        cat57_pos_y2 = MMI_title_y + MMI_title_height + MMI_menuitem_height * cat57_info_row_count - 1;

    }

    gdi_layer_lock_frame_buffer();


     dm_get_control_coordinates_from_category(
            -1,
            MMI_CATEGORY57_ID,
            DM_INLINE_FIXED_LIST1,
            -1,
            &gui_list_get_coordinates);
        
        resize_fixed_list(gui_list_get_coordinates.s16Width, gui_list_get_coordinates.s16Height);
        move_fixed_list(gui_list_get_coordinates.s16X, gui_list_get_coordinates.s16Y);

#if defined(__MMI_TOUCH_SCREEN__)
        mmi_imc_set_inline_editor_full_height(MMI_fixed_list_menu.height);
#endif

    ShowCommonCategoryInlineEdit(
        (UI_string_type) title_string,
        title_icon,
        left_softkey,
        left_softkey_icon,
        right_softkey,
        right_softkey_icon,
        number_of_items,
        list_of_icons,
        list_of_items,
        highlighted_item,
        history_buffer,
        Cat57HighlightHandler,
        Cat57UnHighlightHandler,
        MMI_CATEGORY57_ID);

    if (flag_scroll)
    {
        MMI_fixed_list_menu.flags |= UI_LIST_MENU_DISABLE_SCROLLBAR;
    }
    MMI_fixed_list_menu.flags |= UI_LIST_MENU_ALIGN_TO_TOP;

    if (history_buffer == NULL)
    {
        fixed_list_goto_item_no_redraw(highlighted_item);
    }

    gdi_layer_unlock_frame_buffer();

    ExitCategoryFunction = ExitCategory57Screen;
    RedrawCategoryFunction = dm_redraw_category_screen;
    GetCategoryHistory = GetCategory57History;
    GetCategoryHistorySize = GetCategory57HistorySize;
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32CatId = MMI_CATEGORY57_ID;
    dm_data.s32flags = 0;
    dm_data.s32flags |= DM_SHOW_VKPAD;
    dm_data.s32flags |= DM_CLEAR_SCREEN_BACKGROUND;
#if !defined(GUI_EDITOR_SHOW_TITLE)
    if (full_screen_edit_open)
    {
        dm_data.s32flags |= DM_NO_TITLE;
    }
#endif /* !defined(GUI_EDITOR_SHOW_TITLE) */
    dm_setup_data(&dm_data);
    dm_register_category_controlled_callback(dm_category57_controlled_area);
    dm_register_vkpad_callback(cat57_virtual_keypad_callback);
    dm_redraw_category_screen();
#ifdef __MMI_FTE_SUPPORT__	
	mmi_imc_set_vk_present(MMI_IMC_VK_DEFAULT_ENLARGE);
#endif	

#ifdef __MMI_FTE_SUPPORT__
    wgui_icon_bar_register_pause_interactive_UI_callback(wgui_inline_stop_scroll);
    wgui_icon_bar_register_resume_interactive_UI_callback(wgui_inline_start_scroll);
#endif
}


#ifdef __MMI_INLINE_TOP_INFO_BOX__
/*****************************************************************************
 * FUNCTION
 *  Category57AppendTopInfoBox
 * DESCRIPTION
 *  Append top info box to Category screen 57.
 *  [NOTIC!] call this function before calling ShowCategory57Screen
 * PARAMETERS
 *  num_of_info_box_rows        [IN]       number of info box row 
 *  draw_info_callback          [IN]       draw info callback function 
 *  hide_info_callback          [IN]       hide info callback function 
 *  is_draw_once                [IN]       is draw once 
 * RETURNS
 *  void
 *****************************************************************************/
void Category57AppendTopInfoBox(
        U16 num_of_info_box_rows,
        void (*draw_info_callback) (S32 idx, S32 x1, S32 y1, S32 x2, S32 y2),
        void (*hide_info_callback) (S32 idx),
        BOOL is_draw_once)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    cat57_append_type = CAT57_APPEND_TOP_INFO_BOX;

    cat57_draw_info_callback = draw_info_callback;
    cat57_hide_info_callback = hide_info_callback;
    cat57_info_row_count = num_of_info_box_rows;
    cat57_is_draw_once = is_draw_once;
}
#endif

/*****************************************************************************
 * FUNCTION
 *  CloseCategory57Screen
 * DESCRIPTION
 *  close the category57 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void CloseCategory57Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();
#if defined(__MMI_TOUCH_SCREEN__)
    mmi_pen_editor_is_closecategory57 = MMI_TRUE;
#endif 
    complete_inline_item_edit();
#if defined(__MMI_TOUCH_SCREEN__)
    mmi_pen_editor_is_closecategory57 = MMI_FALSE;
#endif 
    gdi_layer_unlock_frame_buffer();
}


/*****************************************************************************
 * FUNCTION
 *  ExitCategory657Screen
 * DESCRIPTION
 *  Exit category657Screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitCategory657Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if (cat657_tab_num)
    {
        wgui_close_horizontal_tab_bar();
        cat657_tab_num = 0;
    }
    ExitCategory57Screen();
}


/*****************************************************************************
 * FUNCTION
 *  ExitCategory57Screen
 * DESCRIPTION
 *  Exit Category57Screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitCategory57Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(__MMI_PHB_PHOTO_STICKER_SUPPORT__)
    wgui_inline_thumbnail_exit();
#endif /* __MMI_PHB_PHOTO_STICKER_SUPPORT__ */

    wgui_inline_free_mem();
    wgui_inline_mem_alloc_number = 0; 
    
#if defined(__MMI_INSCREEN_MULTILINE_TEXTBOX__)
#if defined( __MMI_INLINE_ITEM_MULTILINE_READ_ONLY__) || defined( __MMI_INLINE_ITEM_MULTILINE_EDIT__)
    MMI_multiline_inputbox.flags &= ~UI_MULTI_LINE_INPUT_BOX_INSIDE_INLINE_MENU;
#endif 
#endif 

#if(UI_BLINKING_CURSOR_SUPPORT)
    StopTimer(BLINKING_CURSOR);
#endif

#if((UI_ENABLE_FRAME_SKIPPING) && (ENABLE_INLINE_SINGLELINE_INPUTBOX_FRAME_SKIPPING))
    gui_cancel_timer(wgui_inline_singleline_inputbox_end_frame);
    wgui_inline_singleline_inputbox_frame_counter = 0;
#endif /* ((UI_ENABLE_FRAME_SKIPPING) && (ENABLE_INLINE_SINGLELINE_INPUTBOX_FRAME_SKIPPING)) */ 

#ifdef __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__
    DisableInlineItemDefaultText();
#endif 

    wgui_title_disable_menu_shortcut_display(MMI_FALSE);
    wgui_inline_edit_arrow_key_flag = CATEGORY57_NO_KEY_FLAG;
    gui_set_fixed_list_menu_current_theme(&MMI_fixed_list_menu);
    current_wgui_inline_item = NULL;
    wgui_n_inline_items = 0;
    wgui_inline_item_highlighted_index = -1;
    wgui_inline_list_menu_changed = 0;
    wgui_inline_list_menu_disable_done = 0;
    wgui_inline_list_menu_rsk_back = 0;
    MMI_multi_line_inputbox_present = 0;
    wgui_inputbox_information_flag = 0;
    wgui_inline_edit_DONE_function = NULL;
    wgui_inline_edit_BACK_function = NULL;
    inline_text_edit_APP_Assigned_RSK_label_string = NULL;
    complete_inline_item_edit = UI_dummy_function;
    category_inline_edit_menuitem_flags();
    clear_inline_item_keys();
    wgui_text_menuitem_reset_scrolling();
    if (g_inline_menu_disable_loop)
    {
        g_inline_menu_disable_loop = MMI_FALSE;
        fixed_list_enable_looping();
    }

#if defined (__MMI_INLINE_ITEM_IMAGETEXT__)    
    clear_inline_image_text_item();
#endif
    
#ifdef __MMI_FTE_SUPPORT__
    /* When FTE, Stop scrolling when highlight item is displayonly or fullscreen edit. */
    wgui_inline_display_only_close();
#endif
    
    //Reset The Change Flag
    MMI_multiline_inputbox.editor_changed = 0;
    reset_pop_up_descriptions();
    redraw_current_inline_item = UI_dummy_function;
#ifdef __MMI_TOUCH_SCREEN__
    wgui_current_inline_item_pen_function = UI_dummy_inline_item_pen_function;
#endif 
    ClearHighlightHandler();
    reset_softkeys();
    set_softkey_function(UI_dummy_function, KEY_EVENT_UP, MMI_CENTER_SOFTKEY);
    mmi_imc_key_setup_csk_function(UI_dummy_function);
    mmi_imc_key_setup_lsk_function(UI_dummy_function);
    mmi_imc_key_setup_rsk_function(UI_dummy_function);
    reset_menu_shortcut_handler();
    reset_fixed_list();
    MMI_fixed_list_menu.flags &= ~UI_LIST_MENU_INLINE_EDIT;
    MMI_fixed_list_menu.item_displayed_callback = UI_dummy_menuitem_displayed_function;
    ExitCategoryFunction = MMI_dummy_function;
    RedrawCategoryFunction = MMI_dummy_function;
    GetCategoryHistory = dummy_get_history;
    GetCategoryHistorySize = dummy_get_history_size;
    MMI_fixed_icontext_menuitem.text_font = cat57_f1;
    MMI_fixed_text_menuitem.text_font = cat57_f2;

    /* reset append */
    cat57_append_type = CAT57_APPEND_NONE;
    cat57_draw_info_callback = NULL;
    cat57_hide_info_callback = NULL;
    cat57_info_row_count = 0;

    g_inline_text_gap_with_list = 0;
    g_inline_picon = NULL;

    handle_inline_full_screen_edit_opacity_reset();
    handle_inline_full_screen_edit_delete_title();

#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
    gui_unblock_list_effect();
#endif 


#ifdef __MMI_UI_TRANSPARENT_EFFECT__
    enable_fixed_icontext_menuitem_transparent_effect();
#endif 

    /* for sending inline items' change notify to application */
    inline_item_changed_handler = NULL;
    /* end */

#ifdef __MMI_INLINE_EDITOR_PRESS_ANY_KEY_ENTER_FULL_SCREEN__
    wgui_inline_key_enter_clear_key_handler();
    g_inline_disable_auto_enter = MMI_FALSE;
#endif /* __MMI_INLINE_EDITOR_PRESS_ANY_KEY_ENTER_FULL_SCREEN__ */

#ifndef __MMI_FTE_SUPPORT__
    g_select_unhighlight_x_corrdinate = 0;
#endif

#ifdef __MMI_FTE_SUPPORT__
    mmi_imc_set_vk_present(MMI_IMC_VK_PRESENT_DEFAULT);
#endif

    if(cui_inline_is_current_cui())
    {
       cui_inline_evt_mainscreen_exit();
       cui_inline_reset_instance_point();
    }

#if defined(__MMI_INSCREEN_MULTILINE_TEXTBOX__)
#if defined( __MMI_INLINE_ITEM_MULTILINE_READ_ONLY__) || defined( __MMI_INLINE_ITEM_MULTILINE_EDIT__)
    memset(&g_inline_ml_rdly_highlight_list, 0, sizeof(wgui_inline_ml_rdly_highlight_list_struct));
#endif
#endif

#ifdef __MMI_TOUCH_SCREEN__
    gui_vertical_scrollbar_reset_get_diff(&(MMI_fixed_list_menu.vbar));
#endif

    g_inline_op_parent_id = 0;
}


/*****************************************************************************
 * FUNCTION
 *  GetCategory57HistorySize
 * DESCRIPTION
 *  Gets the size of the history buffer for the category57 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  size of history buffer in U8s
 *****************************************************************************/
S32 GetCategory57HistorySize(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return (wgui_get_inline_history_size());
}


/*****************************************************************************
 * FUNCTION
 *  GetCategory57History
 * DESCRIPTION
 *  Gets the history buffer for the category57 screen
 * PARAMETERS
 *  history_buffer      [IN]        Is the buffer into which the history data is stored (pre-allocated)
 * RETURNS
 *  pointer to the history buffer
 *****************************************************************************/
U8 *GetCategory57History(U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return (wgui_get_inline_history(MMI_CATEGORY57_ID, history_buffer));
}


/*****************************************************************************
 * FUNCTION
 *  Category57ChangeItemIcon
 * DESCRIPTION
 *  change item icon of category57
 * PARAMETERS
 *  index           [IN]     item index   
 *  image_ID        [IN]     image id   
 * RETURNS
 *  void
 *****************************************************************************/
void Category57ChangeItemIcon(S32 index, U16 image_ID)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* FIXME. There is potential problem that some inline items does not have icon. */
    MMI_fixed_icontext_menuitems[index].item_icon = wgui_get_list_menu_icon(index, image_ID);
}


/*****************************************************************************
 * FUNCTION
 *  GetCategory57DataSize
 * DESCRIPTION
 *  Get cat57 data size
 * PARAMETERS
 *  void
 * RETURNS
 *  data size
 *****************************************************************************/
S32 GetCategory57DataSize(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return (wgui_get_inline_data_size());
}


/*****************************************************************************
 * FUNCTION
 *  GetCategory57Data
 * DESCRIPTION
 *  det cat57 data
 * PARAMETERS
 *  data        [OUT]   data   
 * RETURNS
 *  data pointer
 *****************************************************************************/
U8 *GetCategory57Data(U8 *data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return (wgui_get_inline_data(data));
}


/*****************************************************************************
 * FUNCTION
 *  SetCategory57Data
 * DESCRIPTION
 *  set Cat57 data
 * PARAMETERS
 *  list_of_items       [IN]    list of inline item
 *  number_of_items     [IN]    number of item
 *  data                [IN]    data
 * RETURNS
 *  void
 *****************************************************************************/
void SetCategory57Data(InlineItem *list_of_items, S32 number_of_items, U8 *data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_set_inline_data(list_of_items, number_of_items, data);
}


/*****************************************************************************
 * FUNCTION
 *  ShowCommonCategoryInlineEdit
 * DESCRIPTION
 *  show common inline edit category
 * PARAMETERS
  *  title                   [IN]        Title for the screen
 *  title_icon              [IN]        Icon shown with the title
 *  left_softkey            [IN]        Left softkey label
 *  left_softkey_icon       [IN]        Icon for the left softkey
 *  right_softkey           [IN]        Right softkey label
 *  right_softkey_icon      [IN]        Icon for the right softkey
 *  number_of_items         [IN]        Number of items
 *  list_of_icons           [IN]        List of icons
 *  list_of_items           [IN]        See InlineItem structure.
 *  highlighted_item        [IN]        Default item to be highlighted (if there is no history)
 *  history_buffer          [IN]        History buffer        
 *  highlight_handler       [IN]        highlight handler
 *  unhighlight_handler     [IN]        unhighlight handler
 *  history_id              [IN]        history id
 * RETURNS
 *  void
 *****************************************************************************/
static void ShowCommonCategoryInlineEdit(
        UI_string_type title,
        U16 title_icon,
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        S32 number_of_items,
        U16 *list_of_icons,
        InlineItem *list_of_items,
        S32 highlighted_item,
        U8 *history_buffer,
        void (*highlight_handler) (S32 item_index),
        void (*unhighlight_handler) (S32 item_index),
        U16 history_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 h_flag;
    S32 i;
    U16 inline_item_index = 0;

    UI_fixed_icontext_menuitem_theme *saved_themedata1 = current_fixed_icontext_menuitem_theme;
    UI_fixed_list_menu_theme *saved_themedata2 = current_fixed_list_menu_theme;
    list_menu_category_history *h;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    /* Backup font */
    cat57_f1 = MMI_fixed_icontext_menuitem.text_font;
    cat57_f2 = MMI_fixed_text_menuitem.text_font;

#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
    gui_block_list_effect();
#endif 

    wgui_title_set_menu_shortcut_number(-1);
    clear_category_screen_key_handlers();
    change_left_softkey(left_softkey, left_softkey_icon);
    change_right_softkey(right_softkey, right_softkey_icon);
    clear_left_softkey();
    clear_right_softkey();
    register_left_softkey_handler();
    register_right_softkey_handler();
    register_default_hide_softkeys();

    MMI_title_string = title;
    MMI_title_icon = (PU8) get_image(title_icon);

    wgui_inline_fixed_icontext_menuitem_theme.focussed_filler = current_MMI_theme->list_selected_item_filler;
    wgui_inline_fixed_icontext_menuitem_theme.selected_filler = current_MMI_theme->list_selected_item_filler;
    wgui_inline_fixed_icontext_menuitem_theme.focussed_without_sc_filler = current_MMI_theme->list_selected_item_filler;
    wgui_inline_fixed_list_menu_theme.focussed_filler = current_MMI_theme->list_selected_item_filler;
    wgui_inline_fixed_list_menu_theme.normal_filler = current_fixed_list_menu_theme->normal_filler;
    

    current_fixed_icontext_menuitem_theme = &wgui_inline_fixed_icontext_menuitem_theme;
    current_fixed_list_menu_theme = &wgui_inline_fixed_list_menu_theme;

    gui_set_fixed_list_menu_current_theme(&MMI_fixed_list_menu);

    create_fixed_icontext_menuitems();
#if !defined(__MMI_FTE_SUPPORT__)
    MMI_fixed_list_menu.flags |= UI_LIST_MENU_AUTO_DISABLE_SCROLLBAR;
#endif
    associate_fixed_icontext_list();

    MMI_fixed_list_menu.flags |= UI_LIST_MENU_INLINE_EDIT;

    if (g_inline_menu_disable_loop)
    {
        fixed_list_disable_looping();
    }

#ifdef __MMI_TOUCH_SCREEN__
    /* Avoid menu position shifted when it is resized for differet virtual keyboard layout */
    MMI_fixed_list_menu.flags |= UI_LIST_MENU_ALIGN_TO_TOP;
#endif /* __MMI_TOUCH_SCREEN__ */ 

#ifdef __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__
    temp_inline_edit_normal_filler.border_color = current_fixed_icontext_menuitem_theme->focussed_filler->c;
    MMI_fixed_icontext_menuitem.selected_filler = &temp_inline_edit_normal_filler;
    
#ifndef __GDI_MEMORY_PROFILE_2__
    MMI_fixed_icontext_menuitem.selected_filler = current_MMI_theme->inline_list_normal_item_filler;
#endif

#endif /* __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__ */ 

#ifdef __MMI_UI_TRANSPARENT_EFFECT__
    disable_fixed_icontext_menuitem_transparent_effect();
#endif 

#ifdef __MMI_FTE_SUPPORT__
    for (i = 0; (i < number_of_items) && (i < MAX_INLINE_ITEMS); i++)
    {
        ShowAsControl(&(wgui_inline_items[i]));
        
        MMI_fixed_icontext_menuitems[i].flags |= UI_MENUITEM_INLINE_EDIT_OBJECT | UI_MENUITEM_DISABLE_TEXT_DISPLAY;
        
        list_of_items[i].flags |= INLINE_ITEM_DISABLE_HIGHLIGHT;
        list_of_items[i].flags &= ~INLINE_ITEM_JUSTIFY_MASK;
        list_of_items[i].flags |= INLINE_ITEM_LEFT_JUSTIFY;
    }

    for (i = 0; (i < number_of_items) && (i < MAX_INLINE_ITEMS); i++)
    {
        if(list_of_icons == NULL)
        {
            break;
        }

        if((list_of_icons[i] == NULL) || (get_image(list_of_icons[i]) == NULL))
        {
            list_of_icons = NULL;
            break;
        }
    }
#endif
      //there are no icons in Inline item
   list_of_icons = NULL; 

   wgui_inline_list_of_icons = list_of_icons;

#ifdef __MMI_UI_LIST_GRID_LINE__
    wgui_inline_editor_generate_separator_table(list_of_items,number_of_items);
#endif /* __MMI_UI_LIST_GRID_LINE__ */
    
#ifdef __MMI_FTE_SUPPORT__
    inline_fte_set_item_height_by_guess(list_of_items, number_of_items);
#endif

    if (list_of_icons == NULL)
    {
        /* without icons */
        for (i = 0; (i < number_of_items) && (i < MAX_INLINE_ITEMS); i++)
        {
            wgui_inline_items[i] = list_of_items[i];
            add_fixed_icontext_item((UI_string_type) wgui_inline_items[i].text_p, NULL);
#ifdef __MMI_INLINE_HIGHLIGHT_CAPTION__
            //Inline draw all items by itself
            MMI_fixed_icontext_menuitems[i].flags |= UI_MENUITEM_INLINE_EDIT_OBJECT;
#endif

            if ((wgui_inline_items[i].flags & 0xff) == INLINE_ITEM_TYPE_USER_DEFINED_SELECT)
            {
                MMI_fixed_icontext_menuitems[i].flags |= UI_MENUITEM_DISABLE_BACKGROUND_ALWAYS;
                MMI_fixed_icontext_menuitems[i].ext_flags |= UI_MENUITEM_EXT_DISABLE_FOCUSSED_TEXT_DISPLAY;
            }
			
#if defined (__MMI_INLINE_ITEM_RADIO__)
            if ((wgui_inline_items[i].flags & 0xff) == INLINE_ITEM_TYPE_RADIO)
            {
                MMI_fixed_icontext_menuitems[i].flags |= UI_MENUITEM_INLINE_EDIT_OBJECT;
            }
#endif

#if defined (__MMI_INLINE_ITEM_CHECKBOX__)
            if ((wgui_inline_items[i].flags & 0xff) == INLINE_ITEM_TYPE_CHECKBOX)
            {
                MMI_fixed_icontext_menuitems[i].flags |= UI_MENUITEM_INLINE_EDIT_OBJECT;
            }
#endif			

#if defined (__MMI_INLINE_ITEM_DOW__)
            if ((wgui_inline_items[i].flags & 0xff) == INLINE_ITEM_TYPE_DOW_SELECT)
            {
                MMI_fixed_icontext_menuitems[i].flags |= UI_MENUITEM_INLINE_EDIT_OBJECT;
            }
#endif			
            if ((wgui_inline_items[i].flags & 0xff) == INLINE_ITEM_TYPE_DISPLAY_ONLY)
            {
                if((wgui_inline_items[i].flags) & INLINE_ITEM_RIGHT_JUSTIFY)
                {
                    MMI_fixed_icontext_menuitems[i].flags |= UI_MENUITEM_INLINE_EDIT_OBJECT;
                }
            }

#if defined (__MMI_INLINE_ITEM_COLOR_SELECT__) 			
            if ((wgui_inline_items[i].flags & 0xff) == INLINE_ITEM_TYPE_COLOR_SELECT)
            {               
                MMI_fixed_icontext_menuitems[i].flags |= UI_MENUITEM_INLINE_EDIT_OBJECT;
            }
#endif

            if (wgui_inline_items[i].flags & INLINE_ITEM_DISABLE_HIGHLIGHT)
            {
                MMI_fixed_icontext_menuitems[i].flags |= UI_MENUITEM_DISABLE_BACKGROUND_ALWAYS;
            }

            if ((wgui_inline_items[i].flags & INLINE_ITEM_BOUNDARY_MASK) == INLINE_ITEM_BOUNDARY_ALWAYS)
            {
                MMI_fixed_icontext_menuitems[i].flags |= UI_MENUITEM_INLINE_EDIT_OBJECT;
            }
			
#if defined (__MMI_INLINE_ITEM_IMAGETEXT__)
            if ((wgui_inline_items[i].flags & 0xff) == INLINE_ITEM_IMAGE_TEXT_TYPE)
            {
                if (wgui_inline_items[i].show_img_flag == TRUE)
                {
                    MMI_fixed_icontext_menuitems[i].flags |= UI_MENUITEM_INLINE_EDIT_OBJECT;
                }
            }
#endif			

            if (wgui_inline_items[i].flags & INLINE_ITEM_DOTTED_UNDERLINE)
            {
                MMI_fixed_icontext_menuitems[i].flags |= UI_MENUITEM_DOTTED_UNDERLINE;
            }
			
#if defined (__MMI_INLINE_ITEM_MULTILINE_EDIT__) || defined (__MMI_INLINE_ITEM_MULTILINE_READ_ONLY__)
            if (((wgui_inline_items[i].flags & 0xff) == INLINE_ITEM_TYPE_MULTI_LINE_RD_ONLY) ||
                ((wgui_inline_items[i].flags & 0xff) == INLINE_ITEM_TYPE_MULTI_LINE_EDIT))
            {
                MMI_fixed_icontext_menuitems[i].flags |= UI_MENUITEM_INLINE_EDIT_OBJECT;
            }
#endif

#if defined (__MMI_INLINE_ITEM_TIME_PEROID__)
            if ((wgui_inline_items[i].flags & 0xff) == INLINE_ITEM_TYPE_TIME_PERIOD)
            {
                MMI_fixed_icontext_menuitems[i].ext_flags |= UI_MENUITEM_EXT_DISABLE_FOCUSSED_TEXT_DISPLAY;
            }
#endif			

            if ((wgui_inline_items[i].flags & 0xff) == INLINE_ITEM_TYPE_SELECT)
            {
                if (wgui_inline_items[i].show_img_flag == TRUE)
                {
                    MMI_fixed_icontext_menuitems[i].flags |= UI_MENUITEM_INLINE_EDIT_OBJECT;
                }

                /* flags must be enabled in all the cases so that inline select item will have
                   similar behaviour in each case. */
                MMI_fixed_icontext_menuitems[i].flags |= UI_MENUITEM_DISABLE_BACKGROUND_ALWAYS;
                MMI_fixed_icontext_menuitems[i].ext_flags |= UI_MENUITEM_EXT_DISABLE_FOCUSSED_TEXT_DISPLAY;

            }

#if defined (__MMI_INLINE_ITEM_COLOR_SELECT__)
            if ((wgui_inline_items[i].flags & 0xff) == INLINE_ITEM_TYPE_COLOR_SELECT)
            {                
                if (wgui_inline_items[i].show_img_flag == TRUE)
                {
                    MMI_fixed_icontext_menuitems[i].flags |= UI_MENUITEM_INLINE_EDIT_OBJECT;
                }
                MMI_fixed_icontext_menuitems[i].flags |= UI_MENUITEM_DISABLE_BACKGROUND_ALWAYS;
                MMI_fixed_icontext_menuitems[i].ext_flags |= UI_MENUITEM_EXT_DISABLE_FOCUSSED_TEXT_DISPLAY;
            }
#endif			

            
            if ((wgui_inline_items[i].flags & 0xff) == INLINE_ITEM_TYPE_TEXT_EDIT)
            {
                MMI_fixed_icontext_menuitems[i].ext_flags |= UI_MENUITEM_EXT_DISABLE_FOCUSSED_TEXT_DISPLAY;
                if(wgui_inline_items[i].flags & INLINE_ITEM_ICON_IN_ITEM)
                {
                    MMI_fixed_icontext_menuitems[i].ext_flags |= UI_MENUITEM_EXT_SHOW_INDICATOR;
                }
            }
            
            if (((wgui_inline_items[i].flags & 0xff) == INLINE_ITEM_TYPE_FULL_SCREEN_EDIT) ||
                ((wgui_inline_items[i].flags & 0xff) == INLINE_ITEM_TYPE_CAPTION) ||
                ((wgui_inline_items[i].flags & 0xff) == INLINE_ITEM_TYPE_DISPLAY_ONLY))
            {  
                if(wgui_inline_items[i].flags & INLINE_ITEM_ICON_IN_ITEM)
                {
                    MMI_fixed_icontext_menuitems[i].ext_flags |= UI_MENUITEM_EXT_SHOW_INDICATOR;
                }
            }

        #ifdef __MMI_WALLPAPER_ON_BOTTOM__
            if (((wgui_inline_items[i].flags & 0xff) == INLINE_ITEM_TYPE_FULL_SCREEN_EDIT
                ||(wgui_inline_items[i].flags & 0xff) == INLINE_ITEM_IMAGE_TEXT_TYPE)
                && (wgui_inline_items[i].flags & INLINE_ITEM_OPEN))
            {
                handle_inline_full_screen_edit_opacity_set((U8)(current_MMI_theme->bg_opacity_low));    
            #if !defined(GUI_EDITOR_SHOW_TITLE)
                full_screen_edit_open = 1;
            #endif /* !defined(GUI_EDITOR_SHOW_TITLE) */ 
            }
        #endif /* __MMI_WALLPAPER_ON_BOTTOM__ */ 

        #if defined(__MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__) && !(defined(__MMI_MAINLCD_128X128__) || defined(__MMI_MAINLCD_128X160__) || defined(__MMI_MAINLCD_128X64__)) 
            if ((((wgui_inline_items[i].flags & 0xff) == INLINE_ITEM_TYPE_TEXT_EDIT)
                 || ((wgui_inline_items[i].flags & 0xff) == INLINE_ITEM_TYPE_FULL_SCREEN_EDIT)
                 || ((wgui_inline_items[i].flags & 0xff) == INLINE_ITEM_TYPE_DATE)
                 || ((wgui_inline_items[i].flags & 0xff) == INLINE_ITEM_TYPE_SELECT)
                 || ((wgui_inline_items[i].flags & 0xff) == INLINE_ITEM_TYPE_TIME)
                 || ((wgui_inline_items[i].flags & 0xff) == INLINE_ITEM_TYPE_TIME_PERIOD)
                 || ((wgui_inline_items[i].flags & 0xff) == INLINE_ITEM_TYPE_DOW_SELECT)
                 || ((wgui_inline_items[i].flags & 0xff) == INLINE_ITEM_TYPE_IP4_EDIT)
                 || ((wgui_inline_items[i].flags & 0xff) == INLINE_ITEM_TYPE_COLOR_SELECT))
                && (IsInlineItemDefaultTextEnable()))
            {
                MMI_fixed_icontext_menuitems[i].ext_flags |= UI_MENUITEM_EXT_SHOW_IN_ROUNDED_RECT;
            }
        #endif /* __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__ */ 
        }
    }
    else
    {
        /* with icons */
        for (i = 0; (i < number_of_items) && (i < MAX_INLINE_ITEMS); i++)
        {
            wgui_inline_items[i] = list_of_items[i];
            wgui_inline_items[i].side_img = get_image(list_of_icons[i]);

            add_fixed_icontext_item(
                (UI_string_type) wgui_inline_items[i].text_p,
                /*wgui_get_list_menu_icon_if_not_empty(inline_item_index, list_of_icons[i])*/
			    get_image(list_of_icons[i]));

            if (wgui_inline_items[i].side_img != NULL)
            {
                inline_item_index++;
            }

            if ((wgui_inline_items[i].flags & 0xff) == INLINE_ITEM_TYPE_USER_DEFINED_SELECT)
            {
                MMI_fixed_icontext_menuitems[i].flags |= UI_MENUITEM_DISABLE_BACKGROUND_ALWAYS;
                MMI_fixed_icontext_menuitems[i].ext_flags |= UI_MENUITEM_EXT_DISABLE_FOCUSSED_TEXT_DISPLAY;
            }
			
#if defined (__MMI_INLINE_ITEM_RADIO__)
            if ((wgui_inline_items[i].flags & 0xff) == INLINE_ITEM_TYPE_RADIO)
            {
                MMI_fixed_icontext_menuitems[i].flags |= UI_MENUITEM_INLINE_EDIT_OBJECT;
            }
#endif			

#if defined (__MMI_INLINE_ITEM_CHECKBOX__)
            if ((wgui_inline_items[i].flags & 0xff) == INLINE_ITEM_TYPE_CHECKBOX)
            {
                MMI_fixed_icontext_menuitems[i].flags |= UI_MENUITEM_INLINE_EDIT_OBJECT;
            }
#endif			

#if defined (__MMI_INLINE_ITEM_DOW__)
            if ((wgui_inline_items[i].flags & 0xff) == INLINE_ITEM_TYPE_DOW_SELECT)
            {
                MMI_fixed_icontext_menuitems[i].flags |= UI_MENUITEM_INLINE_EDIT_OBJECT;
            }
#endif			

            if ((wgui_inline_items[i].flags & 0xff) == INLINE_ITEM_TYPE_DISPLAY_ONLY)
            {
                if((wgui_inline_items[i].flags) & INLINE_ITEM_RIGHT_JUSTIFY)
                {
                    MMI_fixed_icontext_menuitems[i].flags |= UI_MENUITEM_INLINE_EDIT_OBJECT;
                }
            }

#if defined (__MMI_INLINE_ITEM_COLOR_SELECT__)			
            if ((wgui_inline_items[i].flags & 0xff) == INLINE_ITEM_TYPE_COLOR_SELECT)
            {                
                MMI_fixed_icontext_menuitems[i].flags |= UI_MENUITEM_INLINE_EDIT_OBJECT;
            }
#endif			

            if (wgui_inline_items[i].flags & INLINE_ITEM_DISABLE_HIGHLIGHT)
            {
                MMI_fixed_icontext_menuitems[i].flags |= UI_MENUITEM_DISABLE_BACKGROUND_ALWAYS;
            }

            if ((wgui_inline_items[i].flags & INLINE_ITEM_BOUNDARY_MASK) == INLINE_ITEM_BOUNDARY_ALWAYS)
            {
                MMI_fixed_icontext_menuitems[i].flags |= UI_MENUITEM_INLINE_EDIT_OBJECT;
            }

            if (((wgui_inline_items[i].flags & INLINE_ITEM_LEFT_ALIGN) == INLINE_ITEM_LEFT_ALIGN) &&
                ((wgui_inline_items[i].flags & 0xff) == INLINE_ITEM_TYPE_CAPTION) &&
                (get_image(list_of_icons[i]) == NULL))
            {
                MMI_fixed_icontext_menuitems[i].flags |= UI_MENUITEM_DISABLE_ICON;
            }

            if (wgui_inline_items[i].flags & INLINE_ITEM_DOTTED_UNDERLINE)
            {
                MMI_fixed_icontext_menuitems[i].flags |= UI_MENUITEM_DOTTED_UNDERLINE;
            }

#if defined (__MMI_INLINE_ITEM_IMAGETEXT__)
            if ((wgui_inline_items[i].flags & 0xff) == INLINE_ITEM_IMAGE_TEXT_TYPE)
            {
                if (wgui_inline_items[i].show_img_flag == TRUE)
                {
                    MMI_fixed_icontext_menuitems[i].flags |= UI_MENUITEM_INLINE_EDIT_OBJECT;
                }
            }
#endif			

#if defined (__MMI_INLINE_ITEM_MULTILINE_EDIT__) || defined(__MMI_INLINE_ITEM_MULTILINE_READ_ONLY__)
            if (((wgui_inline_items[i].flags & 0xff) == INLINE_ITEM_TYPE_MULTI_LINE_RD_ONLY) ||
                ((wgui_inline_items[i].flags & 0xff) == INLINE_ITEM_TYPE_MULTI_LINE_EDIT))
            {
                MMI_fixed_icontext_menuitems[i].flags |= UI_MENUITEM_INLINE_EDIT_OBJECT;
            }
#endif			

#if defined (__MMI_INLINE_ITEM_TIME_PEROID__)
            if ((wgui_inline_items[i].flags & 0xff) == INLINE_ITEM_TYPE_TIME_PERIOD)
            {
                MMI_fixed_icontext_menuitems[i].ext_flags |= UI_MENUITEM_EXT_DISABLE_FOCUSSED_TEXT_DISPLAY;
            }
#endif			

            if ((wgui_inline_items[i].flags & 0xff) == INLINE_ITEM_TYPE_SELECT)
            {
                if (wgui_inline_items[i].show_img_flag == TRUE)
                {
                    MMI_fixed_icontext_menuitems[i].flags |= UI_MENUITEM_INLINE_EDIT_OBJECT;
                }
                /* flags must be enabled in all the cases so that inline select item will have
                   similar behaviour in each case. */
                MMI_fixed_icontext_menuitems[i].flags |= UI_MENUITEM_DISABLE_BACKGROUND_ALWAYS;
                MMI_fixed_icontext_menuitems[i].ext_flags |= UI_MENUITEM_EXT_DISABLE_FOCUSSED_TEXT_DISPLAY;
            }

#if defined (__MMI_INLINE_ITEM_COLOR_SELECT__)
            if ((wgui_inline_items[i].flags & 0xff) == INLINE_ITEM_TYPE_COLOR_SELECT)
            {
                
                if (wgui_inline_items[i].show_img_flag == TRUE)
                {
                    MMI_fixed_icontext_menuitems[i].flags |= UI_MENUITEM_INLINE_EDIT_OBJECT;
                }
                MMI_fixed_icontext_menuitems[i].flags |= UI_MENUITEM_DISABLE_BACKGROUND_ALWAYS;
                MMI_fixed_icontext_menuitems[i].ext_flags |= UI_MENUITEM_EXT_DISABLE_FOCUSSED_TEXT_DISPLAY;
            }
#endif			

            if ((wgui_inline_items[i].flags & 0xff) == INLINE_ITEM_TYPE_TEXT_EDIT)
            {
                MMI_fixed_icontext_menuitems[i].ext_flags |= UI_MENUITEM_EXT_DISABLE_FOCUSSED_TEXT_DISPLAY;
                if(wgui_inline_items[i].flags & INLINE_ITEM_ICON_IN_ITEM)
                {
                    MMI_fixed_icontext_menuitems[i].ext_flags |= UI_MENUITEM_EXT_SHOW_INDICATOR;
                }
                if(wgui_inline_items[i].side_img == NULL)
                {
                    wgui_inline_items[i].flags &= ~INLINE_ITEM_DISABLE_HIGHLIGHT;
                }
            }
            
            if (((wgui_inline_items[i].flags & 0xff) == INLINE_ITEM_TYPE_FULL_SCREEN_EDIT) ||
                ((wgui_inline_items[i].flags & 0xff) == INLINE_ITEM_TYPE_CAPTION) ||
                ((wgui_inline_items[i].flags & 0xff) == INLINE_ITEM_TYPE_DISPLAY_ONLY))
            {  
                if(wgui_inline_items[i].flags & INLINE_ITEM_ICON_IN_ITEM)
                {
                    MMI_fixed_icontext_menuitems[i].ext_flags |= UI_MENUITEM_EXT_SHOW_INDICATOR;
                }
            }

        #ifdef __MMI_WALLPAPER_ON_BOTTOM__
            if (((wgui_inline_items[i].flags & 0xff) == INLINE_ITEM_TYPE_FULL_SCREEN_EDIT
                ||(wgui_inline_items[i].flags & 0xff) == INLINE_ITEM_IMAGE_TEXT_TYPE)
                && (wgui_inline_items[i].flags & INLINE_ITEM_OPEN))
            {
                handle_inline_full_screen_edit_opacity_set((U8)(current_MMI_theme->bg_opacity_low));    
            #if !defined(GUI_EDITOR_SHOW_TITLE)
                full_screen_edit_open = 1;
            #endif /* !defined(GUI_EDITOR_SHOW_TITLE) */
            }
        #endif /* __MMI_WALLPAPER_ON_BOTTOM__ */ 

        #if defined(__MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__) && !(defined(__MMI_MAINLCD_128X128__) || defined(__MMI_MAINLCD_128X160__) || defined(__MMI_MAINLCD_128X64__) || defined(__MMI_MAINLCD_128X64__)) 
            if ((((wgui_inline_items[i].flags & 0xff) == INLINE_ITEM_TYPE_TEXT_EDIT)
                 || ((wgui_inline_items[i].flags & 0xff) == INLINE_ITEM_TYPE_FULL_SCREEN_EDIT)
                 || ((wgui_inline_items[i].flags & 0xff) == INLINE_ITEM_TYPE_DATE)
                 || ((wgui_inline_items[i].flags & 0xff) == INLINE_ITEM_TYPE_SELECT)
                 || ((wgui_inline_items[i].flags & 0xff) == INLINE_ITEM_TYPE_TIME)
                 || ((wgui_inline_items[i].flags & 0xff) == INLINE_ITEM_TYPE_TIME_PERIOD)
                 || ((wgui_inline_items[i].flags & 0xff) == INLINE_ITEM_TYPE_DOW_SELECT)
                 || ((wgui_inline_items[i].flags & 0xff) == INLINE_ITEM_TYPE_IP4_EDIT)
                 || ((wgui_inline_items[i].flags & 0xff) == INLINE_ITEM_TYPE_COLOR_SELECT))
                && (IsInlineItemDefaultTextEnable()))
            {
                MMI_fixed_icontext_menuitems[i].ext_flags |= UI_MENUITEM_EXT_SHOW_IN_ROUNDED_RECT;
            }
        #endif /* __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__ */ 

        }
    }
    wgui_setup_inline_edit_themes();
    wgui_n_inline_items = number_of_items;
    register_inline_fixed_list_keys();
    resize_fixed_icontext_menuitems(0, MMI_MENUITEM_HEIGHT);

    if (list_of_icons == NULL)
    {
        set_fixed_icontext_positions(2, 0, 1, 0);
    }
    else
    {
        set_fixed_icontext_positions(GUI_ICONTEXT_MENUITEM_TEXT_X, 0, GUI_ICONTEXT_MENUITEM_ICON_X, 0);
    }

    /* Inline screens use Pop up description components to get x,y,width,height   */
#if(UI_ENABLE_POP_UP_DESCRIPTIONS)
    MMI_fixed_list_menu.gui_display_pop_up_description = handle_inline_item_location;
#ifdef __MMI_UI_HINTS_IN_MENUITEM__
    MMI_fixed_list_menu.gui_get_current_pop_up_description_string = UI_dummy_get_current_pop_up_description_string;
#endif 
#endif /* (UI_ENABLE_POP_UP_DESCRIPTIONS) */ 

    register_fixed_list_highlight_handler(highlight_handler);
    register_fixed_list_unhighlight_handler(unhighlight_handler);

    /* Override default font */
    MMI_fixed_icontext_menuitem.text_font = &MMI_medium_font;
    MMI_fixed_text_menuitem.text_font = &MMI_medium_font;

    wgui_title_disable_menu_shortcut_display(MMI_TRUE);
    MMI_current_menu_type = LIST_MENU;
    h_flag = set_list_menu_category_history(history_id, history_buffer);
    h = (list_menu_category_history*) history_buffer;
    if (h_flag && (h->num_items == MMI_fixed_list_menu.n_items))
    {
        U32 *flags;
        S32 s = sizeof(list_menu_category_history);
        s32 save_n;
        S32 save_last_display_item_index;

        s = (s + 3) / 4;
        s *= 4;

        if(cui_inline_is_current_cui() == MMI_FALSE)
        {
            flags = (U32*) (history_buffer + s);

            wgui_inline_list_menu_changed = (U8) * flags;
        }
        else
        {   
            S32 index = cui_inline_convert_id_to_index(g_cui_inline_current_instance->gid, g_cui_inline_current_instance->highlight_item_id);
            
            MMI_fixed_list_menu.highlighted_item = index ;
        }

        if((cui_inline_is_current_cui()) &&
           (g_cui_inline_current_instance->history_item_id != g_cui_inline_current_instance->cui_inline_items[MMI_fixed_list_menu.highlighted_item].common_data.item_id)
          )
        {
            wgui_current_history_buffer = NULL;
        }
        else
        {
            wgui_current_history_buffer = (U8*) (history_buffer + s + sizeof(U32));
        }
        save_n = MMI_fixed_list_menu.first_displayed_item;
        save_last_display_item_index = MMI_fixed_list_menu.last_displayed_item;
        
        fixed_list_goto_item_no_redraw(MMI_fixed_list_menu.highlighted_item);
        if (save_n != MMI_fixed_list_menu.first_displayed_item)
        {
	    if(cui_inline_is_current_cui())
	    {
                if((MMI_fixed_list_menu.highlighted_item <= (save_n + MMI_fixed_list_menu.displayed_items - 1)) &&
                   (MMI_fixed_list_menu.highlighted_item >= save_n)
                  )
		{
		    MMI_fixed_list_menu.first_displayed_item = save_n;
                    MMI_fixed_list_menu.last_displayed_item = save_last_display_item_index;
		}
	    }
            else
            {
                MMI_fixed_list_menu.first_displayed_item = save_n;
                MMI_fixed_list_menu.last_displayed_item = save_last_display_item_index;
            }
        }

    #if defined(__MMI_INSCREEN_MULTILINE_TEXTBOX__)
    #if defined( __MMI_INLINE_ITEM_MULTILINE_READ_ONLY__) || defined( __MMI_INLINE_ITEM_MULTILINE_EDIT__)
        for (i = 0; (i < number_of_items) && (i < MAX_INLINE_ITEMS); i++)
        {
            if ((wgui_inline_items[i].flags & 0xff) == INLINE_ITEM_TYPE_MULTI_LINE_EDIT)
            {
                wgui_inline_items[i].flags |= INLINE_ITEM_OPEN;
            }
        }
    #endif
    #endif /* defined(__MMI_INSCREEN_MULTILINE_TEXTBOX__) */ 
    }
    else
    {
        wgui_current_history_buffer = NULL;        
#if defined (__MMI_INLINE_ITEM_IMAGETEXT__)        
        inline_image_text_edit_flag = 0;
#endif
        fixed_list_goto_item_no_redraw(highlighted_item);
    }
    current_fixed_icontext_menuitem_theme = saved_themedata1;
    current_fixed_list_menu_theme = saved_themedata2;

    wgui_inline_edit_resize_multiline_height();
#ifdef __MMI_TOUCH_SCREEN__
    gui_vertical_scrollbar_register_get_diff(&(MMI_fixed_list_menu.vbar), wgui_inline_get_item_height_for_scroll_bar);
#endif

}


#ifdef __MMI_TOUCH_SCREEN__
/*****************************************************************************
 * FUNCTION
 *  UI_dummy_inline_item_pen_function
 * DESCRIPTION
 *  dummy pen function
 * PARAMETERS
 *  pen_event       [IN]    pen event    
 *  x               [IN]    pen x position    
 *  y               [IN]    pen y position    
 *  item_event      [IN]    inline pen enum         
 * RETURNS
 *  BOOL
 *****************************************************************************/
BOOL UI_dummy_inline_item_pen_function(
        mmi_pen_event_type_enum pen_event,
        S16 x,
        S16 y,
        gui_inline_item_pen_enum *item_event)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(pen_event);
    UI_UNUSED_PARAMETER(x);
    UI_UNUSED_PARAMETER(y);
    *item_event = GUI_INLINE_ITEM_PEN_NONE;
    return MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  gui_inline_handle_pen_event_by_item
 * DESCRIPTION
 *  handle pen event by inline item
 * PARAMETERS
 *  m                   [IN]    fixed lit menu pointer         
 *  pen_event           [IN]    pen event    
 *  x                   [IN]    pen x position    
 *  y                   [IN]    pen y position    
 *  inline_event        [IN]    inline pen enum     
 * RETURNS
 *  BOOL
 *****************************************************************************/
static BOOL gui_inline_handle_pen_event_by_item(
                U16 item_index,
                mmi_pen_event_type_enum pen_event,
                S16 x,
                S16 y,
                gui_inline_pen_enum *inline_event)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gui_inline_item_pen_enum item_event;
    BOOL ret;
#if defined(__MMI_TOUCH_SCREEN__) || defined(__MMI_FTE_SUPPORT__)
    U32 item_type = 0;
#endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    *inline_event = GUI_INLINE_PEN_NONE;
#if defined(__MMI_TOUCH_SCREEN__) || defined(__MMI_FTE_SUPPORT__)
	item_type = wgui_inline_items[item_index].flags & INLINE_ITEM_TYPE_MASK;
#endif
#if defined(__MMI_TOUCH_SCREEN__)&& defined (__MMI_INLINE_ITEM_BUTTON__)
    if (item_type == INLINE_ITEM_TYPE_BUTTON)
    {
        inline_button_item_pen_handler(pen_event, x, y, inline_event, item_index);
        return TRUE;
    }
#endif /* __MMI_TOUCH_SCREEN__ */
#ifdef __MMI_FTE_SUPPORT__
    if((item_type == INLINE_ITEM_TYPE_DISPLAY_ONLY)||(item_type == INLINE_ITEM_TYPE_FULL_SCREEN_EDIT))
    {
        inline_fte_displayonly_item_pen_handler(pen_event, x, y, inline_event, item_index);
        return TRUE;
    }
#endif
    ret = wgui_current_inline_item_pen_function(pen_event, x, y, &item_event);
    if (ret)
    {
        if (item_event == GUI_INLINE_ITEM_PEN_NEED_REDRAW_MENU)
        {
            *inline_event = GUI_INLINE_PEN_NEED_REDRAW;
        }
        else if (item_event == GUI_INLINE_ITEM_PEN_NEED_REDRAW_ITEM)
        {
            redraw_current_inline_item();
        }
        else if (item_event == GUI_INLINE_ITEM_PEN_SELECTED)
        {
            *inline_event = GUI_INLINE_PEN_ITEM_SELECTED;
        }
    }

    return ret;
}


/*****************************************************************************
 * FUNCTION
 *  gui_inline_scroll_by_pen
 * DESCRIPTION
 *  handle scrolling by pen event
 * PARAMETERS
 *  m                   [IN]     fixed list menu pointer    
 *  x                   [IN]     pen x position   
 *  y                   [IN]     pen y position   
 *  first_displayed     [IN]     first displayed menu item   
 *  inline_event        [IN]     inline pen enum    
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_inline_scroll_by_pen(
                fixed_list_menu *m,
                S16 x,
                S16 y,
                S32 first_displayed_offset_y,
                gui_inline_pen_enum *inline_event,
                mmi_pen_event_type_enum pen_event)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 last_displayed;
    S32 iwidth, iheight;
    S32 total_height, i;
    S32 first_displayed = 0;
    S32 max_first_displayed = 0;

    MMI_BOOL history_stored;
    U8 gui_buffer[MAX_GUI_BUFFER];
    S32 current_highlight_index = -1;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    total_height = 0;
    for (i = first_displayed; i < m->n_items; i++)
    {
        if (i == m->highlighted_item)
        {
            m->current_displayed_item = -1;
        }
        else
        {
            m->current_displayed_item = i;
        }
        m->item_measure_function(m->items[i], m->common_item_data, &iwidth, &iheight);
        total_height += iheight;
        if (total_height > first_displayed_offset_y)
        {
            first_displayed = i;
            break;
        }
    }
    if( total_height <= first_displayed_offset_y)
    {
        first_displayed = m->n_items - 1;
    }
    total_height = 0;
    for(i = m->n_items - 1; i >= 0; i--)
    {
        if (i == m->highlighted_item)
	  {
            m->current_displayed_item = -1;
        }
        else
	  {
            m->current_displayed_item = i;
	  }
        m->item_measure_function(m->items[i], m->common_item_data, &iwidth, &iheight);
            
        total_height +=iheight;
        if(total_height > m->height)
        {
           max_first_displayed = i + 1;     
           break;
        }
    }
    if(max_first_displayed < first_displayed)
    {
        first_displayed = max_first_displayed;
    }

    if (first_displayed == m->first_displayed_item)
    {
        *inline_event = GUI_INLINE_PEN_NONE;
        return;
    }
    current_highlight_index = m->highlighted_item;
    /* 
     * Sometimes the inline editor is scrolled (m->first_displayed is changed) but
     * the highlighted item (m->highlighted_item) stays unchanged.
     * 
     * In this case, we should keep the context of inline item unchanged 
     * (e.g. editor cursor & input method), and we put the information in gui_buffer[].
     *
     * Reference: wgui_get_inline_history(), wgui_inline_edit_get_current_item_history(), 
     * and wgui_current_history_buffer.
     */
    history_stored = MMI_TRUE;
    switch (wgui_current_inline_item_type)
    {
        case INLINE_ITEM_TYPE_TEXT_EDIT:
            inline_text_edit_get_history(gui_buffer);
            break;

        case INLINE_ITEM_TYPE_DATE:
#if defined (__MMI_INLINE_ITEM_DATE__)
            inline_date_edit_get_history(gui_buffer);
#endif /* __MMI_INLINE_ITEM_DATE__ */
            break;

        case INLINE_ITEM_TYPE_TIME:
#if defined (__MMI_INLINE_ITEM_TIME__)
            inline_time_edit_get_history(gui_buffer);
#endif /* __MMI_INLINE_ITEM_TIME__ */
            break;
#if defined (__MMI_INLINE_ITEM_TIME_PEROID__)   
        case INLINE_ITEM_TYPE_TIME_PERIOD:
            inline_time_period_edit_get_history(gui_buffer);
            break;
#endif
        case INLINE_ITEM_TYPE_IP4_EDIT:
#if defined (__MMI_INLINE_ITEM_IP4__)
            inline_IP4_edit_get_history(gui_buffer);
#endif /* __MMI_INLINE_ITEM_IP4__ */
            break;
#if defined (__MMI_INLINE_ITEM_DOW__)
        case INLINE_ITEM_TYPE_DOW_SELECT:
            inline_DOW_select_get_history(gui_buffer);
            break;
#endif			

#if defined (__MMI_INLINE_ITEM_MULTILINE_EDIT__) || defined (__MMI_INLINE_ITEM_MULTILINE_READ_ONLY__)
        case INLINE_ITEM_TYPE_MULTI_LINE_EDIT:
        case INLINE_ITEM_TYPE_MULTI_LINE_RD_ONLY:
            inline_multi_line_edit_get_history(gui_buffer);
            break;
#endif
        default:
            history_stored = MMI_FALSE;
    }

    /* Finalize current editing. */
    complete_inline_item_edit();

    /*
     * Note that m->first_displayed_item might be changed inside m->item_highlighted() 
     * (which is typically wgui_inline_edit_default_list_highlight_handler())
     * if INLINE_ITEM_FOLLOW_DOWN or INLINE_ITEM_FOLLOW_UP is set on the highlighed item. 
     * 
     * inline item handler is invoked from handle_inline_item_location() (typically from gui_show_fixed_list_menu())
     */

    *inline_event = GUI_INLINE_PEN_NONE;

    if(cui_inline_is_current_cui())
    {
        cui_inline_lock_main_screen(g_cui_inline_current_instance->gid);
    }

    /* Scroll down */
    if (first_displayed > m->highlighted_item)
    {
        /* Revise for multiline. */
#if defined (__MMI_INLINE_ITEM_MULTILINE_READ_ONLY__)		
        if(((wgui_inline_items[m->n_items - 1].flags & 0xff) == INLINE_ITEM_TYPE_MULTI_LINE_RD_ONLY) &&
           (first_displayed == m->n_items - 1)
          )
        {
            m->first_displayed_item = first_displayed;
        }
#endif		
        m->flags |= UI_LIST_MENU_FIRST_SHIFT_HIGHLIGHTED_ITEM;
        inline_fixed_list_goto_item(first_displayed, MMI_FALSE);
        m->flags &= ~UI_LIST_MENU_FIRST_SHIFT_HIGHLIGHTED_ITEM;
    }
    else
    {
        /* Compute last_displayed */
        last_displayed = m->n_items - 1;
        total_height = 0;
        for (i = first_displayed; i < m->n_items; i++)
        {
            if (i == m->highlighted_item)
            {
                m->current_displayed_item = -1;
            }
            else
            {
                m->current_displayed_item = i;
            }
            m->item_measure_function(m->items[i], m->common_item_data, &iwidth, &iheight);
            total_height += iheight;
            if (total_height > m->height + 1)
            {
                last_displayed = i - 1;
                break;
            }
        }

        /* Scroll up */
        if (last_displayed < m->highlighted_item)
        {
#if defined (__MMI_INLINE_ITEM_MULTILINE_READ_ONLY__)
			if(((wgui_inline_items[m->n_items - 1].flags & 0xff) == INLINE_ITEM_TYPE_MULTI_LINE_RD_ONLY) &&
               (last_displayed == m->n_items - 2) &&  /* last_displayed item is above ml_rdonly_item */
               ((wgui_inline_items[m->highlighted_item].flags & 0xff) == INLINE_ITEM_TYPE_MULTI_LINE_RD_ONLY) 
              )
            {  
                /* 
                  It means ml_rdonly_item is exist, so new highlight item(last_displayed item) shouldn't
                pull above all item out on screen.
                */
                total_height = 0;
                for(i = first_displayed; i <= last_displayed; i++)
                {
                    if (i == m->highlighted_item)
                    {
                        m->current_displayed_item = -1;
                    }
                    else
                    {
                        m->current_displayed_item = i;
                    }
                    m->item_measure_function(m->items[i], m->common_item_data, &iwidth, &iheight);
                    total_height += iheight;
                }
                if(total_height < m->height)    /* Means ml_rdonly_item is still shown on screen. */
                {
                    if (history_stored)
                    {
                        wgui_current_history_buffer = gui_buffer;
                    }
                    gui_lock_double_buffer();

                    m->item_unhighlighted(m->highlighted_item);
                    wgui_inline_item_highlighted_index = -1;
                    m->item_highlighted(m->highlighted_item);
                    m->first_displayed_item = first_displayed;
                    m->last_displayed_item = last_displayed;
                    redraw_fixed_list();
                    
                    if (history_stored)
                    {
                    /* Failsafe step because 'gui_buffer' is local variable. 
                    and it's lifecyle is inside the current function */
                    wgui_current_history_buffer = NULL;
                    }
                    gui_unlock_double_buffer();
                    gui_BLT_double_buffer(0, 0, UI_device_width - 1, UI_device_height - 1);
                }
                else
                {
                    m->flags |= UI_LIST_MENU_LAST_SHIFT_HIGHLIGHTED_ITEM;
                    inline_fixed_list_goto_item(last_displayed, MMI_TRUE);
                    m->flags &= ~UI_LIST_MENU_LAST_SHIFT_HIGHLIGHTED_ITEM;
                }
            }
            else
#endif				
            {
                /* Pull above item out on screen. */
            m->flags |= UI_LIST_MENU_LAST_SHIFT_HIGHLIGHTED_ITEM;
            inline_fixed_list_goto_item(last_displayed, MMI_TRUE);
            m->flags &= ~UI_LIST_MENU_LAST_SHIFT_HIGHLIGHTED_ITEM;
        }
        }
        else
        {
            S32 old_first_displayed;

            old_first_displayed = m->first_displayed_item;

            if (history_stored)
            {
                /* 
                 * Restore the context of the original highlighted item.
                 *
                 * Ex: Assume it is an inline text edit, we need to setup history
                 * buffer here; otherwise the virtual keyboard type is reset,
                 * and the list menu height might be changed.                     
                 *
                 * However, the current code logic assumes that menu height should
                 * stay unchanged after m->item_highlighted(). 
                 */
                wgui_current_history_buffer = gui_buffer;
            }
            
            gui_lock_double_buffer();

            m->item_unhighlighted(m->highlighted_item);
            m->first_displayed_item = first_displayed;
            m->last_displayed_item = last_displayed;
            wgui_inline_item_highlighted_index = -1;
            m->item_highlighted(m->highlighted_item);

            /* 
             * m->item_highlighted() might change m->first_displayed_item again if 
             * a. INLINE_ITEM_FOLLOW_DOWN and INLINE_ITEM_FOLLOW_UP is set to highlighted item.
             * b. m->first_displayed_item is incremented to display inline caption item
             *
             * Usually we can test the scenario in MMI Todo screen.
             */
            if (m->first_displayed_item == old_first_displayed)
            {
                /* 
                 * In this case, m->first_displayed_item != first_displayed 
                 * because there are other "restrictions" that set 
                 * m->first_displayed_item to the original value.
                 *
                 * It happens in many inline editor screens in MMI. 
                 */
                if (first_displayed < m->first_displayed_item)
                {
                    /*
                     * In this case, we want to scroll up the menu but fail to do so.
                     *
                     * For example, the last displayed item is currently highlighted, and 
                     * the item before the last displayed item is an inline caption.
                     * If we scroll up by one item, The inline caption is highlighted although
                     * it cannot be highlighted, and then highlight is set to the next 
                     * inline item, which is the original highlighted one. 
                     * As a result, the inline editor is not scrolled at all.
                     * 
                     * In order to solve this, we scroll "one" more inline item up.
                     */
                    m->flags |= UI_LIST_MENU_LAST_SHIFT_HIGHLIGHTED_ITEM;
                    inline_fixed_list_goto_item(last_displayed - 1, MMI_TRUE);
                    m->flags &= ~UI_LIST_MENU_LAST_SHIFT_HIGHLIGHTED_ITEM;
                }
                else
                {
                    /* Similar to previous case */
                    /* There are some problems:
                       1 If m->highlighted_item == 5, and old_first_displayed ==  m->first_displayed_item == 2(means not change list present),
                    first_displayed == 3, then the highlight item is changed from 5 to 3(because inline_fixed_list_goto_item(first_displayed + 1) ).
                       2 if(current_highlight_index != first_displayed + 1) can not work, because supposed this scenario:
                    a list contains only one ip4, and many caption. Then, still ip4 is highlight,but it lost its guibuffer.
                       3 we can not think that first_displayed must be equal to m->highlighted_item.
                    */
                    
                    /* first_displayed is list give inline first index */
                    /* 
                       example: first index is caption, 2th index is enable item and highlight, 3th is caption, 4th is enabler item.
                       when pen drags scroll bar, pen move 1 item distance, but inline will jump 2 items distance,
                       because highlight will shift to 4th item, and 4th item is first display item.
                    */
                    if((!((pen_event == MMI_PEN_EVENT_MOVE) && 
                          ((wgui_inline_items[first_displayed + 1].flags & 0xff) == INLINE_ITEM_TYPE_CAPTION))
                       ) ||
                       (m->last_displayed_item + 1 == m->n_items - 1))
                    {
                    gui_lock_double_buffer();
                    m->flags |= UI_LIST_MENU_FIRST_SHIFT_HIGHLIGHTED_ITEM;
                    wgui_current_history_buffer = NULL;
                    inline_fixed_list_goto_item(first_displayed + 1, MMI_FALSE);
                    m->flags &= ~UI_LIST_MENU_FIRST_SHIFT_HIGHLIGHTED_ITEM;
                    if(current_highlight_index != m->highlighted_item)
                    {
                        if (history_stored)
                        {
                            wgui_current_history_buffer = NULL;
                            wgui_inline_item_handled = 0;
                            redraw_fixed_list();                                                    
                        }            
                    }
                    
                    gui_unlock_double_buffer ();
                    gui_BLT_double_buffer(0, 0, UI_device_width - 1, UI_device_height - 1);
                }
                    else
                    {
                        gui_lock_double_buffer();
                        redraw_fixed_list();
                        gui_unlock_double_buffer();
                        gui_BLT_double_buffer(0, 0, UI_device_width - 1, UI_device_height - 1);
                    }
            }
            }
            else
            {
                gui_lock_double_buffer();

                redraw_fixed_list();
                
                redraw_current_inline_item();
                /* 
                 * Redraw virtual keyboard. 
                 * There is a small gap (e.g. 2 pixels) between fixed list and virtual keyboard
                 * and some inline item draw outside the list, we need to clear the gap by
                 * redrawing virtual keyboard.
                 */

                gui_unlock_double_buffer();
                gui_BLT_double_buffer(0, 0, UI_device_width - 1, UI_device_height - 1);
            }

            if (history_stored)
            {
                /* Failsafe step because 'gui_buffer' is local variable. 
                   and it's lifecyle is inside the current function */
                wgui_current_history_buffer = NULL;
            }
            
            /* Add it for Inline CUI, because highlight handler will blt softkey */
            gui_unlock_double_buffer();
            gui_BLT_double_buffer(0, 0, UI_device_width - 1, UI_device_height - 1);
        }
    }
    /* 
       Because switch to selector might redraw screen, thus pen event will be reset when switch screen,
    so scroll bar can not be dragged anymore. 
       So we prohibit to redraw screen when drag scroll bar. 
    */
    if(cui_inline_is_current_cui())
    {
        cui_inline_unlock_main_screen(g_cui_inline_current_instance->gid);
    }

    /* Because we do not always follow the value of 'first_displayed',
       we need to adjust scrollbar again. */
    gui_vertical_scrollbar_reconfigure_pen_value(&m->vbar, x, y);
}


/*****************************************************************************
 * FUNCTION
 *  gui_inline_translate_pen_position
 * DESCRIPTION
 *  Translate position to item index
 *  
 *  if y < minimum bound, *item_index is first_displayed_item - 1 or 0
 *  if y > maximum bound, *item_index is last_displayed_item + 1 or (n_items - 1)
 *  Caller of this function might be sensitive to the return result.
 *  Be careful when modifying this function.
 * PARAMETERS
 *  m               [IN]        fixed list menu object
 *  y               [IN]        y
 *  item_index      [OUT]       penned item index
 * RETURNS
 *  Return MMI_TRUE if y is within the menu; otherwise, MMI_FALSE.
 *****************************************************************************/
static BOOL gui_inline_translate_pen_position(fixed_list_menu *m, S32 x, S32 y, S32 *item_index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables												  */
    /*----------------------------------------------------------------*/
    BOOL ret = FALSE;
    U32 item_type = 0;
    
    /*----------------------------------------------------------------*/
    /* Code Body													  */
    /*----------------------------------------------------------------*/
    ret = gui_fixed_list_menu_translate_pen_position(m, y, item_index);
    item_type = wgui_inline_items[*item_index].flags & INLINE_ITEM_TYPE_MASK;
#if defined (__MMI_INLINE_ITEM_BUTTON__)    
    if (item_type == INLINE_ITEM_TYPE_BUTTON)
    {
        wgui_inline_item_button *i = (wgui_inline_item_button *)wgui_inline_items[*item_index].item;
        if (!PEN_CHECK_BOUND(x, y, (S32)(i->x), (S32)(i->y), (S32)(i->width), (S32)(i->height)))
        {
            ret = FALSE;
        }
    }
    else
#endif        
#ifdef __MMI_INSCREEN_MULTILINE_TEXTBOX__
#if defined( __MMI_INLINE_ITEM_MULTILINE_READ_ONLY__) || defined( __MMI_INLINE_ITEM_MULTILINE_EDIT__)
     if (!ret && *item_index == m->n_items - 1 &&
        (item_type == INLINE_ITEM_TYPE_MULTI_LINE_EDIT || item_type == INLINE_ITEM_TYPE_MULTI_LINE_RD_ONLY))
    {
        ret = TRUE;
    }
#endif
#endif
    return ret;
}


/*****************************************************************************
 * FUNCTION
 *  gui_inline_pen_get_highlight_index
 * DESCRIPTION
 *  get highlight index
 * PARAMETERS
 *  item_index               	[IN]        		item index
 * RETURNS
 *  void.
 *****************************************************************************/
static MMI_BOOL gui_inline_pen_get_highlight_index(S32 item_index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 high_index = 0;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_inline_pen_real_down_item_index = item_index;
    
    if(item_index != wgui_inline_item_highlighted_index)
    {
        high_index = wgui_inline_item_highlighted_index;
        
        /* if item_index == 0, it will search enable highlight item from index == 1, and 
                if wgui_inline_edit_is_able_to_switch_highlight() == MMI_FALSE, it means no other can highlight,
                so the process is correct.
                */
        if(item_index != 0)
        {
            wgui_inline_item_highlighted_index = item_index - 1; 
        }
        else
        {
            wgui_inline_item_highlighted_index = item_index;
        }
        
        if(wgui_inline_edit_is_able_to_switch_highlight(1) == MMI_FALSE)
        {
            wgui_inline_item_highlighted_index = high_index;
            wgui_inline_pen_handler_type = WGUI_INLINE_PEN_HANDLER_NONE;
            return MMI_TRUE;	
        }	
        else
        {
            wgui_inline_item_highlighted_index = high_index;
        }	
    }
    
    high_index = wgui_inline_edit_get_next_highlight_index(item_index);
    if ((item_index != wgui_inline_item_highlighted_index) &&
        (high_index == wgui_inline_item_highlighted_index))
    {
        wgui_inline_pen_handler_type = WGUI_INLINE_PEN_HANDLER_NONE;
        return MMI_TRUE;
    }
    
    if (item_index != high_index)
    {
        item_index = high_index;
    }
    wgui_inline_pen_down_item_index = item_index;
    return MMI_FALSE;
}


typedef struct
{
    S16 x;
    S16 y;
    mmi_pen_event_type_enum pen_event;
    gui_inline_pen_enum *inline_event;
}gui_inline_pen_event;


/*****************************************************************************
 * FUNCTION
 *  gui_inline_pen_type_handler
 * DESCRIPTION
 *  pen handler according to type
 *  
 * PARAMETERS
 *  m               		[IN]        		fixed list menu object
 *  event		      		[OUT]       	pen event
 * RETURNS
 *  void.
 *****************************************************************************/
static void gui_inline_pen_type_handler(
				fixed_list_menu *m,
				gui_inline_pen_event *event)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (wgui_inline_pen_handler_type == WGUI_INLINE_PEN_HANDLER_WAIT_LONGPRESS)
    {
        gui_wait_longpress_enum w;
        
        w = gui_pen_wait_longpress(
            event->pen_event,
            event->x,
            event->y);
        if (w == GUI_WAIT_LONGPRESS_INVALID)
        {
            wgui_inline_pen_handler_type = WGUI_INLINE_PEN_HANDLER_NONE;
        }
        else if (w == GUI_WAIT_LONGPRESS_READY)
        {
        #if !defined(__MMI_FTE_SUPPORT__)
            S32 type = wgui_inline_items[wgui_inline_item_highlighted_index].flags & INLINE_ITEM_TYPE_MASK;
        #endif
            
            *(event->inline_event) = GUI_INLINE_PEN_ITEM_SELECTED;
        #if !defined(__MMI_FTE_SUPPORT__)
            if (type == INLINE_ITEM_TYPE_FULL_SCREEN_EDIT)
            {
                if (g_inline_lsk_functions)
                {
                    g_inline_lsk_functions();
                    *(event->inline_event) = GUI_INLINE_PEN_NONE;
                }
            }
            else
            {
                if (wgui_inline_list_menu_rsk_back && g_inline_lsk_functions)
                {
                    g_inline_lsk_functions();
                    *(event->inline_event) = GUI_INLINE_PEN_NONE;
                }
            }
        #endif 
            /* ignore subsequent pen events */
            wgui_inline_pen_handler_type = WGUI_INLINE_PEN_HANDLER_NONE;
        }		
    }
    else if (wgui_inline_pen_handler_type == WGUI_INLINE_PEN_HANDLER_CURRENT_ITEM)
    {
        gui_inline_handle_pen_event_by_item(
            (U16)wgui_inline_pen_down_item_index, 
            event->pen_event, 
            event->x, 
            event->y, 
            event->inline_event);
    }
    else if (wgui_inline_pen_handler_type == WGUI_INLINE_PEN_HANDLER_FULLSCREEN_EDITOR)
    {
        /* Handled by editor */
    }
    else if (wgui_inline_pen_handler_type == WGUI_INLINE_PEN_HANDLER_SWITCH_ITEM)
    {
        U32 item_type = 0;
        
        item_type = wgui_inline_items[wgui_inline_pen_down_item_index].flags & INLINE_ITEM_TYPE_MASK;
        if (event->pen_event == MMI_PEN_EVENT_UP)
        {
            S32 item_index;
            
            gui_inline_translate_pen_position(m, event->x, event->y, &item_index);
            if ((item_index == wgui_inline_pen_down_item_index)
                || (item_index == wgui_inline_pen_real_down_item_index))
            {
                gdi_layer_lock_frame_buffer();
                complete_inline_item_edit();	/* Finalize current editing */
                /* Automatically select the next item if it's inline caption item */
                inline_fixed_list_goto_item(wgui_inline_pen_down_item_index, MMI_FALSE);
                gdi_layer_unlock_frame_buffer();
                gdi_lcd_repaint_all();					  
            }
        #if defined(__MMI_TOUCH_SCREEN__) && defined (__MMI_INLINE_ITEM_BUTTON__)
            else if (item_type == INLINE_ITEM_TYPE_BUTTON)
            {
                inline_button_item_pen_handler(
                    event->pen_event, 
                    event->x, 
                    event->y, 
                    event->inline_event, 
                    (U16)wgui_inline_pen_down_item_index);
            }
        #endif /* __MMI_TOUCH_SCREEN__ */
        #ifdef __MMI_FTE_SUPPORT__
            else if((item_type == INLINE_ITEM_TYPE_DISPLAY_ONLY)||(item_type == INLINE_ITEM_TYPE_FULL_SCREEN_EDIT))
            {
                inline_fte_displayonly_item_pen_handler(
                    event->pen_event, 
                    event->x, 
                    event->y, 
                    event->inline_event, 
                    (U16)wgui_inline_pen_down_item_index);
            }
        #endif
            wgui_inline_pen_handler_type = WGUI_INLINE_PEN_HANDLER_NONE;
        }
        else if(event->pen_event == MMI_PEN_EVENT_MOVE)
        {
        #if defined(__MMI_FTE_SUPPORT__)
            if((item_type == INLINE_ITEM_TYPE_DISPLAY_ONLY)||(item_type == INLINE_ITEM_TYPE_FULL_SCREEN_EDIT))
            {
                if(inline_fte_displayonly_item_pen_handler(
                    event->pen_event, 
                    event->x, 
                    event->y, 
                    event->inline_event, 
                    (U16)wgui_inline_pen_down_item_index) 
                    == MMI_FALSE )
                {
                    wgui_inline_pen_handler_type = WGUI_INLINE_PEN_HANDLER_NONE;
                }
            }
        #endif /* __MMI_FTE_SUPPORT__ */
        #if defined(__MMI_TOUCH_SCREEN__) && defined (__MMI_INLINE_ITEM_BUTTON__)
            if (item_type == INLINE_ITEM_TYPE_BUTTON)
            {
                if (inline_button_item_pen_handler(
                        event->pen_event, 
                        event->x, 
                        event->y, 
                        event->inline_event, 
                        (U16)wgui_inline_pen_down_item_index) 
                        == FALSE)
                {
                    wgui_inline_pen_handler_type = WGUI_INLINE_PEN_HANDLER_NONE;
                }
            }
        #endif /* __MMI_TOUCH_SCREEN__ */
        }
    }
    else if (wgui_inline_pen_handler_type == WGUI_INLINE_PEN_HANDLER_NONE)
    {
        /* Do nothing */
    }
}
				


/*****************************************************************************
 * FUNCTION
 *  gui_inline_pen_down_handler
 * DESCRIPTION
 *  pen down handler
 *  
 * PARAMETERS
 *  m               		[IN]        		fixed list menu object
 *  item_index               	[IN]          	item index
 *  event		      		[OUT]       	pen event
 * RETURNS
 *  void.
 *****************************************************************************/
static void gui_inline_pen_down_handler(
				fixed_list_menu *m,
				U16 item_index,
				gui_inline_pen_event *event)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 item_type = wgui_inline_items[item_index].flags & INLINE_ITEM_TYPE_MASK;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (item_index != m->highlighted_item)
    {
        if (!(wgui_inline_items[item_index].flags & INLINE_ITEM_DISABLED))
        {
            wgui_inline_pen_handler_type = WGUI_INLINE_PEN_HANDLER_SWITCH_ITEM;
        #if defined(__MMI_TOUCH_SCREEN__) && defined(__MMI_INLINE_ITEM_BUTTON__)
            if ((item_type == INLINE_ITEM_TYPE_BUTTON) && (item_index >= m->first_displayed_item))
            {
                inline_button_item_pen_handler(
                    MMI_PEN_EVENT_DOWN,
                    event->x,
                    event->y,
                    event->inline_event,
                    item_index);
            }
        #endif /* __MMI_TOUCH_SCREEN__ */
        #ifdef __MMI_FTE_SUPPORT__
            if(((item_type == INLINE_ITEM_TYPE_DISPLAY_ONLY) || (item_type == INLINE_ITEM_TYPE_FULL_SCREEN_EDIT))
                && (item_index >= m->first_displayed_item))
            {
                inline_fte_displayonly_item_pen_handler(
                    MMI_PEN_EVENT_DOWN,
                    event->x,
                    event->y,
                    event->inline_event,
                    item_index);
            }
            if((wgui_inline_items[m->highlighted_item].flags & INLINE_ITEM_TYPE_MASK) == INLINE_ITEM_TYPE_MULTI_LINE_RD_ONLY)
            {
                mmi_pen_point_struct point = {0, 0};
                gui_input_box_ssp_pen_translate(point, MMI_PEN_EVENT_ABORT);
            }
        #endif
        }
        else
        {
            wgui_inline_pen_handler_type = WGUI_INLINE_PEN_HANDLER_NONE;
        }
    }
    else
    {
        if (gui_inline_handle_pen_event_by_item(
                (U16)item_index, 
                MMI_PEN_EVENT_DOWN, 
                event->x, 
                event->y, 
                event->inline_event))
        {
            wgui_inline_pen_handler_type = WGUI_INLINE_PEN_HANDLER_CURRENT_ITEM;
        }
        else
        {
            /*
            * After long press animation, invoke left softkey handler. 
            * * Tricky: it only apply to certain inline item types.
            */
            S32 type = wgui_inline_items[wgui_inline_item_highlighted_index].flags & INLINE_ITEM_TYPE_MASK;
            
            if ((
            #ifndef __MMI_FTE_SUPPORT__                            
                type == INLINE_ITEM_TYPE_FULL_SCREEN_EDIT ||
                type == INLINE_ITEM_TYPE_DISPLAY_ONLY ||
                type == INLINE_ITEM_TYPE_MULTI_LINE_RD_ONLY|| 
                type == INLINE_ITEM_TYPE_BUTTON ||
            #endif      
                type == INLINE_ITEM_IMAGE_TEXT_TYPE ) &&
                ((get_softkey_label(MMI_LEFT_SOFTKEY) != NULL) || (get_softkey_icon(MMI_LEFT_SOFTKEY) != NULL))  
            )
            {
                gui_wait_longpress_enum w;
                
                w = gui_pen_wait_longpress(MMI_PEN_EVENT_DOWN, event->x, event->y);
                if (w == GUI_WAIT_LONGPRESS_INVALID)
                {
                    wgui_inline_pen_handler_type = WGUI_INLINE_PEN_HANDLER_NONE;
                }
                else
                {
                    wgui_inline_pen_handler_type = WGUI_INLINE_PEN_HANDLER_WAIT_LONGPRESS;
                }
            }
            else
            {
                wgui_inline_pen_handler_type = WGUI_INLINE_PEN_HANDLER_NONE;
            }
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  gui_inline_translate_pen_event
 * DESCRIPTION
 *  translate pen event of inline edit
 * PARAMETERS
 *  m                   [IN]       fixed list menu pointer  
 *  pen_event           [IN]       pen event 
 *  x                   [IN]       pen x position  
 *  y                   [IN]       pen y position 
 *  inline_event        [IN]       inline pen enum  
 * RETURNS
 *  BOOL
 *****************************************************************************/
BOOL gui_inline_translate_pen_event(
        fixed_list_menu *m,
        mmi_pen_event_type_enum pen_event,
        S16 x,
        S16 y,
        gui_inline_pen_enum *inline_event)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#if defined(GUI_EDITOR_SHOW_TITLE)
    S32 ix, iy, width, height;
#endif /* defined(GUI_EDITOR_SHOW_TITLE) */
    BOOL ret = MMI_TRUE;
    gui_scrollbar_pen_enum scrollbar_event;
    gui_pen_event_param_struct scrollbar_param;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    *inline_event = GUI_INLINE_PEN_NONE;
    
    if (pen_event == MMI_PEN_EVENT_DOWN)
    {
        wgui_inline_pen_down_item_index = -1;
        wgui_inline_pen_real_down_item_index = -1;
        
        
    #if defined(GUI_EDITOR_SHOW_TITLE)    
        if (wgui_current_inline_item_type == INLINE_ITEM_TYPE_FULL_SCREEN_EDIT)
        {
            wgui_title_get_area(&ix, &iy, &width, &height);
            
            if (PEN_CHECK_BOUND(x, y, ix, iy, width, height))
            {
                return TRUE;
            }
        }
    #endif /* defined(GUI_EDITOR_SHOW_TITLE) */
        
        
        if (PEN_CHECK_BOUND(x, y, m->x, m->y, m->width, m->height))
        {
            if (wgui_current_inline_item_type == INLINE_ITEM_TYPE_FULL_SCREEN_EDIT)
            {
                /* Redirect pen events to editor */
                wgui_inline_pen_handler_type = WGUI_INLINE_PEN_HANDLER_FULLSCREEN_EDITOR;
                /* Handled by editor */
            }
            else if (!((m->flags & UI_LIST_MENU_DISABLE_SCROLLBAR) ||
                ((m->flags & UI_LIST_MENU_AUTO_DISABLE_SCROLLBAR) &&
                (m->displayed_items >= m->n_items))) &&
                gui_vertical_scrollbar_translate_pen_event(
                &m->vbar,
                pen_event,
                x,
                y,
                &scrollbar_event,
                &scrollbar_param))
            {
                wgui_inline_pen_handler_type = WGUI_INLINE_PEN_HANDLER_SCROLLBAR;
                if (scrollbar_event == GUI_SCROLLBAR_PEN_JUMP_TO_I)
                {
                    gui_inline_scroll_by_pen(
						m, 
						x, 
						y, 
						scrollbar_param._u.i, 
						inline_event, 
						pen_event);
                }
            }
            else
            {
                S32 item_index;
                BOOL is_pen_inside_menu;
                MMI_BOOL is_disable_feedback = MMI_FALSE;
                
                is_pen_inside_menu = gui_inline_translate_pen_position(m, x, y, &item_index);
                
                if (item_index == wgui_inline_item_highlighted_index)
                {
                    if ((wgui_inline_items[wgui_inline_pen_real_down_item_index].flags & 0xff) 
                        == INLINE_ITEM_TYPE_TEXT_EDIT)
                    {
                        is_disable_feedback = MMI_TRUE;
                    }
                }
                if (gui_inline_pen_get_highlight_index(item_index))
                {
                    return TRUE;
                }
                
                if(is_pen_inside_menu)
                {
                    if(((wgui_inline_items[wgui_inline_pen_real_down_item_index].flags & 0xff) != INLINE_ITEM_TYPE_CAPTION) &&
                        ((wgui_inline_items[wgui_inline_pen_real_down_item_index].flags & INLINE_ITEM_DISABLED) == 0) &&
                        (is_disable_feedback == MMI_FALSE)
                        )
                    {
                        gui_touch_feedback_play(GUI_TOUCH_FEEDBACK_DOWN);
                    }
                }
                gui_touch_feedback_disable_tone();
                gui_touch_feedback_disable_vibrate();
                
                
                if (!is_pen_inside_menu)
                {
                    wgui_inline_pen_handler_type = WGUI_INLINE_PEN_HANDLER_NONE;
                }
                else
                {
                    gui_inline_pen_event event;
                    event.inline_event = inline_event;
                    event.x = x;
                    event.y = y;
                    gui_inline_pen_down_handler(
                        m,
                        item_index,
                        &event);
                }
                gui_touch_feedback_enable_tone();
                gui_touch_feedback_enable_vibrate();
            }
        }
        else
        {
            ret = MMI_FALSE;
        }
    }
    else
    {
        if (!((m->flags & UI_LIST_MENU_DISABLE_SCROLLBAR) ||
            ((m->flags & UI_LIST_MENU_AUTO_DISABLE_SCROLLBAR) &&
            (m->displayed_items >= m->n_items)
            )
            ) && 
            (wgui_inline_pen_handler_type == WGUI_INLINE_PEN_HANDLER_SCROLLBAR)
            )
        {
            gui_vertical_scrollbar_translate_pen_event(&m->vbar, pen_event, x, y, &scrollbar_event, &scrollbar_param);
            if (scrollbar_event == GUI_SCROLLBAR_PEN_JUMP_TO_I)
            {
                if(pen_event != MMI_PEN_EVENT_UP)
                {
                    gui_inline_scroll_by_pen(
						m, 
						x, 
						y, 
						scrollbar_param._u.i, 
						inline_event, 
						pen_event);
                }
            }
        }
        else if(wgui_inline_pen_handler_type == WGUI_INLINE_PEN_HANDLER_SCROLLBAR)
        {
            gui_vertical_scrollbar_translate_pen_event(&m->vbar, pen_event, x, y, &scrollbar_event, &scrollbar_param);	
        }
        else
        {
            gui_inline_pen_event event;
            event.x = x;
            event.y = y;
            event.inline_event = inline_event;
            event.pen_event = pen_event;
            gui_inline_pen_type_handler(m, &event);
        }
    }
    return ret;
}


/*****************************************************************************
* FUNCTION
*  wgui_inline_get_item_height_for_scroll_bar
* DESCRIPTION
*  return item height for scroll bar.
* PARAMETERS
* RETURNS
*  BOOL
*****************************************************************************/
S32 wgui_inline_get_item_height_for_scroll_bar(gui_scrollbar_dir_enum direction)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 iwidth, iheight;
    U8 item_index = 0;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(direction == GUI_SCROLLBAR_DIR_DOWN)
    {
        item_index = MMI_fixed_list_menu.first_displayed_item;   
    }
    else if(direction == GUI_SCROLLBAR_DIR_UP)
    {  
#if defined (__MMI_INLINE_ITEM_MULTILINE_READ_ONLY__)
		if(((wgui_inline_items[MMI_fixed_list_menu.n_items - 1].flags & 0xff) == INLINE_ITEM_TYPE_MULTI_LINE_RD_ONLY) &&
           (MMI_fixed_list_menu.highlighted_item == MMI_fixed_list_menu.n_items - 1)
          )        
        {
            if(MMI_fixed_list_menu.first_displayed_item > 0)
            {
                item_index = MMI_fixed_list_menu.first_displayed_item - 1;
            }
            else
            {
                item_index = MMI_fixed_list_menu.last_displayed_item;
            }
        }
        else
#endif			
        {
            item_index = MMI_fixed_list_menu.last_displayed_item;
        } 
    }
    {
        if (item_index == MMI_fixed_list_menu.highlighted_item)
        {
            MMI_fixed_list_menu.current_displayed_item = -1;
        }
        else
        {
            MMI_fixed_list_menu.current_displayed_item = item_index;
        }
        MMI_fixed_list_menu.item_measure_function(MMI_fixed_list_menu.items[item_index], MMI_fixed_list_menu.common_item_data, &iwidth, &iheight);
    }
    return iheight;
}


#endif /* __MMI_TOUCH_SCREEN__ */ 


/*****************************************************************************
 * FUNCTION
 *  wgui_inputs_sl_inline_handle_right_arrow_repeat
 * DESCRIPTION
 *  handle right arrow key repeat of inline singleline input box
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_inputs_sl_inline_handle_right_arrow_repeat(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_inputs_fast_del_nav_handler(WGUI_INPUTS_OPER_FAST_NAV_RIGHT, WGUI_INPUTS_EDITOR_INLINE_SL, WGUI_INPUTS_KPD_REPEAT_PERIOD);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_inputs_sl_inline_handle_left_arrow_repeat
 * DESCRIPTION
 *  handle left arrow key repeat of inline singleline input box
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_inputs_sl_inline_handle_left_arrow_repeat(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_inputs_fast_del_nav_handler(WGUI_INPUTS_OPER_FAST_NAV_LEFT, WGUI_INPUTS_EDITOR_INLINE_SL, WGUI_INPUTS_KPD_REPEAT_PERIOD);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_inputs_sl_inline_handle_right_softkey_repeat
 * DESCRIPTION
 *  handle right softkey repeat of inline singleline input box
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_inputs_sl_inline_handle_right_softkey_repeat(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (MMI_inline_singleline_inputbox.text_length <= ENCODING_LENGTH)
    {
        return;
    }

    wgui_inputs_fast_del_nav_handler(WGUI_INPUTS_OPER_FAST_DEL, WGUI_INPUTS_EDITOR_INLINE_SL, WGUI_INPUTS_KPD_REPEAT_PERIOD);
    if (MMI_inline_singleline_inputbox.text_length <= ENCODING_LENGTH)
    {
        if (wgui_inline_singleline_inputbox_decimal_input_mode_flag)
        {
            wgui_inline_singleline_inputbox_decimal_flag = 0;
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_inputs_sl_inline_handle_right_softkey_touch_repeat
 * DESCRIPTION
 *  handle right softkey repeat of inline singleline input box (Touch panel RSK)
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_inputs_sl_inline_handle_right_softkey_touch_repeat(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (MMI_inline_singleline_inputbox.text_length <= ENCODING_LENGTH)
    {
        return;
    }

    wgui_inputs_fast_del_nav_handler(WGUI_INPUTS_OPER_FAST_DEL, WGUI_INPUTS_EDITOR_INLINE_SL, WGUI_INPUTS_TP_REPEAT_PERIOD);
    if (MMI_inline_singleline_inputbox.text_length <= ENCODING_LENGTH)
    {
        if (wgui_inline_singleline_inputbox_decimal_input_mode_flag)
        {
            wgui_inline_singleline_inputbox_decimal_flag = 0;
        }
    }
}


void wgui_inline_text_disable_cursor_display(S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    wgui_inline_items[index].flags |= INLINE_ITEM_DISABLE_CURSOR_DISPLAY;
}


void wgui_inline_text_enable_cursor_display(S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_inline_items[index].flags &= ~INLINE_ITEM_DISABLE_CURSOR_DISPLAY;

}


#ifdef __MMI_FTE_SUPPORT__ 
#if defined(__MMI_TOUCH_SCREEN__)
#if defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN)
extern gui_list_smooth_scrolling_by_pen_state_enum g_gui_ssp_state;
#endif /* GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN */

/*****************************************************************************
 * FUNCTION
 *  inline_is_handle_fte_tap
 * DESCRIPTION
 *  handle inline tap behavior
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL inline_is_handle_fte_tap(mmi_tap_type_enum tap_type, U16 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/   
    U32 flags = 0;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    flags = wgui_inline_items[index].flags & INLINE_ITEM_TYPE_MASK;
    if((flags == INLINE_ITEM_TYPE_DISPLAY_ONLY) 
		|| (flags == INLINE_ITEM_TYPE_MULTI_LINE_RD_ONLY)
		|| (flags == INLINE_ITEM_TYPE_BUTTON))
    {
    #if defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN)
        g_gui_ssp_state = GUI_LIST_SMOOTH_SCROLLING_BY_PEN_STATE_UNFOCUS;
    #endif /* GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN */
        if (wgui_inline_list_menu_rsk_back && g_inline_lsk_functions)
        {
            g_inline_lsk_functions();
            return MMI_TRUE;
        }
        return MMI_FALSE;
    }
#if defined (__MMI_INLINE_ITEM_RADIO__)    
    else if (flags == INLINE_ITEM_TYPE_RADIO)
    {
        inline_radio_select_handler();
    }
#endif    
#if defined (__MMI_INLINE_ITEM_CHECKBOX__)    
    else if (flags == INLINE_ITEM_TYPE_CHECKBOX)
    {
        inline_checkbox_lsk_function();
    }
#endif    
    else if(flags == INLINE_ITEM_TYPE_FULL_SCREEN_EDIT)
    {            
        if(complete_inline_item_edit)
        {
            complete_inline_item_edit();   
        }
        
        wgui_inline_items[index].handler(
            wgui_inline_item_x,
            wgui_inline_item_y,
            wgui_inline_item_width,
            wgui_inline_item_height,
            wgui_inline_item_key_code,
            wgui_inline_item_key_event,
            &wgui_inline_items [index].text_p,
            wgui_inline_items[index].item,
            wgui_inline_items[index].flags,
            wgui_current_history_buffer);
        
        wgui_current_history_buffer = NULL;             
    }
    return MMI_TRUE;     
}
#endif /* __MMI_TOUCH_SCREEN__ */


/*****************************************************************************
 * FUNCTION
 *  inline_fte_set_item_height_by_guess
 * DESCRIPTION
 *  set line style when fte.
 * PARAMETERS
 *  flag          [IN]  flag        
 * RETURNS
 *  void
 *****************************************************************************/
void inline_fte_set_item_height_by_guess(InlineItem *list_of_items, S32 number_of_items)
{
 
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/   
    int i;   
    S32 has_caption = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(g_inline_fte_item_height_table, 0, sizeof(g_inline_fte_item_height_table));

    for(i = 0; i < number_of_items; i++)
    {
       if((list_of_items[i].flags & 0xff) == INLINE_ITEM_TYPE_CAPTION)
       {
            has_caption = 1;
            g_inline_fte_item_height_table[i] = INLINE_LINE_STYLE_TWO_LINE;
            continue;
       }
       else if(has_caption == 1)
       {
            g_inline_fte_item_height_table[i] = INLINE_LINE_STYLE_TWO_LINE;
       }
       else if(has_caption == 0)
       {
            g_inline_fte_item_height_table[i] = INLINE_LINE_STYLE_ONE_LINE;
       }
    }    
}


/*****************************************************************************
 * FUNCTION
 *  wgui_inline_stop_scroll_when_ssp
 * DESCRIPTION
 *  Stop scroll when ssp is run.
 * PARAMETERS
 *      
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_inline_stop_scroll_when_ssp(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(((wgui_inline_items[wgui_inline_item_highlighted_index].flags & 0xff) == INLINE_ITEM_TYPE_DISPLAY_ONLY) ||
       ((wgui_inline_items[wgui_inline_item_highlighted_index].flags & 0xff) == INLINE_ITEM_TYPE_FULL_SCREEN_EDIT)
      )
    {
       wgui_inline_display_only_close(); 
    }
    
}

/*****************************************************************************
 * FUNCTION
 *  wgui_inline_stop_scroll
 * DESCRIPTION
 *  Stop scroll when .
 * PARAMETERS
 *      
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_inline_stop_scroll(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(((wgui_inline_items[wgui_inline_item_highlighted_index].flags & 0xff) == INLINE_ITEM_TYPE_DISPLAY_ONLY) ||
        ((wgui_inline_items[wgui_inline_item_highlighted_index].flags & 0xff) == INLINE_ITEM_TYPE_FULL_SCREEN_EDIT)
        )
    {
        gui_scrolling_text_stop(&wgui_inline_scroll_text);
        memset(&wgui_inline_scroll_text, 0, sizeof(wgui_inline_scroll_text));
    }
}

/*****************************************************************************
 * FUNCTION
 *  wgui_inline_stop_scroll
 * DESCRIPTION
 *  Stop scroll when .
 * PARAMETERS
 *      
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_inline_start_scroll(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(((wgui_inline_items[wgui_inline_item_highlighted_index].flags & 0xff) == INLINE_ITEM_TYPE_DISPLAY_ONLY) ||
        ((wgui_inline_items[wgui_inline_item_highlighted_index].flags & 0xff) == INLINE_ITEM_TYPE_FULL_SCREEN_EDIT)
        )
    {
        wgui_inline_item_text_edit * i = wgui_inline_items[wgui_inline_item_highlighted_index].item;
         wgui_show_inline_fte_displayonly_item_highlight_ext(i->x, i->y, 
                        i->width, i->height, 
                        &wgui_inline_items[wgui_inline_item_highlighted_index], 
                        0);     
    }
}

/*****************************************************************************
 * FUNCTION
 *  wgui_inline_brush_item_background
 * DESCRIPTION
 *  Brush background for input editor item .
 * PARAMETERS
 *      
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_inline_brush_item_background(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_fill_rectangle(x1, y1, x2, y2, (gui_color(0, 0, 255)));   
}

#endif


/*****************************************************************************
* FUNCTION
 *  inline_fte_set_item_show_as_display_only
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 * 
 *****************************************************************************/
void wgui_inline_fte_set_item_show_as_display_only(wgui_inline_item *inline_item)
{
#ifdef __MMI_FTE_SUPPORT__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(((inline_item->flags & 0xff) == INLINE_ITEM_TYPE_DISPLAY_ONLY) ||
       ((inline_item->flags & 0xff) == INLINE_ITEM_TYPE_FULL_SCREEN_EDIT))
    {
        inline_item->flags |= INLINE_ITEM_DISPLAY_ONLY_SHOW;
    }
#endif

}

/*****************************************************************************
* FUNCTION
 *  wgui_inline_fte_reset_item_show_as_display_only
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 * 
 *****************************************************************************/
void wgui_inline_fte_reset_item_show_as_display_only(wgui_inline_item *inline_item)
{
#ifdef __MMI_FTE_SUPPORT__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(((inline_item->flags & 0xff) == INLINE_ITEM_TYPE_DISPLAY_ONLY) ||
       ((inline_item->flags & 0xff) == INLINE_ITEM_TYPE_FULL_SCREEN_EDIT))
    {
        inline_item->flags &= ~INLINE_ITEM_DISPLAY_ONLY_SHOW;
    }
#endif

}


#ifdef __MMI_CLIPBOARD__
/*****************************************************************************
* FUNCTION
*  wgui_inline_sl_insert_string
* DESCRIPTION
*  Insert string at current cursor position.
* PARAMETERS
* str           [in]        string to insert
* len           [in]        string length
* is_redraw     [in]        if need redraw after insert        
* RETURNS
*  characters inserted
*****************************************************************************/
U32 wgui_inline_sl_insert_string(UI_string_type str, U32 len, MMI_BOOL is_redraw)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 i, total_len = 0;
    U32 old_show_action_flag;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    old_show_action_flag = MMI_inline_singleline_inputbox.show_action_flag;
    MMI_inline_singleline_inputbox.show_action_flag = 0;
    for (i = 0; i < len; i++)
    {
        if (MMI_TRUE == wgui_inputs_is_input_char_valid((UI_character_type)str[i]))
        {
            if (((UI_character_type)str[i] == 0x0D) || ((UI_character_type)str[i] == 0x1b))
            {
                continue;
            }
            else if (MMI_TRUE == inline_edit_singleline_inputbox_direct_input_no_draw((UI_character_type)str[i]))
            {
                total_len ++;
            }
            else
            {
                break;
            }
        }
        else
        {
            UI_editor_play_tone_cannot_insert();
            break;
        }
    }
    MMI_inline_singleline_inputbox.show_action_flag = old_show_action_flag;

    gui_single_line_input_box_locate_cursor(&MMI_inline_singleline_inputbox);
    if (is_redraw)
    {
        redraw_inline_singleline_inputbox();
    }

    if (total_len >0)
    {
        inline_singleline_inputbox_input_callback();
    }

    return total_len;
}
#endif
mmi_ret wgui_inline_proc_post_event(mmi_event_struct* param)
{
	/*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	
	/*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(param->evt_id == EVT_ID_INLINE_IMAGETEXT_PEN_UP)
    {
        FuncPtr func = (FuncPtr)param->user_data;
        if(func)
        {
            func();
        }
    }
	return MMI_RET_OK;
}

#if defined (__MMI_INLINE_ITEM_PROGRESS_BAR__)
/***************************************************************************** 
 * Progress bar Control Integration in Inline control   
 *****************************************************************************/
#define MAX_INLINE_PROGRESS_BAR_STRING_SIZE  12

gui_progress_bar_struct* pbar;

gui_progress_bar_theme_struct wgui_inline_progress_bar_focussed_theme;
gui_progress_bar_theme_struct wgui_inline_progress_bar_unfocussed_theme;

UI_filled_area _inline_progress_bar_highlight_bg_defaultTheme={
    UI_FILLED_AREA_TYPE_BITMAP,
    UI_IMAGE_ID_NULL,
    NULL,
    {255, 255, 255, 100},
    {0,0,0,100},
    {0,0,0,100},
    {0,0,0,100},
    0};
    
UI_filled_area _inline_progress_bar_normal_bg_defaultTheme={
    UI_FILLED_AREA_TYPE_BITMAP,
    UI_IMAGE_ID_NULL,
    NULL,
    {255, 255, 255, 100},
    {0, 0, 0, 100},
    {0, 0, 0, 100},
    {0,0,0,100},
    0};  

UI_filled_area _inline_progress_bar_button_up_defaultTheme={
    UI_FILLED_AREA_TYPE_BITMAP,
    UI_IMAGE_ID_NULL,
    NULL,
    {255, 255, 255, 100},
    {0, 0, 0, 100},
    {0, 0, 0, 100},
    {0,0,0,100},
    0};


/*****************************************************************************
 * FUNCTION
 *  wgui_inline_set_focussed_progress_bar_theme
 * DESCRIPTION
 *  Set progress bar focussed theme.
 * PARAMETERS     
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_inline_set_focussed_progress_bar_theme()
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	
	/*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifndef __MMI_FTE_SUPPORT__    
    wgui_inline_progress_bar_focussed_theme.background_filler = current_MMI_theme->inline_item_progress_bar_highlight_bg_filler;
    wgui_inline_progress_bar_focussed_theme.normal_progress_filler= current_MMI_theme->inline_item_progress_bar_normal_progress_filler;
    wgui_inline_progress_bar_focussed_theme.step_filler= current_MMI_theme->inline_item_progress_bar_step_filler;
    wgui_inline_progress_bar_focussed_theme.button_up_filler= current_MMI_theme->inline_item_progress_bar_button_normal_filler;
    wgui_inline_progress_bar_focussed_theme.button_press_filler= current_MMI_theme->inline_item_progress_bar_button_pressed_filler;
    wgui_inline_progress_bar_focussed_theme.text_color = *(current_MMI_theme->inline_item_progress_bar_text_color);
#else
    wgui_inline_progress_bar_focussed_theme.background_filler = &_inline_progress_bar_highlight_bg_defaultTheme;
    wgui_inline_progress_bar_focussed_theme.background_filler->b = current_MMI_theme->slide_bar_focused_bg_image;
    wgui_inline_progress_bar_focussed_theme.background_filler->flags = UI_FILLED_AREA_TYPE_BITMAP;
    
    wgui_inline_progress_bar_focussed_theme.button_up_filler = &_inline_progress_bar_button_up_defaultTheme;
    wgui_inline_progress_bar_focussed_theme.button_up_filler->b = current_MMI_theme->slide_bar_indicator_image;
    wgui_inline_progress_bar_focussed_theme.button_up_filler->flags = UI_FILLED_AREA_TYPE_BITMAP;
#endif
   
}

/*****************************************************************************
 * FUNCTION
 *  wgui_inline_set_focussed_progress_bar_theme
 * DESCRIPTION
 *  Set progress bar focussed theme.
 * PARAMETERS     
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_inline_set_unfocussed_progress_bar_theme()
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	
	/*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifndef __MMI_FTE_SUPPORT__
    wgui_inline_progress_bar_unfocussed_theme.background_filler = current_MMI_theme->inline_item_progress_bar_unhighlight_bg_filler;
    wgui_inline_progress_bar_unfocussed_theme.normal_progress_filler= current_MMI_theme->inline_item_progress_bar_normal_progress_filler;
    wgui_inline_progress_bar_unfocussed_theme.step_filler= current_MMI_theme->inline_item_progress_bar_step_filler;
    wgui_inline_progress_bar_unfocussed_theme.button_up_filler= current_MMI_theme->inline_item_progress_bar_button_normal_filler;
    wgui_inline_progress_bar_unfocussed_theme.button_press_filler= current_MMI_theme->inline_item_progress_bar_button_pressed_filler;
    wgui_inline_progress_bar_unfocussed_theme.text_color= *(current_MMI_theme->inline_item_progress_bar_text_color);
#else
    wgui_inline_progress_bar_unfocussed_theme.background_filler = &_inline_progress_bar_normal_bg_defaultTheme;
    wgui_inline_progress_bar_unfocussed_theme.background_filler->b = current_MMI_theme->slide_bar_background_image;
    wgui_inline_progress_bar_unfocussed_theme.background_filler->flags = UI_FILLED_AREA_TYPE_BITMAP;

    wgui_inline_progress_bar_unfocussed_theme.button_up_filler = &_inline_progress_bar_button_up_defaultTheme;
    wgui_inline_progress_bar_unfocussed_theme.button_up_filler->b = current_MMI_theme->slide_bar_indicator_image;
    wgui_inline_progress_bar_unfocussed_theme.button_up_filler->flags = UI_FILLED_AREA_TYPE_BITMAP;
#endif

}


/*****************************************************************************
 * FUNCTION
 *  redraw_progress_bar_control
 * DESCRIPTION
 *  redraw progress bar control
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void redraw_progress_bar_control(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();
    wgui_progress_bar_draw(pbar);
    gdi_layer_unlock_frame_buffer();
    gdi_layer_blt_previous(
        pbar->x,
        pbar->y,
        pbar->x + pbar->width - 1,
        pbar->y + pbar->height - 1);
}

#ifdef __MMI_TOUCH_SCREEN__

#if defined(__MMI_FTE_SUPPORT__) && defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN)
extern gui_list_smooth_scrolling_by_pen_state_enum g_gui_ssp_state;
#endif

/*****************************************************************************
 * FUNCTION
 *  inline_progress_bar_pen_handler
 * DESCRIPTION
 *  pen handler of inline image text
 * PARAMETERS
 *  pen_event       [IN]    pen event    
 *  x               [IN]    pen x position    
 *  y               [IN]    pen y position    
 *  item_event      [IN]    inline pen enum     
 * RETURNS
 *  ret
 *****************************************************************************/
BOOL inline_progress_bar_pen_handler(
        mmi_pen_event_type_enum pen_event,
        S16 x,
        S16 y,
        gui_inline_item_pen_enum *item_event)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL res = MMI_TRUE;
    U16 old_value = 0;
    static int down_y = -1;
    static S32 reset_pre_hdlr = 0;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
   
    old_value = *(pbar->value);
	*item_event = GUI_INLINE_ITEM_PEN_NONE;
    
    res = (MMI_BOOL)wgui_progress_bar_pen_handler(pbar, pen_event, x, y);
    
#if defined(__MMI_FTE_SUPPORT__) && defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN)
    if(res != MMI_FALSE)
    {
    switch (pen_event)
    {
        case MMI_PEN_EVENT_DOWN:
            if(reset_pre_hdlr == 0)
            {
                wgui_pen_reset_pre_hdlr();
                reset_pre_hdlr = 1;
            }
            down_y = y;
            break;
            default:
                /* ignored events */
                break;
        }
    }
    switch (pen_event)
    {
        case MMI_PEN_EVENT_MOVE:
        {
            if((down_y != -1) && (((down_y - y) > MMI_INLINE_PROGRESS_BAR_Y_OFFSET_TO_SSP) || ((down_y - y) < -MMI_INLINE_PROGRESS_BAR_Y_OFFSET_TO_SSP)))
            {
                if(reset_pre_hdlr == 1)
                {
               wgui_pen_restore_pre_hdlr(); 
                    reset_pre_hdlr = 0;
                }
            }
            break;
        }
        case MMI_PEN_EVENT_UP:
        case MMI_PEN_EVENT_ABORT:
            g_gui_ssp_state = GUI_LIST_SMOOTH_SCROLLING_BY_PEN_STATE_UNFOCUS;
            if(reset_pre_hdlr == 1)
            {
                wgui_pen_restore_pre_hdlr();
                reset_pre_hdlr = 0;
            }
            down_y = -1;
            break; 
    }
#endif
    if(old_value != *(pbar->value))
    {
        redraw_progress_bar_control();
        set_wgui_inline_list_menu_changed();
    }
    return res;
}
#endif

/*****************************************************************************
 * FUNCTION
 *  inline_progress_bar_decrement
 * DESCRIPTION
 *  Decrements the progress bar value
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void inline_progress_bar_decrement(void)
{
    if( (*pbar->value) - pbar->step_size >= 0 )
    {
        wgui_progress_bar_decrement(pbar);
        wgui_progress_bar_draw(pbar);
        set_wgui_inline_list_menu_changed();
    }
}

/*****************************************************************************
 * FUNCTION
 *  inline_progress_bar_increment
 * DESCRIPTION
 *  Increment the progress bar value
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void inline_progress_bar_increment(void)
{
    if( (*pbar->value) + pbar->step_size <= pbar->max_value )
    {
        wgui_progress_bar_increment(pbar);
        wgui_progress_bar_draw(pbar);
        set_wgui_inline_list_menu_changed();
    }

}
/*****************************************************************************
 * FUNCTION
 *  register_inline_progress_bar_keys
 * DESCRIPTION
 *  register key handlers for progress bar
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void register_inline_progress_bar_keys(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    SetKeyHandler(inline_progress_bar_decrement, KEY_LEFT_ARROW, KEY_EVENT_DOWN);
    SetKeyHandler(inline_progress_bar_increment, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
    SetKeyHandler(inline_progress_bar_increment, KEY_VOL_UP, KEY_EVENT_DOWN);
    SetKeyHandler(inline_progress_bar_decrement, KEY_VOL_DOWN, KEY_EVENT_DOWN);

    SetKeyHandler(inline_progress_bar_decrement, KEY_LEFT_ARROW, KEY_REPEAT);
    SetKeyHandler(inline_progress_bar_increment, KEY_RIGHT_ARROW, KEY_REPEAT);
    SetKeyHandler(inline_progress_bar_increment, KEY_VOL_UP, KEY_REPEAT);
    SetKeyHandler(inline_progress_bar_decrement, KEY_VOL_DOWN, KEY_REPEAT);
}

/*****************************************************************************
 * FUNCTION
 *  clear_inline_progress_bar_key_handlers
 * DESCRIPTION
 *  register key handlers for progress bar
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void clear_inline_progress_bar_key_handlers(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ClearKeyHandler(KEY_LEFT_ARROW, KEY_EVENT_DOWN);
    ClearKeyHandler(KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
    ClearKeyHandler(KEY_VOL_UP, KEY_EVENT_DOWN);
    ClearKeyHandler(KEY_VOL_DOWN, KEY_EVENT_DOWN);

    ClearKeyHandler(KEY_LEFT_ARROW, KEY_REPEAT);
    ClearKeyHandler(KEY_RIGHT_ARROW, KEY_REPEAT);
    ClearKeyHandler(KEY_VOL_UP, KEY_REPEAT);
    ClearKeyHandler(KEY_VOL_DOWN, KEY_REPEAT);

    clear_keyboard_key_handler();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_show_inline_progress_bar_list_menuitem
 * DESCRIPTION
 *  Displaying inline text edit as a menu item in the fixed list menu
 * PARAMETERS
 *  x1          [IN]        x
 *  y1          [IN]        y
 *  width       [IN]        width
 *  height      [IN]        height
 *  item        [IN]        inline item         
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_show_inline_progress_bar_list_menuitem(S32 x1, S32 y1, S32 width, S32 height, wgui_inline_item *item)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_inline_item_progress_bar *i = (wgui_inline_item_progress_bar*) item->item;
    gui_progress_bar_struct progress_bar_display = {0};
    S32 xx = x1;
    S32 control_width = width;
    gui_progress_bar_theme_struct display_theme = {0};
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(mmi_fe_get_r2l_state())
    {
        xx = x1;
        if(!(item->flags & INLINE_ITEM_LEFT_ALIGN))
        {
            control_width = width - MMI_fixed_icontext_menuitem.text_x;
        }
        else
        {
            control_width = width;
        }
    }
    else
    {
        if(!(item->flags & INLINE_ITEM_LEFT_ALIGN))
        {
            xx = x1 + MMI_fixed_icontext_menuitem.text_x - 1; 
            control_width = width - MMI_fixed_icontext_menuitem.text_x;
        }
        else
        {
            xx = x1;
            control_width = width;
        }      
    }
    /* Create progress bar */
    wgui_progress_bar_create(&progress_bar_display, (U16)xx, (U16)y1, (U16)control_width, (U16)height, i->max_value, i->step_size, i->value);

    /* Set divided in case application needs divided one */
    if(i->flags & INLINE_PBAR_DIVIDED)
    {
        wgui_progress_bar_set_type_divided(&progress_bar_display);
    }
    /* Set show string in case required */
    if(i->flags & INLINE_PBAR_SHOW_STRING)
    {
        wgui_progress_bar_set_display_string(&progress_bar_display);
        
    }
    if(i->flags & INLINE_PBAR_SHOW_STRING_PERCENTAGE)
    {
        wgui_progress_bar_set_display_string_percentage(&progress_bar_display);
    }
    
    gui_get_progress_bar_theme(&progress_bar_display, &display_theme);
    gui_set_progress_bar_theme(&progress_bar_display, &wgui_inline_progress_bar_unfocussed_theme);
    wgui_progress_bar_draw(&progress_bar_display);
    gui_set_progress_bar_theme(&progress_bar_display, &display_theme);
    
    
}


/*****************************************************************************
 * FUNCTION
 *  inline_select_menu_change_complete
 * DESCRIPTION
 *  change complete function for inline select menu
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_inline_progress_bar_complete(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    clear_inline_progress_bar_key_handlers();
    complete_inline_item_edit = UI_dummy_function;
    redraw_current_inline_item = UI_dummy_function;
#ifdef __MMI_TOUCH_SCREEN__
    wgui_current_inline_item_pen_function = UI_dummy_inline_item_pen_function;
#endif    
      
}


/*****************************************************************************
 * FUNCTION
 *  handle_inline_progress_bar
 * DESCRIPTION
 *  activation function of inline user defined select
 * PARAMETERS
 *  x                   [IN]        left corner's x coordinate
 *  y                   [IN]        left corner's y coordinate
 *  width               [IN]        width
 *  height              [IN]        height
 *  key_code            [IN]        key code
 *  key_event           [IN]        key event
 *  text_p              [IN]        text pointer
 *  item                [IN]        inline item
 *  flags               [IN]        flags
 *  history_buffer      [IN]        history buffer           
 * RETURNS
 *  void
 *****************************************************************************/
void handle_inline_progress_bar(
        S32 x,
        S32 y,
        S32 width,
        S32 height,
        S32 key_code,
        S32 key_event,
        U8 **text_p,
        void *item,
        U32 flags,
        U8 *history_buffer)
{
    wgui_inline_item_progress_bar* i;
    S32 xx = x;
    S32 control_width = width;
    i = (wgui_inline_item_progress_bar*) item;

    redraw_current_inline_item = redraw_progress_bar_control;
#ifdef __MMI_TOUCH_SCREEN__
    wgui_current_inline_item_pen_function = inline_progress_bar_pen_handler;
#endif 
    /* Assign the global pointer to the selected control */
    pbar = &i->pbar;

    if(mmi_fe_get_r2l_state())
    {
        xx = x;
        if(!(flags & INLINE_ITEM_LEFT_ALIGN))
        {
            control_width = width - MMI_fixed_icontext_menuitem.text_x;
        }
        else
        {
            control_width = width;
        }
    }
    else
    {
        if(!(flags & INLINE_ITEM_LEFT_ALIGN))
        {
            xx = x + MMI_fixed_icontext_menuitem.text_x - 1; 
            control_width = width - MMI_fixed_icontext_menuitem.text_x;
        }
        else
        {
            xx = x;
            control_width = width;
        }      
    }
    /* Create progress bar */
    wgui_progress_bar_create(pbar, (U16)xx, (U16)y, (U16)control_width, (U16)height, i->max_value, i->step_size, i->value);
    /* Clear the key handlers */
    clear_inline_progress_bar_key_handlers();
    if(!(i->flags & INLINE_PBAR_READ_ONLY))
    {
        /* Register keys */
        register_inline_progress_bar_keys(); 
    }
    /* Set divided in case application needs divided one */
    if(i->flags & INLINE_PBAR_DIVIDED)
    {
        wgui_progress_bar_set_type_divided(pbar);
    }
    /* Set show string in case required */
    if(i->flags & INLINE_PBAR_SHOW_STRING)
    {
        wgui_progress_bar_set_display_string(pbar);
        
    }
    if(i->flags & INLINE_PBAR_SHOW_STRING_PERCENTAGE)
    {
        wgui_progress_bar_set_display_string_percentage(pbar);
    }
    gui_set_progress_bar_theme(pbar, &wgui_inline_progress_bar_focussed_theme);
    wgui_progress_bar_register_change_listener(pbar, i->callback);
    wgui_progress_bar_draw(pbar);

    complete_inline_item_edit = wgui_inline_progress_bar_complete;
    redraw_current_inline_item = redraw_progress_bar_control;
#ifdef __MMI_TOUCH_SCREEN__
    wgui_current_inline_item_pen_function = inline_progress_bar_pen_handler;
#endif 

}


/*****************************************************************************
 * FUNCTION
 *  SetInlineItemProgressBar
 * DESCRIPTION
 *  set data for inline time edit
 * PARAMETERS
 *  item                [IN]       inline item         
 *  funcptr             [IN]       Callback function from App
 *  value               [IN]       value pointer      
 *  max_value           [IN]       max_value of control
 *  step_size           [IN]       step size
 * RETURNS
 *  void
 *****************************************************************************/
void SetInlineItemProgressBar(InlineItem *item, void(*funcptr)(void), U16* value, U16 max_value, U16 step_size)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_inline_item_progress_bar* i;
    U8 str[20];
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_inline_mem_alloc_info[wgui_inline_mem_alloc_number] = item->item = wgui_inline_malloc(sizeof(wgui_inline_item_progress_bar));
    wgui_inline_mem_alloc_number++;
    wgui_inline_mem_alloc_info[wgui_inline_mem_alloc_number] = item->text_p = (U8*)wgui_inline_malloc(MAX_INLINE_PROGRESS_BAR_STRING_SIZE * sizeof(U8));
    wgui_inline_mem_alloc_number++;  
    item->flags = INLINE_ITEM_TYPE_PROGRESS_BAR;
    item->flags |= INLINE_ITEM_DISABLE_HIGHLIGHT;
    i = (wgui_inline_item_progress_bar*) item->item;
    i->callback = funcptr;
    i->value = value;
    i->max_value = max_value;
    i->step_size = step_size;
    sprintf((PS8) str, "%d", *value);
    mmi_asc_to_ucs2((S8*) i->pbar.string, (S8*) str);
    item->text_p = i->pbar.string;
#if defined (__MMI_INLINE_ITEM_TIME__)
    n_inline_time_items++;
#endif /* __MMI_INLINE_ITEM_TIME__ */
    item->handler = handle_inline_progress_bar;
}

/*****************************************************************************
 * FUNCTION
 *  SetInlineItemProgressBarStyle
 * DESCRIPTION
 *  set Progress bar style
 * PARAMETERS
 *  item                [IN]       inline item         
 *  flags               [IN]       flags
 * RETURNS
 *  void
 *****************************************************************************/
void SetInlineItemProgressBarStyle(InlineItem *item, U32 flags)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_inline_item_progress_bar* i;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    i = (wgui_inline_item_progress_bar*) item->item;
    i->flags |= flags;
    if(flags & INLINE_PBAR_SHOW_STRING_PERCENTAGE)
    {
        U8 str[20];
        sprintf((PS8)str, "%d %%", *(i->value));
        mmi_asc_to_ucs2((S8*) i->pbar.string, (S8*) str);
        item->text_p = i->pbar.string;
    }
}

#endif /*  __MMI_INLINE_ITEM_PROGRESS_BAR__ */

#ifdef __MMI_FTE_SUPPORT__

/*****************************************************************************
* FUNCTION
*  wgui_inline_get_vk_status
* DESCRIPTION
*  Get current vk status.
* PARAMETERS
* RETURNS
*  characters inserted
*****************************************************************************/
void wgui_inline_get_vk_status(U8 *vk_status)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	
	/*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    *vk_status = mmi_imc_get_ui_style(MMI_IMC_UI_STYLE_VK_ON);
}

/*****************************************************************************
* FUNCTION
*  wgui_inline_set_vk_status
* DESCRIPTION
*  Set current vk status.
* PARAMETERS
* RETURNS
*  characters inserted
*****************************************************************************/
void wgui_inline_set_vk_status(U8 vk_status)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	
	/*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(vk_status)
    {
        mmi_imc_set_vk_present(MMI_IMC_VK_DEFAULT_ENLARGE); 
    }
    else
    {
        mmi_imc_set_vk_present(MMI_IMC_VK_PRESENT_DEFAULT); 
    }
}

#endif


/*****************************************************************************
 * FUNCTION
 *  cui_inline_option_menu_done_lsk_handler
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_inline_option_menu_done_lsk_handler(mmi_id menu_gid)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if(UI_DOUBLE_BUFFER_SUPPORT)
    gui_lock_double_buffer();
#endif 
    if ((current_wgui_inline_item == NULL) || (wgui_n_inline_items <= 0))
    {
        cui_menu_close(menu_gid);
    }
    handle_inline_full_screen_edit_complete();
#if(UI_DOUBLE_BUFFER_SUPPORT)
    gui_unlock_double_buffer();
    gui_BLT_double_buffer(0, 0, UI_device_width - 1, UI_device_height - 1);
#endif /* (UI_DOUBLE_BUFFER_SUPPORT) */ 
}


/*****************************************************************************
 * FUNCTION
 *  cui_inline_proc_func
 * DESCRIPTION
 *  Process option menu event
 * PARAMETERS
 *  item_type      [IN]        item type
 * RETURNS
 *  void
 *****************************************************************************/
mmi_ret wgui_inine_option_group_proc(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/  
    cui_menu_event_struct *menu_evt = (cui_menu_event_struct*)evt;
    
    switch (menu_evt->evt_id)
    {   
        case EVT_ID_CUI_MENU_ITEM_SELECT:
        {
            if (menu_evt->highlighted_menu_id == MENU_ID_INLINE_EDITOR_OPT_DONE)
            {
                wgui_inline_option_menu_done_lsk_handler(menu_evt->sender_id);               
            }
            break;
        }
        case EVT_ID_CUI_MENU_CLOSE_REQUEST:
        {           
            cui_menu_close(menu_evt->sender_id);
            break;
        }
    }

    wgui_inputs_options_menu_handler(evt, (mmi_id)(U32)menu_evt->app_data); // app_id is menu cuis parent groupd ID

    return 0;
}



/*****************************************************************************
 * FUNCTION
 *  EntryScrForInputMethodAndDone
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryScrForInputMethodAndDone(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    mmi_id option_menu_gid;
    mmi_id inline_gid;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
     inline_gid = mmi_frm_group_create(
            GRP_ID_ROOT, GRP_ID_AUTO_GEN,
            wgui_inine_option_group_proc, (void*)NULL); 
    mmi_frm_group_enter(inline_gid, MMI_FRM_NODE_SMART_CLOSE_FLAG);

    option_menu_gid = cui_menu_create(inline_gid,
        CUI_MENU_SRC_TYPE_RESOURCE,
        CUI_MENU_TYPE_OPTION,
        MENU_ID_INLINE_EDITOR_OPT,
        MMI_TRUE, (void *)(U32)inline_gid);
    cui_menu_run(option_menu_gid);
}

/*****************************************************************************
 * FUNCTION
 *  DisableInlineItem
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_inline_set_selector_no_loop(InlineItem *item, MMI_BOOL operation)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if((item->flags & 0xff ) == INLINE_ITEM_TYPE_SELECT)
    {
        if(operation == 1)
        {
            item->flags |= INLINE_ITEM_SELECTOR_NO_LOOP;
        }
        else if(operation == 0)
        {
            item->flags &= ~INLINE_ITEM_SELECTOR_NO_LOOP;
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  DisableInlineItem
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_inline_set_displayonly_no_num_key(InlineItem *item, MMI_BOOL operation)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if((item->flags & 0xff ) == INLINE_ITEM_TYPE_DISPLAY_ONLY)
    {
        if(operation == 1)
        {
            item->flags |= INLINE_ITEM_DISPLAY_ONLY_NO_NUMKEY;
        }
        else if(operation == 0)
        {
            item->flags &= ~INLINE_ITEM_DISPLAY_ONLY_NO_NUMKEY;
        }
    }
}


void wgui_inline_set_text_edit_first_cursor(InlineItem *item, MMI_BOOL operation)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if((item->flags & 0xff ) == INLINE_ITEM_TYPE_TEXT_EDIT)
    {
        if(operation == 1)
        {
            item->flags |= INLINE_ITEM_TEXT_EDIT_FIRST_CURSOR;
        }
        else if(operation == 0)
        {
            item->flags &= ~INLINE_ITEM_TEXT_EDIT_FIRST_CURSOR;
        }
    }
}


void wgui_inline_text_edit_move_cursor_to_first(single_line_input_box *b)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(b != NULL)
    {
        b->current_text_p = b->text;
    }   
}


static U8 g_is_current_cui = 0;

/*****************************************************************************
 * FUNCTION
 *  wgui_inline_set_lsk_function
 * DESCRIPTION
 *  Changes the handler of softkeys for inline
 * PARAMETERS
 *  f       [IN]        Handler function
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_inline_set_lsk_function(void (*f) (void))
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_inline_lsk_functions = f;
}

/*****************************************************************************
 * FUNCTION
 *  wgui_inline_set_op_parent_group
 * DESCRIPTION
 *  Set parent  for inline screen option screen.
 * PARAMETERS
 *  MMI_ID  [IN] parent_id
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_inline_set_op_parent_group(MMI_ID parent_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    // parent_id always >= 0
    g_inline_op_parent_id = parent_id;
    
}


#define WGUI_INLINE_OPTION_LIST_MAX_NUM	2
/*****************************************************************************
 * FUNCTION
 *  wgui_inline_set_option_list
 * DESCRIPTION
 *  Set menu items function.
 * PARAMETERS
 *  menu_gid        [IN]   menu group id.     
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_inline_set_option_list(mmi_id menu_gid, S32 flags)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    int i = 0, n_items = WGUI_INLINE_OPTION_LIST_MAX_NUM;
    mmi_menu_id root_ids[WGUI_INLINE_OPTION_LIST_MAX_NUM];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (i = 0; i < WGUI_INLINE_OPTION_LIST_MAX_NUM; i++)
    {
        root_ids[i] = i;
    }

    cui_menu_set_currlist(menu_gid, n_items, root_ids);

	i = 0;	
	if (flags == INLINE_ITEM_TYPE_TEXT_EDIT)
	{
	    cui_menu_set_item_string(menu_gid, i, (WCHAR*)(get_string(STR_GLOBAL_SAVE)));
		i++;
		cui_menu_set_item_string(menu_gid, i, (WCHAR*)(get_string(STR_GLOBAL_CANCEL)));
	}
	else
	{
	    cui_menu_set_item_string(menu_gid, i, (WCHAR*)(g_inline_lsk_string));
		i++;
		cui_menu_set_item_string(menu_gid, i, (WCHAR*)(get_string(STR_GLOBAL_SAVE)));
	}
    cui_menu_set_currlist_left_softkey(menu_gid, (WCHAR*) GetString(STR_GLOBAL_SELECT));
}


/*****************************************************************************
 * FUNCTION
 *  wgui_inline_menu_cui_op_proc
 * DESCRIPTION
 *  Inline Menu CUI proc function of event.
 * PARAMETERS
 *  evt     [IN]    event data struct.
 * RETURNS
 *  
 *****************************************************************************/
static mmi_ret wgui_inline_menu_cui_op_proc(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    cui_menu_event_struct *menu_evt = (cui_menu_event_struct*) evt;
    //mmi_group_event_struct *ext_evt = (mmi_group_event_struct*) evt;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (evt->evt_id)
    {
        case EVT_ID_CUI_MENU_ITEM_SELECT:
        {
			U32 group_info = (U32)menu_evt->app_data;
			U32 parent_info = (U32)mmi_frm_group_get_user_data((MMI_ID)(group_info >> 16));
			S32 flags = (S32)(group_info & 0xFF);
			S32 fte_back = (S32)((group_info >> 8) & 0xFF);
			
			if (g_is_current_cui)
			{
				if (menu_evt->highlighted_menu_id == 0)
				{
				    if ((flags == INLINE_ITEM_TYPE_FULL_SCREEN_EDIT)
						|| (flags == INLINE_ITEM_TYPE_RADIO)
						|| (flags == INLINE_ITEM_TYPE_CHECKBOX))
				    {
				        cui_menu_close(menu_evt->sender_id);
						if (g_inline_lsk_functions)
						{
							g_inline_lsk_functions();
						}
						return MMI_RET_OK;
				    }
					if (g_inline_lsk_functions)
					{
						g_inline_lsk_functions();
					}
					else
					{
						cui_inline_evt_submit_int((MMI_ID)parent_info, MMI_LEFT_SOFTKEY);
					}
				}
				else if (menu_evt->highlighted_menu_id == 1)
				{
				    if (flags == INLINE_ITEM_TYPE_TEXT_EDIT)
				    {
				        cui_inline_evt_abort_int((MMI_ID)parent_info);
				    }
					else
					{
					    if (fte_back)
					    {
					        cui_inline_evt_submit_int((MMI_ID)parent_info, MMI_RIGHT_SOFTKEY);
					    }
						else
						{
						    cui_inline_evt_submit_int((MMI_ID)parent_info, MMI_LEFT_SOFTKEY);
						}
					}
				}
			}
            cui_menu_close(menu_evt->sender_id);
            break;
        }
        case EVT_ID_CUI_MENU_LIST_ENTRY:
        {
			U32 group_info = (U32)menu_evt->app_data;
			
			wgui_inline_set_option_list(menu_evt->sender_id, (S32)(group_info & 0xFF));
            break;
        }
        case EVT_ID_CUI_MENU_CLOSE_REQUEST:
        {
            cui_menu_close(menu_evt->sender_id);
            break;
        }
    }
    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_inline_menu_cui_option
 * DESCRIPTION
 *  Create Menu CUI for inline left softkey.
 * PARAMETERS
 *  parent_id     [IN]  parent group id.
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_inline_menu_cui_option(MMI_ID parent_id, S32 flags)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_id sub_group_id = 0, menu_gid = 0;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    sub_group_id = mmi_frm_group_create(
    					parent_id, 
    					GRP_ID_AUTO_GEN, 
    					wgui_inline_menu_cui_op_proc, 
    					(void*)(parent_id));
    mmi_frm_group_enter(sub_group_id, MMI_FRM_NODE_SMART_CLOSE_FLAG);
    menu_gid = cui_menu_create(
                           sub_group_id,
                           CUI_MENU_SRC_TYPE_APPCREATE,
                           CUI_MENU_TYPE_OPTION,
                           MENU_ID_INLINE_EDITOR_OPT,
                           MMI_TRUE,
                           (void*)((sub_group_id << 16) | flags));
    
    cui_menu_run(menu_gid);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_inline_csk_menu_cui_option
 * DESCRIPTION
 *  csk function to enter Menu CUI.
 * PARAMETERS
 *  void    
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_inline_csk_menu_cui_option(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	if (cui_inline_is_current_cui())
	{
		if (g_inline_lsk_functions)
		{
			g_inline_lsk_functions();
		}
		else
		{
			cui_inline_evt_submit_int((MMI_ID)g_inline_op_parent_id, MMI_LEFT_SOFTKEY);
		}
	}
}


/*****************************************************************************
 * FUNCTION
 *  wgui_inline_lsk_menu_cui_option
 * DESCRIPTION
 *  lsk function to enter Menu CUI.
 * PARAMETERS
 *  void    
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_inline_lsk_menu_cui_option(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
	S32 flag = 0, tmp_flag = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	flag = INLINE_GET_ITEM_TYPE(wgui_inline_item_highlighted_index);
	if (wgui_inline_list_menu_rsk_back)
	{
	    tmp_flag = 1 << 8;
		tmp_flag = (S32)(tmp_flag & 0xff00);
	}
	flag = flag | tmp_flag;
	wgui_inline_menu_cui_option(g_inline_op_parent_id, flag);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_inline_option_handler_for_lsk
 * DESCRIPTION
 *  LSK function to enter Menu CUI.
 * PARAMETERS
 *  void    
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_inline_option_handler_for_lsk(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
	U16 string_id = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	g_is_current_cui = 0;
    if (cui_inline_is_current_cui())
    {
        g_is_current_cui = 1;
		g_inline_lsk_string = 0;
		if ((INLINE_GET_ITEM_TYPE(wgui_inline_item_highlighted_index) == INLINE_ITEM_TYPE_FULL_SCREEN_EDIT)
			|| (INLINE_GET_ITEM_TYPE(wgui_inline_item_highlighted_index) == INLINE_ITEM_TYPE_RADIO)
			|| (INLINE_GET_ITEM_TYPE(wgui_inline_item_highlighted_index) == INLINE_ITEM_TYPE_CHECKBOX)
			)
		{
		    string_id = cui_inline_get_item_default_lsk_strind_id(wgui_inline_item_highlighted_index);
		    wgui_inline_set_lsk_function(get_softkey_function(KEY_EVENT_UP,MMI_LEFT_SOFTKEY));
		}
		else
		{
		    string_id = cui_inline_get_item_lsk_string_id(wgui_inline_item_highlighted_index);
		}
		g_inline_lsk_string = get_string(string_id);
		
        if ((cui_inline_is_item_lsk_by_app(wgui_inline_item_highlighted_index) && string_id)
			|| (INLINE_GET_ITEM_TYPE(wgui_inline_item_highlighted_index) == INLINE_ITEM_TYPE_FULL_SCREEN_EDIT)
			|| (INLINE_GET_ITEM_TYPE(wgui_inline_item_highlighted_index) == INLINE_ITEM_TYPE_RADIO)
			|| (INLINE_GET_ITEM_TYPE(wgui_inline_item_highlighted_index) == INLINE_ITEM_TYPE_CHECKBOX)
			|| (INLINE_GET_ITEM_TYPE(wgui_inline_item_highlighted_index) == INLINE_ITEM_TYPE_TEXT_EDIT)
			)
        {
			set_left_softkey_label(get_string(STR_GLOBAL_OPTIONS));
			register_softkey_handler(MMI_LEFT_SOFTKEY);
			set_softkey_function(wgui_inline_lsk_menu_cui_option, KEY_EVENT_UP, MMI_LEFT_SOFTKEY);
			mmi_imc_key_setup_lsk_function(wgui_inline_lsk_menu_cui_option);
			
            set_softkey_function(wgui_inline_csk_menu_cui_option, KEY_EVENT_UP, MMI_CENTER_SOFTKEY);
			mmi_imc_key_setup_csk_function(wgui_inline_csk_menu_cui_option);
        }
    }
}
