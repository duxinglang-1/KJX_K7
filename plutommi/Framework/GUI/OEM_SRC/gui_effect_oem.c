/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*******************************************************************************
 * Filename:
 * ---------
 *  gui_effect_oem.c
 *
 * Project:
 * --------
 *  PlutoMMI
 *
 * Description:
 * ------------
 *  GUI Effect Engine OEM Layer
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/

/***************************************************************************** 
 * Include
 *****************************************************************************/
#include "MMI_features.h"
#include "MMIDataType.h"
#include "kal_general_types.h"
#include "wgui_fixed_menus.h"
#include "wgui_fixed_menuitems.h"
#include "gdi_include.h"
#include "gd_include.h"
#include "wgui_draw_manager.h"
#include "gui_fixed_menuitems.h"
#include "wgui_categories_util.h"
#include "wgui_asyncdynamic_menus.h"
#include "wgui_dynamic_menus.h"
#include "gui_effect_oem.h"
#include "gui_dynamic_menus.h"
#include "gui_asyncdynamic_menus.h"
#include "gui_font_size.h"
#include "wgui_inputs_internal.h"
#include "wgui_asyncdynamic_menuitems.h"
#include "wgui_dynamic_menuitems.h"

#ifdef __MMI_TOUCH_SCREEN__
#include "wgui_touch_screen.h"
#endif
#ifdef __MMI_SCREEN_ROTATE__
//#include "ScreenRotationGprot.h"
#endif /* __MMI_SCREEN_ROTATE__ */

#include "mmi_frm_gprot.h"
//#include "MMIThemesResDef.h"
#ifndef __COSMOS_MMI_PACKAGE__
#include "Mmi_rp_srv_mmi_theme_def.h"
#endif

#include "wgui.h"
#include "gui_switch.h"
#ifndef __OPTR_NONE__
#include "operator_gui.h"
#endif
#include "gdi_const.h"
#include "lcd_sw_inc.h"
#include "Gui_Setting.h"
#include "gdi_datatype.h"
#include "mmi_frm_input_gprot.h"
#include "gui_typedef.h"
#include "gui_fixed_menus.h"
#include "wgui_categories_list.h"
#include "gdi_features.h"
#include "wgui_inline_edit.h"
#include "kal_public_api.h"
#include "CustDataProts.h"
#include "CustMenuRes.h"
#include "gui.h"
#include "gui_config.h"
#include "gui_scrollbars.h"
#include "gui_themes.h"
#include "CustThemesRes.h"
#include "gui_data_types.h"
#include "wgui_include.h"
#include "string.h"
#include "DebugInitDef_Int.h"
#include "GlobalConstants.h"
#include "GlobalResDef.h"
#include "wgui_categories_enum.h"
#include "UcmSrvGprot.h"
#include "med_smalloc.h"
#include "gui_windows.h"
#include "mmi_frm_mem_gprot.h"
#include "CommonScreens.h"
#include "mmi_frm_events_gprot.h"
#include "gdi_2d_engine.h"

#ifdef __MMI_UCM__
//#include "UCMGProt.h"
#endif

#ifdef __MMI_TOUCH_IDLESCREEN_SHORTCUTS__
//#include "wgui_categories_idlescreen.h"
#endif /* __MMI_TOUCH_IDLESCREEN_SHORTCUTS__ */

#ifdef __MMI_VUI_ENGINE__
//#include "Vapp_hs_res.h"
#include "vadp_p2v_uc.h"
//#include "framework\vadp_p2v_uc.h"
#endif /* __MMI_VUI_ENGINE__ */

#include "med_utility.h"

#include "gui_touch_feedback.h"

//#define __MAUI_SOFTWARE_LA__

#if defined(__MAUI_SOFTWARE_LA__) && defined(__MTK_TARGET__)
#include "SST_sla.h"
#define gui_swla_log_start(log)     SLA_CustomLogging(log, SA_start)
#define gui_swla_log_stop(log)     SLA_CustomLogging(log, SA_stop)
#else
#define gui_swla_log_start(log)
#define gui_swla_log_stop(log)
#endif

extern MMI_BOOL mmi_frm_is_active_scrn_group_node(void);

/* for SSE main menu expanding with highlight scaling */
extern void dm_draw_scr_bg_image(void);

#ifdef __MMI_FTE_SUPPORT__             
extern void inline_fixed_list_goto_item(S32 index, BOOL backward);
extern void inline_fixed_list_goto_item_no_redraw(S32 index, BOOL backward);
#endif  // __MMI_FTE_SUPPORT__

#ifdef GUI_LIST_MENU_SMOOTH_SCROLLING_BY_KEY
extern void gui_screen_switch_effect_draw_world(void);
#endif


/***************************************************************************** 
 * Static Declaration
 *****************************************************************************/
#if defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN) || defined(GUI_MATRIX_MENU_SMOOTH_SCROLLING_BY_PEN)
static gui_list_ssp_parameter_struct g_gui_list_ssp_parameter;

static U8 *g_gui_menu_ssp_pos_delta = &g_gui_list_ssp_parameter.gui_menu_ssp_pos_delta;
static U8 *g_gui_ssp_frame_update_interval = &g_gui_list_ssp_parameter.gui_ssp_frame_update_interval;
static U8 *g_gui_ssp_focus_to_hold_state_y_threshold = &g_gui_list_ssp_parameter.gui_ssp_focus_to_hold_state_y_threshold;
static U8 *g_gui_ssp_free_run_movement_y_thresold = &g_gui_list_ssp_parameter.gui_ssp_free_run_movement_y_thresold;
static float *g_gui_ssp_free_run_scroll_coefficient = &g_gui_list_ssp_parameter.gui_ssp_free_run_scroll_coefficient;
static float *g_gui_ssp_free_run_recover_coefficient= &g_gui_list_ssp_parameter.gui_ssp_free_run_recover_coefficient;
static float *g_gui_ssp_free_run_sensitivity = &g_gui_list_ssp_parameter.gui_ssp_free_run_sensitivity;
static float *g_gui_ssp_menu_over_limit_coefficient = &g_gui_list_ssp_parameter.gui_ssp_menu_over_limit_coefficient;
static U16 *g_gui_ssp_free_run_threshold_time = &g_gui_list_ssp_parameter.gui_ssp_free_run_threshold_time;
#endif  /* GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN */

/*
 *  decide the effect layer size
 */
// TODO: MAY HAVE TO INCREASE GUI_SSE_MAX_MENU_HIGHLIGHT_HEIGHT BY HAND
#define GUI_SSE_MAX_MENU_HIGHLIGHT_HEIGHT   (2 * MMI_MENUITEM_HEIGHT)

/* check multirow menu item height height (128x160 two-line 34 vs multi-row 39) */
#if MMI_MULTIROW_MENUITEM_HEIGHT > GUI_SSE_MAX_MENU_HIGHLIGHT_HEIGHT
#undef GUI_SSE_MAX_MENU_HIGHLIGHT_HEIGHT
#define GUI_SSE_MAX_MENU_HIGHLIGHT_HEIGHT MMI_MULTIROW_MENUITEM_HEIGHT
#endif /* MMI_MULTIROW_MENUITEM_HEIGHT > GUI_SSE_MAX_MENU_HIGHLIGHT_HEIGHT */

#if MMI_MENUITEM_THICK_HEIGHT > GUI_SSE_MAX_MENU_HIGHLIGHT_HEIGHT
#undef GUI_SSE_MAX_MENU_HIGHLIGHT_HEIGHT
#define GUI_SSE_MAX_MENU_HIGHLIGHT_HEIGHT MMI_MENUITEM_THICK_HEIGHT
#endif /* MMI_MULTIROW_MENUITEM_HEIGHT > GUI_SSE_MAX_MENU_HIGHLIGHT_HEIGHT */

#if defined(__MMI_UI_EFFECT_ENGINE__)

/* check if the matrix main menu highlight sliding effect needs a larger height */
#if defined(__MMI_UI_MATRIX_MAIN_MENU_SLIDE_EFFECT__) && (MAIN_MENU_HIGHLIGHTED_IMAGE_HEIGHT > GUI_SSE_MAX_MENU_HIGHLIGHT_HEIGHT)
#undef GUI_SSE_MAX_MENU_HIGHLIGHT_HEIGHT
#define GUI_SSE_MAX_MENU_HIGHLIGHT_HEIGHT MAIN_MENU_HIGHLIGHTED_IMAGE_HEIGHT
#endif /* defined(__MMI_UI_MATRIX_MAIN_MENU_SLIDE_EFFECT__) && (MAIN_MENU_HIGHLIGHTED_IMAGE_HEIGHT > GUI_SSE_MAX_MENU_HIGHLIGHT_HEIGHT) */

#define GUI_EFFECT_LAYER_SIZE  (GUI_SCREEN_SWITCH_EEFECT_MAX_LCD_SIDE_LENGTH * GUI_SSE_MAX_MENU_HIGHLIGHT_HEIGHT * GUI_EFFECT_LAYER_BYTE_PER_PIXEL)

#else /* __MMI_UI_EFFECT_ENGINE__ */

#ifndef GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN
#define GUI_EFFECT_LAYER_SIZE 4
#else
#define GUI_EFFECT_LAYER_SIZE (GUI_SCREEN_SWITCH_EEFECT_MAX_LCD_SIDE_LENGTH * GUI_SSE_MAX_MENU_HIGHLIGHT_HEIGHT * GUI_EFFECT_LAYER_BYTE_PER_PIXEL)
#endif

#endif /* __MMI_UI_EFFECT_ENGINE__ */

#define GUI_SWAP(type, a, b)  \
                do{\
                    type t;\
                    t = a;\
                    a = b;\
                    b = t;\
                } while (0);

#ifdef __MTK_TARGET__
#pragma arm section zidata = "NONCACHEDZI"
#endif
#ifndef __MTK_TARGET__
#define __align(X)
#endif
/* 64 bytes more for alignment */
#if defined(__MMI_SCREEN_SWITCH_EFFECT__) && !defined(__MMI_REDUCED_UI_BUFFER__) 
static U8 *g_gui_effect_layer_buffer = NULL;
#else
__align( __MMI_GDI_LAYER_FRAMEBUF_ALIGNMENT__) static U32 g_gui_effect_layer_buffer[GUI_EFFECT_LAYER_SIZE / sizeof(U32) + 16];
#endif

#ifdef __MTK_TARGET__
#pragma arm section zidata
#endif

static U32  last_start_time = 0;

static gdi_handle  g_layer[4];



static S32 g_old_layer_offset_y = 0;

gdi_handle  g_gui_effect_layer = GDI_ERROR_HANDLE;

static gui_effect_struct    gui_slide_effect;
gui_effect_struct    *g_slide_effect = &gui_slide_effect;
gdi_handle g_gui_ssp_static_layer = GDI_NULL_HANDLE;
static MMI_BOOL r2linslide;


/* default level 1 lies above the background layer */
#ifndef __MMI_UI_MENU_SLIM__
static S32 g_gui_effect_blt_layer_level = 1;

/* is draw the last frame in gui_effect_close */
static MMI_BOOL (*g_query_enable_draw_last_frame)(void) = NULL;
#endif

/* static function prototypes */
static void gui_effect_free_layer(gdi_handle layer);
static void gui_effect_clear_layer(gdi_handle layer);
static void gui_effect_slide_run(void);


extern U8 *dm_get_base_control_set(void);
#if defined(GUI_SUBMENU_USE_SPECIFIC_STYLE)
extern U8 *dm_get_base_control_set_submenu(void);
#endif /* defined(GUI_SUBMENU_USE_SPECIFIC_STYLE) */

//extern void gui_effect_affine_transform_set_subsample_mode(gui_effect_affine_transform_subsample_mode_enum mode);
//extern void gui_effect_projective_transform_set_subsample_mode(gui_effect_projective_transform_subsample_mode_enum mode);


/* 
 * list menu smooth scrolling
 */
#if defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_KEY) || defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN)
static void *gui_list_menu_smooth_scrolling_get_item(S32 item_index);
static void gui_list_menu_smooth_scrolling_goto_item(S32 item_index);
static mmi_ret  gui_list_menu_smooth_scrolling_key_proc(mmi_event_struct *evt);
static void gui_list_menu_smooth_scrolling_goto_item_noredraw(S32 item_index);
#endif /* defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_KEY) || defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN) */

#if defined(GUI_MATRIX_MENU_SMOOTH_SCROLLING_BY_PEN)
static mmi_ret  gui_matrix_menu_smooth_scrolling_key_proc(mmi_event_struct *evt);
#endif

#ifdef GUI_LIST_MENU_SMOOTH_SCROLLING_BY_KEY
static void gui_list_menu_smooth_scrolling_goto_next_item(void);
static void gui_list_menu_smooth_scrolling_goto_previous_item(void);
static void gui_list_menu_smooth_scrolling_by_key(gui_menu_scroll_direction_enum direction);
static void gui_list_menu_smooth_scrolling_draw_highlight_filler(S32 x, S32 y, S32 width, S32 height);
#endif /* GUI_LIST_MENU_SMOOTH_SCROLLING_BY_KEY */

//	static U8 gui_screen_switch_effect_key_detect_pre_key_hdlr(KEYBRD_MESSAGE *eventKey);
static gui_menu_type_enum gui_list_menu_smooth_scrolling_get_menu_type(void);


/*
 * SSP
 */
#if defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN)

#if defined(__MMI_UI_LIST_SUPPORT_UNEQUAL_HEIGHT_ITEM__)
static S32 g_gui_ssp_old_full_height;
#endif

#if defined(__MMI_UI_LIST_SCROLL_BY_PIXEL__)
static S16 g_gui_ssp_old_first_menu_item_offset;
static U16 g_gui_ssp_highlight_first_threshold = GUI_SSP_DEFAULT_HIGHLIGHT_THRESHOLD;
static U16 g_gui_ssp_highlight_last_threshold = GUI_SSP_DEFAULT_HIGHLIGHT_THRESHOLD;
static S16 g_gui_ssp_clicked_half_item;

static void gui_ssp_check_highlight_threshold(S32 *new_highlight_index);
static void gui_ssp_check_highlight_threshold(S32 *new_highlight_index);
static void gui_ssp_sync_list_menu_by_pixel();
static MMI_BOOL gui_ssp_pen_down_on_half_item(mmi_pen_point_struct point, S32 new_highlight_item_index);
static MMI_BOOL gui_ssp_pen_up_on_half_item();
#endif

static S32 g_gui_ssp_old_first_menu_item_index;
static S32 g_gui_ssp_current_menu_y_offset;
static S32 g_gui_ssp_current_menu_last_item_index;
static S32 g_gui_ssp_old_menu_highlight_item_index;

static S32 g_gui_ssp_pen_down_y;
static S32 g_gui_ssp_pen_move_y;
static S32 g_gui_ssp_start_menu_offset;
 
static S32 g_gui_ssp_free_run_momentum;
static S32 g_gui_ssp_free_run_final_pos;
static gui_ssp_free_run_mode_enum g_gui_ssp_free_run_mode;

static U32 g_gui_ssp_pen_down_time;
//static MMI_BOOL g_gui_ssp_is_click_item_own_area;
static MMI_BOOL g_gui_ssp_is_pen_down_in_list;
static MMI_BOOL g_gui_ssp_need_handle_item;

//static MMI_BOOL gui_slide_highlight_removed;

static MMI_BOOL g_gui_ssp_have_goto_disabled_item;

static S32 g_gui_list_ssp_stop_item_index;

static void gui_ssp_enter_free_run_recover_mode(S32 final_y_offset, S32 momentum);
static MMI_BOOL gui_ssp_try_free_run_recover(S32 menu_y_offset);
static S32 gui_ssp_get_menu_last_y_offset(void);


static MMI_BOOL gui_ssp_pen_pre_hdlr(U16 dm_control_id, mmi_pen_point_struct point, mmi_pen_event_type_enum pen_event);

static MMI_BOOL gui_ssp_pen_down_hdlr(mmi_pen_point_struct pos);
static MMI_BOOL gui_ssp_pen_move_hdlr(mmi_pen_point_struct pos);
static MMI_BOOL gui_ssp_pen_up_hdlr(mmi_pen_point_struct pos);
static MMI_BOOL gui_ssp_pen_abort_hdlr(mmi_pen_point_struct pos);

static MMI_BOOL gui_ssp_menu_translate_pen_position(fixed_list_menu *m, S32 x, S32 y, S32 *item_index);

static void gui_ssp_stop_list_menu_scrolling(void);

#endif /* GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN */

#if defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN) || defined(GUI_MATRIX_MENU_SMOOTH_SCROLLING_BY_PEN)
static MMI_BOOL gui_slide_highlight_removed;
static MMI_BOOL g_gui_ssp_is_click_item_own_area;
#endif

/* matrix support ssp */
#if defined(GUI_MATRIX_MENU_SMOOTH_SCROLLING_BY_PEN)
static S32 g_gui_matrix_ssp_pen_down_x;
static S32 g_gui_matrix_ssp_pen_down_y;
//	static S32 g_gui_matrix_ssp_pen_move_x;
static S32 g_gui_matrix_ssp_pen_move_y;
//	static S32 g_gui_matrix_ssp_start_menu_x_offset;
static S32 g_gui_matrix_ssp_start_menu_y_offset;
//	static S32 g_gui_matrix_ssp_current_menu_x_offset;
static S32 g_gui_matrix_ssp_current_menu_y_offset;
static S32 g_gui_matrix_ssp_old_menu_highlight_item_index;

static S32 g_gui_matrix_ssp_old_first_row;
static S32 g_gui_matrix_ssp_old_last_row;
static S32 g_gui_matrix_ssp_old_first_col;
//	static S32 g_gui_matrix_ssp_old_highlight_row;
static S32 g_gui_matrix_ssp_old_highlight_col;

static S32 g_gui_matrix_ssp_free_run_momentum;
static S32 g_gui_matrix_ssp_free_run_final_pos;
static gui_ssp_free_run_mode_enum g_gui_matrix_ssp_free_run_mode;

static U32 g_gui_matrix_ssp_pen_down_time;
static MMI_BOOL g_gui_ssp_is_pen_down_in_matrix;

static MMI_BOOL gui_matrix_ssp_is_point_in_menu_rect (mmi_pen_point_struct point);
static void gui_ssp_stop_matrix_menu_scrolling(void);
static void gui_matrix_menu_smooth_scrolling_redraw_list(void);
static MMI_BOOL gui_matrix_ssp_menu_translate_pen_position(fixed_matrix_menu *m, S32 x, S32 y, S32 *item_index);
static MMI_BOOL gui_matrix_ssp_send_pen_event(mmi_pen_event_type_enum pen_event, mmi_pen_point_struct *point);

static void gui_matrix_menu_smooth_scrolling_goto_item(S32 item_index);

static void *gui_matrix_menu_smooth_scrolling_get_item(S32 item_index);
static void gui_matrix_menu_smooth_scrolling_show_item(S32 item_index, S32 x, S32 y);
static void gui_ssp_show_matrix_menu (S32 offset, S32 x1, S32 y1, S32 x2, S32 y2);

static MMI_BOOL gui_matrix_ssp_pen_down_hdlr (mmi_pen_point_struct point);
static MMI_BOOL gui_matrix_ssp_pen_up_hdlr (mmi_pen_point_struct point);
static MMI_BOOL gui_matrix_ssp_pen_move_hdlr (mmi_pen_point_struct point);
static MMI_BOOL gui_matrix_ssp_pen_abort_hdlr (mmi_pen_point_struct point);

static S32 gui_matrix_ssp_get_menu_last_y_offset(void);
static void gui_matrix_menu_get_gap(fixed_matrix_menu *m, S32 *xoff, S32 *yoff);
static MMI_BOOL gui_matrix_ssp_try_free_run_recover(S32 menu_y_offset);
static void gui_matrix_ssp_enter_free_run_recover_mode(S32 final_y_offset, S32 momentum);

static gui_menu_type_enum gui_matrix_menu_smooth_scrolling_get_menu_type(void);
static MMI_BOOL gui_matrix_ssp_pen_pre_hdlr(U16 dm_control_id, mmi_pen_point_struct point, mmi_pen_event_type_enum pen_event);
#endif  /* GUI_MATRIX_MENU_SMOOTH_SCROLLING_BY_PEN */

#if defined(__MMI_SCREEN_SWITCH_EFFECT__) || defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_KEY)
void gui_effect_clear_blt_rect(void);
#endif

/***************************************************************************** 
 * Global Variable
 *****************************************************************************/
#if defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_KEY) || defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN)
extern S32 gui_asyncdynamic_list_error;
static gui_menu_type_enum  g_gui_list_menu_smooth_scrolling_old_menu_type;
static FuncPtr g_gui_list_menu_smooth_scrolling_stop_callback;
MMI_BOOL gui_in_ssk = MMI_FALSE;
#endif /* defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_KEY) || defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN) */
static gui_menu_type_enum  g_gui_list_menu_smooth_scrolling_menu_type;

#if defined(GUI_MATRIX_MENU_SMOOTH_SCROLLING_BY_PEN)
static gui_menu_type_enum g_gui_matrix_menu_smooth_scrolling_old_menu_type = GUI_MENU_TYPE_INVALID;
static gui_menu_type_enum g_gui_matrix_menu_smooth_scrolling_menu_type;
static MMI_BOOL g_gui_matrix_menu_support_ssp = MMI_TRUE;
#endif

extern S32 gblock_list_animation_highlight;

gui_menu_type_enum g_gui_list_menu_slide_menu_type;

#if defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_KEY)
static S32 g_gui_ssk_incoming_item_index;
#ifdef GDI_6_LAYERS
static S32 g_gui_ssk_outgoing_item_index;
#endif
#endif /* defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_KEY) */

/* dummy temp buffer c for linking. DO NOT REMOVE ME. */
//#ifndef __MMI_SCREEN_SWITCH_EFFECT__
//static U32 g_gui_screen_switch_effect_buf_c[1];
//#endif /* __MMI_SCREEN_SWITCH_EFFECT__ */

#if defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN)
gui_list_smooth_scrolling_by_pen_state_enum g_gui_ssp_state;
gui_list_smooth_scrolling_by_pen_state_enum g_gui_ssp_pen_down_state;
#endif /* GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN */

#if defined(GUI_MATRIX_MENU_SMOOTH_SCROLLING_BY_PEN)
gui_matrix_smooth_scrolling_by_pen_state_enum g_gui_matrix_ssp_state;
gui_matrix_smooth_scrolling_by_pen_state_enum g_gui_matrix_ssp_pen_down_state;
#endif  /* GUI_MATRIX_MENU_SMOOTH_SCROLLING_BY_PEN */

/***************************************************************************** 
 * Local Function
 *****************************************************************************/

/*****************************************************************************
 * FUNCTION
 *  gui_effect_free_layer
 * DESCRIPTION
 *  Free the gui effect layer.
 * PARAMETERS
 *  layer       [IN]    layer handle
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_effect_free_layer(gdi_handle layer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (layer > 0)
    {
        gdi_layer_free(layer);
        g_gui_effect_layer = GDI_ERROR_HANDLE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  gui_effect_clear_layer
 * DESCRIPTION
 *  Clear the gui effect layer.
 * PARAMETERS
 *  layer       [IN]    layer handle
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_effect_clear_layer(gdi_handle layer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_push_and_set_active(layer);      
    gdi_layer_clear(GDI_COLOR_TRANSPARENT);
    gdi_layer_set_source_key(TRUE, GDI_COLOR_TRANSPARENT);
    gdi_layer_pop_and_restore_active();
}

//#if defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_KEY) || defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN)
/*****************************************************************************
 * FUNCTION
 *  gui_list_menu_smooth_scrolling_redraw_list
 * DESCRIPTION
 *  Redraws the list menu
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_list_menu_smooth_scrolling_redraw_list(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (g_gui_list_menu_smooth_scrolling_menu_type)
    {
        case GUI_MENU_TYPE_FIXED:
            redraw_fixed_list();
            break;

#ifdef __MMI_FTE_SUPPORT__ 
        case GUI_MENU_TYPE_INLINE:
            
            wgui_inline_set_ssp_redraw_state(MMI_TRUE);
            redraw_fixed_list();
            break;
#endif

        case GUI_MENU_TYPE_DYNAMIC:
            if (MMI_fixed_list_menu.flags & UI_LIST_MENU_DISABLE_CACHE_DYNAMIC_DATA)
            {
                dynamic_list_goto_item_no_redraw(MMI_fixed_list_menu.highlighted_item);
            }
            redraw_dynamic_list();
            break;

        case GUI_MENU_TYPE_ASYNCDYNAMIC:
            redraw_asyncdynamic_list();
            break;

        default:
            break;                
    }
}  
//#endif /* defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_KEY) || defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN)  */



/*****************************************************************************
 * FUNCTION
 *  gui_effect_slide_run
 * DESCRIPTION
 *  Sliding effect timer callback function.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
#define GUI_EFFECT_TIME_LIMIT       100

static void* gui_list_menu_get_menuitem(S32 index, gui_menu_type_enum menu_type)
{
    void *item = NULL;

    switch (menu_type)
    {
        case GUI_MENU_TYPE_FIXED:
#ifdef __MMI_FTE_SUPPORT__ 
        case GUI_MENU_TYPE_INLINE:
#endif
            item = MMI_fixed_list_menu.items[index];
            break;
            
        case GUI_MENU_TYPE_DYNAMIC:
            item = get_dynamic_item_from_buffer(index);
            break;
            
        case GUI_MENU_TYPE_ASYNCDYNAMIC:
            item = get_asyncdynamic_item_from_buffer(index);
            break;
    }
    
    return item;
}

#ifdef  __MMI_GUI_SUPPORT_LIST_SLIDE_TUNE__
gui_rect    g_gui_list_slide_last_rect;
#endif
static void gui_effect_slide_run(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 start_time, end_time, timer_run_time;
    S32 next_timer_duration;

    S32 layer_offset_x, layer_offset_y;
#ifdef __MMI_UI_LIST_GRID_LINE__
    gdi_handle alpha_layer;
#endif
    S32 i;
    gdi_handle h[4];
    S32 iwidth, iheight, height, y_min, y_max, menu_y2;
    MMI_BOOL r2lnow;
#ifdef __MMI_UI_LIST_GRID_LINE__
#ifndef __MMI_FTE_SUPPORT__
    MMI_BOOL show_scrollbar;
#endif
#endif

    S32 clip_x1, clip_x2, clip_y1, clip_y2;
    
#ifdef  __MMI_GUI_SUPPORT_LIST_SLIDE_TUNE__
    gui_rect current_slide_rect, item_rect, result_rect;
#endif  // __MMI_GUI_SUPPORT_LIST_SLIDE_TUNE__
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_swla_log_start("SLD");
    if (g_slide_effect->current_frame_index == 0)
    {
        // No need to draw zero frame
        g_slide_effect->current_frame_index = 1;
    }

    /* Modify r2lMMIFlag for language setting */
    r2lnow = (MMI_BOOL)mmi_fe_get_r2l_state();
    mmi_fe_set_r2l_state(r2linslide);
    menu_y2 = MMI_fixed_list_menu.y + MMI_fixed_list_menu.height - 1;
    kal_get_time(&start_time);
    if (last_start_time != 0 && g_slide_effect->current_frame_index!= 0 && start_time - last_start_time >=GUI_EFFECT_TIME_LIMIT)
    {
        g_slide_effect->current_frame_index = g_slide_effect->frame_count;
    }

#ifdef  __MMI_GUI_SUPPORT_LIST_SLIDE_TUNE__
    if (g_slide_effect->current_frame_index == 0)
    {
        GUI_RECT(g_gui_list_slide_last_rect, 0, 0, 0, 0);
    }
#endif  // __MMI_GUI_SUPPORT_LIST_SLIDE_TUNE__
    
#ifdef __MMI_UI_MATRIX_MAIN_MENU_SCALING_EFFECT__
    if (MMI_current_menu_type == MATRIX_MENU)
    {
        gui_effect_scaling_set_blt_layer();
    }
    else    
#endif /* __MMI_UI_MATRIX_MAIN_MENU_SCALING_EFFECT__ */
    {
        gui_effect_set_blt_layer();
    }
    if (g_gui_effect_layer != GDI_ERROR_HANDLE)
        gdi_layer_push_and_set_active(g_gui_effect_layer);

    layer_offset_x = g_slide_effect->start_x + (g_slide_effect->end_x - g_slide_effect->start_x) * g_slide_effect->current_frame_index / g_slide_effect->frame_count;
    layer_offset_y = g_slide_effect->start_y + (g_slide_effect->end_y - g_slide_effect->start_y) * g_slide_effect->current_frame_index / g_slide_effect->frame_count;

#ifdef  __MMI_GUI_SUPPORT_LIST_SLIDE_TUNE__
    GUI_RECT(current_slide_rect, layer_offset_x, layer_offset_y, g_slide_effect->width, g_slide_effect->height);
#endif

    gdi_layer_set_position(layer_offset_x, layer_offset_y);

    /* call show function */
    if (g_slide_effect->show_callback)
    {
#ifdef __MMI_GUI_SUPPORT_LIST_SLIDE_TUNE__
        if (g_slide_effect->current_frame_index == 0)
#endif
        {
            g_slide_effect->show_callback(layer_offset_x, layer_offset_y, g_slide_effect->width, g_slide_effect->height);
        }
    }

    /* 
     * hide the old rectangle 
     */    
    /* lock the frame buffer for better performance since hiding old rectangle may introduce many blts */
    gdi_layer_lock_frame_buffer();
    if (g_slide_effect->start_y == g_slide_effect->end_y && g_old_layer_offset_y != 0)
    {
        if (g_slide_effect->end_y <g_old_layer_offset_y)
        {
            y_max = g_old_layer_offset_y;
            y_min = g_slide_effect->end_y;
        }
        else        
        {
            y_max = g_slide_effect->end_y;
            y_min = g_old_layer_offset_y;
        }
    }
    else if (g_slide_effect->start_y > g_slide_effect->end_y)
    {
        y_min = g_slide_effect->end_y;
        y_max = g_slide_effect->start_y;
    }
    else
    {
        y_max = g_slide_effect->end_y;
        y_min = g_slide_effect->start_y;
    }
    if (MMI_current_menu_type == LIST_MENU)
    {
    gdi_layer_get_blt_layer(&h[0], &h[1], &h[2], &h[3]);
    
    for (i = 0; i < 3; i++)
    {
        if (h[i] == g_gui_effect_layer && h[i+1] > GDI_NULL_HANDLE)
        {
            g_slide_effect->in_flatten = 1;
            gdi_layer_push_and_set_active(h[i+1]);
            gui_push_clip();

            clip_x1 = g_slide_effect->start_x;
            clip_x2 = g_slide_effect->start_x + g_slide_effect->width - 1;
            clip_y1 = y_min;
            clip_y2 = y_max + g_slide_effect->height - 1;
            if (y_max + g_slide_effect->height - 1 >= menu_y2)
            {
                clip_y2 = menu_y2;
            }
            gui_set_clip(clip_x1, clip_y1, clip_x2, clip_y2);
            
            if (g_gui_list_hide_menu)
            {
            #ifdef  __MMI_GUI_SUPPORT_LIST_SLIDE_TUNE__
                if (g_slide_effect->current_frame_index == 0)
                {
                    g_gui_list_hide_menu(
                        clip_x1, 
                        clip_y1, 
                        clip_x2, 
                        y_max + g_slide_effect->height - 1);
                }
                else
                {
                    g_gui_list_hide_menu(
                        g_gui_list_slide_last_rect.x,
                        g_gui_list_slide_last_rect.y,
                        g_gui_list_slide_last_rect.x + g_gui_list_slide_last_rect.width - 1,
                        g_gui_list_slide_last_rect.y + g_gui_list_slide_last_rect.height - 1);
                    
                    g_gui_list_hide_menu(
                        current_slide_rect.x,
                        current_slide_rect.y,
                        current_slide_rect.x + current_slide_rect.width - 1,
                        current_slide_rect.y + current_slide_rect.height - 1);
                }
            #else   // __MMI_GUI_SUPPORT_LIST_SLIDE_TUNE__
                g_gui_list_hide_menu(
                    clip_x1, 
                    clip_y1, 
                    clip_x2, 
                    y_max + g_slide_effect->height - 1);
            #endif  // __MMI_GUI_SUPPORT_LIST_SLIDE_TUNE__
            }
            else if (!(MMI_fixed_list_menu.flags & UI_LIST_MENU_DISABLE_BKGRND_IN_LAYER) && 
                     (wgui_is_wallpaper_on_bottom() == MMI_TRUE))
            {
#ifdef  __MMI_GUI_SUPPORT_LIST_SLIDE_TUNE__
                if (g_slide_effect->current_frame_index == 0)
                {
                    gdi_draw_solid_rect(
                        clip_x1, 
                        clip_y1, 
                        clip_x2, 
                        y_max + g_slide_effect->height - 1, 
                        GDI_COLOR_TRANSPARENT);
                }
                else
                {
                    gdi_draw_solid_rect(
                        g_gui_list_slide_last_rect.x,
                        g_gui_list_slide_last_rect.y,
                        g_gui_list_slide_last_rect.x + g_gui_list_slide_last_rect.width - 1,
                        g_gui_list_slide_last_rect.y + g_gui_list_slide_last_rect.height - 1,
                        GDI_COLOR_TRANSPARENT);
                    
                    gdi_draw_solid_rect(
                        current_slide_rect.x,
                        current_slide_rect.y,
                        current_slide_rect.x + current_slide_rect.width - 1,
                        current_slide_rect.y + current_slide_rect.height - 1,
                        GDI_COLOR_TRANSPARENT);
                }
#else   // __MMI_GUI_SUPPORT_LIST_SLIDE_TUNE__
                gdi_draw_solid_rect(
                    clip_x1, 
                    clip_y1, 
                    clip_x2, 
                    y_max + g_slide_effect->height - 1, 
                    GDI_COLOR_TRANSPARENT);
#endif  // __MMI_GUI_SUPPORT_LIST_SLIDE_TUNE__
#ifdef __MMI_UI_LIST_GRID_LINE__
#ifndef __MMI_FTE_SUPPORT__
            /* Check presence of scrollbar */
            show_scrollbar = gui_show_list_menu_check_scrollbar(&MMI_fixed_list_menu);//gui_list_menu_has_scrollbar();
#endif  // __MMI_FTE_SUPPORT__            
            if (MMI_fixed_list_menu.n_items > 0)
            {
                S32 line_height = 0, display_index, index, highlight_height, grid_x;

                iheight = 0;
                MMI_fixed_list_menu.current_displayed_item = -1; 
                index = MMI_fixed_list_menu.current_displayed_item;
                display_index = MMI_fixed_list_menu.first_displayed_item;

#ifdef __MMI_UI_LIST_SCROLL_BY_PIXEL__
                line_height -= MMI_fixed_list_menu.first_displayed_offset;
#endif
                if (mmi_fe_get_r2l_state())
                {
                    grid_x = MMI_fixed_list_menu.x + GUI_MENUITEM_X2_GAP;
#ifndef __MMI_FTE_SUPPORT__
                    if (show_scrollbar)
                    {
                        grid_x = grid_x + MMI_fixed_list_menu.vbar.width;
                    }
                    else
#endif /* __MMI_FTE_SUPPORT__ */
                    {
                        grid_x += GUI_LIST_MENU_X2_GAP;
                    }
                }
                else
                {
                    grid_x = MMI_fixed_list_menu.x + GUI_MENUITEM_X1_GAP;    
                }
                
                MMI_fixed_list_menu.item_measure_function(
                    gui_list_menu_get_menuitem(MMI_fixed_list_menu.highlighted_item, g_gui_list_menu_slide_menu_type),
                    MMI_fixed_list_menu.common_item_data,&iwidth, &highlight_height);
                if (MMI_fixed_list_menu.highlighted_item >= MMI_fixed_list_menu.first_displayed_item + 1 || MMI_fixed_list_menu.n_items == 1)
                {
                    MMI_fixed_list_menu.current_displayed_item = MMI_fixed_list_menu.first_displayed_item;                
                    MMI_fixed_list_menu.item_measure_function(
                        gui_list_menu_get_menuitem(MMI_fixed_list_menu.first_displayed_item, g_gui_list_menu_slide_menu_type),
                        MMI_fixed_list_menu.common_item_data, &iwidth, &iheight);
                }
                else if (MMI_fixed_list_menu.n_items != 0)
                {
                    MMI_fixed_list_menu.current_displayed_item = MMI_fixed_list_menu.first_displayed_item + 1;                
                    MMI_fixed_list_menu.item_measure_function(
                        gui_list_menu_get_menuitem(MMI_fixed_list_menu.first_displayed_item + 1, g_gui_list_menu_slide_menu_type),
                        MMI_fixed_list_menu.common_item_data, &iwidth, &iheight);
                }
                
                if (iheight)
                {
                    if (display_index == MMI_fixed_list_menu.highlighted_item)
                    {
                        line_height += MMI_fixed_list_menu.y + highlight_height;
                    }
                    else
                    {
                        line_height += MMI_fixed_list_menu.y + iheight;
                    }
                    while (line_height < MMI_fixed_list_menu.y + MMI_fixed_list_menu.height -1)
                    {
                        if (MMI_fixed_list_menu.alpha_blend_layer_handle)
                        {
                            alpha_layer = dm_get_scr_bg_layer(); 
                        }
                        else 
                        {
                            alpha_layer = dm_get_scr_bg_layer();   
                            if (alpha_layer == GDI_ERROR_HANDLE)
                            {
                                gdi_layer_get_active(&alpha_layer);
                            }
                        }
                        //if (display_index != MMI_fixed_list_menu.highlighted_item - 1)
                        {
                            // if the previous item has UI_MENUITEM_EXT_SHOW_DOWN_SEPARATORLINE
                            // there is no need to draw seperator line, because the seperator line maybe overlay the horizontal line
                            // in our design, the horizontal line should overlay on the seperator line
                            U32 ret_flag = 0;
                            U32 ret_flag_ext = 0;
                            
                        #ifdef  __MMI_GUI_SUPPORT_LIST_SLIDE_TUNE__
                            gui_rect seperator_rect;
                            GUI_RECT(seperator_rect, grid_x, line_height, iwidth, 1);
                        #endif  // __MMI_GUI_SUPPORT_LIST_SLIDE_TUNE__

                            if (g_gui_list_get_menuitem_flags && (display_index >= 0) && (display_index <= MMI_fixed_list_menu.n_items - 1))
                            {
                                g_gui_list_get_menuitem_flags(display_index, &ret_flag, &ret_flag_ext);
                            }

                            if (!(ret_flag_ext & UI_MENUITEM_EXT_SHOW_DOWN_SEPARATORLINE)
                        #ifdef  __MMI_GUI_SUPPORT_LIST_SLIDE_TUNE__
                                && (gui_rect_get_intersection(&seperator_rect, &current_slide_rect, &result_rect)
                                || gui_rect_get_intersection(&seperator_rect, &g_gui_list_slide_last_rect, &result_rect)) ||
                                (display_index == MMI_fixed_list_menu.highlighted_item - 1)
                        #endif  // __MMI_GUI_SUPPORT_LIST_SLIDE_TUNE__
                                )
                            {
                                // avoid draw all the seperator line
                                gdi_effect_alpha_blending_rect(
                                    alpha_layer, 
                                    grid_x, 
                                    line_height, 
                                    grid_x + iwidth - 1, 
                                    line_height, 
                                    current_MMI_theme->list_grid_line_alpha * 255 / 100,
                                    current_MMI_theme->list_grid_line_color->r,
                                    current_MMI_theme->list_grid_line_color->g,
                                    current_MMI_theme->list_grid_line_color->b);
                            }
                        }
                        display_index ++;                       
                        if ((MMI_fixed_list_menu.flags & UI_LIST_MENU_DISABLE_EXT_GRID_LINE) && (display_index > MMI_fixed_list_menu.n_items - 1))
                        {
                            break;
                        }
                        if (display_index == MMI_fixed_list_menu.highlighted_item)
                        {   
                            line_height += highlight_height;                        
                        }
                        else
                        {
                            line_height += iheight;                        
                        }
                    }
                }
                MMI_fixed_list_menu.current_displayed_item = index;                         
            }
#endif  // __MMI_UI_LIST_GRID_LINE__
            }
#ifdef  __MMI_GUI_SUPPORT_LIST_SLIDE_TUNE__
            if (g_slide_effect->current_frame_index == 0)
            {
                gdi_layer_flatten_with_clipping(h[0], h[1], h[2], h[3]);
            }
            else
            {
                gdi_layer_push_clip();
                gdi_layer_set_clip(
                    current_slide_rect.x,
                    current_slide_rect.y, 
                    current_slide_rect.x + current_slide_rect.width - 1,
                    current_slide_rect.y + current_slide_rect.height - 1);
                gdi_layer_flatten_with_clipping(h[0], h[1], h[2], h[3]);
                
                gdi_layer_set_clip(
                    g_gui_list_slide_last_rect.x,
                    g_gui_list_slide_last_rect.y, 
                    g_gui_list_slide_last_rect.x + g_gui_list_slide_last_rect.width - 1,
                    g_gui_list_slide_last_rect.y + g_gui_list_slide_last_rect.height - 1);
                gdi_layer_flatten_with_clipping(h[0], h[1], h[2], h[3]);
                gdi_layer_pop_clip();
            }
#else
            if (h[i] == g_gui_effect_layer && h[i+1] != GDI_NULL_HANDLE)
            {
                if (g_slide_effect->current_frame_index == g_slide_effect->frame_count)
                {
                    GUI_SWAP(gdi_handle, h[i], h[i+1]);
                }
                gdi_layer_flatten_with_clipping(h[0], h[1], h[2], h[3]);
                if (g_slide_effect->current_frame_index == g_slide_effect->frame_count)
                {
                    GUI_SWAP(gdi_handle, h[i], h[i+1]);
                }
            }
#endif  //  __MMI_GUI_SUPPORT_LIST_SLIDE_TUNE__

            gui_pop_clip();
            height = MMI_fixed_list_menu.y;
#ifdef __MMI_UI_LIST_SCROLL_BY_PIXEL__
            height -= MMI_fixed_list_menu.first_displayed_offset;
#endif
            MMI_fixed_list_menu.current_displayed_item = -1;
            for (i = MMI_fixed_list_menu.first_displayed_item; i <= MMI_fixed_list_menu.last_displayed_item; i++)
            {          
                MMI_fixed_list_menu.current_displayed_item = i;

#ifdef __MMI_UI_LIST_SCROLL_BY_PIXEL__
                if (i == MMI_fixed_list_menu.first_displayed_item && MMI_fixed_list_menu.first_displayed_offset > 0)
                {
                    gui_push_clip();
                    gui_set_clip(g_slide_effect->start_x, 
                        MMI_fixed_list_menu.y,
                        g_slide_effect->start_x + g_slide_effect->width - 1, 
                        MMI_fixed_list_menu.y + MMI_fixed_list_menu.height - 1);
                }
#endif

                if (g_gui_list_menu_slide_menu_type == GUI_MENU_TYPE_ASYNCDYNAMIC)
                {
                    gui_push_clip();
                    if (y_max + g_slide_effect->height - 1 >= menu_y2)
                    {
                        gui_set_clip(g_slide_effect->start_x, 
                            y_min, 
                            g_slide_effect->start_x + g_slide_effect->width - 1, 
                            menu_y2);
                    }
                    else
                    {
                        gui_set_clip(g_slide_effect->start_x, 
                            y_min, 
                            g_slide_effect->start_x + g_slide_effect->width - 1, 
                            y_max + g_slide_effect->height - 1);
                    }
                }
                
                MMI_fixed_list_menu.item_measure_function(
                    gui_list_menu_get_menuitem(i, g_gui_list_menu_slide_menu_type), 
                    MMI_fixed_list_menu.common_item_data, 
                    &iwidth, 
                    &iheight);
            #ifdef  __MMI_GUI_SUPPORT_LIST_SLIDE_TUNE__
                GUI_RECT(item_rect, g_slide_effect->start_x, height, iwidth, iheight);
            #endif  // __MMI_GUI_SUPPORT_LIST_SLIDE_TUNE__
                
                height += iheight;
            #ifdef  __MMI_GUI_SUPPORT_LIST_SLIDE_TUNE__
                if (gui_rect_get_intersection(&item_rect, &current_slide_rect, &result_rect) ||
                    gui_rect_get_intersection(&item_rect, &g_gui_list_slide_last_rect, &result_rect))
            #else
                if (height > y_min)
            #endif
                {
                #ifdef  __MMI_GUI_SUPPORT_LIST_SLIDE_TUNE__
                    gdi_layer_push_clip(
                        g_slide_effect->start_x, 
                        height - iheight, 
                        g_slide_effect->start_x + g_slide_effect->width - 1,
                        height - 1);
                    gdi_layer_flatten_with_clipping(h[0], h[1], h[2], h[3]);
                    gdi_layer_pop_clip();
                #endif  // __MMI_GUI_SUPPORT_LIST_SLIDE_TUNE__
                    MMI_fixed_list_menu.item_display_function(
                        gui_list_menu_get_menuitem(i, g_gui_list_menu_slide_menu_type), 
                        MMI_fixed_list_menu.common_item_data, 
                        g_slide_effect->start_x, 
                        height - iheight);
                }
            #ifdef  __MMI_GUI_SUPPORT_LIST_SLIDE_TUNE__
                else
                {
                    if (i == MMI_fixed_list_menu.highlighted_item &&
                        g_slide_effect->current_frame_index == 0)
                    {                    
                        gdi_layer_push_clip(
                            g_slide_effect->start_x, 
                            height - iheight, 
                            g_slide_effect->start_x + g_slide_effect->width - 1,
                            height - 1);
                        gdi_layer_flatten_with_clipping(h[0], h[1], h[2], h[3]);
                        gdi_layer_pop_clip();

                        MMI_fixed_list_menu.item_display_function(
                            gui_list_menu_get_menuitem(i, g_gui_list_menu_slide_menu_type), 
                            MMI_fixed_list_menu.common_item_data, 
                            g_slide_effect->start_x, 
                            height - iheight);
                    }
                }
            #endif
                
                if (g_gui_list_menu_slide_menu_type == GUI_MENU_TYPE_ASYNCDYNAMIC)
                {
                    gui_pop_clip();
                }
#ifdef __MMI_UI_LIST_SCROLL_BY_PIXEL__
                if (i == MMI_fixed_list_menu.first_displayed_item && MMI_fixed_list_menu.first_displayed_offset > 0)
                {
                    gui_pop_clip();
                }
#endif
                if (height >= y_max + g_slide_effect->height - 1)
                    break;
            }
            
#ifdef __MMI_FTE_SUPPORT__ 
            {
                gui_vertical_scrollbar_enable_clear_background(&MMI_fixed_list_menu.vbar, MMI_FALSE);
                
                gdi_layer_push_and_set_active(MMI_fixed_list_menu.act_layer_handle);
                gdi_layer_get_blt_layer(&h[0], &h[1], &h[2], &h[3]);
                gdi_layer_push_clip();

                clip_x1 = MMI_fixed_list_menu.x + MMI_fixed_list_menu.width - 1 - MMI_fixed_list_menu.vbar.width;
                clip_y1 = y_min;
                clip_x2 = MMI_fixed_list_menu.x + MMI_fixed_list_menu.width - 1;
                clip_y2 = y_max + g_slide_effect->height - 1;
                if (mmi_fe_get_r2l_state())
                {
                    clip_x1 = MMI_fixed_list_menu.x;
                    clip_x2 = MMI_fixed_list_menu.x + MMI_fixed_list_menu.vbar.width - 1;
                }

                gdi_layer_set_clip(clip_x1, clip_y1, clip_x2, clip_y2);

                if (wgui_is_wallpaper_on_bottom() && h[0] != dm_get_scr_bg_layer())
                {
                    gdi_layer_flatten_with_clipping(dm_get_scr_bg_layer(), h[0], h[1], h[2]);
                }
                else
                {
                    gdi_layer_flatten_with_clipping(h[0], h[1], h[2], h[3]);
                }
                gui_enable_scrollbar_redraw_clip(MMI_FALSE);
                gui_show_vertical_scrollbar(&MMI_fixed_list_menu.vbar);
                gui_enable_scrollbar_redraw_clip(MMI_TRUE);
                gdi_layer_pop_clip();
                gdi_layer_pop_and_restore_active();
            }
#endif  // __MMI_FTE_SUPPORT__
            MMI_fixed_list_menu.current_displayed_item = -1; 
#ifdef UI_ENABLE_POP_UP_DESCRIPTIONS
            //if (g_slide_effect->current_frame_index != 0)
            {
                if (g_gui_list_menu_slide_menu_type == GUI_MENU_TYPE_FIXED)
                {
                    wgui_display_fixed_text_list_pop_up_description();
                }
                else if (g_gui_list_menu_slide_menu_type == GUI_MENU_TYPE_DYNAMIC)
                {
                    wgui_display_dynamic_text_list_pop_up_description();
                }
                else if (g_gui_list_menu_slide_menu_type == GUI_MENU_TYPE_ASYNCDYNAMIC)
                {
                    wgui_display_asyncdynamic_text_list_pop_up_description();
                }
            }
#endif
            gdi_layer_pop_and_restore_active();
            g_slide_effect->in_flatten = 0;
            break;
        }
    }
    }
    if (g_slide_effect->current_frame_index == g_slide_effect->frame_count)
    {
        g_old_layer_offset_y = 0;
    }
    else
    {
        g_old_layer_offset_y = layer_offset_y;
    }
    
    /* The blt rect must include the current rectangle. */    
#ifdef __MMI_UI_MATRIX_MAIN_MENU_SCALING_EFFECT__
    if (MMI_current_menu_type == MATRIX_MENU)
    {
        gdi_layer_blt_previous(
            layer_offset_x, 
            layer_offset_y, 
            g_slide_effect->end_x + g_slide_effect->width - 1, 
            g_slide_effect->end_y + g_slide_effect->height - 1); 
    }
    else    
#endif /* __MMI_UI_MATRIX_MAIN_MENU_SCALING_EFFECT__ */
    {
        gdi_layer_blt_previous(layer_offset_x, layer_offset_y, layer_offset_x + g_slide_effect->width - 1, layer_offset_y + g_slide_effect->height - 1);
    }
    
    if (g_slide_effect->hide_callback)
    {
#ifdef __MMI_UI_MATRIX_MAIN_MENU_SCALING_EFFECT__
        if (MMI_current_menu_type == MATRIX_MENU)
        {
            gdi_layer_push_and_set_active(GDI_LAYER_MAIN_BASE_LAYER_HANDLE);
            gdi_layer_push_clip();
            gdi_layer_set_clip(
                g_slide_effect->old_x,
                g_slide_effect->old_y, 
                g_slide_effect->old_x + g_slide_effect->width - 1, 
                g_slide_effect->old_y + g_slide_effect->height - 1);
            gdi_draw_solid_rect(
                g_slide_effect->old_x,
                g_slide_effect->old_y, 
                g_slide_effect->old_x + g_slide_effect->width - 1, 
                g_slide_effect->old_y + g_slide_effect->height - 1,
                GDI_COLOR_TRANSPARENT);
            gdi_layer_pop_clip();
            gdi_layer_pop_and_restore_active();
        }
        else
#endif /* __MMI_UI_MATRIX_MAIN_MENU_SCALING_EFFECT__ */
        {
            g_slide_effect->hide_callback(g_slide_effect->old_x, g_slide_effect->old_y, g_slide_effect->width, g_slide_effect->height);
        }    
    } 
    gdi_layer_blt_previous(g_slide_effect->old_x, g_slide_effect->old_y, g_slide_effect->old_x + g_slide_effect->width - 1, g_slide_effect->old_y + g_slide_effect->height - 1);

    gdi_layer_unlock_frame_buffer();
    gdi_layer_blt_previous(0, 0, 0, 0);

    /* save current position */
    g_slide_effect->old_x = layer_offset_x;
    g_slide_effect->old_y = layer_offset_y;

#ifdef  __MMI_GUI_SUPPORT_LIST_SLIDE_TUNE__
    GUI_RECT(g_gui_list_slide_last_rect, layer_offset_x, layer_offset_y, g_slide_effect->width, g_slide_effect->height);
#endif  // __MMI_GUI_SUPPORT_LIST_SLIDE_TUNE__

    gdi_layer_pop_and_restore_active();
    gui_effect_restore_blt_layer();

    kal_get_time(&end_time); 

    g_slide_effect->current_frame_index++;

    if (g_slide_effect->current_frame_index > g_slide_effect->frame_count)
    {                   
        g_slide_effect->state = GUI_EFFECT_STATE_DONE;
    
        if (g_slide_effect->finish_callback)
        {
            g_slide_effect->finish_callback(g_slide_effect->old_x, g_slide_effect->old_y, g_slide_effect->old_x + g_slide_effect->width - 1, g_slide_effect->old_y + g_slide_effect->height - 1);
        }
        last_start_time = 0;
#ifndef __MMI_FTE_SUPPORT__
        /* for list without ssk and ssp, g_gui_list_menu_smooth_scrolling_menu_type will not be set value */
        g_gui_list_menu_smooth_scrolling_menu_type = gui_list_menu_smooth_scrolling_get_menu_type();
        if (g_gui_list_menu_slide_menu_type != GUI_MENU_TYPE_INVALID)
        {
            gui_list_menu_smooth_scrolling_redraw_list();
        }  
#endif
        gui_swla_log_stop("SLD");
        return;
    }

    /*
     *  start the timer for the next frame.
     */
    timer_run_time = kal_ticks_to_milli_secs(end_time - start_time);
    next_timer_duration = GUI_EFFECT_TIME_UNIT - timer_run_time;
    if (next_timer_duration <= 0)
    {
        next_timer_duration = 0;
    }
    last_start_time = start_time;
    gui_start_timer(next_timer_duration, gui_effect_slide_run);
    mmi_fe_set_r2l_state(r2lnow);
    gui_swla_log_stop("SLD");
}


/***************************************************************************** 
 * Global Function
 *****************************************************************************/

/*****************************************************************************
 * FUNCTION
 *  gui_effect_mem_manager_create
 * DESCRIPTION
 *  Creates the GUI effect memory manager.
 * PARAMETERS
 *  mem_manager       [IN]  memory manager instance
 *  buf               [IN]  buffer pool
 *  size              [IN]  buffer pool size
 * RETURNS
 *  void
 *****************************************************************************/
void gui_effect_mem_manager_create(gui_effect_memory_manager_struct *mem_manager, void *buf, S32 size)
{   
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(mem_manager, 0, sizeof(gui_effect_memory_manager_struct));
    
    mem_manager->free_size = size;
    mem_manager->buf = buf;
}


/*****************************************************************************
 * FUNCTION
 *  gui_effect_mem_manager_free_all
 * DESCRIPTION
 *  Frees all allocated memory.
 * PARAMETERS
 *  mem_manager       [IN]  memory manager instance
 * RETURNS
 *  void
 *****************************************************************************/
void gui_effect_mem_manager_free_all(gui_effect_memory_manager_struct *mem_manager)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* reset to orignal memory size */
    mem_manager->free_size += mem_manager->allocated_size;
    mem_manager->allocated_size = 0;
}


/*****************************************************************************
 * FUNCTION
 *  gui_effect_mem_manager_mem_alloc
 * DESCRIPTION
 *  Allocates memory.
 * PARAMETERS
 *  mem_manager       [IN]  memory manager instance
 *  size              [IN]  memory size to allocate
 * RETURNS
 *  Allocated memory pointer
 *****************************************************************************/
void *gui_effect_mem_manager_mem_alloc(gui_effect_memory_manager_struct *mem_manager, S32 size)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    void *mem;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    // TODO: use ADM?
    /* __MMI_GDI_LAYER_FRAMEBUF_ALIGNMENT__ aligned */
    mem = (PU8)(mem_manager->buf) + mem_manager->allocated_size;

    /* MODIS does not support alignment specifier */
#ifdef __MTK_TARGET__
    MMI_ASSERT(((U32)mem & (__MMI_GDI_LAYER_FRAMEBUF_ALIGNMENT__ - 1)) == 0);
#endif
    
    size = ((size + __MMI_GDI_LAYER_FRAMEBUF_ALIGNMENT__ - 1) / __MMI_GDI_LAYER_FRAMEBUF_ALIGNMENT__) * __MMI_GDI_LAYER_FRAMEBUF_ALIGNMENT__;
    mem_manager->free_size -= size;

    /* assert if left memory is not enough */
    MMI_ASSERT(mem_manager->free_size >= 0);
    mem_manager->allocated_size += size;

    return mem;
}


/*****************************************************************************
 * FUNCTION
 *  gui_effect_mem_manager_mem_free
 * DESCRIPTION
 *  Frees the allocated memory.
 * PARAMETERS
 *  mem_manager       [IN]  memory manager instance
 *  mem_p             [IN]  allocated memory pointer
 * RETURNS
 *  void
 *****************************************************************************/
void gui_effect_mem_manager_mem_free(gui_effect_memory_manager_struct *mem_manager, void *mem_p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(mem_manager);
    UI_UNUSED_PARAMETER(mem_p);
}

 
/*****************************************************************************
 * FUNCTION
 *  gui_rect_get_intersection_rect
 * DESCRIPTION
 *  Get the intersection rectangle of two input rectangles.
 * PARAMETERS
 *  rect1             [IN]  rectangle 1
 *  rect2             [IN]  rectangle 2
 *  result_rect       [OUT] intersection rectangle
 * RETURNS
 *  0: Not intersected. 1: Intersected.
 *****************************************************************************/
S32 gui_rect_get_intersection(gui_rect *rect1, gui_rect *rect2, gui_rect *result_rect)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32     start_x, start_y, end_x, end_y;
    S32     ax1, ay1, ax2, ay2;            
    S32     bx1, by1, bx2, by2;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    GUI_RECT_TO_POINT(*rect1, ax1, ay1, ax2, ay2);
    GUI_RECT_TO_POINT(*rect2, bx1, by1, bx2, by2);
        
    /* Two rects are not overlapped. */
    if ((ax1 > bx2) || (ay1 > by2) || (ax2 < bx1) || (ay2 < by1))
    {
        return 0;
    }

    /* calculate the overlapped rect */
    start_y = GUI_EFFECT_MAX(ay1, by1);
    end_y = GUI_EFFECT_MIN(ay2, by2);
    start_x = GUI_EFFECT_MAX(ax1, bx1);
    end_x = GUI_EFFECT_MIN(ax2, bx2);

    result_rect->x = start_x;
    result_rect->y = start_y;
    result_rect->width = end_x - start_x + 1;
    result_rect->height = end_y - start_y + 1;
 
    return 1;
}


/*****************************************************************************
 * FUNCTION
 *  gui_draw_image_with_alpha
 * DESCRIPTION
 *  Draw an image with alpha channels. The underlying layers of the output layer
 *  will be flattened to the output layer first, and then the image is drawed to
 *  the output layer.
 * PARAMETERS
 *  x                  [IN]     x
 *  y                  [IN]     y
 *  out_rect           [IN]     output rect
 *  image              [IN]     image
 *  output_layer       [IN]     output layer
 * RETURNS
 *  void
 *****************************************************************************/
void gui_draw_image_with_alpha(S32 x, S32 y, gui_rect *out_rect, PU8 image, gui_rect *text_rect, UI_string_type string, gdi_handle output_layer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32     iw, ih;
    S32     i;
    gdi_handle layer[4];
    gdi_handle old_src_layer;

    S32     x1, y1, x2, y2;
    gui_common_menuitem_base_struct *cm;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    cm = (gui_common_menuitem_base_struct*)MMI_fixed_matrix_menu.common_item_data;
    y += cm->icon_y;
    x += cm->icon_x;
    gdi_image_get_dimension(image, &iw, &ih);
    gdi_layer_get_blt_layer(&layer[0], &layer[1], &layer[2], &layer[3]);

    for (i = 4 - 1; i >= 0; i--)
    {
        if (layer[i] == output_layer)
        {
            layer[i] = GDI_NULL_HANDLE;
            break;
        }

        layer[i] = GDI_NULL_HANDLE;
    }

    /* the active layer is not found in the blt layers. */
    if (i == -1)
    {
        return;
    }

    gdi_layer_push_and_set_active(output_layer);
    gdi_layer_push_clip();

    GUI_RECT_TO_POINT(*out_rect, x1, y1, x2, y2);

    gdi_layer_set_clip(x1, y1, x2, y2);
    old_src_layer = gdi_set_alpha_blending_source_layer(output_layer);    
    
    /* only flatten all lower layers to the active layer */
    gdi_layer_flatten_with_clipping(layer[0], layer[1], layer[2], layer[3]);            
    gdi_image_draw(x, y, image);    
#if defined(__MMI_MAINLCD_320X480__)
    gui_set_font((UI_font_type)gui_font_get_type(GUI_FONT_SIZE_MATRIX));
    gui_move_text_cursor(text_rect->x, text_rect->y);
    gui_set_text_color(*current_MMI_theme->matrix_main_menu_normal_text_color);
    if (MMI_fixed_list_menu.current_displayed_item != -1)
    {
        gui_print_truncated_text(text_rect->x, text_rect->y,
            text_rect->width, string);
    }
    else
    {
        gui_print_text(string);    
    }
#endif
    
    gdi_set_alpha_blending_source_layer(old_src_layer);
    gdi_layer_pop_clip();
    gdi_layer_pop_and_restore_active();
    
    gdi_layer_blt_previous(x1, y1, x2, y2);
}


/*****************************************************************************
 * FUNCTION
 *  gui_effect_set_blt_layer
 * DESCRIPTION
 *  Insert the effect layer into blt layers.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gui_effect_set_blt_layer(void)
{   
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#ifndef __MMI_UI_MENU_SLIM__	
    S32         i;
#endif
    gdi_handle  layer[4];
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* save for later restoration */
    gdi_layer_get_blt_layer(&g_layer[0], &g_layer[1], &g_layer[2], &g_layer[3]);

    gdi_layer_get_blt_layer(&layer[0], &layer[1], &layer[2], &layer[3]);

    /* prevent including the effect layer into blt layers twice */
    if ((layer[0] == g_gui_effect_layer) || 
        (layer[1] == g_gui_effect_layer) || 
        (layer[2] == g_gui_effect_layer) || 
        (layer[3] == g_gui_effect_layer))
    {
        return;
    }

#ifndef __MMI_UI_MENU_SLIM__
    for (i = 4 - 1; i > g_gui_effect_blt_layer_level; i--)
    {
       layer[i] = layer[i - 1];
    }

    layer[i] = g_gui_effect_layer;
#endif    
    gdi_layer_set_blt_layer(layer[0], layer[1], layer[2], layer[3]);
}


/*****************************************************************************
 * FUNCTION
 *  gui_effect_scaling_set_blt_layer
 * DESCRIPTION
 *  Set highlight layer and temp layer into blt layers.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gui_effect_scaling_set_blt_layer(void)
{   
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gdi_handle  layer[4];
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* save for later restoration */
    gdi_layer_get_blt_layer(&g_layer[0], &g_layer[1], &g_layer[2], &g_layer[3]);

    gdi_layer_get_blt_layer(&layer[0], &layer[1], &layer[2], &layer[3]);

    /* prevent including the effect layer into blt layers twice */
    if ((layer[0] == g_gui_effect_layer) || 
        (layer[1] == g_gui_effect_layer) || 
        (layer[2] == g_gui_effect_layer) || 
        (layer[3] == g_gui_effect_layer))
    {
        return;
    }
    layer[2] = g_gui_effect_layer;
    
    gdi_layer_set_blt_layer(layer[0], layer[1], layer[2], 0);
}


/*****************************************************************************
 * FUNCTION
 *  gui_effect_restore_blt_layer
 * DESCRIPTION
 *  Restore blt layers modified by gui_effect_set_blt_layer().
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gui_effect_restore_blt_layer(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_set_blt_layer(g_layer[0], g_layer[1], g_layer[2], g_layer[3]);
}


/*****************************************************************************
 * FUNCTION
 *  gui_effect_create
 * DESCRIPTION
 *  Initialize the gui effect engine.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gui_effect_create(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 layer_height;
#if defined(__MMI_SCREEN_SWITCH_EFFECT__)&&!defined(__MMI_REDUCED_UI_BUFFER__)
    S32 buf_size;
#endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    layer_height = GUI_EFFECT_LAYER_SIZE / (UI_device_width * GUI_EFFECT_LAYER_BYTE_PER_PIXEL);

    if (g_gui_effect_layer != GDI_ERROR_HANDLE)
        gui_effect_free_layer(g_gui_effect_layer);

#if defined(__MMI_SCREEN_SWITCH_EFFECT__)&& !defined(__MMI_REDUCED_UI_BUFFER__)
    /* use buffer b */
    gui_screen_switch_effect_get_frame_buffer_info(1, &g_gui_effect_layer_buffer, &buf_size);
#endif

    gdi_layer_create_cf_using_outside_memory(
        GUI_EFFECT_LAYER_COLOR_FORMAT,
        0,
        0,
        UI_device_width,
        layer_height,
        &g_gui_effect_layer,
        (U8*)g_gui_effect_layer_buffer,
        GUI_EFFECT_LAYER_SIZE);

    if (g_gui_effect_layer != GDI_ERROR_HANDLE)
        gui_effect_clear_layer(g_gui_effect_layer);

    memset(g_slide_effect, 0, sizeof(gui_effect_struct));
}


#ifndef __MMI_UI_MENU_SLIM__
/*****************************************************************************
 * FUNCTION
 *  gui_effect_close
 * DESCRIPTION
 *  De-initialize the gui effect engine.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gui_effect_close(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gdi_handle  l1, l2, l3, l4;
    gdi_handle  dm_l1, dm_l2, dm_l3, dm_l4;
    MMI_BOOL    is_sliding_finished;
    BOOL        is_lcd_freeze;
    MMI_BOOL    enable_draw_last_frame = MMI_TRUE;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* 
     * draw the last frame to the main base layer 
     */
    if (g_slide_effect->is_executed)
    {   
        /*
         * Some strange popup apps would change the blt layer, such as 
         * barcodereader mmi_barcodereader_func_save(). So, it's forced to use dm layers here.
         */
        gdi_layer_lock_frame_buffer();        
        gdi_layer_get_blt_layer(&l1, &l2, &l3, &l4);
        dm_l1 = dm_get_layer_handle(0);
        dm_l2 = dm_get_layer_handle(1);
        dm_l3 = dm_get_layer_handle(2);
        dm_l4 = dm_get_layer_handle(3);
        gdi_layer_set_blt_layer(dm_l1, dm_l2, dm_l3, dm_l4);
        if(g_query_enable_draw_last_frame != NULL)
        {
            enable_draw_last_frame = g_query_enable_draw_last_frame();
        }
        /* if the sliding effect is running, go to the last frame. */
        if ((GetExitScrnID() == GetActiveScreenId()) &&
            !mmi_frm_is_in_ui_common_exit_procedure() &&
            (g_slide_effect->state == GUI_EFFECT_STATE_RUNNING) &&
            enable_draw_last_frame)
        {
            is_sliding_finished = MMI_FALSE;
            gui_effect_slide_draw_last_frame();        
        }
        else
        {
            is_sliding_finished = MMI_TRUE;
        }

        /* flatten the effect layer to the active layer (main base layer) */
        // TODO: Only needed for small screens.
        gui_effect_set_blt_layer();
        gdi_layer_get_blt_layer(&dm_l1, &dm_l2, &dm_l3, &dm_l4);
        gdi_layer_push_clip();
        gdi_layer_set_clip(g_slide_effect->old_x, g_slide_effect->old_y, g_slide_effect->old_x + g_slide_effect->width - 1, g_slide_effect->old_y + g_slide_effect->height - 1);
        gdi_layer_flatten_with_clipping(dm_l1, dm_l2, dm_l3, dm_l4);    
        gdi_layer_pop_clip();
        gdi_layer_unlock_frame_buffer();

        /* 
         * Blt out the last frame. Note that, GoBackHistory() to a small screen will freeze the blt. So,
         * we must unfreeze here.
         */
        if (is_sliding_finished == MMI_FALSE)
        {
            is_lcd_freeze = gdi_lcd_get_freeze();
            gdi_lcd_freeze(FALSE);
            gdi_layer_blt_previous(0, 0, 0, 0);
            gdi_lcd_freeze(is_lcd_freeze);
        }

        /* restore old blt layers */
        gdi_layer_set_blt_layer(l1, l2, l3, l4);
    }
 
    gui_effect_slide_close();
    
    g_slide_effect->state = GUI_EFFECT_STATE_READY;
    g_slide_effect->hide_callback = NULL;  
    g_slide_effect->is_executed = 0;
    g_slide_effect->in_flatten = 0;
    g_old_layer_offset_y = 0;

    if (g_gui_effect_layer != GDI_ERROR_HANDLE
#if defined(__MMI_VUI_ENGINE__)
        && !vadp_p2v_uc_is_in_venus()
#endif
        )
    {
        gui_effect_clear_layer(g_gui_effect_layer);
    }
}
#endif

/*****************************************************************************
 * FUNCTION
 *  gui_effect_register_hide_callback
 * DESCRIPTION
 *  Register the hide callback
 * PARAMETERS
 *  hide_cb       [IN]  hide callback function
 * RETURNS
 *  void
 *****************************************************************************/
void gui_effect_register_hide_callback(gui_effect_funcptr_type hide_cb)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_slide_effect->hide_callback = hide_cb;
}


/*****************************************************************************
 * FUNCTION
 *  gui_effect_slide_create
 * DESCRIPTION
 *  Create the slide effect.
 * PARAMETERS
 *  start_x                 [IN]    start x
 *  start_y                 [IN]    start y
 *  end_x                   [IN]    end x
 *  end_y                   [IN]    end y
 *  width                   [IN]    width
 *  height                  [IN]    height
 *  duration                [IN]    duration in ms
 *  show_cb                 [IN]    show callback function
 *  finish_cb               [IN]    finish callback function
 *  start_frame_index       [IN]    start frame index
 * RETURNS
 *  void
 *****************************************************************************/
void gui_effect_slide_create(S32 start_x, S32 start_y, S32 end_x, S32 end_y, S32 width, S32 height, S32 duration, gui_effect_funcptr_type show_cb, gui_effect_funcptr_type finish_cb, S32 start_frame_index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    r2linslide = (MMI_BOOL)mmi_fe_get_r2l_state();
    g_gui_list_menu_slide_menu_type = gui_list_menu_smooth_scrolling_get_menu_type();
#ifdef  __MMI_GUI_SUPPORT_LIST_SLIDE_TUNE__
if ((start_x != end_x) || (start_y != end_y))
#endif  // __MMI_GUI_SUPPORT_LIST_SLIDE_TUNE__
{
    g_slide_effect->is_executed = 1;
    g_slide_effect->in_flatten = 0;
    
    g_slide_effect->frame_count = duration / GUI_EFFECT_TIME_UNIT;   
        
    if (start_frame_index == GUI_EFFECT_FRAME_LAST)
    {
        g_slide_effect->current_frame_index = g_slide_effect->frame_count;        
    }
    else
    {
        g_slide_effect->current_frame_index = start_frame_index;
    }
    r2linslide = (MMI_BOOL)mmi_fe_get_r2l_state();

    g_slide_effect->width = width;
    g_slide_effect->height = height;

    g_slide_effect->start_x = start_x;
    g_slide_effect->start_y = start_y;
    
    g_slide_effect->end_x = end_x;
    g_slide_effect->end_y = end_y;

    g_slide_effect->show_callback = show_cb;
    g_slide_effect->finish_callback = finish_cb;

    g_gui_list_menu_slide_menu_type = gui_list_menu_smooth_scrolling_get_menu_type();

    gdi_layer_lock_frame_buffer();

    if (g_slide_effect->hide_callback &&
        (g_slide_effect->state != GUI_EFFECT_STATE_READY))
    {
#ifdef __MMI_UI_MATRIX_MAIN_MENU_SCALING_EFFECT__
        gdi_layer_push_and_set_active(GDI_LAYER_MAIN_BASE_LAYER_HANDLE);
        gdi_layer_push_clip();
        gdi_layer_set_clip(
            g_slide_effect->old_x,
            g_slide_effect->old_y, 
            g_slide_effect->old_x + g_slide_effect->width - 1, 
            g_slide_effect->old_y + g_slide_effect->height - 1);
        gdi_draw_solid_rect(
            g_slide_effect->old_x,
            g_slide_effect->old_y, 
            g_slide_effect->old_x + g_slide_effect->width - 1, 
            g_slide_effect->old_y + g_slide_effect->height - 1,
            GDI_COLOR_TRANSPARENT);
        gdi_layer_pop_clip();
        gdi_layer_pop_and_restore_active();
#else /* __MMI_UI_MATRIX_MAIN_MENU_SCALING_EFFECT__ */        
        g_slide_effect->hide_callback(g_slide_effect->old_x, g_slide_effect->old_y, g_slide_effect->width, g_slide_effect->height);
#endif /* __MMI_UI_MATRIX_MAIN_MENU_SCALING_EFFECT__ */
    }
     
    gdi_layer_unlock_frame_buffer();

    g_slide_effect->state = GUI_EFFECT_STATE_RUNNING;
    
    g_slide_effect->hide_callback = NULL;

    if (duration == 0)
    {
        g_slide_effect->current_frame_index = 1;
        g_slide_effect->frame_count = 1;
    }

    gui_effect_slide_run();
}
}

#ifndef __MMI_UI_MENU_SLIM__
/*****************************************************************************
 * FUNCTION
 *  gui_effect_slide_close
 * DESCRIPTION
 *  Close the slide effect.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gui_effect_slide_close(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_cancel_timer(gui_effect_slide_run);
    if (g_slide_effect->state == GUI_EFFECT_STATE_RUNNING)
    {
        g_slide_effect->state = GUI_EFFECT_STATE_CANCEL;
    }    
    gui_swla_log_start("CLR");
    if (g_gui_effect_layer != GDI_ERROR_HANDLE
#if defined(__MMI_UI_LIST_HIGHLIGHT_EFFECTS__)
        && gui_get_current_list_effect() == MMI_UI_LIST_HIGHLIGHT_EFFECT_SLIDE
#endif
#if defined(__MMI_VUI_ENGINE__)
        && !vadp_p2v_uc_is_in_venus()
#endif
        )
    {
        gui_effect_clear_layer(g_gui_effect_layer);
    }
    gui_swla_log_stop("CLR");
}
#endif

/*****************************************************************************
 * FUNCTION
 *  gui_effect_slide_draw_last_frame
 * DESCRIPTION
 *  Skip to the last frame.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gui_effect_slide_draw_last_frame(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_slide_effect->current_frame_index = g_slide_effect->frame_count;
    gui_effect_slide_run();
}


/*****************************************************************************
 * FUNCTION
 *  gui_screen_smooth_scrolling_by_pen
 * DESCRIPTION
 *  Runs the screen switch effect. Must be paried with gui_screen_switch_effect_setup().
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL gui_screen_smooth_scrolling_by_pen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN
    if (g_gui_ssp_state != GUI_LIST_SMOOTH_SCROLLING_BY_PEN_STATE_UNFOCUS 
        && (g_gui_list_menu_smooth_scrolling_menu_type == GUI_MENU_TYPE_ASYNCDYNAMIC ||
        g_gui_list_menu_smooth_scrolling_menu_type == GUI_MENU_TYPE_DYNAMIC ||
        g_gui_list_menu_smooth_scrolling_menu_type == GUI_MENU_TYPE_FIXED 
#ifdef __MMI_FTE_SUPPORT__ 
        ||
        g_gui_list_menu_smooth_scrolling_menu_type == GUI_MENU_TYPE_INLINE
#endif
       ))
        return MMI_TRUE;
#endif  /* GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN */

#ifdef GUI_MATRIX_MENU_SMOOTH_SCROLLING_BY_PEN
    if (g_gui_matrix_ssp_state != GUI_MATRIX_SMOOTH_SCROLLING_BY_PEN_STATE_UNFOCUS 
        && (g_gui_matrix_menu_smooth_scrolling_menu_type == GUI_MENU_TYPE_ASYNCDYNAMIC ||
        g_gui_matrix_menu_smooth_scrolling_menu_type == GUI_MENU_TYPE_DYNAMIC ||
        g_gui_matrix_menu_smooth_scrolling_menu_type == GUI_MENU_TYPE_FIXED) 
       )
        return MMI_TRUE;
#endif /* GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN */         

    return MMI_FALSE;
}

#ifndef __MMI_UI_MENU_SLIM__
MMI_BOOL gui_screen_smooth_scrolling_moved_by_pen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN
    if ((g_gui_ssp_state == GUI_LIST_SMOOTH_SCROLLING_BY_PEN_STATE_HOLD
        || g_gui_ssp_state == GUI_LIST_SMOOTH_SCROLLING_BY_PEN_STATE_FREE_RUN)
        && (g_gui_list_menu_smooth_scrolling_menu_type == GUI_MENU_TYPE_ASYNCDYNAMIC ||
        g_gui_list_menu_smooth_scrolling_menu_type == GUI_MENU_TYPE_DYNAMIC ||
        g_gui_list_menu_smooth_scrolling_menu_type == GUI_MENU_TYPE_FIXED 
#ifdef __MMI_FTE_SUPPORT__ 
        ||
        g_gui_list_menu_smooth_scrolling_menu_type == GUI_MENU_TYPE_INLINE
#endif
        ))
        return MMI_TRUE;
    else
        return MMI_FALSE;
#else
    return MMI_FALSE;
#endif
}
#endif

/*****************************************************************************
 * FUNCTION
 *  gui_screen_smooth_scrolling_in_freerun
 * DESCRIPTION
 *  Runs the screen switch effect. Must be paried with gui_screen_switch_effect_setup().
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL gui_screen_smooth_scrolling_in_freerun(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN
    if (g_gui_ssp_state == GUI_LIST_SMOOTH_SCROLLING_BY_PEN_STATE_FREE_RUN 
        && (g_gui_list_menu_smooth_scrolling_menu_type == GUI_MENU_TYPE_ASYNCDYNAMIC ||
        g_gui_list_menu_smooth_scrolling_menu_type == GUI_MENU_TYPE_DYNAMIC ||
        g_gui_list_menu_smooth_scrolling_menu_type == GUI_MENU_TYPE_FIXED
#ifdef __MMI_FTE_SUPPORT__ 
        ||
        g_gui_list_menu_smooth_scrolling_menu_type == GUI_MENU_TYPE_INLINE
#endif
        ))
        return MMI_TRUE;
    else
        return MMI_FALSE;
#else
    return MMI_FALSE;
#endif
}

/*****************************************************************************
 * FUNCTION
 *  gui_screen_matrix_smooth_scrolling_in_freerun
 * DESCRIPTION
 *  Runs the screen switch effect. Must be paried with gui_screen_switch_effect_setup().
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL gui_screen_matrix_smooth_scrolling_in_freerun(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef GUI_MATRIX_MENU_SMOOTH_SCROLLING_BY_PEN
    if (g_gui_matrix_ssp_state == GUI_MATRIX_SMOOTH_SCROLLING_BY_PEN_STATE_FREE_RUN 
        && (g_gui_matrix_menu_smooth_scrolling_menu_type == GUI_MENU_TYPE_ASYNCDYNAMIC ||
        g_gui_matrix_menu_smooth_scrolling_menu_type == GUI_MENU_TYPE_DYNAMIC ||
        g_gui_matrix_menu_smooth_scrolling_menu_type == GUI_MENU_TYPE_FIXED))
        return MMI_TRUE;
    else
        return MMI_FALSE;
#else
    return MMI_FALSE;
#endif
}

/*****************************************************************************
 * FUNCTION
 *  gui_list_menu_smooth_scrolling_get_menu_type
 * DESCRIPTION
 *  Gets the current list menu type.
 * PARAMETERS
 *  void
 * RETURNS
 *  Current list menu type 
 *****************************************************************************/
static gui_menu_type_enum gui_list_menu_smooth_scrolling_get_menu_type(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    FuncPtr             key_down_hdlr;
    gui_menu_type_enum  menu_type;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    // TODO: should identify the menu type in the menu to be more specific

    /* identify the type by the down arrow handler because category 201 will override the up arrow key handler */
    key_down_hdlr = GetKeyHandler(KEY_DOWN_ARROW, KEY_EVENT_DOWN);

    if (key_down_hdlr == fixed_list_goto_next_item)
    {
        menu_type = GUI_MENU_TYPE_FIXED;
    }
    else if (key_down_hdlr == dynamic_list_goto_next_item)
    {
        menu_type = GUI_MENU_TYPE_DYNAMIC;
    }
    else if (key_down_hdlr == asyncdynamic_list_goto_next_item)
    {
        menu_type = GUI_MENU_TYPE_ASYNCDYNAMIC;   
    }
#ifdef __MMI_FTE_SUPPORT__ 
    else if (key_down_hdlr == inline_fixed_list_goto_next_item || MMI_fixed_list_menu.flags & UI_LIST_MENU_INLINE_EDIT)
    {
        menu_type = GUI_MENU_TYPE_INLINE;
    }
#endif
    else
    {
        menu_type = GUI_MENU_TYPE_INVALID;
    }

    return menu_type;
}


#if defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_KEY) || defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN)

/*****************************************************************************
 * FUNCTION
 *  gui_list_menu_smooth_scrolling_get_menu_item_height
 * DESCRIPTION
 *  Gets the menu item height
 * PARAMETERS
 *  void
 * RETURNS
 *  Menu item height
 *****************************************************************************/
static S32 gui_list_menu_smooth_scrolling_get_menu_item_height(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gui_common_menuitem_base_struct *m;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    m = (gui_common_menuitem_base_struct*)MMI_fixed_list_menu.common_item_data;
    MMI_ASSERT(m);
    
    return m->height;
}


/*****************************************************************************
 * FUNCTION
 *  gui_list_menu_smooth_scrolling_get_item
 * DESCRIPTION
 *  Gets the menu item object according to the current menu type.
 * PARAMETERS
 *  item_index       [IN]   menu item index
 * RETURNS
 *  Menu item object
 *****************************************************************************/
static void *gui_list_menu_smooth_scrolling_get_item(S32 item_index)
{    
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 first_item, item_num;
    S32 flags = 0;
    MMI_BOOL in_buffer = MMI_FALSE;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    switch (g_gui_list_menu_smooth_scrolling_menu_type)
    {
        case GUI_MENU_TYPE_FIXED:
#ifdef __MMI_FTE_SUPPORT__ 
        case GUI_MENU_TYPE_INLINE:
#endif
            return MMI_fixed_list_menu.items[item_index];
            
        case GUI_MENU_TYPE_DYNAMIC:
            if (MMI_fixed_list_menu.flags & UI_LIST_MENU_DISABLE_CACHE_DYNAMIC_DATA)
            {   /* special case for category 185 without caching */
                /* 
                 * leave one slot before the first displayed item for smooth scrolling up 
                 * Note that MMI_MAX_MENUITEMS_IN_CONTENT already keeps one additional slot.
                 */
                first_item = item_index;
                item_num = 1;

                /* 
                 * must call flush_dynamic_item_buffer_before_load_chunk() if caching is disabled;
                 * otherwise, load_chunk_dynamic_item_buffer() will assert.
                 */
                if (in_dynamic_item_buffer(item_index))
                {
                    flags = ((fixed_icontext_menuitem_type*)get_dynamic_item_from_buffer(item_index))->flags;
                    in_buffer = MMI_TRUE;
                }
                flush_dynamic_item_buffer_before_load_chunk();                
                load_chunk_dynamic_item_buffer(first_item, item_num);
                
                if (in_buffer == MMI_TRUE)
                {
                    ((fixed_icontext_menuitem_type*)get_dynamic_item_from_buffer(item_index))->flags = flags;
                }
                if (!gui_in_ssk && in_dynamic_item_buffer(MMI_fixed_list_menu.highlighted_item))
                {
                    ((fixed_icontext_menuitem_type*)get_dynamic_item_from_buffer(MMI_fixed_list_menu.highlighted_item))->flags
                        |= UI_MENUITEM_STATE_FOCUSSED;
                }

                /* make sure the item is loaded */
                MMI_ASSERT((item_index >= first_item) && (item_index <= first_item + item_num - 1));
            }
            else
            {   /* normal case with caching */
                /* make sure the item is in buffer. If not, load it. */         
                if (!in_dynamic_item_buffer(item_index))
                {
                    load_chunk_dynamic_item_buffer(item_index, 1);
                    if (item_index == MMI_fixed_list_menu.highlighted_item)
                    {
                        ((fixed_icontext_menuitem_type*)get_dynamic_item_from_buffer(item_index))->flags
                            |= UI_MENUITEM_STATE_FOCUSSED;
                    }
                }                    
            }
            
            return get_dynamic_item_from_buffer(item_index);        
            
        case GUI_MENU_TYPE_ASYNCDYNAMIC:
            /* make sure the item is in buffer. If not, load it. */
            if (!in_asyncdynamic_item_buffer(item_index))
            {
                /* possible asyncdynamic load item failures */
                if (!load_chunk_asyncdynamic_item_buffer(item_index, 1))
                {
                    if (MMI_fixed_list_menu.n_items > 0)
                    {
                        gui_asyncdynamic_list_error = 1;
                    }
                    
                    return NULL;
                }
                if (item_index == MMI_fixed_list_menu.highlighted_item)
                {
                    ((fixed_icontext_list_menuitem_type*)get_asyncdynamic_item_from_buffer(item_index))->flags
                        |= UI_MENUITEM_STATE_FOCUSSED;
                }
            }
            
            return get_asyncdynamic_item_from_buffer(item_index);
            
        default:
            break;
    }   

    return NULL;
}


/*****************************************************************************
 * FUNCTION
 *  gui_list_menu_smooth_scrolling_goto_item
 * DESCRIPTION
 *  Goes to an item according to the list menu type.
 * PARAMETERS
 *  item_index       [IN]   menu item index
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_list_menu_smooth_scrolling_goto_item(S32 item_index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (g_gui_list_menu_smooth_scrolling_menu_type)
    {
        case GUI_MENU_TYPE_FIXED:
            fixed_list_goto_item(item_index);
            break;
            
        case GUI_MENU_TYPE_DYNAMIC:
            dynamic_list_goto_item(item_index);
            break;
            
        case GUI_MENU_TYPE_ASYNCDYNAMIC:
            asyncdynamic_list_goto_item(item_index);
            break;            
            
#ifdef __MMI_FTE_SUPPORT__             
        case GUI_MENU_TYPE_INLINE:
            inline_fixed_list_goto_item(item_index, MMI_FALSE);
            break;
#endif
            
        default:
            break;
    }
}


static MMI_BOOL key_down_removed = MMI_FALSE;

/*****************************************************************************
 * FUNCTION
 *  gui_list_menu_smooth_scrolling_prev_exit_function
 * DESCRIPTION
 *  clean up function
 * PARAMETERS
 *  
 * RETURNS
 *  
 *****************************************************************************/
static void gui_list_menu_smooth_scrolling_prev_exit_function(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    key_down_removed = MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  gui_list_menu_smooth_scrolling_key_proc
 * DESCRIPTION
 *  key event proc for the list menu smooth scrolling.
 * PARAMETERS
 *  evt        : [IN]     key event
 * RETURNS
 *  MMI_RET_KEY_HANDLED: stop key event routing
 *  MMI_RET_OK: continue the key event routing 
 *****************************************************************************/
static mmi_ret  gui_list_menu_smooth_scrolling_key_proc(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_frm_key_evt_struct *key_evt = (mmi_frm_key_evt_struct *)evt;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (key_evt->evt_id == EVT_ID_PRE_KEY)
    {
        mmi_frm_set_key_info(key_evt->key_code, key_evt->key_type);
    #ifdef GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN
        gui_add_pre_cleanup_hook(gui_list_menu_smooth_scrolling_prev_exit_function);
        if (gui_screen_smooth_scrolling_in_freerun() && (key_evt->key_code != KEY_SEND) && (key_evt->key_code != KEY_END))
        {
            gui_ssp_pen_up_dummy();
            if (key_evt->key_type == KEY_EVENT_DOWN)
            {
                key_down_removed = MMI_TRUE;
            }
            return MMI_RET_KEY_HANDLED;
        }
        if (key_down_removed == MMI_TRUE)
        {
            if (key_evt->key_type == KEY_EVENT_UP)
            {
                key_down_removed = MMI_FALSE;
            }
            return MMI_RET_KEY_HANDLED;
        }
        gui_ssp_pen_up_dummy();
        //if (key_evt->key_code == KEY_LSK || key_evt->key_code == KEY_RSK)
        if (key_evt->key_code == KEY_LSK)
        {   
            if (g_gui_list_menu_smooth_scrolling_menu_type == GUI_MENU_TYPE_DYNAMIC)
            {
            #if defined(__MMI_CAT203_SUPPORT__) && defined(__MMI_FTE_SUPPORT__)
                /* for fixed MAUI_02632204 */
                if (!((g_dm_data.s32CatId == MMI_CATEGORY203_ID) && (MMI_fixed_list_menu.highlighted_item == -1)))
            #endif
                {
                    if (MMI_fixed_list_menu.n_items != 0 && !in_dynamic_item_buffer(MMI_fixed_list_menu.highlighted_item))
                        return MMI_RET_KEY_HANDLED;
                }
            }
            else if (g_gui_list_menu_smooth_scrolling_menu_type == GUI_MENU_TYPE_ASYNCDYNAMIC)
            {
                if (MMI_fixed_list_menu.n_items != 0 && !in_asyncdynamic_item_buffer(MMI_fixed_list_menu.highlighted_item))
                    return MMI_RET_KEY_HANDLED;
            }
        }
    #endif

    #ifdef GUI_LIST_MENU_SMOOTH_SCROLLING_BY_KEY
        if ((key_evt->key_type == KEY_EVENT_DOWN) || (key_evt->key_type == KEY_EVENT_REPEAT))
        {
            FuncPtr key_event_hdlr;
            MMI_BOOL no_voice_call = MMI_TRUE;
            
            key_event_hdlr = mmi_frm_get_key_handler(key_evt->key_code, KEY_EVENT_DOWN);

            /* 3G background call will use the volume keys for volume control. */
        #ifdef __MMI_UCM__
            no_voice_call = (srv_ucm_query_call_count(SRV_UCM_CALL_STATE_ALL, SRV_UCM_CALL_TYPE_ALL, NULL) == 0 ? MMI_TRUE : MMI_FALSE);
        #endif
            
            if ((key_evt->key_code == KEY_DOWN_ARROW) || 
                ((key_evt->key_code == KEY_VOL_DOWN) && no_voice_call))
            {
                if ((key_event_hdlr == fixed_list_goto_next_item) ||
                    (key_event_hdlr == dynamic_list_goto_next_item) ||
                    (key_event_hdlr == asyncdynamic_list_goto_next_item))
                {
                    gui_list_menu_smooth_scrolling_by_key(GUI_MENU_SMOOTH_SCROLL_DOWN);
                    
                    return MMI_RET_KEY_HANDLED;
                }                
            }
            else if ((key_evt->key_code == KEY_UP_ARROW) ||
                     ((key_evt->key_code == KEY_VOL_UP) && no_voice_call))
            {
                if ((key_event_hdlr == fixed_list_goto_previous_item) ||
                    (key_event_hdlr == dynamic_list_goto_previous_item) ||
                    (key_event_hdlr == asyncdynamic_list_goto_previous_item))
                {        
                    gui_list_menu_smooth_scrolling_by_key(GUI_MENU_SMOOTH_SCROLL_UP);
                
                    return MMI_RET_KEY_HANDLED;
                }
            }
        }
    #endif /* GUI_LIST_MENU_SMOOTH_SCROLLING_BY_KEY */
    }
    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  gui_list_menu_smooth_scrolling_show_item
 * DESCRIPTION
 *  Shows the specified menu item.
 * PARAMETERS
 *  item_index       [IN]   menu item index to be displayed
 *  x                [IN]   x
 *  y                [IN]   y
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_list_menu_smooth_scrolling_show_item(S32 item_index, S32 x, S32 y)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 old_current_index;    
    void * item;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* save current_displayed_item */
    MMI_fixed_list_menu.current_displayed_item = item_index;
    old_current_index = MMI_fixed_list_menu.current_displayed_item;
    if (item_index == MMI_fixed_list_menu.highlighted_item)
    {
        MMI_fixed_list_menu.current_displayed_item = -1;
    }
    else
    {
        MMI_fixed_list_menu.current_displayed_item = item_index;
    }

    /* display the menu item */
    item = gui_list_menu_smooth_scrolling_get_item(item_index);
    if (item)
    {   
        /* lock frame buffer because there might be item post display function calling blt */
        gdi_layer_lock_frame_buffer();

        MMI_fixed_list_menu.item_display_function(
            item,
            MMI_fixed_list_menu.common_item_data,
            x,
            y);

        gdi_layer_unlock_frame_buffer();

        /* restore current_displayed_item */
        MMI_fixed_list_menu.current_displayed_item = old_current_index;
    }
    else
    {
#if defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN) 
        gui_cancel_timer(gui_ssp_update_frame);        
#endif
    }
}


/*****************************************************************************
 * FUNCTION
 *  gui_list_menu_smooth_scrolling_register_stop_callback
 * DESCRIPTION
 *  Registers stop callback function for smooth scrolling to stop video or async image decoding
 * PARAMETERS
 *  stop_callback       [IN]    stop callback function
 * RETURNS
 *  void
 *****************************************************************************/
void gui_list_menu_smooth_scrolling_register_stop_callback(FuncPtr stop_callback)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_gui_list_menu_smooth_scrolling_stop_callback = stop_callback;    
}


#endif /* defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_KEY) || defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN) */
/*****************************************************************************
 * FUNCTION
 *  gui_list_effect_slide_is_highlight_item_two_line
 * DESCRIPTION
 *  Check if the current highlighted item is two-line.
 * PARAMETERS
 *  void
 * RETURNS
 *  0: single line. 1: two line.
 *****************************************************************************/
S32 gui_list_effect_slide_is_highlight_item_two_line(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32         old_display_index;
    S32         mi_width = 0, mi_height = 0;
    gui_common_menuitem_base_struct *m;
#if defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_KEY) || defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN)
    void* item;
#else
    FuncPtr     key_down_hdlr;
#endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    m = (gui_common_menuitem_base_struct*)(MMI_fixed_list_menu.common_item_data);
    old_display_index = MMI_fixed_list_menu.current_displayed_item;
    MMI_fixed_list_menu.current_displayed_item = -1;
    
#if defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_KEY) || defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN)
    item = gui_list_menu_smooth_scrolling_get_item(MMI_fixed_list_menu.highlighted_item);
    if (item)
    {   
        MMI_fixed_list_menu.item_measure_function(
        item,
        MMI_fixed_list_menu.common_item_data,           
        &mi_width,
        &mi_height);
    }
#else   /* GUI_LIST_MENU_SMOOTH_SCROLLING_BY_KEY || GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN || __MMI_LIST_MENU_SCROLL_WITHOUT_CHANGE_HIGHLIGHT__ */
    key_down_hdlr = GetKeyHandler(KEY_DOWN_ARROW, KEY_EVENT_DOWN);
    if (key_down_hdlr == dynamic_list_goto_next_item)
    {   
        MMI_fixed_list_menu.item_measure_function(
            NULL,
            MMI_fixed_list_menu.common_item_data,           
            &mi_width,
            &mi_height);
    }
    else if (key_down_hdlr == asyncdynamic_list_goto_next_item)
    {   
        MMI_fixed_list_menu.item_measure_function(
            NULL,
            MMI_fixed_list_menu.common_item_data,           
            &mi_width,
            &mi_height);
    }
    else
    {
        MMI_fixed_list_menu.item_measure_function(
            MMI_fixed_list_menu.items[MMI_fixed_list_menu.highlighted_item], 
            MMI_fixed_list_menu.common_item_data,           
            &mi_width,
            &mi_height);
    }
#endif  /* GUI_LIST_MENU_SMOOTH_SCROLLING_BY_KEY || GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN || __MMI_LIST_MENU_SCROLL_WITHOUT_CHANGE_HIGHLIGHT__ */

    MMI_fixed_list_menu.current_displayed_item = old_display_index;

    if (mi_height == m->height * 2)
    {
        return 1;
    }
    return 0;
}


/*****************************************************************************
 * FUNCTION
 *  gui_list_menu_is_highlight_item_two_line
 * DESCRIPTION
 *  Check if the current highlighted item is two-line.
 * PARAMETERS
 *  void
 * RETURNS
 *  0: single line. 1: two line.
 *****************************************************************************/
S32 gui_list_menu_is_highlight_item_two_line(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32         old_display_index;
    S32         mi_width, mi_height;
    gui_common_menuitem_base_struct *m;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_LIST_MENU_SCROLL_WITHOUT_CHANGE_HIGHLIGHT__
    if (MMI_fixed_list_menu.highlighted_item < MMI_fixed_list_menu.first_displayed_item ||
        MMI_fixed_list_menu.highlighted_item > MMI_fixed_list_menu.last_displayed_item)
    {
        return 0;
    }
#endif  /* __MMI_LIST_MENU_SCROLL_WITHOUT_CHANGE_HIGHLIGHT__ */
    m = (gui_common_menuitem_base_struct*)(MMI_fixed_list_menu.common_item_data);
    old_display_index = MMI_fixed_list_menu.current_displayed_item;
    MMI_fixed_list_menu.current_displayed_item = -1;
    
    MMI_fixed_list_menu.item_measure_function(
        NULL, 
        MMI_fixed_list_menu.common_item_data,           
        &mi_width,
        &mi_height);

    MMI_fixed_list_menu.current_displayed_item = old_display_index;

    if (mi_height == m->height * 2)
    {
        return 1;
    }
    return 0;
}


#if defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_KEY) || defined(__MMI_SCREEN_SWITCH_EFFECT__)

/*****************************************************************************
 * FUNCTION
 *  gui_effect_clear_blt_rect
 * DESCRIPTION
 *  Clears the blt union rect.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gui_effect_clear_blt_rect(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_lcd_freeze(TRUE);
    gdi_layer_blt_previous(0, 0, 0, 0);
    gdi_lcd_freeze(FALSE);
}


#endif /* defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_KEY) || defined(__MMI_SCREEN_SWITCH_EFFECT__) */


#ifdef GUI_LIST_MENU_SMOOTH_SCROLLING_BY_KEY

/*****************************************************************************
 * FUNCTION
 *  gui_list_menu_smooth_scrolling_draw_highlight_filler
 * DESCRIPTION
 *  Draws the highlight filler.
 * PARAMETERS
 *  x       [IN]    x
 *  y       [IN]    y
 *  w       [IN]    width
 *  h       [IN]    height
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_list_menu_smooth_scrolling_draw_highlight_filler(S32 x, S32 y, S32 width, S32 height)
{    
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gui_common_menuitem_base_struct *m;
    S32 ax, ay, count;    

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    // TODO: This function is a duplication of gui_list_effect_slide_draw_highlight_filler(). Should use a common function.
    m = (gui_common_menuitem_base_struct*)MMI_fixed_list_menu.common_item_data;

    gdi_layer_push_clip();    
    gdi_layer_set_clip(0, 0, width - 1, height - 1);
    
    gdi_layer_get_position(&ax, &ay);
    gdi_layer_set_position(x, y);
    if ((MMI_fixed_list_menu.flags & UI_LIST_MENU_DISABLE_SCROLLBAR) ||
        ((MMI_fixed_list_menu.flags & UI_LIST_MENU_AUTO_DISABLE_SCROLLBAR) && 
        (MMI_fixed_list_menu.displayed_items >= MMI_fixed_list_menu.n_items)))
    {
        gui_draw_filled_area(0, 0, width - 1, height - 1, m->focussed_without_sc_filler);
    }
    else
    {
        if (gblock_list_animation_highlight && m->focussed_filler->flags & UI_FILLED_AREA_TYPE_BITMAP 
            && m->focussed_filler->b)
        {
            gdi_image_get_frame_count(m->focussed_filler->b, &count);
            if (count >=1)
                gdi_image_draw_frames(0, 0, m->focussed_filler->b, count - 1);
            else
                gui_draw_filled_area(0, 0, width - 1, height - 1, m->focussed_filler);
        }
        else 
        {
            gui_draw_filled_area(0, 0, width - 1, height - 1, m->focussed_filler);
        }         
    }         
    gdi_layer_set_position(ax, ay);

    gdi_layer_pop_clip();
}


/*****************************************************************************
 * FUNCTION
 *  gui_list_menu_smooth_scrolling_goto_next_item
 * DESCRIPTION
 *  Goes to the next menu item according to the list menu type.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_list_menu_smooth_scrolling_goto_next_item(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (g_gui_list_menu_smooth_scrolling_menu_type)
    {
        case GUI_MENU_TYPE_FIXED:
            fixed_list_goto_next_item();
            break;
            
        case GUI_MENU_TYPE_DYNAMIC:
            dynamic_list_goto_next_item();
            break;
            
        case GUI_MENU_TYPE_ASYNCDYNAMIC:
            asyncdynamic_list_goto_next_item();
            break;            
            
#ifdef __MMI_FTE_SUPPORT__             
        case GUI_MENU_TYPE_INLINE:
            inline_fixed_list_goto_next_item();
            break;
#endif
            
        default:
            break;
    }       
}


/*****************************************************************************
 * FUNCTION
 *  gui_list_menu_smooth_scrolling_goto_previous_item
 * DESCRIPTION
 *  Goes to the previous menu item according to the list menu type.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_list_menu_smooth_scrolling_goto_previous_item(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (g_gui_list_menu_smooth_scrolling_menu_type)
    {
        case GUI_MENU_TYPE_FIXED:
            fixed_list_goto_previous_item();
            break;
            
        case GUI_MENU_TYPE_DYNAMIC:
            dynamic_list_goto_previous_item();
            break;
            
        case GUI_MENU_TYPE_ASYNCDYNAMIC:
            asyncdynamic_list_goto_previous_item();
            break;            
            
#ifdef __MMI_FTE_SUPPORT__             
        case GUI_MENU_TYPE_INLINE:
            inline_fixed_list_goto_previous_item();    
            break;
#endif
            
        default:
            break;
    }    
}



/*****************************************************************************
 * FUNCTION
 *  gui_effect_flatten
 * DESCRIPTION
 *  Flatten wrapper to make flattening with "output layer offset" easier.
 * PARAMETERS
 *  l0       [IN]   layer 0
 *  l1       [IN]   layer 1
 *  l2       [IN]   layer 2
 *  l3       [IN]   layer 3
 *  rect     [IN]   flatten rectangle
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_effect_flatten(
                gdi_handle l0, 
                gdi_handle l1,
                gdi_handle l2, 
                gdi_handle l3, 
                gui_rect *rect)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    gdi_layer_push_clip();    

    gdi_layer_set_clip(
        rect->x, 
        rect->y, 
        rect->x + rect->width - 1,
        rect->y + rect->height - 1);
        
    gdi_layer_flatten_with_clipping(l0, l1, l2, l3);
    
    gdi_layer_pop_clip();
}


/*****************************************************************************
 * FUNCTION
 *  gui_ssk_draw_incoming_menu_item
 * DESCRIPTION
 *  Draws the incoming menu item for AA fonts since AA fonts contain ALPHA pixels.
 * PARAMETERS
 *  object       [IN]   object 
 *  param        [IN]   object current parameter
 *  time         [IN]   object frame index
 *  layers       [IN]   layer handle of each object
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_ssk_draw_incoming_menu_item(gui_screen_switch_effect_object_struct *object, gui_screen_switch_effect_param_struct *param, S32 time, gdi_handle *layers)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gdi_handle act_layer;
    gui_rect rect;
    S32 item_width, item_height;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(param);
    UI_UNUSED_PARAMETER(object);
    UI_UNUSED_PARAMETER(time);
    UI_UNUSED_PARAMETER(layers);

    gdi_layer_clear(GDI_COLOR_TRANSPARENT);

    if (g_gui_ssk_incoming_item_index == MMI_fixed_list_menu.highlighted_item)
    {
        gdi_layer_get_active(&act_layer);
        
        GUI_RECT(rect, 0, 0, object->width, object->height);
        gui_effect_flatten(layers[0], layers[1], 0, 0, &rect);
        
        /* set the alpha blending source layer to the current menu layer */
        gdi_push_and_set_alpha_blending_source_layer(act_layer);
    }

#ifdef __MMI_UI_LIST_SCROLL_BY_PIXEL__
    gdi_layer_get_active(&act_layer);

    /* flatten the item rect */
    GUI_RECT(rect, 0, 0, object->width, object->height);
    gui_effect_flatten(layers[0], layers[1], 0, 0, &rect);

    /* set the alpha blending source layer to the current menu layer */
    gdi_push_and_set_alpha_blending_source_layer(act_layer);

    if (g_gui_ssk_incoming_item_index < MMI_fixed_list_menu.first_displayed_item)
    {   /* scroll up */
        if (MMI_fixed_list_menu.first_displayed_offset > 0)
        {
            MMI_fixed_list_menu.item_measure_function(
				gui_list_menu_smooth_scrolling_get_item(g_gui_ssk_incoming_item_index),
                MMI_fixed_list_menu.common_item_data, 
                &item_width, 
                &item_height);
            gui_list_menu_smooth_scrolling_show_item(g_gui_ssk_incoming_item_index, MMI_fixed_list_menu.highlight_x, -MMI_fixed_list_menu.first_displayed_offset);
            gui_list_menu_smooth_scrolling_show_item(g_gui_ssk_incoming_item_index + 1, MMI_fixed_list_menu.highlight_x, item_height - MMI_fixed_list_menu.first_displayed_offset);
        }
        else
        {
            gui_list_menu_smooth_scrolling_show_item(g_gui_ssk_incoming_item_index, MMI_fixed_list_menu.highlight_x, 0);
        }
    }
    else
    {   /* scroll down */
        if (MMI_fixed_list_menu.last_displayed_offset > 0)
        {
            MMI_fixed_list_menu.item_measure_function(
				gui_list_menu_smooth_scrolling_get_item(g_gui_ssk_incoming_item_index),
                MMI_fixed_list_menu.common_item_data, 
                &item_width, 
                &item_height);
            gui_list_menu_smooth_scrolling_show_item(g_gui_ssk_incoming_item_index - 1, MMI_fixed_list_menu.highlight_x, -MMI_fixed_list_menu.last_displayed_offset);
            gui_list_menu_smooth_scrolling_show_item(g_gui_ssk_incoming_item_index, MMI_fixed_list_menu.highlight_x, item_height - MMI_fixed_list_menu.last_displayed_offset);
        }
        else
        {
            gui_list_menu_smooth_scrolling_show_item(g_gui_ssk_incoming_item_index, MMI_fixed_list_menu.highlight_x, 0);
        }
    }
#else
    gui_list_menu_smooth_scrolling_show_item(g_gui_ssk_incoming_item_index, MMI_fixed_list_menu.highlight_x, 0);
#endif
    
    /* 
     * Clear the blt rect because some categories might use item display post callback and that will affect the world rect.
     * Since the frame buffer is locked, it is ok to do this.
     */

#ifdef __MMI_UI_LIST_SCROLL_BY_PIXEL__
    gdi_pop_and_restore_alpha_blending_source_layer();
#endif

    if (g_gui_ssk_incoming_item_index == MMI_fixed_list_menu.highlighted_item)
    {
        gdi_pop_and_restore_alpha_blending_source_layer();
    }

    gdi_layer_blt_previous(0, 0, 0, 0);
}


#ifdef GDI_6_LAYERS

/*****************************************************************************
 * FUNCTION
 *  gui_ssk_draw_outgoing_menu_item
 * DESCRIPTION
 *  Draws the outgoing menu item for AA fonts since AA fonts contain ALPHA pixels.
 * PARAMETERS
 *  object       [IN]   object 
 *  param        [IN]   object current parameter
 *  time         [IN]   object frame index
 *  layers       [IN]   layer handle of each object
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_ssk_draw_outgoing_menu_item(gui_screen_switch_effect_object_struct *object, gui_screen_switch_effect_param_struct *param, S32 time, gdi_handle *layers)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#ifdef  __MMI_FTE_SUPPORT__
    S32 ax, ay, y_off = 0, i;
#endif
#if defined(__MMI_FTE_SUPPORT__) || defined(__MMI_UI_LIST_SCROLL_BY_PIXEL__)
    S32 item_width, item_height;
#endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(param);
    UI_UNUSED_PARAMETER(object);
    UI_UNUSED_PARAMETER(time);
    UI_UNUSED_PARAMETER(layers);

    gdi_layer_clear(GDI_COLOR_TRANSPARENT);

#ifdef __MMI_UI_LIST_SCROLL_BY_PIXEL__
    if (g_gui_ssk_incoming_item_index < MMI_fixed_list_menu.first_displayed_item)
    {   /* scroll up */
        if (MMI_fixed_list_menu.last_displayed_offset > 0)
        {
            MMI_fixed_list_menu.item_measure_function(
				gui_list_menu_smooth_scrolling_get_item(g_gui_ssk_outgoing_item_index),
                MMI_fixed_list_menu.common_item_data, 
                &item_width, 
                &item_height);
            gui_list_menu_smooth_scrolling_show_item(g_gui_ssk_outgoing_item_index - 1, MMI_fixed_list_menu.highlight_x, -MMI_fixed_list_menu.last_displayed_offset);
            gui_list_menu_smooth_scrolling_show_item(g_gui_ssk_outgoing_item_index, MMI_fixed_list_menu.highlight_x, item_height - MMI_fixed_list_menu.last_displayed_offset);
        }
        else
        {
            gui_list_menu_smooth_scrolling_show_item(g_gui_ssk_outgoing_item_index, MMI_fixed_list_menu.highlight_x, 0);
        }
    }
    else
    {   /* scroll down */
        if (MMI_fixed_list_menu.first_displayed_offset > 0)
        {
            MMI_fixed_list_menu.item_measure_function(
				gui_list_menu_smooth_scrolling_get_item(g_gui_ssk_outgoing_item_index),
                MMI_fixed_list_menu.common_item_data, 
                &item_width, 
                &item_height);
            gui_list_menu_smooth_scrolling_show_item(g_gui_ssk_outgoing_item_index, MMI_fixed_list_menu.highlight_x, -MMI_fixed_list_menu.first_displayed_offset);
            gui_list_menu_smooth_scrolling_show_item(g_gui_ssk_outgoing_item_index + 1, MMI_fixed_list_menu.highlight_x, item_height - MMI_fixed_list_menu.first_displayed_offset);
        }
        else
        {
            gui_list_menu_smooth_scrolling_show_item(g_gui_ssk_outgoing_item_index, MMI_fixed_list_menu.highlight_x, 0);
        }
    }
#else
    gui_list_menu_smooth_scrolling_show_item(g_gui_ssk_outgoing_item_index, MMI_fixed_list_menu.highlight_x, 0);
#endif

    /* 
     * Clear the blt rect because some categories might use item display post callback and that will affect the world rect.
     * Since the frame buffer is locked, it is ok to do this.
     */

#ifdef __MMI_FTE_SUPPORT__        
    {
        gdi_handle act_layer;
        gui_push_clip();
        if (mmi_fe_get_r2l_state())
        {
            gdi_layer_set_clip(
                MMI_fixed_list_menu.x, 
                0, 
                MMI_fixed_list_menu.x + MMI_fixed_list_menu.vbar.width - 1, 
                MMI_fixed_list_menu.height - 1);
        }
        else
        {
            gdi_layer_set_clip(
                MMI_fixed_list_menu.x + MMI_fixed_list_menu.width - 1 - MMI_fixed_list_menu.vbar.width, 
                0, 
                MMI_fixed_list_menu.x + MMI_fixed_list_menu.width - 1, 
                MMI_fixed_list_menu.height - 1);
       }
        /* menu height might be larger than normal one. Prevent the scrollbar mismatch when going back to the normal menu */
        
        gdi_layer_get_active(&act_layer);
        if (dm_get_scr_bg_layer() != GDI_ERROR_HANDLE)
        {
            gdi_layer_flatten_with_clipping(dm_get_scr_bg_layer(), act_layer, 0, 0);
        }
        
        gui_enable_scrollbar_redraw_clip(MMI_FALSE);
        gui_vertical_scrollbar_set_target_layer(&MMI_fixed_list_menu.vbar, act_layer);
        gui_vertical_scrollbar_set_alpha_blend_layer(&MMI_fixed_list_menu.vbar, act_layer);

        gdi_layer_get_position(&ax, &ay);
        if (MMI_fixed_list_menu.flags & UI_LIST_MENU_INLINE_EDIT)
        {
            for (i = MMI_fixed_list_menu.first_displayed_item; i < g_gui_ssk_outgoing_item_index; i ++)
            {
                MMI_fixed_list_menu.item_measure_function(
                    MMI_fixed_list_menu.items[i], 
                    MMI_fixed_list_menu.common_item_data, 
                    &item_width, 
                    &item_height);
                y_off += item_height;
            }
        }
        else
        {
            item_height = gui_list_menu_smooth_scrolling_get_menu_item_height();
            y_off = item_height * (g_gui_ssk_outgoing_item_index - MMI_fixed_list_menu.first_displayed_item);
            if (gui_list_menu_is_highlight_item_two_line())
            {
                y_off += item_height;
            }
        }
        gdi_layer_set_position(MMI_fixed_list_menu.highlight_x, MMI_fixed_list_menu.y + y_off);
        gui_show_vertical_scrollbar(&MMI_fixed_list_menu.vbar);
        gdi_layer_set_position(ax, ay);
        gui_vertical_scrollbar_set_target_layer(&MMI_fixed_list_menu.vbar, MMI_fixed_list_menu.act_layer_handle);
        gui_vertical_scrollbar_set_alpha_blend_layer(&MMI_fixed_list_menu.vbar, MMI_fixed_list_menu.act_layer_handle);
        gui_enable_scrollbar_redraw_clip(MMI_TRUE);
        gui_pop_clip();
    }   
#endif  // __MMI_FTE_SUPPORT__

    gdi_layer_blt_previous(0, 0, 0, 0);
}

#endif /* GDI_6_LAYERS */


/*****************************************************************************
 * FUNCTION
 *  gui_ssk_draw_old_menu_items
 * DESCRIPTION
 *  Draws the old menu items for AA fonts since AA fonts contain ALPHA pixels.
 * PARAMETERS
 *  object       [IN]   object 
 *  param        [IN]   object current parameter
 *  time         [IN]   object frame index
 *  layers       [IN]   layer handle of each object
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_ssk_draw_old_menu_items(gui_screen_switch_effect_object_struct *object, gui_screen_switch_effect_param_struct *param, S32 time, gdi_handle *layers)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 menuitem_over_highlight_start_index;
    S32 start_index;
    S32 i;
    gdi_handle act_layer, old_src_layer;
    S32 item_height;
    S32 x, y;
    S32 item_num;
    gui_rect rect;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(time);

    gdi_layer_lock_frame_buffer();
        
    gdi_layer_get_active(&act_layer);
    gdi_layer_clear(GDI_COLOR_TRANSPARENT);

    start_index = MMI_fixed_list_menu.first_displayed_item;
    x = MMI_fixed_list_menu.highlight_x;
    
    if (g_gui_ssk_incoming_item_index < MMI_fixed_list_menu.first_displayed_item)
    {   /* scroll up */
        menuitem_over_highlight_start_index = MMI_fixed_list_menu.first_displayed_item;
    }
    else
    {   /* scroll down */
        menuitem_over_highlight_start_index = MMI_fixed_list_menu.highlighted_item;

    #ifdef GDI_6_LAYERS
        /* skip the outgoing item */
        start_index++;
    #endif /* GDI_6_LAYERS */        
    }
    
    item_height = gui_list_menu_smooth_scrolling_get_menu_item_height();
    item_num = MMI_fixed_list_menu.displayed_items;
#ifdef GDI_6_LAYERS
    /* exclude the outgoing item */
    item_num--;
#endif /* GDI_6_LAYERS */

    gdi_get_alpha_blending_source_layer(&old_src_layer);

    for (i = start_index; i < start_index + item_num; i++)
    {   
        y = (i - start_index) * item_height;
#ifdef __MMI_UI_LIST_SCROLL_BY_PIXEL__
        y -= MMI_fixed_list_menu.first_displayed_offset;
#endif

        /* must flatten lower layers up because there is a highlight layer underneath */
        if ((i == menuitem_over_highlight_start_index) || (i == menuitem_over_highlight_start_index + 1)
            || (i == MMI_fixed_list_menu.highlighted_item - 1))
        {
            /* flatten the item rect */
            GUI_RECT(rect, 0, y, object->width, item_height);
            gui_effect_flatten(layers[0], layers[1], 0, 0, &rect);

            /* set the alpha blending source layer to the current menu layer */
            gdi_set_alpha_blending_source_layer(act_layer);
        }
            
        gui_list_menu_smooth_scrolling_show_item(i, MMI_fixed_list_menu.highlight_x, y);            
#ifdef __MMI_UI_LIST_GRID_LINE__  
        if (y < MMI_fixed_list_menu.y + MMI_fixed_list_menu.height)
        {
            U32 ret_flag = 0;
            U32 ret_flag_ext = 0;
            if (g_gui_list_get_menuitem_flags && (i >= 0))
            {
                g_gui_list_get_menuitem_flags(i, &ret_flag, &ret_flag_ext);
            }

            if (!(ret_flag_ext & UI_MENUITEM_EXT_SHOW_DOWN_SEPARATORLINE))
            {
                gdi_effect_alpha_blending_rect(
                    old_src_layer,
                    x, 
                    y, 
                    x + object->width - 1,
                    y,
                    current_MMI_theme->list_grid_line_alpha * 255 / 100,
                    current_MMI_theme->list_grid_line_color->r,
                    current_MMI_theme->list_grid_line_color->g,
                    current_MMI_theme->list_grid_line_color->b);
            }      
        }      
#endif /* __MMI_UI_LIST_GRID_LINE__ */
        gdi_set_alpha_blending_source_layer(old_src_layer);
    }
#ifdef __MMI_FTE_SUPPORT__        
    {
        gdi_handle layers[4];
        gui_push_clip();
        if (mmi_fe_get_r2l_state())
        {
            gdi_layer_set_clip(
                MMI_fixed_list_menu.x, 
                0, 
                MMI_fixed_list_menu.x + MMI_fixed_list_menu.vbar.width - 1, 
                MMI_fixed_list_menu.height - 1);
        }
        else
        {
            gdi_layer_set_clip(
                MMI_fixed_list_menu.x + MMI_fixed_list_menu.width - 1 - MMI_fixed_list_menu.vbar.width, 
                0, 
                MMI_fixed_list_menu.x + MMI_fixed_list_menu.width - 1, 
                MMI_fixed_list_menu.height - 1);
       }
        /* menu height might be larger than normal one. Prevent the scrollbar mismatch when going back to the normal menu */
        
        gdi_layer_get_blt_layer(&layers[0], &layers[1], &layers[2], &layers[3]);
        if (wgui_is_wallpaper_on_bottom() && layers[0] != dm_get_scr_bg_layer())
        {
            gdi_layer_flatten_with_clipping(dm_get_scr_bg_layer(), act_layer, 0, 0);
        }
        else
        {
            gdi_layer_flatten_with_clipping(layers[0], act_layer, 0, 0);
        }
        gui_enable_scrollbar_redraw_clip(MMI_FALSE);
        gui_show_vertical_scrollbar(&MMI_fixed_list_menu.vbar);
        gui_enable_scrollbar_redraw_clip(MMI_TRUE);
        gui_pop_clip();
    }   
#endif

    gdi_layer_unlock_frame_buffer();

    /* 
     * Clear the blt rect because some categories might use item display post callback and that will affect the world rect.
     * Since the frame buffer is locked, it is ok to do this.
     */
    gdi_layer_blt_previous(0, 0, 0, 0);
}


extern MMI_BOOL g_gui_screen_switch_effect_is_to_clear_key;
extern MMI_BOOL g_gui_screen_switch_effect_enable_early_key_break;
extern S32 g_gui_screen_switch_effect_frames;
extern S32 g_gui_screen_switch_effect_frame_duration;
extern gui_rect g_gui_screen_switch_effect_world_view_rect;
extern gui_screen_switch_effect_param_struct g_gui_screen_switch_effect_object_param[GUI_SCREEN_SWITCH_EFFECT_MAX_OBJECT_NUM][GUI_SCREEN_SWITCH_EFFECT_MAX_FRAME_NUM];
extern gui_screen_switch_effect_object_struct g_gui_screen_switch_effect_object[GUI_SCREEN_SWITCH_EFFECT_MAX_OBJECT_NUM];

extern void gui_screen_switch_effect_create_world(void);
extern void gui_screen_switch_effect_create_object(gui_screen_switch_effect_object_struct *object, S32 id, S32 width, S32 height, S32 bpp, S32 z, PU8 buf, gui_screen_switch_effect_object_get_param_funcptr get_param_callback);
extern void gui_screen_switch_effect_create_object_layer(gui_screen_switch_effect_object_struct *object, gdi_handle *layer);
extern void gui_screen_switch_effect_close_world(void);
extern void gui_screen_switch_effect_register_finish_callback(gui_screen_switch_effect_finish_callback_funcptr_type finish_callback);
extern void gui_screen_switch_effect_object_get_param_callback(gui_screen_switch_effect_object_struct *object, gui_screen_switch_effect_param_struct *param, S32 time);

#ifdef  __MMI_GUI_LIST_MENU_SSK_OPTIMIZE__
/*****************************************************************************
 * FUNCTION
 *  gui_list_menu_draw_grid_line
 * DESCRIPTION
 *  the optimize function for draw grid line in ssk progress.
 * PARAMETERS
 *  src_layer_handle       [IN]     the layer handler which grid line drawn on
 *  index                  [IN]     the index of the menuitem
 *  x                      [IN]     the x position of the grid line
 *  width                  [IN]     the width of the grid line
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_list_menu_draw_grid_line(gdi_handle src_layer_handle, S32 index, S32 x, S32 y, S32 width)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 ret_flag, ret_flag_ext = 0;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_gui_list_get_menuitem_flags && (index >= 0))
    {
        g_gui_list_get_menuitem_flags(index, &ret_flag, &ret_flag_ext);
    }
    
    if (!(ret_flag_ext & UI_MENUITEM_EXT_SHOW_DOWN_SEPARATORLINE))
    {
        gdi_effect_alpha_blending_rect(
            src_layer_handle,
            x, 
            y, 
            x + width - 1,
            y,
            current_MMI_theme->list_grid_line_alpha * 255 / 100,
            current_MMI_theme->list_grid_line_color->r,
            current_MMI_theme->list_grid_line_color->g,
            current_MMI_theme->list_grid_line_color->b);
    }
}


/*****************************************************************************
 * FUNCTION
 *  gui_list_menu_draw_highlight_filler
 * DESCRIPTION
 *  draw the highlight filler of list menu in SSK progress
 * PARAMETERS
 *  m   [IN]    the common menuitem structure
 *  x1  [IN]    the left x position of highlight filler
 *  y1  [IN]    the top y position of highlight filler
 *  x2  [IN]    the right position of highlight filler
 *  y2  [IN]    the bottom position of highlight filler
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_list_menu_draw_highlight_filler(gui_common_menuitem_base_struct *m, S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 count;

    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    if ((MMI_fixed_list_menu.flags & UI_LIST_MENU_DISABLE_SCROLLBAR) ||
        ((MMI_fixed_list_menu.flags & UI_LIST_MENU_AUTO_DISABLE_SCROLLBAR) && 
        (MMI_fixed_list_menu.displayed_items >= MMI_fixed_list_menu.n_items)))
    {
        gui_draw_filled_area(x1, y1, x2, y2, m->focussed_without_sc_filler);
    }
    else
    {
        if (gblock_list_animation_highlight && m->focussed_filler->flags & UI_FILLED_AREA_TYPE_BITMAP 
            && m->focussed_filler->b)
        {
            gdi_image_get_frame_count(m->focussed_filler->b, &count);
            if (count >=1)
                gdi_image_draw_frames(x1, y1, m->focussed_filler->b, count - 1);
            else
                gui_draw_filled_area(x1, y1, x2, y2, m->focussed_filler);
        }
        else 
        {
            gui_draw_filled_area(x1, y1, x2, y2, m->focussed_filler);
        }         
    }         
}
#endif  // __MMI_GUI_LIST_MENU_SSK_OPTIMIZE__


/*****************************************************************************
 * FUNCTION
 *  gui_list_menu_smooth_scrolling_by_key
 * DESCRIPTION
 *  Smooth scrolling effect invoked by key inputs.
 * PARAMETERS
 *  direction       [IN]    scroll direction
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_list_menu_smooth_scrolling_by_key(gui_menu_scroll_direction_enum direction)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32         i;
    fixed_list_menu     *list_menu;
    gui_common_menuitem_base_struct *m;
    S32         move_range;
    gdi_handle  scr_bg_layer;
    S32         offset_y;
    S32         new_menuitem_index;
    S32         highlighted_item_x, highlighted_item_y, menu_y2; 
    
    MMI_BOOL    support_sms;

    S32         first_displayed_item_index, highlighted_item_index;
    
    
#ifndef __MMI_GUI_LIST_MENU_SSK_OPTIMIZE__
    gui_screen_switch_effect_param_struct *param;
#ifdef __MMI_SCREEN_SWITCH_EFFECT__    
    gui_effect_memory_manager_struct   mem_pool;
#endif
    PU8         menu_highlight_buf_p, new_menu_item_buf_p;
    PU8         base_layer_buf_p, scr_bg_buf_p;
    gdi_handle  main_base_layer, new_menuitem_layer, highlight_layer;
    S32         main_base_layer_bpp, main_base_layer_line_jump_bytes;
    S32         old_menu_y, old_menu_height;
    S32         scr_bpp;
#endif
    S32         menu_height;
#if defined (__MMI_UI_LIST_SKIP_DISABLED__)
    U32         flags = 0, flags_ext = 0, n = 0;
#endif
    
#ifdef GDI_6_LAYERS
    PU8         scrolled_out_item_buf_p;
#endif /* GDI_6_LAYERS */
    void  *item;
    
    void  *med_mem_p = NULL;
#ifdef  __MMI_GUI_LIST_MENU_SSK_OPTIMIZE__
    S32 outgoing_item_index, incoming_item_index, start_display_item_index, end_display_item_index, menuitem_over_highlight_start_index;
    S32  x1, x2, y1, y2, item_x, item_y, item_width, item_height, next_timer_duration, j;
    S32 menu_item_layer_buf_size;
    U32 start_time, end_time, elapsed_ms;
    PU8 menu_item_layer_buf = NULL, incoming_layer_buf = NULL;
    gdi_handle menu_item_layer, incoming_layer, act_layer, src_layer_handle, layers[4];
#endif  // __MMI_GUI_LIST_MENU_SSK_OPTIMIZE__
#if defined(__MMI_SCREEN_SWITCH_EFFECT__)
    S32 buf_size;
#endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (MMI_fixed_list_menu.highlighted_item == GUI_LIST_MENU_ALL_ITEMS_ARE_DISABLE)
    {
        return;
    }
    
    menu_y2 = MMI_fixed_list_menu.y + MMI_fixed_list_menu.height - 1;    
    list_menu = &MMI_fixed_list_menu;  
    if (list_menu->n_items <= 0)
    {
        return;
    }
    m = (gui_common_menuitem_base_struct*)list_menu->common_item_data;
    
#ifdef  __MMI_GUI_LIST_MENU_SSK_OPTIMIZE__
    item_width  = m->width;
    item_height = m->height;
    move_range  = m->height;
#endif    
    
    scr_bg_layer = dm_get_scr_bg_layer();
    support_sms = gui_list_menu_is_support_smooth_scrolling();
    gui_in_ssk = MMI_TRUE;

    menu_height = list_menu->displayed_items * m->height;
    if (gui_list_menu_is_highlight_item_two_line())
    {
        menu_height += m->height;
    }
    
    /* Only do the smooth scrolling at the boundary item. (first + 1 or last - 1); Otherwise, go normal way. */
    if (direction == GUI_MENU_SMOOTH_SCROLL_DOWN)
    {
#ifdef  __MMI_GUI_LIST_MENU_SSK_OPTIMIZE__
        outgoing_item_index = list_menu->first_displayed_item;
#endif
#ifdef __MMI_UI_LIST_SCROLL_BY_PIXEL__
        if ((!support_sms) || 
            !((list_menu->highlighted_item == list_menu->last_displayed_item - 1) &&
            (list_menu->last_displayed_item != list_menu->n_items - 1) &&
            (list_menu->displayed_items < list_menu->n_items)))
        {
            gui_in_ssk = MMI_FALSE;
            gui_list_menu_smooth_scrolling_goto_next_item();
            return;
        }
#ifdef  __MMI_GUI_LIST_MENU_SSK_OPTIMIZE__
        incoming_item_index = list_menu->last_displayed_item + 1;
#endif
#else /* __MMI_UI_LIST_SCROLL_BY_PIXEL__ */
        if (list_menu->height > menu_height + (m->height / 3))
        {
            if ((!support_sms) || 
                !((list_menu->highlighted_item == list_menu->last_displayed_item) &&
                (list_menu->last_displayed_item != list_menu->n_items - 1) &&
                (list_menu->displayed_items < list_menu->n_items)))
            {
                gui_in_ssk = MMI_FALSE;
                gui_list_menu_smooth_scrolling_goto_next_item();
                return;
            }
            
#ifdef  __MMI_GUI_LIST_MENU_SSK_OPTIMIZE__
            incoming_item_index = list_menu->last_displayed_item;
#endif
        }
        else
        {
            if (!support_sms ||
            !((list_menu->highlighted_item == list_menu->last_displayed_item - 1) &&
              (list_menu->last_displayed_item != list_menu->n_items - 1) &&
              (list_menu->displayed_items < list_menu->n_items)))
            {
                gui_in_ssk = MMI_FALSE;
                gui_list_menu_smooth_scrolling_goto_next_item();
                return;
            }

#ifdef  __MMI_GUI_LIST_MENU_SSK_OPTIMIZE__
            incoming_item_index = list_menu->last_displayed_item + 1;
#endif
        }
#endif /* __MMI_UI_LIST_SCROLL_BY_PIXEL__ */
    }
    else
    {
        if (!support_sms || 
            !((list_menu->highlighted_item == list_menu->first_displayed_item + 1) &&
              (list_menu->first_displayed_item != 0) &&
              (list_menu->displayed_items < list_menu->n_items)))
        {
            gui_in_ssk = MMI_FALSE;
            gui_list_menu_smooth_scrolling_goto_previous_item();
            return;
        }
#ifdef  __MMI_GUI_LIST_MENU_SSK_OPTIMIZE__
        incoming_item_index = list_menu->first_displayed_item - 1;
        outgoing_item_index = list_menu->last_displayed_item;
#endif        
    }

#ifdef  __MMI_GUI_LIST_MENU_SSK_OPTIMIZE__    
    x1 = list_menu->x;
    y1 = list_menu->y;
    x2 = list_menu->x + list_menu->width - 1;
    y2 = list_menu->y + list_menu->height - 1;
    
    highlighted_item_x = list_menu->highlight_x;
    highlighted_item_y = list_menu->highlight_y;

    gdi_layer_push_and_set_active(list_menu->act_layer_handle);
    gdi_layer_push_clip();
    gdi_layer_set_clip(x1, y1, x2, y2);

    /* remove the highlight from the highlighted item and redraw */           
    item = gui_list_menu_smooth_scrolling_get_item(list_menu->highlighted_item);
    if (item)
    {
        list_menu->item_remove_highlight_function(item, m);
    }

    if (incoming_item_index > outgoing_item_index)
    {
        start_display_item_index = outgoing_item_index;
        end_display_item_index = incoming_item_index;
    }
    else
    {
        start_display_item_index = incoming_item_index;
        end_display_item_index = outgoing_item_index;
    }

    if (direction == GUI_MENU_SMOOTH_SCROLL_DOWN)
    {
        end_display_item_index = list_menu->highlighted_item - 1;
    }
    else
    {
        start_display_item_index = list_menu->highlighted_item + 1;
    }

    // draw all old item in a seperator layer
#ifdef  __MMI_FTE_SUPPORT__
    menu_item_layer_buf_size = UI_DEVICE_WIDTH * (list_menu->height - item_height) * GUI_EFFECT_LAYER_BYTE_PER_PIXEL;
    menu_item_layer_buf = (U8*) mmi_frm_scrmem_alloc_framebuffer(menu_item_layer_buf_size);
    gdi_layer_create_cf_using_outside_memory(
        GUI_SCREEN_SWITCH_EFFECT_LAYER_COLOR_FORMAT,
        0,
        0,
        UI_DEVICE_WIDTH,
        list_menu->height - item_height,
        &menu_item_layer,
        menu_item_layer_buf,
        menu_item_layer_buf_size);

    // TODO: menu_item_layer may not fully display start_display_item_index to end_display_item_index
    // draw all the items in menu_item_layer
    gdi_layer_push_and_set_active(menu_item_layer);
    gdi_layer_reset_clip();
    gdi_layer_set_source_key(TRUE, GDI_COLOR_TRANSPARENT);
    gdi_layer_clear(GDI_COLOR_TRANSPARENT);

    item_x = highlighted_item_x;
    item_y = 0;
    
    gdi_get_alpha_blending_source_layer(&src_layer_handle);
    
    if (incoming_item_index < MMI_fixed_list_menu.first_displayed_item)
    {   /* scroll up */
        menuitem_over_highlight_start_index = MMI_fixed_list_menu.first_displayed_item;
    }
    else
    {   /* scroll down */
        menuitem_over_highlight_start_index = MMI_fixed_list_menu.highlighted_item;
    }
    
    for (i = start_display_item_index; i <= end_display_item_index; i++)
    {
        if ((i == menuitem_over_highlight_start_index) ||
            (i == menuitem_over_highlight_start_index + 1))
        {
            continue;
        }
        
        if (i == MMI_fixed_list_menu.highlighted_item)
            MMI_fixed_list_menu.current_displayed_item = -1;
        else
            MMI_fixed_list_menu.current_displayed_item = i;
        
        item = gui_list_menu_smooth_scrolling_get_item(i);
        if (item)
        {
            MMI_fixed_list_menu.item_measure_function(
                item, 
                MMI_fixed_list_menu.common_item_data,&item_width, &item_height);        
        }

        
        gui_list_menu_smooth_scrolling_show_item(i, item_x, item_y);

#ifdef __MMI_UI_LIST_GRID_LINE__  
        if (item_y < MMI_fixed_list_menu.y + MMI_fixed_list_menu.height)
        {
//	            gui_list_menu_draw_grid_line(src_layer_handle, i, item_x, item_y, item_width);
        }      
#endif /* __MMI_UI_LIST_GRID_LINE__ */

        item_y += item_height;
    }
    
    gdi_layer_pop_and_restore_active();

    // draw outgoing menu item
    menu_item_layer_buf_size = UI_DEVICE_WIDTH * move_range * GUI_EFFECT_LAYER_BYTE_PER_PIXEL;
    incoming_layer_buf = (U8*) mmi_frm_scrmem_alloc_framebuffer(menu_item_layer_buf_size);
    gdi_layer_create_cf_using_outside_memory(
        GUI_SCREEN_SWITCH_EFFECT_LAYER_COLOR_FORMAT,
        0,
        0,
        UI_DEVICE_WIDTH,
        move_range,
        &incoming_layer,
        incoming_layer_buf,
        menu_item_layer_buf_size);
    
    gdi_layer_push_and_set_active(incoming_layer);
    gdi_layer_reset_clip();
    gdi_layer_set_source_key(TRUE, GDI_COLOR_TRANSPARENT);
    gdi_layer_clear(GDI_COLOR_TRANSPARENT);
    gui_list_menu_smooth_scrolling_show_item(incoming_item_index, item_x, 0);
    gdi_layer_pop_and_restore_active();
#endif  // __MMI_FTE_SUPPORT__

    gdi_layer_get_blt_layer(&layers[0], &layers[1], &layers[2], &layers[3]);
    gdi_layer_get_active(&act_layer);
    
    for (i = 0; i < g_gui_screen_switch_effect_frames; i++)
    {
        const S32 offset_story[GUI_LIST_MENU_SMOOTH_SCROLLING_BY_KEY_FRAME_NUM] = 
        {
            GUI_SCREEN_SWITCH_EFFECT_FIXED_POINT(0.5),
            GUI_SCREEN_SWITCH_EFFECT_FIXED_POINT(0.75),
            GUI_SCREEN_SWITCH_EFFECT_FIXED_POINT(0.90),
            GUI_SCREEN_SWITCH_EFFECT_FIXED_POINT(0.96),
            GUI_SCREEN_SWITCH_EFFECT_FIXED_POINT(1)
        };
        
        offset_y = GUI_SCREEN_SWITCH_EFFECT_FIXED_POINT_MUL(move_range, offset_story[i]);
        
        gdi_layer_lock_frame_buffer();
        
        kal_get_time(&start_time);
        
        // clear the background of list menu
        gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_TRANSPARENT);
        
        // draw highlight filler
        gui_list_menu_draw_highlight_filler(
            m, 
            highlighted_item_x, 
            highlighted_item_y, 
            highlighted_item_x + item_width - 1, 
            highlighted_item_y + item_height - 1);

        //draw 2 over highlight filler item
        item_y = MMI_fixed_list_menu.y + item_height * (start_display_item_index - MMI_fixed_list_menu.first_displayed_item);
        if (direction == GUI_MENU_SMOOTH_SCROLL_DOWN)
        {
            item_y -= offset_y;
            gui_list_menu_smooth_scrolling_show_item(
                menuitem_over_highlight_start_index, 
                highlighted_item_x, highlighted_item_y - offset_y);
            
            gui_list_menu_draw_grid_line(
                src_layer_handle, 
                menuitem_over_highlight_start_index, 
                highlighted_item_x, 
                highlighted_item_y - offset_y, 
                item_width);
            
            gui_list_menu_smooth_scrolling_show_item(
                menuitem_over_highlight_start_index + 1, 
                highlighted_item_x, highlighted_item_y + move_range - offset_y);
            gui_list_menu_draw_grid_line(
                src_layer_handle, 
                menuitem_over_highlight_start_index + 1, 
                highlighted_item_x, 
                highlighted_item_y + move_range - offset_y, 
                item_width);
        }
        else
        {
            item_y += offset_y;
            gui_list_menu_smooth_scrolling_show_item(
                menuitem_over_highlight_start_index, 
                highlighted_item_x, highlighted_item_y - move_range + offset_y);
            
            gui_list_menu_draw_grid_line(
                src_layer_handle, 
                menuitem_over_highlight_start_index, 
                highlighted_item_x, 
                highlighted_item_y - move_range + offset_y, 
                item_width);

            gui_list_menu_smooth_scrolling_show_item(
                menuitem_over_highlight_start_index + 1, 
                highlighted_item_x, highlighted_item_y + offset_y);
            gui_list_menu_draw_grid_line(
                src_layer_handle, 
                menuitem_over_highlight_start_index + 1, 
                highlighted_item_x, 
                highlighted_item_y + offset_y, 
                item_width);
        }    

        // draw grid line
        for (j = start_display_item_index; j <= end_display_item_index; j++)
        {
            if ((j == menuitem_over_highlight_start_index) ||
                (j == menuitem_over_highlight_start_index + 1))
            {
                continue;
            }
            
            if (j == MMI_fixed_list_menu.highlighted_item)
                MMI_fixed_list_menu.current_displayed_item = -1;
            else
                MMI_fixed_list_menu.current_displayed_item = j;
            
            item = gui_list_menu_smooth_scrolling_get_item(j);
            if (item)
            {
                MMI_fixed_list_menu.item_measure_function(
                    item, 
                    MMI_fixed_list_menu.common_item_data,&item_width, &item_height);        
            }

#ifdef __MMI_UI_LIST_GRID_LINE__  
            if (item_y < MMI_fixed_list_menu.y + MMI_fixed_list_menu.height &&
                item_y > MMI_fixed_list_menu.y)
            {
                gui_list_menu_draw_grid_line(src_layer_handle, j, item_x, item_y, item_width);
            }      
#endif /* __MMI_UI_LIST_GRID_LINE__ */

            item_y += item_height;
        }

        // set old menu item layer offset
        gdi_layer_push_and_set_active(menu_item_layer);
        if (direction == GUI_MENU_SMOOTH_SCROLL_DOWN)
        {
            gdi_layer_set_position(0, y1 - offset_y);
        }
        else
        {
            gdi_layer_set_position(0, y1 + 2 * move_range + offset_y);
        }
        gdi_layer_pop_and_restore_active();

        // set outgoing layer offset
        gdi_layer_push_and_set_active(incoming_layer);
        if (direction == GUI_MENU_SMOOTH_SCROLL_DOWN)
        {
            gdi_layer_set_position(0, y1 + menu_height - offset_y);
        }
        else
        {
            gdi_layer_set_position(0, y1 - move_range + offset_y);
        }
        gdi_layer_pop_and_restore_active();

        // draw scrollbar
#ifdef __MMI_FTE_SUPPORT__        
        gui_push_clip();
        if (mmi_fe_get_r2l_state())
        {
            gdi_layer_set_clip(
                MMI_fixed_list_menu.x, 
                0, 
                MMI_fixed_list_menu.x + MMI_fixed_list_menu.vbar.width - 1, 
                MMI_fixed_list_menu.height - 1);
        }
        else
        {
            gdi_layer_set_clip(
                MMI_fixed_list_menu.x + MMI_fixed_list_menu.width - 1 - MMI_fixed_list_menu.vbar.width, 
                0, 
                MMI_fixed_list_menu.x + MMI_fixed_list_menu.width - 1, 
                MMI_fixed_list_menu.height - 1);
       }
        /* menu height might be larger than normal one. Prevent the scrollbar mismatch when going back to the normal menu */
        
        if (wgui_is_wallpaper_on_bottom() && layers[0] != dm_get_scr_bg_layer())
        {
            gdi_layer_flatten_with_clipping(dm_get_scr_bg_layer(), act_layer, 0, 0);
        }
        else
        {
            gdi_layer_flatten_with_clipping(layers[0], act_layer, 0, 0);
        }
        gui_enable_scrollbar_redraw_clip(MMI_FALSE);
        gui_show_vertical_scrollbar(&MMI_fixed_list_menu.vbar);
        gui_enable_scrollbar_redraw_clip(MMI_TRUE);
        gui_pop_clip();
#endif  // __MMI_FTE_SUPPORT__

        gdi_layer_unlock_frame_buffer();

        if (scr_bg_layer && wgui_is_wallpaper_on_bottom())
        {
            gdi_layer_blt(scr_bg_layer, list_menu->act_layer_handle, menu_item_layer, incoming_layer, x1, y1, x2, y2);
        }
        else
        {
            gdi_layer_blt(list_menu->act_layer_handle, menu_item_layer, incoming_layer, 0, x1, y1, x2, y2);
        }
        
        kal_get_time(&end_time);
        elapsed_ms = kal_ticks_to_milli_secs(end_time - start_time);
        
        if (elapsed_ms > g_gui_screen_switch_effect_frame_duration)
        {
            next_timer_duration = 0;
        }
        else
        {
            next_timer_duration = g_gui_screen_switch_effect_frame_duration - elapsed_ms; 
        }

        kal_sleep_task(kal_milli_secs_to_ticks(next_timer_duration));
    }

    if (menu_item_layer != GDI_NULL_HANDLE)
    {
        gdi_layer_free(menu_item_layer);
        gdi_layer_free(incoming_layer);
        mmi_frm_scrmem_free(menu_item_layer_buf);
        mmi_frm_scrmem_free(incoming_layer_buf);
    }
    gdi_layer_pop_clip();
    gdi_layer_pop_and_restore_active();

    gdi_layer_set_blt_layer(layers[0], layers[1], layers[2], layers[3]);
#endif   // __MMI_GUI_LIST_MENU_SSK_OPTIMIZE__

#if defined (__MMI_UI_LIST_SKIP_DISABLED__)
    if (direction == GUI_MENU_SMOOTH_SCROLL_DOWN)
    {
        new_menuitem_index = list_menu->highlighted_item + 1;
    }
    else
    {
        new_menuitem_index = list_menu->highlighted_item - 1;
    }
    n = 1;
    item = gui_list_menu_smooth_scrolling_get_item(new_menuitem_index);
    if (item)
    {
        list_menu->item_get_flag_function(
            item, 
            list_menu->common_item_data,
            new_menuitem_index, 
            &flags, 
            &flags_ext);
    }
    if (flags & UI_MENUITEM_STATE_DISABLED)
    {
        while (flags & UI_MENUITEM_STATE_DISABLED)
        {
            if (direction == GUI_MENU_SMOOTH_SCROLL_DOWN)
            {
                
                if ( new_menuitem_index >= (list_menu->n_items - 1))      
                {
                    n = 0;
                    break;
                }
                else
                {
                    new_menuitem_index++;
                    n ++;
                }
            }
            else
            {
                if (new_menuitem_index == 0)        
                {
                    n = 0;
                    break;
                }
                else
                {
                    new_menuitem_index--;
                    n ++;
                }
            }
            item = gui_list_menu_smooth_scrolling_get_item(new_menuitem_index);
            if (item)
            {
                list_menu->item_get_flag_function(
                    item, 
                    list_menu->common_item_data,
                    new_menuitem_index, 
                    &flags, 
                    &flags_ext);
            }
        }
    }
#endif
    /* load the new item ASAP because asyncdynamic item might fail in loading */
    if (direction == GUI_MENU_SMOOTH_SCROLL_DOWN)
    {
#if defined (__MMI_UI_LIST_SKIP_DISABLED__)
        new_menuitem_index = list_menu->last_displayed_item + n;
#else
        new_menuitem_index = list_menu->last_displayed_item + 1;
#endif
    }
    else
    {
#if defined (__MMI_UI_LIST_SKIP_DISABLED__)        
        new_menuitem_index = list_menu->first_displayed_item - n;
#else
        new_menuitem_index = list_menu->first_displayed_item - 1;
#endif
    }

#if defined (__MMI_UI_LIST_SKIP_DISABLED__)        
    if (direction == GUI_MENU_SMOOTH_SCROLL_DOWN && new_menuitem_index > list_menu->n_items - 1)
    {
        gui_in_ssk = MMI_FALSE;
        gui_list_menu_smooth_scrolling_goto_next_item();
        return;
    }
    else if (direction == GUI_MENU_SMOOTH_SCROLL_UP && new_menuitem_index < 0)
    {
        gui_in_ssk = MMI_FALSE;
        gui_list_menu_smooth_scrolling_goto_previous_item();
        return;
    }
#endif

    first_displayed_item_index = list_menu->first_displayed_item;
    highlighted_item_index = list_menu->highlighted_item;

    if (direction == GUI_MENU_SMOOTH_SCROLL_DOWN)
    {
#if defined (__MMI_UI_LIST_SKIP_DISABLED__)
        list_menu->first_displayed_item += n;
        list_menu->highlighted_item += n;
#else
        list_menu->first_displayed_item++;
        list_menu->highlighted_item++;
#endif
    }
    else
    {
#if defined (__MMI_UI_LIST_SKIP_DISABLED__)
        list_menu->first_displayed_item -= n;
        list_menu->highlighted_item -= n;
#else
        list_menu->first_displayed_item--;
        list_menu->highlighted_item--;
#endif
    }   
    gdi_layer_lock_frame_buffer();

    /* get menu item error handling */
    // TODO: should ASSERT
    if ((gui_list_menu_smooth_scrolling_get_item(new_menuitem_index) == NULL) ||
        ((g_gui_list_menu_smooth_scrolling_menu_type == GUI_MENU_TYPE_ASYNCDYNAMIC) && 
         (new_menuitem_index + 1 < list_menu->n_items) && 
         (gui_list_menu_smooth_scrolling_get_item(new_menuitem_index + 1) == NULL)))
    {            
        gui_in_ssk = MMI_FALSE;   
        gdi_layer_unlock_frame_buffer();
        return;   
    }
    gdi_layer_unlock_frame_buffer();

    list_menu->first_displayed_item = first_displayed_item_index;

#ifndef __MMI_GUI_LIST_MENU_SSK_OPTIMIZE__
    list_menu->highlighted_item = highlighted_item_index;
    move_range = gui_list_menu_smooth_scrolling_get_menu_item_height();

    /* get main base layer buffer pointer */  
    gdi_layer_get_base_handle(&main_base_layer);
    gdi_layer_push_and_set_active(main_base_layer);
    gdi_layer_get_buffer_ptr(&base_layer_buf_p);    
    main_base_layer_bpp = gdi_layer_get_bit_per_pixel();    
    gdi_layer_pop_and_restore_active();

    highlighted_item_x = list_menu->highlight_x;
    highlighted_item_y = list_menu->highlight_y;

    /* remove highlight filler on the main base layer */
    gdi_layer_push_clip();
    gdi_layer_reset_clip();
#if defined (__MMI_UI_LIST_SKIP_DISABLED__)
    if (menu_y2 >= highlighted_item_y + m->height * (n + 1) - 1)
    {
        gdi_draw_solid_rect(
            highlighted_item_x, 
            highlighted_item_y,
            highlighted_item_x + m->width - 1,
            highlighted_item_y + m->height * (n + 1) - 1,
            GDI_COLOR_TRANSPARENT);
    }
    else
    {
        gdi_draw_solid_rect(
            highlighted_item_x, 
            highlighted_item_y,
            highlighted_item_x + m->width - 1,
            menu_y2,
            GDI_COLOR_TRANSPARENT);
    }
#else
    if (menu_y2 >= highlighted_item_y + m->height * 2 - 1)
    {
        gdi_draw_solid_rect(
            highlighted_item_x, 
            highlighted_item_y,
            highlighted_item_x + m->width - 1,
            highlighted_item_y + m->height * 2 - 1,
            GDI_COLOR_TRANSPARENT);
    }
    else
    {
        gdi_draw_solid_rect(
            highlighted_item_x, 
            highlighted_item_y,
            highlighted_item_x + m->width - 1,
            menu_y2,
            GDI_COLOR_TRANSPARENT);
    }
#endif
    gdi_layer_pop_clip();

    /* remove the highlight from the highlighted item and redraw */           
    item = gui_list_menu_smooth_scrolling_get_item(list_menu->highlighted_item);
    if (item)
        list_menu->item_remove_highlight_function(item, m);
    gui_list_menu_smooth_scrolling_show_item(list_menu->highlighted_item, highlighted_item_x, highlighted_item_y);
    
    /* remove the hint in the neighborhood by displaying the item overlapped by the hint */
    gui_list_menu_smooth_scrolling_show_item(list_menu->highlighted_item + 1, highlighted_item_x, highlighted_item_y + m->height);
  
    /* get SCR BG layer buffer pointer */
    gdi_layer_push_and_set_active(scr_bg_layer);
    scr_bpp = gdi_layer_get_bit_per_pixel();
    gdi_layer_get_buffer_ptr(&scr_bg_buf_p);
    gdi_layer_pop_and_restore_active();

    /*
     * use highlight sliding gui effect buffer for the menu highlight, MED buffer
     */

    /* allocate memory for the highlight and the new incoming item */
#ifdef __MMI_SCREEN_SWITCH_EFFECT__
    gui_effect_mem_manager_create(&mem_pool, gui_effect_get_buf_b(), MAIN_LCD_DEVICE_WIDTH * MAIN_LCD_DEVICE_HEIGHT * GUI_SCREEN_SWITCH_EFFECT_PIXEL_BYTE_SIZE);
    menu_highlight_buf_p = gui_effect_mem_manager_mem_alloc(&mem_pool, UI_device_width * move_range * GUI_EFFECT_LAYER_BYTE_PER_PIXEL);
    new_menu_item_buf_p = gui_effect_mem_manager_mem_alloc(&mem_pool, UI_device_width * move_range * GUI_EFFECT_LAYER_BYTE_PER_PIXEL);
#else /* __MMI_SCREEN_SWITCH_EFFECT__ */
    /* increase GUI_EFFECT_LAYER_SIZE if not enough */

#if defined(__MMI_SCREEN_SWITCH_EFFECT__)&& !defined(__MMI_REDUCED_UI_BUFFER__)
    /* use buffer b */
    gui_screen_switch_effect_get_frame_buffer_info(1, &g_gui_effect_layer_buffer, &buf_size);
#endif

    menu_highlight_buf_p = (PU8)g_gui_effect_layer_buffer;
    MMI_ASSERT(GUI_EFFECT_LAYER_SIZE >= UI_device_width * move_range * GUI_EFFECT_LAYER_BYTE_PER_PIXEL);
    
    /* use MED memory for the new menu item layer */
    med_mem_p = med_alloc_asm_mem_framebuffer(0, UI_device_width * move_range * GUI_EFFECT_LAYER_BYTE_PER_PIXEL);
    MMI_ASSERT(med_mem_p);
    new_menu_item_buf_p = (PU8)med_mem_p;
#endif /* __MMI_SCREEN_SWITCH_EFFECT__ */

    g_gui_screen_switch_effect_is_to_clear_key = MMI_FALSE;

    gui_screen_switch_effect_create_world();

    /* do not use the default finish callback */
    gui_screen_switch_effect_register_finish_callback(NULL);
    /* enable early key break */
    // TODO: should use a better method, such as timer?
    g_gui_screen_switch_effect_enable_early_key_break = MMI_TRUE;

    /* SCR BG */
    gui_screen_switch_effect_create_object(g_gui_screen_switch_effect_object + 0, 0, UI_device_width, UI_device_height, scr_bpp, 0, scr_bg_buf_p, gui_screen_switch_effect_object_get_param_callback);
    /* highlight */
    gui_screen_switch_effect_create_object(g_gui_screen_switch_effect_object + 1, 1, UI_device_width, move_range, 16, 0, menu_highlight_buf_p, gui_screen_switch_effect_object_get_param_callback);            

    /* old menu content */
    old_menu_y = list_menu->y;

#ifdef GDI_6_LAYERS    
#ifdef __MMI_UI_LIST_SCROLL_BY_PIXEL__
    old_menu_height = list_menu->height - move_range;
#else /* __MMI_UI_LIST_SCROLL_BY_PIXEL__ */
    old_menu_height = m->height * list_menu->displayed_items - move_range;
#endif /* __MMI_UI_LIST_SCROLL_BY_PIXEL__ */
#else /* GDI_6_LAYERS */
#ifdef __MMI_UI_LIST_SCROLL_BY_PIXEL__
    old_menu_height = list_menu->height;
#else /* __MMI_UI_LIST_SCROLL_BY_PIXEL__ */
    old_menu_height = m->height * list_menu->displayed_items;
#endif /* __MMI_UI_LIST_SCROLL_BY_PIXEL__ */
#endif /* GDI_6_LAYERS */

    main_base_layer_line_jump_bytes = UI_device_width * main_base_layer_bpp / 8;    
    base_layer_buf_p += old_menu_y * main_base_layer_line_jump_bytes;

#ifdef GDI_6_LAYERS
    /* scrolled out menu item setup */
    if (direction == GUI_MENU_SMOOTH_SCROLL_DOWN)
    {
        scrolled_out_item_buf_p = base_layer_buf_p;
        base_layer_buf_p += move_range * main_base_layer_line_jump_bytes;
        old_menu_y += move_range;
    }
    else
    {
        scrolled_out_item_buf_p = base_layer_buf_p + old_menu_height * main_base_layer_line_jump_bytes;
    }
#endif /* GDI_6_LAYERS */

    gui_screen_switch_effect_create_object(g_gui_screen_switch_effect_object + 2, 2, UI_device_width, old_menu_height, main_base_layer_bpp, 0, base_layer_buf_p, gui_screen_switch_effect_object_get_param_callback);
    g_gui_screen_switch_effect_object[2].draw_callback = gui_ssk_draw_old_menu_items;

    /* new menu item */
    gui_screen_switch_effect_create_object(g_gui_screen_switch_effect_object + 3, 3, UI_device_width, move_range, 16, 0, new_menu_item_buf_p, gui_screen_switch_effect_object_get_param_callback);

#ifdef GDI_6_LAYERS
    /* scrolled out menu item to fade out, need > 4 layers */
    gui_screen_switch_effect_create_object(g_gui_screen_switch_effect_object + 4, 4, UI_device_width, move_range, main_base_layer_bpp, 0, scrolled_out_item_buf_p, gui_screen_switch_effect_object_get_param_callback);    

    g_gui_screen_switch_effect_object[4].draw_callback = gui_ssk_draw_outgoing_menu_item;
    if (direction == GUI_MENU_SMOOTH_SCROLL_DOWN)
    {
        g_gui_ssk_outgoing_item_index = new_menuitem_index - list_menu->displayed_items;
    }
    else
    {
        g_gui_ssk_outgoing_item_index = new_menuitem_index + list_menu->displayed_items;
    }

#endif /* GDI_6_LAYERS */

    /* new coming menu item */
    gui_screen_switch_effect_create_object_layer(g_gui_screen_switch_effect_object + 3, &new_menuitem_layer);
    g_gui_screen_switch_effect_object[3].draw_callback = gui_ssk_draw_incoming_menu_item;
    g_gui_ssk_incoming_item_index = new_menuitem_index;

    gdi_layer_free(new_menuitem_layer);

    /* draw the highlight layer */
    gui_screen_switch_effect_create_object_layer(g_gui_screen_switch_effect_object + 1, &highlight_layer);
    gdi_layer_push_and_set_active(highlight_layer);

    gdi_layer_clear(GDI_COLOR_TRANSPARENT);

    /* must enable the source key to get rid of the transparent color in IMAGE highlight */
    gdi_layer_set_source_key(TRUE, GDI_COLOR_TRANSPARENT);

    gui_list_menu_smooth_scrolling_draw_highlight_filler(
        highlighted_item_x,
        highlighted_item_y,
        m->width,
        m->height);
        
    gdi_layer_pop_and_restore_active();
    gdi_layer_free(highlight_layer);    

#ifdef __MMI_FTE_SUPPORT__
    /* set view port to the MENU area only (exclude the scroll bar) */
    GUI_RECT(
        g_gui_screen_switch_effect_world_view_rect,
        highlighted_item_x,
        list_menu->y,
        list_menu->width,
        list_menu->height);  
#else   // __MMI_FTE_SUPPORT__
    /* set view port to the MENU area only (exclude the scroll bar) */
    GUI_RECT(
        g_gui_screen_switch_effect_world_view_rect,
        highlighted_item_x,
        list_menu->y,
        m->width,
        list_menu->height);  
#endif // __MMI_FTE_SUPPORT__

    g_gui_screen_switch_effect_frame_duration = GUI_SCREEN_SWITCH_EFFECT_TIMER_UNIT;
    g_gui_screen_switch_effect_frames = GUI_LIST_MENU_SMOOTH_SCROLLING_BY_KEY_FRAME_NUM; // GUI_SCREEN_SWITCH_EFFECT_FRAMES;   
    if (direction == GUI_MENU_SMOOTH_SCROLL_DOWN)
    {    
#if defined (__MMI_UI_LIST_SKIP_DISABLED__)
        list_menu->highlighted_item += n;
#else
        list_menu->highlighted_item += 1;
#endif
    }
    else
    {
#if defined (__MMI_UI_LIST_SKIP_DISABLED__)
        list_menu->highlighted_item -= n;
#else
        list_menu->highlighted_item -= 1;
#endif
    }       

    for (i = 0; i < g_gui_screen_switch_effect_frames; i++)
    {
        const S32 offset_story[GUI_LIST_MENU_SMOOTH_SCROLLING_BY_KEY_FRAME_NUM] = 
        {
            GUI_SCREEN_SWITCH_EFFECT_FIXED_POINT(0.5),
            GUI_SCREEN_SWITCH_EFFECT_FIXED_POINT(0.75),
            GUI_SCREEN_SWITCH_EFFECT_FIXED_POINT(0.90),
            GUI_SCREEN_SWITCH_EFFECT_FIXED_POINT(0.96),
            GUI_SCREEN_SWITCH_EFFECT_FIXED_POINT(1)
        };

    #ifdef GDI_6_LAYERS
#ifdef __MMI_FTE_SUPPORT__
        const S32 opacity_story[GUI_LIST_MENU_SMOOTH_SCROLLING_BY_KEY_FRAME_NUM] = {0, 0, 0, 0, 0};
#else
        const S32 opacity_story[GUI_LIST_MENU_SMOOTH_SCROLLING_BY_KEY_FRAME_NUM] = {128, 160, 180, 200, 255};
#endif
    #endif /* GDI_6_LAYERS */
    
        /* set the menu item highlight position */    
        param = &g_gui_screen_switch_effect_object_param[1][i];
        param->offset_x = highlighted_item_x;
        param->offset_y = highlighted_item_y;

        /* move the old menu */
        param = &g_gui_screen_switch_effect_object_param[2][i];
        offset_y = GUI_SCREEN_SWITCH_EFFECT_FIXED_POINT_MUL(move_range, offset_story[i]);

        if (direction == GUI_MENU_SMOOTH_SCROLL_DOWN)
        {
            offset_y = -offset_y;
        }

        param->offset_y = old_menu_y + offset_y;
        
        /* move the new menu item */
        param = &g_gui_screen_switch_effect_object_param[3][i];

        if (direction == GUI_MENU_SMOOTH_SCROLL_DOWN)
        {
#ifdef __MMI_UI_LIST_SCROLL_BY_PIXEL__
            param->offset_y = list_menu->y + list_menu->top + list_menu->height + offset_y;
#else
            param->offset_y = list_menu->y + list_menu->top + move_range * list_menu->displayed_items + offset_y;
#endif
        }
        else
        {
            param->offset_y = list_menu->y + list_menu->top - move_range + offset_y;
        }

    #ifdef GDI_6_LAYERS
        /* scrolled out item */
        param = &g_gui_screen_switch_effect_object_param[4][i];
        param->opacity = 255 - opacity_story[i];

        if (direction == GUI_MENU_SMOOTH_SCROLL_UP)
        {
            param->offset_y = g_gui_screen_switch_effect_object_param[2][i].offset_y + old_menu_height;
        }
        else
        {
            param->offset_y = g_gui_screen_switch_effect_object_param[2][i].offset_y - move_range;
        }        
    #endif /* GDI_6_LAYERS */        
    }

    /* stop any video or async image decoding */
    if (g_gui_list_menu_smooth_scrolling_stop_callback)
    {
        g_gui_list_menu_smooth_scrolling_stop_callback();
    }
    
    gui_effect_clear_blt_rect();
    gdi_lcd_freeze(TRUE);
    gui_screen_switch_effect_draw_world();
    gdi_lcd_freeze(FALSE);
    gui_screen_switch_effect_close_world();

    if (med_mem_p)
    {
        med_free_asm_mem(0, &med_mem_p);
    }
#endif  // __MMI_GUI_LIST_MENU_SSK_OPTIMIZE__
    
    g_gui_screen_switch_effect_is_to_clear_key = MMI_TRUE;

    if (direction == GUI_MENU_SMOOTH_SCROLL_DOWN)
    {    
#if defined (__MMI_UI_LIST_SKIP_DISABLED__)
        list_menu->first_displayed_item += n;
        list_menu->last_displayed_item += n;
        list_menu->highlighted_item -= n;
        gui_list_menu_smooth_scrolling_goto_item(list_menu->highlighted_item + n);
#else
        list_menu->first_displayed_item++;
        list_menu->last_displayed_item ++;
        list_menu->highlighted_item --;
        gui_list_menu_smooth_scrolling_goto_item(list_menu->highlighted_item + 1);
#endif
    }
    else
    {
#if defined (__MMI_UI_LIST_SKIP_DISABLED__)
        list_menu->first_displayed_item -= n;
        list_menu->last_displayed_item -= n;
        list_menu->highlighted_item += n;
        gui_list_menu_smooth_scrolling_goto_item(list_menu->highlighted_item - n);
#else
        list_menu->first_displayed_item--;
        list_menu->last_displayed_item --;
        list_menu->highlighted_item ++;
        gui_list_menu_smooth_scrolling_goto_item(list_menu->highlighted_item - 1);
#endif
    }       
    gui_in_ssk = MMI_FALSE;
}

#endif /* GUI_LIST_MENU_SMOOTH_SCROLLING_BY_KEY */


#if defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_KEY) || defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN)
/*****************************************************************************
 * FUNCTION
 *  gui_list_menu_smooth_scrolling_goto_item_noredraw
 * DESCRIPTION
 *  Highlight the menu item without drawing the menu
 * PARAMETERS
 *  item_index       [IN]   menu item index to be highlighted
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_list_menu_smooth_scrolling_goto_item_noredraw(S32 item_index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 flags = 0;
    MMI_BOOL in_buffer = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (g_gui_list_menu_smooth_scrolling_menu_type)
    {
        case GUI_MENU_TYPE_FIXED:
            fixed_list_goto_item_no_redraw(item_index);
            break;
            
        case GUI_MENU_TYPE_DYNAMIC:
            if (MMI_fixed_list_menu.flags & UI_LIST_MENU_DISABLE_CACHE_DYNAMIC_DATA && in_dynamic_item_buffer(item_index)
                && gui_in_ssk)
            {
                flags = ((fixed_icontext_menuitem_type*)get_dynamic_item_from_buffer(item_index))->flags;
                in_buffer = MMI_TRUE;
            }
            dynamic_list_goto_item_no_redraw(item_index);
            if (in_buffer == MMI_TRUE)
            {
                ((fixed_icontext_menuitem_type*)get_dynamic_item_from_buffer(item_index))->flags = flags;
            }
            
            break;
            
        case GUI_MENU_TYPE_ASYNCDYNAMIC:
            asyncdynamic_list_goto_item_no_redraw(item_index);
            break;            
            
#ifdef __MMI_FTE_SUPPORT__             
        case GUI_MENU_TYPE_INLINE:
            if (MMI_fixed_list_menu.highlighted_item < item_index)
            {
                inline_fixed_list_goto_item_no_redraw(item_index, MMI_FALSE);
            }
            else
            {
                inline_fixed_list_goto_item_no_redraw(item_index, MMI_TRUE);
            }
            
            break;
#endif
            
        default:
            break;
    }
}
#endif 


#if defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN) || defined(GUI_MATRIX_MENU_SMOOTH_SCROLLING_BY_PEN)
/*****************************************************************************
 * FUNCTION
 *  gui_ssp_execute_lsk
 * DESCRIPTION
 *  Executes the LSK fuction by the specified key event.
 * PARAMETERS
 *  key_event       [IN]    key event
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_ssp_execute_lsk(U16 key_event)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (GetKeyHandler(KEY_LSK, key_event))
    {
        /* Some softkey handlers use GetkeyInfo() */
        SetkeyInfo(KEY_LSK, key_event);
        execute_softkey_function(key_event, MMI_LEFT_SOFTKEY);
    }        
}
#endif /* GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN || GUI_MATRIX_MENU_SMOOTH_SCROLLING_BY_PEN */

#if defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN) || defined(GUI_MATRIX_MENU_SMOOTH_SCROLLING_BY_PEN)
extern S32 handwriting_stroke_layer_mem;
#endif /* GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN || GUI_MATRIX_MENU_SMOOTH_SCROLLING_BY_PEN */

#if defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN)
static S32 gui_list_get_ssp_stop_item(S32 momentum)
{
    S32 total_offset, old_momentum, item_height, stop_item_index;

    total_offset = g_gui_ssp_current_menu_y_offset;

    item_height = gui_list_menu_smooth_scrolling_get_menu_item_height();

    total_offset += momentum;
    old_momentum = momentum;
    momentum = (S32)((float)momentum * GUI_SSP_FREE_RUN_SCROLL_COEFFICIENT);
    
    while (old_momentum != momentum)
    {
        total_offset += momentum;
        old_momentum = momentum;
        momentum = (S32)((float)momentum * GUI_SSP_FREE_RUN_SCROLL_COEFFICIENT);
    }
    
    if (GUI_SSP_MENU_OVER_LIMIT_COEFFICIENT != 0)
    {
	    if (total_offset > 0 && total_offset < item_height * MMI_fixed_list_menu.n_items)
	    {
            stop_item_index = total_offset / item_height;
        }
        else
        {
            stop_item_index = -3;// recovery mode
        }
    }
    else
    {
        if (total_offset <= 0)
        {
            stop_item_index = -1;// the first item
        }
        else if (total_offset > item_height * MMI_fixed_list_menu.n_items)
        {
            stop_item_index = -2;//the first item of last page
        }
        else
        {
            stop_item_index = total_offset / item_height;
        }
    }

    return stop_item_index;
}


/*****************************************************************************
 * FUNCTION
 *  gui_list_menu_smooth_scrolling_get_items_per_page
 * DESCRIPTION
 *  Gets the max number of items in the menu.
 * PARAMETERS
 *  void
 * RETURNS
 *  Max number of items in the menu.
 *****************************************************************************/
static S32 gui_list_menu_smooth_scrolling_get_items_per_page(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 item_height, displayed_items, menu_full_height, iwidth, i, old_current_index;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_gui_list_menu_smooth_scrolling_menu_type == GUI_MENU_TYPE_INLINE
#if defined(__MMI_UI_LIST_SUPPORT_UNEQUAL_HEIGHT_ITEM__)
        || (MMI_fixed_list_menu.flags & UI_LIST_MENU_INEQUAL_HEIGHT_ITEMS)
#endif
    )
    {
        menu_full_height = 0;
        displayed_items = 0;
        old_current_index = MMI_fixed_list_menu.current_displayed_item;
        for (i = MMI_fixed_list_menu.first_displayed_item; i < MMI_fixed_list_menu.n_items; i++)
        {
            if (i == MMI_fixed_list_menu.highlighted_item)
            {
                MMI_fixed_list_menu.current_displayed_item = -1;
            }
            else
            {
                MMI_fixed_list_menu.current_displayed_item = i;
            }
            MMI_fixed_list_menu.item_measure_function(
                MMI_fixed_list_menu.items[i], 
                MMI_fixed_list_menu.common_item_data,
                &iwidth, 
                &item_height);
            menu_full_height += item_height;
            if (menu_full_height > MMI_fixed_list_menu.height)
            {
                break;
            }
            displayed_items ++;
        }
        MMI_fixed_list_menu.current_displayed_item = old_current_index;
        return displayed_items;
    }
    item_height = gui_list_menu_smooth_scrolling_get_menu_item_height();
    displayed_items = (MMI_fixed_list_menu.height - MMI_fixed_list_menu.top) / item_height;
    if (gui_list_menu_is_highlight_item_two_line())
    {
        displayed_items--;
    }
    return displayed_items;
}


/*****************************************************************************
 * FUNCTION
 *  gui_ssp_is_point_in_menu_rect
 * DESCRIPTION
 *  Checks whether a point is in the valid menu rect (excluding the scroll bar)
 * PARAMETERS
 *  x       [IN]    point x coordinate
 *  y       [IN]    point y coordinate
 * RETURNS
 *  MMI_TRUE if the point is inside; otherwise, MMI_FALSE
 *****************************************************************************/
static MMI_BOOL gui_ssp_is_point_in_menu_rect(S32 x, S32 y)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gui_common_menuitem_base_struct *cm;

    S32 x1, y1;
    S32 menu_height, old_index, highlight_width, highlight_height;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    cm = (gui_common_menuitem_base_struct*)MMI_fixed_list_menu.common_item_data;

    /* the menu width is derived from the menu item */
    x1 = MMI_fixed_list_menu.highlight_x;
    y1 = MMI_fixed_list_menu.y;
    menu_height = MMI_fixed_list_menu.displayed_items * cm->height;

    old_index = MMI_fixed_list_menu.current_displayed_item;
    MMI_fixed_list_menu.current_displayed_item = -1;
    MMI_fixed_list_menu.item_measure_function(
        NULL, 
        MMI_fixed_list_menu.common_item_data,&highlight_width, &highlight_height);  
    MMI_fixed_list_menu.current_displayed_item = old_index;
    if (highlight_height == cm->height * 2)
    {
        menu_height += cm->height;
    }

    if (PEN_CHECK_BOUND(x, y, x1, y1, cm->width, MMI_fixed_list_menu.height))
    {
        return MMI_TRUE;
    }
    
    return MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  gui_ssp_stop_list_menu_scrolling
 * DESCRIPTION
 *  Stops the scrolling item and the popup description.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_ssp_stop_list_menu_scrolling(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
    gui_stop_list_highlight_effect();
#endif
    gui_fixed_icontext_list_menuitem_stop_scroll();
    gui_fixed_icontext_menuitem_stop_scroll();
    gui_fixed_text_menuitem_stop_scroll();
    gui_fixed_twostate_menuitem_stop_scroll();
#if (defined __MMI_UI_TWO_LINE_MENUITEM_STYLES__ || defined __MMI_UI_HINTS_IN_MENUITEM__)
    wgui_two_line_stop_scroller();
#endif
    /* IMPORTANT: stop the popup description scrolling */
    gui_pop_up_description_stop_scroll();

#ifdef __MMI_FTE_SUPPORT__
    wgui_inline_stop_scroll_when_ssp();    
#endif

    /* stop any video or async image decoding */
    if (g_gui_list_menu_smooth_scrolling_stop_callback)
    {
        g_gui_list_menu_smooth_scrolling_stop_callback();
    }
}


/*****************************************************************************
 * FUNCTION
 *  gui_ssp_sync_list_menu_display
 * DESCRIPTION
 *  Synchronizes the list menu display by SSP current display.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gui_ssp_sync_list_menu_display(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    fixed_list_menu *m = &MMI_fixed_list_menu;
    S32 new_highlight_index;
    void *item;
    S32 old_flags = MMI_fixed_list_menu.flags;
    S32 displayed_items;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* remove the highlight first */    
    item = gui_list_menu_smooth_scrolling_get_item(m->highlighted_item);
    if (item)
        m->item_remove_highlight_function(item, m->common_item_data);
    
    displayed_items = gui_list_menu_smooth_scrolling_get_items_per_page();
#ifdef __MMI_FTE_SUPPORT__
    if (!(m->flags & UI_LIST_MENU_INLINE_EDIT) && !(m->flags & UI_LIST_MENU_INEQUAL_HEIGHT_ITEMS))
    {
        S32 first_menu_item_index, item_height, old_index;
        S32 highlight_width, highlight_height;
        S32 last_menu_item_index, y2, y1;

        y1 = m->y;
        y2 = m->y + m->height - 1;

        item_height = gui_list_menu_smooth_scrolling_get_menu_item_height();
        
        first_menu_item_index = g_gui_ssp_current_menu_y_offset / item_height;
    
        old_index = MMI_fixed_list_menu.current_displayed_item;
        MMI_fixed_list_menu.current_displayed_item = -1;
        MMI_fixed_list_menu.item_measure_function(
            NULL, 
            MMI_fixed_list_menu.common_item_data,&highlight_width, &highlight_height);  
        MMI_fixed_list_menu.current_displayed_item = old_index;
    
        last_menu_item_index = (g_gui_ssp_current_menu_y_offset + y2 - y1) / item_height;
        
        if ( (g_gui_ssp_current_menu_y_offset + y2 - y1) % item_height == 0)
        {
            last_menu_item_index--;
        }

        if (first_menu_item_index < 0)
        {
            first_menu_item_index = 0;
            if (highlight_height == item_height * 2 && displayed_items < m->n_items)
            {
                last_menu_item_index --;
            }
        }

        if (last_menu_item_index >= m->n_items)
        {
            if ((highlight_height == item_height * 2) && displayed_items <= m->n_items && 
                last_menu_item_index >= m->n_items && first_menu_item_index > m->highlighted_item)
            {
                first_menu_item_index --;
                last_menu_item_index = m->n_items - 1;
            }
            else
            {
                last_menu_item_index = m->n_items - 1;
            }
        }

        m->first_displayed_item = g_gui_ssp_old_first_menu_item_index;
        m->last_displayed_item = g_gui_ssp_old_first_menu_item_index + displayed_items - 1;
    }
    else
    {
        if ((m->highlighted_item >= g_gui_ssp_current_menu_last_item_index) &&
            ((g_gui_ssp_old_first_menu_item_index == 0 && g_gui_ssp_current_menu_y_offset > 0) ||
             (g_gui_ssp_old_first_menu_item_index > 0)) &&                    // not in the first page
            (g_gui_ssp_old_first_menu_item_index + displayed_items - 1 < m->n_items - 1))    // highlight is the last item and have displayed in current screen
        {
            m->last_displayed_item = g_gui_ssp_current_menu_last_item_index;
            m->first_displayed_item = g_gui_ssp_current_menu_last_item_index - displayed_items + 1;
        }
        else
        {
            m->first_displayed_item = g_gui_ssp_old_first_menu_item_index;
            m->last_displayed_item = g_gui_ssp_old_first_menu_item_index + displayed_items - 1;
        }
    }
#else
    m->first_displayed_item = g_gui_ssp_old_first_menu_item_index;
    m->last_displayed_item = g_gui_ssp_old_first_menu_item_index + displayed_items - 1;
#endif    

#ifdef __MMI_UI_LIST_SCROLL_BY_PIXEL__
    gui_ssp_sync_list_menu_by_pixel();
#endif    

    /* validate first and last displayed items */
    if (m->first_displayed_item < 0)
    {
        m->first_displayed_item = 0;
#ifdef __MMI_UI_LIST_SCROLL_BY_PIXEL__
        m->first_displayed_offset = 0;
#endif
    }
    if (m->last_displayed_item >= m->n_items)
    {
        m->last_displayed_item = m->n_items - 1;
#ifdef __MMI_UI_LIST_SCROLL_BY_PIXEL__
        m->last_displayed_offset = 0;
#endif
    }

    /* make sure the highlight is not out of screen */
    new_highlight_index = m->highlighted_item;
    if (m->highlighted_item < m->first_displayed_item) 
    {
        new_highlight_index = m->first_displayed_item;
    }
#ifdef __MMI_FTE_SUPPORT__  
    else if (m->highlighted_item > m->last_displayed_item)
    {
        if ((m->flags & UI_LIST_MENU_INLINE_EDIT) &&
            ((wgui_inline_items[m->highlighted_item].flags & 0xFF) == INLINE_ITEM_TYPE_MULTI_LINE_RD_ONLY))
        {
            //doesn't do highlight validation
			//half display the highlighted RD only multi line
			//if highlight to multi line edit, should do the validation
        }
        else
        {
            new_highlight_index = m->last_displayed_item;
        }
    }
#ifdef __MMI_UI_LIST_SCROLL_BY_PIXEL__
    gui_ssp_check_highlight_threshold(&new_highlight_index);
#endif
    if (g_gui_list_menu_smooth_scrolling_menu_type == GUI_MENU_TYPE_INLINE && 
        new_highlight_index == MMI_fixed_list_menu.highlighted_item)
    {
        MMI_fixed_list_menu.highlighted_item = -1;
    }
#else
    else if (m->highlighted_item > m->last_displayed_item)
    {
        new_highlight_index = m->last_displayed_item;
    }
#ifdef __MMI_UI_LIST_SCROLL_BY_PIXEL__
    gui_ssp_check_highlight_threshold(&new_highlight_index);
#endif
#endif

    MMI_fixed_list_menu.flags &= ~UI_LIST_MENU_LOOP;
    gui_list_menu_smooth_scrolling_goto_item_noredraw(new_highlight_index);
    MMI_fixed_list_menu.flags = old_flags;
}


/*****************************************************************************
 * FUNCTION
 *  gui_ssp_send_pen_event_to_item
 * DESCRIPTION
 *  Sends the pen event to the menu item.
 * PARAMETERS
 *  pen_event        [IN]   pen event
 *  point            [IN]   pen point
 *  item_index       [IN]   item index
 *  item_x           [IN]   item x
 *  item_y           [IN]   item y
 * RETURNS
 *  MMI_TRUE if the pen event is handled; otherwise, MMI_FALSE.
 *****************************************************************************/
static MMI_BOOL gui_ssp_send_pen_event_to_item(mmi_pen_event_type_enum pen_event, mmi_pen_point_struct *point, S32 item_index, S32 item_x, S32 item_y, 
                                               gui_list_pen_enum *menuitem_event,gui_pen_event_param_struct *menuitem_param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL ret = MMI_FALSE;
    fixed_list_menu *m = &MMI_fixed_list_menu;
    void *item;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    GUI_PEN_EVENT_PARAM_SET_INTEGER2((menuitem_param), item_index, GUI_LIST_PEN_NONE);
    item = gui_list_menu_smooth_scrolling_get_item(item_index);
    if (item)
    {
    ret = (MMI_BOOL)m->item_pen_function(
            item,
            m->common_item_data,
            item_x,
            item_y,
            pen_event,
            point->x,
            point->y,
            menuitem_event,
            menuitem_param);
    }

    return ret;            
}


/*****************************************************************************
 * FUNCTION
 *  gui_ssp_show_list_menu
 * DESCRIPTION
 *  Shows the list menu by the y offset.
 * PARAMETERS
 *  menu_offset_y       [IN]    
 *  x1                  [IN]    list menu x1
 *  y1                  [IN]    list menu y1
 *  x2                  [IN]    list menu x2
 *  y2                  [IN]    list menu y2
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_ssp_show_list_menu(S32 menu_offset_y, S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32     first_menu_item_index, last_menu_item_index = 0;
    S32     i;
    S32     menu_height;
    S32     x, y, show_y_offset = 0;
    S32     normal_menu_height;
    S32     items_per_page;
    fixed_list_menu *m = &MMI_fixed_list_menu;
    
    gdi_handle menu_item_layer;
    S32     item_width, item_height, max_item_height;

    gui_rect menu_rect, item_rect, result_rect;
    gui_common_menuitem_base_struct *cm;
    gdi_handle src_layer_handle;

    S32     menu_item_layer_size;
    S32     item_y, total_height = 0, current_height = 0;
    S32     old_index, highlight_width, highlight_height;
    void   *item;
    S32 old_momentum, change_locate = 0;
    UI_filled_area *f;
    gdi_handle act_layer;
#ifdef __MMI_FTE_SUPPORT__    
    PU8 inline_buffer = NULL;
    S32 inline_buffer_size;
#endif  // __MMI_FTE_SUPPORT__    
#ifdef __MMI_UI_LIST_SUPPORT_UNEQUAL_HEIGHT_ITEM__
    PU8 item_buffer = NULL;
#endif
#ifdef __MMI_UI_LIST_GRID_LINE__
#ifndef __MMI_FTE_SUPPORT__ 
    MMI_BOOL show_scrollbar;
#endif
#endif
    U8 *buf_ptr = NULL;
    U8 *static_layer_buf_ptr = NULL;
#if defined(__MMI_SCREEN_SWITCH_EFFECT__)
    S32 buf_size;
#endif
    S32 grid_x;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    if (g_gui_list_menu_smooth_scrolling_menu_type == GUI_MENU_TYPE_INVALID)
    {
        return;
    }
    cm = (gui_common_menuitem_base_struct*)m->common_item_data;  
    item_width = cm->width;
    item_height = gui_list_menu_smooth_scrolling_get_menu_item_height();
    items_per_page = gui_list_menu_smooth_scrolling_get_items_per_page();
    
    if (g_gui_ssp_static_layer)
    {
        gdi_layer_push_and_set_active(g_gui_ssp_static_layer);
        gdi_layer_get_buffer_ptr(&static_layer_buf_ptr);
        gdi_layer_pop_and_restore_active();
    }
    
    gui_push_clip();
    gui_set_clip(x1, y1, x2, y2);

#ifdef __MMI_FTE_SUPPORT__                
    if (g_gui_list_menu_smooth_scrolling_menu_type == GUI_MENU_TYPE_INLINE)
    {   
        wgui_inline_set_ssp_redraw_state(MMI_TRUE);
    }
    if (m->flags & UI_LIST_MENU_STATE_FOCUSSED)
    {
        if ((m->flags & UI_LIST_MENU_DISABLE_SCROLLBAR) ||
            ((m->flags & UI_LIST_MENU_AUTO_DISABLE_SCROLLBAR) && (m->displayed_items >= m->n_items)))
        {
            f = m->focussed_without_sc_filler;
        }
        else
        {
            f = m->focussed_filler;
        }
    }
    else
    {
        f = m->normal_filler;
    }
    /* clear the menu rect */
    gui_swla_log_start("CLR");
    if (wgui_is_wallpaper_on_bottom() == MMI_FALSE)
    {
        if (g_gui_list_hide_menu)
        {
            g_gui_list_hide_menu(x1, y1, x2, y2);
        }
        else
        {
        #if !defined(MT6205B) && !defined(MT6208)
            gui_draw_filled_area(x1, y1, x2, y2, f);
        #else /* !defined(MT6205B) && !defined(MT6208) */
            /* For low-end phone, disable list menu background can greately improve menu performance. 
               We use the color of filler to draw the background (typically white). */
            color c = f->c;
            gdi_draw_solid_rect(x1, y1, x2, y2, gdi_act_color_from_rgb(255, c.r, c.g, c.b));
        #endif /* !defined(MT6205B) && !defined(MT6208) */
        }
    }
    else
    {
#ifdef __LOW_COST_SUPPORT_COMMON__
        gdi_2d_fill_rect((gdi_handle)gdi_act_layer,
                         (gdi_handle)gdi_act_layer,
                         x1,
                         y1,
                         x2 - x1 + 1,
                         y2 - y1 + 1,
                         0,
                         GDI_COLOR_TRANSPARENT,
                         GDI_2D_FILL_FLAG_NON_BLOCKING,
                         NULL);
#else
        gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_TRANSPARENT);
#endif
    }
    gui_swla_log_stop("CLR");
#else
    gui_swla_log_start("CLR");
    gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_TRANSPARENT);
    gui_swla_log_stop("CLR");
#endif
       
       
     
    
#ifdef __MMI_FTE_SUPPORT__
    if (m->flags & UI_LIST_MENU_INLINE_EDIT)
    {
        if (INLINE_FTE_MULTILINE_HEIGHT > GUI_SSE_MAX_MENU_HIGHLIGHT_HEIGHT)
        {
            max_item_height = INLINE_FTE_MULTILINE_HEIGHT;
        }
        else
        {
            max_item_height = GUI_SSE_MAX_MENU_HIGHLIGHT_HEIGHT;
        }       

        if ((wgui_inline_items[m->n_items - 1].flags & 0xFF) == INLINE_ITEM_TYPE_MULTI_LINE_RD_ONLY ||
			(wgui_inline_items[m->n_items - 1].flags & 0xFF) == INLINE_ITEM_TYPE_MULTI_LINE_EDIT)
        {
            S32 iwidth, iheight;
			if (m->highlighted_item == m->n_items - 1)
            {
				m->current_displayed_item = -1;
            }
            else
            {
				m->current_displayed_item = m->n_items - 1;
            }
            m->item_measure_function(m->items[m->n_items - 1], m->common_item_data, &iwidth, &iheight);
            
            if (max_item_height < iheight)
            {
                max_item_height = iheight;
            }
        }
    }
    else
#endif
    if (item_height == MMI_MENUITEM_HEIGHT)
    {   
        max_item_height = item_height * 2;
    }
    else
    {
        max_item_height = item_height;
    }
    menu_item_layer_size = UI_device_width * max_item_height * GUI_EFFECT_LAYER_BYTE_PER_PIXEL;

    if (g_gui_ssp_static_layer != GDI_NULL_HANDLE)
    {
        menu_item_layer = g_gui_ssp_static_layer;
    }
    else
    {
    #ifdef __MMI_FTE_SUPPORT__
    if (m->flags & UI_LIST_MENU_INLINE_EDIT && INLINE_FTE_MULTILINE_HEIGHT > GUI_SSE_MAX_MENU_HIGHLIGHT_HEIGHT)
    {
        S32 max_size = (GDI_LCD_WIDTH * GDI_LCD_HEIGHT * (GDI_MAINLCD_BIT_PER_PIXEL >> 3) + 3) & (~3);
        inline_buffer_size = (GUI_SCREEN_SWITCH_EEFECT_MAX_LCD_SIDE_LENGTH * INLINE_FTE_MULTILINE_HEIGHT * GUI_EFFECT_LAYER_BYTE_PER_PIXEL);
        if (inline_buffer_size > max_size)
        {
            inline_buffer_size = max_size;
            // the old calculate method has some defect, sometimes the buffer size bigger than a full screen size
        }
        if (max_item_height > UI_device_height)
        {
            max_item_height = UI_device_height;
        }
        //MMI_ASSERT(inline_buffer_size <= handwriting_stroke_layer_mem);
        inline_buffer = (U8*) mmi_frm_scrmem_alloc_framebuffer(inline_buffer_size);
        gdi_layer_create_cf_using_outside_memory(
            GUI_SCREEN_SWITCH_EFFECT_LAYER_COLOR_FORMAT,
            0,
            0,
            UI_device_width,
            max_item_height,
            &menu_item_layer,
            (PU8)inline_buffer,
            inline_buffer_size);
    }
    else if (!(m->flags & UI_LIST_MENU_INEQUAL_HEIGHT_ITEMS))
#endif  /* __MMI_FTE_SUPPORT__ */
        {
#if defined(__MMI_SCREEN_SWITCH_EFFECT__)&& !defined(__MMI_REDUCED_UI_BUFFER__)
            /* use buffer b */
            gui_screen_switch_effect_get_frame_buffer_info(1, &g_gui_effect_layer_buffer, &buf_size);
#endif
            gdi_layer_create_cf_using_outside_memory(
                GUI_SCREEN_SWITCH_EFFECT_LAYER_COLOR_FORMAT,
                0,
                0,
                UI_device_width,
                max_item_height,
                &menu_item_layer,
                (PU8)g_gui_effect_layer_buffer,
                menu_item_layer_size);
        }
    }

    y1 += m->top;

    first_menu_item_index = menu_offset_y / item_height;
#ifndef __MMI_UI_LIST_SCROLL_BY_PIXEL__
    if ((first_menu_item_index == g_gui_list_ssp_stop_item_index) && 
        (g_gui_ssp_state == GUI_LIST_SMOOTH_SCROLLING_BY_PEN_STATE_FREE_RUN))
    {
        if (g_gui_ssp_free_run_momentum > 0)
        {
            // scroll up
            g_gui_ssp_free_run_momentum = 0;
        }
        else
        {
            // scroll down
            if (g_gui_ssp_old_first_menu_item_index != first_menu_item_index)
            {
                first_menu_item_index = g_gui_ssp_old_first_menu_item_index;
                menu_offset_y = (g_gui_ssp_old_first_menu_item_index) * item_height;
                g_gui_ssp_free_run_momentum = 0;
            }
        }
    }
#endif
    
    old_index = MMI_fixed_list_menu.current_displayed_item;
    if (m->flags & UI_LIST_MENU_INLINE_EDIT
#if defined(__MMI_UI_LIST_SUPPORT_UNEQUAL_HEIGHT_ITEM__)
        || m->flags & UI_LIST_MENU_INEQUAL_HEIGHT_ITEMS
#endif
    )
    {
        menu_height = 0;
        last_menu_item_index = MMI_fixed_list_menu.n_items - 1;
        first_menu_item_index = -1;
        for(i = 0; i < MMI_fixed_list_menu.n_items; i++)
        {
            MMI_fixed_list_menu.current_displayed_item = i;
            MMI_fixed_list_menu.item_measure_function(
                MMI_fixed_list_menu.items[i], 
                MMI_fixed_list_menu.common_item_data, 
                &item_width, 
                &item_height);
            menu_height += item_height;
            if (menu_height > menu_offset_y && first_menu_item_index == -1)
            {
                first_menu_item_index = i;
                show_y_offset = menu_offset_y - (menu_height - item_height);
                if (show_y_offset >= 0)
                    current_height -= show_y_offset;
#if defined(__MMI_UI_LIST_SCROLL_BY_PIXEL__)
                g_gui_ssp_old_first_menu_item_offset = show_y_offset;
#endif
#if defined(__MMI_UI_LIST_SUPPORT_UNEQUAL_HEIGHT_ITEM__)
                g_gui_ssp_old_full_height = menu_height - item_height;
#endif
            }
            if (menu_height > menu_offset_y + MMI_fixed_list_menu.height && last_menu_item_index == MMI_fixed_list_menu.n_items - 1)
            {
                last_menu_item_index = i - 1;
            }
            if (first_menu_item_index != -1 && i >= first_menu_item_index && i <= last_menu_item_index)
            {
                current_height += item_height;
            }
            total_height += item_height;
        }
        if (first_menu_item_index == -1)
        {
            show_y_offset = menu_offset_y;
            first_menu_item_index = MMI_fixed_list_menu.n_items - 1;
            last_menu_item_index = MMI_fixed_list_menu.n_items - 1;
        }
    }

    MMI_fixed_list_menu.current_displayed_item = -1;
    MMI_fixed_list_menu.item_measure_function(
        NULL, 
        MMI_fixed_list_menu.common_item_data,&highlight_width, &highlight_height);  
    MMI_fixed_list_menu.current_displayed_item = old_index;
    
    if (!(m->flags & UI_LIST_MENU_INLINE_EDIT) && !(m->flags & UI_LIST_MENU_INEQUAL_HEIGHT_ITEMS))
    {
        last_menu_item_index = (menu_offset_y + y2 - y1) / item_height;
    }

    if (first_menu_item_index < 0)
    {
        first_menu_item_index = 0;
        if (highlight_height == item_height * 2 && items_per_page < m->n_items)
        {
            last_menu_item_index --;
        }
    }
    last_menu_item_index ++;

    if (last_menu_item_index >= m->n_items)
    {
        if ((highlight_height == item_height * 2) && items_per_page <= m->n_items && 
            last_menu_item_index >= m->n_items && first_menu_item_index > m->highlighted_item)
        {
            first_menu_item_index --;
            last_menu_item_index = m->n_items - 1;
            change_locate = 1;
        }
        else
        {
            last_menu_item_index = m->n_items - 1;
        }
    }

#if defined(__MMI_UI_LIST_SUPPORT_UNEQUAL_HEIGHT_ITEM__)
    if (m->flags & UI_LIST_MENU_INEQUAL_HEIGHT_ITEMS)
    {
        S32 iwidth, iheight;
        for (i = first_menu_item_index; i <= last_menu_item_index; i++)
        {
            gui_list_menu_smooth_scrolling_get_item(i);
            gui_list_menu_measure_item(m, i, &iwidth, &iheight);
            if (max_item_height < iheight)
            {
                max_item_height = iheight;
            }
            if (max_item_height > m->height)
            {
                max_item_height = m->height;
                break;
            }
        }

        if (gui_asyncdynamic_list_error && 
            g_gui_list_menu_smooth_scrolling_menu_type == GUI_MENU_TYPE_ASYNCDYNAMIC)
        {
            gui_pop_clip();
			return;
        }

        menu_item_layer_size = (GUI_SCREEN_SWITCH_EEFECT_MAX_LCD_SIDE_LENGTH * max_item_height * GUI_EFFECT_LAYER_BYTE_PER_PIXEL);
        if (max_item_height > GUI_SSE_MAX_MENU_HIGHLIGHT_HEIGHT)
        {
            item_buffer = (U8*) mmi_frm_asm_alloc_anonymous_nc(menu_item_layer_size);
            gdi_layer_create_cf_using_outside_memory(
                GUI_SCREEN_SWITCH_EFFECT_LAYER_COLOR_FORMAT,
                0,
                0,
                UI_device_width,
                max_item_height,
                &menu_item_layer,
                (PU8)item_buffer,
                menu_item_layer_size);
        }
        else
        {
#if defined(__MMI_SCREEN_SWITCH_EFFECT__)&&!defined(__MMI_REDUCED_UI_BUFFER__)
            /* use buffer b */
            gui_screen_switch_effect_get_frame_buffer_info(1, &g_gui_effect_layer_buffer, &buf_size);
#endif
            gdi_layer_create_cf_using_outside_memory(
                GUI_SCREEN_SWITCH_EFFECT_LAYER_COLOR_FORMAT,
                0,
                0,
                UI_device_width,
                max_item_height,
                &menu_item_layer,
                (PU8)g_gui_effect_layer_buffer,
                menu_item_layer_size);
        }
    }
#endif

	if (!(m->flags & UI_LIST_MENU_INLINE_EDIT) && !(m->flags & UI_LIST_MENU_INEQUAL_HEIGHT_ITEMS))
	{
		show_y_offset = menu_offset_y % item_height;
		if ((highlight_height == 2 * item_height) &&
			(first_menu_item_index == MMI_fixed_list_menu.highlighted_item))
		{
			if ((menu_offset_y / item_height) > first_menu_item_index)
			{
				show_y_offset += item_height;
			}			
		}			  
	}

    x = m->highlight_x;
    y = y1 - show_y_offset;

    if (menu_offset_y < 0)
    {
        y = y1 - menu_offset_y;
    }

    gdi_layer_lock_frame_buffer();

    /* remove the highlight if it is not visible. important for dynamic and asyncdynamic menus */
    if (((m->highlighted_item < first_menu_item_index) || (m->highlighted_item > last_menu_item_index)) && 
        gui_slide_highlight_removed == MMI_FALSE)
    {
        item = gui_list_menu_smooth_scrolling_get_item(m->highlighted_item);
        if (item)
            m->item_remove_highlight_function(item, m->common_item_data);
        gui_slide_highlight_removed = MMI_TRUE;
    }        

    gdi_get_alpha_blending_source_layer(&src_layer_handle);

    item_y = y;

    if (first_menu_item_index <= m->highlighted_item && m->highlighted_item <= last_menu_item_index &&
        gui_slide_highlight_removed == MMI_FALSE)
    {
        item = gui_list_menu_smooth_scrolling_get_item(m->highlighted_item);
        if (item)
        {
            m->item_remove_highlight_function(item, m->common_item_data);        
            m->item_highlight_function(item, m->common_item_data);
        }
    }

    if (first_menu_item_index <= m->highlighted_item && m->highlighted_item <= last_menu_item_index &&
        gui_slide_highlight_removed == MMI_TRUE)
    {
        item = gui_list_menu_smooth_scrolling_get_item(m->highlighted_item);
        if (item)
        {
            m->item_highlight_function(item, m->common_item_data);
        }
        gui_slide_highlight_removed = MMI_FALSE;
    }

    GUI_RECT(menu_rect, m->x, m->y, m->width, m->height);

    for (i = first_menu_item_index; i <= last_menu_item_index; i++)
    {
        if (i == MMI_fixed_list_menu.highlighted_item)
            MMI_fixed_list_menu.current_displayed_item = -1;
        else
            MMI_fixed_list_menu.current_displayed_item = i;

        item = gui_list_menu_smooth_scrolling_get_item(i);
        if (item)
        {
        MMI_fixed_list_menu.item_measure_function(
            item, 
            MMI_fixed_list_menu.common_item_data,&item_width, &item_height);        
        }

        /* draw the first and the last item on the separated buffer */
        if (((i == first_menu_item_index) || (item_y + item_height > m->y + m->height))
            && first_menu_item_index != last_menu_item_index)
        {
            GUI_RECT(item_rect, x, item_y, item_width, item_height);

            if (gui_rect_get_intersection(&menu_rect, &item_rect, &result_rect))
            {
                /* draw the partial menu item on another layer */
                gdi_layer_push_and_set_active(menu_item_layer);
                gui_swla_log_start("CLR");
                if (g_gui_ssp_static_layer == GDI_NULL_HANDLE)
                {
                    gdi_layer_reset_clip();
#ifdef __LOW_COST_SUPPORT_COMMON__
                    gdi_2d_fill_rect((gdi_handle)gdi_act_layer,
                                     (gdi_handle)gdi_act_layer,
                                     result_rect.x,
                                     result_rect.y - item_y,
                                     result_rect.width,
                                     result_rect.height,
                                     0,
                                     GDI_COLOR_TRANSPARENT,
                                     0,
                                     NULL);
#else
                    gdi_layer_clear(GDI_COLOR_TRANSPARENT);
#endif
                }
                else
                {
                    gdi_layer_push_clip();
                    gdi_layer_set_clip(result_rect.x, result_rect.y, result_rect.x + result_rect.width - 1, result_rect.y + result_rect.height - 1);
                    gdi_draw_solid_rect(
                        menu_rect.x, 
                        menu_rect.y, 
                        menu_rect.x + menu_rect.width - 1, 
                        menu_rect.y + menu_rect.height - 1,
                        GDI_COLOR_TRANSPARENT);
                }
                gui_swla_log_stop("CLR");

                if (g_gui_ssp_static_layer == GDI_NULL_HANDLE)
                {
                    if (i == first_menu_item_index && item_height > max_item_height)
                    {
                        gdi_layer_set_position(0, item_y + (item_height - max_item_height));
                    }
                    else
                    {
                        gdi_layer_set_position(0, item_y);
                    }
                }

                /* must enable the source key to get rid of the transparent color in IMAGE highlight */
                gdi_layer_set_source_key(TRUE, GDI_COLOR_TRANSPARENT);                
                gui_swla_log_start("SIT");
                if (g_gui_ssp_static_layer == GDI_NULL_HANDLE)
                {
                    if (i == first_menu_item_index && item_height > max_item_height)
                    {
                        gui_list_menu_smooth_scrolling_show_item(i, x, max_item_height - item_height);
                    }
                    else
                    {
                        gui_list_menu_smooth_scrolling_show_item(i, x, 0);
                    }
                }
                else
                {
                    gui_list_menu_smooth_scrolling_show_item(i, x, item_y);
                    gdi_layer_pop_clip();
                }
                gui_swla_log_stop("SIT");
            #ifdef __MMI_FTE_SUPPORT__ 
                if (m->flags & UI_LIST_MENU_INLINE_EDIT)
                {
                    wgui_inline_shift_input_cursor(first_menu_item_index, last_menu_item_index, i, item_y);
                }
            #endif

                if (gui_asyncdynamic_list_error && 
                    (g_gui_list_menu_smooth_scrolling_menu_type == GUI_MENU_TYPE_ASYNCDYNAMIC ||
                    g_gui_list_menu_smooth_scrolling_old_menu_type == GUI_MENU_TYPE_ASYNCDYNAMIC))
                {
                    gdi_layer_pop_and_restore_active();
                    if (g_gui_ssp_static_layer == NULL)
                    {
                        gdi_layer_free(menu_item_layer);
                    }
                    gui_pop_clip();
                    gdi_layer_unlock_frame_buffer();
                    gdi_layer_blt_previous(x1, y1, x2, y2);
#ifdef __MMI_FTE_SUPPORT__
                    if (m->flags & UI_LIST_MENU_INLINE_EDIT && INLINE_FTE_MULTILINE_HEIGHT > GUI_SSE_MAX_MENU_HIGHLIGHT_HEIGHT)
                    {
                        mmi_frm_scrmem_free(inline_buffer);
                    }
#endif
#ifdef __MMI_UI_LIST_SUPPORT_UNEQUAL_HEIGHT_ITEM__
                    if (m->flags & UI_LIST_MENU_INEQUAL_HEIGHT_ITEMS && max_item_height > GUI_SSE_MAX_MENU_HIGHLIGHT_HEIGHT)
                    {
                        mmi_frm_asm_free_anonymous(item_buffer);
                    }
#endif
                    return;
                }
                /* disable the source key to make flattening (copying) ok */
                gdi_layer_set_source_key(FALSE, GDI_COLOR_TRANSPARENT);                

                gdi_layer_pop_and_restore_active();

                /* flatten the partial item to the main base layer */
                gdi_layer_push_and_set_active(m->act_layer_handle);
                gdi_layer_push_clip();
                gdi_layer_set_clip(result_rect.x, result_rect.y, result_rect.x + result_rect.width - 1, result_rect.y + result_rect.height - 1);

                gdi_layer_get_buffer_ptr(&buf_ptr);
                gui_swla_log_start("FLT");
#ifdef __MMI_FTE_SUPPORT__ 
                if (wgui_is_wallpaper_on_bottom() == MMI_FALSE)
                {
                    gdi_layer_push_and_set_active(menu_item_layer);
                    gdi_layer_set_source_key(TRUE, GDI_COLOR_TRANSPARENT);    
                    gdi_layer_pop_and_restore_active();
                    if (g_gui_list_hide_menu)
                    {
                        g_gui_list_hide_menu(result_rect.x, result_rect.y, result_rect.x + result_rect.width - 1, result_rect.y + result_rect.height - 1);
                    }
                    if (g_gui_ssp_static_layer)
                    {
                        gd_bitblt[GUI_SCREEN_SWITCH_EFFECT_LAYER_COLOR_FORMAT](
                            buf_ptr,
                            UI_DEVICE_WIDTH,
                            UI_DEVICE_HEIGHT,
                            result_rect.x,
                            result_rect.y,
                            result_rect.x + result_rect.width - 1,
                            result_rect.y + result_rect.height - 1,
                            static_layer_buf_ptr,
                            UI_DEVICE_WIDTH,
                            UI_DEVICE_HEIGHT,
                            result_rect.x,
                            result_rect.y,
                            result_rect.x + result_rect.width - 1,
                            result_rect.y + result_rect.height - 1,
                            result_rect.x,
                            result_rect.y,
                            result_rect.x + result_rect.width - 1,
                            result_rect.y + result_rect.height - 1,
                            GDI_COLOR_TRANSPARENT,
                            0x01ffffff);
                    }
                    else
                    {
#ifdef __LOW_COST_SUPPORT_COMMON__
                        gdi_layer_flatten_nb_with_clip_ext(m->act_layer_handle, menu_item_layer, 0, 0, 0, 0, 0, 0);
#else
                        gdi_layer_flatten_with_clipping(m->act_layer_handle, menu_item_layer, 0, 0);
#endif
                    }
                }
                else
                {
                    if (g_gui_ssp_static_layer)
                    {
                        gd_bitblt[GUI_SCREEN_SWITCH_EFFECT_LAYER_COLOR_FORMAT](
                            buf_ptr,
                            UI_DEVICE_WIDTH,
                            UI_DEVICE_HEIGHT,
                            result_rect.x,
                            result_rect.y,
                            result_rect.x + result_rect.width - 1,
                            result_rect.y + result_rect.height - 1,
                            static_layer_buf_ptr,
                            UI_DEVICE_WIDTH,
                            UI_DEVICE_HEIGHT,
                            result_rect.x,
                            result_rect.y,
                            result_rect.x + result_rect.width - 1,
                            result_rect.y + result_rect.height - 1,
                            result_rect.x,
                            result_rect.y,
                            result_rect.x + result_rect.width - 1,
                            result_rect.y + result_rect.height - 1,
                            GDI_COLOR_TRANSPARENT,
                            0x01ffffff);
                    }
                    else
                    {
#ifdef __LOW_COST_SUPPORT_COMMON__
                        gdi_layer_flatten_nb_with_clip_ext(menu_item_layer, 0, 0, 0, 0, 0, 0, 0);
#else
                        gdi_layer_flatten_with_clipping(menu_item_layer, 0, 0, 0);
#endif
                    }
                }
#else
                if (g_gui_ssp_static_layer)
                {
                    gd_bitblt[GUI_SCREEN_SWITCH_EFFECT_LAYER_COLOR_FORMAT](
                        buf_ptr,
                        UI_DEVICE_WIDTH,
                        UI_DEVICE_HEIGHT,
                        result_rect.x,
                        result_rect.y,
                        result_rect.x + result_rect.width - 1,
                        result_rect.y + result_rect.height - 1,
                        static_layer_buf_ptr,
                        UI_DEVICE_WIDTH,
                        UI_DEVICE_HEIGHT,
                        result_rect.x,
                        result_rect.y,
                        result_rect.x + result_rect.width - 1,
                        result_rect.y + result_rect.height - 1,
                        result_rect.x,
                        result_rect.y,
                        result_rect.x + result_rect.width - 1,
                        result_rect.y + result_rect.height - 1,
                        GDI_COLOR_TRANSPARENT,
                        0x01ffffff);
                }
                else
                {
                    gdi_layer_flatten_with_clipping(menu_item_layer, 0, 0, 0);
                }
#endif
                gui_swla_log_stop("FLT");
                gdi_layer_pop_clip();
                gdi_layer_pop_and_restore_active();
            }                
            else
            {
            #ifdef __MMI_FTE_SUPPORT__ 
                if (m->flags & UI_LIST_MENU_INLINE_EDIT)
                {
                    wgui_inline_shift_input_cursor(-1, -1, -1, 0);
                }
            #endif
            }

        }
        else
        {
            gui_swla_log_start("SIT");
            gui_list_menu_smooth_scrolling_show_item(i, x, item_y);
            gui_swla_log_stop("SIT");
            if (gui_asyncdynamic_list_error && 
                (g_gui_list_menu_smooth_scrolling_menu_type == GUI_MENU_TYPE_ASYNCDYNAMIC ||
                g_gui_list_menu_smooth_scrolling_old_menu_type == GUI_MENU_TYPE_ASYNCDYNAMIC))
            {
                gui_pop_clip();
                if (g_gui_ssp_static_layer == NULL)
                {
                    gdi_layer_free(menu_item_layer);
                }
                gdi_layer_unlock_frame_buffer();
                gdi_layer_blt_previous(x1, y1, x2, y2);
#ifdef __MMI_FTE_SUPPORT__
                if (m->flags & UI_LIST_MENU_INLINE_EDIT && INLINE_FTE_MULTILINE_HEIGHT > GUI_SSE_MAX_MENU_HIGHLIGHT_HEIGHT)
                {
                    mmi_frm_scrmem_free(inline_buffer);
                }
#endif
#ifdef __MMI_UI_LIST_SUPPORT_UNEQUAL_HEIGHT_ITEM__
                if (m->flags & UI_LIST_MENU_INEQUAL_HEIGHT_ITEMS && max_item_height > GUI_SSE_MAX_MENU_HIGHLIGHT_HEIGHT)
                {
                    mmi_frm_asm_free_anonymous(item_buffer);
                }
#endif
                return;
            }
        }
        
        item_y += item_height;
    }

    item_height = gui_list_menu_smooth_scrolling_get_menu_item_height();
        
    /* draw the grid line */
#ifdef __MMI_UI_LIST_GRID_LINE__
    if (!(m->flags & UI_LIST_MENU_DISABLE_GRID_LINE))
    {
    U32 alpha = current_MMI_theme->list_grid_line_alpha * 255 / 100;
    gdi_layer_push_clip();
    gdi_layer_set_clip(
        MMI_fixed_list_menu.x, 
        MMI_fixed_list_menu.y, 
        MMI_fixed_list_menu.x + MMI_fixed_list_menu.width - 1, 
        MMI_fixed_list_menu.y + MMI_fixed_list_menu.height - 1);
    i = first_menu_item_index;
    if (m->flags & UI_LIST_MENU_INLINE_EDIT
#if defined(__MMI_UI_LIST_SUPPORT_UNEQUAL_HEIGHT_ITEM__)
        || m->flags & UI_LIST_MENU_INEQUAL_HEIGHT_ITEMS
#endif
    )
    {
        if(i != m->highlighted_item)
        {
            MMI_fixed_list_menu.current_displayed_item = i;
        }
        else
        {
            MMI_fixed_list_menu.current_displayed_item = -1;
        }
        m->item_measure_function(m->items[i], m->common_item_data, &item_width, &item_height);
    }
    
#ifndef __MMI_FTE_SUPPORT__    
   show_scrollbar = gui_show_list_menu_check_scrollbar(m);
#endif  // __MMI_FTE_SUPPORT__    
    
    if (mmi_fe_get_r2l_state())
    {
        grid_x = x1 + GUI_MENUITEM_X2_GAP;
#ifndef __MMI_FTE_SUPPORT__
        if (show_scrollbar)
        {
            grid_x += m->vbar.width;
        }
        else
#endif /* __MMI_FTE_SUPPORT__ */
        {
            grid_x += GUI_LIST_MENU_X2_GAP;
        }
    }
    else
    {
        grid_x = x1 + GUI_MENUITEM_X1_GAP;    
    }
    
    for (item_y = y; item_y < m->y + m->height - 1; item_y += item_height)
    {
        S32  grid_y;//old_index,
//        U32 ret_flag = 0, ret_flag_ext = 0;

        if ((m->flags & UI_LIST_MENU_DISABLE_EXT_GRID_LINE) && (i > m->n_items - 1))
        {
            break;
        }

        if (i == MMI_fixed_list_menu.highlighted_item)
            MMI_fixed_list_menu.current_displayed_item = -1;
        else
            MMI_fixed_list_menu.current_displayed_item = i;
        if (item_y + item_height >= m->y)
        {
            if (m->flags & UI_LIST_MENU_INLINE_EDIT && i <= (m->n_items - 1))
            {
                m->item_measure_function(m->items[i], m->common_item_data, &item_width, &item_height);
                if ( i >= m->n_items || (i && wgui_inline_editor_if_need_draw_separator_line(i - 1) && i != first_menu_item_index))
                {
                    gui_swla_log_start("GRD");
                    gdi_effect_alpha_blending_rect(
                        src_layer_handle,
                        grid_x, 
                        item_y, 
                        grid_x + item_width - 1,
                        item_y,
                        alpha,
                        current_MMI_theme->list_grid_line_color->r,
                        current_MMI_theme->list_grid_line_color->g,
                        current_MMI_theme->list_grid_line_color->b);
                    gui_swla_log_stop("GRD");
                }

            }
            else if(i != MMI_fixed_list_menu.highlighted_item - 1)
            {
                U32 ret_flag = 0;
                U32 ret_flag_ext = 0;
                if (g_gui_list_get_menuitem_flags && (i >= 0) && (i < MMI_fixed_list_menu.n_items))
                {
                    g_gui_list_get_menuitem_flags(i, &ret_flag, &ret_flag_ext);
                }

                if (i == MMI_fixed_list_menu.highlighted_item && !(m->flags & UI_LIST_MENU_INLINE_EDIT) && !(m->flags & UI_LIST_MENU_INEQUAL_HEIGHT_ITEMS))
                {
                    grid_y = item_y + highlight_height;
                }
                else
                {
                    if (m->flags & UI_LIST_MENU_INLINE_EDIT)
                    {
                        grid_y = item_y;
                    }
#if defined(__MMI_UI_LIST_SUPPORT_UNEQUAL_HEIGHT_ITEM__)
                    else if (m->flags & UI_LIST_MENU_INEQUAL_HEIGHT_ITEMS)
                    {
                        old_index = MMI_fixed_list_menu.current_displayed_item;
                        MMI_fixed_list_menu.current_displayed_item = i;
                        MMI_fixed_list_menu.item_measure_function(
                            NULL, 
                            MMI_fixed_list_menu.common_item_data,&item_width, &item_height);  
                        MMI_fixed_list_menu.current_displayed_item = old_index;
                        grid_y = item_y + item_height;
                    }
#endif
                    else
                    {
                        grid_y = item_y + item_height;
                    }
                }

                if (grid_y < m->y + m->height - 1 && !(ret_flag_ext & UI_MENUITEM_EXT_SHOW_DOWN_SEPARATORLINE))
                {
                    gui_swla_log_start("GRD");
                    gdi_effect_alpha_blending_rect(
                        src_layer_handle,
                        grid_x, 
                        grid_y, 
                        grid_x + item_width - 1,
                        grid_y,
                        alpha,
                        current_MMI_theme->list_grid_line_color->r,
                        current_MMI_theme->list_grid_line_color->g,
                        current_MMI_theme->list_grid_line_color->b);
                    gui_swla_log_stop("GRD");
                }
            }
        }

        if (i == MMI_fixed_list_menu.highlighted_item && !(m->flags & UI_LIST_MENU_INLINE_EDIT))
        {
            if (highlight_height != item_height)
                item_y += highlight_height - item_height;
        }
        if (m->flags & UI_LIST_MENU_INLINE_EDIT && i <= (m->n_items - 1)
#if defined(__MMI_UI_LIST_SUPPORT_UNEQUAL_HEIGHT_ITEM__)
            || m->flags & UI_LIST_MENU_INEQUAL_HEIGHT_ITEMS && i <= (m->n_items - 1)
#endif
        )
        {
            if(i != m->highlighted_item)
            {
                MMI_fixed_list_menu.current_displayed_item = i;
            }
            else
            {
                MMI_fixed_list_menu.current_displayed_item = -1;
            }
            m->item_measure_function(m->items[i], m->common_item_data, &item_width, &item_height);
        }
        i ++;
    }

    gdi_layer_pop_clip();
    }
#endif /* __MMI_UI_LIST_GRID_LINE__ */        

    if (g_gui_ssp_static_layer)
    {
        gdi_layer_push_and_set_active(g_gui_ssp_static_layer);
        gdi_layer_set_source_key(MMI_TRUE, GDI_COLOR_TRANSPARENT);
        gdi_layer_clear(GDI_COLOR_TRANSPARENT);
        gdi_layer_pop_and_restore_active();
    }

    /* 
     * update the scrollbar smoothly
     */
    // TODO: Deciding the scrollbar is showed or not is tricky. Should decide this in show menu functions.
#ifndef __MMI_FTE_SUPPORT__
    if (item_width <= m->width - m->vbar.width)
#endif
    {
        gui_push_clip();
        if (mmi_fe_get_r2l_state())
        {
            gdi_layer_set_clip(
                MMI_fixed_list_menu.x, 
                MMI_fixed_list_menu.y, 
                MMI_fixed_list_menu.x + MMI_fixed_list_menu.vbar.width - 1, 
                MMI_fixed_list_menu.y + MMI_fixed_list_menu.height - 1);
        }
        else
        {
            gdi_layer_set_clip(
                MMI_fixed_list_menu.x + MMI_fixed_list_menu.width - 1 - MMI_fixed_list_menu.vbar.width, 
                MMI_fixed_list_menu.y, 
                MMI_fixed_list_menu.x + MMI_fixed_list_menu.width - 1, 
                MMI_fixed_list_menu.y + MMI_fixed_list_menu.height - 1);
       }

#ifdef __MMI_UI_LIST_SCROLL_BY_PIXEL__
        menu_height = 0;
        total_height = 0;
        current_height = 0;
        for (i = 0; i < MMI_fixed_list_menu.n_items; i++)
        {
            gui_list_menu_measure_item(m, i, &item_width, &item_height);

            menu_height += item_height;
            if (i == first_menu_item_index)
            {
                gui_set_vertical_scrollbar_value(&m->vbar, menu_height - (item_height - g_gui_ssp_old_first_menu_item_offset));
            }
            total_height += item_height;
        }
        gui_set_vertical_scrollbar_value(&m->vbar, menu_offset_y);
        gui_set_vertical_scrollbar_range(&m->vbar, total_height);
        gui_set_vertical_scrollbar_scale(&m->vbar, MMI_fixed_list_menu.height);
#else
        if (m->flags & UI_LIST_MENU_INLINE_EDIT)
        {
            /* menu height might be larger than normal one. Prevent the scrollbar mismatch when going back to the normal menu */
            gui_set_vertical_scrollbar_range(&m->vbar, total_height);
            if ((*g_gui_ssp_menu_over_limit_coefficient) != 0)
            {
                gui_set_vertical_scrollbar_scale(&m->vbar, current_height);
            }
        }
        else
        {
            /* menu height might be larger than normal one. Prevent the scrollbar mismatch when going back to the normal menu */
            gui_set_vertical_scrollbar_range(&m->vbar, m->n_items * item_height);
            
            /* menu height might be larger than normal one. Prevent the scrollbar mismatch when going back to the normal menu */
            menu_height = (last_menu_item_index - first_menu_item_index + 1) * item_height;
            if (menu_height <= item_height)
            {
                menu_height = item_height;
            }
            normal_menu_height = items_per_page * item_height;
            if ((*g_gui_ssp_menu_over_limit_coefficient) != 0)
            {
                if (menu_height > normal_menu_height)
                {
                    gui_set_vertical_scrollbar_scale(&m->vbar, normal_menu_height);
                }
                else
                {
                    gui_set_vertical_scrollbar_scale(&m->vbar, menu_height);
                }
            }
            else
            {
                gui_set_vertical_scrollbar_scale(&m->vbar, m->displayed_items * item_height);
            }
        }
        gui_set_vertical_scrollbar_value(&m->vbar, menu_offset_y);
#endif

        /* Scrollbar style 6 in the single page menu hides the indicator button. */
        if (gui_vertical_scrollbar_auto_hide_scroll_button(&m->vbar) && 
            m->n_items <= items_per_page)
        {
            gui_set_vertical_scrollbar_range(&m->vbar, m->n_items);
            gui_set_vertical_scrollbar_scale(&m->vbar, m->n_items);
            gui_set_vertical_scrollbar_value(&m->vbar, 0);
        }

        gdi_layer_get_active(&act_layer);
#ifdef __MMI_FTE_SUPPORT__
        if (dm_get_scr_bg_layer() != GDI_ERROR_HANDLE)
        {
            if (g_gui_ssp_static_layer)
            {
                U8 *act_buf_ptr, *bg_buf_ptr;
                S32 clip_x1, clip_x2, clip_y1, clip_y2;
                S32 buf_offset, copy_buf_size;

                clip_x1 = m->x;
                clip_y1 = m->y;
                clip_x2 = m->x + m->width - 1;
                clip_y2 = m->y + m->height - 1;
                
                buf_offset = UI_DEVICE_WIDTH * m->y * GUI_SCREEN_SWITCH_EFFECT_LAYER_COLOR_FORMAT;
                copy_buf_size = UI_DEVICE_WIDTH * m->height * GUI_SCREEN_SWITCH_EFFECT_LAYER_COLOR_FORMAT;
                
                gdi_layer_get_buffer_ptr(&act_buf_ptr);
                gdi_layer_push_and_set_active(dm_get_scr_bg_layer());
                gdi_layer_get_buffer_ptr(&bg_buf_ptr);
                gdi_layer_pop_and_restore_active();

                gui_swla_log_start("FLT");
                memcpy(static_layer_buf_ptr + buf_offset, bg_buf_ptr + buf_offset, copy_buf_size);

                /* use static layer buffer as temp buffer to store the flatten result layer buffer */
                gd_bitblt[GUI_SCREEN_SWITCH_EFFECT_LAYER_COLOR_FORMAT](
                            static_layer_buf_ptr,
                            UI_DEVICE_WIDTH,
                            UI_DEVICE_HEIGHT,
                            clip_x1,
                            clip_y1,
                            clip_x2,
                            clip_y2,
                            act_buf_ptr,
                            UI_DEVICE_WIDTH,
                            UI_DEVICE_HEIGHT,
                            clip_x1, 
                            clip_y1, 
                            clip_x2, 
                            clip_y2,
                            clip_x1,
                            clip_y1,
                            clip_x2,
                            clip_y2,
                            GDI_COLOR_TRANSPARENT,
                            0x01ffffff);
                memcpy(act_buf_ptr + buf_offset, static_layer_buf_ptr + buf_offset, copy_buf_size);

                /* clear the list area in util layer to make sure display normal */
                gdi_layer_push_and_set_active(g_gui_ssp_static_layer);
                gdi_draw_solid_rect(m->x, m->y, m->x + m->width, m->y + m->height - 1, GDI_COLOR_TRANSPARENT);
                gdi_layer_pop_and_restore_active();
                gui_swla_log_stop("FLT");
            }
            else
            {
                gui_swla_log_start("FLT");
                gdi_layer_flatten_with_clipping(dm_get_scr_bg_layer(), act_layer, 0, 0);
                gui_swla_log_stop("FLT");
            }
        }
#endif    
        gui_enable_scrollbar_redraw_clip(MMI_FALSE);
        gui_swla_log_start("SRB");
        gui_redraw_vertical_scrollbar(&m->vbar, MMI_FALSE);
        gui_swla_log_stop("SRB");
        gui_enable_scrollbar_redraw_clip(MMI_TRUE);
        gui_pop_clip();
    }        

    gui_pop_clip();
    /* 
     * It is very important to stop scrolling here since we just highlighted the highlighted item again, which
     * starts scrolling. Moreover, since we are re-using the effect layer, gui_ssp_stop_list_menu_scrolling()
     * also clears the effect layer to transparent.
     */    
    gui_ssp_stop_list_menu_scrolling();
    
    gdi_layer_unlock_frame_buffer();
    
    gui_swla_log_start("BLT");
    gdi_layer_blt_previous(x1, y1, x2, y2);
    gui_swla_log_stop("BLT");

    if (g_gui_ssp_static_layer == NULL)
    {
        gdi_layer_free(menu_item_layer);
    }

#ifdef __MMI_FTE_SUPPORT__
    if (m->flags & UI_LIST_MENU_INLINE_EDIT && INLINE_FTE_MULTILINE_HEIGHT > GUI_SSE_MAX_MENU_HIGHLIGHT_HEIGHT)
    {
        mmi_frm_scrmem_free(inline_buffer);
    }
#endif
#ifdef __MMI_UI_LIST_SUPPORT_UNEQUAL_HEIGHT_ITEM__
    if (m->flags & UI_LIST_MENU_INEQUAL_HEIGHT_ITEMS && max_item_height > GUI_SSE_MAX_MENU_HIGHLIGHT_HEIGHT)
    {
        mmi_frm_asm_free_anonymous(item_buffer);
    }
#endif

    
    g_gui_ssp_old_first_menu_item_index = first_menu_item_index;
    g_gui_ssp_current_menu_last_item_index = last_menu_item_index;
    g_gui_ssp_current_menu_y_offset = menu_offset_y;
    if (highlight_height == item_height * 2)
    {
        old_momentum = g_gui_ssp_free_run_momentum;
        g_gui_ssp_free_run_momentum = (S32)((float)g_gui_ssp_free_run_momentum * (*g_gui_ssp_free_run_scroll_coefficient));
        /* make sure converge to zero */
        if (old_momentum == g_gui_ssp_free_run_momentum)
        {
            g_gui_ssp_free_run_momentum = 0;
        }
        if (g_gui_ssp_free_run_momentum == 0 && change_locate)
        {
            g_gui_ssp_old_first_menu_item_index++;
            //g_gui_ssp_current_menu_last_item_index++;
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  gui_ssp_pen_down_hdlr
 * DESCRIPTION
 *  Pen down handler of Smooth Scrolling by Pen.
 * PARAMETERS
 *  point       [IN]    pen point
 * RETURNS
 *  MMI_TRUE if this pen event is handled; otherwise, MMI_FALSE.
 *****************************************************************************/
static MMI_BOOL gui_ssp_pen_down_hdlr(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    fixed_list_menu *m = &MMI_fixed_list_menu;
    S32 new_highlight_item_index, i, iwidth, iheight;
    gui_list_pen_enum menuitem_event;
    gui_pen_event_param_struct menuitem_param;
    S32 old_flags, old_highlight;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_gui_ssp_is_click_item_own_area = MMI_FALSE;
    gui_slide_highlight_removed = MMI_FALSE;
    g_gui_ssp_is_pen_down_in_list = MMI_FALSE;
    g_gui_ssp_have_goto_disabled_item = MMI_FALSE;
    g_gui_ssp_old_menu_highlight_item_index = MMI_fixed_list_menu.highlighted_item;
    g_gui_ssp_need_handle_item = MMI_FALSE;
#if defined(__MMI_UI_LIST_SCROLL_BY_PIXEL__)
    g_gui_ssp_clicked_half_item = -1;
#endif

    if (MMI_fixed_list_menu.n_items == 0)
        return MMI_FALSE;
    if (!gui_ssp_is_point_in_menu_rect((S32)point.x, (S32)point.y))
    {
        if (g_gui_ssp_state == GUI_LIST_SMOOTH_SCROLLING_BY_PEN_STATE_FREE_RUN)
        {
            gui_ssp_pen_up_hdlr(point);
            g_gui_ssp_state = GUI_LIST_SMOOTH_SCROLLING_BY_PEN_STATE_UNFOCUS;
            g_gui_ssp_is_pen_down_in_list = MMI_TRUE;
            return MMI_TRUE;  
        }    

        gui_ssp_pen_abort_hdlr(point);

        return MMI_FALSE;  
    }

    g_gui_ssp_pen_down_y = (S32)point.y;
    g_gui_ssp_free_run_mode = GUI_SSP_FREE_RUN_MODE_RECOVER;
    g_gui_ssp_pen_down_state = g_gui_ssp_state;

    switch (g_gui_ssp_state)
    {
        case GUI_LIST_SMOOTH_SCROLLING_BY_PEN_STATE_UNFOCUS:
            g_gui_ssp_old_first_menu_item_index = m->first_displayed_item;
            g_gui_ssp_state = GUI_LIST_SMOOTH_SCROLLING_BY_PEN_STATE_FOCUS;                
            break;

        case GUI_LIST_SMOOTH_SCROLLING_BY_PEN_STATE_FREE_RUN:
#ifdef __MMI_FTE_SUPPORT__ 
            if (g_gui_list_menu_smooth_scrolling_menu_type == GUI_MENU_TYPE_INLINE)
            {
                wgui_inline_set_ssp_redraw_state(MMI_TRUE);
            }
#endif
            gui_cancel_timer(gui_ssp_update_frame);        
            g_gui_ssp_state = GUI_LIST_SMOOTH_SCROLLING_BY_PEN_STATE_HOLD;       
            gui_list_menu_smooth_scrolling_get_item(m->highlighted_item);
            old_highlight = m->highlighted_item;
            m->flags |= UI_LIST_MENU_ENABLE_GOTO_HALF_ITEM;
            gui_ssp_sync_list_menu_display();
            m->flags &= ~UI_LIST_MENU_ENABLE_GOTO_HALF_ITEM;
            if (old_highlight != m->highlighted_item)
            {
                g_gui_ssp_have_goto_disabled_item = MMI_TRUE;
            }
            g_gui_ssp_old_first_menu_item_index = m->first_displayed_item;
            g_gui_ssp_state = GUI_LIST_SMOOTH_SCROLLING_BY_PEN_STATE_HOLD;               
            break;

        default:
            break;
    }
    if (g_gui_list_menu_smooth_scrolling_menu_type == GUI_MENU_TYPE_INVALID)
    {
        return MMI_FALSE;
    }
    /* goes to the selected item */
    if (gui_ssp_menu_translate_pen_position(m, (S32)point.x, g_gui_ssp_pen_down_y, &new_highlight_item_index))
    {
        if (new_highlight_item_index == m->highlighted_item)
        {   /* still have to redraw when the highlight does not change */
            if (g_gui_list_menu_smooth_scrolling_menu_type != GUI_MENU_TYPE_INLINE || g_gui_ssp_pen_down_state == GUI_LIST_SMOOTH_SCROLLING_BY_PEN_STATE_FREE_RUN)
            {
                gui_touch_feedback_play(GUI_TOUCH_FEEDBACK_DOWN);
                gui_list_menu_smooth_scrolling_redraw_list();
            }
        }
        else
        {
            if (g_gui_list_menu_smooth_scrolling_menu_type != GUI_MENU_TYPE_INLINE || g_gui_ssp_pen_down_state == GUI_LIST_SMOOTH_SCROLLING_BY_PEN_STATE_FREE_RUN)
            {
                old_flags = m->flags;
                m->flags &= ~UI_LIST_MENU_LOOP;
                m->flags |= UI_LIST_MENU_ENABLE_GOTO_HALF_ITEM;
                gui_list_menu_smooth_scrolling_goto_item(new_highlight_item_index);
#ifdef __MMI_UI_LIST_SCROLL_BY_PIXEL__
                g_gui_ssp_old_first_menu_item_index = m->first_displayed_item;
#endif
                m->flags = old_flags;

                if (new_highlight_item_index != m->highlighted_item)
                {
                    g_gui_ssp_have_goto_disabled_item = MMI_TRUE;
                }
                else
                {
                    gui_touch_feedback_play(GUI_TOUCH_FEEDBACK_DOWN);
                }
            }
        }

        /* check if the item handles the pen event */
        if (g_gui_ssp_state == GUI_LIST_SMOOTH_SCROLLING_BY_PEN_STATE_FOCUS)
        {
#if defined(__MMI_UI_LIST_SCROLL_BY_PIXEL__)
            if (gui_ssp_pen_down_on_half_item(point, new_highlight_item_index))
            {
                g_gui_ssp_clicked_half_item = new_highlight_item_index;
            }
            else
#endif
            if (gui_ssp_send_pen_event_to_item(
                    MMI_PEN_EVENT_DOWN, 
                    &point,
                    new_highlight_item_index,
                    m->highlight_x,
                    m->highlight_y,
                    &menuitem_event,
                    &menuitem_param))
            {
                m->pen_state.pen_on_scrollbar = 0;
                m->pen_state.handled_by_menu_item = 1;

                if (menuitem_event == GUI_LIST_PEN_DOWN_ON_STATE_BOX)
                {
                    m->pen_state.pen_down_state_box = 1;
                    g_gui_ssp_state = GUI_LIST_SMOOTH_SCROLLING_BY_PEN_STATE_UNFOCUS;
                    g_gui_ssp_is_click_item_own_area = MMI_TRUE;
                    
                    return MMI_TRUE;                
                }        
                else
                {
                    g_gui_ssp_need_handle_item = MMI_TRUE;
                }
            }        
        }        
    }
    else if (!gui_ssp_is_point_in_menu_rect((S32)point.x, (S32)point.y))
//    else
    {
        /*
         * Redraw the list when pen down is not on the valid item and the menu is free running.
         * Note that FREE_RUN went to HOLD already.
         */
        if (g_gui_ssp_state == GUI_LIST_SMOOTH_SCROLLING_BY_PEN_STATE_HOLD)
        {
            gui_list_menu_smooth_scrolling_redraw_list();
        }
        
        g_gui_ssp_state = GUI_LIST_SMOOTH_SCROLLING_BY_PEN_STATE_UNFOCUS;
    
        return MMI_FALSE;
    }

    kal_get_time(&g_gui_ssp_pen_down_time);

    if (g_gui_list_menu_smooth_scrolling_menu_type == GUI_MENU_TYPE_INLINE
#if defined(__MMI_UI_LIST_SUPPORT_UNEQUAL_HEIGHT_ITEM__)
        || MMI_fixed_list_menu.flags & UI_LIST_MENU_INEQUAL_HEIGHT_ITEMS
#endif
        )
    {
        g_gui_ssp_start_menu_offset = 0;
        for (i = 0; i < MMI_fixed_list_menu.first_displayed_item; i++)
        {
            MMI_fixed_list_menu.current_displayed_item = i;
            MMI_fixed_list_menu.item_measure_function(
                MMI_fixed_list_menu.items[i], 
                MMI_fixed_list_menu.common_item_data,
                &iwidth, 
                &iheight);
            g_gui_ssp_start_menu_offset += iheight;
        }
#if defined(__MMI_UI_LIST_SUPPORT_UNEQUAL_HEIGHT_ITEM__)
        g_gui_ssp_old_full_height = g_gui_ssp_start_menu_offset;
#endif
#ifdef __MMI_UI_LIST_SCROLL_BY_PIXEL__
        g_gui_ssp_old_first_menu_item_offset = MMI_fixed_list_menu.first_displayed_offset;
        g_gui_ssp_start_menu_offset += MMI_fixed_list_menu.first_displayed_offset;
#endif
    }
    else
    {
        g_gui_ssp_start_menu_offset = m->first_displayed_item * gui_list_menu_smooth_scrolling_get_menu_item_height();
#ifdef __MMI_UI_LIST_SCROLL_BY_PIXEL__
        g_gui_ssp_start_menu_offset += MMI_fixed_list_menu.first_displayed_offset;
#endif
    }
    g_gui_ssp_current_menu_y_offset = g_gui_ssp_start_menu_offset;


    if (g_dm_data.s32CatId == MMI_CATEGORY_CASCADING_MENU_ID)
    {
        m->disable_move_highlight = MMI_FALSE;
        m->disable_up_select = MMI_FALSE;
    }

    if (g_gui_list_menu_smooth_scrolling_menu_type == GUI_MENU_TYPE_INLINE &&
        g_gui_ssp_pen_down_state != GUI_LIST_SMOOTH_SCROLLING_BY_PEN_STATE_FREE_RUN)
        return MMI_FALSE;

    return MMI_TRUE;
}



/*****************************************************************************
 * FUNCTION
 *  gui_menuitem_handle_ssp_pen_up
 * DESCRIPTION
 *  menuitem handler pen up event.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_menuitem_handle_ssp_pen_up()
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    fixed_list_menu *m = &MMI_fixed_list_menu;
#ifdef __MMI_FTE_SUPPORT__
    MMI_BOOL is_inline_handle;
    gui_common_menuitem_base_struct * cm;
#endif // __MMI_FTE_SUPPORT__
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_FTE_SUPPORT__     
    
    is_inline_handle = MMI_TRUE;
    if (g_gui_list_menu_smooth_scrolling_menu_type == GUI_MENU_TYPE_INLINE)
    {
        if (g_gui_ssp_old_menu_highlight_item_index == MMI_fixed_list_menu.highlighted_item)
        {
            is_inline_handle = inline_is_handle_fte_tap(ENUM_TAP_ON_HIGHLIGHTED_ITEM, MMI_fixed_list_menu.highlighted_item);
        }
        else
        {
            is_inline_handle = inline_is_handle_fte_tap(ENUM_TAP_ON_NONHIGHLIGHTED_ITEM, MMI_fixed_list_menu.highlighted_item);
        }
        if (is_inline_handle == MMI_TRUE)
        {
            return;
        }
    }
    cm = (gui_common_menuitem_base_struct*)MMI_fixed_list_menu.common_item_data;
    if (cm->ext_flags & UI_MENUITEM_EXT_SHOW_ICONTEXT_CHECKBOX)
    {
        if (cm->checkbox_clicked_callback(m->highlighted_item) == MMI_TRUE)
        {                    
            gui_list_menu_smooth_scrolling_redraw_list();
        }
        return;
    }
    if (g_gui_list_menu_smooth_scrolling_menu_type != GUI_MENU_TYPE_INLINE || !is_inline_handle)
    {
        if (MMI_fixed_list_menu.tap_callback_funtion == NULL)
        {
            gui_ssp_execute_lsk(KEY_EVENT_UP);
        }
        else
        {
            if (g_gui_ssp_old_menu_highlight_item_index == MMI_fixed_list_menu.highlighted_item)
            {
                MMI_fixed_list_menu.tap_callback_funtion(ENUM_TAP_ON_HIGHLIGHTED_ITEM, MMI_fixed_list_menu.highlighted_item);
            }
            else
            {
                MMI_fixed_list_menu.tap_callback_funtion(ENUM_TAP_ON_NONHIGHLIGHTED_ITEM, MMI_fixed_list_menu.highlighted_item);
            }
        }
    }
#else
    
    if (m->pen_event_current_selected_callback_function != NULL)
    {
        m->pen_event_current_selected_callback_function();
    }
    else if (m->tap_callback_funtion != NULL)
    {
        if (g_gui_ssp_old_menu_highlight_item_index == m->highlighted_item)
        {
            m->tap_callback_funtion(ENUM_TAP_ON_HIGHLIGHTED_ITEM, m->highlighted_item);
        }
        else
        {
            m->tap_callback_funtion(ENUM_TAP_ON_NONHIGHLIGHTED_ITEM, m->highlighted_item);
        }
    }
    else
    {
        gui_ssp_execute_lsk(KEY_EVENT_UP);
    }
#endif

}

/*****************************************************************************
 * FUNCTION
 *  gui_ssp_pen_up_hdlr
 * DESCRIPTION
 *  Pen up handler of Smooth Scrolling by Pen.
 * PARAMETERS
 *  point       [IN]    pen point
 * RETURNS
 *  MMI_TRUE if this pen event is handled; otherwise, MMI_FALSE.
 *****************************************************************************/
static MMI_BOOL gui_ssp_pen_up_hdlr(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    fixed_list_menu *m = &MMI_fixed_list_menu;
    S32 item_height;
    U32 pen_up_time, pen_down_to_up_delta_time;
    S32 pen_down_to_up_y_delta;
    S32 up_item_index, list_error;
    gui_list_smooth_scrolling_by_pen_state_enum gui_ssp_old_state, gui_ssp_state_redraw;

    gui_list_pen_enum menuitem_event;
    gui_pen_event_param_struct menuitem_param;
    MMI_BOOL first_item_changed, is_slow_data, trans_ret;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (MMI_fixed_list_menu.n_items == 0)
        return MMI_FALSE;
    
    item_height = gui_list_menu_smooth_scrolling_get_menu_item_height();

#if defined(__MMI_UI_LIST_SCROLL_BY_PIXEL__)
    if (gui_ssp_pen_up_on_half_item())
    {
        return MMI_TRUE;
    }
#endif

    if ((g_gui_ssp_state == GUI_LIST_SMOOTH_SCROLLING_BY_PEN_STATE_UNFOCUS) ||
        (g_gui_ssp_need_handle_item && g_gui_ssp_state == GUI_LIST_SMOOTH_SCROLLING_BY_PEN_STATE_FOCUS))
    {
        /* The pen down was handled by the item. Now check if it still handles pen up. */
        if ((g_gui_ssp_is_click_item_own_area || g_gui_ssp_need_handle_item) &&
            gui_ssp_is_point_in_menu_rect((S32)point.x, (S32)point.y) &&
            gui_ssp_send_pen_event_to_item(
                MMI_PEN_EVENT_UP,
                &point,
                m->highlighted_item,
                m->highlight_x,
                m->highlight_y,
                &menuitem_event,
                &menuitem_param))
        {
            gui_swla_log_start("TAP");
            if (g_gui_list_menu_smooth_scrolling_menu_type != GUI_MENU_TYPE_INVALID)
            {
                gui_list_menu_smooth_scrolling_redraw_list();
                if (g_gui_list_menu_smooth_scrolling_menu_type == GUI_MENU_TYPE_DYNAMIC)
                {
                    if (MMI_fixed_list_menu.n_items != 0 && !in_dynamic_item_buffer(MMI_fixed_list_menu.highlighted_item))
                        return MMI_TRUE;
                }
                else if (g_gui_list_menu_smooth_scrolling_menu_type == GUI_MENU_TYPE_ASYNCDYNAMIC)
                {
                    if (MMI_fixed_list_menu.n_items != 0 && !in_asyncdynamic_item_buffer(MMI_fixed_list_menu.highlighted_item))
                        return MMI_TRUE;
                }
#ifdef __MMI_FTE_SUPPORT__
                if (g_gui_list_menu_smooth_scrolling_menu_type == GUI_MENU_TYPE_INLINE)
                {
                    if (g_gui_ssp_old_menu_highlight_item_index == MMI_fixed_list_menu.highlighted_item)
                    {
                        inline_is_handle_fte_tap(ENUM_TAP_ON_HIGHLIGHTED_ITEM, MMI_fixed_list_menu.highlighted_item);
                    }
                    else
                    {
                        inline_is_handle_fte_tap(ENUM_TAP_ON_NONHIGHLIGHTED_ITEM, MMI_fixed_list_menu.highlighted_item);
                    }
                }
#else
               
                if (m->pen_event_current_selected_callback_function != NULL)
                {
                    m->pen_event_current_selected_callback_function();
                }
                else if (m->tap_callback_funtion != NULL)
                {
                    if (g_gui_ssp_old_menu_highlight_item_index == m->highlighted_item)
                    {
                        m->tap_callback_funtion(ENUM_TAP_ON_HIGHLIGHTED_ITEM, m->highlighted_item);
                    }
                    else
                    {
                        m->tap_callback_funtion(ENUM_TAP_ON_NONHIGHLIGHTED_ITEM, m->highlighted_item);
                    }
                }
                else if (menuitem_event != GUI_LIST_PEN_NEED_REDRAW && menuitem_event != GUI_LIST_PEN_NONE)
                {
                    gui_ssp_execute_lsk(KEY_EVENT_UP);
                }
#endif
#ifdef __MMI_UI_TWO_LINE_MENUITEM_STYLES__
                if (menuitem_event == GUI_LIST_PEN_TWO_LINE_NEXT)
                {
                    ExecuteCurrKeyHandler(KEY_RIGHT_ARROW,KEY_EVENT_DOWN);
                }
                else if (menuitem_event == GUI_LIST_PEN_TWO_LINE_PREVIOUS)
                {
                    ExecuteCurrKeyHandler(KEY_LEFT_ARROW,KEY_EVENT_DOWN);
                }
#endif /* __MMI_UI_TWO_LINE_MENUITEM_STYLES__ */
            }
            gui_swla_log_stop("TAP");

            return MMI_TRUE;
        }
        if (m->pen_state.pen_on_scrollbar)
        {
            return MMI_FALSE;
        }
        else
        {
            if (g_dm_data.s32CatId == MMI_CATEGORY_CASCADING_MENU_ID && !(point.x == 0 && point.y == 0))
            {
                CloseCascadingMenu();
                return MMI_TRUE;
            }
            else
            {
                return MMI_FALSE;
            }
        }
    }

    if (g_gui_ssp_state == GUI_LIST_SMOOTH_SCROLLING_BY_PEN_STATE_HOLD)
    {
        kal_get_time(&pen_up_time);

        pen_down_to_up_delta_time = kal_ticks_to_milli_secs(pen_up_time - g_gui_ssp_pen_down_time);
        pen_down_to_up_y_delta = (S32)point.y - g_gui_ssp_pen_down_y;
        
        if ((pen_down_to_up_delta_time < (*g_gui_ssp_free_run_threshold_time)) &&
            (GUI_EFFECT_ABS(pen_down_to_up_y_delta) > (*g_gui_ssp_free_run_movement_y_thresold)))
        {
            S32 pos_delta, max_offset;
            
            pos_delta = GUI_EFFECT_ABS(pen_down_to_up_y_delta) * (*g_gui_menu_ssp_pos_delta);

            g_gui_ssp_free_run_momentum = pen_down_to_up_y_delta;
            if (g_gui_ssp_free_run_momentum < 0)
            {
                pos_delta = -pos_delta;
            }

            max_offset = (S32)((float)m->height * (*g_gui_ssp_menu_over_limit_coefficient));
            if ((pos_delta > 0 && g_gui_ssp_current_menu_y_offset <= -max_offset) ||
                (pos_delta < 0 && g_gui_ssp_current_menu_y_offset >= gui_ssp_get_menu_last_y_offset() + max_offset))
            {
                /* don't move if already at the bound */
            }
            /* only move when the move range is greater than a single item */
            else if (GUI_EFFECT_ABS(g_gui_ssp_free_run_momentum) > item_height)
            {
                /* free run mode */
                g_gui_ssp_state = GUI_LIST_SMOOTH_SCROLLING_BY_PEN_STATE_FREE_RUN;            
                g_gui_ssp_free_run_mode = GUI_SSP_FREE_RUN_MODE_RUN;
                g_gui_ssp_free_run_momentum = (S32)((float)-pos_delta * (*g_gui_ssp_free_run_sensitivity));
                g_gui_ssp_free_run_final_pos = g_gui_ssp_current_menu_y_offset - pos_delta;
#ifndef __MMI_UI_LIST_SCROLL_BY_PIXEL__
                /* align the final position to multiples of menu item */
                g_gui_ssp_free_run_final_pos -= g_gui_ssp_free_run_final_pos % item_height;
#endif
                g_gui_list_ssp_stop_item_index = gui_list_get_ssp_stop_item(g_gui_ssp_free_run_momentum);

                /* stop menu item scrolling */
                gui_ssp_stop_list_menu_scrolling();
                gui_start_timer((*g_gui_ssp_frame_update_interval), gui_ssp_update_frame);

                return MMI_TRUE;
            }            
        }

        /* go recover mode if the menu is scrolled out of normal */
        if (gui_ssp_try_free_run_recover(g_gui_ssp_current_menu_y_offset))
        {
            return MMI_TRUE;
        }        
    }
     
    gui_cancel_timer(gui_ssp_update_frame);
    if (m->first_displayed_item != g_gui_ssp_old_first_menu_item_index)
    {
        first_item_changed = MMI_TRUE;
        m->first_displayed_item = g_gui_ssp_old_first_menu_item_index;
    }
    else
    {
        first_item_changed = MMI_FALSE;
    }
    
        
    /* 
     * GUI_LIST_SMOOTH_SCROLLING_BY_PEN_STATE_FREE_RUN -> GUI_LIST_SMOOTH_SCROLLING_BY_PEN_STATE_UNFOCUS
     * This is not a valid state transition but to reuse the pen up code.
     * Do not redraw list in screen exit
     */    
    gui_ssp_state_redraw = g_gui_ssp_state;
    is_slow_data = wgui_list_menu_slow_data_mode;
    list_error = gui_asyncdynamic_list_error;
    
    MMI_fixed_list_menu.flags |= UI_LIST_MENU_ENABLE_GOTO_HALF_ITEM;
    if (((g_gui_ssp_state == GUI_LIST_SMOOTH_SCROLLING_BY_PEN_STATE_FREE_RUN) ||
        (g_gui_ssp_state == GUI_LIST_SMOOTH_SCROLLING_BY_PEN_STATE_HOLD)) && 
        GetExitScrnID() == GetActiveScreenId())
    {
        g_gui_ssp_state = GUI_LIST_SMOOTH_SCROLLING_BY_PEN_STATE_UNFOCUS;
#ifdef __MMI_FTE_SUPPORT__ 
        if (g_gui_list_menu_smooth_scrolling_menu_type == GUI_MENU_TYPE_INLINE && 
            g_gui_ssp_old_menu_highlight_item_index == MMI_fixed_list_menu.highlighted_item)
        {
            wgui_inline_set_ssp_redraw_state(MMI_TRUE);
        }
#endif
        gui_ssp_sync_list_menu_display();
    }
        
    gui_ssp_old_state = g_gui_ssp_state;
    list_error = gui_asyncdynamic_list_error;
    g_gui_ssp_state = GUI_LIST_SMOOTH_SCROLLING_BY_PEN_STATE_UNFOCUS;
    if (first_item_changed == MMI_TRUE)
    {   
        if (g_gui_list_menu_smooth_scrolling_menu_type == GUI_MENU_TYPE_FIXED
#ifdef __MMI_FTE_SUPPORT__ 
            || g_gui_list_menu_smooth_scrolling_menu_type == GUI_MENU_TYPE_INLINE
#endif            
            )
        {
            gui_fixed_list_menu_locate_highlighted_item(m);
        }
        if (g_gui_list_menu_smooth_scrolling_menu_type == GUI_MENU_TYPE_DYNAMIC && 
            !(MMI_fixed_list_menu.flags & UI_LIST_MENU_DISABLE_CACHE_DYNAMIC_DATA))
        {
            gui_dynamic_list_menu_locate_highlighted_item(m);
        }
        if (g_gui_list_menu_smooth_scrolling_menu_type == GUI_MENU_TYPE_ASYNCDYNAMIC)
        {
            // in exit procedure, does not locate list, for the app data may have been free
            if (!mmi_frm_is_in_ui_common_exit_procedure())
            {
                gui_asyncdynamic_list_menu_locate_highlighted_item(m);
            }
        }
    }
    MMI_fixed_list_menu.flags &= ~UI_LIST_MENU_ENABLE_GOTO_HALF_ITEM;
    if(g_gui_list_menu_smooth_scrolling_menu_type == GUI_MENU_TYPE_INVALID)
    {
        return MMI_TRUE;
    }
    
    trans_ret = gui_ssp_menu_translate_pen_position(m, (S32)point.x, (S32)point.y, &up_item_index);
    
#ifdef __MMI_FTE_SUPPORT__ 
    if (g_gui_list_menu_smooth_scrolling_menu_type == GUI_MENU_TYPE_INLINE)
    {
        gui_inline_pen_enum inline_event;
        if (gui_ssp_old_state == GUI_LIST_SMOOTH_SCROLLING_BY_PEN_STATE_FOCUS)
        {
            gui_inline_translate_pen_event(
                &MMI_fixed_list_menu,
                MMI_PEN_EVENT_UP,
                point.x,
                point.y,
                &inline_event); 
        }
        else
        {
            gui_inline_translate_pen_event(
                &MMI_fixed_list_menu,
                MMI_PEN_EVENT_ABORT,
                point.x,
                point.y,
                &inline_event); 
        }
    }
#endif

    if ((GetExitScrnID() == GetActiveScreenId()) &&
        !mmi_frm_is_in_ui_common_exit_procedure())
    {
        if (!(((gui_ssp_state_redraw == GUI_LIST_SMOOTH_SCROLLING_BY_PEN_STATE_FREE_RUN) ||
            (gui_ssp_state_redraw == GUI_LIST_SMOOTH_SCROLLING_BY_PEN_STATE_HOLD)) && is_slow_data &&
            list_error == 1))
        {
            if ((g_gui_list_menu_smooth_scrolling_menu_type != GUI_MENU_TYPE_INLINE ||
                gui_ssp_old_state != GUI_LIST_SMOOTH_SCROLLING_BY_PEN_STATE_FOCUS))
            {
                gui_list_menu_smooth_scrolling_redraw_list();
            }
                
        }
    }
    g_gui_ssp_state = gui_ssp_old_state;
    
    /* execute selected item */
    if ((g_gui_ssp_state == GUI_LIST_SMOOTH_SCROLLING_BY_PEN_STATE_FOCUS) &&
        gui_ssp_is_point_in_menu_rect((S32)point.x, (S32)point.y) &&
        (trans_ret == MMI_TRUE) &&
        (up_item_index == m->highlighted_item) &&
        !(MMI_fixed_list_menu.disable_up_select) &&
        (!g_gui_ssp_have_goto_disabled_item))
    {     
        if (g_gui_list_menu_smooth_scrolling_menu_type == GUI_MENU_TYPE_DYNAMIC)
        {
            if (MMI_fixed_list_menu.n_items != 0 && !in_dynamic_item_buffer(MMI_fixed_list_menu.highlighted_item))
                return MMI_TRUE;
        }
        else if (g_gui_list_menu_smooth_scrolling_menu_type == GUI_MENU_TYPE_ASYNCDYNAMIC)
        {
            if (MMI_fixed_list_menu.n_items != 0 && !in_asyncdynamic_item_buffer(MMI_fixed_list_menu.highlighted_item))
                return MMI_TRUE;
        }
        
        gui_menuitem_handle_ssp_pen_up();
    }

    g_gui_ssp_state = GUI_LIST_SMOOTH_SCROLLING_BY_PEN_STATE_UNFOCUS;

    return MMI_TRUE;       
}


/*****************************************************************************
 * FUNCTION
 *  gui_ssp_get_menu_last_y_offset
 * DESCRIPTION
 *  Gets the last menu y offset for for a normal displayed menu.
 * PARAMETERS
 *  void
 * RETURNS
 *  The last y offset.
 *****************************************************************************/
static S32 gui_ssp_get_menu_last_y_offset(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 item_height, max_items_per_page, menu_full_height, current_height;
    S32 i, iwidth, iheight;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    item_height = gui_list_menu_smooth_scrolling_get_menu_item_height();
    max_items_per_page = gui_list_menu_smooth_scrolling_get_items_per_page();
    if (MMI_fixed_list_menu.n_items <= max_items_per_page)
    {   /* single page menu*/
        return 0;
    }
    else
    {
        if (g_gui_list_menu_smooth_scrolling_menu_type == GUI_MENU_TYPE_INLINE
#if defined(__MMI_UI_LIST_SUPPORT_UNEQUAL_HEIGHT_ITEM__)
            || MMI_fixed_list_menu.flags & UI_LIST_MENU_INEQUAL_HEIGHT_ITEMS
#endif
        )
        {
            menu_full_height = 0;
            current_height = 0;
            for (i = 0; i < MMI_fixed_list_menu.n_items; i++)
            {
                if (i == MMI_fixed_list_menu.highlighted_item)
                {
                    MMI_fixed_list_menu.current_displayed_item = -1;
                }
                else
                {
                    MMI_fixed_list_menu.current_displayed_item = i;
                }
            
                MMI_fixed_list_menu.item_measure_function(
                    MMI_fixed_list_menu.items[i], 
                    MMI_fixed_list_menu.common_item_data,
                    &iwidth, 
                    &iheight);
                menu_full_height += iheight;
                if (i >= MMI_fixed_list_menu.first_displayed_item && i <= MMI_fixed_list_menu.last_displayed_item)
                {
                    current_height += iheight;
                }
            }
#ifdef __MMI_UI_LIST_SCROLL_BY_PIXEL__
            return menu_full_height - (MMI_fixed_list_menu.height - MMI_fixed_list_menu.top);
#else
            return (menu_full_height - current_height);
#endif
        }
        else
        {
            /* multi page menu */
#ifdef __MMI_UI_LIST_SCROLL_BY_PIXEL__
            if (gui_list_menu_is_highlight_item_two_line())
            {
                return ((MMI_fixed_list_menu.n_items + 1) * item_height - (MMI_fixed_list_menu.height - MMI_fixed_list_menu.top));
            }
            return (MMI_fixed_list_menu.n_items * item_height - (MMI_fixed_list_menu.height - MMI_fixed_list_menu.top));
#else
            return (MMI_fixed_list_menu.n_items * item_height - max_items_per_page * item_height);
#endif
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  gui_ssp_enter_free_run_recover_mode
 * DESCRIPTION
 *  Enters the SSP recover mode.
 * PARAMETERS
 *  final_y_offset       [IN]   the final menu y offset
 *  momentum             [IN]   move range to recover
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_ssp_enter_free_run_recover_mode(S32 final_y_offset, S32 momentum)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_gui_ssp_state = GUI_LIST_SMOOTH_SCROLLING_BY_PEN_STATE_FREE_RUN;
    g_gui_ssp_free_run_mode = GUI_SSP_FREE_RUN_MODE_RECOVER;            
    g_gui_ssp_free_run_momentum = momentum;
    g_gui_ssp_free_run_final_pos = final_y_offset;
}


/*****************************************************************************
 * FUNCTION
 *  gui_ssp_try_free_run_recover
 * DESCRIPTION
 *  Tries to enter the recover mode as possible.
 * PARAMETERS
 *  menu_y_offset       [IN]    current menu y offset
 * RETURNS
 *  MMI_TRUE if recovering is executed; otherwise, MMI_FALSE.
 *****************************************************************************/
static MMI_BOOL gui_ssp_try_free_run_recover(S32 menu_y_offset)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 menu_last_y_offset;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    menu_last_y_offset = gui_ssp_get_menu_last_y_offset();

    if ((!menu_last_y_offset && menu_y_offset) || (menu_y_offset < 0))
    {   
        /* 
         * single page: always go back to origin
         * multi page: go back to origin
         */
        gui_ssp_enter_free_run_recover_mode(0, menu_y_offset);
        gui_start_timer((*g_gui_ssp_frame_update_interval), gui_ssp_update_frame);

        return MMI_TRUE;
    }
    else if (menu_last_y_offset && (menu_y_offset > menu_last_y_offset))
    {
        /*
         * multi page: go back to the last y
         */
        gui_ssp_enter_free_run_recover_mode(menu_last_y_offset, menu_y_offset - menu_last_y_offset);
        gui_start_timer((*g_gui_ssp_frame_update_interval), gui_ssp_update_frame);   

        return MMI_TRUE;
    }

    return MMI_FALSE;
}
    

/*****************************************************************************
 * FUNCTION
 *  gui_ssp_update_frame
 * DESCRIPTION
 *  Updates a SSP frame.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gui_ssp_update_frame(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 menu_offset_y,default_fist_item = -1;
    S32 item_height = 0;
    S32 menu_full_height, current_height;
    fixed_list_menu *m = &MMI_fixed_list_menu;
    S32 max_offset, low_bound, high_bound;
    S32 old_momentum;
    S32 menu_last_y_offset;
    S32 i, iwidth, iheight, mi_width = 0, mi_height = 0;
    void *item;
    MMI_BOOL menu_highlight_twoline = MMI_FALSE;
	S32 old_current_index;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_swla_log_start("UFM");
    gui_asyncdynamic_list_error = 0;

#if defined(__MMI_UI_LIST_SUPPORT_UNEQUAL_HEIGHT_ITEM__)
    if (m->flags & UI_LIST_MENU_INEQUAL_HEIGHT_ITEMS)
    {
        menu_offset_y = g_gui_ssp_pen_down_y - g_gui_ssp_pen_move_y + g_gui_ssp_start_menu_offset;        
        if (g_gui_ssp_state == GUI_LIST_SMOOTH_SCROLLING_BY_PEN_STATE_FREE_RUN)
        {
            if (g_gui_ssp_free_run_mode == GUI_SSP_FREE_RUN_MODE_RUN)
            {
                menu_offset_y = g_gui_ssp_current_menu_y_offset + g_gui_ssp_free_run_momentum;
            }
            else
            {
                menu_offset_y = g_gui_ssp_free_run_final_pos + (S32)((float)g_gui_ssp_free_run_momentum * (*g_gui_ssp_free_run_recover_coefficient));
            }
        }

        if (menu_offset_y < g_gui_ssp_current_menu_y_offset)
        {
            S32 offset;
            offset = g_gui_ssp_current_menu_y_offset - menu_offset_y - g_gui_ssp_old_first_menu_item_offset;
            i = g_gui_ssp_old_first_menu_item_index - 1;
            while (offset > 0 && i >= 0)
            {
                if (i == MMI_fixed_list_menu.highlighted_item)
                {
                    MMI_fixed_list_menu.current_displayed_item = -1;
                }
                else
                {
                    MMI_fixed_list_menu.current_displayed_item = i;
                }

                item = gui_list_menu_smooth_scrolling_get_item(i);
                MMI_fixed_list_menu.item_measure_function(
                    item, 
                    MMI_fixed_list_menu.common_item_data,
                    &iwidth, 
                    &iheight);
                offset -= iheight;
                i--;
            }
        }
    }
#endif
    if (g_gui_list_menu_smooth_scrolling_menu_type == GUI_MENU_TYPE_INLINE
#if defined(__MMI_UI_LIST_SUPPORT_UNEQUAL_HEIGHT_ITEM__)
        || m->flags & UI_LIST_MENU_INEQUAL_HEIGHT_ITEMS
#endif
    )
    {
        menu_full_height = 0;
        for (i = 0; i < MMI_fixed_list_menu.n_items; i++)
        {
            if (i == MMI_fixed_list_menu.highlighted_item)
            {
                MMI_fixed_list_menu.current_displayed_item = -1;
            }
            else
            {
                MMI_fixed_list_menu.current_displayed_item = i;
            }
            
            MMI_fixed_list_menu.item_measure_function(
                MMI_fixed_list_menu.items[i], 
                MMI_fixed_list_menu.common_item_data,
                &iwidth, 
                &iheight);
            menu_full_height += iheight;
#if defined(__MMI_UI_LIST_SUPPORT_UNEQUAL_HEIGHT_ITEM__)
            if (m->flags & UI_LIST_MENU_INEQUAL_HEIGHT_ITEMS && i == g_gui_ssp_old_first_menu_item_index - 1 && menu_full_height != g_gui_ssp_old_full_height)
            {
                g_gui_ssp_start_menu_offset += menu_full_height - g_gui_ssp_old_full_height;
                g_gui_ssp_current_menu_y_offset += menu_full_height - g_gui_ssp_old_full_height;
            }
#endif
        }
    }
    else
    {
        item_height = gui_list_menu_smooth_scrolling_get_menu_item_height();

        if (gui_slide_highlight_removed == MMI_FALSE)
        {
            item = gui_list_menu_smooth_scrolling_get_item(MMI_fixed_list_menu.highlighted_item);
            
            if (item)
            {
    			old_current_index = MMI_fixed_list_menu.current_displayed_item;
    			MMI_fixed_list_menu.current_displayed_item = -1;
                MMI_fixed_list_menu.item_measure_function(
                    item,
                    MMI_fixed_list_menu.common_item_data,           
                    &mi_width,
                    &mi_height);
    			MMI_fixed_list_menu.current_displayed_item = old_current_index;
            }
        }
        if (mi_height == item_height * 2)
        {
            menu_full_height = m->n_items * item_height + item_height;
            menu_highlight_twoline = MMI_TRUE;
        }
        else
        {
            menu_full_height = m->n_items * item_height;
        }
    }
    
    max_offset = (S32)((float)m->height * (*g_gui_ssp_menu_over_limit_coefficient));
    low_bound = -max_offset;
    high_bound = menu_full_height - m->height + max_offset;

    menu_offset_y = g_gui_ssp_pen_down_y - g_gui_ssp_pen_move_y + g_gui_ssp_start_menu_offset;        

    switch (g_gui_ssp_state)
    {
        case GUI_LIST_SMOOTH_SCROLLING_BY_PEN_STATE_HOLD:
            /* drag menu */
            if (menu_offset_y < low_bound)
            {
                menu_offset_y = low_bound;
                default_fist_item = 0;
            }
            else if ((high_bound > 0) && (menu_offset_y > high_bound))
            {
                if ((*g_gui_ssp_menu_over_limit_coefficient) != 0)
                {
                menu_offset_y = high_bound;
                }
                else
                {
                    if (g_gui_list_menu_smooth_scrolling_menu_type == GUI_MENU_TYPE_INLINE)
                    {
                        current_height = 0;
                        for (i = MMI_fixed_list_menu.n_items - 1; i >= 0; i--)
                        {
                            if (i == MMI_fixed_list_menu.highlighted_item)
                            {
                                MMI_fixed_list_menu.current_displayed_item = -1;
                            }
                            else
                            {
                                MMI_fixed_list_menu.current_displayed_item = i;
                            }
                            
                            MMI_fixed_list_menu.item_measure_function(
                                MMI_fixed_list_menu.items[i], 
                                MMI_fixed_list_menu.common_item_data,
                                &iwidth, 
                                &iheight);
                            current_height += iheight;
                            if (current_height > MMI_fixed_list_menu.height)
                            {
                                break;
                            }
                        }
#ifdef __MMI_UI_LIST_SCROLL_BY_PIXEL__
                        menu_offset_y = menu_full_height - MMI_fixed_list_menu.height;
                        if (current_height - iheight == MMI_fixed_list_menu.height)
                        {
                            default_fist_item = i + 1;
                        }
                        else
                        {
                            default_fist_item = i;
                        }
#else /* __MMI_UI_LIST_SCROLL_BY_PIXEL__ */
                        menu_offset_y = menu_full_height - current_height + iheight;
                        default_fist_item = i + 1;
#endif /* __MMI_UI_LIST_SCROLL_BY_PIXEL__ */
                    }
                    else
                    {
#ifdef __MMI_UI_LIST_SCROLL_BY_PIXEL__
                        current_height = 0;
                        for (i = MMI_fixed_list_menu.n_items - 1; i >= 0; i--)
                        {
                            gui_list_menu_measure_item(m, i, &iwidth, &iheight);
                            current_height += iheight;
                            if (current_height > MMI_fixed_list_menu.height)
                            {
                                break;
                            }
                        }
                        menu_offset_y = menu_full_height - MMI_fixed_list_menu.height;
//                        default_fist_item = m->n_items - gui_list_menu_smooth_scrolling_get_items_per_page();
                        if (current_height - iheight == MMI_fixed_list_menu.height)
                        {
                            default_fist_item = i + 1;
                        }
                        else
                        {
                            default_fist_item = i;
                        }
#else /* __MMI_UI_LIST_SCROLL_BY_PIXEL__ */
                        menu_offset_y = menu_full_height - item_height * m->displayed_items;
                        default_fist_item = m->n_items - m->displayed_items;
                        if (menu_highlight_twoline )
                        {
                            menu_offset_y -= item_height;
                        }
#endif /* __MMI_UI_LIST_SCROLL_BY_PIXEL__ */
                    }
                }
            }
            else if (high_bound <= 0)
            {
                menu_offset_y = 0;
            }
            break;

        case GUI_LIST_SMOOTH_SCROLLING_BY_PEN_STATE_FREE_RUN:
            /* free run */
            old_momentum = g_gui_ssp_free_run_momentum;
            if (g_gui_ssp_free_run_mode == GUI_SSP_FREE_RUN_MODE_RUN)
            {   /* run mode */
                menu_offset_y = g_gui_ssp_current_menu_y_offset + g_gui_ssp_free_run_momentum;

                g_gui_ssp_free_run_momentum = (S32)((float)g_gui_ssp_free_run_momentum * (*g_gui_ssp_free_run_scroll_coefficient));
                /* make sure converge to zero */
                if (old_momentum == g_gui_ssp_free_run_momentum)
                {
                    g_gui_ssp_free_run_momentum = 0;
                }
            }
            else
            {   /* recover mode */
                g_gui_ssp_free_run_momentum = (S32)((float)g_gui_ssp_free_run_momentum * (*g_gui_ssp_free_run_recover_coefficient));
                
                /* make sure converge to zero */
                if (old_momentum == g_gui_ssp_free_run_momentum)
                {
                    g_gui_ssp_free_run_momentum = 0;
                }

                menu_offset_y = g_gui_ssp_free_run_final_pos + g_gui_ssp_free_run_momentum;
            }

            menu_last_y_offset = gui_ssp_get_menu_last_y_offset();

            /* menu bound check */
            if ((*g_gui_ssp_menu_over_limit_coefficient) != 0)
            {
                if (menu_offset_y < low_bound)
                {
                    gui_ssp_enter_free_run_recover_mode(0, menu_offset_y);
                }
                else if ((high_bound > 0) && (menu_offset_y > high_bound))
                {
                    gui_ssp_enter_free_run_recover_mode(menu_last_y_offset, menu_offset_y - menu_last_y_offset);
                }
            }
            else
            {   
                if (menu_full_height <= m->height)
                    g_gui_ssp_free_run_momentum = 0;
                if (menu_offset_y < low_bound)
                {
                    menu_offset_y = low_bound;
                    default_fist_item = 0;
                    if (g_gui_ssp_free_run_momentum)
                    {
                        g_gui_ssp_free_run_momentum = -1;
                    }
                }
                else if ((high_bound > 0) && (menu_offset_y > high_bound))
                {
                    menu_offset_y = high_bound;
                    
                    if (g_gui_list_menu_smooth_scrolling_menu_type == GUI_MENU_TYPE_INLINE)
                    {
                        current_height = 0;
                        for (i = MMI_fixed_list_menu.n_items - 1; i >= 0; i--)
                        {
                            if (i == MMI_fixed_list_menu.highlighted_item)
                            {
                                MMI_fixed_list_menu.current_displayed_item = -1;
                            }
                            else
                            {
                                MMI_fixed_list_menu.current_displayed_item = i;
                            }
                            
                            MMI_fixed_list_menu.item_measure_function(
                                MMI_fixed_list_menu.items[i], 
                                MMI_fixed_list_menu.common_item_data,
                                &iwidth, 
                                &iheight);
                            current_height += iheight;
                            if (current_height > MMI_fixed_list_menu.height)
                            {
                                break;
                            }
                        }
#ifdef __MMI_UI_LIST_SCROLL_BY_PIXEL__
                        menu_offset_y = menu_full_height - MMI_fixed_list_menu.height;
                        if (current_height - iheight == MMI_fixed_list_menu.height)
                        {
                            default_fist_item = i + 1;
                        }
                        else
                        {
                            default_fist_item = i;
                        }
#else /* __MMI_UI_LIST_SCROLL_BY_PIXEL__ */
                        menu_offset_y = menu_full_height - current_height + iheight;
                        default_fist_item = i + 1;
#endif /* __MMI_UI_LIST_SCROLL_BY_PIXEL__ */
                    }
                    else
                    {
#ifdef __MMI_UI_LIST_SCROLL_BY_PIXEL__
                        current_height = 0;
                        for (i = MMI_fixed_list_menu.n_items - 1; i >= 0; i--)
                        {
                            gui_list_menu_measure_item(m, i, &iwidth, &iheight);
                            current_height += iheight;
                            if (current_height > MMI_fixed_list_menu.height)
                            {
                                break;
                            }
                        }
                        menu_offset_y = menu_full_height - MMI_fixed_list_menu.height;
//                        default_fist_item = m->n_items - gui_list_menu_smooth_scrolling_get_items_per_page();
                        if (current_height - iheight == MMI_fixed_list_menu.height)
                        {
                            default_fist_item = i + 1;
                        }
                        else
                        {
                            default_fist_item = i;
                        }
#else /* __MMI_UI_LIST_SCROLL_BY_PIXEL__ */
                        menu_offset_y = menu_full_height - item_height * m->displayed_items;
                        default_fist_item = m->n_items - m->displayed_items;
                        
                        if (menu_highlight_twoline)
                        {
                            menu_offset_y -= item_height;
                        }
#endif /* __MMI_UI_LIST_SCROLL_BY_PIXEL__ */
                    }
                    if (g_gui_ssp_free_run_momentum)
                    {
                        g_gui_ssp_free_run_momentum = 1;
                    }
                }
                else if (high_bound <= 0)
                {
                    menu_offset_y = 0;
                }
            }

            /* running or running -> recover */
//            if (g_gui_ssp_free_run_momentum)
            if (old_momentum)
            {
                gui_start_timer((*g_gui_ssp_frame_update_interval), gui_ssp_update_frame);
            }
            else
            {   /* g_gui_ssp_free_run_momentum == 0 */
                /* try to recover if the menu is not in the normal position */
                if ((*g_gui_ssp_menu_over_limit_coefficient) != 0 && gui_ssp_try_free_run_recover(menu_offset_y))
                {
                    gui_swla_log_stop("UFM");
                    return;
                }
                if (menu_highlight_twoline && 
                        MMI_fixed_list_menu.last_displayed_item != MMI_fixed_list_menu.n_items - 1)
                    m->first_displayed_item++;
                gui_ssp_pen_up_dummy();
                gui_swla_log_stop("UFM");
                return;
            }
            break;

        default:
            break;
    }
            
    gui_swla_log_start("SSP");
    gui_ssp_show_list_menu(menu_offset_y, m->x, m->y, m->x + m->width - 1, m->y + m->height - 1);
    gui_swla_log_stop("SSP");
    if (default_fist_item != -1)
    {
        if (default_fist_item > MMI_fixed_list_menu.n_items - 1)
        {
            g_gui_ssp_old_first_menu_item_index = MMI_fixed_list_menu.n_items - 1;
        }
        else
        {
            g_gui_ssp_old_first_menu_item_index = default_fist_item;
        }
    }
#ifdef WIN32
    kal_sleep_task(1);
#endif
    gui_swla_log_stop("UFM");
}


/*****************************************************************************
 * FUNCTION
 *  gui_ssp_pen_move_hdlr
 * DESCRIPTION
 *  Pen move handler of Smooth Scrolling by Pen.
 * PARAMETERS
 *  point       [IN]    pen point
 * RETURNS
 *  MMI_TRUE if this pen event is handled; otherwise, MMI_FALSE.
 *****************************************************************************/
static MMI_BOOL gui_ssp_pen_move_hdlr(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    fixed_list_menu *m = &MMI_fixed_list_menu;
    void *item;
    gui_list_pen_enum menuitem_event;
    gui_pen_event_param_struct menuitem_param;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (MMI_fixed_list_menu.n_items == 0)
        return MMI_FALSE;
    
    /* do not handle move events when unfocused */
    if (g_gui_ssp_state == GUI_LIST_SMOOTH_SCROLLING_BY_PEN_STATE_UNFOCUS)
    {
        if (gui_ssp_is_point_in_menu_rect((S32)point.x, (S32)point.y))
        {
            if (g_gui_ssp_is_click_item_own_area)
            {
                gui_ssp_send_pen_event_to_item(
                    MMI_PEN_EVENT_MOVE,
                    &point,
                    m->highlighted_item,
                    m->highlight_x,
                    m->highlight_y,
                    &menuitem_event,
                    &menuitem_param);
                return MMI_FALSE;
            }
            else
                return MMI_TRUE;
        }
        else if (g_gui_ssp_is_pen_down_in_list)
            return MMI_TRUE;
        else
            return MMI_FALSE;
    }

    /* update pen move y */
    g_gui_ssp_pen_move_y = (S32)point.y;
    
    switch (g_gui_ssp_state)
    {
        case GUI_LIST_SMOOTH_SCROLLING_BY_PEN_STATE_FOCUS:
            /* 
             * go to hold state when 
             * 1. the pen moves to the neighbor item, and
             * 2. the offset from pen down y exceed the (*g_gui_ssp_focus_to_hold_state_y_threshold) 
             */
            if ((GUI_EFFECT_ABS(g_gui_ssp_pen_move_y - g_gui_ssp_pen_down_y) > (*g_gui_ssp_focus_to_hold_state_y_threshold) ))
            {
                /* stop scrolling and reset scrolling position */
                item = gui_list_menu_smooth_scrolling_get_item(m->highlighted_item);
                if (item)
                {
                    m->item_remove_highlight_function(item, m->common_item_data);
                    m->item_highlight_function(item, m->common_item_data);
                }
                gui_ssp_stop_list_menu_scrolling();

                g_gui_ssp_state = GUI_LIST_SMOOTH_SCROLLING_BY_PEN_STATE_HOLD;
                /* trigger GUI_LIST_SMOOTH_SCROLLING_BY_PEN_STATE_HOLD state */
                return gui_ssp_pen_move_hdlr(point);
            }
            break;

        case GUI_LIST_SMOOTH_SCROLLING_BY_PEN_STATE_HOLD:
            gui_ssp_stop_list_menu_scrolling();        
            gui_start_timer((*g_gui_ssp_frame_update_interval), gui_ssp_update_frame);
            break;

        default:       
            break;
    }
   
    return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  gui_ssp_pen_abort_hdlr
 * DESCRIPTION
 *  Pen abort handler of Smooth Scrolling by Pen.
 * PARAMETERS
 *  point       [IN]    pen point
 * RETURNS
 *  MMI_TRUE if this pen event is handled; otherwise, MMI_FALSE.
 *****************************************************************************/
static MMI_BOOL gui_ssp_pen_abort_hdlr(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (MMI_fixed_list_menu.n_items == 0)
        return MMI_FALSE;
    g_gui_ssp_state = GUI_LIST_SMOOTH_SCROLLING_BY_PEN_STATE_UNFOCUS;
    gui_cancel_timer(gui_ssp_update_frame);
    
    return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  gui_ssp_pen_pre_hdlr
 * DESCRIPTION
 *  Pre-pen handler of Smooth Scrolling by Pen.
 * PARAMETERS
 *  dm_control_id       [IN]    DM control ID
 *  point               [IN]    pen point
 *  pen_event           [IN]    pen event
 * RETURNS
 *  MMI_TRUE if this pen event is handled; otherwise, MMI_FALSE.
 *****************************************************************************/
static MMI_BOOL gui_ssp_pen_pre_hdlr(U16 dm_control_id, mmi_pen_point_struct point, mmi_pen_event_type_enum pen_event)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#if defined(__MTK_TARGET__) && !defined(__TOUCH_PANEL_CAPACITY__)
    U32 i;
    mmi_pen_point_struct v1, v0, a, predict_pos;
    static mmi_pen_point_struct s_ssp_pos[3];
    static U32 s_ssp_timestamp[3];
#endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (dm_control_id)
    {
        case DM_CATEGORY_CONTROLLED_AREA:
            if(g_dm_data.s32CatId != MMI_CATEGORY200_ID && 
                g_dm_data.s32CatId != MMI_CATEGORY202_ID &&
                g_dm_data.s32CatId != MMI_CATEGORY199_ID &&
                g_dm_data.s32CatId != MMI_CATEGORY199_SCROLLTEXT_ID &&
                g_dm_data.s32CatId != MMI_CATEGORY202_NOINFO_ID 
#ifdef __MMI_CAT103_SUPPORT__
                && g_dm_data.s32CatId != MMI_CATEGORY103_ID
#endif
#ifdef __MMI_CAT203_SUPPORT__
                && g_dm_data.s32CatId != MMI_CATEGORY203_ID
#endif
                )
                return MMI_FALSE;
        case DM_LIST1:
        case DM_DYNAMIC_LIST1:
        case DM_ASYNCDYNAMIC_LIST1:
#ifdef __MMI_FTE_SUPPORT__ 
        case DM_INLINE_FIXED_LIST1:
#endif
            /* 
             * handle list menu events
             */
            switch (pen_event)
            {
                case MMI_PEN_EVENT_DOWN:
#if defined(__MTK_TARGET__) && !defined(__TOUCH_PANEL_CAPACITY__)
                    for (i = 0; i < 3; i++)
                    {
                        s_ssp_pos[i] = point;
                        kal_get_time(&s_ssp_timestamp[i]);
                    }
#endif
                    return gui_ssp_pen_down_hdlr(point);

                case MMI_PEN_EVENT_UP:
#if defined(__MTK_TARGET__) && !defined(__TOUCH_PANEL_CAPACITY__)
                    predict_pos = point;
                    v1.x = s_ssp_pos[1].x - s_ssp_pos[2].x;
                    v1.y = s_ssp_pos[1].y - s_ssp_pos[2].y;
                    v0.x = s_ssp_pos[0].x - s_ssp_pos[1].x;
                    v0.y = s_ssp_pos[0].y - s_ssp_pos[1].y;
                    a.x = v0.x - v1.x;
                    a.y = v0.y - v1.y;

                    if ((v0.x * a.x + v0.y * a.y) <= 0 && 
                        (a.x * a.x + a.y * a.y) >= (v0.x * v0.x + v0.y * v0.y))
                    {
                        // Do nothing
                    }
                    else
                    {
                        predict_pos.x += v0.x + a.x;
                        predict_pos.y += v0.y + a.y;
                    }
                    if (predict_pos.y < 0)
                    {
                        predict_pos.y = 0;
                    }
                    else if (predict_pos.y > MAIN_LCD_device_height)
                    {
                        predict_pos.y = MAIN_LCD_device_height - 1;
                    }
                    kal_prompt_trace(MOD_MMI_FW, "Pos: %d %d, Point: %d %d", point.x, point.y, predict_pos.x, predict_pos.y);
                    return gui_ssp_pen_up_hdlr(predict_pos);
#else
                    return gui_ssp_pen_up_hdlr(point);
#endif

                case MMI_PEN_EVENT_MOVE:
#if defined(__MTK_TARGET__) && !defined(__TOUCH_PANEL_CAPACITY__)
                    for (i = 2; i >= 1; i--)
                    {
                        s_ssp_pos[i] = s_ssp_pos[i - 1];
                        s_ssp_timestamp[i] = s_ssp_timestamp[i - 1];
                    }
                    
                    s_ssp_pos[0] = point;
                    kal_get_time(&s_ssp_timestamp[0]);
#endif
                    return gui_ssp_pen_move_hdlr(point);

                case MMI_PEN_EVENT_ABORT:
                    return gui_ssp_pen_abort_hdlr(point);
                case MMI_PEN_EVENT_REPEAT:
                    return MMI_FALSE;

                default:
                    /* ignored events */
                    break;
            }

            return MMI_TRUE;

        default:
            return MMI_FALSE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  gui_ssp_pen_up_dummy
 * DESCRIPTION
 *  Executes the pen up handler without pen up point information.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gui_ssp_pen_up_dummy(void) 
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_pen_point_struct dummy_point = {0};

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_gui_ssp_is_click_item_own_area = MMI_FALSE;
    g_gui_ssp_need_handle_item = MMI_FALSE;
#if defined(__MMI_UI_LIST_SCROLL_BY_PIXEL__)
    g_gui_ssp_clicked_half_item = -1;
#endif

    gui_ssp_pen_up_hdlr(dummy_point);
    gui_cancel_timer(gui_ssp_update_frame);
}        


/*****************************************************************************
 * FUNCTION
 *  gui_ssp_menu_translate_pen_position
 * DESCRIPTION
 *  Translate pen position to menu item index for SSP
 * PARAMETERS
 *  m               [IN]        list menu object
 *  y               [IN]        y
 *  item_index      [OUT]       penned item index
 * RETURNS
 *  Return MMI_TRUE if y is within the menu; otherwise, MMI_FALSE.
 *****************************************************************************/
static MMI_BOOL gui_ssp_menu_translate_pen_position(fixed_list_menu *m, S32 x, S32 y, S32 *item_index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (g_gui_list_menu_smooth_scrolling_menu_type)
    {
        case GUI_MENU_TYPE_FIXED:
#ifdef __MMI_FTE_SUPPORT__ 
        case GUI_MENU_TYPE_INLINE:
#endif
            return gui_fixed_list_menu_translate_pen_position(m, y, item_index);
            
        case GUI_MENU_TYPE_DYNAMIC:
            return gui_dynamic_list_menu_translate_pen_position(m, y, item_index);
            
        case GUI_MENU_TYPE_ASYNCDYNAMIC:
            return gui_asyncdynamic_list_menu_translate_pen_position(m, x, y, item_index);
            
        default:
            break;
    }

    return MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  gui_ssp_reset_state
 * DESCRIPTION
 *  Reset g_gui_ssp_state.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gui_ssp_reset_state(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_gui_ssp_state = GUI_LIST_SMOOTH_SCROLLING_BY_PEN_STATE_UNFOCUS;
}        


/*****************************************************************************
 * FUNCTION
 *  gui_ssp_pos_in_menu
 * DESCRIPTION
 * PARAMETERS
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL gui_ssp_pos_in_menu(S32 x, S32 y)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (x >= MMI_fixed_list_menu.x &&
        x <= MMI_fixed_list_menu.x + MMI_fixed_list_menu.width - 1 &&
        y >= MMI_fixed_list_menu.y &&
        y <= MMI_fixed_list_menu.y + MMI_fixed_list_menu.height - 1)
    {
        return MMI_TRUE;
    }
    else
    {
        return MMI_FALSE;
    }
    
}        


#if defined(__MMI_UI_LIST_SCROLL_BY_PIXEL__)
/*****************************************************************************
 * FUNCTION
 *  gui_ssp_set_static_layer
 * DESCRIPTION
 *  
 * PARAMETERS
 *  : 
 * RETURNS
 *  void 
 *****************************************************************************/
void gui_ssp_set_highlight_threshold(U16 highlight_first_threshold, U16 hilight_last_threshold)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_gui_ssp_highlight_first_threshold = highlight_first_threshold;
    g_gui_ssp_highlight_last_threshold = hilight_last_threshold;
}


static void gui_ssp_check_highlight_threshold(S32 *new_highlight_index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    fixed_list_menu *m = &MMI_fixed_list_menu;
    S32 item_width, item_height;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (m->first_displayed_item == m->last_displayed_item)
    {
        return;
    }
    if (*new_highlight_index == m->first_displayed_item)
    {
        gui_list_menu_measure_item(m, m->first_displayed_item, &item_width, &item_height);
        if ((g_gui_ssp_highlight_first_threshold == GUI_SSP_DEFAULT_HIGHLIGHT_THRESHOLD && m->first_displayed_offset > 0) ||
            (g_gui_ssp_highlight_first_threshold != GUI_SSP_DEFAULT_HIGHLIGHT_THRESHOLD && item_height - m->first_displayed_offset <= g_gui_ssp_highlight_first_threshold))
        {
            *new_highlight_index += 1;
        }
    }
#ifdef __MMI_FTE_SUPPORT__  
    else if (*new_highlight_index == m->last_displayed_item)
    {
        if ((m->flags & UI_LIST_MENU_INLINE_EDIT) &&
            ((wgui_inline_items[m->highlighted_item].flags & 0xFF) == INLINE_ITEM_TYPE_MULTI_LINE_RD_ONLY))
        {
            //doesn't do highlight validation
            //half display the highlighted RD only multi line
            //if highlight to multi line edit, should do the validation
        }
        else if ((g_gui_ssp_highlight_last_threshold == GUI_SSP_DEFAULT_HIGHLIGHT_THRESHOLD && m->last_displayed_offset > 0) ||
                 (g_gui_ssp_highlight_last_threshold != GUI_SSP_DEFAULT_HIGHLIGHT_THRESHOLD && m->last_displayed_offset > 0 && m->last_displayed_offset <= g_gui_ssp_highlight_last_threshold))
        {
            *new_highlight_index -= 1;
        }
    }
#else
    else if (*new_highlight_index == m->last_displayed_item)
    {
        if ((g_gui_ssp_highlight_last_threshold == GUI_SSP_DEFAULT_HIGHLIGHT_THRESHOLD && m->last_displayed_offset > 0) ||
            (m->last_displayed_offset > 0 && m->last_displayed_offset <= g_gui_ssp_highlight_last_threshold))
        {
            *new_highlight_index -= 1;
        }
    }
#endif
}


static void gui_ssp_sync_list_menu_by_pixel()
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    fixed_list_menu *m = &MMI_fixed_list_menu;
    void *item;
    S32 menu_height = 0;
    S32 i, item_width, item_height;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_FTE_SUPPORT__
    if (!(m->flags & UI_LIST_MENU_INLINE_EDIT) && !(m->flags & UI_LIST_MENU_INEQUAL_HEIGHT_ITEMS))
    {
        item_height = gui_list_menu_smooth_scrolling_get_menu_item_height();
        m->first_displayed_offset = g_gui_ssp_current_menu_y_offset % item_height;
        m->last_displayed_offset = (g_gui_ssp_current_menu_y_offset + m->height) % item_height;
        m->last_displayed_item = m->first_displayed_item + (m->height + m->first_displayed_offset - m->last_displayed_offset) / item_height - 1;
        if (m->last_displayed_offset > 0)
        {
            m->last_displayed_item++;
        }
        if (gui_list_menu_is_highlight_item_two_line())
        {
            m->last_displayed_item--;
        }
    }
    else
    {
        flush_asyncdynamic_item_buffer_before_load_chunk();
        m->first_displayed_item = g_gui_ssp_old_first_menu_item_index;
        m->first_displayed_offset = g_gui_ssp_old_first_menu_item_offset;
        m->last_displayed_item = m->n_items - 1;
        m->last_displayed_offset = 0;
        menu_height = -g_gui_ssp_old_first_menu_item_offset;
        for (i = m->first_displayed_item; i < m->n_items; i++)
        {
            gui_list_menu_smooth_scrolling_get_item(i);
            gui_list_menu_measure_item(m, i, &item_width, &item_height);
            menu_height += item_height;
            if (menu_height > m->height)
            {
                m->last_displayed_offset = m->height - (menu_height - item_height);
                if (m->last_displayed_offset > 0)
                {
                    m->last_displayed_item = i;
                }
                else
                {
                    m->last_displayed_item = i - 1;
                }
                break;
            }
        }
    }
#else /* __MMI_FTE_SUPPORT__ */
    m->first_displayed_offset = g_gui_ssp_old_first_menu_item_offset;
    m->last_displayed_item = m->n_items - 1;
    m->last_displayed_offset = 0;
    menu_height = -g_gui_ssp_old_first_menu_item_offset;
    for (i = m->first_displayed_item; i < m->n_items; i++)
    {
        gui_list_menu_smooth_scrolling_get_item(i);
        gui_list_menu_measure_item(m, i, &item_width, &item_height);
        menu_height += item_height;
        if (menu_height > m->height)
        {
            m->last_displayed_offset = m->height - (menu_height - item_height);
            if (m->last_displayed_offset > 0)
            {
                m->last_displayed_item = i;
            }
            else
            {
                m->last_displayed_item = i - 1;
            }
            break;
        }
    }
#endif
}


/*****************************************************************************
 * FUNCTION
 *  gui_ssp_pen_down_on_half_item
 * DESCRIPTION
 *  Handle pen down event on half menu item.
 * PARAMETERS
 *  point                    [IN]    pen point
 *  new_highlight_item_index [IN]    new highlight index
 * RETURNS
 *  MMI_TRUE if this pen event is handled; otherwise, MMI_FALSE.
 *****************************************************************************/
static MMI_BOOL gui_ssp_pen_down_on_half_item(mmi_pen_point_struct point, S32 new_highlight_item_index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    fixed_list_menu *m = &MMI_fixed_list_menu;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (gui_fixed_icontext_list_menuitem_is_pen_in_checkbox(NULL, m->common_item_data, m->highlight_x, m->highlight_y, point.x, point.y))
    {
        return MMI_FALSE;
    }
    else if (new_highlight_item_index == m->first_displayed_item)
    {
        if (m->first_displayed_offset > 0)
        {
            return MMI_TRUE;
        }
    }
    else if (new_highlight_item_index == m->last_displayed_item && m->last_displayed_offset > 0 &&
             !((m->flags & UI_LIST_MENU_INLINE_EDIT) && 
               ((wgui_inline_items[m->last_displayed_item].flags & 0xFF) == INLINE_ITEM_TYPE_MULTI_LINE_EDIT ||
                (wgui_inline_items[m->last_displayed_item].flags & 0xFF) == INLINE_ITEM_TYPE_MULTI_LINE_RD_ONLY)))
    {
        return MMI_TRUE;
    }

    return MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  gui_ssp_pen_up_on_half_item
 * DESCRIPTION
 *  Handle pen up event on half menu item.
 * PARAMETERS
 *  none
 * RETURNS
 *  MMI_TRUE if this pen event is handled; otherwise, MMI_FALSE.
 *****************************************************************************/
static MMI_BOOL gui_ssp_pen_up_on_half_item()
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    fixed_list_menu *m = &MMI_fixed_list_menu;
    S32 iwidth, iheight;
    S32 final_y_offset = 0, momentum = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_gui_ssp_state == GUI_LIST_SMOOTH_SCROLLING_BY_PEN_STATE_FOCUS && g_gui_ssp_clicked_half_item >= 0)
    {
        if (g_gui_ssp_clicked_half_item == m->first_displayed_item)
        {
            final_y_offset = g_gui_ssp_start_menu_offset - m->first_displayed_offset;
            momentum = m->first_displayed_offset;
        }
        else
        {
            gui_list_menu_measure_item(m, g_gui_ssp_clicked_half_item, &iwidth, &iheight);
            if (iheight < m->height)
            {
                final_y_offset = g_gui_ssp_start_menu_offset + (iheight - m->last_displayed_offset);
            }
            else
            {
                final_y_offset = g_gui_ssp_start_menu_offset + (m->height - m->last_displayed_offset);
            }
            momentum = m->last_displayed_offset - iheight;
        }
        gui_ssp_enter_free_run_recover_mode(final_y_offset, momentum);
        gui_start_timer((*g_gui_ssp_frame_update_interval), gui_ssp_update_frame);   
        g_gui_ssp_clicked_half_item = -1;
        return MMI_TRUE;
    }

    return MMI_FALSE;
}
#endif /* defined(__MMI_UI_LIST_SCROLL_BY_PIXEL__) */

#else /* GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN */
/*****************************************************************************
 * FUNCTION
 *  gui_ssp_pen_up_dummy
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gui_ssp_pen_up_dummy(void) 
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
}        

#endif /* GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN */


/*****************************************************************************
 * FUNCTION
 *  gui_effect_register_query_enable_draw_last_frame
 * DESCRIPTION
 *  set the query draw last frame callback
 * PARAMETERS
 *  f        : [IN]        query callback function
 * RETURNS
 *  void
 *****************************************************************************/
void gui_effect_register_query_enable_draw_last_frame(MMI_BOOL(*f)(void))
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifndef __MMI_UI_MENU_SLIM__	
    g_query_enable_draw_last_frame = f;
#endif
}


/*****************************************************************************
 * FUNCTION
 *  gui_smooth_scrolling_effect_run
 * DESCRIPTION
 *  Runs the smooth scrolling effect.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gui_smooth_scrolling_effect_run(void)
{ 
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#ifdef GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN
    gui_common_menuitem_base_struct *m = (gui_common_menuitem_base_struct*)MMI_fixed_list_menu.common_item_data;  
#endif

#ifdef GUI_MATRIX_MENU_SMOOTH_SCROLLING_BY_PEN
    gui_common_menuitem_base_struct *mm = (gui_common_menuitem_base_struct*)MMI_fixed_matrix_menu.common_item_data;  
#endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN

#ifdef __MMI_FTE_SUPPORT__            
    /* register pre-pen handler for SSP (Smooth Scrolling by Pen) */
    if (m &&
        (MMI_current_menu_type == LIST_MENU) && /* only for the list menu */
#if defined(__MMI_CAT203_SUPPORT__) || defined(__MMI_CAT103_SUPPORT__)
        (!(m->flags & UI_MENUITEM_DISABLE_HIGHLIGHT)/* need highlight */    
#if defined(__MMI_CAT203_SUPPORT__)        
         || g_dm_data.s32CatId == MMI_CATEGORY203_ID  /* Or Use Category 203 */
#endif
#if defined(__MMI_CAT103_SUPPORT__)        
        || g_dm_data.s32CatId == MMI_CATEGORY103_ID
#endif
        ) &&  /* Or Use Category 203 */
#else
        !(m->flags & UI_MENUITEM_DISABLE_HIGHLIGHT) &&/* need highlight */        
#endif
        (g_gui_list_menu_smooth_scrolling_menu_type != GUI_MENU_TYPE_INVALID) &&
        g_dm_data.s32CatId != MMI_CATEGORY150_ID &&
        g_dm_data.s32CatId != MMI_CATEGORY273_ID
#ifndef __COSMOS_MMI_PACKAGE__
#ifndef __MMI_THEMES_V2_SUPPORT__
#ifdef  __MMI_THEMES_APPLICATION__
        &&
        (g_dm_data.s32ScrId != SCR_ID_THM_MENU)
#endif  /* __MMI_THEMES_APPLICATION__ */
#endif
#endif
#ifdef __MMI_CAT265_SUPPORT__
		&& 
		(g_dm_data.s32CatId != MMI_CATEGORY265_ID)
#endif

        )
#else
    /* register pre-pen handler for SSP (Smooth Scrolling by Pen) */
    if (m &&
        (MMI_current_menu_type == LIST_MENU) && /* only for the list menu */
#ifdef __MMI_CAT203_SUPPORT__
        (!(m->flags & UI_MENUITEM_DISABLE_HIGHLIGHT) ||/* need highlight */        
        g_dm_data.s32CatId == MMI_CATEGORY203_ID) &&  /* Or Use Category 203 */
#else
        !(m->flags & UI_MENUITEM_DISABLE_HIGHLIGHT) &&/* need highlight */        
#endif
        (g_gui_list_menu_smooth_scrolling_menu_type != GUI_MENU_TYPE_INVALID) &&
        g_dm_data.s32CatId != MMI_CATEGORY_CASCADING_MENU_ID && 
        g_dm_data.s32CatId != MMI_CATEGORY150_ID &&
        g_dm_data.s32CatId != MMI_CAT1001_ID &&
        g_dm_data.s32CatId != MMI_CATEGORY273_ID
#ifndef __COSMOS_MMI_PACKAGE__
#ifndef __MMI_THEMES_V2_SUPPORT__
#ifdef  __MMI_THEMES_APPLICATION__
        &&
        (g_dm_data.s32ScrId != SCR_ID_THM_MENU)
#endif  /* __MMI_THEMES_APPLICATION__ */
#endif
#endif
#ifdef __MMI_SMALL_LIST_SCREEN__
        &&
        (g_dm_data.s32CatId != MMI_CATEGORY10_ID)
#endif 
#ifdef __MMI_CAT265_SUPPORT__
		&& 
		(g_dm_data.s32CatId != MMI_CATEGORY265_ID)
#endif

        )
#endif

    {
        wgui_pen_register_pre_hdlr(gui_ssp_pen_pre_hdlr);
        mmi_pen_config_sampling_period(MMI_PEN_SAMPLING_PERIOD_2, MMI_PEN_SAMPLING_PERIOD_2);
    }    
#endif /* GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN */ 

#if defined(GUI_MATRIX_MENU_SMOOTH_SCROLLING_BY_PEN) && defined(__MMI_TOUCH_SCREEN__)
    if (mm && (MMI_current_menu_type == MATRIX_MENU) && 
        //(!(MMI_fixed_matrix_menu.flags & UI_MATRIX_MENU_FOR_MAINMENU)) &&
        g_gui_matrix_menu_support_ssp &&
        (g_gui_matrix_menu_smooth_scrolling_menu_type != GUI_MENU_TYPE_INVALID))
    {
        wgui_pen_register_pre_hdlr(gui_matrix_ssp_pen_pre_hdlr);
        mmi_pen_config_sampling_period(MMI_PEN_SAMPLING_PERIOD_2, MMI_PEN_SAMPLING_PERIOD_2);
    }
#endif  /* GUI_MATRIX_MENU_SMOOTH_SCROLLING_BY_PEN */
}

#ifndef __MMI_UI_MENU_SLIM__
/*****************************************************************************
 * FUNCTION
 *  gui_smooth_scrolling_effect_post_exit_category
 * DESCRIPTION
 *  post exit category for smooth scrolling 
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gui_smooth_scrolling_effect_post_exit_category(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN
    wgui_pen_register_pre_hdlr(NULL);
    gui_cancel_timer(gui_ssp_update_frame);
    mmi_pen_config_sampling_period(MMI_PEN_SAMPLING_PERIOD_1, MMI_PEN_SAMPLING_PERIOD_2);
#endif /* GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN */

#if defined(GUI_MATRIX_MENU_SMOOTH_SCROLLING_BY_PEN) && defined(__MMI_TOUCH_SCREEN__)
    wgui_pen_register_pre_hdlr(NULL);
    gui_cancel_timer(gui_matrix_ssp_update_frame);
    mmi_pen_config_sampling_period(MMI_PEN_SAMPLING_PERIOD_1, MMI_PEN_SAMPLING_PERIOD_2);
    g_gui_matrix_menu_support_ssp = MMI_TRUE;
#endif

    /* clears the stop callback */
#if defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_KEY) || defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN)
    gui_list_menu_smooth_scrolling_register_stop_callback(NULL);
#endif
}

#endif
/*****************************************************************************
 * FUNCTION
 *  gui_smooth_scrolling_effect_setup
 * DESCRIPTION
 *  setup smooth scrolling effect
 * PARAMETERS
 *  category_id           [IN]      current category ID
 *  category_flag         [IN]      current category flag
 *  category_redraw       [IN]      current category redraw state
 * RETURNS
 *  void
 *****************************************************************************/
void gui_smooth_scrolling_effect_setup(S32 category_id, S32 category_flag, S32 category_redraw)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_KEY) || defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN) || defined(GUI_MATRIX_MENU_SMOOTH_SCROLLING_BY_PEN)
    /* 
     * only detect the menu type for the first time showing since some APP might clear the KEY_DOWN handler,
     * such as, CALLSETLineSwitchRsp() and MakePsSelectLine() in LineSwitching.c. 
     */
    if (category_redraw == NORMAL_REDRAW)
    {
#if defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_KEY) || defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN)
        g_gui_list_menu_smooth_scrolling_old_menu_type = g_gui_list_menu_smooth_scrolling_menu_type;
#endif
        g_gui_list_menu_smooth_scrolling_menu_type = gui_list_menu_smooth_scrolling_get_menu_type();
        
#ifdef GUI_MATRIX_MENU_SMOOTH_SCROLLING_BY_PEN
        g_gui_matrix_menu_smooth_scrolling_old_menu_type = g_gui_matrix_menu_smooth_scrolling_menu_type;
        g_gui_matrix_menu_smooth_scrolling_menu_type = gui_matrix_menu_smooth_scrolling_get_menu_type();
#endif

        if (g_gui_list_menu_smooth_scrolling_menu_type != GUI_MENU_TYPE_INVALID 
#ifdef __MMI_CAT1X_0P11_SUPPORT__
            && g_dm_data.s32CatId != MMI_CAT1001_OP11_ID
#endif /* __MMI_CAT1X_0P11_SUPPORT__*/
         )
        {                
#if defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_KEY) || defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN)
            MMI_WGUI_SET_KEY_PROC(gui_list_menu_smooth_scrolling_key_proc, NULL);
#endif
        }  

#if defined(GUI_MATRIX_MENU_SMOOTH_SCROLLING_BY_PEN)
        if ((g_gui_matrix_menu_smooth_scrolling_menu_type != GUI_MENU_TYPE_INVALID)) //&&
            //!(MMI_fixed_matrix_menu.flags & UI_MATRIX_MENU_FOR_MAINMENU))
        {
            MMI_WGUI_SET_KEY_PROC(gui_matrix_menu_smooth_scrolling_key_proc, NULL);
        }
#endif
    }
#endif /* defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_KEY) || defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN) */
}


#if  defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_KEY)
/*****************************************************************************
 * FUNCTION
 *  gui_list_menu_is_support_smooth_scrolling
 * DESCRIPTION
 *  whether current list menu is support smooth scrolling effect.
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_BOOL : 
 *      MMI_TRUE : curent list menu support smooth scrolling effect, vice versa
 *****************************************************************************/
MMI_BOOL gui_list_menu_is_support_smooth_scrolling(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL support_sms = MMI_TRUE;
    fixed_list_menu *list_menu;
    gui_common_menuitem_base_struct *m;
    gdi_handle scr_bg_layer;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    list_menu = &MMI_fixed_list_menu;  
    m = (gui_common_menuitem_base_struct*)list_menu->common_item_data;
    
    /* 
     * For REAL asyncdynamic 26x categories, when going back from the loading screen,
     * the highlighted item may be the last item. That causes this effect ineffective.
     * To avoid the inconsistency in the same screen, smooth scrolling must be disabled.
     */
    if ((g_dm_data.s32CatId == MMI_CATEGORY261_ID) || 
        (g_dm_data.s32CatId == MMI_CATEGORY262_ID) || 
        (g_dm_data.s32CatId == MMI_CATEGORY263_ID) ||
        (g_dm_data.s32CatId == MMI_CATEGORY267_ID))
    {
        support_sms = MMI_FALSE;
    }

    g_gui_list_menu_smooth_scrolling_menu_type = gui_list_menu_smooth_scrolling_get_menu_type();

    if ((m == NULL) ||
#if defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_KEY) || defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN)
        (wgui_fixed_list_get_style() == GUI_MENU_TYPE_INVALID) ||
#endif
#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
        (gui_get_current_list_effect() != MMI_UI_LIST_HIGHLIGHT_EFFECT_SLIDE) || 
#endif        
        (MMI_current_menu_type != LIST_MENU) || /* only for the list menu */
        (m->flags & UI_MENUITEM_DISABLE_HIGHLIGHT) ||  /* need highlight */
        (m->ext_flags & UI_MENUITEM_EXT_INEQUAL_HEIGHT) ||
        gui_list_effect_slide_is_highlight_item_two_line() || /* disable for two line */
        (m->focussed_filler->b == NULL) ||
        (list_menu->displayed_items < 3))  /* do not enable when fewer than 3 displayed items */
    {
        support_sms = MMI_FALSE;
    }

    scr_bg_layer = dm_get_scr_bg_layer();
    if (scr_bg_layer == GDI_ERROR_HANDLE)
    {
        support_sms = MMI_FALSE;
    }

    if ((g_gui_ssp_static_layer != GDI_NULL_HANDLE))
    {
        support_sms = MMI_FALSE;
    }

    return support_sms;
}
#endif  /* GUI_LIST_MENU_SMOOTH_SCROLLING_BY_NUMBER_KEY | GUI_LIST_MENU_SSK_EFFECT_BY_PEN */


#if defined(GUI_MATRIX_MENU_SMOOTH_SCROLLING_BY_PEN)
/*****************************************************************************
 * FUNCTION
 *  gui_matrix_menu_enable_ssp
 * DESCRIPTION
 *  set whether matrix menu support ssp
 * PARAMETERS
 *  enable_ssp       [IN]   whether matrix menu support ssp
 * RETURNS
 *  void
 *****************************************************************************/
void gui_matrix_menu_enable_ssp(MMI_BOOL enable_ssp)
{
    g_gui_matrix_menu_support_ssp = enable_ssp;
}


/*****************************************************************************
 * FUNCTION
 *  gui_matrix_ssp_enter_free_run_recover_mode
 * DESCRIPTION
 *  Enters the SSP recover mode.
 * PARAMETERS
 *  final_y_offset       [IN]   the final menu y offset
 *  momentum             [IN]   move range to recover
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_matrix_ssp_enter_free_run_recover_mode(S32 final_y_offset, S32 momentum)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_gui_matrix_ssp_state = GUI_MATRIX_SMOOTH_SCROLLING_BY_PEN_STATE_FREE_RUN;
    g_gui_matrix_ssp_free_run_mode = GUI_SSP_FREE_RUN_MODE_RECOVER;            
    g_gui_matrix_ssp_free_run_momentum = momentum;
    g_gui_matrix_ssp_free_run_final_pos = final_y_offset;
}


/*****************************************************************************
 * FUNCTION
 *  gui_matrix_ssp_try_free_run_recover
 * DESCRIPTION
 *  Tries to enter the recover mode as possible.
 * PARAMETERS
 *  menu_y_offset       [IN]    current menu y offset
 * RETURNS
 *  MMI_TRUE if recovering is executed; otherwise, MMI_FALSE.
 *****************************************************************************/
static MMI_BOOL gui_matrix_ssp_try_free_run_recover(S32 menu_y_offset)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 menu_last_y_offset;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    menu_last_y_offset = gui_matrix_ssp_get_menu_last_y_offset();

    if ((!menu_last_y_offset && menu_y_offset) || (menu_y_offset < 0))
    {   
        /* 
         * single page: always go back to origin
         * multi page: go back to origin
         */
        gui_matrix_ssp_enter_free_run_recover_mode(0, menu_y_offset);
        gui_start_timer((*g_gui_ssp_frame_update_interval), gui_matrix_ssp_update_frame);

        return MMI_TRUE;
    }
    else if (menu_last_y_offset && (menu_y_offset > menu_last_y_offset))
    {
        /*
         * multi page: go back to the last y
         */
        gui_matrix_ssp_enter_free_run_recover_mode(menu_last_y_offset, menu_y_offset - menu_last_y_offset);
        gui_start_timer((*g_gui_ssp_frame_update_interval), gui_matrix_ssp_update_frame);   

        return MMI_TRUE;
    }

    return MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  gui_matrix_ssp_pen_up_dummy
 * DESCRIPTION
 *  Executes the pen up handler without pen up point information.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gui_matrix_ssp_pen_up_dummy(void) 
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_pen_point_struct dummy_point = {0};

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_matrix_ssp_pen_up_hdlr(dummy_point);
    gui_cancel_timer(gui_matrix_ssp_update_frame);
}        


/*****************************************************************************
 * FUNCTION
 *  gui_matrix_ssp_get_menu_last_y_offset
 * DESCRIPTION
 *  Gets the last menu y offset for for a normal displayed menu.
 * PARAMETERS
 *  void
 * RETURNS
 *  The last y offset.
 *****************************************************************************/
static S32 gui_matrix_ssp_get_menu_last_y_offset(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 item_height, xoff, yoff, total_height;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    item_height = MMI_fixed_matrix_menu.item_height;
    gui_matrix_menu_get_gap(&MMI_fixed_matrix_menu, &xoff, &yoff);
    
    if (MMI_fixed_matrix_menu.displayed_rows >= MMI_fixed_matrix_menu.n_rows)
    {   /* single page menu*/
        return 0;
    }
    else
    {
        /* multi page menu */
        total_height = MMI_fixed_matrix_menu.n_rows* (item_height + yoff) + yoff;
        if (MMI_fixed_matrix_menu.flags & UI_DYAMIC_MATRIX_MENU_ALIGN_LEFT_TOP ||
            MMI_fixed_matrix_menu.flags & UI_MATRIX_MENU_ALIGN_LEFT_TOP)
        {
            total_height += (MMI_fixed_matrix_menu.height - (item_height + yoff) * MMI_fixed_matrix_menu.displayed_rows);
        }

        return (total_height - MMI_fixed_matrix_menu.height);
    }
}


/*****************************************************************************
 * FUNCTION
 *  gui_matrix_ssp_is_point_in_menu_rect
 * DESCRIPTION
 *  Checks whether a point is in the valid matrix menu rect (excluding the scroll bar)
 * PARAMETERS
 *  point       [IN]    coordinate
 * RETURNS
 *  MMI_TRUE if the point is inside; otherwise, MMI_FALSE
 *****************************************************************************/
static MMI_BOOL gui_matrix_ssp_is_point_in_menu_rect (mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    fixed_matrix_menu *m = &MMI_fixed_matrix_menu;
    S32 x1, y1, menu_height, menu_width;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    x1 = m->x;
    y1 = m->y;

    menu_height = m->height;
    menu_width = m->width;

    /* check whether have horizontal and vertical bar */
    if (m->flags & UI_MATRIX_MENU_SHOW_HORIZONTAL_SCROLLBAR)
    {
        menu_height -= m->hbar.height;
    }
    
    if (m->flags & UI_MATRIX_MENU_SHOW_VERTICAL_SCROLLBAR)
    {
        menu_width -= m->vbar.width;
    }

    if (PEN_CHECK_BOUND(point.x, point.y, x1, y1, menu_width, menu_height))
    {
        return MMI_TRUE;
    }
    
    return MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  gui_matrix_menu_smooth_scrolling_redraw_list
 * DESCRIPTION
 *  Redraws the matrix menu
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_matrix_menu_smooth_scrolling_redraw_list(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (g_gui_matrix_menu_smooth_scrolling_menu_type)
    {
        case GUI_MENU_TYPE_FIXED:
            show_fixed_matrix();
            break;

#ifdef  __MMI_SUPPORT_DYNAMIC_MATRIX_MENU__
        case GUI_MENU_TYPE_DYNAMIC:
            show_dynamic_matrix();
            break;
#endif  // __MMI_SUPPORT_DYNAMIC_MATRIX_MENU__

#ifdef  __MMI_SUPPORT_ASYNCDYNAMIC_MATRIX_MENU__
        case GUI_MENU_TYPE_ASYNCDYNAMIC:
            show_asyncdynamic_matrix();
            break;
#endif  /* __MMI_SUPPORT_ASYNCDYNAMIC_MATRIX_MENU__ */            

        default:
            break;                
    }
}  


/*****************************************************************************
 * FUNCTION
 *  gui_matrix_menu_smooth_scrolling_goto_item
 * DESCRIPTION
 *  Goes to an item according to the matrix menu type.
 * PARAMETERS
 *  item_index       [IN]   menu item index
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_matrix_menu_smooth_scrolling_goto_item(S32 item_index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 old_flags = MMI_fixed_matrix_menu.flags;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_fixed_matrix_menu.flags |= UI_MATRIX_MENU_DISABLE_DRAW;
    switch (g_gui_matrix_menu_smooth_scrolling_menu_type)
    {
        case GUI_MENU_TYPE_FIXED:
            fixed_matrix_goto_item(item_index);
            break;

#ifdef  __MMI_SUPPORT_DYNAMIC_MATRIX_MENU__
        case GUI_MENU_TYPE_DYNAMIC:
            dynamic_matrix_goto_item(item_index);
            break;
#endif  // __MMI_SUPPORT_DYNAMIC_MATRIX_MENU__
            
#ifdef  __MMI_SUPPORT_ASYNCDYNAMIC_MATRIX_MENU__            
        case GUI_MENU_TYPE_ASYNCDYNAMIC:
            asyncdynamic_matrix_goto_item(item_index);
            break;            
#endif  /* __MMI_SUPPORT_ASYNCDYNAMIC_MATRIX_MENU__ */            
            
        default:
            break;
    }
    MMI_fixed_matrix_menu.flags = old_flags;
}


/*****************************************************************************
 * FUNCTION
 *  gui_matrix_menu_smooth_scrolling_goto_item_noredraw
 * DESCRIPTION
 *  Highlight the menu item without drawing the menu
 * PARAMETERS
 *  item_index       [IN]   menu item index to be highlighted
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_matrix_menu_smooth_scrolling_goto_item_noredraw(S32 item_index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (g_gui_matrix_menu_smooth_scrolling_menu_type)
    {
        case GUI_MENU_TYPE_FIXED:
            fixed_matrix_goto_item_no_redraw(item_index);
            break;

#ifdef  __MMI_SUPPORT_DYNAMIC_MATRIX_MENU__
        case GUI_MENU_TYPE_DYNAMIC:
            dynamic_matrix_goto_item_no_redraw(item_index);
            break;
#endif  // __MMI_SUPPORT_DYNAMIC_MATRIX_MENU__
            
#ifdef  __MMI_SUPPORT_ASYNCDYNAMIC_MATRIX_MENU__           
        case GUI_MENU_TYPE_ASYNCDYNAMIC:
            asyncdynamic_matrix_goto_item_no_redraw(item_index);
            break;            
#endif  /* __MMI_SUPPORT_ASYNCDYNAMIC_MATRIX_MENU__ */            
            
        default:
            break;
    }
}


/*****************************************************************************
 * FUNCTION
 *  gui_matrix_menu_get_gap
 * DESCRIPTION
 *  get the  horizontal and vertical gap between menu item
 * PARAMETERS
 *  m       [IN]    matrix menu point
 *  xoff    [OUT] horizontal gap
 *  yoff    [OUT]   vertical gap
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_matrix_menu_get_gap(fixed_matrix_menu *m, S32 *xoff, S32 *yoff)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 width, height, iwidth, iheight;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    height = m->height;
    width = m->width;
    iwidth = m->item_width;
    iheight = m->item_height;
    
    if (m->flags & UI_MATRIX_MENU_SHOW_HORIZONTAL_SCROLLBAR)
    {
        height -= m->hbar.height;
    }

    if (m->flags & UI_MATRIX_MENU_SHOW_VERTICAL_SCROLLBAR)
    {
        width -= m->vbar.width;
    }
    
    *xoff = (width - (iwidth * m->displayed_columns)) / (m->displayed_columns + 1);
    *yoff = (height - (iheight * m->displayed_rows)) / (m->displayed_rows + 1);
}


/*****************************************************************************
 * FUNCTION
 *  gui_matrix_ssp_pen_down_hdlr
 * DESCRIPTION
 *  Pen down handler of matrix Smooth Scrolling by Pen.
 * PARAMETERS
 *  point       [IN]    pen point
 * RETURNS
 *  MMI_TRUE if this pen event is handled; otherwise, MMI_FALSE.
 *****************************************************************************/
static MMI_BOOL gui_matrix_ssp_pen_down_hdlr (mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    fixed_matrix_menu *m = &MMI_fixed_matrix_menu;
    S32 new_highlight_item_index, xoff, yoff;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_gui_ssp_is_pen_down_in_matrix = MMI_FALSE;
    gui_slide_highlight_removed = MMI_FALSE;
    g_gui_matrix_ssp_old_menu_highlight_item_index = m->highlighted_item;

    if (m->n_items == 0)
    {
        return MMI_FALSE;
    }
    
    if (!gui_matrix_ssp_is_point_in_menu_rect(point))
    {
        if (g_gui_matrix_ssp_state == GUI_MATRIX_SMOOTH_SCROLLING_BY_PEN_STATE_FREE_RUN)
        {
            gui_matrix_ssp_pen_up_hdlr(point);
            g_gui_matrix_ssp_state = GUI_MATRIX_SMOOTH_SCROLLING_BY_PEN_STATE_UNFOCUS;
            g_gui_ssp_is_pen_down_in_matrix = MMI_TRUE;
            return MMI_TRUE;  
        }    

        gui_matrix_ssp_pen_abort_hdlr(point);

        return MMI_FALSE;  
    }

    g_gui_matrix_ssp_pen_down_x = (S32) point.x;
    g_gui_matrix_ssp_pen_down_y = (S32) point.y;
    g_gui_matrix_ssp_pen_down_state = g_gui_matrix_ssp_state;

    switch (g_gui_matrix_ssp_state)
    {
        case GUI_MATRIX_SMOOTH_SCROLLING_BY_PEN_STATE_UNFOCUS:
            g_gui_matrix_ssp_old_first_row = m->first_displayed_row;
            g_gui_matrix_ssp_old_last_row = g_gui_matrix_ssp_old_first_row + m->displayed_rows;
            g_gui_matrix_ssp_old_first_col = m->first_displayed_column;
            g_gui_matrix_ssp_state = GUI_MATRIX_SMOOTH_SCROLLING_BY_PEN_STATE_FOCUS;
            break;

        case GUI_MATRIX_SMOOTH_SCROLLING_BY_PEN_STATE_FREE_RUN:
            gui_cancel_timer(gui_matrix_ssp_update_frame);
            g_gui_matrix_ssp_state = GUI_MATRIX_SMOOTH_SCROLLING_BY_PEN_STATE_HOLD;
            gui_ssp_sync_matrix_menu_display();
            g_gui_matrix_ssp_old_first_row = m->first_displayed_row;
            g_gui_matrix_ssp_old_last_row = g_gui_matrix_ssp_old_first_row + m->displayed_rows;
            g_gui_matrix_ssp_old_first_col = m->first_displayed_column;
            g_gui_matrix_ssp_state = GUI_MATRIX_SMOOTH_SCROLLING_BY_PEN_STATE_HOLD;
            break;

        default:
            break;
    }

    g_gui_matrix_ssp_old_highlight_col = m->highlighted_column;
    
    if (g_gui_matrix_menu_smooth_scrolling_menu_type == GUI_MENU_TYPE_INVALID)
    {
        return MMI_FALSE;
    }
    
    /* goes to the selected item */
    if (gui_matrix_ssp_menu_translate_pen_position(m, g_gui_matrix_ssp_pen_down_x, g_gui_matrix_ssp_pen_down_y, &new_highlight_item_index))
    {
        if (new_highlight_item_index == m->highlighted_item)
        {   /* still have to redraw when the highlight does not change */
            if (g_gui_matrix_menu_smooth_scrolling_menu_type != GUI_MENU_TYPE_INLINE || g_gui_matrix_ssp_pen_down_state == GUI_LIST_SMOOTH_SCROLLING_BY_PEN_STATE_FREE_RUN)
            {
                if (!(MMI_fixed_matrix_menu.flags & UI_MATRIX_MENU_FOR_MAINMENU))
                {
                    gui_matrix_menu_smooth_scrolling_redraw_list();
                }
            }
        }
        else
        {
            if (g_gui_matrix_menu_smooth_scrolling_menu_type != GUI_MENU_TYPE_INLINE || g_gui_matrix_ssp_pen_down_state == GUI_LIST_SMOOTH_SCROLLING_BY_PEN_STATE_FREE_RUN)
            {
                gdi_layer_lock_frame_buffer();
                gui_matrix_menu_smooth_scrolling_goto_item(new_highlight_item_index);
                gdi_layer_unlock_frame_buffer();
                /* it will only draw the last highlight item and the new highlight item, so it need redraw the other menu item */
                gui_matrix_menu_smooth_scrolling_redraw_list();
                g_gui_matrix_ssp_old_highlight_col = m->highlighted_column;
            }
        }
        
        if (g_gui_matrix_ssp_state == GUI_MATRIX_SMOOTH_SCROLLING_BY_PEN_STATE_FOCUS)
        {
            /* send event to menu item handle */
            if (gui_matrix_ssp_send_pen_event(
                    MMI_PEN_EVENT_DOWN, 
                    &point))
            {
                g_gui_matrix_ssp_state = GUI_MATRIX_SMOOTH_SCROLLING_BY_PEN_STATE_UNFOCUS;
                g_gui_ssp_is_click_item_own_area = MMI_TRUE;
                    
                return MMI_TRUE;                
            }        
        }        
    }
    else
    {
        /* redraw matrix menu when pen down not in matrix menu valid area in free run state */
        if (g_gui_matrix_ssp_state == GUI_MATRIX_SMOOTH_SCROLLING_BY_PEN_STATE_HOLD)
        {
            gui_list_menu_smooth_scrolling_redraw_list();
        }
        
        g_gui_matrix_ssp_state = GUI_MATRIX_SMOOTH_SCROLLING_BY_PEN_STATE_UNFOCUS;
    
        return MMI_FALSE;
    }
    
    kal_get_time(&g_gui_matrix_ssp_pen_down_time);

    gui_matrix_menu_get_gap (m, &xoff, &yoff);
    g_gui_matrix_ssp_start_menu_y_offset = m->first_displayed_row * (m->item_height + yoff);
    if (m->flags & UI_DYAMIC_MATRIX_MENU_ALIGN_LEFT_TOP ||
        m->flags & UI_MATRIX_MENU_ALIGN_LEFT_TOP)
    {
        g_gui_matrix_ssp_start_menu_y_offset -= yoff;
    }
    g_gui_matrix_ssp_current_menu_y_offset = g_gui_matrix_ssp_start_menu_y_offset;

    return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  gui_matrix_ssp_pen_move_hdlr
 * DESCRIPTION
 *  Pen move handler of Matrix Smooth Scrolling by Pen.
 * PARAMETERS
 *  point       [IN]    pen point
 * RETURNS
 *  MMI_TRUE if this pen event is handled; otherwise, MMI_FALSE.
 *****************************************************************************/
static MMI_BOOL gui_matrix_ssp_pen_move_hdlr (mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    fixed_matrix_menu *m = &MMI_fixed_matrix_menu;
    void *item;
    S32 y_move_offset;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_gui_matrix_ssp_state == GUI_MATRIX_SMOOTH_SCROLLING_BY_PEN_STATE_UNFOCUS)
    {
        if (gui_matrix_ssp_is_point_in_menu_rect(point))
        {
            if (g_gui_ssp_is_click_item_own_area)
            {
                gui_matrix_ssp_send_pen_event(MMI_PEN_EVENT_MOVE, &point);
                return MMI_FALSE;
            }
            else
                return MMI_TRUE;
        }
        else if (g_gui_ssp_is_pen_down_in_matrix)
        {
            return MMI_TRUE;
        }
        else
        {
            return MMI_FALSE;
        }
    }

    /* update pen move point */
    g_gui_matrix_ssp_pen_move_y = (S32) point.y;

    switch (g_gui_matrix_ssp_state)
    {
        case GUI_MATRIX_SMOOTH_SCROLLING_BY_PEN_STATE_FOCUS:
            /* goto the hold state if move range execed threhold */
            y_move_offset = GUI_EFFECT_ABS(g_gui_matrix_ssp_pen_move_y - g_gui_matrix_ssp_pen_down_y);
            
            if ((y_move_offset > GUI_MATRIX_SSP_FOCUS_TO_HOLD_STATE_Y_THRESHOLD))
            {
                item = gui_matrix_menu_smooth_scrolling_get_item(m->highlighted_item);
                if (item)
                {
                    m->item_remove_highlight_function(item, m->common_item_data);
                    m->item_highlight_function(item, m->common_item_data);
                }
                gui_ssp_stop_matrix_menu_scrolling();

                g_gui_matrix_ssp_state = GUI_MATRIX_SMOOTH_SCROLLING_BY_PEN_STATE_HOLD;
                /* trigger GUI_MATRIX_SMOOTH_SCROLLING_BY_PEN_STATE_HOLD state */
                return gui_matrix_ssp_pen_move_hdlr(point);
            }
            break;

        case GUI_MATRIX_SMOOTH_SCROLLING_BY_PEN_STATE_HOLD:
            /* start update matrix frame */
            gui_ssp_stop_matrix_menu_scrolling();        
            gui_start_timer((*g_gui_ssp_frame_update_interval), gui_matrix_ssp_update_frame);
            break;

        default:
            break;
    }

    return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  gui_matrix_menuitem_handle_ssp_pen_up
 * DESCRIPTION
 *  menuitem handler pen up event.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_matrix_menuitem_handle_ssp_pen_up()
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    fixed_matrix_menu *m = &MMI_fixed_matrix_menu;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_TOUCH_SCREEN__
#ifdef __MMI_FTE_SUPPORT__
    if (m->tap_callback_funtion == NULL)
    {
        gui_ssp_execute_lsk(KEY_EVENT_UP);
    }
    else
    {
        if (g_gui_matrix_ssp_old_menu_highlight_item_index == m->highlighted_item)
        {
            m->tap_callback_funtion(ENUM_TAP_ON_HIGHLIGHTED_ITEM, m->highlighted_item);
        }
        else
        {
            m->tap_callback_funtion(ENUM_TAP_ON_NONHIGHLIGHTED_ITEM, m->highlighted_item);
        }
    }
#else   /* __MMI_FTE_SUPPORT__ */
    if (m->pen_event_current_selected_callback_function != NULL)
    {
        m->pen_event_current_selected_callback_function();
    }
    else
    {
        gui_ssp_execute_lsk(KEY_EVENT_UP);
    }
#endif  /* __MMI_FTE_SUPPORT__ */
#endif
}


/*****************************************************************************
 * FUNCTION
 *  gui_matrix_ssp_pen_up_hdlr
 * DESCRIPTION
 *  Pen up handler of Matrix Smooth Scrolling by Pen.
 * PARAMETERS
 *  point       [IN]    pen point
 * RETURNS
 *  MMI_TRUE if this pen event is handled; otherwise, MMI_FALSE.
 *****************************************************************************/
static MMI_BOOL gui_matrix_ssp_pen_up_hdlr (mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    fixed_matrix_menu *m = &MMI_fixed_matrix_menu;
    S32 item_height;//, item_width;
    U32 pen_up_time, pen_down_to_up_delta_time;
    S32 pen_down_to_up_y_delta;
    S32 up_item_index, list_error;
    MMI_BOOL trans_ret, is_slow_data;
    gui_matrix_smooth_scrolling_by_pen_state_enum gui_ssp_state_redraw, gui_ssp_old_state;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (m->n_items == 0)
    {
        return MMI_FALSE;
    }
    item_height = MMI_fixed_matrix_menu.item_height;

    if (g_gui_matrix_ssp_state == GUI_MATRIX_SMOOTH_SCROLLING_BY_PEN_STATE_UNFOCUS)
    {
        /* matrix has handle the pen down event, Now check if it still handles pen up event */
        if (g_gui_ssp_is_click_item_own_area &&
            gui_matrix_ssp_is_point_in_menu_rect(point) &&
            gui_matrix_ssp_send_pen_event(
                MMI_PEN_EVENT_UP,
                &point))
        {
            if (g_gui_matrix_menu_smooth_scrolling_menu_type != GUI_MENU_TYPE_INVALID)
            {
                gui_matrix_menu_smooth_scrolling_redraw_list();
                if (g_gui_matrix_menu_smooth_scrolling_menu_type == GUI_MENU_TYPE_DYNAMIC)
                {
                    if ((m->n_items != 0) && 
                        (!in_dynamic_item_buffer(m->highlighted_item)))
                    {
                        return MMI_TRUE;
                    }
                }
                else if (g_gui_matrix_menu_smooth_scrolling_menu_type == GUI_MENU_TYPE_ASYNCDYNAMIC)
                {
                    if ((m->n_items != 0) &&
                        (in_asyncdynamic_item_buffer(m->highlighted_item)))
                    {
                        return MMI_TRUE;
                    }
                }

#ifndef __MMI_FTE_SUPPORT__
                if (m->pen_event_current_selected_callback_function != NULL)
                {
                    m->pen_event_current_selected_callback_function();
                }
                else if ((m->pen_state.pen_on_horizontal_scrollbar == 0) || 
                        (m->pen_state.pen_on_vertical_scrollbar == 0))
                {
                    gui_ssp_execute_lsk(KEY_EVENT_UP);
                }
#endif  /* __MMI_FTE_SUPPORT__ */
            }

            return MMI_TRUE;
        }

#ifdef __MMI_TOUCH_SCREEN__
        if ((m->pen_state.pen_on_horizontal_scrollbar) || 
            (m->pen_state.pen_on_vertical_scrollbar)) 
        {
            return MMI_FALSE;
        }
        else
#endif
        {
            return MMI_TRUE;
        }
    }

    if (g_gui_matrix_ssp_state == GUI_MATRIX_SMOOTH_SCROLLING_BY_PEN_STATE_HOLD)
    {
        kal_get_time(&pen_up_time);
        
        pen_down_to_up_delta_time = kal_ticks_to_milli_secs(pen_up_time - g_gui_matrix_ssp_pen_down_time);
        pen_down_to_up_y_delta = (S32)point.y - g_gui_matrix_ssp_pen_down_y;

        if ((pen_down_to_up_delta_time < (*g_gui_ssp_free_run_threshold_time)) &&
            (GUI_EFFECT_ABS(pen_down_to_up_y_delta) > (*g_gui_ssp_free_run_movement_y_thresold)))
        {
            /* goto free run/recover mode */
            S32 pos_delta;
            
            pos_delta = GUI_EFFECT_ABS(pen_down_to_up_y_delta) * (*g_gui_menu_ssp_pos_delta);

            g_gui_matrix_ssp_free_run_momentum = pen_down_to_up_y_delta;
            if (g_gui_matrix_ssp_free_run_momentum < 0)
            {
                pos_delta = -pos_delta;
            }

            /* only move when the move range is greater than a single item */
            if (GUI_EFFECT_ABS(g_gui_matrix_ssp_free_run_momentum) > item_height)
            {
                /* free run mode */
                g_gui_matrix_ssp_state = GUI_MATRIX_SMOOTH_SCROLLING_BY_PEN_STATE_FREE_RUN;            
                g_gui_matrix_ssp_free_run_mode = GUI_SSP_FREE_RUN_MODE_RUN;
                g_gui_matrix_ssp_free_run_momentum = (S32)((float)-pos_delta * (*g_gui_ssp_free_run_sensitivity));
                g_gui_matrix_ssp_free_run_final_pos = g_gui_matrix_ssp_current_menu_y_offset - pos_delta;
                /* align the final position to multiples of menu item */
                g_gui_matrix_ssp_free_run_final_pos -= g_gui_matrix_ssp_free_run_final_pos % item_height;

                /* stop menu item scrolling */
                gui_ssp_stop_matrix_menu_scrolling();
                gui_start_timer((*g_gui_ssp_frame_update_interval), gui_matrix_ssp_update_frame);

                return MMI_TRUE;
            } 
        }
    }

    gui_cancel_timer(gui_matrix_ssp_update_frame);
    
    gui_ssp_state_redraw = g_gui_matrix_ssp_state;
    is_slow_data = wgui_list_menu_slow_data_mode;
    list_error = gui_asyncdynamic_list_error;
    
    if (((g_gui_matrix_ssp_state == GUI_MATRIX_SMOOTH_SCROLLING_BY_PEN_STATE_FREE_RUN) ||
        (g_gui_matrix_ssp_state == GUI_MATRIX_SMOOTH_SCROLLING_BY_PEN_STATE_HOLD)) && 
        GetExitScrnID() == GetActiveScreenId())
    {
        g_gui_matrix_ssp_state = GUI_MATRIX_SMOOTH_SCROLLING_BY_PEN_STATE_UNFOCUS;
        gui_ssp_sync_matrix_menu_display();
    }
    
    gui_ssp_old_state = g_gui_matrix_ssp_state;
    list_error = gui_asyncdynamic_list_error;
    g_gui_matrix_ssp_state = GUI_MATRIX_SMOOTH_SCROLLING_BY_PEN_STATE_UNFOCUS;

    trans_ret = gui_matrix_ssp_menu_translate_pen_position(m, (S32)point.x, (S32)point.y, &up_item_index);
    if (GetExitScrnID() == GetActiveScreenId())
    {
        if (!(((gui_ssp_state_redraw == GUI_MATRIX_SMOOTH_SCROLLING_BY_PEN_STATE_FREE_RUN) ||
            (gui_ssp_state_redraw == GUI_MATRIX_SMOOTH_SCROLLING_BY_PEN_STATE_HOLD)) && is_slow_data &&
            list_error == 1))
        {
            if (gui_ssp_old_state != GUI_MATRIX_SMOOTH_SCROLLING_BY_PEN_STATE_FOCUS)
            {
                gui_matrix_menu_smooth_scrolling_redraw_list();
            }
        }
    }
    g_gui_matrix_ssp_state = gui_ssp_old_state;
    
    /* execute selected item */
    if ((g_gui_matrix_ssp_state == GUI_MATRIX_SMOOTH_SCROLLING_BY_PEN_STATE_FOCUS) &&
        gui_matrix_ssp_is_point_in_menu_rect(point) &&
        (trans_ret == MMI_TRUE) &&
        (up_item_index == m->highlighted_item))
    {     
        if (g_gui_matrix_menu_smooth_scrolling_menu_type == GUI_MENU_TYPE_DYNAMIC)
        {
            if (MMI_fixed_matrix_menu.n_items != 0 && !in_dynamic_item_buffer(MMI_fixed_matrix_menu.highlighted_item))
                return MMI_TRUE;
        }
        else if (g_gui_matrix_menu_smooth_scrolling_menu_type == GUI_MENU_TYPE_ASYNCDYNAMIC)
        {
            if (MMI_fixed_matrix_menu.n_items != 0 && !in_asyncdynamic_item_buffer(MMI_fixed_matrix_menu.highlighted_item))
                return MMI_TRUE;
        }
        
        gui_matrix_menuitem_handle_ssp_pen_up();
    }

    g_gui_matrix_ssp_state = GUI_MATRIX_SMOOTH_SCROLLING_BY_PEN_STATE_UNFOCUS;

    return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  gui_matrix_ssp_pen_abort_hdlr
 * DESCRIPTION
 *  Pen abort handler of Matrix Smooth Scrolling by Pen.
 * PARAMETERS
 *  point       [IN]    pen point
 * RETURNS
 *  MMI_TRUE if this pen event is handled; otherwise, MMI_FALSE.
 *****************************************************************************/
static MMI_BOOL gui_matrix_ssp_pen_abort_hdlr (mmi_pen_point_struct point)
{
     /*----------------------------------------------------------------*/
     /* Local Variables                                                */
     /*----------------------------------------------------------------*/
     
     /*----------------------------------------------------------------*/
     /* Code Body                                                      */
     /*----------------------------------------------------------------*/
     if (MMI_fixed_matrix_menu.n_items == 0)
         return MMI_FALSE;
     g_gui_matrix_ssp_state = GUI_MATRIX_SMOOTH_SCROLLING_BY_PEN_STATE_UNFOCUS;
     gui_cancel_timer(gui_matrix_ssp_update_frame);
     
     return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  gui_ssp_sync_list_menu_display
 * DESCRIPTION
 *  Synchronizes the list menu display by SSP current display.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gui_ssp_sync_matrix_menu_display (void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    fixed_matrix_menu *m = &MMI_fixed_matrix_menu;
    void *item;
    S32 highlight_row, highlight_col, new_highlight_index;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* remove the highlight first */
    item = gui_matrix_menu_smooth_scrolling_get_item(m->highlighted_item);
    if (item)
    {
        m->item_remove_highlight_function(item, m->common_item_data);
    }

    m->first_displayed_row = g_gui_matrix_ssp_old_first_row;
    if ((g_gui_matrix_ssp_old_last_row >= m->n_rows - 1) && 
        (g_gui_matrix_ssp_old_last_row - g_gui_matrix_ssp_old_first_row) > m->displayed_rows - 1 &&
        (gui_matrix_ssp_get_menu_last_y_offset() - g_gui_matrix_ssp_current_menu_y_offset) < 5 )
    {
        m->first_displayed_row += 1;
    }
    m->first_displayed_column = g_gui_matrix_ssp_old_first_col;

    /* validate the first display row and col */
    if (m->first_displayed_row < 0)
    {
        m->first_displayed_row = 0;
    }
    if (m->first_displayed_column < 0)
    {
        m->first_displayed_column = 0;
    }

    if (m->first_displayed_row + m->displayed_rows > m->n_rows)
    {
        m->first_displayed_row = m->n_rows - m->displayed_rows;
    }

    if (m->first_displayed_column + m->displayed_columns > m->n_columns)
    {
        m->first_displayed_column = m->n_columns - m->displayed_columns;
    }

    if (m->first_displayed_row < 0)
    {
        m->first_displayed_row = 0;
    }
    if (m->first_displayed_column < 0)
    {
        m->first_displayed_column = 0;
    }

    /* calculate the new highlight index */
    new_highlight_index = m->highlighted_item;
    highlight_row = new_highlight_index/m->n_columns;
    highlight_col = g_gui_matrix_ssp_old_highlight_col;

    if (highlight_row < m->first_displayed_row)
    {
        highlight_row = m->first_displayed_row;
    }
    else if (highlight_row > m->first_displayed_row + m->displayed_rows - 1)
    {
        highlight_row = m->first_displayed_row + m->displayed_rows - 1;
    }

    new_highlight_index = highlight_row * m->n_columns + highlight_col;
    gui_matrix_menu_smooth_scrolling_goto_item_noredraw(new_highlight_index);
}


/*****************************************************************************
 * FUNCTION
 *  gui_matrix_ssp_update_frame
 * DESCRIPTION
 *  Updates a Matrix SSP frame.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gui_matrix_ssp_update_frame (void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    fixed_matrix_menu *m = &MMI_fixed_matrix_menu;
    S32 gap_x, gap_y, iheight, menu_full_height;//menu_full_width
    S32 max_offset_y, menu_offset_y;//menu_offset_x
    S32 low_bound, high_bound;
    S32 old_momentum;
    S32 menu_last_y_offset;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* calc the full menu height */
    gui_matrix_menu_get_gap(m, &gap_x, &gap_y);
    iheight = m->item_height;
    menu_full_height = (iheight + gap_y) * m->n_rows + gap_y;
    if (m->flags & UI_DYAMIC_MATRIX_MENU_ALIGN_LEFT_TOP ||
        m->flags & UI_MATRIX_MENU_ALIGN_LEFT_TOP)
    {
        menu_full_height += (m->height - (iheight + gap_y) * m->displayed_rows);
    }

    max_offset_y = (S32) ((float)m->height * (*g_gui_ssp_menu_over_limit_coefficient));

    menu_offset_y = g_gui_matrix_ssp_pen_down_y - g_gui_matrix_ssp_pen_move_y + g_gui_matrix_ssp_start_menu_y_offset;

    low_bound = -max_offset_y;
    high_bound = menu_full_height - m->height + max_offset_y;

    switch (g_gui_matrix_ssp_state)
    {
        case GUI_MATRIX_SMOOTH_SCROLLING_BY_PEN_STATE_HOLD:
            /* drag the menu */
            if (menu_offset_y < low_bound)
            {
                menu_offset_y = low_bound;
            }
            else if ((high_bound > 0) && (menu_offset_y > high_bound))
            {
                if ((*g_gui_ssp_menu_over_limit_coefficient) != 0)
                {
                    menu_offset_y = high_bound;
                }
                else
                {
                    menu_offset_y = menu_full_height - m->height;
                }
            }
            else if (high_bound <= 0)
            {
                menu_offset_y = 0;
            }
            break;

        case GUI_MATRIX_SMOOTH_SCROLLING_BY_PEN_STATE_FREE_RUN:
            /* free run */
            if (g_gui_matrix_ssp_free_run_mode == GUI_SSP_FREE_RUN_MODE_RUN)
            {   /* run mode */
                menu_offset_y = g_gui_matrix_ssp_current_menu_y_offset + g_gui_matrix_ssp_free_run_momentum;

                old_momentum = g_gui_matrix_ssp_free_run_momentum;
                g_gui_matrix_ssp_free_run_momentum = (S32)((float)g_gui_matrix_ssp_free_run_momentum * (*g_gui_ssp_free_run_scroll_coefficient));
                /* make sure converge to zero */
                if (old_momentum == g_gui_matrix_ssp_free_run_momentum)
                {
                    g_gui_matrix_ssp_free_run_momentum = 0;
                }
            }
            else
            {   /* recover mode */
                old_momentum = g_gui_matrix_ssp_free_run_momentum;
                g_gui_matrix_ssp_free_run_momentum = (S32)((float)g_gui_matrix_ssp_free_run_momentum * (*g_gui_ssp_free_run_recover_coefficient));
                
                /* make sure converge to zero */
                if (old_momentum == g_gui_matrix_ssp_free_run_momentum)
                {
                    g_gui_matrix_ssp_free_run_momentum = 0;
                }

                menu_offset_y = g_gui_matrix_ssp_free_run_final_pos + g_gui_matrix_ssp_free_run_momentum;
            }

            menu_last_y_offset = gui_matrix_ssp_get_menu_last_y_offset();
            
            /* menu bound check */
            if ((*g_gui_ssp_menu_over_limit_coefficient) != 0)
            {
                if (menu_offset_y < low_bound)
                {
                    gui_matrix_ssp_enter_free_run_recover_mode(0, menu_offset_y);
                }
                else if ((high_bound > 0) && (menu_offset_y > high_bound))
                {
                    gui_matrix_ssp_enter_free_run_recover_mode(menu_last_y_offset, menu_offset_y - menu_last_y_offset);
                }
            }
            else
            {   
                if (menu_full_height <= m->height)
                {
                    g_gui_matrix_ssp_free_run_momentum = 0;
                }
                
                if (menu_offset_y < low_bound)
                {
                    menu_offset_y = low_bound;
                    if (g_gui_matrix_ssp_free_run_momentum)
                    {
                        g_gui_matrix_ssp_free_run_momentum = -1;
                    }
                }
                else if ((high_bound > 0) && (menu_offset_y > high_bound))
                {
                    menu_offset_y = menu_full_height - m->height;
                    
                    if (g_gui_matrix_ssp_free_run_momentum)
                    {
                        g_gui_matrix_ssp_free_run_momentum = 1;
                    }
                }
                else if (high_bound <= 0)
                {
                    menu_offset_y = 0;
                }
            }

            /* running or running -> recover */
            if (g_gui_matrix_ssp_free_run_momentum)
            {
                gui_start_timer((*g_gui_ssp_frame_update_interval), gui_matrix_ssp_update_frame);
            }
            else
            {   /* g_gui_ssp_free_run_momentum == 0 */
                /* try to recover if the menu is not in the normal position */
                if ((*g_gui_ssp_menu_over_limit_coefficient) != 0 && gui_matrix_ssp_try_free_run_recover(menu_offset_y))
                {
                    return;
                }
                gui_matrix_ssp_pen_up_dummy();
                return;
            }
            break;

        default:
            break;
    }

    gui_ssp_show_matrix_menu(menu_offset_y, m->x, m->y, m->x + m->width - 1, m->y + m->height - 1);
}


/*****************************************************************************
 * FUNCTION
 *  gui_ssp_stop_matrix_menu_scrolling
 * DESCRIPTION
 *  Stops the scrolling item and the popup description.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_ssp_stop_matrix_menu_scrolling(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_fixed_icontext_menuitem_stop_scroll();
    gui_pop_up_description_stop_scroll();
}


#define COMPUTE_NEW_ROW()  do {                                            \
      if (y < yoff)                                                           \
         new_row = m->first_displayed_row;                                    \
      else                                                                    \
         new_row = m->first_displayed_row + ((y - yoff) / (iheight + yoff));  \
      if (new_row > m->first_displayed_row + m->displayed_rows - 1)           \
         new_row = m->first_displayed_row + m->displayed_rows - 1;            \
   } while (0)

#define COMPUTE_NEW_COLUMN() do {                                                \
      if (x < xoff)                                                                 \
         new_column = m->first_displayed_column;                                    \
      else                                                                          \
         new_column = m->first_displayed_column + ((x - xoff) / (iwidth + xoff));   \
      if (new_column > m->first_displayed_column + m->displayed_columns - 1)        \
         new_column = m->first_displayed_column + m->displayed_columns - 1;         \
   } while (0)


/*****************************************************************************
 * FUNCTION
 *  gui_matrix_ssp_menu_translate_pen_position
 * DESCRIPTION
 *  Translate pen position to menu item index for SSP
 * PARAMETERS
 *  m               [IN]        list menu object
 *  y               [IN]        y
 *  item_index      [OUT]       penned item index
 * RETURNS
 *  Return MMI_TRUE if x, y is within the menu; otherwise, MMI_FALSE.
 *****************************************************************************/
static MMI_BOOL gui_matrix_ssp_menu_translate_pen_position(
    fixed_matrix_menu *m, S32 x, S32 y, S32 *item_index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 iwidth, iheight, xoff, yoff, width, height;
    S32 new_row, new_column;
    MMI_BOOL result = MMI_TRUE;;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    x -= m->x;
    y -= m->y;
    iwidth = m->item_width;
    iheight = m->item_height;
    height = m->height;
    width = m->width;
    

    gui_matrix_menu_get_gap(m, &xoff, &yoff);

    if (m->flags & UI_MATRIX_MENU_SHOW_VERTICAL_SCROLLBAR)
    {
        width = m->width - m->vbar.width;
    }
    if (m->flags & UI_MATRIX_MENU_SHOW_HORIZONTAL_SCROLLBAR)
    {
        height = m->height - m->hbar.height;
    }

    /* These asumptions are mandatory */
    MMI_DBG_ASSERT(m->first_displayed_row >= 0 && m->first_displayed_column >= 0);

    if (y < 0)  /* Scroll up */
    {
        new_row = m->first_displayed_row - 1;
        COMPUTE_NEW_COLUMN();
        result = MMI_FALSE;
    }
    else if (x < 0) /* Scroll left */
    {
        new_column = m->first_displayed_column - 1;
        COMPUTE_NEW_ROW();
        result = MMI_FALSE;
    }
    else if (y >= height)   /* Scroll down */
    {
        new_row = m->first_displayed_row + m->displayed_rows;
        COMPUTE_NEW_COLUMN();
        result = MMI_FALSE;
    }
    else if (x >= width)    /* Scroll right */
    {
        new_column = m->first_displayed_column + m->displayed_columns;
        COMPUTE_NEW_ROW();
        result = MMI_FALSE;
    }
    else
    {
        COMPUTE_NEW_ROW();
        COMPUTE_NEW_COLUMN();
    }

    *item_index = new_row * m->n_columns + new_column;
    if (*item_index >= m->n_items)
    {
        result = MMI_FALSE;
    }

    return result;
}


/*****************************************************************************
 * FUNCTION
 *  gui_matrix_ssp_send_pen_event
 * DESCRIPTION
 *  Sends the pen event to the menu item.
 * PARAMETERS
 *  pen_event        [IN]   pen event
 *  point            [IN]   pen point
 * RETURNS
 *  MMI_TRUE if the pen event is handled; otherwise, MMI_FALSE.
 *****************************************************************************/
static MMI_BOOL gui_matrix_ssp_send_pen_event(
    mmi_pen_event_type_enum pen_event, 
    mmi_pen_point_struct *point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL ret = MMI_FALSE;
    fixed_matrix_menu *m = &MMI_fixed_matrix_menu;
    gui_matrix_pen_enum menu_event;
    MMI_BOOL handle_pen_event = MMI_FALSE;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_TOUCH_SCREEN__
    switch (g_gui_matrix_menu_smooth_scrolling_menu_type)
    {
        case GUI_MENU_TYPE_FIXED:
            handle_pen_event = gui_fixed_matrix_menu_translate_pen_event(
                                    m,
                                    pen_event,
                                    point->x,
                                    point->y,
                                    &menu_event);
            break;

#ifdef  __MMI_SUPPORT_DYNAMIC_MATRIX_MENU__
        case GUI_MENU_TYPE_DYNAMIC:
            handle_pen_event = gui_dynamic_matrix_menu_translate_pen_event(
                                    m,
                                    pen_event,
                                    point->x,
                                    point->y,
                                    &menu_event);
            break;
#endif  // __MMI_SUPPORT_DYNAMIC_MATRIX_MENU__

#ifdef  __MMI_SUPPORT_ASYNCDYNAMIC_MATRIX_MENU__            
        case GUI_MENU_TYPE_ASYNCDYNAMIC:
            handle_pen_event = gui_asyncdynamic_matrix_menu_translate_pen_event(
                                    m,
                                    pen_event,
                                    point->x,
                                    point->y,
                                    &menu_event);
            break;            
#endif  /* __MMI_SUPPORT_ASYNCDYNAMIC_MATRIX_MENU__ */            
            
        default:
            break;
    }

    if (handle_pen_event)
    {
        if ((m->pen_state.pen_on_horizontal_scrollbar) || m->pen_state.pen_on_vertical_scrollbar)
        {
            ret = MMI_TRUE;
        }
    }
#endif /* __MMI_TOUCH_SCREEN__ */

    return ret;            
}


/*****************************************************************************
 * FUNCTION
 *  gui_ssp_show_list_menu
 * DESCRIPTION
 *  Shows the list menu by the y offset.
 * PARAMETERS
 *  menu_offset_y       [IN]    
 *  x1                  [IN]    list menu x1
 *  y1                  [IN]    list menu y1
 *  x2                  [IN]    list menu x2
 *  y2                  [IN]    list menu y2
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_ssp_show_matrix_menu (S32 offset, S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    fixed_matrix_menu *m = &MMI_fixed_matrix_menu;
    S32 item_width, item_height, gap_x, gap_y, row, col;
    S32 first_menu_item_row, first_menu_item_col, last_menu_item_row, last_menu_item_col;
    gdi_handle menu_item_layer, act_layer;
    S32 menu_item_layer_size;
    void *item;
    S32 item_x, item_y, item_index, menu_full_height;
    S32 has_intersection = 0;

    gui_rect menu_rect, item_rect, result_rect;
    U8 *static_layer_buf_ptr = NULL;
    U8 *menu_item_layer_buffer = NULL;
#if defined(__MMI_SCREEN_SWITCH_EFFECT__)
    S32 buf_size;
#endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_gui_matrix_menu_smooth_scrolling_menu_type == GUI_MENU_TYPE_INVALID)
    {
        return;
    }

    if (g_gui_ssp_static_layer)
    {
        gdi_layer_push_and_set_active(g_gui_ssp_static_layer);
        gdi_layer_get_buffer_ptr(&static_layer_buf_ptr);
        gdi_layer_pop_and_restore_active();
    }


    item_width = m->item_width;
    item_height = m->item_height;

    gui_push_clip();
    gui_set_clip(x1, y1, x2, y2);

    /* clear the menu rect */
#ifdef __MMI_FTE_SUPPORT__
    if (wgui_is_wallpaper_on_bottom() == MMI_FALSE)
    {
        if (g_gui_list_hide_menu)
        {
            g_gui_list_hide_menu(x1, y1, x2, y2);
        }
        else
        {
            gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_TRANSPARENT);
        }
    }
    else
    {
        gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_TRANSPARENT);
    }
#else
    gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_TRANSPARENT);
#endif  /* __MMI_FTE_SUPPORT__ */

    /* calculate the first, last display row and col */
    gui_matrix_menu_get_gap(m, &gap_x, &gap_y);
    menu_full_height = (item_height + gap_y) * m->n_rows + gap_y;
    if (m->flags & UI_DYAMIC_MATRIX_MENU_ALIGN_LEFT_TOP ||
        m->flags & UI_MATRIX_MENU_ALIGN_LEFT_TOP) 
    {
    menu_full_height += (m->height - (item_height + gap_y) * m->displayed_rows);
    }

    {
        if (g_gui_ssp_static_layer != GDI_NULL_HANDLE)
        {
            menu_item_layer = g_gui_ssp_static_layer;
        }
        else
        {
            /* in vertical direction */
            menu_item_layer_size = (gap_y + item_height) * UI_DEVICE_WIDTH * GUI_EFFECT_LAYER_BYTE_PER_PIXEL;

            if (menu_item_layer_size <= GUI_EFFECT_LAYER_SIZE)
            {
#if defined(__MMI_SCREEN_SWITCH_EFFECT__)&&!defined(__MMI_REDUCED_UI_BUFFER__)
                /* use buffer b */
                gui_screen_switch_effect_get_frame_buffer_info(1, &g_gui_effect_layer_buffer, &buf_size);
#endif
                gdi_layer_create_cf_using_outside_memory(
                    GUI_SCREEN_SWITCH_EFFECT_LAYER_COLOR_FORMAT,
                    0,
                    0,
                    UI_device_width,
                    item_height,
                    &menu_item_layer,
                    (PU8)g_gui_effect_layer_buffer,
                     GUI_EFFECT_LAYER_SIZE);
            }
            else
            {
                //MMI_ASSERT(menu_item_layer_size <= handwriting_stroke_layer_mem);

                menu_item_layer_buffer = (U8*) mmi_frm_scrmem_alloc_framebuffer(menu_item_layer_size);
                gdi_layer_create_cf_using_outside_memory(
                    GUI_SCREEN_SWITCH_EFFECT_LAYER_COLOR_FORMAT,
                    0,
                    0,
                    UI_device_width,
                    item_height,
                    &menu_item_layer,
                    (PU8)menu_item_layer_buffer,
                    menu_item_layer_size);
            }
        }
        
        first_menu_item_row = offset / (gap_y + item_height);
        first_menu_item_col = g_gui_matrix_ssp_old_first_col;
        
        m->first_displayed_row = first_menu_item_row;
        last_menu_item_row = first_menu_item_row + m->displayed_rows;
        last_menu_item_col = first_menu_item_col + m->displayed_columns - 1;

        if (first_menu_item_row < 0)
        {
            first_menu_item_row = 0;
        }
        if (last_menu_item_row >= m->n_rows)
        {
            last_menu_item_row = m->n_rows - 1;
        }
        
        gdi_layer_lock_frame_buffer();

        /* remove the highlight if it is not visible. important for dynamic and asyncdynamic menus */
        if (((m->highlighted_row < first_menu_item_row) || (m->highlighted_row > last_menu_item_row)) && 
            gui_slide_highlight_removed == MMI_FALSE)
        {
            item = gui_matrix_menu_smooth_scrolling_get_item(m->highlighted_item);
            if (item)
                m->item_remove_highlight_function(item, m->common_item_data);
        }
        
        if (offset > 0)
        {
            item_y = y1 - offset % (item_height + gap_y) + gap_y;
        }
        else
        {
            item_y = y1 - offset + gap_y;
        }
        
        for (row = first_menu_item_row; row <= last_menu_item_row; row++)
        {
            item_x = x1 + gap_x;
            GUI_RECT(menu_rect, m->x, m->y, m->width, m->height);
            //GUI_RECT(item_rect, m->x, item_y - gap_y, m->width, item_height + gap_y);
            GUI_RECT(item_rect, m->x, item_y, m->width, item_height);
            has_intersection = 0;

            gdi_layer_push_and_set_active(menu_item_layer);
            gdi_layer_reset_clip();
            gdi_layer_clear(GDI_COLOR_TRANSPARENT);
            gdi_layer_pop_and_restore_active();
            
            for (col = first_menu_item_col; col <= last_menu_item_col; col++)
            {
                item_index = row * m->n_columns + col;
                if (item_index > m->n_items - 1)
                {
                    break;
                }
                if ((row == first_menu_item_row) || (row == last_menu_item_row))
                {   
                    has_intersection = gui_rect_get_intersection(&menu_rect, &item_rect, &result_rect);
                    /* draw on seperator layer */
                    if (has_intersection)
                    {
                        /* start draw menu item on another layer */
                        gdi_layer_push_and_set_active(menu_item_layer);
                        gdi_layer_reset_clip();

                        //gdi_layer_set_position(0, item_y - gap_y);
                        if (g_gui_ssp_static_layer == GDI_NULL_HANDLE)
                        {
                            gdi_layer_set_position(0, item_y);
                        }
                        gdi_layer_set_source_key(MMI_TRUE, GDI_COLOR_TRANSPARENT);
                        
                        if (item_index == m->highlighted_item && gui_slide_highlight_removed == MMI_FALSE)
                        {
                            item = gui_matrix_menu_smooth_scrolling_get_item(m->highlighted_item);
                            if (item)
                            {
                                m->item_remove_highlight_function(item, m->common_item_data);        
                                m->item_highlight_function(item, m->common_item_data);
                            }
                            gui_slide_highlight_removed = MMI_TRUE;
                        }

                        //gui_matrix_menu_smooth_scrolling_show_item(item_index, item_x, gap_y); 
                        if (g_gui_ssp_static_layer == GDI_NULL_HANDLE)
                        {
                            gui_matrix_menu_smooth_scrolling_show_item(item_index, item_x, 0); 
                        }
                        else
                        {
                            gui_matrix_menu_smooth_scrolling_show_item(item_index, item_x, item_y);
                        }
                        
                        if (gui_asyncdynamic_list_error && 
                            ((g_gui_matrix_menu_smooth_scrolling_menu_type == GUI_MENU_TYPE_ASYNCDYNAMIC) ||
                             (g_gui_matrix_menu_smooth_scrolling_old_menu_type == GUI_MENU_TYPE_ASYNCDYNAMIC)))
                        {
                            gdi_layer_pop_and_restore_active();
                            if (g_gui_ssp_static_layer == GDI_NULL_HANDLE)
                            {
                                gdi_layer_free(menu_item_layer);
                            }
                            gui_pop_clip();
                            gdi_layer_unlock_frame_buffer();
                            gdi_layer_blt_previous(x1, y1, x2, y2);

                            if (menu_item_layer_buffer)
                            {
                                mmi_frm_scrmem_free(menu_item_layer_buffer);
							}
                            return;
                        }

                        /* disable the source key to make flatten successful */
                        gdi_layer_set_source_key(FALSE, GDI_COLOR_TRANSPARENT);                

                        gdi_layer_pop_and_restore_active();
                    }
                }
                else
                {
                    /* draw on the base layer */
                    if (item_index == m->highlighted_item && gui_slide_highlight_removed == MMI_FALSE)
                    {
                        item = gui_matrix_menu_smooth_scrolling_get_item(m->highlighted_item);
                        if (item)
                        {
                            m->item_remove_highlight_function(item, m->common_item_data);        
                            m->item_highlight_function(item, m->common_item_data);
                        }
                        gui_slide_highlight_removed = MMI_TRUE;
                    }
                    gui_matrix_menu_smooth_scrolling_show_item(item_index, item_x, item_y);
                    
                    if (gui_asyncdynamic_list_error && 
                        ((g_gui_matrix_menu_smooth_scrolling_menu_type == GUI_MENU_TYPE_ASYNCDYNAMIC) ||
                         (g_gui_matrix_menu_smooth_scrolling_old_menu_type == GUI_MENU_TYPE_ASYNCDYNAMIC)))
                    {
                        gui_pop_clip();
                        if (g_gui_ssp_static_layer == GDI_NULL_HANDLE)
                        {
                            gdi_layer_free(menu_item_layer);
                        }
                        gdi_layer_unlock_frame_buffer();
                        gdi_layer_blt_previous(x1, y1, x2, y2);

                        if (menu_item_layer_buffer)
                        {
                            mmi_frm_scrmem_free(menu_item_layer_buffer);
                        }
                        return;
                    }
                }
                item_x += gap_x + item_width;                
            }           

            if (has_intersection)
            {
                U8 *buf_ptr = NULL;
                
                /* flatten to main base layer */
                gdi_layer_push_clip();
                gdi_layer_set_clip(result_rect.x, result_rect.y, result_rect.x + result_rect.width - 1, result_rect.y + result_rect.height - 1);

                gdi_layer_get_buffer_ptr(&buf_ptr);
#ifdef __MMI_FTE_SUPPORT__ 
                if (wgui_is_wallpaper_on_bottom() == MMI_FALSE)
                {
                    gdi_layer_push_and_set_active(menu_item_layer);
                    gdi_layer_set_source_key(TRUE, GDI_COLOR_TRANSPARENT);    
                    gdi_layer_pop_and_restore_active();
                    if (g_gui_list_hide_menu)
                    {
                        g_gui_list_hide_menu(result_rect.x, result_rect.y, result_rect.x + result_rect.width - 1, result_rect.y + result_rect.height - 1);
                    }

                    if (g_gui_ssp_static_layer)
                    {
                        gd_bitblt[GUI_SCREEN_SWITCH_EFFECT_LAYER_COLOR_FORMAT](
                            buf_ptr,
                            UI_DEVICE_WIDTH,
                            UI_DEVICE_HEIGHT,
                            result_rect.x,
                            result_rect.y,
                            result_rect.x + result_rect.width - 1,
                            result_rect.y + result_rect.height - 1,
                            static_layer_buf_ptr,
                            UI_DEVICE_WIDTH,
                            UI_DEVICE_HEIGHT,
                            result_rect.x,
                            result_rect.y,
                            result_rect.x + result_rect.width - 1,
                            result_rect.y + result_rect.height - 1,
                            result_rect.x,
                            result_rect.y,
                            result_rect.x + result_rect.width - 1,
                            result_rect.y + result_rect.height - 1,
                            GDI_COLOR_TRANSPARENT,
                            0x01ffffff);
                    }
                    else
                    {
                        gdi_layer_flatten_with_clipping((gdi_handle) gdi_act_layer, menu_item_layer, 0, 0);
                    }
                }
                else
                {
                    if (g_gui_ssp_static_layer)
                    {
                        gd_bitblt[GUI_SCREEN_SWITCH_EFFECT_LAYER_COLOR_FORMAT](
                            buf_ptr,
                            UI_DEVICE_WIDTH,
                            UI_DEVICE_HEIGHT,
                            result_rect.x,
                            result_rect.y,
                            result_rect.x + result_rect.width - 1,
                            result_rect.y + result_rect.height - 1,
                            static_layer_buf_ptr,
                            UI_DEVICE_WIDTH,
                            UI_DEVICE_HEIGHT,
                            result_rect.x,
                            result_rect.y,
                            result_rect.x + result_rect.width - 1,
                            result_rect.y + result_rect.height - 1,
                            result_rect.x,
                            result_rect.y,
                            result_rect.x + result_rect.width - 1,
                            result_rect.y + result_rect.height - 1,
                            GDI_COLOR_TRANSPARENT,
                            0x01ffffff);
                    }
                    else
                    {
                        gdi_layer_flatten_with_clipping(menu_item_layer, 0, 0, 0);
                    }
                }
#else   /* __MMI_FTE_SUPPORT__ */
                if (g_gui_ssp_static_layer)
                {
                    gd_bitblt[GUI_SCREEN_SWITCH_EFFECT_LAYER_COLOR_FORMAT](
                        buf_ptr,
                        UI_DEVICE_WIDTH,
                        UI_DEVICE_HEIGHT,
                        result_rect.x,
                        result_rect.y,
                        result_rect.x + result_rect.width - 1,
                        result_rect.y + result_rect.height - 1,
                        static_layer_buf_ptr,
                        UI_DEVICE_WIDTH,
                        UI_DEVICE_HEIGHT,
                        result_rect.x,
                        result_rect.y,
                        result_rect.x + result_rect.width - 1,
                        result_rect.y + result_rect.height - 1,
                        result_rect.x,
                        result_rect.y,
                        result_rect.x + result_rect.width - 1,
                        result_rect.y + result_rect.height - 1,
                        GDI_COLOR_TRANSPARENT,
                        0x01ffffff);
                }
                else
                {
                    gdi_layer_flatten_with_clipping(menu_item_layer, 0, 0, 0);
                }
#endif  /* __MMI_FTE_SUPPORT__ */
                gdi_layer_pop_clip();
            }
            item_y += gap_y + item_height;
        }
    }

    if (g_gui_ssp_static_layer)
    {
        gdi_layer_push_and_set_active(g_gui_ssp_static_layer);
        gdi_layer_set_source_key(MMI_TRUE, GDI_COLOR_TRANSPARENT);
        gdi_layer_clear(GDI_COLOR_TRANSPARENT);
        gdi_layer_pop_and_restore_active();
    }

    /* update scrollbar */
    if (m->flags & UI_MATRIX_MENU_SHOW_VERTICAL_SCROLLBAR)
    {
        /* vertical scrollbar */
        gui_push_clip();
        if (mmi_fe_get_r2l_state())
        {
            gdi_layer_set_clip(
                m->x, 
                m->y, 
                m->x + m->vbar.width - 1, 
                m->y + m->height - 1);
        }
        else
        {
            gdi_layer_set_clip(
                m->x + m->width - 1 - m->vbar.width, 
                m->y, 
                m->x + m->width - 1, 
                m->y + m->height - 1);
        }

        gui_resize_vertical_scrollbar(&m->vbar, m->vbar.width, m->height);

        /* menu height might be larger than normal one. Prevent the scrollbar mismatch when going back to the normal menu */
        gui_set_vertical_scrollbar_range(&m->vbar, menu_full_height);//m->n_rows * (item_height + gap_y) + gap_y);

        if ((*g_gui_ssp_menu_over_limit_coefficient) != 0)
        {
            S32 max_offset_y = gui_matrix_ssp_get_menu_last_y_offset();
            
            if (offset < 0)
            {
                gui_set_vertical_scrollbar_scale(&m->vbar, m->height + offset);
            }
            else if (offset > max_offset_y)
            {
                gui_set_vertical_scrollbar_scale(&m->vbar, m->height + max_offset_y - offset);
            }
            else
            {
                gui_set_vertical_scrollbar_scale(&m->vbar, m->height);
            }
        }
        else
        {
            gui_set_vertical_scrollbar_scale(&m->vbar, m->height);
        }
            
        gui_set_vertical_scrollbar_value(&m->vbar, offset);

        /* Scrollbar style 6 in the single page menu hides the indicator button. */
        if (gui_vertical_scrollbar_auto_hide_scroll_button(&m->vbar) && 
            m->n_rows <= m->displayed_rows)
        {
            gui_set_vertical_scrollbar_range(&m->vbar, m->n_rows);
            gui_set_vertical_scrollbar_scale(&m->vbar, m->n_rows);
            gui_set_vertical_scrollbar_value(&m->vbar, 0);
        }

        gdi_layer_get_active(&act_layer);
#ifdef __MMI_FTE_SUPPORT__
        if (dm_get_scr_bg_layer() != GDI_ERROR_HANDLE)
        {
            if (g_gui_ssp_static_layer)
            {
                U8 *act_buf_ptr, *bg_buf_ptr;
                S32 clip_x1, clip_x2, clip_y1, clip_y2;
                S32 buf_offset, copy_buf_size;
	
                clip_x1 = m->x;
                clip_y1 = m->y;
                clip_x2 = m->x + m->width - 1;
                clip_y2 = m->y + m->height - 1;
                
                buf_offset = UI_DEVICE_WIDTH * m->y * GUI_SCREEN_SWITCH_EFFECT_LAYER_COLOR_FORMAT;
                copy_buf_size = UI_DEVICE_WIDTH * m->height * GUI_SCREEN_SWITCH_EFFECT_LAYER_COLOR_FORMAT;
                
                gdi_layer_get_buffer_ptr(&act_buf_ptr);
                gdi_layer_push_and_set_active(dm_get_scr_bg_layer());
                gdi_layer_get_buffer_ptr(&bg_buf_ptr);
                gdi_layer_pop_and_restore_active();
	                
                memcpy(static_layer_buf_ptr + buf_offset, bg_buf_ptr + buf_offset, copy_buf_size);
	
                /* use static layer buffer as temp buffer to store the flatten result layer buffer */
                gd_bitblt[GUI_SCREEN_SWITCH_EFFECT_LAYER_COLOR_FORMAT](
                    static_layer_buf_ptr,
                    UI_DEVICE_WIDTH,
                    UI_DEVICE_HEIGHT,
                    clip_x1,
                    clip_y1,
                    clip_x2,
                    clip_y2,
                    act_buf_ptr,
                    UI_DEVICE_WIDTH,
                    UI_DEVICE_HEIGHT,
                    clip_x1, 
                    clip_y1, 
                    clip_x2, 
                    clip_y2,
                    clip_x1,
                    clip_y1,
                    clip_x2,
                    clip_y2,
                    GDI_COLOR_TRANSPARENT,
                    0x01ffffff);
                memcpy(act_buf_ptr + buf_offset, static_layer_buf_ptr + buf_offset, copy_buf_size);
	
                /* clear the list area in util layer to make sure display normal */
                gdi_layer_push_and_set_active(g_gui_ssp_static_layer);
                gdi_draw_solid_rect(m->x, m->y, m->x + m->width, m->y + m->height - 1, GDI_COLOR_TRANSPARENT);
                gdi_layer_pop_and_restore_active();
            }
            else
            {
                gdi_layer_flatten_with_clipping(dm_get_scr_bg_layer(), act_layer, 0, 0);
            }
        }
#endif    
        //gui_enable_scrollbar_redraw_clip(MMI_FALSE);
        gui_redraw_vertical_scrollbar(&m->vbar, MMI_FALSE);
        //gui_enable_scrollbar_redraw_clip(MMI_TRUE);
        gui_pop_clip();
    }

    
    if (m->flags & UI_MATRIX_MENU_SHOW_HORIZONTAL_SCROLLBAR)
    {
        /* vertical scrollbar */
        gui_push_clip();
        gdi_layer_set_clip(
            m->x, 
            m->y, 
            m->x + m->width - 1, 
            m->y + m->hbar.height - 1);

        /* menu height might be larger than normal one. Prevent the scrollbar mismatch when going back to the normal menu */
        gui_set_horizontal_scrollbar_range(&m->hbar, m->n_columns);
        gui_set_horizontal_scrollbar_scale(&m->hbar, m->displayed_columns);
        gui_set_horizontal_scrollbar_value(&m->hbar, m->first_displayed_column);

        /* Scrollbar style 6 in the single page menu hides the indicator button. */
        if (gui_horizontal_scrollbar_auto_hide_scroll_button(&m->hbar) && 
            m->n_columns <= m->displayed_columns)
        {
            gui_set_horizontal_scrollbar_range(&m->hbar, m->n_columns);
            gui_set_horizontal_scrollbar_scale(&m->hbar, m->n_columns);
            gui_set_horizontal_scrollbar_value(&m->hbar, 0);
        }

        gdi_layer_get_active(&act_layer);
#ifdef __MMI_FTE_SUPPORT__
        if (dm_get_scr_bg_layer() != GDI_ERROR_HANDLE)
        {
            if (g_gui_ssp_static_layer)
            {
                U8 *act_buf_ptr, *bg_buf_ptr;
                S32 clip_x1, clip_x2, clip_y1, clip_y2;
                S32 buf_offset, copy_buf_size;
	
                clip_x1 = m->x;
                clip_y1 = m->y;
                clip_x2 = m->x + m->width - 1;
                clip_y2 = m->y + m->height - 1;
                
                buf_offset = UI_DEVICE_WIDTH * m->y * GUI_SCREEN_SWITCH_EFFECT_LAYER_COLOR_FORMAT;
                copy_buf_size = UI_DEVICE_WIDTH * m->height * GUI_SCREEN_SWITCH_EFFECT_LAYER_COLOR_FORMAT;
                
                gdi_layer_get_buffer_ptr(&act_buf_ptr);
                gdi_layer_push_and_set_active(dm_get_scr_bg_layer());
                gdi_layer_get_buffer_ptr(&bg_buf_ptr);
                gdi_layer_pop_and_restore_active();
	                
                memcpy(static_layer_buf_ptr + buf_offset, bg_buf_ptr + buf_offset, copy_buf_size);
	
                /* use static layer buffer as temp buffer to store the flatten result layer buffer */
                gd_bitblt[GUI_SCREEN_SWITCH_EFFECT_LAYER_COLOR_FORMAT](
                    static_layer_buf_ptr,
                    UI_DEVICE_WIDTH,
                    UI_DEVICE_HEIGHT,
                    clip_x1,
                    clip_y1,
                    clip_x2,
                    clip_y2,
                    act_buf_ptr,
                    UI_DEVICE_WIDTH,
                    UI_DEVICE_HEIGHT,
                    clip_x1, 
                    clip_y1, 
                    clip_x2, 
                    clip_y2,
                    clip_x1,
                    clip_y1,
                    clip_x2,
                    clip_y2,
                    GDI_COLOR_TRANSPARENT,
                    0x01ffffff);
                memcpy(act_buf_ptr + buf_offset, static_layer_buf_ptr + buf_offset, copy_buf_size);
	
                /* clear the list area in util layer to make sure display normal */
                gdi_layer_push_and_set_active(g_gui_ssp_static_layer);
                gdi_draw_solid_rect(m->x, m->y, m->x + m->width, m->y + m->height - 1, GDI_COLOR_TRANSPARENT);
                gdi_layer_pop_and_restore_active();
            }
            else
            {
                gdi_layer_flatten_with_clipping(dm_get_scr_bg_layer(), act_layer, 0, 0);
            }
        }
#endif    
        gui_redraw_horizontal_scrollbar(&m->hbar, MMI_FALSE);
        gui_pop_clip();
    }

    gdi_layer_unlock_frame_buffer();
    gui_pop_clip();
    gdi_layer_blt_previous(x1, y1, x2, y2);
    if (g_gui_ssp_static_layer == GDI_NULL_HANDLE)
    {
        gdi_layer_free(menu_item_layer);
        if (menu_item_layer_buffer)
        {
            mmi_frm_scrmem_free(menu_item_layer_buffer);
        }
    }

    g_gui_matrix_ssp_old_first_row = first_menu_item_row;
    g_gui_matrix_ssp_old_last_row = last_menu_item_row;
    g_gui_matrix_ssp_old_first_col = first_menu_item_col;
    g_gui_matrix_ssp_current_menu_y_offset = offset;
}


/*****************************************************************************
 * FUNCTION
 *  gui_matrix_menu_smooth_scrolling_get_item
 * DESCRIPTION
 *  Gets the menu item object according to the current menu type.
 * PARAMETERS
 *  item_index       [IN]   menu item index
 * RETURNS
 *  Menu item object
 *****************************************************************************/
static void *gui_matrix_menu_smooth_scrolling_get_item(S32 item_index)
{    
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 first_item, item_num;
    S32 flags = 0;
    MMI_BOOL in_buffer = MMI_FALSE;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    switch (g_gui_matrix_menu_smooth_scrolling_menu_type)
    {
        case GUI_MENU_TYPE_FIXED:
            return MMI_fixed_matrix_menu.items[item_index];
            
        case GUI_MENU_TYPE_DYNAMIC:
            if (MMI_fixed_list_menu.flags & UI_LIST_MENU_DISABLE_CACHE_DYNAMIC_DATA)
            {   /* special case for category 185 without caching */
                /* 
                 * leave one slot before the first displayed item for smooth scrolling up 
                 * Note that MMI_MAX_MENUITEMS_IN_CONTENT already keeps one additional slot.
                 */
                first_item = item_index;
                item_num = 1;

                /* 
                 * must call flush_dynamic_item_buffer_before_load_chunk() if caching is disabled;
                 * otherwise, load_chunk_dynamic_item_buffer() will assert.
                 */
                if (in_dynamic_item_buffer(item_index))
                {
                    flags = ((fixed_icontext_menuitem_type*)get_dynamic_item_from_buffer(item_index))->flags;
                    in_buffer = MMI_TRUE;
                }
                flush_dynamic_item_buffer_before_load_chunk();                
                load_chunk_dynamic_item_buffer(first_item, item_num);
                
                if (in_buffer == MMI_TRUE)
                {
                    ((fixed_icontext_menuitem_type*)get_dynamic_item_from_buffer(item_index))->flags = flags;
                }

                /* make sure the item is loaded */
                MMI_ASSERT((item_index >= first_item) && (item_index <= first_item + item_num - 1));
            }
            else
            {   /* normal case with caching */
                /* make sure the item is in buffer. If not, load it. */         
                if (!in_dynamic_item_buffer(item_index))
                {
                    load_chunk_dynamic_item_buffer(item_index, 1);
                    if (item_index == MMI_fixed_matrix_menu.highlighted_item)
                    {
                        ((fixed_icontext_menuitem_type*)get_dynamic_item_from_buffer(item_index))->flags
                            |= UI_MENUITEM_STATE_FOCUSSED;
                    }
                }                    
            }
            
            return get_dynamic_item_from_buffer(item_index);        
            
        case GUI_MENU_TYPE_ASYNCDYNAMIC:
            /* make sure the item is in buffer. If not, load it. */
            if (!in_asyncdynamic_item_buffer(item_index))
            {
                /* possible asyncdynamic load item failures */
                if (!load_chunk_asyncdynamic_item_buffer(item_index, 1))
                {
                    gui_asyncdynamic_list_error = 1;
                    
                    return NULL;
                }
                if (item_index == MMI_fixed_matrix_menu.highlighted_item)
                {
                    ((fixed_icontext_list_menuitem_type*)get_asyncdynamic_item_from_buffer(item_index))->flags
                        |= UI_MENUITEM_STATE_FOCUSSED;
                }
            }
            
            return get_asyncdynamic_item_from_buffer(item_index);
            
        default:
            break;
    }   

    return NULL;
}


/*****************************************************************************
 * FUNCTION
 *  gui_matrix_menu_smooth_scrolling_show_item
 * DESCRIPTION
 *  Shows the specified menu item.
 * PARAMETERS
 *  item_index       [IN]   menu item index to be displayed
 *  x                [IN]   x
 *  y                [IN]   y
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_matrix_menu_smooth_scrolling_show_item(S32 item_index, S32 x, S32 y)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    void * item;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* save current_displayed_item */
    MMI_fixed_matrix_menu.current_display_item = item_index;

    /* display the menu item */
    item = gui_matrix_menu_smooth_scrolling_get_item(item_index);
    if (item)
    {   
        /* lock frame buffer because there might be item post display function calling blt */
        gdi_layer_lock_frame_buffer();

        MMI_fixed_matrix_menu.item_display_function(
            item,
            MMI_fixed_matrix_menu.common_item_data,
            x,
            y);
        gdi_layer_unlock_frame_buffer();

        /* restore current_displayed_item */
    }
    else
    {
        gui_cancel_timer(gui_matrix_ssp_update_frame);        
    }
}


/*****************************************************************************
 * FUNCTION
 *  gui_ssp_pen_pre_hdlr
 * DESCRIPTION
 *  Pre-pen handler of Smooth Scrolling by Pen.
 * PARAMETERS
 *  dm_control_id       [IN]    DM control ID
 *  point               [IN]    pen point
 *  pen_event           [IN]    pen event
 * RETURNS
 *  MMI_TRUE if this pen event is handled; otherwise, MMI_FALSE.
 *****************************************************************************/
static MMI_BOOL gui_matrix_ssp_pen_pre_hdlr(U16 dm_control_id, mmi_pen_point_struct point, mmi_pen_event_type_enum pen_event)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if ((!g_gui_matrix_menu_support_ssp)) //||
        //(MMI_fixed_matrix_menu.flags & UI_MATRIX_MENU_FOR_MAINMENU))
    {
        return MMI_FALSE;
    }
    
    switch (dm_control_id)
    {
        case DM_CATEGORY_CONTROLLED_AREA:
        case DM_MATRIX_MENU1:
        case DM_DYNAMIC_MATRIX1:
        case DM_ASYNCDYNAMIC_MATRIX1:
            switch (pen_event)
            {
                case MMI_PEN_EVENT_DOWN:
                    return gui_matrix_ssp_pen_down_hdlr(point);

                case MMI_PEN_EVENT_UP:
                    return gui_matrix_ssp_pen_up_hdlr(point);

                case MMI_PEN_EVENT_MOVE:
                    return gui_matrix_ssp_pen_move_hdlr(point);

                case MMI_PEN_EVENT_ABORT:
                    return gui_matrix_ssp_pen_abort_hdlr(point);
                    
                case MMI_PEN_EVENT_REPEAT:
                    return MMI_FALSE;

                default:
                    /* ignored events */
                    break;
            }

            return MMI_TRUE;

        default:
            return MMI_FALSE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  gui_matrix_menu_smooth_scrolling_get_menu_type
 * DESCRIPTION
 *  Gets the current matrix menu type.
 * PARAMETERS
 *  void
 * RETURNS
 *  Current matrix menu type 
 *****************************************************************************/
static gui_menu_type_enum gui_matrix_menu_smooth_scrolling_get_menu_type(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    FuncPtr             key_down_hdlr;
    gui_menu_type_enum  menu_type;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    key_down_hdlr = GetKeyHandler(KEY_DOWN_ARROW, KEY_EVENT_DOWN);

    if (key_down_hdlr == fixed_matrix_goto_next_row)
    {
        menu_type = GUI_MENU_TYPE_FIXED;
    }
#ifdef  __MMI_SUPPORT_DYNAMIC_MATRIX_MENU__
    else if (key_down_hdlr == dynamic_matrix_goto_next_row)
    {
        menu_type = GUI_MENU_TYPE_DYNAMIC;
    }
#endif  // __MMI_SUPPORT_DYNAMIC_MATRIX_MENU__
#ifdef  __MMI_SUPPORT_ASYNCDYNAMIC_MATRIX_MENU__    
    else if (key_down_hdlr == asyncdynamic_matrix_goto_next_row)
    {
        menu_type = GUI_MENU_TYPE_ASYNCDYNAMIC;   
    }
#endif  /* __MMI_SUPPORT_ASYNCDYNAMIC_MATRIX_MENU__ */    
    else
    {
        menu_type = GUI_MENU_TYPE_INVALID;
    }

    return menu_type;
}


/*****************************************************************************
 * FUNCTION
 *  gui_matrix_menu_smooth_scrolling_key_proc
 * DESCRIPTION
 *  key event proc for the matrix menu smooth scrolling.
 * PARAMETERS
 *  evt        : [IN]     key event
 * RETURNS
 *  MMI_RET_KEY_HANDLED: stop key event routing
 *  MMI_RET_OK: continue the key event routing 
 *****************************************************************************/
static mmi_ret  gui_matrix_menu_smooth_scrolling_key_proc(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    static MMI_BOOL key_down_removed = MMI_FALSE;
    mmi_frm_key_evt_struct *key_evt = (mmi_frm_key_evt_struct *)evt;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (key_evt->evt_id == EVT_ID_PRE_KEY)
    {
        mmi_frm_set_key_info(key_evt->key_code, key_evt->key_type);
    #ifdef GUI_MATRIX_MENU_SMOOTH_SCROLLING_BY_PEN
        if (gui_screen_matrix_smooth_scrolling_in_freerun() && (key_evt->key_code != KEY_SEND) && (key_evt->key_code != KEY_END))
        {
            gui_matrix_ssp_pen_up_dummy();
            if (key_evt->key_type == KEY_EVENT_DOWN)
            {
                key_down_removed = MMI_TRUE;
            }
            return MMI_RET_KEY_HANDLED;
        }
        if (key_down_removed == MMI_TRUE)
        {
            if (key_evt->key_type == KEY_EVENT_UP)
            {
                key_down_removed = MMI_FALSE;
            }
            return MMI_RET_KEY_HANDLED;
        }
        gui_matrix_ssp_pen_up_dummy();
        if (key_evt->key_code == KEY_LSK || key_evt->key_code == KEY_RSK)
        {   
            if (g_gui_matrix_menu_smooth_scrolling_menu_type == GUI_MENU_TYPE_DYNAMIC)
            {
                if (MMI_fixed_matrix_menu.n_items != 0 && !in_dynamic_item_buffer(MMI_fixed_matrix_menu.highlighted_item))
                    return MMI_RET_KEY_HANDLED;
            }
            else if (g_gui_matrix_menu_smooth_scrolling_menu_type == GUI_MENU_TYPE_ASYNCDYNAMIC)
            {
                if (MMI_fixed_matrix_menu.n_items != 0 && !in_asyncdynamic_item_buffer(MMI_fixed_matrix_menu.highlighted_item))
                    return MMI_RET_KEY_HANDLED;
            }
        }
    #endif
    }
    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  gui_matrix_ssp_reset_state
 * DESCRIPTION
 *  reset matrix ssp state
 * PARAMETERS
 *  None
 * RETURNS
 *  None 
 *****************************************************************************/
void gui_matrix_ssp_reset_state(void)
{
    g_gui_matrix_ssp_state = GUI_MATRIX_SMOOTH_SCROLLING_BY_PEN_STATE_UNFOCUS;
}


MMI_BOOL gui_matrix_screen_smooth_scrolling_moved_by_pen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef GUI_MATRIX_MENU_SMOOTH_SCROLLING_BY_PEN
    if ((g_gui_matrix_ssp_state == GUI_MATRIX_SMOOTH_SCROLLING_BY_PEN_STATE_HOLD
        || g_gui_matrix_ssp_state == GUI_MATRIX_SMOOTH_SCROLLING_BY_PEN_STATE_FREE_RUN)
        && (g_gui_matrix_menu_smooth_scrolling_menu_type == GUI_MENU_TYPE_ASYNCDYNAMIC ||
        g_gui_matrix_menu_smooth_scrolling_menu_type == GUI_MENU_TYPE_DYNAMIC ||
        g_gui_matrix_menu_smooth_scrolling_menu_type == GUI_MENU_TYPE_FIXED 
        ))
        return MMI_TRUE;
    else
        return MMI_FALSE;
#else
    return MMI_FALSE;
#endif
}

#endif  /* GUI_MATRIX_MENU_SMOOTH_SCROLLING_BY_PEN */


/*****************************************************************************
 * FUNCTION
 *  gui_ssp_set_static_layer
 * DESCRIPTION
 *  set the static layer for list effect.
 * PARAMETERS
 *  layer: the layer handle
 * RETURNS
 *  void 
 *****************************************************************************/
void gui_ssp_set_static_layer(gdi_handle layer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_KEY) || defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN)
    g_gui_ssp_static_layer = layer;
#ifdef  __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
    gui_block_list_effect();
#endif  // __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
#endif
}

#ifndef __MMI_UI_MENU_SLIM__
/*****************************************************************************
 * FUNCTION
 *  gui_ssp_reset_static_layer
 * DESCRIPTION
 *  reset the static layer for list effect.
 * PARAMETERS
 *  layer: the layer handle
 * RETURNS
 *  void 
 *****************************************************************************/
void gui_ssp_reset_static_layer(void)
{
#if defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_KEY) || defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN)
    g_gui_ssp_static_layer = GDI_NULL_HANDLE;
#ifdef  __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
    gui_unblock_list_effect();
#endif  // __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
#endif
}
#endif

#if defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN) || defined(GUI_MATRIX_MENU_SMOOTH_SCROLLING_BY_PEN)
/*****************************************************************************
 * FUNCTION
 *  gui_list_ssp_init_parameter
 * DESCRIPTION
 *  init the parameter of list ssp
 * PARAMETERS
 *  None
 * RETURNS
 *  None 
 *****************************************************************************/
void gui_list_ssp_init_parameter(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    *g_gui_menu_ssp_pos_delta = GUI_MENU_SSP_POS_DELTA;
    *g_gui_ssp_frame_update_interval= GUI_SSP_FRAME_UPDATE_INTERVAL;
    *g_gui_ssp_free_run_threshold_time = GUI_SSP_FREE_RUN_THRESHOLD_TIME;
    *g_gui_ssp_free_run_movement_y_thresold = GUI_SSP_FREE_RUN_MOVEMENT_Y_THRESOLD;
    *g_gui_ssp_free_run_scroll_coefficient = GUI_SSP_FREE_RUN_SCROLL_COEFFICIENT;
    *g_gui_ssp_free_run_recover_coefficient = GUI_SSP_FREE_RUN_RECOVER_COEFFICIENT;
    *g_gui_ssp_free_run_sensitivity = GUI_SSP_FREE_RUN_SENSITIVITY;
    *g_gui_ssp_focus_to_hold_state_y_threshold = GUI_SSP_FOCUS_TO_HOLD_STATE_Y_THRESHOLD;
    *g_gui_ssp_menu_over_limit_coefficient = GUI_SSP_MENU_OVER_LIMIT_COEFFICIENT;
}


void gui_list_ssp_get_parameter(gui_list_ssp_parameter_struct *a)
{    
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    memcpy(a, &g_gui_list_ssp_parameter, sizeof(gui_list_ssp_parameter_struct));
}



/*****************************************************************************
 * FUNCTION
 *  gui_list_ssp_set_parameter
 * DESCRIPTION
 *  set the list ssp parameter
 * PARAMETERS
 *  ssp_parameter: the parameter of list ssp
 * RETURNS
 *  None 
 *****************************************************************************/
void gui_list_ssp_set_parameter(gui_list_ssp_parameter_struct *ssp_parameter)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 tempu8;
    U16 tempu16;
    float tempf;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    tempu8 = ssp_parameter->gui_menu_ssp_pos_delta;
    if (tempu8 > GUI_MENU_SSP_POS_DELTA_MAX || tempu8 < GUI_MENU_SSP_POS_DELTA_MIN)
    {
        tempu8 = GUI_MENU_SSP_POS_DELTA;
    }
    *g_gui_menu_ssp_pos_delta = tempu8;

    tempu8 = ssp_parameter->gui_ssp_focus_to_hold_state_y_threshold;
    if ((tempu8 > GUI_SSP_FOCUS_TO_HOLD_STATE_Y_THRESHOLD_MAX) ||
        (tempu8 < GUI_SSP_FOCUS_TO_HOLD_STATE_Y_THRESHOLD_MIN))
    {
        tempu8 = GUI_SSP_FOCUS_TO_HOLD_STATE_Y_THRESHOLD;
    }
    *g_gui_ssp_focus_to_hold_state_y_threshold = tempu8;

    tempu8 = ssp_parameter->gui_ssp_frame_update_interval;
    if (tempu8 > GUI_SSP_FRAME_UPDATE_INTERVAL_MAX)// ||
//        (tempu8 < (U8)GUI_SSP_FRAME_UPDATE_INTERVAL_MIN))
    {
        tempu8 = GUI_SSP_FRAME_UPDATE_INTERVAL;
    }
    *g_gui_ssp_frame_update_interval = tempu8;

    tempu8 = ssp_parameter->gui_ssp_free_run_movement_y_thresold;
    if ((tempu8 > GUI_SSP_FREE_RUN_MOVEMENT_Y_THRESOLD_MAX) ||
        (tempu8 < GUI_SSP_FREE_RUN_MOVEMENT_Y_THRESOLD_MIN))
    {
        tempu8 = GUI_SSP_FREE_RUN_MOVEMENT_Y_THRESOLD;
    }
    *g_gui_ssp_free_run_movement_y_thresold = tempu8;

    tempu16 = ssp_parameter->gui_ssp_free_run_threshold_time;
    if ((tempu16 > GUI_SSP_FREE_RUN_THRESHOLD_TIME_MAX) ||
        (tempu16 < GUI_SSP_FREE_RUN_THRESHOLD_TIME_MIN))
    {
        tempu16 = GUI_SSP_FREE_RUN_THRESHOLD_TIME;
    }
    *g_gui_ssp_free_run_threshold_time = tempu16;

    tempf = ssp_parameter->gui_ssp_free_run_recover_coefficient;
    if ((tempf > GUI_SSP_FREE_RUN_RECOVER_COEFFICIENT_MAX) ||
        (tempf < GUI_SSP_FREE_RUN_RECOVER_COEFFICIENT_MIN))
    {
        tempf = GUI_SSP_FREE_RUN_RECOVER_COEFFICIENT;
    }
    *g_gui_ssp_free_run_recover_coefficient = tempf;

    tempf = ssp_parameter->gui_ssp_free_run_scroll_coefficient;
    if ((tempf > GUI_SSP_FREE_RUN_SCROLL_COEFFICIENT_MAX) ||
        (tempf < GUI_SSP_FREE_RUN_SCROLL_COEFFICIENT_MIN))
    {
        tempf = GUI_SSP_FREE_RUN_SCROLL_COEFFICIENT;
    }
    *g_gui_ssp_free_run_scroll_coefficient = tempf;

    tempf = ssp_parameter->gui_ssp_free_run_sensitivity;
    if ((tempf > GUI_SSP_FREE_RUN_SENSITIVITY_MAX) ||
        (tempf < GUI_SSP_FREE_RUN_SENSITIVITY_MIN))
    {
        tempf = GUI_SSP_FREE_RUN_SENSITIVITY;
    }
    *g_gui_ssp_free_run_sensitivity = tempf;

    tempf = ssp_parameter->gui_ssp_menu_over_limit_coefficient;
    if ((tempf > GUI_SSP_MENU_OVER_LIMIT_COEFFICIENT_MAX) ||
        (tempf < GUI_SSP_MENU_OVER_LIMIT_COEFFICIENT_MIN))
    {
        tempf = GUI_SSP_MENU_OVER_LIMIT_COEFFICIENT;
    }
    *g_gui_ssp_menu_over_limit_coefficient = tempf;
}


/*****************************************************************************
 * FUNCTION
 *  gui_list_ssp_reset_parameter
 * DESCRIPTION
 *  reset the list ssp parameter to default value
 * PARAMETERS
 *  None
 * RETURNS
 *  None 
 *****************************************************************************/
void gui_list_ssp_reset_parameter(void)
{
    gui_list_ssp_init_parameter();
}

#endif


void gui_list_get_displayed_item_range(U32 *start_index, U32 *end_index)
{
#ifdef GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN
	if ((g_gui_ssp_state == GUI_LIST_SMOOTH_SCROLLING_BY_PEN_STATE_FREE_RUN ||
		 g_gui_ssp_state == GUI_LIST_SMOOTH_SCROLLING_BY_PEN_STATE_HOLD)	&&
		(g_gui_list_menu_smooth_scrolling_menu_type == GUI_MENU_TYPE_ASYNCDYNAMIC ||
		 g_gui_list_menu_smooth_scrolling_menu_type == GUI_MENU_TYPE_DYNAMIC ||
		 g_gui_list_menu_smooth_scrolling_menu_type == GUI_MENU_TYPE_FIXED))
	{
		if (start_index)
		{
			*start_index = g_gui_ssp_old_first_menu_item_index;
		}

		if (end_index)
		{
			*end_index = g_gui_ssp_old_first_menu_item_index + MMI_fixed_list_menu.displayed_items;
            if (*end_index > (U32)MMI_fixed_list_menu.n_items - 1)
            {
                *end_index = MMI_fixed_list_menu.n_items - 1;
            }
		}

		return;
	}
#endif

	if (start_index)
	{
		*start_index = MMI_fixed_list_menu.first_displayed_item;
	}

	if (end_index)
	{
		*end_index = MMI_fixed_list_menu.first_displayed_item + MMI_fixed_list_menu.displayed_items - 1;
	}

	if (start_index)
	{
		if (*start_index > 0)
		{
			*start_index -= 1;
		}
	}

	if (end_index)
	{
		if (*end_index < (U32)MMI_fixed_list_menu.n_items - 1)
		{
			*end_index += 1;
		}
	}
}

