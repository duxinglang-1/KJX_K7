/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*******************************************************************************
 * Filename:
 * ---------
 *  gui_title_oem.c
 *
 * Project:
 * --------
 *  MAUI
 *
 * Description:
 * ------------
 *  Extract the codes related drawing into this file for oem
 *
 * Author:
 * -------
 * -------
 *
 *==============================================================================
 *     HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *==============================================================================
 *******************************************************************************/


#include "MMI_features.h"
#include "gui_config.h"
#include "wgui.h"
#include "gui_title_pre_oem.h"
#include "gui_title.h"
#include "gui_title_post_oem.h"
#include "wgui_categories_util.h"

#include "MMIDataType.h"
#include "gdi_const.h"
#include "gdi_datatype.h"
#include "gdi_include.h"
#include "gui.h"
#include "kal_general_types.h"
#include "CustDataRes.h"
#include "gui_switch.h"
#include "wgui_inputs.h"
#include "gui_menu_shortcut.h"
#include "gui_themes.h"
#include "gui_data_types.h"
#include "kal_public_api.h"
#include "DebugInitDef_Int.h"
#include "gui_windows.h"


#ifdef __MMI_UI_TITLE_MINI_INDICATOR__
#define GUI_TITLE_MINI_INDICATOR_GAP    3
#endif


/*****************************************************************************
 * Local Function
 *****************************************************************************/
 #ifndef __MMI_TITLE_BAR_NO_ICON_SHCT__
static void gui_title_show_area1(gui_title_struct *t, U32 part);
static void gui_title_show_area2(gui_title_struct *t, U32 part);
#else
#define gui_title_show_area1(_arg1, _arg2) 
#define gui_title_show_area2(_arg1, _arg2) 
#endif
static void gui_title_show_text(gui_title_struct *t, U32 part);

#ifndef __MMI_TITLE_BAR_NO_ICON_SHCT__
static void gui_title_animate1_before_callback(GDI_RESULT result);
static void gui_title_animate2_before_callback(GDI_RESULT result);
static void gui_title_animate_after_callback(GDI_RESULT result);
#else
#define gui_title_animate1_before_callback 
#define gui_title_animate2_before_callback 
#define gui_title_animate_after_callback  
#endif

static gui_title_struct *current_title = NULL;

/*****************************************************************************
 * FUNCTION
 *  gui_title_setup_target_lcd_and_layer
 * DESCRIPTION
 *  set up title target lcd , target layer and alpha blend layer
 * PARAMETERS
 *  t       [IN]        Is the struct of title
 * RETURNS
 *  the old lcd handle
 *****************************************************************************/
gdi_handle gui_title_setup_target_lcd_and_layer(gui_title_struct *t)
{

    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gdi_handle old_lcd_handle = NULL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
  #ifdef __MMI_SUBLCD__  
    gdi_lcd_get_active (&old_lcd_handle);
    if(t->target_lcd == GDI_LCD_SUB_LCD_HANDLE && old_lcd_handle == GDI_LCD_MAIN_LCD_HANDLE)
    {
        UI_set_sub_LCD_graphics_context();
    }
    if(t->target_lcd == GDI_LCD_MAIN_LCD_HANDLE && old_lcd_handle == GDI_LCD_SUB_LCD_HANDLE)
    {
        UI_set_main_LCD_graphics_context();
    }
#endif	
    if(t->target_layer != GDI_NULL_HANDLE)
    {
        gdi_layer_push_and_set_active(t->target_layer);
    }
    if(t->alpha_blend_layer != GDI_NULL_HANDLE)
    {
        gdi_push_and_set_alpha_blending_source_layer(t->alpha_blend_layer);
    }
    return old_lcd_handle;
}


/*****************************************************************************
 * FUNCTION
 *  gui_title_restore_target_lcd_and_layer
 * DESCRIPTION
 *  restore title target lcd , target layer and alpha blend layer
 * PARAMETERS
 *  t               [IN]        Is the struct of title
 *  old_lcd_handle  [IN]        the olcd lcd handle
 * RETURNS
 *  void
 *****************************************************************************/
void gui_title_restore_target_lcd_and_layer(
                gui_title_struct *t,
                gdi_handle old_lcd_handle)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(t->alpha_blend_layer != GDI_NULL_HANDLE)
    {
        gdi_pop_and_restore_alpha_blending_source_layer();
    }
    if(t->target_layer != GDI_NULL_HANDLE)
    {
        gdi_layer_pop_and_restore_active();
    }
#ifdef __MMI_SUBLCD__	
    if(t->target_lcd == GDI_LCD_SUB_LCD_HANDLE && old_lcd_handle == GDI_LCD_MAIN_LCD_HANDLE)
    {
        UI_set_main_LCD_graphics_context();
    }
    if(t->target_lcd == GDI_LCD_MAIN_LCD_HANDLE && old_lcd_handle == GDI_LCD_SUB_LCD_HANDLE)
    {
        UI_set_sub_LCD_graphics_context();
    }
#endif	
}


/*****************************************************************************
 * FUNCTION
 *  gui_title_oem_show_background
 * DESCRIPTION
 *  draw background of title
 * PARAMETERS
 *  t       [IN/OUT]        Is the struct of title
 *  x       [IN]
 *  y       [IN]
 *  w       [IN]
 *  h       [IN]
 * RETURNS
 *  void
 *****************************************************************************/
void gui_title_oem_show_background(gui_title_struct *t, S32 x, S32 y, S32 w, S32 h)
{
#ifdef __MMI_SUBLCD__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gdi_handle old_lcd_handle;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    old_lcd_handle = gui_title_setup_target_lcd_and_layer(t);
#endif
    gdi_layer_push_and_set_clip(x, y, x + w - 1, y + h - 1);

    if (t->hide_callback)
    {
        t->hide_callback(x, y, w, h);
    }
    else
    {
        /* modified to support wallpaper on bottom */
        if (!(t->style & GUI_TITLE_STYLE_DISABLEBG))
        {
            if (wgui_is_wallpaper_on_bottom() == MMI_TRUE)
            {
                gdi_draw_solid_rect(t->x, t->y, t->x + t->width - 1, t->y + t->height - 1, GDI_COLOR_TRANSPARENT);  /* 061705 Calvin added */
            }
            else
            {
                gdi_draw_solid_rect(t->x, t->y, t->x + t->width - 1, t->y + t->height - 1, GDI_COLOR_WHITE);        /* 090605 Title Calvin added */
            }
            
            if (title_bg_id != 0)
            {
                gdi_image_draw_id(t->x, t->y, title_bg_id);
            }
            else
            {
                gui_draw_filled_area(t->x, t->y, t->x + t->width - 1, t->y + t->height - 1, t->active_filler);
            }
        #ifdef __MMI_UI_ANIMATED_TITLE_EFFECT__
            if (gui_title_is_animation_enabled(t))
            {
                if (t->animated_style == MMI_UI_TITLE_IMAGE_ANIMATE_NONE)
                {
                    gui_title_show_animate_image_frame_0(t, t->x, t->y, t->x + t->width - 1, t->y + t->height - 1);
                }
                if (t->animated_style == MMI_UI_TITLE_IMAGE_ANIMATE_ONCE && t->current_frame_count == -1)
                {
                    gui_title_show_animate_image_frame_0(t, t->x, t->y, t->x + t->width - 1, t->y + t->height - 1);
                }
                else
                {
                    gui_title_show_animate_image(t, t->x, t->y, t->x + t->width - 1, t->y + t->height - 1);
                }
            }
        #endif /* __MMI_UI_ANIMATED_TITLE_EFFECT__ */
        }
        else
        {
            gdi_draw_solid_rect(t->x, t->y, t->x + t->width - 1, t->y + t->height - 1, GDI_COLOR_TRANSPARENT);
        }
    }
    gdi_layer_pop_clip();
#ifdef __MMI_SUBLCD__
    gui_title_restore_target_lcd_and_layer(t, old_lcd_handle);
#endif
}


/*****************************************************************************
 * FUNCTION
 *  gui_title_measure_oem
 * DESCRIPTION
 *  restore title target lcd , target layer and alpha blend layer
 * PARAMETERS
 *  t               [IN]        Is the struct of title
 * RETURNS
 *  void
 *****************************************************************************/
void gui_title_measure_oem(gui_title_struct *t, U32 part, S32 *x1, S32 *x2, S32 *h)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 width, height;
    S32 left_width, right_width;
#ifndef __MMI_TITLE_BAR_NO_ICON_SHCT__		
    S32 gap;
#endif
#ifdef __MMI_SUBLCD__	
    gdi_handle active_lcd;
#endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    left_width = 1;
    right_width = 1;
#ifdef  MMI_SHOW_STATUS_ICON_IN_TITLE
    wgui_status_icon_bar_get_integrated_icon_size(STATUS_ICON_SIGNAL_STRENGTH, &width, &height);
    left_width += width;
#ifdef __MMI_DUAL_SIM_MASTER__
    wgui_status_icon_bar_get_integrated_icon_size (STATUS_ICON_SLAVE_SIGNAL_STRENGTH, &width, &height);
    left_width += width + STATUS_ICON_X_GAP;
#endif
    if (part == GUI_TITLE_PART_SIGNAL)
    {
        *x1 = t->x + 1;
        *x2 = *x1 + left_width - 1;
        *h = height;
        return;
    }
    
    wgui_status_icon_bar_get_integrated_icon_size(STATUS_ICON_BATTERY_STRENGTH, &width, &height);
    right_width += width;
#ifdef __MMI_CALL_INDICATOR__
    #ifndef __MMI_DUAL_SIM_MASTER__
    if(!wgui_is_touch_title_bar_buttons())
    {
    #endif
        wgui_status_icon_bar_get_integrated_icon_size(STATUS_ICON_CALL_INDICATOR, &width, &height);
        right_width += width + STATUS_ICON_X_GAP;
    #ifndef __MMI_DUAL_SIM_MASTER__
    }
    #endif
#endif  /* __MMI_CALL_INDICATOR__ */

#ifdef __OP02__
    if (gui_title_get_in_wap() == MMI_TRUE)
    {
        wgui_status_icon_bar_get_integrated_icon_size(STATUS_ICON_MISSED_CALL, &width, &height);
        right_width += width + STATUS_ICON_X_GAP;
    #ifndef __MMI_DUAL_SIM_MASTER__
        wgui_status_icon_bar_get_integrated_icon_size(STATUS_ICON_INCOMING_SMS, &width, &height);
        right_width += width + STATUS_ICON_X_GAP;
        wgui_status_icon_bar_get_integrated_icon_size(STATUS_ICON_MMS_UNREAD, &width, &height);
        right_width += width + STATUS_ICON_X_GAP;
    #else /* __MMI_DUAL_SIM_MASTER__ */
        wgui_status_icon_bar_get_integrated_icon_size(STATUS_ICON_INCOMING_SMS, &width, &height);
        right_width += width + STATUS_ICON_X_GAP;
        wgui_status_icon_bar_get_integrated_icon_size(STATUS_ICON_SLAVE_INCOMING_SMS, &width, &height);
        right_width += width + STATUS_ICON_X_GAP;
        wgui_status_icon_bar_get_integrated_icon_size(STATUS_ICON_MMS_UNREAD_SIM_1, &width, &height);
        right_width += width + STATUS_ICON_X_GAP;
        wgui_status_icon_bar_get_integrated_icon_size(STATUS_ICON_MMS_UNREAD_SIM_2, &width, &height);
        right_width += width + STATUS_ICON_X_GAP;
    #endif /* __MMI_DUAL_SIM_MASTER__ */
    }
#endif /* __OP02__ */
    if (part == GUI_TITLE_PART_BATTERY)
    {
        *x2 = t->x + t->width - 1 - 1;
        *x1 = *x2 - right_width + 1;
        *h = height;
        return;
    }
#endif

    width = 0;
    height = 0;
#ifndef __MMI_TITLE_BAR_NO_ICON_SHCT__	
    if (t->icon != NULL)
    {
    #if defined(__MMI_SCREEN_ROTATE__) && defined(GUI_COMMON_USE_THICK_TITLE)
        if (mmi_frm_is_screen_width_height_swapped() && t->height == MMI_THIN_TITLE_HEIGHT)
        {
            gap = GUI_TITLE_NON_ICON_GAP;
        }
        else
    #endif
        {
            gdi_image_get_dimension((U8*) t->icon, &width, &height);
            if (width <= 0 || height <= 0)
            {
                gap = GUI_TITLE_NON_ICON_GAP;
            }
            else
            {
                gap = width + GUI_TITLE_ICON_GAP;
            }
        }
    }
    else
    {
        gap = GUI_TITLE_NON_ICON_GAP;
    }

    if (!mmi_fe_get_r2l_state())
    {
        left_width += gap;
    }
    else
    {
        right_width += gap;
    }

    if (part == GUI_TITLE_PART_ICON)
    {
        if (!mmi_fe_get_r2l_state())
        {
            *x2 = t->x + left_width - 1;
            *x1 = *x2 - width + 1;
        }
        else
        {
            *x1 = t->x + t->width - right_width;
            *x2 = *x1 + width - 1;
        }
        *h = height;
        return;
    }

    width = 0;
    height = 0;
    if (t->no_icon_shct == MMI_FALSE)
    {
    #ifdef __MMI_TITLE_BAR_NO_ICON_SHCT__
        if (wgui_if_mini_tab_bar_enable())
        {
            gdi_image_get_dimension((U8*) get_image(RIGHT_RED_ARROW), &width, &height);
            gap = width + GUI_TITLE_ICON_GAP;
        }
        else
        {
            gap = GUI_TITLE_NON_ICON_GAP;
        }
    #else /* __MMI_TITLE_BAR_NO_ICON_SHCT__ */
        if (t->icon2 != NULL)
        {
            gdi_image_get_dimension((U8*) t->icon2, &width, &height);
            gap = width + GUI_TITLE_ICON_GAP;;
        }
        else
        {
            gap = GUI_TITLE_NON_ICON_GAP;
        }

    #endif /* __MMI_TITLE_BAR_NO_ICON_SHCT__ */
    }
    else if (t->icon2 != NULL)
    {
        gdi_image_get_dimension((U8*) t->icon2, &width, &height);
        gap = width + GUI_TITLE_ICON_GAP;
    }
    else if (gui_shortcut_is_show(&t->sc))
    {
        width = gui_shortcut_get_width(&t->sc);
        gap = width + GUI_TITLE_NON_ICON_GAP + GUI_SHORTCUT_INSERT_GAP;
        if (!mmi_fe_get_r2l_state())
        {
            gui_shortcut_move(&t->sc, t->x + t->width - right_width - width, t->sc.y);
        }
        else
        {
            gui_shortcut_move(&t->sc, t->x + left_width + GUI_TITLE_NON_ICON_GAP, t->sc.y);
        }
    }
    else
    {
        gap = GUI_TITLE_NON_ICON_GAP;
    }

    if (!mmi_fe_get_r2l_state())
    {
        right_width += gap;
    }
    else
    {
        left_width += gap;
    }

    if (part == GUI_TITLE_PART_ICON2)
    {
        if (!mmi_fe_get_r2l_state())
        {
            *x1 = t->x + t->width  - right_width;
            *x2 = *x1 + width - 1;
        }
        else
        {
            *x2 = t->x + left_width - 1;
            *x1 = *x2 - width + 1;
        }
        *h = height;
        return;
    }
#endif

#ifdef __MMI_SUBLCD__
    gdi_lcd_get_active(&active_lcd);
    if(active_lcd == GDI_LCD_SUB_LCD_HANDLE)
    {
        gui_set_font(&MMI_sublcd_font);
    }
    else
#endif		
    {
        gui_set_font(t->normal_font);
    }
    
    gui_measure_string((UI_string_type) t->text, &width, &height);
    /* all title text have border,so width add 2 */
    width += 2;
    if (width <= t->width - left_width - right_width && !(t->style & GUI_TITLE_STYLE_LEFTALIGN))
    {
        *x1 = t->x + left_width + ((t->width - left_width - right_width - width) >> 1);
        *x2 = *x1 + width - 1;
    }
    else// if (width > t->width - left_width - right_width)
    {
        *x1 = t->x + left_width - 1 + GUI_TITLE_TEXT_GAP + GUI_TITLE_ICON_GAP;
        *x2 = t->x + t->width - right_width - GUI_TITLE_TEXT_GAP - GUI_TITLE_ICON_GAP;
        // Add the gap for title border
        *x1 += 2;
        *x2 -= 2;
    }
    *h = height;
    MMI_ASSERT(part == GUI_TITLE_PART_TEXT);
}


/*****************************************************************************
 * FUNCTION
 *  gui_title_show_scrolling_background
 * DESCRIPTION
 *  Fill the title bar with default color when text is scrolling
 * PARAMETERS
 *  x1      [IN]        Left-top x,y position of title bar
 *  y1      [IN]        Left-top x,y position of title bar
 *  x2      [IN]        Right-bottom x,y position of title bar
 *  y2      [IN]        Right-bottom x,y position of title bar
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_title_show_scrolling_background(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_title_oem_show_background(current_title, x1, y1, x2 - x1 + 1, y2 - y1 + 1);
}


/*****************************************************************************
 * FUNCTION
 *  gui_title_scrolling_timer_callback
 * DESCRIPTION
 *  scrolling title bat timer callback
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_title_scrolling_timer_callback(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_handle_scrolling_text(&current_title->scrolling_text);
}

#ifndef __MMI_TITLE_BAR_NO_ICON_SHCT__
/*****************************************************************************
 * FUNCTION
 *  gui_title_measure_area1
 * DESCRIPTION
 *  t->icon or leftarrow of mini tab bar
 * PARAMETERS
 *  t           [IN/OUT]        Is the struct of title
 *  width       [IN/OUT]        Get the width of area1
 *  height      [IN/OUT]        Get the height of area1
 * RETURNS
 *  void
 *****************************************************************************/
void gui_title_measure_area1(gui_title_struct *t, S32 *width, S32 *height)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x1, x2;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_title_measure_oem(t, GUI_TITLE_PART_ICON, &x1, &x2, height);
    if (!mmi_fe_get_r2l_state())
    {
        *width = x2 - t->x;
    }
    else
    {
        *width = t->x + t->width - x1;
    }
}
#endif

#ifndef __MMI_TITLE_BAR_NO_ICON_SHCT__
/*****************************************************************************
 * FUNCTION
 *  gui_title_measure_area2
 * DESCRIPTION
 *  get the width of t->icon2 or t->sc or right arrow of mini tab bar
 * PARAMETERS
 *  t           [IN/OUT]        Is the struct of title
 *  width       [IN/OUT]        Get the width of area2
 *  height      [IN/OUT]        Get the height of area2
 * RETURNS
 *  void
 *****************************************************************************/
void gui_title_measure_area2(gui_title_struct *t, S32 *width, S32 *height)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x1, x2;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    gui_title_measure_oem(t, GUI_TITLE_PART_ICON2, &x1, &x2, height);
    if (!mmi_fe_get_r2l_state())
    {
        *width = t->x + t->width - x1;
    }
    else
    {
        *width = x2 - t->x;
    }
}
#endif

#ifndef __MMI_TITLE_BAR_NO_ICON_SHCT__
/*****************************************************************************
 * FUNCTION
 *  gui_title_animate_before_callback
 * DESCRIPTION
 *  title animate draw before callback funciton, show the background and set alpha blending layer
 * PARAMETERS
 *  result       [IN/OUT]        result
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_title_animate1_before_callback(GDI_RESULT result)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x1, x2;
    S32 h;
#if defined(__MMI_WALLPAPER_ON_BOTTOM__)	
    gdi_handle active_layer;
#endif


    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_title_measure_oem(current_title, GUI_TITLE_PART_ICON, &x1, &x2, &h);
    gui_title_oem_show_background(current_title, x1, current_title->y, x2 - x1 + 1, current_title->height);
#if defined(__MMI_WALLPAPER_ON_BOTTOM__)
    gdi_layer_get_active(&active_layer);
    gdi_push_and_set_alpha_blending_source_layer(active_layer);
#endif
}


/*****************************************************************************
 * FUNCTION
 *  gui_title_animate_before_callback
 * DESCRIPTION
 *  title animate draw before callback funciton, show the background and set alpha blending layer
 * PARAMETERS
 *  result       [IN/OUT]        result
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_title_animate2_before_callback(GDI_RESULT result)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x1, x2;
    S32 h;
#if defined(__MMI_WALLPAPER_ON_BOTTOM__)	
    gdi_handle active_layer;
#endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_title_measure_oem(current_title, GUI_TITLE_PART_ICON2, &x1, &x2, &h);

    gui_title_oem_show_background(current_title, x1, current_title->y, x2 - x1 + 1, current_title->height);

#if defined(__MMI_WALLPAPER_ON_BOTTOM__)
    gdi_layer_get_active(&active_layer);
    gdi_push_and_set_alpha_blending_source_layer(active_layer);
#endif
}


/*****************************************************************************
 * FUNCTION
 *  gui_title_animate_after_callback
 * DESCRIPTION
 *  the animate draw after callback function, restore the alpha blend layer
 * PARAMETERS
 *  result       [IN/OUT]        Is the struct of title
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_title_animate_after_callback(GDI_RESULT result)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(__MMI_WALLPAPER_ON_BOTTOM__)
    gdi_pop_and_restore_alpha_blending_source_layer();
#endif
}
#endif

#ifdef MMI_SHOW_STATUS_ICON_IN_TITLE
/*****************************************************************************
 * FUNCTION
 *  gui_title_show_status_icon
 * DESCRIPTION
 *  draw icon of title
 * PARAMETERS
 *  t       [IN/OUT]        Is the struct of title
 *  x       [IN]
 *  y       [IN]
 * RETURNS
 *  void
 *****************************************************************************/
void gui_title_show_status_icon_oem(gui_title_struct *t)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 w, h;
    S32 width;
#ifdef __MMI_CALL_INDICATOR__
    S32 w1, h1;
#endif
#ifdef __MMI_DUAL_SIM_MASTER__
    S32 w2, h2;
#endif
    S32 x1, x2;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_push_clip();
    gui_title_measure_oem(t, GUI_TITLE_PART_SIGNAL, &x1, &x2, &h);
    gui_title_oem_show_background(t, x1, t->y, x2 - x1 + 1, t->height);
    
    gdi_layer_set_clip(x1, t->y, x2, t->y + t->height - 1);
    wgui_status_icon_bar_get_integrated_icon_size(STATUS_ICON_SIGNAL_STRENGTH, &w, &h);
    wgui_status_icon_bar_show_integrated_icon(STATUS_ICON_SIGNAL_STRENGTH, t->x, t->y + t->height - h);
#ifdef __MMI_DUAL_SIM_MASTER__
    w += STATUS_ICON_X_GAP;
    wgui_status_icon_bar_get_integrated_icon_size(STATUS_ICON_SLAVE_SIGNAL_STRENGTH, &w2, &h2);
    wgui_status_icon_bar_show_integrated_icon(STATUS_ICON_SLAVE_SIGNAL_STRENGTH, t->x + w - 1, t->y + t->height - h2);
#endif

    gui_title_measure_oem(t, GUI_TITLE_PART_BATTERY, &x1, &x2, &h);
    gui_title_oem_show_background(t, x1, t->y, x2 - x1 + 1, t->height);
    
    gdi_layer_set_clip(x1, t->y, x2, t->y + t->height - 1);
    wgui_status_icon_bar_get_integrated_icon_size(STATUS_ICON_BATTERY_STRENGTH, &w, &h);
    width = w;
    wgui_status_icon_bar_show_integrated_icon(STATUS_ICON_BATTERY_STRENGTH, t->x + t->width - width, t->y + t->height - h);
#ifdef __MMI_CALL_INDICATOR__
    #ifndef __MMI_DUAL_SIM_MASTER__
    if(wgui_is_touch_title_bar_buttons() == MMI_FALSE)
    {
    #endif
        wgui_status_icon_bar_get_integrated_icon_size(STATUS_ICON_CALL_INDICATOR, &w1, &h1);
        width += w1 + STATUS_ICON_X_GAP;
        wgui_status_icon_bar_show_integrated_icon(STATUS_ICON_CALL_INDICATOR, t->x + t->width - width + 1, t->y + t->height - h);
    #ifndef __MMI_DUAL_SIM_MASTER__
    }
    #endif
#endif /* __MMI_CALL_INDICATOR__ */

#ifdef __OP02__
    if (gui_title_get_in_wap() == MMI_TRUE)
    {
        S32 w2, w3, w4, w5,w6, h;
        wgui_status_icon_bar_get_integrated_icon_size(STATUS_ICON_MISSED_CALL, &w2, &h);
        width += w2 + STATUS_ICON_X_GAP;
        wgui_status_icon_bar_show_integrated_icon(STATUS_ICON_MISSED_CALL, t->x + t->width - width + 1, t->y + t->height - h);
    #ifndef __MMI_DUAL_SIM_MASTER__
        wgui_status_icon_bar_get_integrated_icon_size(
            STATUS_ICON_INCOMING_SMS, 
            &w3, 
            &h);
        width += w3 + STATUS_ICON_X_GAP;
        wgui_status_icon_bar_show_integrated_icon(STATUS_ICON_INCOMING_SMS, t->x + t->width - width + 1, t->y + t->height - h);
        wgui_status_icon_bar_get_integrated_icon_size(
            STATUS_ICON_MMS_UNREAD, 
            &w4, 
            &h);
        width += w4 + STATUS_ICON_X_GAP;
        wgui_status_icon_bar_show_integrated_icon(STATUS_ICON_MMS_UNREAD, t->x + t->width - width + 1, t->y + t->height - h);
    #else /* __MMI_DUAL_SIM_MASTER__ */
        wgui_status_icon_bar_get_integrated_icon_size(
            STATUS_ICON_INCOMING_SMS, 
            &w3, 
            &h);
        width += w3 + STATUS_ICON_X_GAP;
        wgui_status_icon_bar_show_integrated_icon(STATUS_ICON_INCOMING_SMS, t->x + t->width - width + 1, t->y + t->height - h);
        wgui_status_icon_bar_get_integrated_icon_size(
            STATUS_ICON_SLAVE_INCOMING_SMS, 
            &w4,
            &h);
        width += w4 + STATUS_ICON_X_GAP;
        wgui_status_icon_bar_show_integrated_icon(STATUS_ICON_SLAVE_INCOMING_SMS, t->x + t->width - width + 1, t->y + t->height - h);
        wgui_status_icon_bar_get_integrated_icon_size(
            STATUS_ICON_MMS_UNREAD_SIM_1, 
            &w5, 
            &h);
        width += w5 + STATUS_ICON_X_GAP;
        wgui_status_icon_bar_show_integrated_icon(STATUS_ICON_MMS_UNREAD_SIM_1, t->x + t->width - width + 1, t->y + t->height - h);
        wgui_status_icon_bar_get_integrated_icon_size(
            STATUS_ICON_MMS_UNREAD_SIM_2, 
            &w6, 
            &h);
        width += w5 + STATUS_ICON_X_GAP;
        wgui_status_icon_bar_show_integrated_icon(STATUS_ICON_MMS_UNREAD_SIM_2, t->x + t->width - width + 1, t->y + t->height - h);
    #endif /* __MMI_DUAL_SIM_MASTER__ */
    }
#endif /* __OP02__ */

    gdi_layer_pop_clip();
}
#endif /* MMI_SHOW_STATUS_ICON_IN_TITLE */

#ifndef __MMI_TITLE_BAR_NO_ICON_SHCT__
/*****************************************************************************
 * FUNCTION
 *  gui_title_show_area1
 * DESCRIPTION
 *  draw icon of title
 * PARAMETERS
 *  t       [IN/OUT]        Is the struct of title
 *  x       [IN]
 *  y       [IN]
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_title_show_area1(gui_title_struct *t, U32 part)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#if defined(__MMI_WALLPAPER_ON_BOTTOM__)	
    gdi_handle act_layer;
#endif
    U16 image_type;
    S32 x1, x2, h;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_title_measure_oem(t, GUI_TITLE_PART_ICON, &x1, &x2, &h);
    gdi_layer_push_clip();
    gdi_layer_set_clip(x1, t->y, x2, t->y + t->height - 1);

    if (part != GUI_TITLE_PART_ALL)
    {
        gui_title_oem_show_background(t, x1, t->y, x2 - x1 + 1, t->height);
    }
    
    if (t->icon != NULL)
    {
        image_type = gdi_image_get_buf_type(t->icon);
        /* Set active layer as the abm source layer for png title icon*/
    #if defined(__MMI_WALLPAPER_ON_BOTTOM__)
        if ((image_type == GDI_IMAGE_TYPE_GIF) || (image_type == GDI_IMAGE_TYPE_GIF_FILE))
        {
            gdi_layer_get_active(&act_layer);
            gdi_push_and_set_alpha_blending_source_layer(act_layer);
        }
    #endif

    #if defined(__MMI_SCREEN_ROTATE__) && defined(GUI_COMMON_USE_THICK_TITLE)
        if (mmi_frm_is_screen_width_height_swapped() && t->height == MMI_THIN_TITLE_HEIGHT)
        {
        }
        else
    #endif
        {
            if ((image_type != GDI_IMAGE_TYPE_GIF) && (image_type != GDI_IMAGE_TYPE_GIF_FILE))
            {
                gdi_anim_set_draw_before_callback(gui_title_animate1_before_callback);
                gdi_anim_set_draw_after_callback (gui_title_animate_after_callback);
            }
            gdi_image_draw_animation(x1, t->y + ((t->height - h) >> 1), (U8*) t->icon, &t->icon_ani_handle);
        }
    #if defined(__MMI_WALLPAPER_ON_BOTTOM__)
        if ((image_type == GDI_IMAGE_TYPE_GIF) || (image_type == GDI_IMAGE_TYPE_GIF_FILE))
        {
            gdi_pop_and_restore_alpha_blending_source_layer();
        }
    #endif
    }
    gdi_layer_pop_clip();
}


/*****************************************************************************
 * FUNCTION
 *  gui_title_show_area2
 * DESCRIPTION
 *  draw icon of title
 * PARAMETERS
 *  t       [IN/OUT]        Is the struct of title
 *  x       [IN]
 *  y       [IN]
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_title_show_area2(gui_title_struct *t, U32 part)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x1, x2;
    S32 h;
    U16 image_type;
#if defined(__MMI_WALLPAPER_ON_BOTTOM__)	
    gdi_handle act_layer;
#endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_title_measure_oem(t, GUI_TITLE_PART_ICON2, &x1, &x2, &h);

    gdi_layer_push_clip();
    gdi_layer_set_clip(x1, t->y, x2, t->y + t->height - 1);

    if (part != GUI_TITLE_PART_ALL)
    {
        gui_title_oem_show_background(t, x1, t->y, x2 - x1 + 1, t->height);
    }
	
#ifndef __MMI_TITLE_BAR_NO_ICON_SHCT__
  t->sc.display_disabled = t->no_icon_shct;
/*
    if (t->no_icon_shct == MMI_FALSE)
    {
        t->sc.display_disabled = MMI_TRUE;
    }
    else
    {
        t->sc.display_disabled = MMI_FALSE;
    }
*/
#ifdef __MMI_WGUI_MINI_TAB_BAR__
    if (wgui_if_mini_tab_bar_enable())
    {
        gdi_image_draw_id(x1, y, RIGHT_RED_ARROW);
    }
#endif
//#else
    if (t->icon2 != NULL)
    {
        image_type = gdi_image_get_buf_type(t->icon2);
        /* When show gif animate image, we can't register function to clear background,
         * Should set the right alpha blend layer here
         */
    #if defined(__MMI_WALLPAPER_ON_BOTTOM__)
        if ((image_type == GDI_IMAGE_TYPE_GIF) || (image_type == GDI_IMAGE_TYPE_GIF_FILE))
        {
            gdi_layer_get_active(&act_layer);
            gdi_push_and_set_alpha_blending_source_layer(act_layer);
        }
    #endif

    #if defined(__MMI_SCREEN_ROTATE__) && defined(GUI_COMMON_USE_THICK_TITLE)
        if (mmi_frm_is_screen_width_height_swapped() && t->height == MMI_THIN_TITLE_HEIGHT)
        {
        }
        else
    #endif
        {
            if ((image_type != GDI_IMAGE_TYPE_GIF) && (image_type != GDI_IMAGE_TYPE_GIF_FILE))
            {
                gdi_anim_set_draw_before_callback(gui_title_animate2_before_callback);
                gdi_anim_set_draw_after_callback (gui_title_animate_after_callback);
            }
            gdi_image_draw_animation(x1, t->y + ((t->height - h) >> 1), (U8*) t->icon2, &t->icon2_ani_handle);
        }
    #if defined(__MMI_WALLPAPER_ON_BOTTOM__)
        if ((image_type == GDI_IMAGE_TYPE_GIF) || (image_type == GDI_IMAGE_TYPE_GIF_FILE))
        {
            gdi_pop_and_restore_alpha_blending_source_layer();
        }
    #endif
    }
#endif /* __MMI_TITLE_BAR_NO_ICON_SHCT__ */
    
    gdi_layer_pop_clip();
}
#endif

/*****************************************************************************
 * FUNCTION
 *  gui_title_show_text
 * DESCRIPTION
 *  draw title text
 * PARAMETERS
 *  t       [IN/OUT]        Is the struct of title
 *  x1      [IN]
 *  y1      [IN]
 *  x2      [IN]
 *  y2      [IN]
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_title_show_text(gui_title_struct *t, U32 part)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#ifdef __MMI_SUBLCD__	
    gdi_handle active_lcd;
#endif
    S32 x1, x2, y;
    S32 h;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_title_measure_oem(t, GUI_TITLE_PART_TEXT, &x1, &x2, &h);
    y = t->y + ((t->height - h) >> 1);
    //gdi_layer_push_clip();
    gdi_layer_push_and_set_clip(x1, t->y, x2, t->y + t->height - 1);

    if (part != GUI_TITLE_PART_ALL)
    {
        gui_title_oem_show_background(t, x1, t->y, x2 - x1 + 1, t->height);
    }
    #ifdef __MMI_SUBLCD__
    gdi_lcd_get_active(&active_lcd);
    if(active_lcd == GDI_LCD_SUB_LCD_HANDLE)
    {
        gui_set_font(&MMI_sublcd_font);
    }
    else
	#endif
    {
        gui_set_font(t->normal_font);
    }

    gui_set_text_color(t->text_color);
    gui_set_text_border_color(t->text_border_color);

#ifdef __MMI_UI_TITLE_TRANSITION__
    if (!t->check_for_transition)
    {
        if (!mmi_fe_get_r2l_state())
        {

        #ifdef __MMI_SCREEN_SWITCH_EFFECT__
            gui_move_text_cursor(x1 + t->offset_x, y + t->offset_y);
        #else
            gui_move_text_cursor(x1, y);
        #endif
        }
        else
        {
        #ifdef __MMI_SCREEN_SWITCH_EFFECT__
            gui_move_text_cursor(x2 + t->offset_x, y + t->offset_y);
        #else
            gui_move_text_cursor(x2, y);
        #endif
        }
    #if defined(__MMI_FTE_SUPPORT__) && defined(__MMI_VECTOR_FONT_SUPPORT__)
        gui_print_text((UI_string_type) t->text);
    #else
        gui_print_bordered_text((UI_string_type) t->text);
    #endif
    }
    else
#endif /* __MMI_UI_TITLE_TRANSITION__ */
    {   
        if (t->style & GUI_TITLE_STYLE_SCROLLING)
        {
            gui_create_scrolling_text(
                &(t->scrolling_text),
                x1,
                t->y + ((t->height - h) >> 1),
                x2 - x1 + 1,
                h, 
                (UI_string_type)(t->text),
                gui_title_scrolling_timer_callback,
                gui_title_show_scrolling_background, 
                t->text_color,
                t->text_border_color);
#ifndef __MMI_FTE_SUPPORT__
            t->scrolling_text.flags |= UI_SCROLLING_TEXT_BORDERED_TEXT;
#endif
            gui_change_scrolling_text_font(&t->scrolling_text, t->normal_font);
            gui_show_scrolling_text(&t->scrolling_text);
        }
        else
        {
            if (!mmi_fe_get_r2l_state())
            {
            #ifdef __MMI_SCREEN_SWITCH_EFFECT__
                #if defined(__MMI_FTE_SUPPORT__) && defined(__MMI_VECTOR_FONT_SUPPORT__)
                gui_print_truncated_text(x1 + t->offset_x + 1, y + t->offset_y, x2 - x1 + 1, (UI_string_type) t->text);
                #else
                gui_print_truncated_borderd_text(x1 + t->offset_x + 1, y + t->offset_y, x2 - x1 + 1, (UI_string_type) t->text);
                #endif
            #else
                #if defined(__MMI_FTE_SUPPORT__) && defined(__MMI_VECTOR_FONT_SUPPORT__)
                gui_print_truncated_text(x1 + 1, y, x2 - x1 + 1, (UI_string_type) t->text);
                #else
                gui_print_truncated_borderd_text(x1 + 1, y, x2 - x1 + 1, (UI_string_type) t->text);
                #endif
            #endif
            }
            else
            {
            #ifdef __MMI_SCREEN_SWITCH_EFFECT__
                #if defined(__MMI_FTE_SUPPORT__) && defined(__MMI_VECTOR_FONT_SUPPORT__)
                gui_print_truncated_text(x2 + t->offset_x - 1, y + t->offset_y, x2 - x1 + 1, (UI_string_type) t->text);
                #else
                gui_print_truncated_borderd_text(x2 + t->offset_x - 1, y + t->offset_y, x2 - x1 + 1, (UI_string_type) t->text);
                #endif
            #else
                #if defined(__MMI_FTE_SUPPORT__) && defined(__MMI_VECTOR_FONT_SUPPORT__)
                gui_print_truncated_text(x2 - 1, y, x2 - x1 + 1, (UI_string_type) t->text);
                #else
                gui_print_truncated_borderd_text(x2 - 1, y, x2 - x1 + 1, (UI_string_type) t->text);
                #endif
            #endif
            }
        }
    }
    gdi_layer_pop_clip();
}


/*****************************************************************************
 * FUNCTION
 *  gui_title_show_mini_inidcator
 * DESCRIPTION
 *  Draw title mini inidcator
 * PARAMETERS
 *  t           [IN/OUT]        Is the struct of title
 * RETURNS
 *  void
 *****************************************************************************/
#ifdef __MMI_UI_TITLE_MINI_INDICATOR__
static void gui_title_show_mini_inidcator(gui_title_struct *t)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x1, y1, x2, y2, ix1, ix2, iwidth;
    S32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!t->display_indicator || t->number_of_indicator <= 0 ||
        t->highlight_of_indicator < 0 || t->highlight_of_indicator >= t->number_of_indicator)
    {
        return;
    }

    /* draw background */
    x1 = t->x;
    x2 = t->x + t->width - 1;
    y2 = t->y + t->height - 1;
    y1 = y2 - 5;

    //gdi_layer_push_clip();
    gdi_layer_push_and_set_clip(x1, y1, x2, y2);
    gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_BLACK);
    gdi_layer_pop_clip();

    /* draw_indicator */
    x1 += 16;
    x2 -= 16;

    iwidth = (x2 - x1 + 1 - GUI_TITLE_MINI_INDICATOR_GAP * (t->number_of_indicator - 1)) / t->number_of_indicator;
    ix1 = x1 + 2 + (x2 - x1 + 1 - GUI_TITLE_MINI_INDICATOR_GAP * (t->number_of_indicator - 1)) % t->number_of_indicator;
    ix2 = ix1 + iwidth - 1;
    for (i = 0; i < t->number_of_indicator; i ++)
    {
        if (i == t->highlight_of_indicator)
        {
            gdi_draw_solid_rect(ix1, y1 + 1, ix2, y2 - 1, GDI_COLOR_RED);
        }
        else
        {
            gdi_draw_solid_rect(ix1, y1 + 1, ix2, y2 - 1, GDI_COLOR_WHITE);
        }

        ix1 = ix2 + GUI_TITLE_MINI_INDICATOR_GAP;
        ix2 = ix1 + iwidth - 1;
    }

}
#endif /* __MMI_UI_TITLE_MINI_INDICATOR__ */


/*****************************************************************************
 * FUNCTION
 *  gui_title_oem_show_normal_ex
 * DESCRIPTION
 *  draw title
 * PARAMETERS
 *  t           [IN/OUT]        Is the struct of title
 *  part        [IN]            the part to be redraw (icon, icon2, text, shortcut, all)
 * RETURNS
 *  void
 *****************************************************************************/
void gui_title_oem_show_normal_ex(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_title_oem_show_normal(current_title, GUI_TITLE_PART_SIGNAL | GUI_TITLE_PART_BATTERY);
#ifdef __MMI_VUI_ENGINE__
    if(current_title->venus_update_screen_callback)
    {
        current_title->venus_update_screen_callback(current_title->venus_update_screen_handle);
    }
    else
    {
#endif
        gdi_layer_blt_previous(
            current_title->x,
            current_title->y,
            current_title->x + current_title->width - 1,
            current_title->y + current_title->height - 1);
#ifdef __MMI_VUI_ENGINE__
    }
#endif
}


/*****************************************************************************
 * FUNCTION
 *  gui_title_oem_show_normal
 * DESCRIPTION
 *  draw title
 * PARAMETERS
 *  t           [IN/OUT]        Is the struct of title
 *  part        [IN]            the part to be redraw (icon, icon2, text, shortcut, all)
 * RETURNS
 *  void
 *****************************************************************************/
S32 gui_title_oem_show_normal(gui_title_struct *t, U32 part)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL bitblt = MMI_TRUE;
    gdi_handle old_lcd_handle;


    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
//disable title icon in 96X64
#ifdef __MMI_MAINLCD_96X64__
	t->icon  = NULL;
#endif
    current_title = t;

    old_lcd_handle = gui_title_setup_target_lcd_and_layer(t);
#ifndef __MMI_TITLE_BAR_NO_ICON_SHCT__	
    if ((part & GUI_TITLE_PART_ICON) && (t->icon_ani_handle != GDI_ERROR_HANDLE))
    {
        gdi_image_stop_animation(t->icon_ani_handle);
        t->icon_ani_handle = GDI_ERROR_HANDLE;
    }

    if ((part & GUI_TITLE_PART_ICON2) && (t->icon2_ani_handle != GDI_ERROR_HANDLE))
    {
        gdi_image_stop_animation(t->icon2_ani_handle);
        t->icon2_ani_handle = GDI_ERROR_HANDLE;
    }
#endif
    
#ifdef __MMI_UI_TITLE_TRANSITION__
    bitblt = gui_title_pre_show(t);
#endif

    gui_lock_double_buffer();
    if (part == GUI_TITLE_PART_ALL)
    {
        gui_title_oem_show_background(t, t->x, t->y, t->width, t->height);
    }
#ifdef MMI_SHOW_STATUS_ICON_IN_TITLE
    if (part & GUI_TITLE_PART_SIGNAL || part & GUI_TITLE_PART_BATTERY)
    {
        wgui_status_icon_bar_register_integrated_redraw(gui_title_oem_show_normal_ex);
        gui_title_show_status_icon_oem(t);
    }
#endif

#ifndef __MMI_TITLE_BAR_NO_ICON_SHCT__	
    if (part & GUI_TITLE_PART_ICON)
    {
        gui_title_show_area1(t, part);
    }

    if (part & GUI_TITLE_PART_ICON2)
    {
        gui_title_show_area2(t, part);
    }
#endif
    if (part & GUI_TITLE_PART_TEXT)
    {
        gui_title_show_text(t, part);
    }

#ifndef __MMI_TITLE_BAR_NO_ICON_SHCT__	

#ifdef __MMI_UI_TITLE_TRANSITION__
    if (!t->enable_transition)
#endif
    {
        if (t->icon2 == NULL && (part & GUI_TITLE_PART_SHORTCUT))
        {
            gui_shortcut_show(&t->sc);
        }
    }
#endif

#ifdef __MMI_UI_TITLE_MINI_INDICATOR__

    if (part & GUI_TITLE_PART_MINI_INDICATOR)
    {
        gui_title_show_mini_inidcator(t);
    }

#endif /* __MMI_UI_TITLE_MINI_INDICATOR__ */

    gui_unlock_double_buffer();
    gui_title_restore_target_lcd_and_layer(t, old_lcd_handle);
    return bitblt;
}


