/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*******************************************************************************
 * Filename:
 * ---------
 *  History.c
 *
 * Project:
 * --------
 *  MAUI
 *
 * Description:
 * ------------
 *  
 *
 * Author:
 * -------
 * -------
 *
 *==============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!! 
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!! 
 *==============================================================================
 *******************************************************************************/

/***************************************************************************** 
*  Include
*****************************************************************************/
#include "MMI_features.h"
#include "MMIDataType.h"
#include "GlobalResdef.h"
//#include "mmi_frm_gprot.h"
#include "mmi_frm_prot.h"
//#include "CustMenuRes.h"
#include "gdi_include.h"        
#include "wgui_categories_util.h" 
#include "wgui_draw_manager.h"
#include "gui_effect_oem.h"
#include "ProfilingEngine.h"
//#include "SimDetectionGprot.h"
#include "Mmi_frm_scenario_prot.h"

//RHR Add
#include "ImeGprot.h"
#include "kal_general_types.h"
#include "mmi_frm_history.h"
#include "mmi_frm_history_gprot.h"
#include "gui_typedef.h"
#include "DebugInitDef_Int.h"
#include "pluto_fw_trc.h"
#include "kal_trace.h"
#include "string.h"
#include "mmi_frm_mem_gprot.h"
//#include "app_buff_alloc.h"
#include "kal_public_api.h"
#include "MMI_fw_trc.h"
#include "mmi_frm_scenario_gprot.h"
#include "mmi_frm_events_gprot.h"
#include "Unicodexdcl.h"
#include "custom_mmi_default_value.h"
#include "gdi_datatype.h"
#include "CustThemesRes.h"
#include "lcd_sw_inc.h"
#include "Gui_Setting.h"
#include "gui_themes.h"
#include "ScreenRotationGprot.h"
#include "gdi_const.h"
#include "CustDataRes.h"
#include "mmi_rp_app_uiframework_def.h"
#include "gui.h"
#include "mmi_frm_events.h"
#include "gui_data_types.h"
//RHR Add more
#include "wgui_categories_list.h"
#include "mmi_fw_trc.h"
#include "wgui_categories.h"
#include "mmi_frm_at_util_prot.h"
#include "mmi_frm_input.h"
#include "kal_debug.h"

#ifdef __TST_TRACE_ENABLED__
static MMI_BOOL g_dump_history = MMI_FALSE;
#endif /* __TST_TRACE_ENABLED__ */
static S32 no_small_screen = 0;
static S32 small_screen_enabled = 0;
static MMI_BOOL g_switch_flag = MMI_FALSE;
/*static*/ S32 small_history_node = 0;

/*****************************************************************************  
*   Extern Functions 
*****************************************************************************/
#ifndef __MMI_NOT_TAB_SUPPORT__
extern MMI_BOOL mmi_frm_scrn_tab_get_bar_items(tab_bar_item_type *tab_bar_items_p, S8 *tabs_p);
#endif /* __MMI_NOT_TAB_SUPPORT__ */
void mmi_frm_redraw_bg(void);
extern void ShowCategoryDummyScreen(void);

#ifdef __MMI_FRM_HISTORY__

/***************************************************************************** 
*  Define
*****************************************************************************/
#ifdef __MMI_TOUCH_SCREEN__
extern void mmi_frm_touch_screen_switch_action(void);
#endif

#ifdef ENHANCE_HISTORY_UNIT_TEST
extern void* test_case_scrn_arg;
#endif

#define MMI_FRM_INPUT_BUFFER_HEADER_TYPE S32
#define MMI_FRM_INPUT_BUFFER_HEADER_SIZE sizeof(MMI_FRM_INPUT_BUFFER_HEADER_TYPE) 

#ifdef HISTORY_TAB_MANGER
/***************************************************************************** 
*  Typedef 
*****************************************************************************/
typedef struct{
    U16 screen_id;
    FuncPtr entry_func_ptr;
    U8 *input_buffer;    
    U8 *gui_buffer;      
}mmi_frm_tab_history_node_struct;

typedef struct{
    U16     scrn_id;
    FuncPtr entry_func_ptr;
    U8 cur_sel_index;
    U8 tab_page_count;
    S8 tab_bar_first_item_index;
    MMI_BOOL use_pen_switch;
    mmi_frm_tab_history_node_struct *tab_history_p;
}mmi_frm_tab_group_struct;
#endif

/***************************************************************************** 
*  Extern Variables
*****************************************************************************/
MMI_BOOL g_is_back_root_main_hist = MMI_FALSE;
MMI_BOOL g_is_stop_when_forbiden = MMI_FALSE;


/***************************************************************************** 
*  Global Variables
*****************************************************************************/
pBOOL IsBackHistory = MMI_FALSE;


/*****************************************************************************  
*  Local Variables 
*****************************************************************************/
static historyCallback historyCBHandler[MAX_HISTORY];
static historyNode historyData[MAX_HISTORY];    /* array of history data */
static S16 currHistoryIndex = -1;

static S16 activeScrnIndex = -1;    /* the active screen index */
static S16 newScrnIndex = -1;       /* the new screen index, it temp state during entry new screen process */
static S16 _tmp_topHistoryIndex = -1;
static S16 topHistoryIndex = -1;    /* the topest inactive screen index */
static U8 goback_reentry_count = 0;
static U8 delete_reentry_count = 0;
void*  g_frm_current_scrn_arg  = NULL;

static U16 curr_redraw_scrn  = SCR_ID_INVALID;  /* In small screen procedure */
static U16 curr_delete_scrn  = SCR_ID_INVALID;  /* Delete the screen in the history */
static U16 curr_destroy_scrn = SCR_ID_INVALID;  /* Destroy the screen */

static MMI_BOOL CheckMainLCDHistoryBack     = MMI_FALSE;
static MMI_BOOL bBackHistoryFlag            = MMI_FALSE;

#ifdef HISTORY_TAB_MANGER

static mmi_frm_tab_group_struct  tab_group         = {0};
static tab_bar_item_type*        g_tab_bar_items_p = NULL;
static S8                        g_tab_bar_num     = 0;

static FuncPtr curr_tab_exit_func_ptr = NULL;
static FuncPtr curr_tab_entry_func_ptr = NULL;
static U16     curr_tab_scrn_id;

#endif

/* Small screen mechanism */

static mmi_hist_smallscreen_state_enum redrawing_old_screens = MMI_HIST_SMALLSCREEN_NONE;


static U16 currSmallScrnID = 0;

/* Redraw */
static MMI_BOOL isRedrawEmptyBg = MMI_FALSE;
static MMI_BOOL isEnableSmallScrnRedraw = MMI_TRUE;
/* 
 * Record screen & history for small screen case:
 * when redraw background, its destory hdlr can't be invoked,
 * but when enter small screnn, destory hdlr of exit screen must be invoked!
 */
U16 top_scrn_in_go_back_id;
HistoryDelCBPtr top_scrn_in_go_back_destroy_func = NULL;
void *top_scrn_in_go_back_arg_p = NULL;
/* events.c */
static MMI_BOOL is_in_exit_handler_proc = MMI_FALSE;

static U16 currExitScrnID;   /* curr exit func ptr with scrn id */
static U16 currActiveScrnID;
static U16 currActiveScrnType;
static MMI_BOOL mmu_frm_execute_scrn_exit_handler = MMI_FALSE;
static exit_func_ptr curr_exit_handler = NULL; 
static entry_func_ptr curr_entry_handler = NULL;
static void *curr_exit_scrn_arg_p = NULL;
static void *curr_entry_scrn_arg_p = NULL;

/*****************************************************************************  
*   Local Functions  
*****************************************************************************/
static U8 SearchDelScrnIDCallbackHandler(U16 ScrnID, U16 *found_idx);
static U8 ExecTopScrnCallbackHandler(void);
static U8 ExecHistoryScrnCallBackHandle(U16 HistoryIndex);
static void mmi_free_history_buffer(S16 id);
static S16 increment(void);
static S16 searched_history_node(S16 first_index, U16 scrn_id);
static U16 mmi_frm_remove_history_node(mmi_history_node_status_enum status);
static U8  mmi_frm_go_back_to_history_int(U16 scrnid);
static mmi_history_node_status_enum mmi_frm_set_history_node_status(U16 index, mmi_history_node_status_enum status);
static U8 mmi_frm_clear_destroy_scrn_callback(U16 scrn_id);
static MMI_BOOL mmi_frm_get_scrn_idx(U16 scrn_id, U16 *found_idx);
__inline static U8 DeleteHistoryInt(U16 startScrId, U8 bIncStart, U16 count, U16 endScrId, U8 bIncEnd, U8 flag, U16* deleteCount);
static void insert_history_by_idx(S16 insert_idx, mmi_frm_screen_struct *scrn_struct);

#ifdef HISTORY_TAB_MANGER
static MMI_BOOL mmi_frm_is_tab_info_loaded(void);
static void mmi_frm_release_tab_group(mmi_frm_tab_group_struct* tab_group_p);
static U8* mmi_frm_get_tab_group_data(U8* buffer);
static mmi_frm_tab_history_node_struct *mmi_frm_find_tab_history(U16 screen_id);
static void mmi_frm_set_tab_bar_items(mmi_frm_tab_struct *tab_pages_info_array, U8 tab_pages_count);
static void mmi_frm_free_tab_bar_items(void);
static MMI_BOOL mmi_frm_is_tab_history(U16 scrnid);
static void mmi_frm_reset_tab_history(U16 scrnid);
void mmi_frm_tab_save_history(U16 scrnID, FuncPtr entryFuncPtr);
#endif /* HISTORY_TAB_MANGER */

/* events.c */
static void update_entry_exit_handler(exit_func_ptr exit_handler, entry_func_ptr entry_handler);
static void ExecuteCurrExitHandler(mmi_frm_scrn_type_enum scrn_type, MMI_BOOL is_clear_input_hdr);
static void update_entry_exit_handler(exit_func_ptr exit_handler, entry_func_ptr entry_handler);


/*****************************************************************************  
*  Initialize  history Series APIs
*****************************************************************************/

/*****************************************************************************
 * FUNCTION
 *  InitHistory
 * DESCRIPTION
 *  Initialize the history data structure
 * PARAMETERS
 *  main_root_ptr       [IN] Reserved. It sould be NULL.       
 *  sub_root_ptr        [IN] The root entry function of the sub LCD.      
 * RETURNS
 *  void
 *****************************************************************************/
void InitHistory(MainLcdHistoryCBPtr main_root_ptr, SubLcdHistoryCBPtr sub_root_ptr)
{

    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(PLUTO_FW_TRC_SCREEN, TRC_MMI_FRM_HIST_INIT_HIST_BEGIN);
    
    curr_exit_handler = NULL; 
    curr_entry_handler = NULL;
    curr_exit_scrn_arg_p = NULL;
    curr_entry_scrn_arg_p = NULL;
    currExitScrnID   = 0;
    currActiveScrnID = 0;
    set_exit_scrn_id(GRP_ID_INVALID, SCR_ID_INVALID);
    set_active_scrn_id(GRP_ID_INVALID, SCR_ID_INVALID);
    

    mmu_frm_execute_scrn_exit_handler = MMI_FALSE;

    if (mmi_is_redrawing_bk_screens())
    {
        return;
    }

    memset(historyData, 0, sizeof(historyNode) * MAX_HISTORY);
    memset(historyCBHandler, 0, sizeof(historyCBHandler));

    topHistoryIndex = -1;    /* the topest inactive screen index */

    /* initialize active historyData[] */
    activeScrnIndex = -1;
    newScrnIndex = -1;

    InitSubLCDHistory(sub_root_ptr);
    MMI_TRACE(PLUTO_FW_TRC_SCREEN, TRC_MMI_FRM_HIST_INIT_HIST_END);
}


/*****************************************************************************
 * FUNCTION
 *  DinitHistory
 * DESCRIPTION
 *  Free the history node
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void DinitHistory(void)
{

    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 count = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(PLUTO_FW_TRC_SCREEN, TRC_MMI_FRM_HIST_DINIT_HIST_BEGIN);
    if (mmi_is_redrawing_bk_screens())
    {
        return;
    }

    ExecTopScrnCallbackHandler();
    if (topHistoryIndex > 0)
    {
        for (count = topHistoryIndex; count > 0; --count)
        {
            if (count <= currHistoryIndex)
            {
                ExecHistoryScrnCallBackHandle(count);
                mmi_frm_exec_scrn_destroy_hdlr(historyData[count].scrnID, historyData[count].app_arg);
            }
            mmi_free_history_buffer(count);
            memset(&historyData[count], 0, sizeof(historyNode));

        }
    }
    topHistoryIndex = -1;
    /*
     * Free historyData[0] memory:
     * Here can't use mmi_free_history_buffer() 
     * because currHistoryIndex may be -1 in ExecutePopHistory and then
     * invoke DinitHistory() in EntryIdleScreen()
     */
    if (historyData[0].guiBuffer)
    {
        OslMfree(historyData[0].guiBuffer);
    }
    if (historyData[0].inputBuffer)
    {
        OslMfree(historyData[0].inputBuffer);
    }

    memset(&historyData[0], 0, sizeof(historyData[0]));
    currHistoryIndex = -1;

    /* update historyData[activeScrnIndex] */
    memcpy(&historyData[topHistoryIndex + 1], &historyData[activeScrnIndex], sizeof(historyNode));
    if (activeScrnIndex > topHistoryIndex + 1)
    {
        memset(&historyData[activeScrnIndex], 0, sizeof(historyNode));
    }
    //activeScrnIndex = topHistoryIndex + 1;
    //newScrnIndex = activeScrnIndex;
    activeScrnIndex = -1;
    newScrnIndex    = -1;
    
    MMI_TRACE(PLUTO_FW_TRC_SCREEN, TRC_MMI_FRM_HIST_DINIT_HIST_END);
}


/*****************************************************************************
 * FUNCTION
 *  increment
 * DESCRIPTION
 *  Increments the global currHistoryIndex
 * PARAMETERS
 *  void
 * RETURNS
 *  S16 - Current history index
 *****************************************************************************/
static S16 increment(void)
{

    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    ++currHistoryIndex;
    MMI_ASSERT(currHistoryIndex < MAX_HISTORY);
    ++topHistoryIndex;
    MMI_ASSERT(topHistoryIndex < MAX_HISTORY);

    MMI_TRACE(PLUTO_FW_TRC_SCREEN, TRC_MMI_FRM_HIST_INC_HIST, currHistoryIndex, topHistoryIndex);
    return currHistoryIndex;
}


/*****************************************************************************
 * FUNCTION
 *  searched_history_node
 * DESCRIPTION
 *  The function is used for look up the history index mapped to a given screen id. 
 * PARAMETERS
 *  first_index     [IN] The index of the first history node to be searched.        
 *  scrn_id         [IN] Specifies the screen ID to be searched.       
 * RETURNS
 *  returns the index of the screen in history. If no such screen exists, 
 *  the function returns a negative.
 *****************************************************************************/ 
static S16 searched_history_node(S16 first_index, U16 scrn_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/ 
    while (first_index >= 0)
    {
        if (historyData[first_index].scrnID == scrn_id)
        {
            break;
        }
        --first_index;
    }
    return first_index;    
}


/*****************************************************************************  
*  active screen history Series APIs
*****************************************************************************/
static void *g_keep_user_data = NULL;
void mmi_frm_set_active_scrn_user_data(void* user_data)
{
    if (mmi_is_redrawing_bk_screens())
    {
        small_history_node = 0;
        return;
    }

    /* entry from mmi_frm_create_new_screen and we need to keep app_arg */
    g_keep_user_data = user_data;
}


void mmi_frm_create_active_scrn(U16 scrn_id, mmi_frm_scrn_type_enum scrn_type, exit_func_ptr exit_handler, entry_func_ptr entry_handler)
{
    U16 cb_idx = 0;
    HistoryDelCBPtr keep_destroy_func = NULL;

    if (mmi_is_redrawing_bk_screens())
    {
        small_history_node = 0;
        return;
    }

    _tmp_topHistoryIndex = topHistoryIndex;
    if (activeScrnIndex <= topHistoryIndex)
    {
        /* for first time handling */
        activeScrnIndex = topHistoryIndex + 1;
        newScrnIndex = activeScrnIndex;
    }
    else
    {
        newScrnIndex = activeScrnIndex + 1;
    }
    /* boundary check at begin, not running in unexpectedly statement */
    if(newScrnIndex >= MAX_HISTORY)
    {
        MMI_ASSERT(MMI_FALSE);
    }
    if (IsBackHistory)
    {
        /* goback history process, we need to get the user_data */
        g_keep_user_data = mmi_frm_get_argument_with_screen(scrn_id);
        keep_destroy_func = NULL;
        if (mmi_frm_get_scrn_idx(scrn_id, &cb_idx))
        {
            keep_destroy_func = historyData[cb_idx].destroyFuncPtr;
        }
    }
    MMI_TRACE(PLUTO_FW_TRC_SCREEN, TRC_MMI_FRM_HIST_CREATE_ACTIVE_SCRN, scrn_id, topHistoryIndex, currHistoryIndex, activeScrnIndex, newScrnIndex);

    memset(&historyData[newScrnIndex], 0, sizeof(historyNode));
    historyData[newScrnIndex].scrnID = scrn_id;
    if (scrn_type == MMI_FRM_TAB_PAGE)
    {
#ifdef HISTORY_TAB_MANGER
        historyData[newScrnIndex].isTab = 1;
#endif
    }
    else if (scrn_type == MMI_FRM_SCRN_GROUP)
    {
        historyData[newScrnIndex].isGroupNode = 1;
    }
    historyData[newScrnIndex].entryFuncPtr = entry_handler;
    historyData[newScrnIndex].exitFuncPtr = exit_handler;

    historyData[newScrnIndex].app_arg = g_keep_user_data;
    historyData[newScrnIndex].destroyFuncPtr = keep_destroy_func;
    g_keep_user_data = NULL;
}


void mmi_frm_update_active_scrn_from_new_scrn(void)
{
    if (mmi_is_redrawing_bk_screens())
    {
        small_history_node = 0;
        return;
    }

    /* entry new screen process finish and update activeScrnIndex & newScrnIndex */
    if (_tmp_topHistoryIndex == topHistoryIndex)
    {
        /* no add history process during entry new screen */
    }
    else
    {
        activeScrnIndex = topHistoryIndex + 1;
    }
#ifdef HISTORY_TAB_MANGER
    if (historyData[newScrnIndex].isTab)
    {
        /* current screen is MMI_FRM_TAB_PAGE */
        if (historyData[activeScrnIndex].isTab)
        {
            /*
             * If we aleady keep tab-page in history, we only update the tab-page info. */
            memcpy(&historyData[activeScrnIndex], &historyData[newScrnIndex], sizeof(historyNode));
            if (newScrnIndex > activeScrnIndex)
            {
                memset(&historyData[newScrnIndex], 0, sizeof(historyNode));
            }
            newScrnIndex = activeScrnIndex;
        }
        else
        {
            /* If entry tab-page first, we keep tab & tab-page in the history */
            activeScrnIndex = newScrnIndex;
        }
    }
    else if(newScrnIndex != activeScrnIndex)
#endif
    {
        memcpy(&historyData[activeScrnIndex], &historyData[newScrnIndex], sizeof(historyNode));
        if (newScrnIndex > activeScrnIndex)
        {
            memset(&historyData[newScrnIndex], 0, sizeof(historyNode));
        }
        newScrnIndex = activeScrnIndex;
    }
    MMI_TRACE(PLUTO_FW_TRC_SCREEN, TRC_MMI_FRM_HIST_UPDATE_ACTIVE_SCRN_FROM_NEW_SCRN, topHistoryIndex, currHistoryIndex, activeScrnIndex, newScrnIndex);
}


void mmi_frm_update_active_scrn(U16 scrn_id, MMI_BOOL is_tab, exit_func_ptr exit_handler, entry_func_ptr entry_handler, void* user_data)
{
    if (mmi_is_redrawing_bk_screens())
    {
        small_history_node = 0;
        return;
    }

    MMI_TRACE(PLUTO_FW_TRC_SCREEN, TRC_MMI_FRM_HIST_UPDATE_ACTIVE_SCRN, scrn_id, topHistoryIndex, currHistoryIndex, activeScrnIndex, newScrnIndex);

    memset(&historyData[activeScrnIndex], 0, sizeof(historyNode));

    historyData[activeScrnIndex].scrnID = scrn_id;
#ifdef HISTORY_TAB_MANGER
    historyData[activeScrnIndex].isTab = is_tab;
#endif
    historyData[activeScrnIndex].entryFuncPtr = entry_handler;
    historyData[activeScrnIndex].exitFuncPtr = exit_handler;
    historyData[activeScrnIndex].app_arg = user_data;
}


static void move_up_active_scrn_node(void)
{
    if (mmi_is_redrawing_bk_screens())
    {
        small_history_node = 0;
        return;
    }

    if (newScrnIndex != activeScrnIndex)
    {
#ifdef HISTORY_TAB_MANGER
        if (historyData[newScrnIndex].isTab)
        {
            /* If the screen is tab-page, we need to copy 2 history node */
            memcpy(&historyData[newScrnIndex + 1], &historyData[newScrnIndex], sizeof(historyNode));
            memcpy(&historyData[newScrnIndex], &historyData[newScrnIndex-1], sizeof(historyNode));
        }
        else
#endif
        {
            /* If the screen is normal, we need to copy 1 history node (active node) */
            memcpy(&historyData[newScrnIndex + 1], &historyData[newScrnIndex], sizeof(historyNode));
        }
        newScrnIndex++;
    }
#ifdef HISTORY_TAB_MANGER
    if (historyData[activeScrnIndex].isTab)
    {
        /* If the screen is tab-page, we need to copy 2 history node */
        memcpy(&historyData[activeScrnIndex + 1], &historyData[activeScrnIndex], sizeof(historyNode));
        memcpy(&historyData[activeScrnIndex], &historyData[activeScrnIndex-1], sizeof(historyNode));
    }
    else
#endif
    {
        /* If the screen is normal, we need to copy 1 history node (active node) */
        memcpy(&historyData[activeScrnIndex + 1], &historyData[activeScrnIndex], sizeof(historyNode));
    }
    activeScrnIndex++;
    if (newScrnIndex < activeScrnIndex)
    {
        /* If newScrnIndex is less than activeScrnIndex, we should adjust newScrnIndex */
        newScrnIndex = activeScrnIndex;
    }
}


static void move_down_active_scrn_node(void)
{
    S16 org_active_idx = activeScrnIndex;

    if (mmi_is_redrawing_bk_screens())
    {
        small_history_node = 0;
        return;
    }
#ifdef HISTORY_TAB_MANGER
    if (historyData[activeScrnIndex].isTab)
    {
        /* If the screen is tab-page, we need to copy 2 history node */
        memcpy(&historyData[topHistoryIndex + 1], &historyData[activeScrnIndex - 1], sizeof(historyNode)*2);
        if (activeScrnIndex > topHistoryIndex + 2)
        {
            memset(&historyData[activeScrnIndex], 0, sizeof(historyNode));
        }
        activeScrnIndex = topHistoryIndex + 2;
    }
    else
#endif
    {
        /* If the screen is normal, we need to copy 1 history node (active node) */
        memcpy(&historyData[topHistoryIndex + 1], &historyData[activeScrnIndex], sizeof(historyNode));
        if (activeScrnIndex > topHistoryIndex + 1)
        {
            memset(&historyData[activeScrnIndex], 0, sizeof(historyNode));
        }
        activeScrnIndex = topHistoryIndex + 1;
    }

    if (newScrnIndex != org_active_idx)
    {
#ifdef HISTORY_TAB_MANGER
        if (historyData[newScrnIndex].isTab)
        {
            /* If the screen is tab-page, we need to copy 2 history node */
            memcpy(&historyData[activeScrnIndex + 1], &historyData[newScrnIndex], sizeof(historyNode));
            memcpy(&historyData[activeScrnIndex], &historyData[newScrnIndex-1], sizeof(historyNode));
        }
        else
#endif
        {
            /* If the screen is normal, we need to copy 1 history node (active node) */
            memcpy(&historyData[activeScrnIndex + 1], &historyData[newScrnIndex], sizeof(historyNode));
        }
        newScrnIndex = activeScrnIndex + 1;
    }
    else
    {
        newScrnIndex = activeScrnIndex;
    }

}


MMI_BOOL mmi_frm_is_active_scrn_group_node(void)
{
    return (historyData[activeScrnIndex].isGroupNode) ? MMI_TRUE : MMI_FALSE;
}


/*****************************************************************************  
*  Add history Series APIs
*****************************************************************************/

MMI_BOOL AddHistory_Int(U16 scrnID, entry_func_ptr entryFuncPtr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /* 1. Check for OK pressed or BACK pressed */
    if (mmi_is_redrawing_bk_screens())
    {
        small_history_node = 0;
        return MMI_FALSE;
    }
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (IsBackHistory != MMI_TRUE)
    {
		/* 2. Check the added node is active screen */
		if (historyData[activeScrnIndex].scrnID == scrnID)
		{
			/* current active screen wants to add itself in the history */
			increment();
		}
		else
		{
			/* current active screen wants to insert another node in the history, and we need to adjust historyData[activeScrnIndex] */
			increment();
            move_up_active_scrn_node();
		}

        /* 3. Store History to History Data Structure */
        if (historyData[topHistoryIndex].scrnID != scrnID)
        {
            memset(&historyData[topHistoryIndex], 0, sizeof(historyNode));
            historyData[topHistoryIndex].scrnID = scrnID;
        }
        historyData[topHistoryIndex].entryFuncPtr = entryFuncPtr;
        if (!historyData[topHistoryIndex].isGroupNode)
        {
            /* If the screen is group node, we don't need to small screen flag. */
            historyData[topHistoryIndex].isSmallScreen = (U16) small_history_node;
        }
    }
    return MMI_TRUE;
}

/*****************************************************************************
 * FUNCTION
 *  AddHistoryReference
 * DESCRIPTION
 *  adds a history
 *  
 *  This is used to add a history
 * PARAMETERS
 *  addHistory      [IN]  Node to be added in history database.      
 * RETURNS
 *  void
 *****************************************************************************/
void AddHistoryReference(history *addHistory)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(addHistory == NULL || 
        !AddHistory_Int(addHistory->scrnID, (entry_func_ptr) addHistory->entryFuncPtr))
        return;

    MMI_TRACE(MMI_FW_TRC_G1_FRM, MMI_FRM_INFO_HIST_ADD_HISTREF_HDLR, (IsBackHistory != MMI_TRUE));

    if (IsBackHistory != MMI_TRUE)
    {
        S32 length = mmi_ucs2strlen((PS8) addHistory->inputBuffer);
        MMI_ASSERT(length * ENCODING_LENGTH + ENCODING_LENGTH <= MAX_INPUT_BUFFER);
        if (length)
        {
            historyData[topHistoryIndex].inputBuffer = OslMalloc(length * ENCODING_LENGTH + ENCODING_LENGTH);
            mmi_ucs2cpy((PS8) historyData[topHistoryIndex].inputBuffer, (PS8) addHistory->inputBuffer);
        }
        historyData[topHistoryIndex].guiBuffer = OslMalloc(MAX_GUI_BUFFER);
        memcpy(historyData[topHistoryIndex].guiBuffer, addHistory->guiBuffer, MAX_GUI_BUFFER);
        currHistoryIndex = topHistoryIndex;
    }
    small_history_node = 0;
    IsBackHistory = MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  AddNHistory_ext
 * DESCRIPTION
 *  This is used to add a history where user specifies the size
 * PARAMETERS
 *  addHistory      [IN]  Node to be added in history database.      
 *  size            [IN]  User specifies data size.      
 * RETURNS
 *  void
 *****************************************************************************/
void AddNHistory_ext(history *addHistory, U16 size)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(addHistory == NULL || 
        !AddHistory_Int(addHistory->scrnID, (entry_func_ptr) addHistory->entryFuncPtr))
        return;

    MMI_TRACE(MMI_FW_TRC_G1_FRM, MMI_FRM_INFO_HIST_ADD_NHIST_HDLR, size, (IsBackHistory != MMI_TRUE));
    if (IsBackHistory != MMI_TRUE)
    {
        if (size > 0) 
        {

            MMI_ASSERT(size + ENCODING_LENGTH + MMI_FRM_INPUT_BUFFER_HEADER_SIZE <= MAX_INPUT_BUFFER);
            historyData[topHistoryIndex].inputBuffer = OslMalloc(size + ENCODING_LENGTH + MMI_FRM_INPUT_BUFFER_HEADER_SIZE);
            memcpy(historyData[topHistoryIndex].inputBuffer, &size, MMI_FRM_INPUT_BUFFER_HEADER_SIZE);
            memcpy((PS8) (historyData[topHistoryIndex].inputBuffer + MMI_FRM_INPUT_BUFFER_HEADER_SIZE), (PS8) addHistory->inputBuffer, (U32) size);
        }
        else
        {
            historyData[topHistoryIndex].inputBuffer = NULL;
        }

        historyData[topHistoryIndex].guiBuffer = OslMalloc(MAX_GUI_BUFFER);
        memcpy(historyData[topHistoryIndex].guiBuffer, addHistory->guiBuffer, MAX_GUI_BUFFER);
        currHistoryIndex = topHistoryIndex;
    }
    small_history_node = 0;
    IsBackHistory = MMI_FALSE;

}


/*****************************************************************************
 * FUNCTION
 *  AddHistoryEx
 * DESCRIPTION
 *  adds a history with 
 *  
 *  The applications could assign the related function pointer
 *  and let the MMI framework to get history data
 * PARAMETERS
 *  scrnID                  [IN]  the screen id      
 *  entryFuncPtr            [IN]  the screen's entry function
 *  getGuiFuncPtr           [IN]  the function to get GUI data
 *  getInputBufSizeFuncPtr  [IN]  the function to get input buffer size 
 *  getInputBufFuncPtr      [IN]  the function to get input buffer
 *  mallocFuncPtr           [IN]  the function to allocate memory
 *  mfreeFuncPtr            [IN]  the function to free memory
 * RETURNS
 *  Always returns MMI_TRUE.
 *****************************************************************************/
MMI_BOOL mmi_frm_add_history(
            U16 scrn_id,                            /* the screen id */
            entry_func_ptr entryFuncPtr,            /* the screen's entry function */
            HistoryGetData getGuiFuncPtr,           /* the function to get GUI data */
            HistoryGetSize getInputBufSizeFuncPtr,  /* the function to get input buffer size */
            HistoryGetData getInputBufFuncPtr,      /* the function to get input buffer */
            MemAlloc mallocFuncPtr,                 /* the function to allocate memory */
            MemFree mfreeFuncPtr,                   /* the function to free memory */
            void* app_arg_p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 inputBuf_size;
	S32 gui_buffer_size;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if(!AddHistory_Int(scrn_id, (entry_func_ptr)entryFuncPtr))
        return MMI_TRUE;

    MMI_TRACE(MMI_FW_TRC_G1_FRM, TRC_MMI_FRM_HIST_ADD_HISTORY, scrn_id, (IsBackHistory != MMI_TRUE));
    if (IsBackHistory != MMI_TRUE)
    {
        MMI_ASSERT(getGuiFuncPtr);

		if (historyData[topHistoryIndex].isGroupNode)
		{
			historyData[topHistoryIndex].guiBuffer = NULL;
		}
		else
		{
			gui_buffer_size = (GetCategoryHistorySize) ? GetCategoryHistorySize() : MAX_GUI_BUFFER;
			gui_buffer_size = (gui_buffer_size > 0) ? gui_buffer_size : MAX_GUI_BUFFER;
			historyData[topHistoryIndex].guiBuffer = OslMalloc(gui_buffer_size);
			memset(historyData[topHistoryIndex].guiBuffer, 0, gui_buffer_size);
			getGuiFuncPtr(historyData[topHistoryIndex].guiBuffer);
		}
        historyData[topHistoryIndex].mallcFuncPtr = mallocFuncPtr;
        historyData[topHistoryIndex].mfreeFuncPtr = mfreeFuncPtr;
        historyData[topHistoryIndex].app_arg = app_arg_p;
        if (getInputBufSizeFuncPtr)
        {
            MMI_ASSERT(getInputBufFuncPtr);
            inputBuf_size = (S32)getInputBufSizeFuncPtr();

            if (inputBuf_size > 0)
            {
                if(mallocFuncPtr)
                {
                    /* Check memory free function pointer is valid */
                    MMI_ASSERT(mfreeFuncPtr);
                    historyData[topHistoryIndex].inputBuffer = (U8*)mallocFuncPtr(inputBuf_size + ENCODING_LENGTH + MMI_FRM_INPUT_BUFFER_HEADER_SIZE);
                 }
                else
                {
                    historyData[topHistoryIndex].inputBuffer = OslMalloc(inputBuf_size + ENCODING_LENGTH + MMI_FRM_INPUT_BUFFER_HEADER_SIZE);
                }
                memcpy(historyData[topHistoryIndex].inputBuffer, &inputBuf_size, MMI_FRM_INPUT_BUFFER_HEADER_SIZE);
                getInputBufFuncPtr(historyData[topHistoryIndex].inputBuffer + MMI_FRM_INPUT_BUFFER_HEADER_SIZE);
            }
            else
            {
                historyData[topHistoryIndex].inputBuffer = NULL;
            }
        }

        currHistoryIndex = topHistoryIndex;       
    }
    small_history_node = 0;
    IsBackHistory = MMI_FALSE;

    return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_frm_process_gui_buffer
 * DESCRIPTION
 *  Insert new screen into history node
 * PARAMETERS
 *  dst         [IN] Destination input buffer.
 *  src         [IN] Source input buffer.
 *  malloc_func [IN] Memory allocate function pointer.
 *  free_func   [IN] Memory release function pointer.
 * RETURNS
 *  void
 *****************************************************************************/
static MMI_BOOL mmi_frm_process_input_buffer(U8 **dst, U8 *src, MemAlloc malloc_func, MemFree free_func)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 inputbuff_size = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!src)
    {
        return MMI_FALSE;
    }

    inputbuff_size = mmi_ucs2strlen((PS8)src);
    if (inputbuff_size > 0)
    {
        if(malloc_func)
        {
            /* Check memory free function pointer is valid */
            MMI_ASSERT(free_func);
            *dst = (U8*)malloc_func(inputbuff_size * ENCODING_LENGTH + ENCODING_LENGTH);
         }
        else
        {
            *dst = OslMalloc(inputbuff_size * ENCODING_LENGTH + ENCODING_LENGTH);
        }
        mmi_ucs2cpy((PS8)*dst, (PS8)src);
    }

    return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_frm_process_gui_buffer
 * DESCRIPTION
 *  Insert new screen into history node
 * PARAMETERS
 *  dst      [IN] Destination gui buffer.
 *  src      [IN] Source gui buffer.
 * RETURNS
 *  void
 *****************************************************************************/
static MMI_BOOL mmi_frm_process_gui_buffer(U8 **dst, U8 *src)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!src)
    {
        return MMI_FALSE;
    }

    *dst = OslMalloc(MAX_GUI_BUFFER);
    memcpy(*dst, src, MAX_GUI_BUFFER);

    return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  load_scrn_struct_into_history_node
 * DESCRIPTION
 *  Insert new screen into history node
 * PARAMETERS
 *  histy_node      [IN] History index.
 *  scrn_struct     [IN] The node to be added to  history database.
 *  need_mem        [IN] Whether need allocate memory for gui or input buffer.
 * RETURNS
 *  void
 *****************************************************************************/
static void load_scrn_struct_into_history_node(historyNode *histy_node, const mmi_frm_screen_struct *scrn_struct, MMI_BOOL need_mem)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    histy_node->scrnID = scrn_struct->scrnID;
    histy_node->entryFuncPtr = (entry_func_ptr)scrn_struct->entryFuncPtr;
    histy_node->app_arg = scrn_struct->app_arg;
    histy_node->isSmallScreen = scrn_struct->isSmallScreen;
    histy_node->mallcFuncPtr = scrn_struct->mallcFuncPtr;
    histy_node->mfreeFuncPtr = scrn_struct->mfreeFuncPtr;
    if (need_mem)
    {
        mmi_frm_process_gui_buffer(&histy_node->guiBuffer, scrn_struct->guiBuffer);
        mmi_frm_process_input_buffer(&histy_node->inputBuffer, scrn_struct->inputBuffer, scrn_struct->mallcFuncPtr, scrn_struct->mfreeFuncPtr);
    }
    else
    {
        histy_node->guiBuffer = scrn_struct->guiBuffer;
        histy_node->inputBuffer = scrn_struct->inputBuffer;
    }
}


/*****************************************************************************
 * FUNCTION
 *  insert_history_by_idx
 * DESCRIPTION
 *  Insert new screen into history by history index
 * PARAMETERS
 *  insert_idx      [IN] The insert history index.
 *  scrn_struct     [IN] The node to be added to  history database.
 *      |---------------|   Top
 *      |    scrnId1    |
 *      |---------------|
 *      |  insert idx   |   History stack
 *      |---------------|
 *      |    scrnId2    |
 *      |---------------|   Bottom
 * RETURNS
 *  void
 *****************************************************************************/
static void insert_history_by_idx(S16 insert_idx, mmi_frm_screen_struct *scrn_struct)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(PLUTO_FW_TRC_SCREEN, TRC_MMI_FRM_HIST_INSERT_HIST_BY_IDX, insert_idx, scrn_struct->scrnID);
    /* Adjust history index to upper position */
    increment();
	/* shifting the active screen node first */
    move_up_active_scrn_node();

    /* Shifting all the nodes by one notch */
    for (i = currHistoryIndex; i > insert_idx; i--)
    {
        memcpy(&historyData[i], &historyData[i - 1], sizeof(historyNode));
    }

    /* Init elements since not all the attibutes will be inserted */
    memset(&historyData[insert_idx], 0, sizeof(historyNode));

    /* Insert new screen in history stack */
    load_scrn_struct_into_history_node(&historyData[insert_idx], scrn_struct, MMI_TRUE);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_frm_insert_screen
 * DESCRIPTION
 *  Insert new screen into history
 * PARAMETERS
 *  scrnId          [IN] The specified screen ID.
 *  scrn_struct     [IN] The node to be added to  history database.
 *  insert_type     [IN] The position need to insert.
 *      MMI_FRM_INSERT_BEFORE_SCRN means insert screen under designated screen in history stack;
 *      MMI_FRM_INSERT_AFTER_SCRN means insert screen up designated screen in history stack;
 *      |---------------|   Top
 *      |    After      |
 *      |---------------|
 *      |    scrnId     |   History stack
 *      |---------------|
 *      |    Before     |
 *      |---------------|   Bottom
 * RETURNS
 *  If the screen doesn't exist in history will return MMI_FALSE, 
 *  return MMI_TRUE if successfull.
 *****************************************************************************/
MMI_BOOL mmi_frm_insert_screen(U16 scrn_id, mmi_frm_screen_struct *scrn_struct, mmi_frm_insert_scrn_enum insert_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 insert_idx;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Find designated screen position */
    MMI_TRACE(MMI_FW_TRC_G1_FRM, TRC_MMI_FRM_HIST_INSERT_SCRN, scrn_id, scrn_struct->scrnID, insert_type);
    insert_idx = searched_history_node(currHistoryIndex, scrn_id);
    if (insert_idx < 0)
    {
        MMI_TRACE(MMI_FW_TRC_G1_FRM, TRC_MMI_FRM_HIST_INSERT_INSERT_SCRN_ERROR, insert_idx);
        return MMI_FALSE;
    }

    /* Adjust insert position */
    switch (insert_type)
    {
        case MMI_FRM_INSERT_BEFORE_SCRN:
            break;
        case MMI_FRM_INSERT_AFTER_SCRN:
            insert_idx++;
            break;
        default:
            MMI_ASSERT(0);
            return MMI_FALSE;
    }

    insert_history_by_idx(insert_idx, scrn_struct);

    return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  InsertHistoryBeforeThisScrnReference
 * DESCRIPTION
 *  Insert new screen into history before this screen
 * PARAMETERS
 *  scrnId          [IN] The specified screen ID.       
 *  addHistory      [IN] The node to be added to  history database.       
 * RETURNS
 *  If the screen doesn't exist in history will return MMI_FALSE, otherwise 
 *  return MMI_TRUE.
 *****************************************************************************/
void InsertHistoryBeforeThisScrnReference(U16 scrnId, history *addHistory)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_frm_screen_struct scrn_st = {0};

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
   
    MMI_TRACE(MMI_FW_TRC_G1_FRM, TRC_MMI_FRM_HIST_INSERT_HIST_BEFORE_SCREEN_HDLR, scrnId);

    if (addHistory != NULL)
    {
        scrn_st.scrnID = addHistory->scrnID;
        scrn_st.entryFuncPtr = (entry_func_ptr)addHistory->entryFuncPtr;
        scrn_st.inputBuffer = (U8*)addHistory->inputBuffer;
        scrn_st.guiBuffer = (U8*)addHistory->guiBuffer;

        mmi_frm_insert_screen(scrnId, &scrn_st, MMI_FRM_INSERT_BEFORE_SCRN);
    }
}


/*****************************************************************************
 * FUNCTION
 *  InsertHistoryAfterThisScrnReference
 * DESCRIPTION
 *  Insert new screen into history after this screen
 * PARAMETERS
 *  scrnId          [IN] The specified screen ID.       
 *  addHistory      [IN] The node to be added to  history database.       
 * RETURNS
 *  If the screen doesn't exist in history will return MMI_FALSE, otherwise 
 *  return MMI_TRUE.
 *****************************************************************************/
MMI_BOOL InsertHistoryAfterThisScrnReference(U16 scrnId, history *addHistory)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_frm_screen_struct scrn_st = {0};

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_FW_TRC_G1_FRM, TRC_MMI_FRM_HIST_INSERT_HIST_AFTER_SCREEN_HDLR, scrnId);
       
    if (addHistory != NULL)
    {
        scrn_st.scrnID = addHistory->scrnID;
        scrn_st.entryFuncPtr = (entry_func_ptr)addHistory->entryFuncPtr;
        scrn_st.inputBuffer = (U8*)addHistory->inputBuffer;
        scrn_st.guiBuffer = (U8*)addHistory->guiBuffer;
   
        return mmi_frm_insert_screen(scrnId, &scrn_st, MMI_FRM_INSERT_AFTER_SCRN);
    }

    return MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_frm_init_screen_struct
 * DESCRIPTION
 *  Initialze screen struct node created by user.
 *  This interface must be invoked before user fill information into history node
 *  and invoke interface of add history, insert history and replace history.
 * PARAMETERS
 *  screen_struct         [IN]  Screen struct pointer.
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_frm_init_screen_struct(mmi_frm_screen_struct *screen_struct)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_FW_TRC_G1_FRM, TRC_MMI_FRM_HIST_INIT_SCRN_STRUCT, screen_struct->scrnID);

    memset(screen_struct, 0, sizeof(mmi_frm_screen_struct));
}
  

/*****************************************************************************
 * FUNCTION
 *  mmi_frm_history_replace
 * DESCRIPTION
 *  HistoryReplace will be used for a exist history
 * PARAMETERS
 *  out_scrn_id     [IN]  Specify the Screen ID wants to be replaced.      
 *  in_scrn_id      [IN]  Specify the new Screen ID that wants to be replace with.      
 *  in_src_func     [IN]  The entry function of the new screen.       
 * RETURNS
 *  Returns MMI_TRUE if replace the specified history node succeed; MMI_FALSE otherwise.
 *****************************************************************************/
MMI_BOOL mmi_frm_history_replace(U16 out_scrn_id, U16 in_scrn_id, entry_func_ptr in_src_func)
{

    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 index = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_FW_TRC_G1_FRM, TRC_MMI_FRM_HIST_REPLACE, out_scrn_id, in_scrn_id);
    index = searched_history_node(currHistoryIndex, out_scrn_id);

    if (index >= 0)
    {
        ClearDelScrnIDCallbackHandler(out_scrn_id, NULL);
        mmi_free_history_buffer(index);
        historyData[index].scrnID = in_scrn_id;
        historyData[index].entryFuncPtr = in_src_func;

        return MMI_TRUE;
    }
    MMI_TRACE(MMI_FW_TRC_G1_FRM, TRC_MMI_FRM_HIST_REPLACE_ERROR, out_scrn_id, in_scrn_id);

    return MMI_FALSE;    

}


MMI_BOOL HistoryReplace(U16 out_scrn_id, U16 in_scrn_id, FuncPtr in_src_func)
{
    return  mmi_frm_history_replace(out_scrn_id, in_scrn_id, (entry_func_ptr)in_src_func);
}


MMI_BOOL mmi_frm_move_history_node_to_top(U16 scrn_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 idx;
    historyNode tmp;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    /* Find designated screen position */
    idx = searched_history_node(currHistoryIndex, scrn_id);
    if (idx < 0)
    {
        return MMI_FALSE;
    }
    /* Copy the target history node to the temp buffer */
    memcpy(&tmp, &historyData[idx], sizeof(historyNode));
    /* Shift historyData[] content */
    memmove(&historyData[idx], &historyData[idx +1], (currHistoryIndex-idx)*sizeof(historyNode));
    /* Copy the temp buffer to the top of historyData[] */
    memcpy(&historyData[currHistoryIndex], &tmp, sizeof(historyNode));

    return MMI_TRUE;
}


/*****************************************************************************  
*  Go Back Series APIs
*****************************************************************************/

/*****************************************************************************
 * FUNCTION
 *  mmi_go_back_to_history
 * DESCRIPTION
 *  This is used to goback previous screen history from screen group. (internal use only)
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_go_back_to_history(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_FW_TRC_G1_FRM, TRC_MMI_FRM_HIST_GO_BACK_HIST_HDLR);
    if (currHistoryIndex < 0)
    {
        return;
    }
    mmi_frm_go_back_to_history_int(historyData[currHistoryIndex].scrnID);
}


/*****************************************************************************
 * FUNCTION
 *  GoBackToHistory
 * DESCRIPTION
 *  Goes back to specified screen
 * PARAMETERS
 *  scrnid      [IN]  Screen ID of screen which needs to be displayed.        
 * RETURNS
 *  Returns ST_SUCCESS if go back to the specified history succeed; ST_FAILURE otherwise.
 *****************************************************************************/
U8 GoBackToHistory(U16 scrnid)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    /* this API doesn't support in screen group mechanism */

    if (mmi_is_redrawing_bk_screens())
    {
        return ST_SUCCESS;
    }

    MMI_TRACE(MMI_FW_TRC_G1_FRM, TRC_MMI_FRM_HIST_GO_BACK_TO_HIST_HDLR, scrnid);

    return mmi_frm_go_back_to_history_int(scrnid);
}


/*****************************************************************************
 * FUNCTION
 *  GoBacknHistory
 * DESCRIPTION
 *  Goes 'n' screens back
 * PARAMETERS
 *  nHistory        [IN] Number of screens one want to go back.       
 * RETURNS
 *  Returns ST_SUCCESS if go back to the specified history succeed; ST_FAILURE otherwise.
 *****************************************************************************/
U8 GoBacknHistory(U16 nHistory)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 pos = currHistoryIndex - (S16)nHistory;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    /* this API doesn't support in screen group mechanism */

    if (mmi_is_redrawing_bk_screens())
    {
        return ST_SUCCESS;
    }

    MMI_TRACE(MMI_FW_TRC_G1_FRM, TRC_MMI_FRM_HIST_GO_BACK_NHIST_HDLR, nHistory);
    if( pos < 0 )
        pos = 0;
    pos = mmi_frm_go_back_to_history_int(historyData[pos].scrnID);
    mmi_frm_execute_scenario_post_event();
    return (U8)pos;
}


/*****************************************************************************
 * FUNCTION
 *  GoBeyondMarkerScr
 * DESCRIPTION
 *  This function deletes the history nodes from the current node up to the node
 *  corresponding to specified Screen ID and execute the entry function of the 
 *  node beyond it. The screen ID should be in the history database, or the 
 *  function will return fail.
 * PARAMETERS
 *  scrnid      [IN] Screen ID of screen beyond which one want to go and execute the Entry Function of that screen.       
 * RETURNS
 *  Returns ST_SUCCESS if go back to the specified history succeed; ST_FAILURE otherwise. 
 *****************************************************************************/
U8 GoBeyondMarkerScr(U16 scrnid)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 beyond_screen;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    /* this API doesn't support in screen group mechanism */

    if (mmi_is_redrawing_bk_screens())
    {
        return ST_SUCCESS;
    }

    MMI_TRACE(MMI_FW_TRC_G1_FRM, MMI_FRM_INFO_GO_BEYOND_MARKER_SCR_HDLR, scrnid, currHistoryIndex);

    if (!GetPreviousScrnIdOf(scrnid, &beyond_screen))
    {
        return ST_FAILURE;
    }

    return mmi_frm_go_back_to_history_int(beyond_screen);
}

U8 mmi_frm_history_back_to_idle(void)
{
    U8 Status = ST_SUCCESS;
    g_is_back_root_main_hist = MMI_TRUE;
    Status = mmi_frm_go_back_to_history_int(historyData[0].scrnID);
    g_is_back_root_main_hist = MMI_FALSE;
    return Status;
}

/*****************************************************************************
 * FUNCTION
 *  ExecuteRootMainHistoryScreen
 * DESCRIPTION
 *  To execute the root history screen.
 * PARAMETERS
 *  funcPtr     [IN]        Reserve not use
 * RETURNS
 *  Returns ST_SUCCESS if go back to the specified history succeed; ST_FAILURE otherwise. 
 *****************************************************************************/
U8 ExecuteRootMainHistoryScreen(void *funcPtr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 Status = ST_SUCCESS;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/  
    if (mmi_is_redrawing_bk_screens())
    {
        return ST_SUCCESS;
    }
    if (currHistoryIndex == -1)
    {
        return ST_SUCCESS;
    }    
    MMI_TRACE(MMI_FW_TRC_G1_FRM, TRC_MMI_FRM_HIST_EXECUTEROOTMAINHISTSCRN, historyData[0].scrnID);
    Status = mmi_frm_scenario_close_to_idle();

    return Status;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_frm_is_in_end_key_process
 * DESCRIPTION
 *  Check if it is in end key process (back to idle screen)
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_TRUE: it is in end key process now.
 *  MMI_FALSE: it isn't in end key process.
 *****************************************************************************/
MMI_BOOL mmi_frm_is_in_end_key_process(void)	//gilbert
{
    return g_is_back_root_main_hist;
}


/*****************************************************************************
 * FUNCTION
 *  decrement_current_history_index
 * DESCRIPTION
 *  Decrements the global currHistoryIndex to the topmost normal history node
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void decrement_current_history_index(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    while (currHistoryIndex >= 0 && (historyData[currHistoryIndex].status != MMI_HIST_NODE_NORMAL))
    {
         currHistoryIndex--;
         MMI_TRACE(PLUTO_FW_TRC_SCREEN, TRC_MMI_FRM_HIST_DECREMENT_CURRHIST_IDX, currHistoryIndex);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_frm_go_back_to_history_int
 * DESCRIPTION
 *  Goes back to specified screen
 * PARAMETERS
 *  scrnid      [IN]  Screen ID of screen which needs to be displayed.        
 * RETURNS
 *  void
 *****************************************************************************/
static U8 mmi_frm_go_back_to_history_int(U16 scrnid)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 Status = ST_FAILURE;
    U16 del_count;
    U8 res;

    MMI_BOOL b_is_back_to_top_screen = MMI_FALSE;
    MMI_BOOL is_stop = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_is_redrawing_bk_screens())
    {
        return ST_SUCCESS;
    }

    MMI_TRACE(MMI_FW_TRC_G1_FRM, TRC_MMI_FRM_HIST_GOBACKTOHIST_BEGIN, scrnid, get_active_history_node_id(), get_exit_history_node_id());

    if (scrnid == historyData[currHistoryIndex].scrnID)
    {
        /* This is GoBackHistory case */
        b_is_back_to_top_screen = MMI_TRUE;
    }

    /* To make sure the callback will run at topist screen, and callback for APP */
    res = ExecTopScrnCallbackHandler();

    if (historyData[activeScrnIndex].isGroupNode)
    {
        if (res == MMI_HIST_STOP_DELETING)
        {
            is_stop = MMI_TRUE;
            if (g_is_stop_when_forbiden)
            {
                return ST_FAILURE;
            }
        }
    }

    if (currHistoryIndex <= 0)
    {
        if (historyData[0].entryFuncPtr)
        {
            currHistoryIndex = 0;
            Status =  ST_SUCCESS;
        }
        else
        {
            return ST_FAILURE;
        }
    }

    /*
     * In GoBackHistory Case:
     * Because the application may delete the top screen in ExecTopScrnCallbackHandler(), 
     * we need to goback the top screen continuely. (MAUI_01389592)
     */
    if (b_is_back_to_top_screen == MMI_FALSE)
    {
        /* 
         * In GoBackToHistory, GoBacknHistory, GoBeyondMarkerScr, ExecuteRootMainHistoryScreen cases:
         * We will try to find the target screen and do the delete history. 
         * If the target screen can't be found in the history, we will back to history[0] screen.
         */
        if (IsScreenPresent(scrnid))
        {        
            DeleteHistoryInt(MMI_HIST_TOP_SCREEN, 1, 0, scrnid, 0, MMI_HIST_DISABLE_DESTROY_HANDLER, &del_count);

            if (historyData[currHistoryIndex].scrnID == scrnid)
            {
                Status =  ST_SUCCESS;
            }
        }
        else
        {
            DeleteHistoryInt(MMI_HIST_TOP_SCREEN, 1, 0, historyData[0].scrnID, 0, MMI_HIST_DISABLE_DESTROY_HANDLER, &del_count);
        }
    }
    if (is_stop == MMI_TRUE)
    {
        decrement_current_history_index();
        mmi_frm_exec_scrn_wait_to_destroy_hdlr(MMI_HIST_NODE_WAIT_TO_DESTROY);
        move_down_active_scrn_node();
        return ST_FAILURE;
    }

    /* Start to goback history procedure */
    IsBackHistory = MMI_TRUE;
    CheckMainLCDHistoryBack = MMI_TRUE;
    bBackHistoryFlag = MMI_TRUE;

    if (goback_reentry_count == 0)
    {
        /* first enter goback history procedure  */
    #ifdef __MMI_INTERACTIVE_PROFILNG__
        mmi_frm_profiling_interactive_start();
    #endif
    }
    goback_reentry_count++;
    decrement_current_history_index();
    /* Goback->delete will have gobacking&deleting nodes, index should point to the top normal node (MAUI_01389581)*/
    if (historyData[currHistoryIndex].entryFuncPtr && currHistoryIndex > 0)
    {
    #ifdef HISTORY_TAB_MANGER
        U16 id;
    #endif
        /* Redraw background:
         * Trigger background redraw only if the top history node is not a grope node.
         * The background redraw will be triggered in scrn_active for the case that top history node 
         * is a gorup node scrn_active
         */
        if (historyData[currHistoryIndex].isGroupNode == 0 && historyData[currHistoryIndex].isSmallScreen)
        {
            if (mmi_frm_get_scrn_idx(get_exit_history_node_id(), &top_scrn_in_go_back_id))
            {
                top_scrn_in_go_back_destroy_func = historyData[top_scrn_in_go_back_id].destroyFuncPtr;
                top_scrn_in_go_back_arg_p = mmi_frm_get_exit_scrn_arg();
                top_scrn_in_go_back_id = get_exit_history_node_id();
            }
            if (historyData[currHistoryIndex].isGroupNode == 0)
                mmi_frm_redraw_bg();
        }
        IsBackHistory = MMI_TRUE;
        CheckMainLCDHistoryBack = MMI_TRUE;
        /* Goback->delete will have gobacking&deleting nodes, index should point to the top normal node */
        decrement_current_history_index();
    #ifdef HISTORY_TAB_MANGER
        id = historyData[currHistoryIndex].scrnID;
    #endif
        mmi_frm_set_history_node_status(currHistoryIndex, MMI_HIST_NODE_GOBACKING);
        mmi_frm_set_active_scrn_arg(historyData[currHistoryIndex].app_arg);

        MMI_TRACE(MMI_FW_TRC_G1_FRM, TRC_MMI_FRM_HIST_GOBACKTOHIST_ENTRY, historyData[currHistoryIndex].scrnID, historyData[currHistoryIndex].entryFuncPtr, historyData[currHistoryIndex].app_arg);
        (*(historyData[currHistoryIndex].entryFuncPtr)) (historyData[currHistoryIndex].app_arg);

        /* 
         * Tab history buffer should be freed in delete callback when being deleted, exited.
         * If tab screen is in top of history stack, when gobackhistory, for normal case,
         * app will enter tab entry function and tab history will be gotten from history->guibuffer, 
         * but some application didn't enter tab screen directly,
         * it send primitive and enter tab screen when receiving response,
         * then history->guibuffer is freed in goback process, but tab history buffer is leaked,
         * so we need to release tab group memory for this case.
         */
#ifdef HISTORY_TAB_MANGER
        if (id == historyData[currHistoryIndex].scrnID && historyData[currHistoryIndex].isTab
			&& !mmi_frm_is_tab_info_loaded())
        {/* The first condition may not match if entryfunc delete history and index shift */
			mmi_frm_reset_tab_history(historyData[currHistoryIndex].scrnID);
        }
#endif
        decrement_current_history_index();
    }
    else if (currHistoryIndex == 0)
    {
        /*
         * Some index[0] screen will execute DinitHistory() to free historyData[0] data,
         * and add its screen info. into history[0].
         * ex. EntryIdleScreen, EntryScrnSimErrorScreen, EntryScrnSimBlockRsp, ...
         * We don't need to free history node here again.
         */
        /* To make sure the callback will run at topist screen */
        //ExecTopScrnCallbackHandler();
        /* Go to idle screen */
        currHistoryIndex = -1;
        if ((historyData[0].entryFuncPtr))
        {
			mmi_frm_set_history_node_status(0, MMI_HIST_NODE_GOBACKING);
			mmi_frm_set_active_scrn_arg(historyData[0].app_arg);
            (*(historyData[0].entryFuncPtr)) (historyData[0].app_arg);
        }
        IsBackHistory = MMI_FALSE;
    }

    /*
     * We change the small screen procedure state here.
     * When we execute the last entry function, 
     * it also executed the previous exit function.
     * We still don't want to add the history in that case.
     */
    mmi_set_redrawing_bk_screens_status(MMI_HIST_SMALLSCREEN_NONE);

    goback_reentry_count--;

    if (0 == goback_reentry_count)
    {
        MMI_TRACE(MMI_FW_TRC_G1_FRM, TRC_MMI_FRM_HIST_GOBACKTOHIST_REMOVE, scrnid);
        mmi_frm_remove_history_node(MMI_HIST_NODE_GOBACKING);
    #ifdef __MMI_INTERACTIVE_PROFILNG__
        mmi_frm_profiling_interactive_end();
        mmi_frm_profiling_interactive_show((U8*) L"S", MMI_FRM_PROFILING_MASK_1);
    #endif /* __MMI_INTERACTIVE_PROFILNG__ */ 
        top_scrn_in_go_back_id = SCR_ID_INVALID;
        top_scrn_in_go_back_destroy_func = NULL;
        top_scrn_in_go_back_arg_p = NULL;
    }
    else
    {/* history node status maybe set gobacking, should adjust history index */
        decrement_current_history_index();
    }

    IsBackHistory = MMI_FALSE;
    CheckMainLCDHistoryBack = MMI_FALSE;
    bBackHistoryFlag = MMI_FALSE;

    MMI_TRACE(MMI_FW_TRC_G1_FRM, TRC_MMI_FRM_HIST_GOBACKTOHIST_END);

    return Status;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_frm_set_history_node_status
 * DESCRIPTION
 *  Set status of history node
 * PARAMETERS
 *  index      [IN]  history index.
 *  status     [IN]  status to be set.
 * RETURNS
 *  status
 *****************************************************************************/
static mmi_history_node_status_enum mmi_frm_set_history_node_status(U16 index, mmi_history_node_status_enum status)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i = index;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (MMI_HIST_NODE_GOBACKING != historyData[i].status)
    {
        MMI_TRACE(PLUTO_FW_TRC_SCREEN, TRC_MMI_FRM_HIST_SET_HISTO_STATUS, i, historyData[i].status, status);
         historyData[i].status = status;         
    }
    else if ((MMI_HIST_NODE_GOBACKING == status) && goback_reentry_count > 1)
    {
        while(i-- >= 0)
        {
            if (MMI_HIST_NODE_NORMAL == historyData[i].status)
            {
                MMI_TRACE(PLUTO_FW_TRC_SCREEN, TRC_MMI_FRM_HIST_SET_HISTO_STATUS_GB, i, status);

                historyData[i].status = MMI_HIST_NODE_GOBACKING;
                return  MMI_HIST_NODE_GOBACKING;               
            }
        }
        MMI_TRACE(PLUTO_FW_TRC_SCREEN, TRC_MMI_FRM_HIST_SET_HISTO_STATUS_GB_RET, i, historyData[i].status, status, goback_reentry_count);
        return MMI_HIST_NODE_NORMAL;
    }
    MMI_TRACE(PLUTO_FW_TRC_SCREEN, TRC_MMI_FRM_HIST_SET_HISTO_STATUS_RET, historyData[i].status);

    return historyData[i].status;

}


/*****************************************************************************
 * FUNCTION
 *  mmi_frm_remove_history_node
 * DESCRIPTION
 *  Removes the nodes which match the specific status 
 * PARAMETERS
 *  status  [in] The status which wants to remove.
 * RETURNS
 *  The number of removed nodes.
 *****************************************************************************/
static U16 mmi_frm_remove_history_node(mmi_history_node_status_enum status)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 index, count = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(MMI_HIST_NODE_NORMAL != status);

    if (currHistoryIndex > topHistoryIndex)
    {
        currHistoryIndex = topHistoryIndex;
    }

    /*(1) Searchs the node which matchs the specific status  */
    for (index = topHistoryIndex; index >= 0;  index--)
    {
        if (historyData[index].status == status)
        {
            MMI_TRACE(PLUTO_FW_TRC_SCREEN, TRC_MMI_FRM_HIST_REMOVE_HIST_NODE, status, index);
            /*(2) Deletes this node*/
            mmi_free_history_buffer(index);
            memset(&historyData[index], 0, sizeof(historyNode));
            count++;

            /*(3) Moves upper nodes to here */
            if (index < topHistoryIndex)
            {
               memmove(&historyData[index], &historyData[index +1], (topHistoryIndex-index)*sizeof(historyNode));
    		   memset(&historyData[topHistoryIndex], 0, sizeof(historyNode));
            }                    
            topHistoryIndex--;
            _tmp_topHistoryIndex--;

            if (currHistoryIndex > topHistoryIndex)
            {
                currHistoryIndex = topHistoryIndex;
            }

            while ((currHistoryIndex >= 0) && (historyData[currHistoryIndex].status != MMI_HIST_NODE_NORMAL))
            {
                currHistoryIndex--;
            }
        }
    }

    /* update historyData[activeScrnIndex] */
    move_down_active_scrn_node();
 
    return count;

}


/*****************************************************************************
 * FUNCTION
 *  mmi_free_history_buffer
 * DESCRIPTION
 *  Free history GUI buffer and Input buffer
 * PARAMETERS
 *  id         [IN]  Index of history node which want to free. 
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_free_history_buffer(S16 id)
{

    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/ 
    if ((id >= 0) && (id <= topHistoryIndex))
    {
        if (historyData[id].guiBuffer)
        {
            OslMfree(historyData[id].guiBuffer);
            historyData[id].guiBuffer = NULL;
        }
        if (historyData[id].inputBuffer)
        {
            if (historyData[id].mfreeFuncPtr)
            {
                historyData[id].mfreeFuncPtr(historyData[id].inputBuffer);
            }
            else
            {
                OslMfree(historyData[id].inputBuffer);
            }
            historyData[id].inputBuffer = NULL;
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_frm_check_is_back_history
 * DESCRIPTION
 *  Is in GoBackHistory
 *  
 *  This is typically used by entry function
 * PARAMETERS
 *  void
 * RETURNS
 *  Returns MMI_TRUE if in GoBackHistory; MMI_FALSE otherwise.
 *****************************************************************************/
MMI_BOOL mmi_frm_check_is_back_history(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return bBackHistoryFlag;
}


/*****************************************************************************
 * FUNCTION
 *  CheckIsBackHistory
 * DESCRIPTION
 *  Is in GoBackHistory in original screen-histroy mech. or in screen group mech.
 *  
 *  This is typically used by entry function
 * PARAMETERS
 *  void
 * RETURNS
 *  Returns MMI_TRUE if in GoBackHistory; MMI_FALSE otherwise.
 *****************************************************************************/
MMI_BOOL CheckIsBackHistory(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return mmi_frm_is_in_backward_scenario();
}


/*****************************************************************************
 * FUNCTION
 *  IsMainLCDHistoryBack
 * DESCRIPTION
 *  Queries MainLCD history is back now or not
 * PARAMETERS
 *  void
 * RETURNS
 *  Returns MMI_TRUE if the MainLCD history is back now ; MMI_FALSE otherwise.
 *****************************************************************************/
MMI_BOOL IsMainLCDHistoryBack(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return CheckMainLCDHistoryBack;

}


/*****************************************************************************
 * FUNCTION
 *  mmi_set_orderly_exit_screen
 * DESCRIPTION
 *  Called by app to tell history that the screen will use the orderly exit 
 *  mechanism, namely calls the active screen's delete callback function and 
 *  exit function at first when goes back to specified screen.   
 * PARAMETERS
 *  void     
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_set_orderly_exit_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
}



/*****************************************************************************  
*  Delete Screen Callback Series APIs
*****************************************************************************/

/*****************************************************************************
 * FUNCTION
 *  SetDelScrnIDCallbackHandler
 * DESCRIPTION
 *  This function is used for register callback function when deleting or exiting
 *  the screens. In some special cases, the application may want to know it screen
 *  is destroyed (exit the screen or delete by other screens). Sometimes, the 
 *  application may want to delete the screens in the history stack, but these 
 *  screens may need to release the resource or not allow for deleting. These 
 *  kind of screens should register history delete callback function, and if the
 *  screen can't be deleted, the function should return MMI_TRUE. 
 * PARAMETERS
 *  ScrnID      [IN]  Specify the Screen ID that  wants to register delete callback function      
 *  funcPtr     [IN]  Pointer to the delete callback function to be registered.      
 * RETURNS
 *  Returns MMI_TRUE if set the delete callback function succeed; MMI_FALSE otherwise.
 *****************************************************************************/
U8 SetDelScrnIDCallbackHandler(U16 ScrnID, HistoryDelCBPtr funcPtr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    MMI_TRACE(PLUTO_FW_TRC_SCREEN, MMI_FRM_INFO_SET_SCREEN_ID_CB_HDLR, ScrnID, funcPtr);

    /* MTK added by JL for history callback */
    for (count = 0; count < MAX_HISTORY; count++)
    {
        /* add new one, while scrnID and historydelCBPtr is NULL, means not found we can add a new one. */
        if ((historyCBHandler[count].scrnID == 0) && (historyCBHandler[count].historydelCBPtr == NULL))
        {
            historyCBHandler[count].scrnID = ScrnID;
            historyCBHandler[count].historydelCBPtr = funcPtr;
            return MMI_TRUE;
        }

        /* already exist, to overwrite, while ScrnID and funcPtr are not NULL, and fount ScrnID. */
        /*
         * Leo remove, each screen can only have one callback.
         * if ( (historyCBHandler[count].scrnID == ScrnID) && (historyCBHandler[count].historydelCBPtr != NULL) )
         */
        if (historyCBHandler[count].scrnID == ScrnID)
        {
            historyCBHandler[count].historydelCBPtr = funcPtr;
            return MMI_TRUE;
        }
    }

    MMI_ASSERT(MMI_FALSE);

    return MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  ClearDelScrnIDCallbackHandler
 * DESCRIPTION
 *  Clear callback fucntion for delete screen occur.
 * PARAMETERS
 *  ScrnID      [IN] Specify the Screen ID that  wants to remove the registered delete callback function        
 * RETURNS
 *  Returns MMI_TRUE if succeed; MMI_FALSE otherwise.
 *****************************************************************************/
U8 ClearDelScrnIDCallbackHandler(U16 ScrnID, HistoryDelCBPtr funcPtr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 index;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    /* MTK added by JL for history callback */
    for (index = 0; index < MAX_HISTORY; index++)
    {
        /* found the delete one. */
        if (historyCBHandler[index].scrnID == ScrnID)
        {
            break;
        }
    }
    if( index >= MAX_HISTORY )
        return 0;
    MMI_TRACE(PLUTO_FW_TRC_SCREEN, MMI_FRM_INFO_CLR_SCREEN_ID_CB_HDLR, ScrnID, historyCBHandler[index].historydelCBPtr);

    historyCBHandler[index].scrnID = 0;
    historyCBHandler[index].historydelCBPtr = NULL;
    if( (index+1) < MAX_HISTORY )
    {
        memmove(&historyCBHandler[index], &historyCBHandler[index+1],(MAX_HISTORY-index-1)*sizeof(historyCallback));
    }

    return 0;
}


/*****************************************************************************
 * FUNCTION
 *  SearchDelScrnIDCallbackHandler
 * DESCRIPTION
 *  Search index of the delete callback screen.
 * PARAMETERS
 *  ScrnID          [IN]  Specify the Screen ID that wants to search.      
 *  found_idx       [OUT] The index of the delete callback screen.       
 * RETURNS
 *  Returns MMI_TRUE if found the index of the delete callback screen; MMI_FALSE otherwise.
 *****************************************************************************/
static U8 SearchDelScrnIDCallbackHandler(U16 ScrnID, U16 *found_idx)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if (mmi_is_redrawing_bk_screens())
    {
        return MMI_FALSE;
    }

    for (count = 0; count < MAX_HISTORY; count++)
    {
        /* found the delete one. */
        if (historyCBHandler[count].scrnID == ScrnID)
        {
            MMI_TRACE(PLUTO_FW_TRC_SCREEN, MMI_FRM_INFO_SRCH_DEL_SCRN_CB_HDLR, ScrnID, count);

            *found_idx = count;
            return MMI_TRUE;
        }
        /* because historyCBHandler[] data is not exist gap */
        if (historyCBHandler[count].scrnID == 0)
	        break;
    }

    return MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_frm_set_destroy_scrn_callback
 * DESCRIPTION
 *  The application could use this API to register screen's destroy callback function.
 *  Situation: 
 *    1. Go back history and then the screen is gone; 
 *    2. delete the screen in the history
 * PARAMETERS
 *  
 * RETURNS
 *  
 *****************************************************************************/ 
MMI_BOOL mmi_frm_set_destroy_scrn_callback(U16 scrn_id, HistoryDelCBPtr func_ptr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_FW_TRC_G1_FRM, TRC_MMI_FRM_HIST_SET_DESTROY_SCRN_CB, scrn_id, func_ptr);
    for (count = 0; count < MAX_HISTORY; count++)
    {
        if (historyData[count].scrnID == scrn_id && historyData[count].status == MMI_HIST_NODE_NORMAL)
        {
            historyData[count].destroyFuncPtr = func_ptr;

            return MMI_TRUE;
        }
    }

    MMI_ASSERT(MMI_FALSE);

    return MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_frm_clear_destroy_scrn_callback
 * DESCRIPTION
 *  Clear the screen's destroy callback fucntion.
 * PARAMETERS
 *  ScrnID      [IN] Specify the Screen ID that  wants to remove the registered delete callback function        
 * RETURNS
 *  Returns MMI_TRUE if succeed; MMI_FALSE otherwise.
 *****************************************************************************/
static U8 mmi_frm_clear_destroy_scrn_callback(U16 scrn_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_FW_TRC_G1_FRM, TRC_MMI_FRM_HIST_CLEAR_DESTROY_SCRN_CB, scrn_id);
    for (count = 0; count < MAX_HISTORY; count++)
    {
        /* found the delete one. */
        if (historyData[count].scrnID == scrn_id && historyData[count].status == MMI_HIST_NODE_NORMAL)
        {
            historyData[count].destroyFuncPtr = NULL;
            return MMI_TRUE;
        }
    }
    return MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_frm_get_scrn_idx
 * DESCRIPTION
 *  Search index of the destroy callback from history_destroy_hdlr_array[]
 * PARAMETERS
 *  ScrnID          [IN]  Specify the Screen ID that wants to search.      
 *  found_idx       [OUT] The index of the delete callback screen.       
 * RETURNS
 *  Returns MMI_TRUE if found the index of the delete callback screen; MMI_FALSE otherwise.
 *****************************************************************************/
static MMI_BOOL mmi_frm_get_scrn_idx(U16 scrn_id, U16 *found_idx)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if (mmi_is_redrawing_bk_screens())
    {
        return MMI_FALSE;
    }

    for (count = 0; count < MAX_HISTORY; count++)
    {
        /* found the delete one. */
        if (historyData[count].scrnID == scrn_id)
        {
            MMI_TRACE(PLUTO_FW_TRC_SCREEN, TRC_MMI_FRM_SRCH_DEL_SCRN_CB_HDLR, scrn_id, count);
            *found_idx = count;
            return MMI_TRUE;
        }
    }

    return MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_frm_exec_scrn_destroy_hdlr
 * DESCRIPTION
 *  Execute the screen's destroy callback function with the argument
 * PARAMETERS
 *  scrn_id         [IN] The screen id of destroy callback function.
 *  arg_p           [IN] the argument of the destroy callback function.
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_frm_exec_scrn_destroy_hdlr(U16 scrn_id, void *arg_p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 cb_history_index;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_frm_get_scrn_idx(scrn_id, &cb_history_index))
    {
        if (historyData[cb_history_index].destroyFuncPtr)
        {
			MMI_TRACE(MMI_FW_TRC_G1_FRM, TRC_MMI_FRM_HIST_EXE_DESTROY_HDLR, scrn_id, historyData[cb_history_index].destroyFuncPtr, arg_p);
            curr_destroy_scrn = scrn_id;
            historyData[cb_history_index].destroyFuncPtr(arg_p);
            mmi_frm_clear_destroy_scrn_callback(scrn_id);
            curr_destroy_scrn = SCR_ID_INVALID; 
        }        
    }   

    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_frm_exec_scrn_wait_to_destroy_hdlr
 * DESCRIPTION
 *  Find out the special status history node and 
 *  execute their destroy callback functions with the argument 
 *  when re-enter gobak history procedure
 * PARAMETERS
 *  status      [IN] execute destroy callback function in what histoy node status
 * RETURNS
 *  S16     the number of destroy callback functions were invoked
 *****************************************************************************/
S16 mmi_frm_exec_scrn_wait_to_destroy_hdlr(mmi_history_node_status_enum status)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 index, count = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if (mmi_is_redrawing_bk_screens())
    {
        return 0;
    }
    
    MMI_ASSERT(MMI_HIST_NODE_NORMAL != status);

    if (currHistoryIndex > topHistoryIndex)
    {
        currHistoryIndex = topHistoryIndex;
    }

    for (index = topHistoryIndex; index > 0/*currHistoryIndex*/;  index--)
    {
        if (historyData[index].status == status)
        {
            /*(1) execute screen's destroy callback function */
			MMI_TRACE(PLUTO_FW_TRC_SCREEN, TRC_MMI_FRM_HIST_EXE_WAIT_TO_DESTROY_HDLR, status);
            mmi_frm_exec_scrn_destroy_hdlr(historyData[index].scrnID, historyData[index].app_arg);

            /*(2) Deletes this node*/
            mmi_free_history_buffer(index);
            memset(&historyData[index], 0, sizeof(historyNode));
            count++;

            /*(3) Moves upper nodes to here */
            if (index < topHistoryIndex)
            {
               memmove(&historyData[index], &historyData[index +1], (topHistoryIndex-index)*sizeof(historyNode));
       		   memset(&historyData[topHistoryIndex], 0, sizeof(historyNode));
            }                    
            topHistoryIndex--;
            _tmp_topHistoryIndex--;
        }
    }                
 
    return count;
}


/*****************************************************************************
 * FUNCTION
 *  ExecTopScrnCallbackHandler
 * DESCRIPTION
 *  Check if topist view screen exist in delete screen will be callback.
 * PARAMETERS
 *  void
 * RETURNS
 *  U8 - status
 *****************************************************************************/
static U8 ExecTopScrnCallbackHandler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return ExecTopScrnCallbackHandler_ex(1);
}


/*****************************************************************************
 * FUNCTION
 *  ExecTopScrnCallbackHandler_ex
 * DESCRIPTION
 *  Check if topist view screen exist in delete screen will be callback.
 * PARAMETERS
 *  is_main_hist        [IN]  Is Main LCD or Sub LCD.      
 * RETURNS
 *  Returns MMI_HIST_STOP_DELETING if the screen can't be deleted, MMI_HIST_ALLOW_DELETING otherwise. otherwise.
 *****************************************************************************/
U8 ExecTopScrnCallbackHandler_ex(U8 is_main_hist)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 is_stop_delete = MMI_HIST_ALLOW_DELETING;
    U8 is_found = MMI_FALSE;
    U16 cb_history_index;
    U16 scrnID;
    void *type = (void*)MMI_HIST_EXIT_SCREEN_TYPE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if (is_main_hist)
    {
        scrnID = get_exit_history_node_id();
        is_found = SearchDelScrnIDCallbackHandler(scrnID, &cb_history_index);
    }
    else
    {
        scrnID = GetSubLCDExitScrnId();
        is_found = SearchDelScrnIDCallbackHandler(scrnID, &cb_history_index);
    }

    if (g_is_back_root_main_hist)
    {
        /* it is in end key process */
        type = (void*)MMI_HIST_EXIT_SCREEN_IN_END_KEY_TYPE;
    }

    if (is_found == MMI_TRUE)
    {
        if (historyCBHandler[cb_history_index].historydelCBPtr)
        {
        #ifdef ENHANCE_HISTORY_UNIT_TEST
            test_case_scrn_arg = mmi_frm_get_exit_scrn_arg();
        #endif
        #ifdef HISTORY_TAB_MANGER
            if (is_main_hist && historyData[cb_history_index].isTab)
            {
                is_stop_delete = historyCBHandler[cb_history_index].historydelCBPtr(&tab_group);
            }
            else
        #endif
            {
                is_stop_delete = historyCBHandler[cb_history_index].historydelCBPtr(type);
            }
        }

        MMI_TRACE(MMI_FW_TRC_G1_FRM, TRC_MMI_FRM_HIST_EXETOPDELET_HDLR, historyCBHandler[cb_history_index].historydelCBPtr, is_stop_delete);
        if (historyData[activeScrnIndex].isGroupNode == 0 || is_stop_delete == MMI_HIST_ALLOW_DELETING)
        {  
            ClearDelScrnIDCallbackHandler(scrnID, NULL);
        }
    }

    return is_stop_delete;
}


/*****************************************************************************
 * FUNCTION
 *  ExecHistoryScrnCallBackHandle
 * DESCRIPTION
 *  Check if the history screen exist in delete screen will be callback.
 * PARAMETERS
 *  HistoryIndex        [IN]        
 * RETURNS
 *  U8 - status
 *****************************************************************************/
static U8 ExecHistoryScrnCallBackHandle(U16 HistoryIndex)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return ExecHistoryScrnCallBackHandle_ex(HistoryIndex, 1);
}


/*****************************************************************************
 * FUNCTION
 *  ExecHistoryScrnCallBackHandle_ex
 * DESCRIPTION
 *  Check if the history screen exist in delete screen will be callback.
 * PARAMETERS
 *  HistoryIndex        [IN] The Index of History Node.      
 *  is_main_hist        [IN] Is Main LCD or Sub LCD.       
 * RETURNS
 *  Returns MMI_HIST_STOP_DELETING if the screen can't be deleted, MMI_HIST_ALLOW_DELETING otherwise. otherwise.
 *****************************************************************************/
U8 ExecHistoryScrnCallBackHandle_ex(U16 HistoryIndex, U8 is_main_hist)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    /* Not support for stop callback at this funciton */
    U8 is_found = MMI_FALSE;
    U16 cb_history_index;
    U16 scrnID;
    U8 is_stop_allow = MMI_HIST_ALLOW_DELETING;
    void *type = (void*)MMI_HIST_DELETE_SCREEN_TYPE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if (is_main_hist)
    {
        /* main LCD history */
        scrnID = historyData[HistoryIndex].scrnID;
        is_found = SearchDelScrnIDCallbackHandler(scrnID, &cb_history_index);
    }
    else
    {
        /* sub LCD history */
        scrnID = GetSubLCDScrnId(HistoryIndex);
        is_found = SearchDelScrnIDCallbackHandler(scrnID, &cb_history_index);
    }

    if (g_is_back_root_main_hist)
    {
        /* it is in end key process */
        type = (void*)MMI_HIST_DELETE_SCREEN_IN_END_KEY_TYPE;
    }
    
    if (is_found == MMI_TRUE)
    {
        if (historyCBHandler[cb_history_index].historydelCBPtr)
        {
            MMI_TRACE(PLUTO_FW_TRC_SCREEN, MMI_FRM_INFO_EXEC_HIST_SCRN_CB_STRAT, scrnID);
        #ifdef ENHANCE_HISTORY_UNIT_TEST
            test_case_scrn_arg = historyData[HistoryIndex].app_arg;
        #endif

            curr_delete_scrn = scrnID;
        #ifdef HISTORY_TAB_MANGER
            if (is_main_hist && historyData[HistoryIndex].isTab && historyData[HistoryIndex].guiBuffer)
            {
                is_stop_allow = historyCBHandler[cb_history_index].historydelCBPtr((void*)historyData[HistoryIndex].guiBuffer);
            }
            else
        #endif
            {
                is_stop_allow = historyCBHandler[cb_history_index].historydelCBPtr(type);
            }
            MMI_TRACE(PLUTO_FW_TRC_SCREEN, MMI_FRM_INFO_EXEC_HIST_SCRN_CB_END, scrnID, is_stop_allow);

            if (is_stop_allow != MMI_HIST_STOP_DELETING)
            {   
                ClearDelScrnIDCallbackHandler(scrnID, NULL);
            }

            curr_delete_scrn = SCR_ID_INVALID;
        }        
    }   

    return is_stop_allow;
}


/*****************************************************************************  
*  Get History information Series APIs
*****************************************************************************/

/*****************************************************************************
 * FUNCTION
 *  mmi_frm_get_scrn_pointer
 * DESCRIPTION
 *  Used to get the reference of the screen history node for a screen id
 * PARAMETERS
 *  scrnID       [IN]   The screen ID of the history node.     
 *  ptrHistory   [OUT]  The pointer to the history buffer of the specified screen ID.      
 * RETURNS
 *  Returns ST_SUCCESS if success; ST_FAILURE otherwise.
 *****************************************************************************/
U8 mmi_frm_get_scrn_pointer(U16 scrnID, historyNode **ptrHistory)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 count = 0;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    /*
     * Each time the idle screen is popped from the history, the index is first
     * reset to -1. If the idle screen also wants to get its history pointer,
     * must handle it specially in the following if block.
     */
    if (-1 == currHistoryIndex && historyData[0].scrnID == scrnID)
    {
        *ptrHistory = &historyData[0];
        return ST_SUCCESS;
    } 

    if (IsBackHistory)
    {
        count = searched_history_node(topHistoryIndex, scrnID);
    }
    else
    {
        count = searched_history_node(newScrnIndex, scrnID);
    }
    if (count < 0 )
    {
        return ST_FAILURE;
    }
    *ptrHistory = &historyData[count];

    return ST_SUCCESS;

}


/*****************************************************************************
 * FUNCTION
 *  GetHistory
 * DESCRIPTION
 *  Used to get the history buffer for a screen id
 * PARAMETERS
 *  scrnID          [IN]  The screen ID of the history node.      
 *  ptrHistory      [OUT] The history buffer of the specified screen ID.       
 * RETURNS
 *  Returns ST_SUCCESS if success; ST_FAILURE otherwise.
 *****************************************************************************/
U8 GetHistory(U16 scrnID, history *ptrHistory)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 count = 0;
    U16 nSize;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(PLUTO_FW_TRC_SCREEN, MMI_FRM_INFO_HIST_GET_HIST_HDLR, scrnID, currHistoryIndex);

    count = searched_history_node(currHistoryIndex, scrnID);
    if (count < 0 )
    {
        return ST_FAILURE;
    }
    ptrHistory->entryFuncPtr = (FuncPtr) historyData[count].entryFuncPtr;
    ptrHistory->scrnID = historyData[count].scrnID;
    if (historyData[count].guiBuffer)
    {
        memcpy(ptrHistory->guiBuffer, historyData[count].guiBuffer, MAX_GUI_BUFFER);
    }
    else
    {
        memset(ptrHistory->guiBuffer, 0, MAX_GUI_BUFFER);
    }
    if (historyData[count].inputBuffer)
    /* 2 Bytes Are Added By UI To Keep Size Of InputBuffer Internally In AddNHistory */
    {
        memcpy(&nSize, historyData[count].inputBuffer, 2);
        memcpy(
               ptrHistory->inputBuffer,
               historyData[count].inputBuffer + 2,
               (nSize > MAX_INPUT_BUFFER) ? MAX_INPUT_BUFFER : nSize);
    }
    else
    {
        memset(ptrHistory->inputBuffer, 0, MAX_INPUT_BUFFER);
    }
    return ST_SUCCESS;

}


/*****************************************************************************
 * FUNCTION
 *  GetHistoryPointer
 * DESCRIPTION
 *  Used to get the reference of the history buffer for a screen id
 * PARAMETERS
 *  scrnID       [IN]   The screen ID of the history node.     
 *  ptrHistory   [OUT]  The pointer to the history buffer of the specified screen ID.      
 * RETURNS
 *  Returns ST_SUCCESS if success; ST_FAILURE otherwise.
 *****************************************************************************/
U8 GetHistoryPointer(U16 scrnID, historyNode **ptrHistory)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 count = 0;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(PLUTO_FW_TRC_SCREEN, MMI_FRM_INFO_HIST_GET_HIST_SCRID_HDLR, scrnID, currHistoryIndex);

    /*
     * Each time the idle screen is popped from the history, the index is first
     * reset to -1. If the idle screen also wants to get its history pointer,
     * must handle it specially in the following if block.
     */
    if (-1 == currHistoryIndex && historyData[0].scrnID == scrnID)
    {
        *ptrHistory = &historyData[0];
        return ST_SUCCESS;
    } 

    count = searched_history_node(currHistoryIndex, scrnID);
    if (count < 0 )
    {
        return ST_FAILURE;
    }
    *ptrHistory = &historyData[count];

    return ST_SUCCESS;

}


MMI_BOOL is_group_node(MMI_ID scrn_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 index;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    index = searched_history_node(activeScrnIndex, scrn_id);
    if (index == -1)
    {
        return MMI_FALSE;
    }
    return (historyData[index].isGroupNode == 1) ? MMI_TRUE : MMI_FALSE;
}




/*****************************************************************************
 * FUNCTION
 *  GetHistoryScrID
 * DESCRIPTION
 *  Used to get the reference of the history buffer for a screen id
 *  
 *  Please change to use GetHistoryPointer,
 *  rather than GetHistoryScrID
 * PARAMETERS
 *  scrnID          [IN]   The screen ID of the history node.     
 *  ptrHistory      [OUT]  The history buffer of the specified screen ID.      
 * RETURNS
 *  Returns ST_SUCCESS if success; ST_FAILURE otherwise.
 *****************************************************************************/
U8 GetHistoryScrID(U16 scrnID, historyNode **ptrHistory)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return GetHistoryPointer(scrnID, ptrHistory);
}


/*****************************************************************************
 * FUNCTION
 *  GetNHistory
 * DESCRIPTION
 *  Used to get the history for a screen id, and also the history buffer size
 * PARAMETERS
 *  scrnID          [IN]   The screen ID of the history node.     
 *  ptrHistory      [OUT]  The history buffer of the specified screen ID.         
 * RETURNS
 *  Returns ST_SUCCESS if success; ST_FAILURE otherwise.
 *****************************************************************************/
U8 GetNHistory(U16 scrnID, history *ptrHistory)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 count = 0;
    U8 Status = ST_FAILURE;
    MMI_FRM_INPUT_BUFFER_HEADER_TYPE buffer_header;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(PLUTO_FW_TRC_SCREEN, MMI_FRM_INFO_HIST_GET_NHIST_HDLR, scrnID, currHistoryIndex);

    count = currHistoryIndex;
    do
    {
        if (scrnID == historyData[count].scrnID)
        {
            ptrHistory->entryFuncPtr = (FuncPtr)historyData[count].entryFuncPtr;
            ptrHistory->scrnID = historyData[count].scrnID;
            if (historyData[count].guiBuffer)
            {
                memcpy(ptrHistory->guiBuffer, historyData[count].guiBuffer, MAX_GUI_BUFFER);
            }
            else
            {
                memset(ptrHistory->guiBuffer, 0, MAX_GUI_BUFFER);
            }
            if (historyData[count].inputBuffer)
            {
                memcpy(&buffer_header, historyData[count].inputBuffer, MMI_FRM_INPUT_BUFFER_HEADER_SIZE);
                memcpy(ptrHistory->inputBuffer, (historyData[count].inputBuffer + MMI_FRM_INPUT_BUFFER_HEADER_SIZE), buffer_header);
            }
            else
            {
                memset(ptrHistory->inputBuffer, 0, MAX_INPUT_BUFFER);
            }
            Status = ST_SUCCESS;
            break;
        }

        if (count > MIN_HISTORY + 1 && count < MAX_HISTORY)
        {
            --count;
        }
        else
        {
                break;  /* Status is by default FAILURE so no need to set again */
        }

    } while ((count != currHistoryIndex) && (historyData[count].entryFuncPtr != NULL));

    return Status;

}




/*****************************************************************************
 * FUNCTION
 *  GetCurrScrnId
 * DESCRIPTION
 *  Gets the id of the screen on the top of history stack.
 *  
 *  This is used to get current screen input buffer
 * PARAMETERS
 *  void
 * RETURNS
 *  U16 - Current Screen Id
 *****************************************************************************/
U16 GetCurrScrnId(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return (historyData[currHistoryIndex].scrnID);
}


/*****************************************************************************
 * FUNCTION
 *  GetIdleScrnId
 * DESCRIPTION
 *  Gets the id of the screen on the bottom of history stack.
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  U16 - Bottom Screen Id
 *****************************************************************************/
U16 GetIdleScrnId(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return (historyData[0].scrnID);
}


/*****************************************************************************
 * FUNCTION
 *  GetScreenCountInHistory
 * DESCRIPTION
 *  Get the screen numbers in the history
 * PARAMETERS
 *  void
 * RETURNS
 *  S16 - screen count
 *****************************************************************************/
S16 GetScreenCountInHistory(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return (currHistoryIndex + 1);
}


/*****************************************************************************
 * FUNCTION
 *  GetCurrInputBuffer
 * DESCRIPTION
 *  This is used to get current screen input buffer.
 *  This function is used to retrieve current Input buffer. In Input buffer all 
 *  running text related information is stored by framework whenever this screen
 *  is overwritten. The application use this function to get Input buffer pointer
 *  of MMI history database directly, its size is not exceed MAX_INPUT_BUFFER and
 *  its life cycle in during this screen is active. If the current screen ID 
 *  isn't the same with the input parameter, the function will return NULL input
 *  buffer pointer.
 * PARAMETERS
 *  scrnid      [IN]  Screen ID of screen whose corresponding Input buffer is to be retrieved.       
 * RETURNS
 *  Pointer to unsigned char pointing to the Input buffer returned.
 *****************************************************************************/
U8 *GetCurrInputBuffer(U16 scrnid)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_FW_TRC_G1_FRM, MMI_FRM_INFO_HIST_GET_CUR_INPUT_BUF_HDLR, scrnid);

    if (historyData[currHistoryIndex].scrnID == scrnid)
    {
        return (historyData[currHistoryIndex].inputBuffer);
    }
    return NULL;
}


/*****************************************************************************
 * FUNCTION
 *  GetCurrNInputBuffer
 * DESCRIPTION
 *  This function is used to retrieve current Input buffer with the Inptut buffer
 *  size. In Input buffer all running text related information is stored by 
 *  framework whenever this screen is overwritten. The application use this 
 *  function to get Input buffer pointer of MMI history database directly, its 
 *  size could be larger than MAX_INPUT_BUFFER and its life cycle in during this
 *  screen is active. If the current screen ID isn't the same with the input 
 *  parameter, the function will return NULL Input buffer pointer.
 * PARAMETERS
 *  scrnid      [IN] Screen ID of screen whose corresponding Input buffer is to be retrieved.       
 *  size        [IN] The Input buffer size.       
 * RETURNS
 *  Pointer to unsigned char pointing to the Input buffer returned.
 *****************************************************************************/
U8 *GetCurrNInputBuffer(U16 scrnid, U16 *size)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_FRM_INPUT_BUFFER_HEADER_TYPE buffer_header;
    U8* pRet = NULL;
    
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_FW_TRC_G1_FRM, MMI_FRM_INFO_HIST_GET_CUR_NINPUT_BUF_HDLR, scrnid);
    if( size == NULL )
        return NULL;
    *size = 0;
    if (historyData[currHistoryIndex].scrnID == scrnid && historyData[currHistoryIndex].inputBuffer != NULL)
    {
        memcpy(&buffer_header, historyData[currHistoryIndex].inputBuffer, MMI_FRM_INPUT_BUFFER_HEADER_SIZE);
        *size = (U16)buffer_header;
        pRet = ((historyData[currHistoryIndex].inputBuffer) + MMI_FRM_INPUT_BUFFER_HEADER_SIZE);
    }
    return pRet;
}


/*****************************************************************************
 * FUNCTION
 *  GetCurrGuiBuffer
 * DESCRIPTION
 *  This function is used to retrieve current GUI buffer. In GUI buffer all GUI 
 *  related information is stored by framework whenever this screen is overwritten.
 *  The application use this function to get GUI buffer pointer of MMI history 
 *  database directly and its life cycle in during this screen is active. If the
 *current screen ID isn't the same with the input parameter, the function will
 *  return NULL GUI buffer pointer.
 * PARAMETERS
 *  scrnid      [IN] Screen ID of screen whose corresponding GUI buffer is to be retrieved.       
 * RETURNS
 *  Pointer to unsigned char pointing to the GUI buffer returned. 
 *****************************************************************************/
U8 *GetCurrGuiBuffer(U16 scrnid)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_FW_TRC_G1_FRM, MMI_FRM_INFO_HIST_GET_CUR_GUI_BUF_HDLR, scrnid, currHistoryIndex);

    
    if (-1 == currHistoryIndex)
    {
        if (historyData[0].scrnID == scrnid)
        {
            return (historyData[0].guiBuffer);
        }
    } 
    else if (historyData[currHistoryIndex].scrnID == scrnid)
    {
        return (historyData[currHistoryIndex].guiBuffer);
    }
       
    return NULL;
}


/*****************************************************************************
 * FUNCTION
 *  GetPreviousScrnIdOf
 * DESCRIPTION
 *  Queries previous scrn id of this Id
 * PARAMETERS
 *  scrnId              [IN]   The based Screen ID.     
 *  previousScrnId      [OUT]  The previous Screen ID.       
 * RETURNS
 *  Returns MMI_TRUE if get the previous Screen ID succeed ; MMI_FALSE otherwise. 
 *****************************************************************************/
MMI_BOOL GetPreviousScrnIdOf(U16 scrnId, U16 *previousScrnId)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (count = 0; ((count < MAX_HISTORY) && ((count <= currHistoryIndex) && (currHistoryIndex != -1))); count++)
    {
        if (historyData[count].scrnID == scrnId)
        {
            if ((count - 1) >= 0)
            {
                *previousScrnId = historyData[count - 1].scrnID;
                MMI_TRACE(PLUTO_FW_TRC_SCREEN, MMI_FRM_INFO_GET_PREVIOUS_SCR_IDOF_HDLR, scrnId,
                           historyData[count - 1].scrnID);
                return MMI_TRUE;
            }
            MMI_TRACE(PLUTO_FW_TRC_SCREEN, MMI_FRM_INFO_GET_PREVIOUS_SCR_IDOF_2_HDLR, scrnId);
            return MMI_FALSE;
        }
    }
    MMI_TRACE(PLUTO_FW_TRC_SCREEN, MMI_FRM_INFO_GET_PREVIOUS_SCR_IDOF_2_HDLR, scrnId);
    return MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  GetNextScrnIdOf
 * DESCRIPTION
 *  Queries next scrn id of this Id
 * PARAMETERS
 *  scrnId          [IN]   The based Screen ID.      
 *  nextScrnId      [OUT]  The next Screen ID.       
 * RETURNS
 *  Returns MMI_TRUE if get the next Screen ID succeed ; MMI_FALSE otherwise.
 *****************************************************************************/
MMI_BOOL GetNextScrnIdOf(U16 scrnId, U16 *nextScrnId)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (count = 0; ((count < MAX_HISTORY) && ((count <= currHistoryIndex) && (currHistoryIndex != -1))); count++)
    {
        if (historyData[count].scrnID == scrnId)
        {
            if ((count + 1) <= currHistoryIndex)
            {
                *nextScrnId = historyData[count + 1].scrnID;
                MMI_TRACE(PLUTO_FW_TRC_SCREEN, TRC_MMI_FRM_HIST_GET_NEXT_SCR_ID, scrnId, *nextScrnId);
                return MMI_TRUE;
            }
            return MMI_FALSE;
        }
    }
    return MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_frm_get_current_delete_screen_id
 * DESCRIPTION
 *  Get the current deleted screen id
 * PARAMETERS
 *  scrnId          [OUT] the specified Screen ID is in delete process.
 * RETURNS
 *  Returns MMI_TRUE if get the deleted screen ID succeed ; MMI_FALSE otherwise.
 *****************************************************************************/
MMI_BOOL mmi_frm_get_current_delete_screen_id(U16 *scrn_id)
{
    if (curr_delete_scrn != SCR_ID_INVALID)
    {
        /* It is in deleting screen process now. */
        *scrn_id = curr_delete_scrn;
        return MMI_TRUE;
    }
    else
    {
        /* There is no deleting screen process. */
        *scrn_id = SCR_ID_INVALID;
        return MMI_FALSE;
    }
}

 
/*****************************************************************************
 * FUNCTION
 *  mmi_frm_get_screen_index
 * DESCRIPTION
 *  Queries the index in history database for specified screen Id
 * PARAMETERS
 *  scrnId          [IN] the specified Screen ID which want to query.       
 * RETURNS
 *  Returns positive number or 0 if the specified Screen ID is in the history database; 
 *  otherwise returns -1.
 *****************************************************************************/
S16 mmi_frm_get_screen_index(U16 screen_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (count = 0; ((count < MAX_HISTORY) && ((count <= currHistoryIndex) && (currHistoryIndex != -1))); count++)
    {
        if (historyData[count].scrnID == screen_id)
        {
            MMI_TRACE(PLUTO_FW_TRC_SCREEN, TRC_MMI_FRM_HIST_GET_SCR_IDX, screen_id, count);
            return count;
        }
    }
    return -1;
}


/*****************************************************************************
 * FUNCTION
 *  is_top_history_node
 * DESCRIPTION
 *  Judge a screen if it is on the top of the history stack.
 *  This API is only used for scenerio tree.
 * PARAMETERS
 *  scrnId          :[IN] the specified Screen ID which want to query.       
 * RETURNS
 *  Returns MMI_TRUE if the screen on the top of the history stack(Active Screen)
 *****************************************************************************/
MMI_BOOL is_top_history_node(U16 srnID)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return (srnID == historyData[activeScrnIndex].scrnID) ? MMI_TRUE: MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  IsScreenPresent
 * DESCRIPTION
 *  Queries history for presence of a screen Id
 * PARAMETERS
 *  scrnId          [IN] the specified Screen ID which want to query.       
 * RETURNS
 *  Returns MMI_TRUE if the specified Screen ID is in the history database; MMI_FALSE otherwise.
 *****************************************************************************/
MMI_BOOL IsScreenPresent(U16 scrnId)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (count = 0; ((count < MAX_HISTORY) && ((count <= currHistoryIndex) && (currHistoryIndex != -1))); count++)
    {
        if (historyData[count].scrnID == scrnId)
        {
            MMI_TRACE(PLUTO_FW_TRC_SCREEN, MMI_FRM_INFO_IS_SCR_PRESENT_HDLR, scrnId, MMI_TRUE);
            return MMI_TRUE;
        }
    }
    MMI_TRACE(PLUTO_FW_TRC_SCREEN, MMI_FRM_INFO_IS_SCR_PRESENT_HDLR, scrnId, MMI_FALSE);
    return MMI_FALSE;

}


/*****************************************************************************
 * FUNCTION
 *  IsCurrMarkerScreen
 * DESCRIPTION
 *  Check if the current screen is  marker screen.
 * PARAMETERS
 *  scrnid      [IN]  The ID of marker screen.       
 * RETURNS
 *  Returns MMI_TRUE if the current screen is marker screen; MMI_FALSE otherwise. 
 *****************************************************************************/
U8 IsCurrMarkerScreen(U16 scrnid)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_FW_TRC_G1_FRM, MMI_FRM_INFO_IS_CUR_MARKER_SCR_HDLR, scrnid, historyData[currHistoryIndex].scrnID);
    return (historyData[currHistoryIndex].scrnID == scrnid);
}


/*****************************************************************************  
*   Delete Series APIs
*****************************************************************************/

/*****************************************************************************
 * FUNCTION
 *  DeleteScreens
 * DESCRIPTION
 *  Deletes the screen IDs in the history
 *  The start screen ID and end screen ID will be deleted.
 *  If all screen IDs in the history are deleted
 *  successfully, the function returns ST_SUCCESS.
 *  If the parameters are error or someone screen
 *  ID can't be deleted successfully, the function
 *  returns ST_FAILURE.
 * PARAMETERS
 *  start_scrnid        [IN]        IN  the start screen ID (small number)
 *  end_scrnid          [IN]        IN  the end screen ID (big number)
 * RETURNS
 *  Returns ST_SUCCESS if success; ST_FAILURE otherwise.
 *****************************************************************************/
U8 DeleteScreens(U16 start_scrnid, U16 end_scrnid)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 count = 0, del_cnt = 0;
    U8  Status = ST_SUCCESS;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if (mmi_is_redrawing_bk_screens())
    {
        return ST_SUCCESS;
    }
    if (start_scrnid > end_scrnid)
    {
        return ST_FAILURE;
    }

    delete_reentry_count++;
    count = currHistoryIndex;

    while (count)
    {
        if ((start_scrnid <= historyData[count].scrnID) &&
            (historyData[count].scrnID <= end_scrnid) &&
            historyData[count].isGroupNode == 0)
        {
            if (ExecHistoryScrnCallBackHandle(count) == MMI_HIST_STOP_DELETING)
            {
                /*
                 * The screen won't want to delete. 
                 * We stop continue to delete the screens.
                 */
                Status = ST_FAILURE;
                break;
            }
            del_cnt++;
            /* Deleting the node */
            mmi_frm_set_history_node_status(count, MMI_HIST_NODE_DELETING);

            /* In delete procedure, we need to invoke destroy handlers directly. */
	        mmi_frm_exec_scrn_destroy_hdlr(historyData[count].scrnID, historyData[count].app_arg);
        }
        count--;
    }    
    MMI_TRACE(MMI_FW_TRC_G1_FRM, TRC_MMI_FRM_HIST_DEL_SCRS_HDLR, start_scrnid, end_scrnid, del_cnt);

    currHistoryIndex -= del_cnt;
    MMI_ASSERT(currHistoryIndex>=0);
    delete_reentry_count--;
    
    if (0 == delete_reentry_count)
    {
        mmi_frm_remove_history_node(MMI_HIST_NODE_DELETING);
    }

    return Status;
}


/*****************************************************************************
 * FUNCTION
 *  DeleteBeyondScrTillScr
 * DESCRIPTION
 *  To delete screens beyond screen ID - beyondScrnID till screen ID - tillScrnID. 
 *  Both beyondScrnID and tillScrnID have to be in history database, or the 
 *  function will return fail. And within the History stack the beyondScrnid position 
 *  is reachable from the tillScrnid by decrementation. Otherwise an assert failure 
 *  occurs.
 * PARAMETERS
 *  beyondScrnid        [IN]   Specify the beyond Screen ID wants to delete the nodes.[Exclusive]      
 *  tillScrnid          [IN]   Specify the till Screen ID wants to delete the nodes.  [Inclusive]  
 * RETURNS
 *  Returns ST_SUCCESS if success; ST_FAILURE otherwise.
 *****************************************************************************/
U8 DeleteBeyondScrTillScr(U16 beyondScrnid, U16 tillScrnid)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 del_count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_FW_TRC_G1_FRM, MMI_FRM_INFO_HIST_DEL_BEYOND_SCR_TILL_SCR_HDLR, beyondScrnid, tillScrnid);

    return DeleteHistoryInt(beyondScrnid, 0, 0, tillScrnid, 1, MMI_HIST_ENABLE_DESTROY_HANDLER, &del_count);
}


/*****************************************************************************
 * FUNCTION
 *  DeleteBetweenScreen
 * DESCRIPTION
 *  Deletes Between two Screens including the boundaries
 *  To delete screens between screen ID - StartScrnID till screen ID EndScrnID. 
 *  Both StartScrID and EndScrnID have to be in history database, or the function
 *  will return fail. 
 *  And within the History stack the StartScrId position is reachable 
 *  from the EndScrId by decrementation. Otherwise an assert failure occurs.
 * PARAMETERS
 *  StartScrId      [IN]  Specify the beginning Screen ID wants to delete the nodes. [Inclusive].      
 *  EndScrId        [IN]  Specify the endding Screen ID wants to delete the nodes.   [Inclusive].      
 * RETURNS
 *  Returns ST_SUCCESS if success; ST_FAILURE otherwise.
 *****************************************************************************/
U16 DeleteBetweenScreen(U16 StartScrId, U16 EndScrId)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 del_count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_FW_TRC_G1_FRM, MMI_FRM_INFO_HIST_DEL_BETWEEN_SCR_HDLR, StartScrId, EndScrId);
    /* 
     * index of StartScrId <= index of EndScrId for DeleteBetweenScreen;
     * but the meaning of arg naming of DeleteHistoryInt is opposite,
     * which means index of StartScrId >= index of EndScrId for DeleteHistoryInt.
     */
    return DeleteHistoryInt(EndScrId, 1, 0, StartScrId, 1, MMI_HIST_ENABLE_DESTROY_HANDLER, &del_count);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_frm_delete_screen_if_present_ex
 * DESCRIPTION
 *  This function Deletes specified screen ID history nodes from the history 
 *  database. The screen ID should be in the history database, or the function 
 *  will return fail.
 * PARAMETERS
 *  ScrId       [IN] Specify the Screen ID wants to delete the nodes.       
 * RETURNS
 *  Returns ST_SUCCESS if success; ST_FAILURE otherwise.
 *****************************************************************************/
U16 mmi_frm_delete_screen_if_present_ex(U16 scrn_id, MMI_BOOL is_internal_used)
{
    /*
     * return DeleteHistory(ScrId, 1, 1, 0, 0);
     * This function can't use the new del API. If it uses the new API, the  
     * original API's behavior will be changed. The original behavior is that
     * immediately delete the screen, doesn't consider whether the screen 
     * allow to delete or not.       
     */ 
        
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if (mmi_is_redrawing_bk_screens())
    {
        MMI_TRACE(MMI_FW_TRC_G1_FRM, TRC_MMI_FRM_HIST_DEL_SCR_IF_PRESENT_RETURN, scrn_id);
        return ST_SUCCESS;
    }

    count = searched_history_node(topHistoryIndex, scrn_id);
    if (count < 0)
    {       
        MMI_TRACE(MMI_FW_TRC_G1_FRM, TRC_MMI_FRM_HIST_DEL_SCR_IF_PRESENT_HDLR_ERROR, scrn_id);
        return ST_FAILURE;
    }
    if (historyData[count].isGroupNode && is_internal_used == MMI_FALSE)
    {
        /* We don't support delete the screen group. Should use screen group API to do this action. */
        return ST_FAILURE;
    }

    delete_reentry_count++;

	if (historyData[count].status != MMI_HIST_NODE_DELETING && historyData[count].status != MMI_HIST_NODE_WAIT_TO_DESTROY)
	{
	    mmi_frm_set_history_node_status(count, MMI_HIST_NODE_DELETING);
	    /*
	     * Not support for stop callback at this funciton 
	     * Because the application want to delete the special screen in the history,
	     * we don't need to check the return value of the delete callback function.
	     */
	    ExecHistoryScrnCallBackHandle(count);
        mmi_frm_exec_scrn_destroy_hdlr(historyData[count].scrnID, historyData[count].app_arg);
	}
	
    delete_reentry_count--;
    if (0 == delete_reentry_count)
    {
        mmi_frm_remove_history_node(MMI_HIST_NODE_DELETING);
    }

    MMI_TRACE(MMI_FW_TRC_G1_FRM, TRC_MMI_FRM_HIST_DEL_SCR_IF_PRESENT_HDLR, scrn_id, count);

    return ST_SUCCESS;

}


/*****************************************************************************
 * FUNCTION
 *  mmi_delete_scrn_if_present
 * DESCRIPTION
 *  This function Deletes specified screen ID history nodes from the history 
 *  database. The screen ID should be in the history database, or the function 
 *  will return fail. This function is only used for internal. MMI framework
 *  scenario module use this function to delete the adaptor node.
 * PARAMETERS
 *  ScrId       [IN] Specify the Screen ID wants to delete the nodes.       
 * RETURNS
 *  Returns ST_SUCCESS if success; ST_FAILURE otherwise.
 *****************************************************************************/
U16 mmi_delete_scrn_if_present(U16 scrn_id)
{
    return mmi_frm_delete_screen_if_present_ex(scrn_id, MMI_TRUE);
}


/*****************************************************************************
 * FUNCTION
 *  DeleteScreenIfPresent
 * DESCRIPTION
 *  This function Deletes specified screen ID history nodes from the history 
 *  database. The screen ID should be in the history database, or the function 
 *  will return fail.
 * PARAMETERS
 *  ScrId       [IN] Specify the Screen ID wants to delete the nodes.       
 * RETURNS
 *  Returns ST_SUCCESS if success; ST_FAILURE otherwise.
 *****************************************************************************/
U16 DeleteScreenIfPresent(U16 ScrId)
{
    return mmi_frm_delete_screen_if_present_ex(ScrId, MMI_FALSE);
}


/*****************************************************************************
 * FUNCTION
 *  DeleteScreenFromToNnodes
 * DESCRIPTION
 *  Deletes N nodes from  History starting from a particular screen
 * PARAMETERS
 *  ScrId           [IN]  Specify the Screen ID wants to delete the nodes.      
 *  num_nodes       [IN]  The number of the history node to delete.      
 * RETURNS
 *  Returns ST_SUCCESS if success; ST_FAILURE otherwise.
 *****************************************************************************/
U16 DeleteScreenFromToNnodes(U16 ScrId, U16 num_nodes)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 del_count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_FW_TRC_G1_FRM, MMI_FRM_INFO_HIST_DEL_SCR_FROM_TO_N_NODE_HDLR, ScrId, num_nodes);

    return DeleteHistoryInt(ScrId, 1, num_nodes, 0, 0, MMI_HIST_ENABLE_DESTROY_HANDLER, &del_count);
}


/*****************************************************************************
 * FUNCTION
 *  DeleteFromScrUptoScr
 * DESCRIPTION
 *  Deletes screen from start scrnid to before end scrnid
 *  (include start scrnid but not include end scrnid)
 *  And within the History stack the upto_scrnid position is reachable from the 
 *  start_scrnid by decrementation. Otherwise an assert failure 
 *  occurs.
 * PARAMETERS
 *  start_scrnid        [IN] Specify the beginning Screen ID wants to delete the nodes. [Inclusive]    
 *  upto_scrnid         [IN] Specify the endding Screen ID wants to delete the nodes.   [Exclusive]    
 * RETURNS
 *  Returns ST_SUCCESS if success; ST_FAILURE otherwise.
 *****************************************************************************/
U8 DeleteFromScrUptoScr(U16 start_scrnid, U16 upto_scrnid)
{

    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 del_count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_FW_TRC_G1_FRM, MMI_FRM_INFO_HIST_DEL_FROM_SCR_UPTO_SCR_HDLR, start_scrnid, upto_scrnid);
    return DeleteHistoryInt(start_scrnid, 1, 0, upto_scrnid, 0, MMI_HIST_ENABLE_DESTROY_HANDLER, &del_count);
}


/*****************************************************************************
 * FUNCTION
 *  DeleteNHistory
 * DESCRIPTION
 *  Deletes 'n' history nodes from current history index
 *  
 *  This shall pop 'n' history nodes without invoking
 *  entry functions of the deleted nodes
 * PARAMETERS
 *  DeleteCount     [IN] Number of nodes to be deleted from the history.       
 * RETURNS
 *  void
 *****************************************************************************/
void DeleteNHistory(U16 DeleteCount)
{

    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_FW_TRC_G1_FRM, MMI_FRM_INFO_DEL_NHIST_HDLR, DeleteCount);
    DeleteHistory(MMI_HIST_TOP_SCREEN, 1, DeleteCount, 0, 0);
}


/*****************************************************************************
 * FUNCTION
 *  DeleteUptoScrID
 * DESCRIPTION
 *  Delete all the nodes in the screen up to specified Screen ID and does not 
 *  execute the Entry Function of the history node beyond the specified Screen 
 *  ID. The specified screen ID should be in the history database, or the function
 *  will return fail.
 * PARAMETERS
 *  scrnid      [IN] Specify the Screen ID up to which one wants to delete the nodes. (not include the specified screen ID).       
 * RETURNS
 *  Returns ST_SUCCESS if delete the history node succeed; ST_FAILURE otherwise.
 *****************************************************************************/
U8 DeleteUptoScrID(U16 scrnid)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 del_count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_FW_TRC_G1_FRM, MMI_FRM_INFO_DEL_UPTO_SCRID_HDLR, scrnid, currHistoryIndex);
    return DeleteHistoryInt(MMI_HIST_TOP_SCREEN, 1, 0, scrnid, 0, MMI_HIST_ENABLE_DESTROY_HANDLER, &del_count);
}


/*****************************************************************************
 * FUNCTION
 *  DeleteNScrId
 * DESCRIPTION
 *  Delete all the nodes in the screen up to specified Screen ID and decrement 
 *  the pointer the history node beyond it but do not execute the entry function. 
 *  The screen ID should be in the history database, or the function will return
 *  fail.
 * PARAMETERS
 *  scrnid      [IN] Specify the Screen ID up to which one wants to delete the nodes. (include the specified screen ID).       
 * RETURNS
 *  Returns ST_SUCCESS if delete the history node succeed; ST_FAILURE otherwise.
 *****************************************************************************/
U8 DeleteNScrId(U16 scrnid)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 del_count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_FW_TRC_G1_FRM, MMI_FRM_INFO_DEL_NSCRID_HDLR, scrnid, currHistoryIndex);
    return DeleteHistoryInt(MMI_HIST_TOP_SCREEN, 1, 0, scrnid, 1, MMI_HIST_ENABLE_DESTROY_HANDLER, &del_count);
}


/*****************************************************************************
 * FUNCTION
 *  get_range_index
 * DESCRIPTION
 *  get start/end index of given range
 * PARAMETERS
 *  startScrId  [IN]    screen id of start node
 *  bIncStart   [IN]    includes start node or not
 *  count       [IN]    delete count
 *  endScrId    [IN]    screen id of end node
 *  bIncEnd     [IN]    includes end node or not
 *  startIdxPtr [OUT]   pointer to calculated start index
 *  endIdxPtr   [OUT]   pointer to calculated end index
 * RETURNS
 *  success or not
 *****************************************************************************/
__inline static MMI_BOOL get_range_index(U16 startScrId, U8 bIncStart, U16 count, 
                                    U16 endScrId, U8 bIncEnd, S32 *startIdxPtr, S32 *endIdxPtr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 idx, startIdx = -1, endIdx = -1, endIdxTmp = -1;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
 
     /* validate range and get start/end index */
    if ((0 == startScrId) && (0 == endScrId))
    {
        MMI_TRACE(PLUTO_FW_TRC_SCREEN, TRC_MMI_FRM_HIST_GET_RANGE_IDX_ERR1);
        return MMI_FALSE;
    }

    /* get start/end index from given screen id */
    idx = currHistoryIndex;

    if (startScrId > 0)
    {
        for (; idx >= 0; idx--)
        {
            if (historyData[idx].scrnID == startScrId)
            {
                startIdx = idx;
                break;
            }
        }

        /* startIdx not found, reset idx for endIdx */
        if (startIdx < 0)
        {
            idx = currHistoryIndex;
        }
    }

    if (endScrId > 0)
    {
        /* start search from previous idx */
        for (; idx >= 0; idx--)
        {
            if (historyData[idx].scrnID == endScrId)
            {
                endIdx = idx;
                break;
            }
        }       
    }

    /* scr not present in history */
    if (((startScrId > 0) && (startIdx < 0)) || 
        ((endScrId > 0) && (endIdx < 0)))
    {
        MMI_TRACE(PLUTO_FW_TRC_SCREEN, TRC_MMI_FRM_HIST_GET_RANGE_IDX_ERR2);
        return MMI_FALSE;
    }

    /* handle inclusion */
    if (!bIncStart && (startIdx > 0))
    {
        startIdx--;
    }

    /* handle inclusion */
    if (!bIncEnd && (endIdx >= 0))
    {
        endIdx++;
    }

    /* get max range (when count is given) and validate it.
     * Conditions :
     * [1] no startIdx/count/endIdx
     * [2] startIdx exists, no count/endIdx
     * [3] count exists, no startIdx/endIdx
     * [4] endIdx exists, no startIdx/count
     * [5] startIdx/count exist, no endIdx
     * [6] startIdx/endIdx exist, no count
     * [7] endIdx/count exist, no startIdx
     * [8] startIdx/count/endIdx all exist
     */
    if (count > 0)
    {
        if (startIdx >= 0)
        {
            endIdxTmp = startIdx - count + 1;

            if (endIdxTmp < 0)
            {
                /* endIdxTmp is invalid, and will always dominate endIdx (greedy), just return */
                MMI_TRACE(PLUTO_FW_TRC_SCREEN, TRC_MMI_FRM_HIST_GET_RANGE_IDX_ERR3);
                return MMI_FALSE;
            }
        }
        else if (endIdx >= 0)
        {
            /* [7] endIdx/count exist, no startIdx */
            startIdx = endIdx + count - 1;
        }
        else
        {
            /* [3] count exists, no startIdx/endIdx, just return */
            MMI_TRACE(PLUTO_FW_TRC_SCREEN, TRC_MMI_FRM_HIST_GET_RANGE_IDX_ERR4);
            return MMI_FALSE;
        }

    }
    /* count == 0 */
    else if ((startIdx < 0) || (endIdx < 0))
    {
        /* [1] no startIdx/endIdx/count, or
         * [2] no endIdx/count, or
         * [4] no startIdx/count */
        MMI_TRACE(PLUTO_FW_TRC_SCREEN, TRC_MMI_FRM_HIST_GET_RANGE_IDX_ERR5);
        return MMI_FALSE;
    }
    /* else, [6] startIdx/endIdx exist, no count */

    if (endIdx < 0)
    {
        /* [5] startIdx/count exists, no endIdx */
        endIdx = endIdxTmp;
    }
    /* [8] startIdx/endIdx/count exists, do greedy check */
    else if ((endIdxTmp > 0) && (endIdxTmp < endIdx))
    {
        endIdx = endIdxTmp;
    }

    *startIdxPtr = startIdx;
    *endIdxPtr = endIdx;
    
    MMI_TRACE(PLUTO_FW_TRC_SCREEN, TRC_MMI_FRM_HIST_GET_RANGE_IDX_SUCCESS, startIdx, endIdx);
    return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  DeleteHistory
 * DESCRIPTION
 *  Delete history
 * 
 * 1. SCR ID should be larger than 0
 * 2. This function is greedy, which means delete histories for 
 *     max( startScrId to endScrId, count)
 * 3. index of startScrId >= index of endScrId
 * 
 * PARAMETERS
 *  startScrId  [IN]    screen id of start node
 *  bIncStart   [IN]    includes start node or not
 *  count       [IN]    delete count
 *  endScrId    [IN]    screen id of end node
 *  bIncEnd     [IN]    includes end node or not
 * RETURNS
 *  no. of nodes deleted
 *****************************************************************************/
U32 DeleteHistory(U16 startScrId, U8 bIncStart, U16 count, U16 endScrId, U8 bIncEnd)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 del_count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    DeleteHistoryInt(startScrId, bIncStart, count, endScrId, bIncEnd, MMI_HIST_ENABLE_DESTROY_HANDLER, &del_count);

    return del_count;
}


/*****************************************************************************
 * FUNCTION
 *  DeleteHistoryInt
 * DESCRIPTION
 *  Delete history (internal function)
 * 
 * 1. SCR ID should be larger than 0
 * 2. This function is greedy, which means delete histories for 
 *     max( startScrId to endScrId, count)
 * 3. index of startScrId >= index of endScrId
 * 
 * PARAMETERS
 *  startScrId  [IN]    screen id of start node
 *  bIncStart   [IN]    includes start node or not
 *  count       [IN]    delete count
 *  endScrId    [IN]    screen id of end node
 *  flag        [IN]    destroy handler invoking type
 *  bIncEnd     [IN]    includes end node or not
 *  deleteCount [OUT]   no. of nodes deleted
 * RETURNS
 *  Returns ST_SUCCESS if success to delete all required history nodes; 
 *  Returns ST_FAILURE if some history nodes can't be deleted.
 *****************************************************************************/
__inline static U8 DeleteHistoryInt(U16 startScrId, U8 bIncStart, U16 count, 
                                     U16 endScrId, U8 bIncEnd, U8 flag, U16* deleteCount)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 delCount = 0;
    S32 delIdx, startIdx, endIdx;
    U8 status = ST_SUCCESS;
    U8 ret;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_is_redrawing_bk_screens())
    {
        return status;
    }

    delete_reentry_count++;
    MMI_TRACE(PLUTO_FW_TRC_SCREEN, TRC_MMI_FRM_HIST_DEL_HISTORY_HDLR, 
                startScrId, bIncStart, count, endScrId, bIncEnd);

    /* get start/end index of delete range */
    if (get_range_index(startScrId, bIncStart, count, endScrId, bIncEnd, &startIdx, &endIdx))
    {
        /* both startIdx/endIdx should be valid here */
        MMI_TRACE(PLUTO_FW_TRC_SCREEN, TRC_MMI_FRM_HIST_DEL_HISTORY_INDEX_HDLR, 
                    currHistoryIndex, startIdx, endIdx);
        for (delIdx = startIdx; delIdx >= endIdx; delIdx--)
        {
			if (historyData[delIdx].status == MMI_HIST_NODE_NORMAL)
			{/* Each history node could only be processed by one action */
                MMI_TRACE(MMI_FW_TRC_G1_FRM, TRC_MMI_FRM_HIST_DEL_HISTORY_INDEX, historyData[delIdx].scrnID, delIdx);
	            mmi_frm_set_history_node_status((U16)delIdx, MMI_HIST_NODE_DELETING);
	            /* exe. del cb */

                ret = ExecHistoryScrnCallBackHandle((U16)delIdx);
	            if ( ret == MMI_HIST_STOP_DELETING)
	            {
	                MMI_TRACE(MMI_FW_TRC_G1_FRM, TRC_MMI_FRM_HIST_DEL_HISTORY_STOP_DELETING, historyData[delIdx].scrnID, delIdx);
                	status = ST_FAILURE;
	                mmi_frm_set_history_node_status((U16)delIdx, MMI_HIST_NODE_NORMAL);
                    if (g_is_back_root_main_hist && (g_is_stop_when_forbiden == MMI_FALSE))
                    {
	                    continue;  /* APP forbid to delete */
                    }
                    else
                    {
                        break;
                    }
	            }

	            /*
	             * In delete procedure, we need to invoke destroy handlers directly.
	             * In goback procedure, we need to invoke destroy handlers after entry new screen.
	             */
	            if (MMI_HIST_ENABLE_DESTROY_HANDLER == flag)
	            {
	            	mmi_frm_exec_scrn_destroy_hdlr(historyData[delIdx].scrnID, historyData[delIdx].app_arg);
				}
				else
				{
	                mmi_frm_set_history_node_status((U16)delIdx, MMI_HIST_NODE_WAIT_TO_DESTROY);
				}
                if (ret == MMI_HIST_STOP_BUT_DEL_THIS_ONE)
                {
                    MMI_ASSERT(historyData[delIdx].isGroupNode == 1);
					delCount++;
                    break;
                }
			}
            delCount++;
        }
    }
    else
    {
        status = ST_FAILURE;
    }
    delete_reentry_count--;
    if (0 == delete_reentry_count)
    {
        mmi_frm_remove_history_node(MMI_HIST_NODE_DELETING);
    }
    else
    {/* history node status maybe set deleting, should adjust history index */
        decrement_current_history_index();
    }
    MMI_TRACE(MMI_FW_TRC_G1_FRM, MMI_FRM_INFO_DEL_HISTORY_END, delCount);
    *deleteCount = delCount;

    return status;
}


U16 GetCurrSmallScrnID(void)
{
    return (currSmallScrnID & 0XFFFF);
}


/*****************************************************************************
 * FUNCTION mmi_frm_enable_redraw_empty_bg
 *  
 * DESCRIPTION
 *  AP can use the function in entry function to let framework fill the 
 *  a defualt background during redraw.
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/

void mmi_frm_enable_redraw_empty_bg()
{
    isRedrawEmptyBg = MMI_TRUE;   
}


/*****************************************************************************
 * FUNCTION mmi_frm_reset_redraw_empty_bg
 *  
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/

void mmi_frm_reset_redraw_empty_bg()
{
    isRedrawEmptyBg = MMI_FALSE;   
}


/*****************************************************************************
 * FUNCTION mmi_frm_is_redraw_empty_bg
 *  
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/

MMI_BOOL mmi_frm_is_redraw_empty_bg()
{
    return isRedrawEmptyBg;   
}



/*****************************************************************************
 * FUNCTION mmi_frm_traverse_history
 *  
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/

typedef void (*TraverseOpFunc) (S16 scrn_idx, void* func_arg);


void mmi_frm_traverse_bg_screen(S16 start_idx, S16 end_idx, TraverseOpFunc history_op, TraverseOpFunc group_op, void* op_arg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 old_currHistoryIndex;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(start_idx >= 0);

    old_currHistoryIndex = currHistoryIndex;
    
    for (currHistoryIndex = start_idx; currHistoryIndex <= end_idx; currHistoryIndex++)
    {
        MMI_TRACE(MMI_FW_TRC_G6_FRM_DETAIL, MMI_FRM_SCENARIO_REDRAW_TRAVERSE_HIST, currHistoryIndex, historyData[currHistoryIndex].status, historyData[currHistoryIndex].isGroupNode);     
        
        /* the followiing if statement filter the case that activeScrnIndex and old_currHistoryIndex is not continuous */
        if ((currHistoryIndex == activeScrnIndex) || (currHistoryIndex <= old_currHistoryIndex))      
        {
            if (historyData[currHistoryIndex].isGroupNode)
            {
                /* For the screen group case, even the group node is in gobacking state, 
                   there may be some other screens in the group that is not at froeground.
                   Those screen also must be traverse.
                */
                if (historyData[currHistoryIndex].status == MMI_HIST_NODE_NORMAL)
                {
                    group_op(currHistoryIndex, op_arg);
                }
            }
            else
            {    
                if (historyData[currHistoryIndex].status == MMI_HIST_NODE_NORMAL)
                {
                    history_op(currHistoryIndex, op_arg);
                }
            }
        }
    }
    currHistoryIndex = old_currHistoryIndex;
    return;
}

static void group_check_small(S16 scrn_idx, void*  func_arg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    traverse_find_ctxt_struct  *find_ctxt_ptr = (traverse_find_ctxt_struct *) func_arg;
 
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    find_ctxt_ptr->tmp_idx = scrn_idx;
    group_check_small_by_id(historyData[scrn_idx].scrnID, find_ctxt_ptr);
}


static void history_check_small(S16 scrn_idx, void* func_arg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    traverse_find_ctxt_struct  *find_ctxt_ptr = (traverse_find_ctxt_struct *) func_arg;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_FW_TRC_G6_FRM_DETAIL, MMI_FRM_SCENARIO_REDRAW_HIST_CHECK_SMALL, historyData[scrn_idx].scrnID, historyData[scrn_idx].isSmallScreen);
    if (historyData[scrn_idx].scrnID == currSmallScrnID)
    {
        return;
    }
    if (historyData[scrn_idx].isSmallScreen == MMI_FALSE)
    {
        find_ctxt_ptr->history_idx = scrn_idx;
        find_ctxt_ptr->topmost_full_scrn_id = historyData[scrn_idx].scrnID;
    }
    MMI_TRACE(MMI_FW_TRC_G6_FRM_DETAIL, MMI_FRM_SCENARIO_REDRAW_FIND_CTXT_DUMP, find_ctxt_ptr->topmost_full_scrn_id, find_ctxt_ptr->history_idx, find_ctxt_ptr->tmp_idx);
}

static void history_redraw(S16 scrn_idx, void* func_arg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    traverse_redraw_ctxt_struct*  redraw_ctxt_ptr = (traverse_redraw_ctxt_struct *) func_arg;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (historyData[scrn_idx].scrnID == redraw_ctxt_ptr->topmost_full_scrn_id)
        redraw_ctxt_ptr->start_draw = MMI_TRUE;
    if (historyData[scrn_idx].scrnID == currSmallScrnID)
        redraw_ctxt_ptr->start_draw = MMI_FALSE;
   
    if (redraw_ctxt_ptr->start_draw == MMI_FALSE) 
        return;    

    IsBackHistory = MMI_TRUE;
    CheckMainLCDHistoryBack = MMI_TRUE;
    decrement_current_history_index();
    if (historyData[scrn_idx].entryFuncPtr)
    {
        mmi_frm_set_active_scrn_arg(historyData[scrn_idx].app_arg);
        g_frm_current_scrn_arg = historyData[scrn_idx].app_arg;
        curr_redraw_scrn = historyData[scrn_idx].scrnID;
        MMI_TRACE(MMI_FW_TRC_G6_FRM_DETAIL, MMI_FRM_SCENARIO_REDRAW_HISTORY_EXEC_ENTRY, curr_redraw_scrn, historyData[scrn_idx].entryFuncPtr, historyData[scrn_idx].app_arg);
        mmi_frm_reset_redraw_empty_bg();

        (*(historyData[scrn_idx].entryFuncPtr)) (historyData[scrn_idx].app_arg);
        if (mmi_frm_is_redraw_empty_bg())
        {
            mmi_frm_redraw_fill_empty_bg();
        }
        curr_redraw_scrn = SCR_ID_INVALID;
    }
}


static void group_redraw(S16 scrn_idx, void*  func_arg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    traverse_redraw_ctxt_struct*  redraw_ctxt_ptr = (traverse_redraw_ctxt_struct *) func_arg;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    // Run group adaptor redraw.
    // We need cleanup the latest screen which is redraw in screen group by adaptor exit fxn.
    history_redraw(scrn_idx, func_arg);

    // May merge follwoing function to group adaptor entry.
    group_redraw_by_id(historyData[scrn_idx].scrnID, redraw_ctxt_ptr);
}



extern void history_status_backup(history_ctxt_struct  *);
extern void history_status_restore(history_ctxt_struct  *);

void mmi_frm_redraw_bg()
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    traverse_find_ctxt_struct       find_ctxt;
    traverse_redraw_ctxt_struct     redraw_ctxt;
    history_ctxt_struct             backup_history;
    U16                             backup_active_scr_id;
    void*                           backup_g_frm_current_scrn_arg;
    S16                             search_end;    
    
    MMI_ID group_id = GRP_ID_INVALID;
    MMI_ID scrn_id  = GRP_ID_INVALID;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (isEnableSmallScrnRedraw == MMI_FALSE)
    {
        return;
    }
 
    /* backup orignal history status */
    history_status_backup(&backup_history);
    backup_active_scr_id = get_active_history_node_id();
    backup_g_frm_current_scrn_arg = g_frm_current_scrn_arg;
    mmi_frm_get_active_scrn_id(&group_id, &scrn_id);
    

    if (mmi_is_redrawing_bk_screens())
    {
        /* don't allow re-entry redraw */
        //MMI_ASSERT(MMI_FALSE);
        return;
    }

    MMI_TRACE(MMI_FW_TRC_G1_FRM, MMI_FRM_SCENARIO_START_SMALL_SCREEN_REDRAW);
    /* backup orignal group status */
    group_status_backup(&redraw_ctxt.backup_group_shell);

  if (redraw_ctxt.backup_group_shell.active_scrn)
    {
        currSmallScrnID = redraw_ctxt.backup_group_shell.active_scrn->id;
        search_end = activeScrnIndex;
    }
    else
    {
        currSmallScrnID = historyData[currHistoryIndex].scrnID;
        search_end = currHistoryIndex;
    }

    mmi_set_redrawing_bk_screens_status(MMI_HIST_SMALLSCREEN_ACTIVE);
    
    /* reset find context */
    find_ctxt.topmost_full_scrn_id = MMI_SCR_ID_INAVLID;
    find_ctxt.history_idx = 0;
    find_ctxt.tmp_idx = 0;

    /*  Traverse all history and scenario tree to find topmost full screen.
        The redraw will start at the place                                  */
    mmi_frm_traverse_bg_screen(0, search_end, history_check_small, group_check_small, (void *)&find_ctxt);

    gdi_lcd_freeze(TRUE);
    
    /* force small screen flatten always on */
    dm_force_small_screen_flatten();
    
    /* Redraw background screen, may include small screen, 
    the topmost small screen will be draw in next entryFuncPtr process below */
    redraw_ctxt.topmost_full_scrn_id = find_ctxt.topmost_full_scrn_id;
    redraw_ctxt.start_draw = MMI_FALSE;
    redraw_ctxt.skip_group_ptr = NULL;
    mmi_frm_traverse_bg_screen(find_ctxt.history_idx, search_end, history_redraw, group_redraw, (void *) &redraw_ctxt);
    
    /* unforce small screen flatten always on */
    dm_unforce_small_screen_flatten();            

    if (mmi_frm_shell_is_in_backward_scenario())
    {
        // For the case goback history -> group adaptor -> scrn_active -> redraw
        // Avoid the condition that the exit function of latest EntryNewScreen during redraw be skiped.
        EntryNewScreen(SCR_ID_DUMMY, NULL, NULL, NULL);
        ShowCategoryDummyScreen(); /* dummy category */
        history_status_restore(&backup_history);
        g_frm_current_scrn_arg = backup_g_frm_current_scrn_arg;
    }
    gui_sse_set_is_dummy_screen(MMI_FALSE);
    group_status_restore(&redraw_ctxt.backup_group_shell);
    set_active_history_node_id(backup_active_scr_id);
    set_active_scrn_id(group_id, scrn_id);

    gdi_lcd_freeze(FALSE);
    mmi_set_redrawing_bk_screens_status(MMI_HIST_SMALLSCREEN_ACTIVE_IN_EXIT_FUNC);
    MMI_TRACE(MMI_FW_TRC_G1_FRM, MMI_FRM_SCENARIO_END_SMALL_SCREEN_REDRAW);    
}


static void history_check_level(S16 scrn_idx, void* func_arg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    traverse_level_ctxt_struct*  level_ctx_ptr = (traverse_level_ctxt_struct *) func_arg;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    level_ctx_ptr->currLevel++;

    if (level_ctx_ptr->target_scrn_id == historyData[scrn_idx].scrnID)
        level_ctx_ptr->result = level_ctx_ptr->currLevel;
}

static void group_check_level(S16 scrn_idx, void*  func_arg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    traverse_level_ctxt_struct*  level_ctx_ptr = (traverse_level_ctxt_struct *) func_arg;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    group_check_level_by_id(historyData[scrn_idx].scrnID, level_ctx_ptr);
}

/*****************************************************************************
 * FUNCTION
 *  mmi_get_redrawing_bk_screens_status
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
mmi_hist_smallscreen_state_enum mmi_get_redrawing_bk_screens_status(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return redrawing_old_screens;
}

mmi_hist_smallscreen_state_enum GetSmallScreenState(void)
{
    return mmi_get_redrawing_bk_screens_status();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_get_redrawing_bk_screens_status
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
MMI_BOOL mmi_set_redrawing_bk_screens_status(mmi_hist_smallscreen_state_enum status)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    redrawing_old_screens = status;
    return MMI_TRUE;
}

/* events.c */

/*****************************************************************************
 * FUNCTION
 *  update_entry_exit_handler
 * DESCRIPTION
 *  This function is used to update curr exit handler and entry handler
 *
 * PARAMETERS
 *  exit_handler     :[IN] new exit handler 
 *  entry_handler    :[IN] new entry handler
 * RETURNS
 *  MMI_TRUE if application enter an dump screen or return MMI_FALSE
 *****************************************************************************/
static void update_entry_exit_handler(exit_func_ptr exit_handler, entry_func_ptr entry_handler)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    curr_exit_handler = exit_handler;
    curr_entry_handler = entry_handler;
}

void Deinit_active_screen_info(void)
{
    curr_exit_handler = NULL; 
    curr_entry_handler = NULL;
    curr_exit_scrn_arg_p = NULL;
    curr_entry_scrn_arg_p = NULL;
    currExitScrnID = 0;
    currActiveScrnID = 0;
    set_exit_scrn_id(GRP_ID_INVALID, SCR_ID_INVALID);
    set_active_scrn_id(GRP_ID_INVALID, SCR_ID_INVALID);    
}

void set_active_history_node_id(U16 id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    currActiveScrnID = id;
}

U16 get_active_history_node_id()
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return currActiveScrnID;
}

U16 get_active_scrn_type(void)
{
	return currActiveScrnType;
}

U16 get_exit_history_node_id()
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    return currExitScrnID;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_frm_create_new_screen
 * DESCRIPTION
 *  The application could use this API to create a new screen and pass the 
 *  screens argument through invoke the entry function of the screen.
 * PARAMETERS
 *  entry_func  [IN] The entry handler of the new screen. 
 *  arg         [IN] the screens argument
 * RETURNS
 *  If succeed returns MMI_TRUE, otherwise  
 *  Returns MMI_TRUE if it succeed; otherwise returns MMI_FALSE. 
 *****************************************************************************/
MMI_BOOL mmi_frm_create_new_screen(entry_func_ptr entry_func, void* arg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    curr_entry_scrn_arg_p = arg;
    g_frm_current_scrn_arg = arg;

    mmi_frm_set_active_scrn_user_data(arg);
    entry_func(arg);

    return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_entry_new_screen_int
 * DESCRIPTION
 *  This function is used for enter the new screen. When the applications call
 *  this function, it executes the previous screen's exit handler, and adds the
 *  previous screen in the history, then clears the key handlers and entries the
 *  new screen with the parameter setting. After the applications call 
 *  EntryNewScreen(), they can draw the specified category screen.
 * PARAMETERS
 *  new_scrn_id           [IN] The new screen ID will enter.       
 *  new_exit_handler      [IN] The exit handler of the new screen. It could be NULL.       
 *  new_entry_handler     [IN] The entry handler of the new screen. It could be NULL.       
 *  flag                  [IN] flag parameters.        
 *  is_clear_input_hdr    [IN] Need to clear all key handler when changing the scenario
 * RETURNS
 *  MMI_TRUE - enter the new screen succeed.
 *  MMI_FALSE - enter the new screen failed.
 *****************************************************************************/
U8 mmi_frm_entry_new_screen_int(U16 new_scrn_id, exit_func_ptr new_exit_handler, entry_func_ptr new_entry_handler, void *flag, MMI_BOOL is_clear_input_hdr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_frm_scrn_type_enum scrn_type = MMI_FRM_UNKNOW_SCRN;
    //MMI_BOOL    is_tab_page = MMI_FALSE;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if ((U32)flag == (U32)MMI_FULL_SCREEN)
    {
        scrn_type = MMI_FRM_FULL_SCRN;
    }
    else if ((U32)flag == (U32)MMI_SMALL_SCREEN)
    {
        scrn_type = MMI_FRM_SMALL_SCRN;
    }
    else if ((U32)flag == (U32)MMI_TAB_PAGE)
    {
        scrn_type = MMI_FRM_TAB_PAGE;
    }
    else if ((U32)flag == (U32)MMI_FRM_SCRN_GROUP)
    {
        scrn_type = MMI_FRM_SCRN_GROUP;
    }
    if (scrn_type != MMI_FRM_SCRN_GROUP)
    {
        MMI_TRACE(
            MMI_FW_TRC_G1_FRM,
            MMI_FRM_SCENARIO_CHANGE_ACTIVE_SCRN,
            GRP_ID_ROOT,
            new_scrn_id
            );        
    }
    if (mmi_frm_shell_is_in_backward_scenario())
    {
        /* We don't allow enter original screen (EntryNewScreen) in screen group goback process. */
        if (mmi_is_redrawing_bk_screens() == 0)
        {
            #ifdef __MTK_TARGET__
                MMI_TRACE(MMI_TRACE_ERROR, TRC_MMI_FRM_SCENARIO_CONFLICT);
                MMI_TRACE(MMI_FW_TRC_G1_FRM, TRC_MMI_FRM_SCENARIO_CONFLICT);
                return MMI_TRUE;
            #else
                kal_printf("ERROR !!!! We don't allow enter original screen (EntryNewScreen) in screen group goback process.\n");
                return MMI_TRUE;
//            MMI_ASSERT(0);
            #endif
        }
    }

#ifdef __TST_TRACE_ENABLED__
    mmi_frm_event_set_dump_history_flag(MMI_TRUE);
#endif /* __TST_TRACE_ENABLED__ */
    /* entry the new screen */
    if (flag != MMI_TAB_PAGE)
    {
        //is_tab_page = MMI_FALSE;
        mmi_frm_create_active_scrn(new_scrn_id, scrn_type, new_exit_handler, new_entry_handler);

        set_active_scrn_id(GRP_ID_ROOT, new_scrn_id);
        currActiveScrnID = new_scrn_id;
		currActiveScrnType = scrn_type;
        /* disable small screen flatten for full-screen APPs */
        if (flag == MMI_FULL_SCREEN)
        {
            dm_disable_small_screen_flatten();
        }
        else
        {
            dm_enable_small_screen_flatten();
        }

        ExecuteCurrExitHandler(scrn_type, is_clear_input_hdr);


        /* store the exit current Top entry screen */
        currExitScrnID = new_scrn_id;
        set_exit_scrn_id(GRP_ID_ROOT, new_scrn_id);

        //if (curr_entry_scrn_arg_p != NULL)
        {
            curr_exit_scrn_arg_p = curr_entry_scrn_arg_p;
            curr_entry_scrn_arg_p = NULL;
        }

        update_entry_exit_handler(new_exit_handler, new_entry_handler);
        mmi_frm_update_active_scrn_from_new_scrn();
    }
    else
    {
#ifdef HISTORY_TAB_MANGER
        //is_tab_page = MMI_TRUE;
        mmi_frm_create_active_scrn(new_scrn_id, scrn_type, new_exit_handler, new_entry_handler);
        ExecuteCurrExitHandler(scrn_type, is_clear_input_hdr);
        
        curr_tab_exit_func_ptr = (FuncPtr)new_exit_handler;
        curr_tab_entry_func_ptr = (FuncPtr)new_entry_handler;
        curr_tab_scrn_id = new_scrn_id;

        //if (curr_entry_scrn_arg_p != NULL)
        {
            curr_exit_scrn_arg_p = curr_entry_scrn_arg_p;
            curr_entry_scrn_arg_p = NULL;
        }

        mmi_frm_update_active_scrn_from_new_scrn();

    #ifndef __MMI_NOT_TAB_SUPPORT__
        SetKeyHandler(mmi_frm_general_tab_l_arrow_key_hdlr, KEY_LEFT_ARROW, KEY_EVENT_DOWN);
        SetKeyHandler(mmi_frm_general_tab_l_arrow_key_hdlr, KEY_LEFT_ARROW, KEY_EVENT_REPEAT);
        SetKeyHandler(mmi_frm_general_tab_r_arrow_key_hdlr, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
        SetKeyHandler(mmi_frm_general_tab_r_arrow_key_hdlr, KEY_RIGHT_ARROW, KEY_EVENT_REPEAT);
    #endif  /* __MMI_NOT_TAB_SUPPORT__ */
#endif /* HISTORY_TAB_MANGER */
    }
#ifdef __MMI_LCM_PRIMITIVE_FLUSH__
    mmi_frm_screen_change();
#endif /* __MMI_LCM_PRIMITIVE_FLUSH__ */

    return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_entry_new_screen
 * DESCRIPTION
 *  This function is used for enter the new screen. When the applications call
 *  this function, it executes the previous screen's exit handler, and adds the
 *  previous screen in the history, then clears the key handlers and entries the
 *  new screen with the parameter setting. After the applications call 
 *  EntryNewScreen(), they can draw the specified category screen.
 * PARAMETERS
 *  new_scrn_id           [IN] The new screen ID will enter.       
 *  new_exit_handler      [IN] The exit handler of the new screen. It could be NULL.       
 *  new_entry_handler     [IN] The entry handler of the new screen. It could be NULL.       
 *  flag                  [IN] flag parameters.        
 * RETURNS
 *  MMI_TRUE - enter the new screen succeed.
 *  MMI_FALSE - enter the new screen failed.
 *****************************************************************************/
U8 mmi_frm_entry_new_screen(U16 new_scrn_id, exit_func_ptr new_exit_handler, entry_func_ptr new_entry_handler, void *flag)
{
    MMI_TRACE(MMI_FW_TRC_G1_FRM, TRC_MMI_FRM_EVENT_ENTRYNEWSCR_BEGIN, new_scrn_id, new_exit_handler, new_entry_handler, (U32)flag);

    mmi_frm_entry_new_screen_int(new_scrn_id, new_exit_handler, new_entry_handler, flag, MMI_TRUE);

    MMI_TRACE(MMI_FW_TRC_G1_FRM, TRC_MMI_FRM_EVENT_ENTRYNEWSCR_END);
    return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_frm_entry_new_screen_ext
 * DESCRIPTION
 *  The behavior is the same with mmi_frm_create_new_screen(), but this function doesn't 
 *  clear the key handlers.
 * PARAMETERS
 *  newscrnID           [IN]   The new screen ID will enter.     
 *  newExitHandler      [IN]   The exit handler of the new screen. It could be NULL.      
 *  newEntryHandler     [IN]   The entry handler of the new screen. It could be NULL.     
 *  peerBuf             [IN]   Reserved.       
 * RETURNS
 *  MMI_TRUE - enter the new screen succeed.
 *  MMI_FALSE - enter the new screen failed.
 *****************************************************************************/
U8 mmi_frm_entry_new_screen_ext(U16 new_scrn_id, exit_func_ptr new_exit_handler, entry_func_ptr new_entry_handler, void *flag)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_FW_TRC_G1_FRM, TRC_MMI_FRM_EVENT_ENTRYNEWSCR_EXT_BEGIN, new_scrn_id, new_exit_handler, new_entry_handler, flag);

    mmi_frm_entry_new_screen_int(new_scrn_id, new_exit_handler, new_entry_handler, flag, MMI_FALSE);

    MMI_TRACE(MMI_FW_TRC_G1_FRM, TRC_MMI_FRM_EVENT_ENTRYNEWSCR_EXT_END);

    return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  ExecuteCurrExitHandler
 * DESCRIPTION
 * This function is used for executes current exit func handler without clear keys.
 * PARAMETERS
 *  is_clear_input_hdr      [IN]    If need to claer all key handlers
 * RETURNS
 *  void
 *****************************************************************************/
extern MMI_BOOL mmi_frm_is_active_scrn_group_node(void);
static void ExecuteCurrExitHandler(mmi_frm_scrn_type_enum scrn_type, MMI_BOOL is_clear_input_hdr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 count = 0;
    static MMI_BOOL goback_first_entry = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    is_in_exit_handler_proc = MMI_TRUE;
    mmi_frm_dss_clear_backup_string();

	/* 
     * Need new variable to record the first time of entrynewscreen in goback 
     * process, since IsBackHistory will be reset in mmi_frm_generic_exit_scrn.
     */
	goback_first_entry = IsBackHistory ? MMI_TRUE : MMI_FALSE;

    if (mmi_frm_is_active_scrn_group_node() == MMI_FALSE ||
        (mmi_frm_is_active_scrn_group_node() == MMI_TRUE && mmi_frm_is_in_backward_scenario()))
    {
        g_frm_current_scrn_arg = curr_exit_scrn_arg_p;        
        /* Failsafe common function before exit screen */
        UI_common_screen_pre_exit();

        for (count = 0; count < MAX_SUB_MENUS; count++)
        {
            subMenuDataPtrs[count] = subMenuData[count];
        }

#ifdef HISTORY_TAB_MANGER
        if (curr_tab_entry_func_ptr)
        {
            mmi_frm_tab_save_history(curr_tab_scrn_id, curr_tab_entry_func_ptr);
            curr_tab_entry_func_ptr = NULL;
        }

        if (curr_tab_exit_func_ptr)
        {
            curr_tab_exit_func_ptr();
            curr_tab_exit_func_ptr = NULL;        
        }
#endif
    }

    /* call GenericExitScreen if currEntryFuncPtr is not NULL */
    if (scrn_type != MMI_FRM_TAB_PAGE)
    {
        if (curr_entry_handler)
        {
            mmi_frm_generic_exit_scrn(currExitScrnID, curr_entry_handler);
        }

        if (curr_exit_handler)
        {
           MMI_TRACE(MMI_FW_TRC_G1_FRM, TRC_MMI_FRM_EVENT_ENTRYNEWSCR_EXIT_HDLR);
           mmu_frm_execute_scrn_exit_handler = MMI_TRUE;
           curr_exit_handler(curr_exit_scrn_arg_p);
           mmu_frm_execute_scrn_exit_handler = MMI_FALSE;
        }
    }

#ifdef __MMI_FRAMEWORK_BACKWARD_COMPATIBLE__
    /* reset g_mask_hilite_partent_id & g_mask_hilite_mask when entry new screen */
    g_mask_hilite_partent_id = 0;
    g_mask_hilite_mask = 0xFFFFFFFF;
#endif /* __MMI_FRAMEWORK_BACKWARD_COMPATIBLE__ */

    //if (!is_tab_page)
    if (scrn_type != MMI_FRM_TAB_PAGE)
    {/* Destroy handler should be invoked after ExitCategoryFunction in UI_common_screen_exit. */
        if (goback_first_entry && 
            (mmi_get_redrawing_bk_screens_status() != MMI_HIST_SMALLSCREEN_ACTIVE || GetScreenCountInHistory() == 0))
        {   /* If the full screen is invoked as background, we won't invoke destroy hdlr since the screen is still in history and destroyed. */
            /* execute the active screen's destroy callback function in goback process. */
            /* If historyData[0] is small screen, we also need to invoke destory hdlr here. */
            if (mmi_get_redrawing_bk_screens_status() == MMI_HIST_SMALLSCREEN_ACTIVE_IN_EXIT_FUNC)
            {/* For some casse: top_scrn_in_go_back_id == currExitScrnID if background entry won't invoke EntryNewScreen e.g. MAUI_02226149 */
                if (top_scrn_in_go_back_destroy_func)
                {
                    top_scrn_in_go_back_destroy_func(top_scrn_in_go_back_arg_p);
                }
				clear_scrn_layer_key_proc();
            }
            else
            {/* MMI_HIST_SMALLSCREEN_NONE */
                mmi_frm_exec_scrn_destroy_hdlr(currExitScrnID, curr_exit_scrn_arg_p);
				clear_scrn_layer_key_proc();
            }
        }
        /* execute the destroy callback function of MMI_HIST_NODE_WAIT_TO_DESTROY history node when the node is deleted. */
        mmi_frm_exec_scrn_wait_to_destroy_hdlr(MMI_HIST_NODE_WAIT_TO_DESTROY);
    }

    if (mmi_get_redrawing_bk_screens_status() == MMI_HIST_SMALLSCREEN_ACTIVE_IN_EXIT_FUNC)
    {
        /* After invoking small-screen's entry function, the small screen procedure is finished. */
        mmi_set_redrawing_bk_screens_status(MMI_HIST_SMALLSCREEN_NONE);
    }

    /* Failsafe common screen exit function   */
    UI_common_screen_exit();

    /* App may get current screen arg in UI_common_screen_exit, should update later. */
    g_frm_current_scrn_arg = curr_entry_scrn_arg_p;

    /* it clears all the key handlers, registered by the current screen */
    IsBackHistory = MMI_FALSE;

    mmi_frm_key_event_screen_switch_action();
#ifdef __MMI_TOUCH_SCREEN__
    mmi_frm_touch_screen_switch_action();
#endif
    /* reset all keypad tone to enabled state */


#ifdef __COSMOS_MMI_PACKAGE__
	mmi_frm_kbd_set_tone_state(MMI_KEY_TONE_DISABLED);
#else
    mmi_frm_kbd_set_tone_state(MMI_KEY_TONE_ENABLED);
#endif




    if (is_clear_input_hdr)
    {
        /* it clears all the key handlers, registered by the current screen */
        ClearInputEventHandler(MMI_DEVICE_KEY);
    }
    else
    {
        /* 
         * There is only one special screen EM_LOG_SCREEN_ID using EntryNewScreen_Ext
         * But this interface will not clear key handler in the past, so the translate key handler
         * will also not be cleared. It will be a problem for Venus Home Screen, because when
         * exit from ILDE venus will not happen to receive any key events any more, so
         * we clear the translate key handler here. In the future, we will ask engineer mode's collegue
         * to revise the screen EM_LOG_SCREEN_ID's implementaion
         */
        mmi_frm_clear_all_translate_key_handler();
    }

#ifdef __MMI_DOWNLOADABLE_THEMES_SUPPORT__
    mmi_tm_reset_imageid_image_header_pool();
  #ifdef __MMI_DLT_CACHE_SUPPORT__
    mmi_tm_clear_ondemand_cache();
  #endif 
#endif /* __MMI_DOWNLOADABLE_THEMES_SUPPORT__ */ 

    is_in_exit_handler_proc = MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_frm_set_active_scrn_arg
 * DESCRIPTION
 *  
 * PARAMETERS
 *    
 * RETURNS
 *  
 *****************************************************************************/
void mmi_frm_set_active_scrn_arg(void *arg_p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    curr_entry_scrn_arg_p = arg_p;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_frm_get_active_scrn_arg
 * DESCRIPTION
 *  
 * PARAMETERS
 *    
 * RETURNS
 *  
 *****************************************************************************/
void *mmi_frm_get_active_scrn_arg(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return curr_entry_scrn_arg_p;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_frm_set_curr_exit_handler
 * DESCRIPTION
 *  
 * PARAMETERS
 *    
 * RETURNS
 *  
 *****************************************************************************/
void* mmi_frm_get_exit_scrn_arg(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return curr_exit_scrn_arg_p;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_frm_set_curr_exit_hdlr
 * DESCRIPTION
 *  Sets current exit function
 * PARAMETERS
 *  ptr     [IN]  The pointer to the exit function.      
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_frm_set_curr_exit_hdlr(exit_func_ptr ptr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    curr_exit_handler = ptr;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_frm_get_curr_exit_hdlr
 * DESCRIPTION
 *  Get current exit function
 * PARAMETERS
 *  void
 * RETURNS
 *  The pointer to the current exit function
 *****************************************************************************/
exit_func_ptr mmi_frm_get_curr_exit_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return curr_exit_handler;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_frm_get_curr_entry_hdlr
 * DESCRIPTION
 *  Get current entry function
 * PARAMETERS
 *  void
 * RETURNS
 *  The pointer to the current entry function.
 *****************************************************************************/
entry_func_ptr mmi_frm_get_curr_entry_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return curr_entry_handler ;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_frm_set_curr_entry_hdlr
 * DESCRIPTION
 *  Sets current entry function
 * PARAMETERS
 *  ptr     [IN]  The pointer to the entry function.      
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_frm_set_curr_entry_hdlr(entry_func_ptr ptr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    curr_entry_handler = ptr;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_frm_replace_new_scrn_hdlr
 * DESCRIPTION
 *  This function is used for sets current new screen handlers.
 * PARAMETERS
 *  scrnID              [IN]   The screen ID.     
 *  exitFuncPtr         [IN]   The exit handler.     
 *  entryFuncPtr        [IN]   The entry handler.     
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_frm_replace_new_scrn_hdlr(U16 scrn_id, exit_func_ptr exit_func_p, entry_func_ptr entry_func_p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_FW_TRC_G1_FRM, MMI_FRM_INFO_EVENT_SETEXIT_HDLR, scrn_id);

    mmi_frm_update_active_scrn(scrn_id, MMI_FALSE, exit_func_p, entry_func_p, NULL);
    currExitScrnID = scrn_id;
    curr_exit_handler = exit_func_p;
    curr_entry_handler = entry_func_p;

}

/*****************************************************************************
 * FUNCTION
 *  mmi_frm_generic_exit_inline_scrn
 * DESCRIPTION
 *  This function is the general inline screen's exit handler. If the previous 
 *  screen is the inline editor screen and needs to add in the history, the 
 *  framework calls this function to execute the general exit handler first, 
 *  then tries to call its exit handler.
 * PARAMETERS
 *  scrn_id               [IN]        The specified screen ID will exit.
 *  entry_func_ptr        [IN]        The entry handler of the specified screen. 
 *                                  The specified screen should be inline editor
 *                                  screen.
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_frm_generic_exit_inline_scrn(U16 scrn_id, entry_func_ptr entry_func_ptr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    CloseCategory57Screen();

    if ((scrn_id == currExitScrnID) && (curr_exit_scrn_arg_p != NULL))
    {
        mmi_frm_add_history(scrn_id, entry_func_ptr, GetCategoryHistory, GetCategory57DataSize, 
                            GetCategory57Data, NULL, NULL, curr_exit_scrn_arg_p);
    }
    else
    {
        mmi_frm_add_history(scrn_id, entry_func_ptr, GetCategoryHistory, GetCategory57DataSize, 
                            GetCategory57Data, NULL, NULL, NULL);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_frm_generic_exit_scrn
 * DESCRIPTION
 *  This function is the general screen's exit handler. If the previous screen
 *  is the normal screen (not inline editor screen) and needs to add in the 
 *  history, the framework calls this function to execute the general exit 
 *  handler first, then tries to call its exit handler.
 * PARAMETERS
 *  scrnID              [IN]        The specified screen ID will exit.
 *  entryFuncPtr        [IN]        The entry handler of the specified screen. 
 *                                  The specified screen without inputBuffer[ ].
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_frm_generic_exit_scrn(U16 scrn_id, entry_func_ptr entry_func_ptr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    historyNode *hist;
	MMI_BOOL    add_hist = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_frm_get_scrn_pointer(scrn_id, &hist))
    {
		/* Check if the scrn_id is active screen */
    #ifdef HISTORY_TAB_MANGER
        if (!(hist->isTab))
    #endif
        {
			add_hist = MMI_TRUE;
		}
	}
	else
	{
		/* insert the new node (not the active screen) in the history  */
		add_hist = MMI_TRUE;
	}
	if (add_hist)
	{
        if ((scrn_id == currExitScrnID) && (curr_exit_scrn_arg_p != NULL))
        {
            mmi_frm_add_history(scrn_id, entry_func_ptr, GetCategoryHistory, NULL, NULL, NULL, NULL, curr_exit_scrn_arg_p);
        }
        else
        {
            mmi_frm_add_history(scrn_id, entry_func_ptr, GetCategoryHistory, NULL, NULL, NULL, NULL, NULL);
        }
        /* mini_tab_bar */
    #ifdef __MMI_WGUI_MINI_TAB_BAR__
        wgui_disable_mini_tab_bar();
    #endif
    }
}


/*****************************************************************************
 * FUNCTION
 *  
 * DESCRIPTION
 *
 * PARAMETERS
 *           
 * RETURNS
 * 
 *****************************************************************************/
U8 EntryNewScreen(U16 newscrnID, FuncPtr newExitHandler, FuncPtr newEntryHandler, void *flag)
{
	#if defined(__IV_TTS__) 
		Npr_Tts_stop_immediately();
	#endif
    return mmi_frm_entry_new_screen(newscrnID, (exit_func_ptr)newExitHandler, (entry_func_ptr)newEntryHandler, flag);
}


/*****************************************************************************
 * FUNCTION
 *  
 * DESCRIPTION
 *
 * PARAMETERS
 *           
 * RETURNS
 * 
 *****************************************************************************/
U8 EntryNewScreen_Ext(U16 newscrnID, FuncPtr newExitHandler, FuncPtr newEntryHandler, void *peerBuf)
{
	#if defined(__IV_TTS__) 
		Npr_Tts_stop_immediately();
	#endif
    return mmi_frm_entry_new_screen_ext(newscrnID, (exit_func_ptr)newExitHandler, (entry_func_ptr)newEntryHandler, peerBuf);
}


/*****************************************************************************
 * FUNCTION
 *  
 * DESCRIPTION
 *
 * PARAMETERS
 *           
 * RETURNS
 * 
 *****************************************************************************/
void SetCurrExitFuncPtr(FuncPtr ptr)
{
    mmi_frm_set_curr_exit_hdlr((exit_func_ptr)ptr);
}


/*****************************************************************************
 * FUNCTION
 *  
 * DESCRIPTION
 *
 * PARAMETERS
 *           
 * RETURNS
 * 
 *****************************************************************************/
FuncPtr GetCurrExitFuncPtr(void)
{
    return  (FuncPtr)mmi_frm_get_curr_exit_hdlr();
}


/*****************************************************************************
 * FUNCTION
 *  
 * DESCRIPTION
 *
 * PARAMETERS
 *           
 * RETURNS
 * 
 *****************************************************************************/
void SetCurrEntryFuncPtr(FuncPtr ptr)
{
    mmi_frm_set_curr_entry_hdlr((entry_func_ptr)ptr);
}


/*****************************************************************************
 * FUNCTION
 *  
 * DESCRIPTION
 *
 * PARAMETERS
 *           
 * RETURNS
 * 
 *****************************************************************************/
FuncPtr GetCurrEntryFuncPtr(void)
{
    return (FuncPtr)mmi_frm_get_curr_entry_hdlr();
}


/*****************************************************************************
 * FUNCTION
 *  
 * DESCRIPTION
 *
 * PARAMETERS
 *           
 * RETURNS
 * 
 *****************************************************************************/
void ReplaceNewScreenHandler(U16 scrnID, FuncPtr exitFuncPtr, FuncPtr entryFuncPtr)
{
   mmi_frm_replace_new_scrn_hdlr(scrnID, (exit_func_ptr)exitFuncPtr, (entry_func_ptr)entryFuncPtr);

}


/*****************************************************************************
 * FUNCTION
 *  
 * DESCRIPTION
 *
 * PARAMETERS
 *           
 * RETURNS
 * 
 *****************************************************************************/
void GenericExitInlineScreen(U16 scrnID, FuncPtr entryFuncPtr)
{
     mmi_frm_generic_exit_inline_scrn(scrnID, (entry_func_ptr)entryFuncPtr);
}


/*****************************************************************************
 * FUNCTION
 *  
 * DESCRIPTION
 *
 * PARAMETERS
 *           
 * RETURNS
 * 
 *****************************************************************************/
void GenericExitScreen(U16 scrnID, FuncPtr entryFuncPtr)
{
   mmi_frm_generic_exit_scrn(scrnID, (entry_func_ptr)entryFuncPtr);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_execute_scrn_exit_func
 * DESCRIPTION
 *  This function is used for check if framework executes the screen's exit 
 *  handler.
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL mmi_execute_scrn_exit_func(void)
{
    return mmu_frm_execute_scrn_exit_handler;
}


/*****************************************************************************
 * FUNCTION
 *  ClearExitHandler
 * DESCRIPTION
 *  This function is used for special scenarios. If the applications enter 
 *  the special screen A and want to go back to the idle screen directly 
 *  after exiting the screen A, they could use this function to clear the 
 *  pervious screen's exit hanler before enter the special screen.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ClearExitHandler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_FW_TRC_G1_FRM, MMI_FRM_INFO_EVENT_CLREXIT_HDLR);
    mmi_frm_update_active_scrn(0, MMI_FALSE, NULL, NULL, NULL);
    currExitScrnID = 0;
    curr_exit_handler = NULL; 
    curr_entry_handler = NULL;
    curr_exit_scrn_arg_p = NULL;
    curr_entry_scrn_arg_p = NULL;
}

/*****************************************************************************
 * FUNCTION
 *  history_status_backup
 * DESCRIPTION
 *  backup_history_ptr        [in]  storage for history content     
 * PARAMETERS
 * RETURNS
 *  U8
 *****************************************************************************/
void history_status_backup(history_ctxt_struct  *backup_history_ptr)
{
    backup_history_ptr->currExitScrnID = currExitScrnID;
    backup_history_ptr->curr_entry_handler = curr_entry_handler;
    backup_history_ptr->curr_entry_scrn_arg_p = curr_entry_scrn_arg_p;
    backup_history_ptr->curr_exit_handler = curr_exit_handler;
    backup_history_ptr->curr_exit_scrn_arg_p = curr_exit_scrn_arg_p;
}

/*****************************************************************************
 * FUNCTION
 *  history_status_restore
 * DESCRIPTION
 * PARAMETERS
 *  backup_history_ptr        [in]  storage for history content     
 * RETURNS
 *  U8
 *****************************************************************************/
void history_status_restore(history_ctxt_struct  *backup_history_ptr)
{
    currExitScrnID = backup_history_ptr->currExitScrnID;
    curr_entry_handler = backup_history_ptr->curr_entry_handler;
    curr_entry_scrn_arg_p = backup_history_ptr->curr_entry_scrn_arg_p;
    curr_exit_handler = backup_history_ptr->curr_exit_handler;
    curr_exit_scrn_arg_p = backup_history_ptr->curr_exit_scrn_arg_p;
}


/*****************************************************************************
 * FUNCTION
 *  SetActiveScreenId
 * DESCRIPTION
 *  Sets the current active screen ID.
 * PARAMETERS
 *  scrnId      [IN]  the screen ID      
 * RETURNS
 *  void
 *****************************************************************************/
void SetActiveScreenId(U16 scrnId)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    set_active_scrn_id(GRP_ID_ROOT, scrnId);
}


/*****************************************************************************
 * FUNCTION
 *  SetExitScreenId
 * DESCRIPTION
 *  Sets the current exit screen ID.
 * PARAMETERS
 *  scrnId      [IN]  the screen ID      
 * RETURNS
 *  void
 *****************************************************************************/
void SetExitScreenId(U16 scrnId)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/	
	set_exit_scrn_id(GRP_ID_ROOT, scrnId);
}



#ifdef HISTORY_TAB_MANGER

void mmi_frm_tab_save_history(U16 scrnID, FuncPtr entryFuncPtr)
{

    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    history h;
    U16 nHistory = 0;

    h.scrnID = scrnID;
    h.entryFuncPtr = entryFuncPtr;
    mmi_ucs2cpy((S8*) h.inputBuffer, (S8*) & nHistory);

    GetCategoryHistory(h.guiBuffer);
    mmi_frm_add_tab_history(scrnID, &h);     

}


/*****************************************************************************
 * FUNCTION
 *  mmi_frm_reset_tab
 * DESCRIPTION
 *  Reset tab structure and free memory resource.
 * PARAMETERS
 *  tab_info_p  [IN] pointer of tab information struture
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_frm_reset_tab(mmi_frm_tab_group_struct *tab_info_p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
//    MMI_TRACE(PLUTO_FW_TRC_SCREEN, TRC_MMI_FRM_HIST_RESET_TAB, tab_info_p);
    mmi_frm_release_tab_group(tab_info_p);
    if ((void *)tab_info_p == (void *)MMI_HIST_EXIT_SCREEN_TYPE || (void *)tab_info_p == (void *)MMI_HIST_EXIT_SCREEN_IN_END_KEY_TYPE)
    {
        mmi_frm_free_tab_bar_items();
    }
    memset(tab_info_p, 0, sizeof(mmi_frm_tab_group_struct));
}


/*****************************************************************************
 * FUNCTION
 *  mmi_frm_reset_tab
 * DESCRIPTION
 *  Check if tab information has been loaded from history to tab_group.
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_TRUE if tab information has been loaded from gui buffer into tab_group
 *  MMI_FALSE if has not been loaded
 *****************************************************************************/
static MMI_BOOL mmi_frm_is_tab_info_loaded(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    return (tab_group.entry_func_ptr != NULL && tab_group.tab_history_p != NULL) ? MMI_TRUE : MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_frm_is_tab_history
 * DESCRIPTION
 *  Check if scrnid is a tab screen in history stack.
 * PARAMETERS
 *  scrnid      [IN]    screen id
 * RETURNS
 *  MMI_TRUE if scrnid is tab screen
 *  MMI_FALSE if not
 *****************************************************************************/
static MMI_BOOL mmi_frm_is_tab_history(U16 scrnid)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    
    if (-1 == currHistoryIndex)
    {
        if (historyData[0].scrnID == scrnid)
        {
            return (historyData[0].isTab);
        }
    } 
    else if (historyData[currHistoryIndex].scrnID == scrnid)
    {
        return (historyData[currHistoryIndex].isTab);
    }
       
    return MMI_FALSE;

}


/*****************************************************************************
 * FUNCTION
 *  mmi_frm_reset_tab_history
 * DESCRIPTION
 *  Release tab group resource scrnid is a tab screen.
 * PARAMETERS
 *  scrnid      [IN]    screen id
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_frm_reset_tab_history(U16 scrnid)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    historyNode* node;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    node = NULL;
    
    if (-1 == currHistoryIndex)
    {
        if (historyData[0].scrnID == scrnid)
        {
            node = &historyData[0];
        }
    } 
    else if (historyData[currHistoryIndex].scrnID == scrnid)
    {
        node = &historyData[currHistoryIndex];
    }
    
    if(node && node->isTab)
    {
        if(node->guiBuffer)
            mmi_frm_release_tab_group((mmi_frm_tab_group_struct*)node->guiBuffer);
        node->isTab = 0;
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_frm_general_tab_entry_int
 * DESCRIPTION
 *  This function is used for create a tab manager and attaches it to an 
 *  instance of a tab group screen. 
 * PARAMETERS
 *  scrnId               [IN] the specified Screen ID.
 *  entry_func_ptr       [IN] entry function pointer.
 *  tab_pages_info_array [IN] information array of tab pages.
 *  tab_pages_count      [IN] count of tab pages.
 *  sel_idx              [IN] tab page selected index
 * RETURNS
 *  Return MMI_TRUE if enter tab screen successfully;
 *  Return MMI_FALSE if can't get tab_group from gui buffer.
 *****************************************************************************/
static MMI_BOOL mmi_frm_general_tab_entry_int(U16 screen_id, FuncPtr entry_func_ptr, mmi_frm_tab_struct *tab_pages_info_array, U8 tab_pages_count, U8 sel_idx)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i;
    mmi_frm_tab_group_struct *temp_p;    

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(screen_id, mmi_frm_general_tab_exit, NULL, NULL);

    if((!IsMainLCDHistoryBack() && !mmi_is_redrawing_bk_screens()) ||
        !mmi_frm_is_tab_history(screen_id))
        /* FMGR - one entry with one scrnid, non-tab scrn -> dummy scrn -> goback -> tab scrn */
    {
tab_reinit:
//        MMI_TRACE(PLUTO_FW_TRC_SCREEN, TRC_MMI_FRM_HIST_GEN_TAB_FIRST_ENTRY, entry_func_ptr, tab_pages_count, sel_idx);
        /* 
         * Coyp of tab_group has been recorded in history->guibuffer, 
         * all the element could be updated if enter another tab page.
         */
	    tab_group.scrn_id = screen_id;
        tab_group.tab_page_count = tab_pages_count;
		tab_group.entry_func_ptr = entry_func_ptr;
		MMI_ASSERT(NULL == tab_group.tab_history_p);
        tab_group.tab_history_p = OslMalloc(sizeof(mmi_frm_tab_history_node_struct)*tab_pages_count);
        memset(tab_group.tab_history_p, 0, sizeof(mmi_frm_tab_history_node_struct)*tab_pages_count);

        for(i = 0; i<tab_pages_count; i++)
        {
            tab_group.tab_history_p[i].screen_id = tab_pages_info_array[i].screen_id;
            tab_group.tab_history_p[i].entry_func_ptr = tab_pages_info_array[i].tab_entry_func;
        }
        wgui_horizontal_tab_bar_set_first_displayed_item((S8)UI_HORIZONTAL_TAB_BAR_ERROR_INDEX);
        wgui_horizontal_tab_bar_set_use_pen_switch(MMI_FALSE);
    }
    else
    {
//        MMI_TRACE(PLUTO_FW_TRC_SCREEN, TRC_MMI_FRM_HIST_GEN_TAB_OTHER_ENTRY, screen_id, entry_func_ptr, tab_pages_count, sel_idx);
        temp_p = (mmi_frm_tab_group_struct *)GetCurrGuiBuffer(screen_id);

        if (NULL == temp_p)
        {
            return MMI_FALSE;            
        }

        if(temp_p->tab_page_count != tab_pages_count)
        {
            mmi_frm_release_tab_group(temp_p);
            goto tab_reinit;
        }

        memcpy(&tab_group, temp_p, sizeof(mmi_frm_tab_group_struct));
        sel_idx = tab_group.cur_sel_index;
        
        wgui_horizontal_tab_bar_set_first_displayed_item (tab_group.tab_bar_first_item_index);
        wgui_horizontal_tab_bar_set_use_pen_switch(tab_group.use_pen_switch);
    }

    SetDelScrnIDCallbackHandler(screen_id, mmi_frm_general_tab_delete_hdlr);

    mmi_frm_set_tab_bar_items(tab_pages_info_array, tab_pages_count);

    mmi_frm_set_cur_sel_page(sel_idx);

    if (mmi_is_redrawing_bk_screens())
    {/* 
      * Load tab info from history into tab_group for temporay use to show background,
      * Need to reset tab_group here 
      */
        memset(&tab_group, 0, sizeof(mmi_frm_tab_group_struct));
    }

    return MMI_TRUE;

}


/*****************************************************************************
 * FUNCTION
 *  mmi_frm_general_tab_entry_ex
 * DESCRIPTION
 *  This function is used for create a tab manager and attaches it to an 
 *  instance of a tab group screen. 
 * PARAMETERS
 *  scrnId               [IN] the specified Screen ID.
 *  entry_func_ptr       [IN] entry function pointer.
 *  tab_pages_info_array [IN] information array of tab pages.
 *  tab_pages_count      [IN] count of tab pages.
 *  sel_idx              [IN] tab page selected index
 * RETURNS
 *  Return MMI_TRUE if enter tab screen successfully;
 *  Return MMI_FALSE if can't get tab_group from gui buffer.
 *****************************************************************************/
MMI_BOOL mmi_frm_general_tab_entry_ex(U16 screen_id, FuncPtr entry_func_ptr, mmi_frm_tab_struct *tab_pages_info_array, U8 tab_pages_count, U8 sel_idx)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return mmi_frm_general_tab_entry_int(screen_id, entry_func_ptr, tab_pages_info_array, tab_pages_count, sel_idx);

}


/*****************************************************************************
 * FUNCTION
 *  mmi_frm_general_tab_entry
 * DESCRIPTION
 *  This function is used for create a tab manager and attaches it to an 
 *  instance of a tab group screen. 
 * PARAMETERS
 *  scrnId               [IN] the specified Screen ID.
 *  entry_func_ptr       [IN] entry function pointer.
 *  tab_pages_info_array [IN] information array of tab pages.
 *  tab_pages_count      [IN] count of tab pages.
 * RETURNS
 *  Return MMI_TRUE if enter tab screen successfully;
 *  Return MMI_FALSE if can't get tab_group from gui buffer.
 *****************************************************************************/
MMI_BOOL mmi_frm_general_tab_entry(U16 screen_id, FuncPtr entry_func_ptr, mmi_frm_tab_struct *tab_pages_info_array, U8 tab_pages_count)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return mmi_frm_general_tab_entry_int(screen_id, entry_func_ptr, tab_pages_info_array, tab_pages_count, tab_group.cur_sel_index);

}


/*****************************************************************************
 * FUNCTION
 *  mmi_frm_general_tab_exit
 * DESCRIPTION
 *  This function is used for save information about tab group. The 
 *  information include which tab page be selected and the pointer to 
 *  attached tab manager buffer.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_frm_general_tab_exit(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    historyNode *history_p;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_is_redrawing_bk_screens())
    {
        return;
    }
//    MMI_TRACE(PLUTO_FW_TRC_SCREEN, TRC_MMI_FRM_HIST_GEN_TAB_EXIT_HDLR);
    tab_group.tab_bar_first_item_index = wgui_horizontal_tab_bar_get_first_displayed_item();
    tab_group.use_pen_switch = wgui_horizontal_tab_bar_get_use_pen_switch();
    AddHistoryEx(tab_group.scrn_id, tab_group.entry_func_ptr, mmi_frm_get_tab_group_data, NULL, NULL, NULL, NULL);
    
    if (!IsMainLCDHistoryBack())
    {
        GetHistoryPointer(tab_group.scrn_id, &history_p);
        history_p->isTab = MMI_TRUE;
    }
    /* 
     * We could clear structure here since tab history memory will be freed in delete callback 
     * or entry function for special case.
     */
    memset(&tab_group, 0, sizeof(mmi_frm_tab_group_struct));
    mmi_frm_free_tab_bar_items();

    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_frm_general_tab_delete_hdlr
 * DESCRIPTION
 *  This function is used for destroy tab manager.
 * PARAMETERS
 *   void*
 * RETURNS
 *  Allow deleting
 *****************************************************************************/
U8 mmi_frm_general_tab_delete_hdlr(void* p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_frm_tab_group_struct *tab_info_p;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
//    MMI_TRACE(PLUTO_FW_TRC_SCREEN, TRC_MMI_FRM_HIST_GEN_TAB_DELETE_HDLR, p);
    if (p == (void *)MMI_HIST_EXIT_SCREEN_TYPE || p == (void *)MMI_HIST_EXIT_SCREEN_IN_END_KEY_TYPE)
    {/* ExecTopScrnCallbackHandler won't input history->guibuffer */
        tab_info_p = &tab_group;
    }
    else if (p == (void *)MMI_HIST_DELETE_SCREEN_TYPE || p == (void *)MMI_HIST_DELETE_SCREEN_IN_END_KEY_TYPE)
    {/* 
      * If mmi_frm_hold_history_buffer in goback process, historyData.guiBuffer will be NULL,
      * ExecHistoryScrnCallBackHandle_ex will input MMI_HIST_DELETE_SCREEN_TYPE.
      */
        return MMI_HIST_ALLOW_DELETING;
    }
    else
    {
        tab_info_p = (mmi_frm_tab_group_struct *)p;
    }
    mmi_frm_reset_tab(tab_info_p);

    return MMI_HIST_ALLOW_DELETING;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_frm_get_tab_group_data
 * DESCRIPTION
 *  This function is used to get tab group structure data.
 * PARAMETERS
 *  buffer  [OUT] tab_group structure information
 * RETURNS
 *  Pointer of tab_group structure information.
 *****************************************************************************/
static U8* mmi_frm_get_tab_group_data(U8* buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memcpy(buffer, &tab_group, sizeof(mmi_frm_tab_group_struct));

    return buffer;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_frm_release_tab_group
 * DESCRIPTION
 *  This function is used for release the specific tab manager.
 * PARAMETERS
 *  tab_group_p [IN] pointer of tab group structure
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_frm_release_tab_group(mmi_frm_tab_group_struct* tab_group_p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
//    MMI_TRACE(PLUTO_FW_TRC_SCREEN, TRC_MMI_FRM_HIST_RELEASE_TAB_GROUP, tab_group_p->tab_page_count, tab_group_p->tab_history_p);
    for(i = 0; i < tab_group_p->tab_page_count; i++)
    {
        if (NULL != tab_group_p->tab_history_p[i].gui_buffer)
        {
            OslMfree(tab_group_p->tab_history_p[i].gui_buffer);
            tab_group_p->tab_history_p[i].gui_buffer = NULL;
        }
        if (NULL != tab_group_p->tab_history_p[i].input_buffer)
        {
            OslMfree(tab_group_p->tab_history_p[i].input_buffer);
            tab_group_p->tab_history_p[i].input_buffer = NULL;
        }               
    }
    
    if (tab_group_p->tab_history_p)
    {
        OslMfree(tab_group_p->tab_history_p);
        tab_group_p->tab_history_p = NULL;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_frm_find_tab_history
 * DESCRIPTION
 *  Find history node information of tab page by tab page screen id.
 * PARAMETERS
 *  screen_id   [IN] screen id
 * RETURNS
 *  Tab history node pointer.
 *****************************************************************************/
static mmi_frm_tab_history_node_struct *mmi_frm_find_tab_history(U16 screen_id) 
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for(i = 0; i < tab_group.tab_page_count; i++)
    {
        if (tab_group.tab_history_p[i].screen_id == screen_id)
        {
//            MMI_TRACE(PLUTO_FW_TRC_SCREEN, TRC_MMI_FRM_HIST_FIND_TAB_HIST, screen_id, i);
            return &tab_group.tab_history_p[i];
        }
    }

    return NULL;    
}


/*****************************************************************************
 * FUNCTION
 *  add_tab_history
 * DESCRIPTION
 *  This function is used to save information about a tab page in a tab group.
 * PARAMETERS
 *  screen_id           [IN] tap page screen id
 *  tab_page_history    [IN] information of added taba page
 * RETURNS
 *  MMI_TRUE success to add tab history;
 *  MMI_FALSE fail to add tab history
 *****************************************************************************/
MMI_BOOL mmi_frm_add_tab_history(U16 screen_id , history *tab_page_history)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_frm_tab_history_node_struct *temp_p = NULL;
    S32 length = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
//    MMI_TRACE(MMI_FW_TRC_G1_FRM, TRC_MMI_FRM_HIST_ADD_TAB_HIST, screen_id);
    if (CheckMainLCDHistoryBack == MMI_TRUE)
    {
//        MMI_TRACE(PLUTO_FW_TRC_SCREEN, TRC_MMI_FRM_HIST_ADD_TAB_HIST_ERR1);
        return MMI_FALSE; 
    }

    temp_p = mmi_frm_find_tab_history(screen_id);

    if (NULL != temp_p)
    {
        if (temp_p->gui_buffer != NULL)
        {
            OslMfree(temp_p->gui_buffer);
            temp_p->gui_buffer = NULL;
        }
        if (temp_p->input_buffer != NULL)
        {
            OslMfree(temp_p->input_buffer);
            temp_p->input_buffer = NULL;
        }

        memset(temp_p, 0, sizeof(mmi_frm_tab_history_node_struct));
        temp_p->screen_id = tab_page_history->scrnID;
        temp_p->entry_func_ptr = tab_page_history->entryFuncPtr;
       
        temp_p->gui_buffer = OslMalloc(MAX_GUI_BUFFER);
        memcpy(temp_p->gui_buffer, tab_page_history->guiBuffer, MAX_GUI_BUFFER);

        length = mmi_ucs2strlen((PS8) tab_page_history->inputBuffer);
        MMI_ASSERT(length * ENCODING_LENGTH + ENCODING_LENGTH <= MAX_INPUT_BUFFER);
        if (length)
        {
            temp_p->input_buffer = OslMalloc(length * ENCODING_LENGTH + ENCODING_LENGTH);
            mmi_ucs2cpy((PS8) temp_p->input_buffer, (PS8) tab_page_history->inputBuffer);
        }        
    }
    else
    {
//        MMI_TRACE(PLUTO_FW_TRC_SCREEN, TRC_MMI_FRM_HIST_ADD_TAB_HIST_ERR2, screen_id);
        return MMI_FALSE; 
    }

    return MMI_TRUE;        
}


/*****************************************************************************
 * FUNCTION
 *  mmi_frm_add_tab_n_history
 * DESCRIPTION
 *  This function is used to save information about a tab page in a tab group.
 * PARAMETERS
 *  screen_id           [IN] tap page screen id
 *  tab_page_history    [IN] information of added taba page
 *  size                [IN] User specifies data size for input buffer.      
 * RETURNS
 *  MMI_TRUE success to add tab history;
 *  MMI_FALSE fail to add tab history
 *****************************************************************************/
MMI_BOOL mmi_frm_add_tab_n_history(U16 screen_id , history *tab_page_history, U16 size)
{    
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_frm_tab_history_node_struct *temp_p = NULL;
   
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
//    MMI_TRACE(MMI_FW_TRC_G1_FRM, TRC_MMI_FRM_HIST_ADD_TAB_N_HIST, screen_id, size);
    if (CheckMainLCDHistoryBack == MMI_TRUE)
    {
//        MMI_TRACE(PLUTO_FW_TRC_SCREEN, TRC_MMI_FRM_HIST_ADD_TAB_N_HIST_ERR1);
        return MMI_FALSE; 
    }
    
    temp_p = mmi_frm_find_tab_history(screen_id);

    if (NULL != temp_p)
    {
        if (temp_p->gui_buffer != NULL)
        {
            OslMfree(temp_p->gui_buffer);
            temp_p->gui_buffer = NULL;
        }
        if (temp_p->input_buffer != NULL)
        {
            OslMfree(temp_p->input_buffer);
            temp_p->input_buffer = NULL;
        }

        memset(temp_p, 0, sizeof(mmi_frm_tab_history_node_struct));
        temp_p->screen_id = tab_page_history->scrnID;
        temp_p->entry_func_ptr = tab_page_history->entryFuncPtr;
       
        temp_p->gui_buffer = OslMalloc(MAX_GUI_BUFFER);
        memcpy(temp_p->gui_buffer, tab_page_history->guiBuffer, MAX_GUI_BUFFER);
        
        MMI_ASSERT(size + ENCODING_LENGTH + MMI_FRM_INPUT_BUFFER_HEADER_SIZE <= MAX_INPUT_BUFFER);
        temp_p->input_buffer = OslMalloc(size + ENCODING_LENGTH + MMI_FRM_INPUT_BUFFER_HEADER_SIZE);
        memcpy(temp_p->input_buffer, &size, MMI_FRM_INPUT_BUFFER_HEADER_SIZE);
        memcpy((PS8) (temp_p->input_buffer + MMI_FRM_INPUT_BUFFER_HEADER_SIZE), (PS8) tab_page_history->inputBuffer, (U32) size);       
    }
    else
    {
//        MMI_TRACE(PLUTO_FW_TRC_SCREEN, TRC_MMI_FRM_HIST_ADD_TAB_N_HIST_ERR2);
        return MMI_FALSE; 
    }

    return MMI_TRUE;       
}

/*****************************************************************************
 * FUNCTION
 *  mmi_frm_set_first_sel_page
 * DESCRIPTION
 *  Set current select index of tab page.
 * PARAMETERS
 *  index   [IN] page index
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_frm_set_first_sel_page(S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
//    MMI_TRACE(MMI_FW_TRC_G1_FRM, TRC_MMI_FRM_HIST_SET_FIRST_SEL_PAGE, index);
    tab_group.cur_sel_index = index;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_frm_get_cur_sel_page
 * DESCRIPTION
 *  Get current select index of tab page.
 * PARAMETERS
 *  void
 * RETURNS
 *  Page index
 *****************************************************************************/
U8 mmi_frm_get_cur_sel_page(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
//    MMI_TRACE(MMI_FW_TRC_G1_FRM, TRC_MMI_FRM_HIST_GET_CUR_SEL_PAGE, tab_group.cur_sel_index);
    return tab_group.cur_sel_index;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_frm_get_cur_tab_gui_buffer
 * DESCRIPTION
 *  Get gui buffer pointer by screen id.
 * PARAMETERS
 *  screen_id   [IN] screen id
 * RETURNS
 *  Gui buffer pointer
 *****************************************************************************/
U8 *mmi_frm_get_cur_tab_gui_buffer(U16 screen_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_frm_tab_history_node_struct *temp_p = NULL;
   
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    temp_p = mmi_frm_find_tab_history(screen_id);

    if (NULL != temp_p)
    {
//        MMI_TRACE(PLUTO_FW_TRC_SCREEN, TRC_MMI_FRM_HIST_GET_CUR_TAB_GUIBUF);
        return temp_p->gui_buffer;
    }
    else
    {
//        MMI_TRACE(PLUTO_FW_TRC_SCREEN, TRC_MMI_FRM_HIST_GET_CUR_TAB_GUIBUF_ERR);
        return NULL; 
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_frm_get_cur_tab_input_buffer
 * DESCRIPTION
 *  Get input buffer pointer by screen id.
 * PARAMETERS
 *  screen_id   [IN] screen id
 * RETURNS
 *  Input buffer pointer
 *****************************************************************************/
U8 *mmi_frm_get_cur_tab_input_buffer(U16 screen_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_frm_tab_history_node_struct *temp_p = NULL;
   
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    temp_p = mmi_frm_find_tab_history(screen_id);

    if (NULL != temp_p)
    {
//        MMI_TRACE(PLUTO_FW_TRC_SCREEN, TRC_MMI_FRM_HIST_GET_CUR_TAB_INPUTBUF);
         return temp_p->input_buffer;             
    }
    else
    {
//        MMI_TRACE(PLUTO_FW_TRC_SCREEN, TRC_MMI_FRM_HIST_GET_CUR_TAB_INPUTBUF_ERR);
        return NULL;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_frm_get_cur_tab_n_input_buffer
 * DESCRIPTION
 *  Get input buffer pointer by screen id.
 * PARAMETERS
 *  screen_id   [IN]  screen id
 *  size        [OUT] input buffer size 
 * RETURNS
 *  Input buffer pointer
 *****************************************************************************/
U8 *mmi_frm_get_cur_tab_n_input_buffer(U16 screen_id, U16 *size)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_frm_tab_history_node_struct *temp_p = NULL;
    MMI_FRM_INPUT_BUFFER_HEADER_TYPE buffer_header;
   
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    temp_p = mmi_frm_find_tab_history(screen_id);

    if (NULL != temp_p)
    {
        
        if (NULL ==  temp_p->input_buffer)
        {
            *size = 0;
//            MMI_TRACE(PLUTO_FW_TRC_SCREEN, TRC_MMI_FRM_HIST_GET_CUR_TAB_N_INPUTBUF_ERR2);
            return NULL;
        }
        else
        {
            memcpy(&buffer_header, temp_p->input_buffer, MMI_FRM_INPUT_BUFFER_HEADER_SIZE);
            *size = (U16)(buffer_header);
//            MMI_TRACE(PLUTO_FW_TRC_SCREEN, TRC_MMI_FRM_HIST_GET_CUR_TAB_N_INPUTBUF);
            return ((temp_p->input_buffer) + MMI_FRM_INPUT_BUFFER_HEADER_SIZE);
        }
    }
    else
    {
//        MMI_TRACE(PLUTO_FW_TRC_SCREEN, TRC_MMI_FRM_HIST_GET_CUR_TAB_N_INPUTBUF_ERR1);
        return NULL; 
    }
}

/*****************************************************************************
 * FUNCTION
 *  mmi_frm_set_tab_bar_items
 * DESCRIPTION
 *  Set tab bar information.
 * PARAMETERS
 *  tab_pages_info_array    [IN] tab page information array
 *  tab_pages_count         [IN] count of tab pages
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_frm_set_tab_bar_items(mmi_frm_tab_struct *tab_pages_info_array, U8 tab_pages_count)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 i;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(tab_pages_count > 0);

    mmi_frm_free_tab_bar_items();
    g_tab_bar_items_p = OslMalloc(sizeof(tab_bar_item_type)*tab_pages_count);
    g_tab_bar_num = tab_pages_count;

    for (i = 0; i <tab_pages_count; i++)
    {
        g_tab_bar_items_p[i].icon  = tab_pages_info_array[i].tab_icon;
        g_tab_bar_items_p[i].text  = (UI_string_type)tab_pages_info_array[i].tab_string;
        g_tab_bar_items_p[i].flags = 0;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_frm_free_tab_bar_items
 * DESCRIPTION
 *  Free tab bar information memory.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_frm_free_tab_bar_items(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
//    MMI_TRACE(PLUTO_FW_TRC_SCREEN, TRC_MMI_FRM_HIST_FREE_TAB_BAR_ITEMS);
    if (g_tab_bar_items_p)
    {
        OslMfree(g_tab_bar_items_p);
        g_tab_bar_items_p = NULL;
        g_tab_bar_num = 0;
    }
}

MMI_BOOL mmi_frm_get_tab_bar_items_int(tab_bar_item_type *tab_bar_items_p, S8 *tabs_p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
   
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
//    MMI_TRACE(PLUTO_FW_TRC_SCREEN, TRC_MMI_FRM_HIST_GET_TAB_BAR_ITEMS);
    *tabs_p = g_tab_bar_num;
    if (g_tab_bar_num == 0)
    {
//        MMI_TRACE(PLUTO_FW_TRC_SCREEN, TRC_MMI_FRM_HIST_GET_TAB_BAR_ITEMS_ERR);
        return MMI_FALSE;       
    }

    memcpy(tab_bar_items_p, g_tab_bar_items_p, sizeof(tab_bar_item_type)*g_tab_bar_num);

    return MMI_TRUE;    
}


/*****************************************************************************
 * FUNCTION
 *  mmi_frm_general_tab_entry_change_page_index
 * DESCRIPTION
 *  This function is used for change the first page index in history
 * PARAMETERS
 *   screen_id  [IN] screen id
 *   page_index [IN] tab page index
 * RETURNS
 *  MMI_TRUE if success to change page index;
 *  MMI_FALSE if fail to change page index.
 *****************************************************************************/
MMI_BOOL mmi_frm_general_tab_entry_change_page_index(U16 screen_id, U8 page_index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_frm_tab_group_struct *temp_p;    
    historyNode* ptrHistory;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (GetHistoryPointer(screen_id, &ptrHistory) && ptrHistory->isTab)
    {
        temp_p = (mmi_frm_tab_group_struct *)ptrHistory->guiBuffer;
        
        if (temp_p != NULL && temp_p->tab_page_count > page_index)
        {
            temp_p->cur_sel_index = page_index;
//            MMI_TRACE(PLUTO_FW_TRC_SCREEN, TRC_MMI_FRM_HIST_GEN_TAB_ENTRY_CHANGE_PAGE_IDX);
            return MMI_TRUE;
        }
    }
//    MMI_TRACE(PLUTO_FW_TRC_SCREEN, TRC_MMI_FRM_HIST_GEN_TAB_ENTRY_CHANGE_PAGE_IDX_ERR);

    return MMI_FALSE;
}

#endif /* HISTORY_TAB_MANGER */


/*****************************************************************************
 * FUNCTION
 *  mmi_frm_get_argument_with_screen
 * DESCRIPTION
 *  The application could use this API to get the argument of the screen ID.
 * PARAMETERS
 *  ScrnID    [IN] the specific screen ID.
 * RETURNS
 *  The argument of the specific screen ID.
 *****************************************************************************/
void* mmi_frm_get_argument_with_screen(U16 scrn_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 index;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (get_active_history_node_id() == scrn_id)
    {
        MMI_TRACE(PLUTO_FW_TRC_SCREEN, TRC_MMI_FRM_HIST_GET_ARG_WITH_SCRN_EXIT, scrn_id);
        return mmi_frm_get_exit_scrn_arg();
    }

    
    index = searched_history_node(topHistoryIndex, scrn_id);

    if (index >= 0)
    {
        MMI_TRACE(PLUTO_FW_TRC_SCREEN, TRC_MMI_FRM_HIST_GET_ARG_WITH_SCRN_HIST, scrn_id, index);
        return historyData[index].app_arg;
    }
    else
    {
        MMI_TRACE(PLUTO_FW_TRC_SCREEN, TRC_MMI_FRM_HIST_GET_ARG_WITH_SCRN_NULL, scrn_id);
        return NULL; 
    }
        
}


/*****************************************************************************
 * FUNCTION
 *  mmi_frm_get_current_screen_argument
 * DESCRIPTION
 *  The application could use this API to get the argument of the current screen.
 * PARAMETERS
 *  void
 * RETURNS
 *  The argument of the current screen.
 *****************************************************************************/ 
void* mmi_frm_get_current_screen_argument(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return g_frm_current_scrn_arg;    
}


/*****************************************************************************
 * FUNCTION
 *  mmi_frm_get_screen_info
 * DESCRIPTION
 *  The application could use this API to query the information of current screen.
 * PARAMETERS
 *  
 * RETURNS
 * 
 *****************************************************************************/ 
MMI_BOOL mmi_frm_get_screen_info(U16 scrn_id, mmi_frm_scrn_info_struct *info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(scrn_id == SCR_ID_INVALID)
    {
        MMI_TRACE(PLUTO_FW_TRC_SCREEN, TRC_MMI_FRM_HIST_GET_SCRN_INFO_ERR, scrn_id);
        return MMI_FALSE;
    }
    
    info->curr_scrn_id = get_exit_history_node_id();
    info->new_scrn_id  = get_active_history_node_id();
    
    if (scrn_id == curr_redraw_scrn)
    {
       info->state = MMI_FRM_SCREEN_REDRAW;
    }
    else if (scrn_id == curr_delete_scrn)
    {
        info->state = MMI_FRM_SCREEN_DELETE;
    }
    else if (scrn_id == curr_destroy_scrn)
    {
        info->state = MMI_FRM_SCREEN_DESTROY;    
    }    
    else if (scrn_id == get_active_history_node_id() || scrn_id == get_exit_history_node_id())
    {
        if (bBackHistoryFlag)
        {
            info->state = MMI_FRM_SCREEN_BACKWARD;
        }
        else
        {
            info->state = MMI_FRM_SCREEN_FORWARD;
        }
    }
    else if (IsScreenPresent(scrn_id))
    {
        info->state = MMI_FRM_SCREEN_INACTIVE;
    }
    else 
    {
        info->state = MMI_FRM_SCREEN_NONE;
    }
    MMI_TRACE(PLUTO_FW_TRC_SCREEN, TRC_MMI_FRM_HIST_GET_SCRN_INFO, scrn_id, info->state);

    return MMI_TRUE;
    
}


/*****************************************************************************
 * FUNCTION
 *  mmi_frm_set_hist_ui_data
 * DESCRIPTION
 *  The ui layer such as wgui, categroy and SSE can use the api to set its data for each screen
 *  The data is resever for the outside module use, history and screen group mechanism will not
 *  depend on the value to work.
 * PARAMETERS
 *  scrn_id    [IN] the specific screen ID.
 *  uiData     [IN] data for ui layer
 * RETURNS
 *  
 *****************************************************************************/ 
mmi_ret mmi_frm_set_hist_ui_data(U16 scrn_id, U32  uiData)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (count = 0; count < MAX_HISTORY; count++)
    {
        if (historyData[count].scrnID == scrn_id && historyData[count].status == MMI_HIST_NODE_NORMAL)
        {
            historyData[count].uiData = uiData;

            return MMI_RET_OK;
        }
    }
    return MMI_RET_ERR;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_frm_get_hist_ui_data
 * DESCRIPTION
 *  The ui layer such as wgui, categroy and SSE can use the api to get its data for each screen
 *  The data is resever for the outside module use, history and screen group mechanism will not
 *  depend on the value to work.
 * PARAMETERS
 *  scrn_id    [IN] the specific screen ID.
 * RETURNS
 *  data for ui layer
 *****************************************************************************/ 
U32 mmi_frm_get_hist_ui_data(U16 scrn_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (count = 0; count < MAX_HISTORY; count++)
    {
        if (historyData[count].scrnID == scrn_id && historyData[count].status == MMI_HIST_NODE_NORMAL)
        {
            return historyData[count].uiData;
        }
    }
    return 0;
}
#endif /* __MMI_FRM_HISTORY__ */


/*****************************************************************************
 * FUNCTION
 *  mmi_frm_event_set_dump_history_flag
 * DESCRIPTION
 *  Set dump history flag
 * PARAMETERS
 *  flag    [IN]    falg value
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_frm_event_set_dump_history_flag(MMI_BOOL flag)
{
#ifdef __TST_TRACE_ENABLED__
    g_dump_history = flag;
#endif /* __TST_TRACE_ENABLED__ */
}


/*****************************************************************************
 * FUNCTION
 *  mmi_frm_event_get_dump_history_flag
 * DESCRIPTION
 *  Set dump history flag
 * PARAMETERS
 *  void
 * RETURNS
 *  Reture MMI_TRUE means need to dump history content 
 *****************************************************************************/
MMI_BOOL mmi_frm_event_get_dump_history_flag(void)
{
#ifdef __TST_TRACE_ENABLED__
    return g_dump_history;
#else
    return MMI_FALSE;
#endif /* __TST_TRACE_ENABLED__ */
}

/*****************************************************************************
 * FUNCTION
 *  HistoryDump
 * DESCRIPTION
 *  Dumps the history to file or debug window
 *  
 *  HistoryDump will be used for dbugging purposes
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HistoryDump(void)
{
#ifdef __TST_TRACE_ENABLED__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_FRM_HISTORY__
    S16 count = 0;

    //count = currHistoryIndex;
    count = activeScrnIndex;
    MMI_TRACE(MMI_FW_TRC_G1_FRM,
        MMI_FRM_INFO_HIST_ACTIVE_SCRN_LABEL,
        mmi_frm_group_get_active_id(),
        mmi_frm_scrn_get_active_id());
#ifndef __MTK_TARGET__
    kal_printf("***** dump start *****\n");
#endif

    if (count >= 0)
    {
        do
        {
            if (count == currHistoryIndex)
            {
                MMI_TRACE(MMI_FW_TRC_G1_FRM, MMI_FRM_INFO_HIST_INACTIVE_SCRN_LABEL);
            }

    	    if (historyData[count].status == MMI_HIST_NODE_NORMAL)
   	        {
                MMI_TRACE(MMI_FW_TRC_G1_FRM, MMI_FRM_INFO_HIST_DUMP_HDLR, count, historyData[count].scrnID);
            #ifndef __MTK_TARGET__
                kal_printf("[Main HISTORY] idx:%d, scrn_id: [0x%04x]  \n", count, historyData[count].scrnID);
            #endif
            /*
                if (historyData[count].isGroupNode)
                {
                    mmi_frm_dump_node(historyData[count].app_arg, 0);
                }
            */
            }
            --count;      

        } while ((count >= MIN_HISTORY) && (historyData[count].entryFuncPtr != NULL));
    }
#endif
    DUMP_TREE_ALL;

#ifndef __MTK_TARGET__
    {
        extern void mmi_frm_dbg_dump_shell(void);
        mmi_frm_dbg_dump_shell();
    }
#endif
#ifndef __32_32_SEG__
    applib_mem_ap_dump();
#endif
#ifdef __MMI_SUBLCD__
    SubLCDHistoryDump();
#endif /* __MMI_SUBLCD__ */
#endif /* __TST_TRACE_ENABLED__ */
}


/*****************************************************************************
 * FUNCTION
 *  GoBackHistory
 * DESCRIPTION
 *  This is used to goback previous screen history
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void GoBackHistory(void)
{
    mmi_frm_scrn_close_active_id();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_is_redrawing_bk_screens
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
S32 mmi_is_redrawing_bk_screens()
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_FRM_HISTORY__
    if (mmi_execute_scrn_exit_func())
    {
        if (redrawing_old_screens == MMI_HIST_SMALLSCREEN_ACTIVE ||
            redrawing_old_screens == MMI_HIST_SMALLSCREEN_ACTIVE_IN_EXIT_FUNC)
        {
            MMI_TRACE(MMI_FW_TRC_G6_FRM_DETAIL, TRC_MMI_FRM_HIST_IS_REDRAW_BK, redrawing_old_screens);
            return 1;
        }
        else
        {
            return 0;
        }
    }
    else
    {
        MMI_TRACE(MMI_FW_TRC_G6_FRM_DETAIL, TRC_MMI_FRM_HIST_IS_REDRAW_BK, redrawing_old_screens);
        return (redrawing_old_screens == MMI_HIST_SMALLSCREEN_ACTIVE) ? 1 : 0;
    }
#else
    return mmi_frm_scenario_is_redrawing() ? 1: 0;
#endif
}

/*****************************************************************************
 * FUNCTION
 *  set_small_screen
 * DESCRIPTION
 *  Called by category to tell history that the screen being drawn is small.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void set_small_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (no_small_screen)
    {
        MMI_TRACE(MMI_FW_TRC_G6_FRM_DETAIL, TRC_MMI_FRM_HIST_SET_SMALL_SCRN_ERR);
        return;
    }

    MMI_TRACE(MMI_FW_TRC_G6_FRM_DETAIL, TRC_MMI_FRM_HIST_SET_SMALL_SCRN);

    gui_sse_set_is_small_screen(MMI_TRUE);

    if (mmi_frm_group_get_active_id() != GRP_ID_INVALID)
    {
        mmi_frm_scrn_set_attribute(mmi_frm_group_get_active_id(), mmi_frm_scrn_get_active_id(), MMI_SCRN_ATTRIB_SMALL_SCRN);
    }
#ifdef __MMI_FRM_HISTORY__
    else
    {
        if (currHistoryIndex == -1)
        {
            clear_screen();
        }
        small_history_node = 1;
    }
#endif
}


/*****************************************************************************
 * FUNCTION
 *  reset_small_screen
 * DESCRIPTION
 *  Called by category to tell history that it is exiting from small screen.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void reset_small_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_sse_set_is_small_screen(MMI_FALSE);

    small_history_node = 0;
    no_small_screen = 0;
}


/*****************************************************************************
 * FUNCTION
 *  restore_small_screen
 * DESCRIPTION
 *  Restores small screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void restore_small_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    no_small_screen = 0;
}


/*****************************************************************************
 * FUNCTION
 *  force_no_small_screen
 * DESCRIPTION
 *  Called by Application to disable small screen history saving.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void force_no_small_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    no_small_screen = 1;
}


/* 
 * enable_resized_small_screen(), disable_resized_small_screen(), and whether_no_small_screen()
 * There is no relation with small screen process in history.
 * It's only used for tha WGUI and application and decide to 
 * show the small screen or the normal screen.
 */


/*****************************************************************************
 * FUNCTION
 *  enable_resized_small_screen
 * DESCRIPTION
 *  Called by application to enable the small screen.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void enable_resized_small_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    small_screen_enabled = 1;
}


/*****************************************************************************
 * FUNCTION
 *  disable_resized_small_screen
 * DESCRIPTION
 *  Called on exiting the small screen.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void disable_resized_small_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    small_screen_enabled = 0;
}


/*****************************************************************************
 * FUNCTION
 *  whether_no_small_screen
 * DESCRIPTION
 *  Tells whether small screen is enabled or not
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
S32 whether_no_small_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return small_screen_enabled;
}


/*****************************************************************************
 * FUNCTION
 *  GetExitScrnID
 * DESCRIPTION
 *  This function is used for query the screen ID that will be exited. 
 * PARAMETERS
 *  void
 * RETURNS
 *  Return the screen ID that will be exited.
 *****************************************************************************/
U16 GetExitScrnID(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_ID group_id;
    MMI_ID scrn_id;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_frm_get_exit_scrn_id(&group_id, &scrn_id);
    return scrn_id;
}


/*****************************************************************************
 * FUNCTION
 *  GetActiveScreenId
 * DESCRIPTION
 *  This function is used for query the current active screen ID. The 
 *  application use this function to get the current active screen ID in 
 *  different occasions.
 * PARAMETERS
 *  void
 * RETURNS
 *  Return the screen ID
 *****************************************************************************/
U16 GetActiveScreenId(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_ID group_id = GRP_ID_INVALID;
    MMI_ID scrn_id  = GRP_ID_INVALID;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_frm_get_active_scrn_id(&group_id, &scrn_id);
    return scrn_id;
}

/*****************************************************************************  
*  Tab Bar Manager Series APIs
*****************************************************************************/

/*****************************************************************************
 * FUNCTION
 *  mmi_frm_get_tab_bar_items
 * DESCRIPTION
 *  Get tab bar intem information
 * PARAMETERS
 *  tab_bar_items_p [OUT] tab bar item information
 *  tabs_p          [OUT] tab bar count
 * RETURNS
 *  MMI_FALSE if tab bar count is 0;
 *  MMI_TRUE if success to get tab bar.
 *****************************************************************************/
MMI_BOOL mmi_frm_get_tab_bar_items(tab_bar_item_type *tab_bar_items_p, S8 *tabs_p)
{
#ifndef __MMI_NOT_TAB_SUPPORT__
    return mmi_frm_scrn_tab_get_bar_items(tab_bar_items_p, tabs_p);
#else
    return MMI_TRUE;
#endif /* __MMI_NOT_TAB_SUPPORT__ */
}


/*****************************************************************************
 * FUNCTION
 *  mmi_frm_set_cur_sel_page
 * DESCRIPTION
 *  Select a tab page in the tab group and enter this page.
 * PARAMETERS
 *  index   [IN] page index
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_frm_set_cur_sel_page (S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
  
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef HISTORY_TAB_MANGER
    if (tab_group.entry_func_ptr != NULL)
    {
        if(index < tab_group.tab_page_count)
        {        
            tab_group.cur_sel_index = index;
            tab_group.tab_history_p[index].entry_func_ptr();
        }
    }
    else
#endif
#ifndef __MMI_NOT_TAB_SUPPORT__
    {
        mmi_frm_scrn_tab_change_page_index(
            mmi_frm_group_get_active_id(),
            mmi_frm_scrn_tab_get_active_id(),
            (U8)index);
    }
#endif /* __MMI_NOT_TAB_SUPPORT__ */
    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_frm_general_tab_l_arrow_key_hdlr
 * DESCRIPTION
 *  Left arrow key handler of tab page.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_frm_general_tab_l_arrow_key_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(PLUTO_FW_TRC_SCREEN, TRC_MMI_FRM_HIST_TAB_L_ARROW_KEY_HDLR);
#ifndef __MMI_NOT_TAB_SUPPORT__
    if (mmi_frm_scrn_tab_get_active_id() != SCR_ID_INVALID)
    {
        /* If it is in screen group, we use screen group tab left arrow key handler */
        tab_l_arrow_key_hdlr();
        return;
    }
#endif /* __MMI_NOT_TAB_SUPPORT__ */
#ifdef HISTORY_TAB_MANGER

    if(tab_group.tab_page_count <= 1)
        return;
    if (tab_group.cur_sel_index > 0)
    {
        tab_group.cur_sel_index--;
    }
    else
    {
        tab_group.cur_sel_index = tab_group.tab_page_count - 1;
    }

    wgui_horizontal_tab_bar_store_first_displayed_item();
    mmi_frm_set_cur_sel_page(tab_group.cur_sel_index);
#endif /* HISTORY_TAB_MANGER */
}




/*****************************************************************************
 * FUNCTION
 *  mmi_frm_general_tab_r_arrow_key_hdlr
 * DESCRIPTION
 *  Right arrow key handler of tab page.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_frm_general_tab_r_arrow_key_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(PLUTO_FW_TRC_SCREEN, TRC_MMI_FRM_HIST_TAB_R_ARROW_KEY_HDLR);
#ifndef __MMI_NOT_TAB_SUPPORT__
    if (mmi_frm_scrn_tab_get_active_id() != SCR_ID_INVALID)
    {
        /* If it is in screen group, we use screen group tab right arrow key handler */
        tab_r_arrow_key_hdlr();
        return;
    }
#endif
#ifdef HISTORY_TAB_MANGER

    if(tab_group.tab_page_count <= 1)
        return;
    if (tab_group.cur_sel_index < tab_group.tab_page_count - 1)
    {
        tab_group.cur_sel_index++;
    }
    else
    {
        tab_group.cur_sel_index = 0;
    }
    wgui_horizontal_tab_bar_store_first_displayed_item();
    mmi_frm_set_cur_sel_page(tab_group.cur_sel_index);
#endif
}


/*****************************************************************************
 * FUNCTION
 *  mmi_frm_query_screen_level
 * DESCRIPTION
 *      
 * PARAMETERS
 *  
 * RETURNS
 *      the screen level(order) in history node
 *****************************************************************************/
U32 mmi_frm_get_screen_level(U16 scrn_id)
{
#ifdef __MMI_FRM_HISTORY__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16                             search_end;    
    traverse_level_ctxt_struct      level_ctxt;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_LCM_PRIMITIVE_FLUSH__
        search_end = activeScrnIndex;
#else
    if (mmi_frm_shell_is_in_backward_scenario())
    {
    search_end = activeScrnIndex;
    }
    else 
    {
        search_end = currHistoryIndex;
    }
#endif

    level_ctxt.target_scrn_id = scrn_id;
    level_ctxt.result = 0;
    level_ctxt.currLevel = 0;
    mmi_frm_traverse_bg_screen(0, search_end, history_check_level, group_check_level, (void *)&level_ctxt);
    return level_ctxt.result;
#else
    return mmi_frm_get_screen_level_sg(scrn_id);
#endif
}
/*****************************************************************************
 * FUNCTION
 *  mmi_frm_in_exit_hdlr_proc
 * DESCRIPTION
 *  Check if in exit handler process which means in ExecuteCurrExitHandler function.
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL mmi_frm_in_exit_hdlr_proc(void)
{
#ifdef __MMI_FRM_HISTORY__

    return is_in_exit_handler_proc;
#else
    return mmi_frm_in_exit_hdlr_proc_sg();
#endif
}

void mmi_frm_switch_small_screen_redraw(MMI_BOOL enable)
{
#ifdef __MMI_FRM_HISTORY__
    isEnableSmallScrnRedraw = enable;
#else
    mmi_frm_switch_small_screen_redraw_sg(enable);
#endif
}

void mmi_frm_redraw_fill_empty_bg()
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gdi_handle          gdi_base;
    UI_filled_area*     bg_filler;
    S32                 x1, y1, x2, y2;
    #ifdef __MMI_SCREEN_ROTATE__
    S32 tmp;
    #endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    x1 = y1 = 0;
    x2 = MAIN_LCD_DEVICE_WIDTH - 1; 
    y2 = MAIN_LCD_DEVICE_HEIGHT - 1; 
    bg_filler = current_MMI_theme->sub_menu_bkg_filler;

#ifdef __MMI_SCREEN_ROTATE__
    if (mmi_frm_is_screen_width_height_swapped())
    {       
        bg_filler = (current_MMI_theme->rotated_bkg_filler);
        if (bg_filler == NULL)
        {
            gdi_image_draw_id(0, 0, IMG_SCREEN_ROTATE_BACKGROUND);
            return;
        }
        tmp = x2;
        x2 = y2;
        y2 = tmp;
    }
#endif

    gdi_layer_get_base_handle(&gdi_base);
    gdi_layer_push_and_set_active(gdi_base);
    gui_draw_filled_area(x1, y1, x2, y2, bg_filler);
    gdi_layer_pop_and_restore_active();
}

void mmi_frm_event_set_switch_screen_flag(MMI_BOOL flag)
{
    g_switch_flag = flag;
}


MMI_BOOL mmi_frm_event_get_switch_screen_flag(void)
{ 
    return g_switch_flag;
}
/********************* End of Tab Bar Manager Series APIs ****************/

/**********************************************************************************
 * History unit test
 * We provide some history unit tests for new history mechanism
 * Re-entry case:
 * goback -> goback
 * delete cb (goback) -> delete history
 * delete cb || destroy cb -> goback (forbidden)
 **********************************************************************************/
#ifdef ENHANCE_HISTORY_UNIT_TEST
/* 
 * Create an history array to present test screen argument, hold information of  
 * screen id, screen name, operation action etc.
 */
#include "GlobalDefs.h"
#include "TimerEvents.h" 
/*****************************************************************************  
 * Define 
 *****************************************************************************/
#define HISTORY_TEST_CASE_SCR_NUM   10
#define HISTORY_TEST_CASE_STEP_NUM  30
#define HISTORY_TEST_CASE_STEP_STR_LEN  30

typedef enum
{
    /* These values will be used as index of test case data base */
    UT_TYPE_HISTORY_GOBACK_REENTRY,
    UT_TYPE_HISTORY_DELETE_REENTRY,
    UT_TYPE_HISTORY_GOBACK_TO_HISTORY,
    UT_TYPE_HISTORY_SMALL_SCRN_REDRAW,
    UT_TYPE_HISTORY_END
} mmi_frm_history_test_case_type;

typedef enum
{
    UT_STEP_ERROR = -1,
    UT_STEP_BEGIN,
    UT_STEP_SCR_A_ENTRY_CB,
    UT_STEP_SCR_A_DELETE_CB,
    UT_STEP_SCR_A_EXIT_CB,
    UT_STEP_SCR_A_DESTROY_CB,
    UT_STEP_SCR_B_ENTRY_CB,
    UT_STEP_SCR_B_DELETE_CB,
    UT_STEP_SCR_B_EXIT_CB,
    UT_STEP_SCR_B_DESTROY_CB,
    UT_STEP_SCR_C_ENTRY_CB,
    UT_STEP_SCR_C_DELETE_CB,
    UT_STEP_SCR_C_EXIT_CB,
    UT_STEP_SCR_C_DESTROY_CB,
    UT_STEP_SCR_D_ENTRY_CB,
    UT_STEP_SCR_D_DELETE_CB,
    UT_STEP_SCR_D_EXIT_CB,
    UT_STEP_SCR_D_DESTROY_CB,
    UT_STEP_SCR_E_ENTRY_CB,
    UT_STEP_SCR_E_DELETE_CB,
    UT_STEP_SCR_E_EXIT_CB,
    UT_STEP_SCR_E_DESTROY_CB,
    UT_STEP_END
} mmi_frm_history_test_case_step_content;

/*****************************************************************************  
 * Local variable 
 *****************************************************************************/
static history history_node_arr[HISTORY_TEST_CASE_SCR_NUM];
static U8 history_node_idx = 0;
/* The base screen id is the original current screen id */
static U16 test_case_base_scrid = 0;
void* test_case_scrn_arg = NULL;

typedef struct
{
    U8 step_index;
    mmi_frm_history_test_case_step_content history_test_case_step_info[HISTORY_TEST_CASE_STEP_NUM];
} mmi_frm_history_test_case_context_struct;

static mmi_frm_history_test_case_context_struct mmi_frm_history_test_case_context;

static U8 mmi_frm_history_test_case_step_content_str[UT_STEP_END][HISTORY_TEST_CASE_STEP_STR_LEN] = 
{
    "0", 
    "UT_STEP_SCR_A_ENTRY_CB", "UT_STEP_SCR_A_DELETE_CB", "UT_STEP_SCR_A_EXIT_CB", "UT_STEP_SCR_A_DESTROY_CB",
    "UT_STEP_SCR_B_ENTRY_CB", "UT_STEP_SCR_B_DELETE_CB", "UT_STEP_SCR_B_EXIT_CB", "UT_STEP_SCR_B_DESTROY_CB",
    "UT_STEP_SCR_C_ENTRY_CB", "UT_STEP_SCR_C_DELETE_CB", "UT_STEP_SCR_C_EXIT_CB", "UT_STEP_SCR_C_DESTROY_CB",
    "UT_STEP_SCR_D_ENTRY_CB", "UT_STEP_SCR_D_DELETE_CB", "UT_STEP_SCR_D_EXIT_CB", "UT_STEP_SCR_D_DESTROY_CB",
    "UT_STEP_SCR_E_ENTRY_CB", "UT_STEP_SCR_E_DELETE_CB", "UT_STEP_SCR_E_EXIT_CB", "UT_STEP_SCR_E_DESTROY_CB",
};

static const mmi_frm_history_test_case_step_content mmi_frm_history_test_case_step_database[UT_TYPE_HISTORY_END][HISTORY_TEST_CASE_STEP_NUM] = 
{
    /* UT_TYPE_HISTORY_GOBACK_REENTRY */
    {UT_STEP_SCR_D_ENTRY_CB, UT_STEP_SCR_C_ENTRY_CB, UT_STEP_SCR_D_EXIT_CB, UT_STEP_SCR_B_ENTRY_CB, 
     UT_STEP_SCR_C_EXIT_CB, UT_STEP_SCR_A_ENTRY_CB, UT_STEP_SCR_B_EXIT_CB,
     UT_STEP_SCR_A_DELETE_CB, UT_STEP_SCR_B_ENTRY_CB, UT_STEP_SCR_A_EXIT_CB, UT_STEP_SCR_A_DESTROY_CB,
     UT_STEP_SCR_B_DELETE_CB, UT_STEP_SCR_C_ENTRY_CB, UT_STEP_SCR_B_EXIT_CB, UT_STEP_SCR_B_DESTROY_CB,
     UT_STEP_SCR_C_DELETE_CB, UT_STEP_SCR_D_ENTRY_CB, UT_STEP_SCR_C_EXIT_CB, UT_STEP_SCR_C_DESTROY_CB, UT_STEP_END},
    /* UT_TYPE_HISTORY_DELETE_REENTRY */
    {UT_STEP_SCR_E_ENTRY_CB, UT_STEP_SCR_D_ENTRY_CB, UT_STEP_SCR_E_EXIT_CB, UT_STEP_SCR_C_ENTRY_CB, UT_STEP_SCR_D_EXIT_CB,
     UT_STEP_SCR_B_ENTRY_CB, UT_STEP_SCR_C_EXIT_CB, UT_STEP_SCR_A_ENTRY_CB, UT_STEP_SCR_B_EXIT_CB, 
     UT_STEP_SCR_A_DELETE_CB, UT_STEP_SCR_B_DELETE_CB, UT_STEP_SCR_B_DESTROY_CB, UT_STEP_SCR_C_DELETE_CB, UT_STEP_SCR_C_DESTROY_CB,
     UT_STEP_SCR_D_DELETE_CB, UT_STEP_SCR_D_DESTROY_CB, UT_STEP_SCR_E_ENTRY_CB, UT_STEP_SCR_A_EXIT_CB, UT_STEP_SCR_A_DESTROY_CB, UT_STEP_END},
    /* UT_TYPE_HISTORY_GOBACK_TO_HISTORY */
    {UT_STEP_SCR_E_ENTRY_CB, UT_STEP_SCR_D_ENTRY_CB, UT_STEP_SCR_E_EXIT_CB, UT_STEP_SCR_C_ENTRY_CB, UT_STEP_SCR_D_EXIT_CB,
     UT_STEP_SCR_B_ENTRY_CB, UT_STEP_SCR_C_EXIT_CB, UT_STEP_SCR_A_ENTRY_CB, UT_STEP_SCR_B_EXIT_CB, 
     UT_STEP_SCR_A_DELETE_CB, UT_STEP_SCR_B_DELETE_CB, UT_STEP_SCR_C_DELETE_CB, UT_STEP_SCR_D_DELETE_CB,
     UT_STEP_SCR_E_ENTRY_CB, UT_STEP_SCR_A_EXIT_CB,
     UT_STEP_SCR_A_DESTROY_CB, UT_STEP_SCR_B_DESTROY_CB, UT_STEP_SCR_C_DESTROY_CB, UT_STEP_SCR_D_DESTROY_CB, UT_STEP_END},
     /* UT_TYPE_HISTORY_SMALL_SCRN_REDRAW */
     {UT_STEP_SCR_C_ENTRY_CB, UT_STEP_SCR_B_ENTRY_CB, UT_STEP_SCR_C_EXIT_CB, UT_STEP_SCR_A_ENTRY_CB, UT_STEP_SCR_B_EXIT_CB,
      UT_STEP_SCR_A_DELETE_CB, UT_STEP_SCR_C_ENTRY_CB, UT_STEP_SCR_A_EXIT_CB, UT_STEP_SCR_B_ENTRY_CB, UT_STEP_SCR_C_EXIT_CB,
      UT_STEP_SCR_A_DESTROY_CB},
};

/*****************************************************************************
 * Local function 
 *****************************************************************************/
#ifndef __MTK_TARGET__
#define PRINT_TEST_CASE_HANDLER_INFO(handler, scrid)    \
        kal_print("[History]%s screen id: %s, currscrid:%d\n", handler, scrid, GetActiveScreenId());
#else
#define PRINT_TEST_CASE_HANDLER_INFO(handler, scrid)
#endif

/*****************************************************************************
 * Function for checking test steps
 *****************************************************************************/
static void mmi_frm_history_test_case_reset_step_database(void)
{
    mmi_frm_history_test_case_context.step_index = 0;
    memset(mmi_frm_history_test_case_context.history_test_case_step_info, 0, 
        sizeof(mmi_frm_history_test_case_context.history_test_case_step_info));
}

static mmi_frm_history_test_case_step_content mmi_frm_history_test_case_get_step_enum(U8 *step_content)
{
    U8 i;
    
    for (i = 1; i < UT_STEP_END; i++)
    {/* Start from 1 for UT_STEP_BEGIN */
        if (strcmp((const char *)step_content, (const char*)mmi_frm_history_test_case_step_content_str[i]) == 0)
        {
            return i;
        }
    }
    return UT_STEP_ERROR;
}

__inline static void mmi_frm_history_test_case_set_step_info(U8 *scrid, S8 *hdlr_type)
{
    char tmp_str[30] = "UT_STEP_";
    mmi_frm_history_test_case_step_content step;
    
    strcat(tmp_str, (const char *)scrid);
	strcat(tmp_str, "_");
    strcat(tmp_str, (const char *)hdlr_type);
    strcat(tmp_str, "_CB");
    step = mmi_frm_history_test_case_get_step_enum((U8 *)tmp_str);
    MMI_ASSERT(step != UT_STEP_ERROR);
    MMI_ASSERT(mmi_frm_history_test_case_context.step_index < HISTORY_TEST_CASE_STEP_NUM);
    mmi_frm_history_test_case_context.history_test_case_step_info[mmi_frm_history_test_case_context.step_index++] = step;
}

__inline static void mmi_frm_history_test_case_check_step_info(mmi_frm_history_test_case_type test_case_type)
{
    U8 i;

    for(i = 0; i < HISTORY_TEST_CASE_STEP_NUM; i++)
    {
        if (mmi_frm_history_test_case_step_database[test_case_type][i] == UT_STEP_END || 
            mmi_frm_history_test_case_context.history_test_case_step_info[i] == 0)
        {/* Get the end of table */
            break;
        }
        MMI_ASSERT(mmi_frm_history_test_case_context.history_test_case_step_info[i] ==
            mmi_frm_history_test_case_step_database[test_case_type][i]);
    }
    MMI_ASSERT(mmi_frm_history_test_case_step_database[test_case_type][i] == UT_STEP_END || 
               mmi_frm_history_test_case_context.history_test_case_step_info[i] == 0);
}

/*****************************************************************************
 * Function for operating argument structure and dynamic screen
 *****************************************************************************/
static history *mmi_frm_history_test_case_get_history_node(void)
{
    if (history_node_idx < HISTORY_TEST_CASE_SCR_NUM)
    {
        return &history_node_arr[history_node_idx++];
    }
    else 
    {
        MMI_ASSERT(0);
        return NULL;
    }
}

static void mmi_frm_history_test_case_flush_history_node_array(void)
{
    history_node_idx = 0;
    memset(history_node_arr, 0, sizeof(history) * HISTORY_TEST_CASE_SCR_NUM);
}

static U16 mmi_frm_history_test_case_generate_screen_id(U16 curr_scrid)
{
    return ++curr_scrid;
}

/*****************************************************************************
 * Function for common handlers, delete, exit, destroy, entry etc.
 *****************************************************************************/
static U8 mmi_frm_history_test_case_common_delete_hdlr(void *arg)
{
    arg = test_case_scrn_arg;
    PRINT_TEST_CASE_HANDLER_INFO("Delete", ((history *)arg)->inputBuffer);
    mmi_frm_history_test_case_set_step_info((U8 *)((history *)arg)->inputBuffer, "DELETE");

    if (0 != strlen((const char *)((history *)arg)->guiBuffer) && 
        0 == strcmp((const char *)((history *)arg)->guiBuffer, "delete_history"))
    {
        kal_print("[History]Deleteupto base screen\n");
        DeleteUptoScrID(test_case_base_scrid);
    }

    return MMI_FALSE;
}

static void mmi_frm_history_test_case_common_exit_hdlr(void *arg)
{
    PRINT_TEST_CASE_HANDLER_INFO("Exit", ((history *)arg)->inputBuffer);
    mmi_frm_history_test_case_set_step_info(((history *)arg)->inputBuffer, "EXIT");
}

static U8 mmi_frm_history_test_case_common_destroy_hdlr(void *arg)
{
    PRINT_TEST_CASE_HANDLER_INFO("Destory", ((history *)arg)->inputBuffer);
    mmi_frm_history_test_case_set_step_info(((history *)arg)->inputBuffer, "DESTROY");

    return MMI_FALSE;
}

static void mmi_frm_history_test_case_common_entry_hdlr(void *arg)
{
    U16 screen_id;

    screen_id = ((history *)arg)->scrnID;

    PRINT_TEST_CASE_HANDLER_INFO("Entry", ((history *)arg)->inputBuffer);
    mmi_frm_history_test_case_set_step_info(((history *)arg)->inputBuffer, "ENTRY");
    
    mmi_frm_entry_new_screen(screen_id, mmi_frm_history_test_case_common_exit_hdlr,
                             mmi_frm_history_test_case_common_entry_hdlr, NULL);

    SetDelScrnIDCallbackHandler(screen_id, mmi_frm_history_test_case_common_delete_hdlr);
    mmi_frm_set_destroy_scrn_callback(screen_id, mmi_frm_history_test_case_common_destroy_hdlr);

    if (0 != strlen((const char *)((history *)arg)->guiBuffer) && 
        0 == strcmp((const char *)((history *)arg)->guiBuffer, "goback_history") &&
        CheckIsBackHistory())
    {
    #ifndef __MTK_TARGET__
        kal_print("[History]Gobackhistory from %d\n", GetActiveScreenId());
    #endif
        GoBackHistory();
    }
}

static void mmi_frm_history_test_case_enter_new_screen(U16 screen_id, S8 *screen_name, S8 *action)
{
    history *screen_arg;

    screen_arg = mmi_frm_history_test_case_get_history_node();
    screen_arg->scrnID = screen_id;
    if (screen_name)
    {
        strncpy((char *)screen_arg->inputBuffer, (const char *)screen_name, strlen((const char *)screen_name) + 1);
    }
    if (action)
    {
        strncpy((char *)screen_arg->guiBuffer, (const char *)action, strlen((const char *)action) + 1);
    }
    mmi_frm_create_new_screen(mmi_frm_history_test_case_common_entry_hdlr, screen_arg);
}

/*****************************************************************************
 * Function for initialze test context
 *****************************************************************************/
static mmi_frm_history_test_case_init_context(void)
{
    mmi_frm_history_test_case_flush_history_node_array();
    mmi_frm_history_test_case_reset_step_database();
}

/*****************************************************************************  
 * External function for test cases
 *****************************************************************************/

/*****************************************************************************
 * FUNCTION
 *  mmi_frm_history_test_case_goback_reentry
 * DESCRIPTION
 *  goback -> goback: gobackhistory in entry function in gobacking flow
 *  Top screen is A, from top in history stack: B, C, D(original top screen - E).
 *  Action is go back from A to B, B goback to C, C goback to D.
 *  Final active screen should be original top screen (E).
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_TRUE if success
 *  MMI_FALSE if fail
 *****************************************************************************/
MMI_BOOL mmi_frm_history_test_case_goback_reentry(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 scrid_A, scrid_B, scrid_C, scrid_D;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_frm_history_test_case_init_context();

    /* Generate dynamic screen id */
    test_case_base_scrid = GetActiveScreenId();
    scrid_D = mmi_frm_history_test_case_generate_screen_id(test_case_base_scrid);
    scrid_C = mmi_frm_history_test_case_generate_screen_id(scrid_D);
    scrid_B = mmi_frm_history_test_case_generate_screen_id(scrid_C);
    scrid_A = mmi_frm_history_test_case_generate_screen_id(scrid_B);

    PRINT_TEST_CASE_HANDLER_INFO("Current", "SCR_CURR");

    /* Generate all screens for test case and input operating info for each screen */
    mmi_frm_history_test_case_enter_new_screen(scrid_D, "SCR_D", NULL);
    mmi_frm_history_test_case_enter_new_screen(scrid_C, "SCR_C", "goback_history");
    mmi_frm_history_test_case_enter_new_screen(scrid_B, "SCR_B", "goback_history");
    mmi_frm_history_test_case_enter_new_screen(scrid_A, "SCR_A", NULL);

    /* Trigger test case */
#ifndef __MTK_TARGET__
    kal_print("[History]Gobackhistory from %d\n", GetActiveScreenId());
#endif
    GoBackHistory();

    /* Check test result */
    MMI_ASSERT(GetActiveScreenId() == scrid_D);
    mmi_frm_history_test_case_check_step_info(UT_TYPE_HISTORY_GOBACK_REENTRY);

    /* Go back to test_case_base_scrid */
    GoBackHistory();
    return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_frm_history_test_case_delete_reentry
 * DESCRIPTION
 *  delete -> delete: delete hisory in delete call back handler
 *  Top screen is A, from top in history stack: B, C, D, original top screen(E).
 *  Action is go back from A, delete cb of A delete history up to original top screen.
 *  Final active screen should be original top screen (E).
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_TRUE if success
 *  MMI_FALSE if fail
 *****************************************************************************/
MMI_BOOL mmi_frm_history_test_case_delete_reentry(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 curr_scrid, scrid_A, scrid_B, scrid_C, scrid_D, scrid_E;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_frm_history_test_case_init_context();

    /* Generate dynamic screen id */
    curr_scrid = GetActiveScreenId();
    scrid_E = mmi_frm_history_test_case_generate_screen_id(curr_scrid);
    test_case_base_scrid = scrid_E;
    scrid_D = mmi_frm_history_test_case_generate_screen_id(scrid_E);
    scrid_C = mmi_frm_history_test_case_generate_screen_id(scrid_D);
    scrid_B = mmi_frm_history_test_case_generate_screen_id(scrid_C);
    scrid_A = mmi_frm_history_test_case_generate_screen_id(scrid_B);

    /* Generate all screens for test case and input operating info for each screen */
    PRINT_TEST_CASE_HANDLER_INFO("Current", "curr_scr");
    mmi_frm_history_test_case_enter_new_screen(scrid_E, "SCR_E", NULL);
    mmi_frm_history_test_case_enter_new_screen(scrid_D, "SCR_D", NULL);
    mmi_frm_history_test_case_enter_new_screen(scrid_C, "SCR_C", NULL);
    mmi_frm_history_test_case_enter_new_screen(scrid_B, "SCR_B", NULL);
    mmi_frm_history_test_case_enter_new_screen(scrid_A, "SCR_A", "delete_history");

    /* Trigger test case */
#ifndef __MTK_TARGET__
    kal_print("[History]Gobackhistory from %d\n", GetActiveScreenId());
#endif
    GoBackHistory();

    /* Check test result */
    MMI_ASSERT(GetActiveScreenId() == scrid_E);
    mmi_frm_history_test_case_check_step_info(UT_TYPE_HISTORY_DELETE_REENTRY);

    /* Go back to curr_scrid */
    GoBackHistory();
    return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_frm_history_test_case_gobacktohisory
 * DESCRIPTION
 *  delete -> delete: delete hisory in delete call back handler
 *  Top screen is A, from top in history stack: B, C, D, original top screen(E).
 *  Action is go back from A to original top screen(E).
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_TRUE if success
 *  MMI_FALSE if fail
 *****************************************************************************/
MMI_BOOL mmi_frm_history_test_case_gobacktohisory(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 curr_scrid, scrid_A, scrid_B, scrid_C, scrid_D, scrid_E;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_frm_history_test_case_init_context();

    /* Generate dynamic screen id */
    test_case_base_scrid = GetActiveScreenId();
    curr_scrid = GetActiveScreenId();
    scrid_E = mmi_frm_history_test_case_generate_screen_id(curr_scrid);
    scrid_D = mmi_frm_history_test_case_generate_screen_id(scrid_E);
    scrid_C = mmi_frm_history_test_case_generate_screen_id(scrid_D);
    scrid_B = mmi_frm_history_test_case_generate_screen_id(scrid_C);
    scrid_A = mmi_frm_history_test_case_generate_screen_id(scrid_B);

    /* Generate all screens for test case and input operating info for each screen */
    PRINT_TEST_CASE_HANDLER_INFO("Current", "curr_scr");
    mmi_frm_history_test_case_enter_new_screen(scrid_E, "SCR_E", NULL);
    mmi_frm_history_test_case_enter_new_screen(scrid_D, "SCR_D", NULL);
    mmi_frm_history_test_case_enter_new_screen(scrid_C, "SCR_C", NULL);
    mmi_frm_history_test_case_enter_new_screen(scrid_B, "SCR_B", NULL);
    mmi_frm_history_test_case_enter_new_screen(scrid_A, "SCR_A", NULL);

    /* Trigger test case */
#ifndef __MTK_TARGET__
    kal_print("[History]Gobackhistory from %d to %d\n", GetActiveScreenId(), curr_scrid);
#endif
    GoBackToHistory(scrid_E);

    /* Check test result */
    MMI_ASSERT(GetActiveScreenId() == scrid_E);
    mmi_frm_history_test_case_check_step_info(UT_TYPE_HISTORY_GOBACK_TO_HISTORY);

    /* Go back to curr_scrid */
    GoBackHistory();
    return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_frm_history_test_case_small_scrn
 * DESCRIPTION
 *  From top: scrn A(F), scrn B(small), scrn C(F), .
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_TRUE if success
 *  MMI_FALSE if fail
 *****************************************************************************/
MMI_BOOL mmi_frm_history_test_case_small_scrn(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 curr_scrid, scrid_A, scrid_B, scrid_C;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_frm_history_test_case_init_context();

    /* Generate dynamic screen id */
    test_case_base_scrid = GetActiveScreenId();
    curr_scrid = GetActiveScreenId();
    scrid_C = mmi_frm_history_test_case_generate_screen_id(curr_scrid);
    scrid_B = mmi_frm_history_test_case_generate_screen_id(scrid_C);
    scrid_A = mmi_frm_history_test_case_generate_screen_id(scrid_B);

    /* Generate all screens for test case and input operating info for each screen */
    PRINT_TEST_CASE_HANDLER_INFO("Current", "curr_scr");
    mmi_frm_history_test_case_enter_new_screen(scrid_C, "SCR_C", NULL);
    mmi_frm_history_test_case_enter_new_screen(scrid_B, "SCR_B", NULL);
    set_small_screen();
    mmi_frm_history_test_case_enter_new_screen(scrid_A, "SCR_A", NULL);

    /* Trigger test case */
#ifndef __MTK_TARGET__
    kal_print("[History]Gobackhistory from %d to %d\n", GetActiveScreenId(), curr_scrid);
#endif
    GoBackHistory();

    /* Check test result */
    MMI_ASSERT(GetActiveScreenId() == scrid_B);
    mmi_frm_history_test_case_check_step_info(UT_TYPE_HISTORY_SMALL_SCRN_REDRAW);
    
    GoBackHistory();
    MMI_ASSERT(GetActiveScreenId() == scrid_C);
    /* Go back to curr_scrid */
    GoBackHistory();
    return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_frm_history_ut_replace_history_node
 * DESCRIPTION
 *  Test init history node and replace history node api.
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_TRUE if success
 *  MMI_FALSE if fail
 *****************************************************************************/
static __inline void mmi_frm_history_ut_replace_screen(U16 out_scrid, U16 in_scrid, void *arg)
{
    mmi_frm_screen_struct screen;

    mmi_frm_init_screen_struct(&screen);
    screen.app_arg = arg;
    screen.scrnID = in_scrid;
    screen.entryFuncPtr = mmi_frm_history_test_case_common_entry_hdlr;
    screen.isSmallScreen = 1;

//    MMI_ASSERT(mmi_frm_replace_screen(out_scrid, &screen));
}

MMI_BOOL mmi_frm_history_ut_replace_screen_struct(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 curr_scrid, scrid_A, scrid_B;
    static history arg = {0};
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Construct test environment */
    mmi_frm_history_test_case_init_context();
    curr_scrid = GetActiveScreenId();
    scrid_A = mmi_frm_history_test_case_generate_screen_id(curr_scrid);
    scrid_B = mmi_frm_history_test_case_generate_screen_id(scrid_A);
    
    mmi_frm_history_test_case_enter_new_screen(scrid_A, "SCR_A", NULL);
    MMI_ASSERT(GetActiveScreenId() == scrid_A);
    mmi_frm_entry_new_screen(0, NULL, NULL, NULL);
    MMI_ASSERT(IsScreenPresent(scrid_A));

    arg.scrnID = scrid_B;
    strcpy((char *)arg.inputBuffer, "SCR_B");

    mmi_frm_history_ut_replace_screen(scrid_A, scrid_B, &arg);

//    MMI_ASSERT(IsScreenPresent(scrid_B));
    GoBackHistory();
//    MMI_ASSERT(GetActiveScreenId() == scrid_B);

	ExecuteRootMainHistoryScreen(NULL);
    return MMI_TRUE;
}


static void mmi_frm_history_ut_entry_dummy(void *arg)
{
    mmi_frm_entry_new_screen(GLOBAL_SCR_DUMMY, NULL, mmi_frm_history_ut_entry_dummy, NULL);
}


MMI_BOOL mmi_frm_history_ut_insert_screen_struct(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 curr_scrid, scrid_A, scrid_B, scrid_C;
    mmi_frm_screen_struct insert_scrn;
    const char *input_str = "Input buffer";
    const char *gui_str = "Gui buffer";
    static history arg = {0};

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Construct test environment */
    mmi_frm_history_test_case_init_context();
    curr_scrid = GetActiveScreenId();
    scrid_A = mmi_frm_history_test_case_generate_screen_id(curr_scrid);
    scrid_B = mmi_frm_history_test_case_generate_screen_id(scrid_A);
    scrid_C = mmi_frm_history_test_case_generate_screen_id(scrid_B);

    mmi_frm_history_test_case_enter_new_screen(scrid_A, "SCR_A", NULL);
    MMI_ASSERT(GetActiveScreenId() == scrid_A);
    /* Put screen A into history */
    mmi_frm_entry_new_screen(GLOBAL_SCR_DUMMY, NULL, mmi_frm_history_ut_entry_dummy, NULL);
    mmi_frm_entry_new_screen(GLOBAL_SCR_DUMMY, NULL, mmi_frm_history_ut_entry_dummy, NULL);
    /*****************************************
     *      |---------------|   Top
     *      |    DUMMY      |
     *      |---------------|
     *      |    SCR_B      |   History stack
     *      |---------------|
     *      |    SCR_A      |
     *      |---------------|   Bottom
     *****************************************/
    mmi_frm_init_screen_struct(&insert_scrn);
    insert_scrn.scrnID = scrid_B;
    insert_scrn.inputBuffer = (U8 *)input_str;
	arg.scrnID = scrid_B;
    strcpy((char *)arg.inputBuffer, "SCR_B");
	insert_scrn.app_arg = &arg;
    insert_scrn.entryFuncPtr = mmi_frm_history_test_case_common_entry_hdlr;
    mmi_frm_insert_screen(scrid_A, &insert_scrn, MMI_FRM_INSERT_AFTER_SCRN);
    MMI_ASSERT(IsScreenPresent(scrid_B));
    GoBackHistory();
    MMI_ASSERT(GetActiveScreenId() == GLOBAL_SCR_DUMMY);
    MMI_ASSERT(strcmp((char *)GetCurrInputBuffer(scrid_B), input_str) == 0);
    GoBackHistory();
    MMI_ASSERT(GetActiveScreenId() == scrid_B);
    GoBackHistory();
    MMI_ASSERT(GetActiveScreenId() == scrid_A);

    /*****************************************
     *      |---------------|   Top
     *      |    DUMMY      |
     *      |---------------|
     *      |    SCR_A      |   History stack
     *      |---------------|
     *      |    SCR_C      |
     *      |---------------|   Bottom
     *****************************************/
    /* Put screen A into history */
    mmi_frm_entry_new_screen(GLOBAL_SCR_DUMMY, NULL, mmi_frm_history_ut_entry_dummy, NULL);
    mmi_frm_entry_new_screen(GLOBAL_SCR_DUMMY, NULL, mmi_frm_history_ut_entry_dummy, NULL);
    mmi_frm_init_screen_struct(&insert_scrn);
    insert_scrn.scrnID = scrid_C;
    insert_scrn.guiBuffer = (U8 *)gui_str;
	arg.scrnID = scrid_C;
    strcpy((char *)arg.inputBuffer, "SCR_C");
	insert_scrn.app_arg = &arg;
    insert_scrn.entryFuncPtr = mmi_frm_history_test_case_common_entry_hdlr;
    mmi_frm_insert_screen(scrid_A, &insert_scrn, MMI_FRM_INSERT_BEFORE_SCRN);
    MMI_ASSERT(IsScreenPresent(scrid_C));
    GoBackHistory();
    MMI_ASSERT(GetActiveScreenId() == GLOBAL_SCR_DUMMY);
    GoBackHistory();
    MMI_ASSERT(GetActiveScreenId() == scrid_A);
    MMI_ASSERT(IsScreenPresent(scrid_C));
    MMI_ASSERT(strcmp((char *)GetCurrGuiBuffer(scrid_C), gui_str) == 0);
    GoBackHistory();
    MMI_ASSERT(GetActiveScreenId() == scrid_C);

	ExecuteRootMainHistoryScreen(NULL);
	return MMI_TRUE;
}

/*****************************************************************************/
typedef enum
{
    ACTION_BASE_ENUM,
        
    ACTION_WAIT_TO_ENTRY_SYNC_ENUM,
    ACTION_WAIT_TO_ENTRY_ASYNC_ENUM,

    ACTION_ENTRY_CANOT_WORKING_ENUM,
    
    ACTION_INVOKE_GOBACK_IN_ENTRY,
    ACTION_INVOKE_DELETE_IN_DELETE_CALLBACK,
    
}screen_action_enum;
typedef struct
{
    U8 desp[16];
    screen_action_enum action;
    U32 screen_id;
}screen_arg_struct;
MMI_BOOL b_data_ready = MMI_TRUE;
MMI_BOOL b_back = MMI_FALSE;
void mmi_frm_history_test_case_entry_screen(void *arg);

static screen_arg_struct* mmi_frm_history_test_case_alloc_screen_arg()
{
    static screen_arg_struct screen_arg_arr[10];
    static U8 index = 0;
    if(index < 10)
        return &screen_arg_arr[index++];
    return NULL;
}

static U8 *mmi_frm_history_test_case_get_gui_buff(U8 *history_buffer)
{
    if (history_buffer != NULL)
    {
        *history_buffer = 0x11;
    }
    return history_buffer;
}
static void mmi_frm_history_test_case_timer(void* arg)
{
    b_data_ready = MMI_TRUE;            
    mmi_frm_history_test_case_entry_screen(arg);
//    mmi_frm_free_history_buffer(((screen_arg_struct*)arg)->screen_id);
}

U8 mmi_frm_history_test_case_delete_screen(void *arg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    screen_arg_struct* screen_arg_p = (screen_arg_struct*)test_case_scrn_arg;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (screen_arg_p == NULL)
        return MMI_HIST_STOP_DELETING;

#ifndef __MTK_TARGET__
    kal_print("[History] [delete] screen desp = [%s],screen id = [0x%x]\n", \
        screen_arg_p->desp, screen_arg_p->screen_id);
#endif

    if (screen_arg_p->action== ACTION_INVOKE_DELETE_IN_DELETE_CALLBACK)
    {
        mmi_delete_scrn_if_present(0xCCC1);
    }
    return MMI_HIST_ALLOW_DELETING;
}

U8 mmi_frm_history_test_case_destroy_screen(void *arg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    screen_arg_struct* screen_arg_p = (screen_arg_struct*)arg;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (screen_arg_p == NULL)
        return 0;
    
#ifndef __MTK_TARGET__    
    kal_print("[History] [destroy] screen desp = [%s],screen id = [0x%x]\n", \
        screen_arg_p->desp, screen_arg_p->screen_id);
#endif

    return 1;

}

void mmi_frm_history_test_case_exit_screen(void *arg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    screen_arg_struct* screen_arg_p = (screen_arg_struct*)arg;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (screen_arg_p == NULL)
        return;

#ifndef __MTK_TARGET__
    kal_print("[History] [exit] screen desp = [%s],screen id = [0x%x]\n", \
        screen_arg_p->desp, screen_arg_p->screen_id);
#endif

}
void mmi_frm_history_test_case_entry_screen(void *arg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    screen_arg_struct* screen_arg_p = (screen_arg_struct*)arg;
    U8* gui_buff_p;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(screen_arg_p); /* check */
    
    /* when the data is not ready,wait to */
    if (!b_data_ready)
    {
        screen_arg_struct* screen_wait_to_p = mmi_frm_history_test_case_alloc_screen_arg();
        screen_wait_to_p->action = ACTION_BASE_ENUM;
        screen_wait_to_p->screen_id = 0xFFF1;
        strcpy(screen_wait_to_p->desp,"WAIT_TO");

#ifndef __MTK_TARGET__
        kal_print("[History] [entry] screen desp = [%s],screen id = [0x%x]\n", \
            screen_wait_to_p->desp, screen_wait_to_p->screen_id);
#endif
                
        /* mmi_frm_create_new_screen(mmi_frm_history_test_case_entry_screen,screen_wait_to_p); */
        mmi_frm_set_active_scrn_arg(screen_wait_to_p);
        mmi_frm_entry_new_screen(screen_wait_to_p->screen_id, mmi_frm_history_test_case_exit_screen,
                             NULL, NULL);
        
        SetDelScrnIDCallbackHandler(screen_wait_to_p->screen_id, 
            mmi_frm_history_test_case_delete_screen);
        mmi_frm_set_destroy_scrn_callback(screen_wait_to_p->screen_id, 
            mmi_frm_history_test_case_destroy_screen);
        gui_buff_p = GetCurrGuiBuffer(screen_wait_to_p->screen_id);
        
        /* sync entry */
        if (screen_arg_p->action == ACTION_WAIT_TO_ENTRY_SYNC_ENUM)
        {
            /* prepare the data, wait to... */
            b_data_ready = MMI_TRUE;
            
            mmi_frm_history_test_case_entry_screen(arg);
        }
        /* async entry */
        else if (screen_arg_p->action == ACTION_WAIT_TO_ENTRY_ASYNC_ENUM)
        {
            /* async prepare the data */
            //StartTimerEx(MAX_TIMERS-1, 1000, mmi_frm_history_test_case_timer,arg);
            //if (CheckIsBackHistory())
            //{
              //  mmi_frm_hold_history_buffer(screen_arg_p->screen_id);
            //}                
        }        
        return;
    }
    
#ifndef __MTK_TARGET__    
    kal_print("[History] [entry] screen desp = [%s],screen id = [0x%x]\n", \
        screen_arg_p->desp, screen_arg_p->screen_id);
#endif

    /* entry function can not working because unexpectable reason */
	if (screen_arg_p->action == ACTION_ENTRY_CANOT_WORKING_ENUM && CheckIsBackHistory())
    {
        return;
    }

    mmi_frm_set_active_scrn_arg(screen_arg_p);
    mmi_frm_entry_new_screen(screen_arg_p->screen_id, mmi_frm_history_test_case_exit_screen,
                         mmi_frm_history_test_case_entry_screen, NULL);
    
    SetDelScrnIDCallbackHandler(screen_arg_p->screen_id, 
        mmi_frm_history_test_case_delete_screen);
    mmi_frm_set_destroy_scrn_callback(screen_arg_p->screen_id, 
        mmi_frm_history_test_case_destroy_screen);
    gui_buff_p = GetCurrGuiBuffer(screen_arg_p->screen_id);
    /* check the gui data is correct */
    if (screen_arg_p->action == ACTION_WAIT_TO_ENTRY_SYNC_ENUM || screen_arg_p->action == ACTION_WAIT_TO_ENTRY_ASYNC_ENUM)
    {
        GetCategoryHistory = mmi_frm_history_test_case_get_gui_buff;
        if (b_back)
        {
            U8 gui_buff;
            mmi_frm_history_test_case_get_gui_buff(&gui_buff);
            
            MMI_ASSERT(*gui_buff_p == gui_buff);
        }
    }
    
    /* invoke goback history in entry function */
	if (screen_arg_p->action == ACTION_INVOKE_GOBACK_IN_ENTRY && CheckIsBackHistory())
    {
        GoBackHistory();
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmI_frm_history_test_case_wait_to_entry_sync
 * DESCRIPTION
 *  Test sync entry screen.
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_TRUE if success
 *  MMI_FALSE if fail
 *****************************************************************************/
MMI_BOOL mmi_frm_history_test_case_wait_to_entry_sync(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    screen_arg_struct* screen_arg_p = NULL;
    screen_arg_struct* screen_arg_arr_p[3];
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    b_back = MMI_FALSE;
    screen_arg_p = mmi_frm_history_test_case_alloc_screen_arg();
    if (screen_arg_p == NULL)
        return MMI_FALSE;
    strcpy( screen_arg_p->desp, "SCR_A");
    screen_arg_p->action = ACTION_BASE_ENUM;
    screen_arg_p->screen_id = 0xAAA1;
    screen_arg_arr_p[0] = screen_arg_p;

    
    screen_arg_p = mmi_frm_history_test_case_alloc_screen_arg();
    if (screen_arg_p == NULL)
        return MMI_FALSE;
    strcpy( screen_arg_p->desp, "SCR_B");
    screen_arg_p->action = ACTION_WAIT_TO_ENTRY_SYNC_ENUM;
    screen_arg_p->screen_id = 0xBBB1;
    screen_arg_arr_p[1] = screen_arg_p;    


    screen_arg_p = mmi_frm_history_test_case_alloc_screen_arg();
    if (screen_arg_p == NULL)
        return MMI_FALSE;
    strcpy( screen_arg_p->desp, "SCR_C");
    screen_arg_p->action = ACTION_BASE_ENUM;
    screen_arg_p->screen_id = 0xCCC1;
    screen_arg_arr_p[2] = screen_arg_p;


    /*****************************************
     *      |---------------|   Top
     *      |    SCR_C      |
     *      |---------------|
     *      |    SCR_B      |   History stack
     *      |---------------|
     *      |    SCR_A      |
     *      |---------------|   Bottom
     *****************************************/
    b_data_ready = MMI_TRUE;
    mmi_frm_create_new_screen(mmi_frm_history_test_case_entry_screen,screen_arg_arr_p[0]);
    b_data_ready = MMI_FALSE;
    mmi_frm_create_new_screen(mmi_frm_history_test_case_entry_screen,screen_arg_arr_p[1]);
    b_data_ready = MMI_TRUE;
    mmi_frm_create_new_screen(mmi_frm_history_test_case_entry_screen,screen_arg_arr_p[2]);

    b_data_ready = MMI_FALSE;
    b_back = MMI_TRUE;
    GoBackHistory();
    GoBackHistory();
    GoBackHistory();
	return MMI_TRUE;
}

/*****************************************************************************
 * FUNCTION
 *  mmI_frm_history_test_case_wait_to_entry_async
 * DESCRIPTION
 *  Test async entry screen.
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_TRUE if success
 *  MMI_FALSE if fail
 *****************************************************************************/
MMI_BOOL mmi_frm_history_test_case_wait_to_entry_async(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    static U8 first_in = 1;
    screen_arg_struct* screen_arg_p = NULL;
    screen_arg_struct* screen_arg_arr_p[3];
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    b_back = MMI_FALSE;
    if (first_in)
    {
        screen_arg_p = mmi_frm_history_test_case_alloc_screen_arg();
        if (screen_arg_p == NULL)
            return MMI_FALSE;
        strcpy( screen_arg_p->desp, "SCR_A");
        screen_arg_p->action = ACTION_BASE_ENUM;
        screen_arg_p->screen_id = 0xAAA1;
        screen_arg_arr_p[0] = screen_arg_p;
        
        screen_arg_p = mmi_frm_history_test_case_alloc_screen_arg();
        if (screen_arg_p == NULL)
            return MMI_FALSE;
        strcpy( screen_arg_p->desp, "SCR_B");
        screen_arg_p->action = ACTION_WAIT_TO_ENTRY_ASYNC_ENUM;
        screen_arg_p->screen_id = 0xBBB1;
        screen_arg_arr_p[1] = screen_arg_p;   

        /*****************************************
         *      |---------------|   Top
         *      |    SCR_C      |
         *      |---------------|
         *      |    SCR_B      |   History stack
         *      |---------------|
         *      |    SCR_A      |
         *      |---------------|   Bottom
         *****************************************/
        b_data_ready = MMI_TRUE;
        mmi_frm_create_new_screen(mmi_frm_history_test_case_entry_screen,screen_arg_arr_p[0]);
        b_data_ready = MMI_FALSE;
        mmi_frm_create_new_screen(mmi_frm_history_test_case_entry_screen,screen_arg_arr_p[1]);
        first_in = 0;
    }
    else
    {
        screen_arg_p = mmi_frm_history_test_case_alloc_screen_arg();
        if (screen_arg_p == NULL)
            return MMI_FALSE;
        strcpy( screen_arg_p->desp, "SCR_C");
        screen_arg_p->action = ACTION_BASE_ENUM;
        screen_arg_p->screen_id = 0xCCC1;
        screen_arg_arr_p[2] = screen_arg_p;

        b_data_ready = MMI_TRUE;
        mmi_frm_create_new_screen(mmi_frm_history_test_case_entry_screen,screen_arg_arr_p[2]);

        b_data_ready = MMI_FALSE;
        b_back = MMI_TRUE;
        GoBackHistory();
        //GoBackHistory();
        //GoBackHistory();
    }

	return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_frm_history_test_case_entry_screen_canot_working_goback_procedure
 * DESCRIPTION
 *  The goback to screen's entry function canot working because unexpectable reason in goback procedure
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_TRUE if success
 *  MMI_FALSE if fail
 *****************************************************************************/
MMI_BOOL mmi_frm_history_test_case_entry_screen_canot_working_goback_procedure(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 index = 0;
    screen_arg_struct* screen_arg_p = NULL;
    screen_arg_struct* screen_arg_arr_p[4];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    screen_arg_p = mmi_frm_history_test_case_alloc_screen_arg();
    if (screen_arg_p == NULL)
        return MMI_FALSE;
    strcpy( screen_arg_p->desp, "SCR_A");
    screen_arg_p->action = ACTION_BASE_ENUM;
    screen_arg_p->screen_id = 0xAAA1;
    screen_arg_arr_p[index++] = screen_arg_p;
    
    screen_arg_p = mmi_frm_history_test_case_alloc_screen_arg();
    if (screen_arg_p == NULL)
        return MMI_FALSE;
    strcpy( screen_arg_p->desp, "SCR_B");
    screen_arg_p->action = ACTION_ENTRY_CANOT_WORKING_ENUM;
    screen_arg_p->screen_id = 0xBBB1;
    screen_arg_arr_p[index++] = screen_arg_p;

    screen_arg_p = mmi_frm_history_test_case_alloc_screen_arg();
    if (screen_arg_p == NULL)
        return MMI_FALSE;
    strcpy( screen_arg_p->desp, "SCR_C");
    screen_arg_p->action = ACTION_BASE_ENUM;
    screen_arg_p->screen_id = 0xCCC1;
    screen_arg_arr_p[index++] = screen_arg_p;

    /*****************************************
     *      |---------------|   Top
     *      |    SCR_C      |
     *      |---------------|
     *      |    SCR_B      |   History stack
     *      |---------------|
     *      |    SCR_A      |
     *      |---------------|   Bottom
     *****************************************/   
    b_data_ready = MMI_TRUE;
    mmi_frm_create_new_screen(mmi_frm_history_test_case_entry_screen,screen_arg_arr_p[0]);
    mmi_frm_create_new_screen(mmi_frm_history_test_case_entry_screen,screen_arg_arr_p[1]);
    mmi_frm_create_new_screen(mmi_frm_history_test_case_entry_screen,screen_arg_arr_p[2]);

    GoBackHistory();
    GoBackHistory();
    GoBackHistory();
}

/*****************************************************************************
 * FUNCTION
 *  mmi_frm_history_test_case_invoke_goback_in_entry
 * DESCRIPTION
 *  Test and check if invoke GoBackHistory in entry function
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_TRUE if success
 *  MMI_FALSE if fail
 *****************************************************************************/
MMI_BOOL mmi_frm_history_test_case_invoke_goback_in_entry(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 index = 0;
    screen_arg_struct* screen_arg_p = NULL;
    screen_arg_struct* screen_arg_arr_p[4];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    screen_arg_p = mmi_frm_history_test_case_alloc_screen_arg();
    if (screen_arg_p == NULL)
        return MMI_FALSE;
    strcpy( screen_arg_p->desp, "SCR_A");
    screen_arg_p->action = ACTION_BASE_ENUM;
    screen_arg_p->screen_id = 0xAAA1;
    screen_arg_arr_p[index++] = screen_arg_p;
    
    screen_arg_p = mmi_frm_history_test_case_alloc_screen_arg();
    if (screen_arg_p == NULL)
        return MMI_FALSE;
    strcpy( screen_arg_p->desp, "SCR_B");
    screen_arg_p->action = ACTION_BASE_ENUM;
    screen_arg_p->screen_id = 0xBBB1;
    screen_arg_arr_p[index++] = screen_arg_p;

    screen_arg_p = mmi_frm_history_test_case_alloc_screen_arg();
    if (screen_arg_p == NULL)
        return MMI_FALSE;
    strcpy( screen_arg_p->desp, "SCR_C");
    screen_arg_p->action = ACTION_INVOKE_GOBACK_IN_ENTRY;
    screen_arg_p->screen_id = 0xCCC1;
    screen_arg_arr_p[index++] = screen_arg_p;
    
    screen_arg_p = mmi_frm_history_test_case_alloc_screen_arg();
    if (screen_arg_p == NULL)
        return MMI_FALSE;
    strcpy( screen_arg_p->desp, "SCR_D");
    screen_arg_p->action = ACTION_BASE_ENUM;
    screen_arg_p->screen_id = 0xDDD1;
    screen_arg_arr_p[index++] = screen_arg_p;

    /*****************************************
     *      |---------------|   Top
     *      |    SCR_D      |
     *      |---------------|   
     *      |    SCR_C      |
     *      |---------------|
     *      |    SCR_B      |   History stack
     *      |---------------|
     *      |    SCR_A      |
     *      |---------------|   Bottom
     *****************************************/
    b_data_ready = MMI_TRUE;
    mmi_frm_create_new_screen(mmi_frm_history_test_case_entry_screen,screen_arg_arr_p[0]);
    mmi_frm_create_new_screen(mmi_frm_history_test_case_entry_screen,screen_arg_arr_p[1]);
    mmi_frm_create_new_screen(mmi_frm_history_test_case_entry_screen,screen_arg_arr_p[2]);
    mmi_frm_create_new_screen(mmi_frm_history_test_case_entry_screen,screen_arg_arr_p[3]);

	GoBackHistory();
	GoBackHistory();
}

/*****************************************************************************
 * FUNCTION
 *  mmi_frm_history_test_case_invoke_goback_in_entry
 * DESCRIPTION
 *  Test and check if invoke GoBackHistory in entry function
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_TRUE if success
 *  MMI_FALSE if fail
 *****************************************************************************/
MMI_BOOL mmi_frm_history_test_case_invoke_delete_in_delete_callback(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 index = 0;
    screen_arg_struct* screen_arg_p = NULL;
    screen_arg_struct* screen_arg_arr_p[4];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    screen_arg_p = mmi_frm_history_test_case_alloc_screen_arg();
    if (screen_arg_p == NULL)
        return MMI_FALSE;
    strcpy( screen_arg_p->desp, "SCR_A");
    screen_arg_p->action = ACTION_BASE_ENUM;
    screen_arg_p->screen_id = 0xAAA1;
    screen_arg_arr_p[index++] = screen_arg_p;
    
    screen_arg_p = mmi_frm_history_test_case_alloc_screen_arg();
    if (screen_arg_p == NULL)
        return MMI_FALSE;
    strcpy( screen_arg_p->desp, "SCR_B");
    screen_arg_p->action = ACTION_BASE_ENUM;
    screen_arg_p->screen_id = 0xBBB1;
    screen_arg_arr_p[index++] = screen_arg_p;

    screen_arg_p = mmi_frm_history_test_case_alloc_screen_arg();
    if (screen_arg_p == NULL)
        return MMI_FALSE;
    strcpy( screen_arg_p->desp, "SCR_C");
    screen_arg_p->action = ACTION_BASE_ENUM;
    screen_arg_p->screen_id = 0xCCC1;
    screen_arg_arr_p[index++] = screen_arg_p;
    
    screen_arg_p = mmi_frm_history_test_case_alloc_screen_arg();
    if (screen_arg_p == NULL)
        return MMI_FALSE;
    strcpy( screen_arg_p->desp, "SCR_D");
    screen_arg_p->action = ACTION_INVOKE_DELETE_IN_DELETE_CALLBACK;
    screen_arg_p->screen_id = 0xDDD1;
    screen_arg_arr_p[index++] = screen_arg_p;

    /*****************************************
     *      |---------------|   Top
     *      |    SCR_D      |
     *      |---------------|   
     *      |    SCR_C      |
     *      |---------------|
     *      |    SCR_B      |   History stack
     *      |---------------|
     *      |    SCR_A      |
     *      |---------------|   Bottom
     *****************************************/
    b_data_ready = MMI_TRUE;
    mmi_frm_create_new_screen(mmi_frm_history_test_case_entry_screen,screen_arg_arr_p[0]);
    mmi_frm_create_new_screen(mmi_frm_history_test_case_entry_screen,screen_arg_arr_p[1]);
    mmi_frm_create_new_screen(mmi_frm_history_test_case_entry_screen,screen_arg_arr_p[2]);
    mmi_frm_create_new_screen(mmi_frm_history_test_case_entry_screen,screen_arg_arr_p[3]);

    GoBackHistory();
	GoBackHistory();
}


/*****************************************************************************  
 * Function for test case driven engine
 *****************************************************************************/
typedef MMI_BOOL (*history_test_case_fp)(void);
typedef struct
{
    S8 index;
    history_test_case_fp test_case_func;
} _history_test_case_struct;

static const _history_test_case_struct history_test_case_db[] =
{
    /* Test all cases */
    {0, NULL},
    {1, mmi_frm_history_test_case_goback_reentry},
    {2, mmi_frm_history_test_case_delete_reentry},
    {3, mmi_frm_history_test_case_gobacktohisory},
    {4, mmi_frm_history_ut_replace_screen_struct},
    {5, mmi_frm_history_ut_insert_screen_struct},
    {6, mmi_frm_history_test_case_small_scrn},
    
    {7, mmi_frm_history_test_case_wait_to_entry_sync},
    //{8, mmi_frm_history_test_case_wait_to_entry_async},
    {8, mmi_frm_history_test_case_entry_screen_canot_working_goback_procedure},
    {9,mmi_frm_history_test_case_invoke_goback_in_entry},
    {10,mmi_frm_history_test_case_invoke_delete_in_delete_callback},
    
    
    {-1, NULL}
};
/*****************************************************************************
 * FUNCTION
 *  mmi_frm_history_test_case_entry
 * DESCRIPTION
 * History test case entry function, could be invoked by catcher inject string
 * in mmi_proc_inject_string (events.c).
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_frm_history_test_case_entry(U8 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (0 == index)
    {
        /* Test all cases */
        U8 i = 1;
        while (history_test_case_db[i].index > 0 && history_test_case_db[i].test_case_func)
        {
            history_test_case_db[i].test_case_func();
            i++;
        }
    }
    else
    {
        history_test_case_db[index].test_case_func();
    }

    HistoryDump();
}
#endif /* ENHANCE_HISTORY_UNIT_TEST */


