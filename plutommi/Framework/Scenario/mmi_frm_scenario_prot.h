/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*******************************************************************************
 * Filename:
 * ---------
 *  mmi_frm_scenario_prot.h
 *
 * Project:
 * --------
 *  MAUI
 *
 * Description:
 * ------------
 *  
 *
 * Author:
 * -------
 * -------
 *
 *==============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!! 
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!! 
 *==============================================================================
 *******************************************************************************/

#ifndef MMI_FRM_SCENARIO_PROT_H
#define MMI_FRM_SCENARIO_PROT_H

//RHR Add
#include "GlobalResDef.h"
#include "MMIDataType.h"
#include "kal_general_types.h"
#include "mmi_frm_mem_gprot.h"
#include "mmi_frm_scenario_gprot.h"
#include "mmi_frm_events_gprot.h"
#include "mmi_frm_history_gprot.h"

/***************************************************************************** 
*  Define
*****************************************************************************/
#define _NODE(n)                        ((base_node_struct*)(n))
#define _GROUP(n)                       ((group_node_struct*)(n))
#define _SCRN(n)                        ((scrn_node_struct*)(n))
#define _TAB(n)                         ((tab_node_struct*)(n))
#define _TAB_PAGE(n)                    ((tab_page_node_struct*)(n))
#define _IS_GROUP(n)                    (n && _NODE(n)->type == SCENARIO_GROUP_NODE)
#define _IS_SCRN(n)                     (n && _NODE(n)->type == SCENARIO_SCRN_NODE)
#define _IS_TAB(n)                      (n && _NODE(n)->type == SCENARIO_TAB_NODE)
#define _IS_TAB_PAGE(n)                 (n && _NODE(n)->type == SCENARIO_TAB_PAGE_NODE)

#define _SCRN_ID(g, s)                  (((U32)(g))<<16|(U32)(s))
#define _PARENT_ID(p, s)                ((p) == GRP_ID_ROOT)?(s):(p)

/* base tree operations */
#define _GROUP_FIND_LATEST_DESC_SCREEN(node)        find_latest_descendant_scrn(GRP_ID_INVALID, _GROUP(node))

/* base sg operation */
#define SG_ADD_NODE(node_parent, node_new)      add_node_tree_op((node_parent), _NODE(node_new))
#define SG_REMOVE_NODE(node_parent, node_del)   remove_node_tree_op((node_parent), _NODE(node_del))
#define SG_GET_CHILD(node_parent, self_id)      get_child_tree_op((node_parent), self_id)
#define SG_GET_NODE(node_parent, self_id)       get_node_tree_op((node_parent), self_id)

#define SG_GET_NODE_FROM_ROOT(self_id)      get_node_sg_op(self_id, 0x01)
#define SG_GET_NODE_FROM_DANGLE(self_id)    get_node_sg_op(self_id, 0x02)
#define SG_GET_NODE_FROM_BG(self_id)        get_node_sg_op(self_id, 0x04)
#define SG_GET_NODE_FROM_ALL(self_id)       get_node_sg_op(self_id, 0x0F)

#define SG_FREE_NODE(node_free)                     free_node_sg_op(_NODE(node_free), MMI_TRUE)
#define SG_FREE_NODE_CHILDREN(node_free)            free_node_sg_op(_NODE(node_free), MMI_FALSE)
#define SG_REMOVE_FREE_NODE(node_parent, node_free) remove_free_node_sg_op((node_parent),_NODE(node_free))

#define DUMP_TREE_ROOT                      mmi_frm_dump_tree(0x01)
#define DUMP_TREE_DANGLE                    mmi_frm_dump_tree(0x02)
#define DUMP_TREE_BG                        mmi_frm_dump_tree(0x04)
#define DUMP_TREE_SRV                       mmi_frm_dump_tree(0x08)
#define DUMP_TREE_ALL                       mmi_frm_dump_tree(0x0F)


#define _EXECUTE_NODE_INIT(n, evt)                  execute_node_init(_NODE(n), (mmi_event_struct*)(evt))
#define _EXECUTE_NODE_ACTIVE(n, evt)                execute_node_active(_NODE(n), (mmi_event_struct*)(evt));
#define _EXECUTE_NODE_INACTIVE(n, evt)              execute_node_inactive(_NODE(n), (mmi_event_struct*)(evt));
#define _EXECUTE_NODE_CLOSE(n, evt)                 execute_node_close(_NODE(n), (mmi_event_struct*)(evt));
#define _EXECUTE_NODE_DEINIT(n, evt)                execute_node_deinit(_NODE(n), (mmi_event_struct*)(evt))
#define _EXECUTE_NODE_HIDE(n, evt)                  execute_node_hide(_NODE(n), (mmi_event_struct *)evt)
#define _EXECUTE_NODE_UNHIDE(n, evt)                execute_node_unhide(_NODE(n), (mmi_event_struct *)evt)

#define MMI_SCENARIO_STATE_ACTIVE_IDX               (0)
#define MMI_SCENARIO_STATE_INACTIVE_IDX             (1)
#define MMI_SCENARIO_STATE_CREATE_IDX               (2)
#define MMI_SCENARIO_STATE_FIRST_ENTRY_IDX          (3)
#define MMI_SCENARIO_STATE_FORWARD_IDX              (4)
#define MMI_SCENARIO_STATE_BACKWARD_IDX             (5)
#define MMI_SCENARIO_STATE_REDRAW_IDX               (6)
#define MMI_SCENARIO_STATE_CLOSE_IND_IDX            (7)
#define MMI_SCENARIO_STATE_DELETE_REQ_IDX           (8)
#define MMI_SCENARIO_STATE_EXIT_IDX                 (9)
#define MMI_SCENARIO_STATE_DEINIT_IDX               (10)
#define MMI_SCENARIO_STATE_HIDE_IDX                 (11)
#define MMI_SCENARIO_STATE_UNHIDE_IDX               (12)
#define MMI_SCENARIO_STATE_APP_DO_HIDE_IDX          (13)
#define MMI_SCENARIO_STATE_APP_DO_UNHIDE_IDX        (14)
#define MMI_SCENARIO_STATE_FOCUS_IDX                (15)
#define MMI_SCENARIO_STATE_BACK_TO_IDLE_IDX         (16)
#define MMI_SCENARIO_STATE_STOP_CLOSE_BREAK_IDX     (17)
#define MMI_SCENARIO_STATE_STOP_CLOSE_CONTINUE_IDX  (18)
#define MMI_SCENARIO_STATE_SCRN_EXIT_IDE            (19)
#define MMI_SCENARIO_STATE_CLOSE_ALL_BG_GROUPS      (20)


#define NODE_ATTRIB_IN_END_KEY_PROCESS_IDX          (1)
#define NODE_ATTRIB_CLOSED_TARGET_IDX               (2)

/* Group */

#define NODE_ATTRIB_CLOSE_FROM_EXTERNAL_IDX         (5)
#define NODE_ATTRIB_CLOSE_TO_EXTERNAL_IDX           (6)
#define NODE_ATTRIB_SMART_CLOSED_IDX                (7)
#define NODE_ATTRIB_GRP_REDRAW_START_IDX            (8)
#define NODE_ATTRIB_SMART_CLOSED_CAUSE_BY_CLOSE_IDX (9)
#define NODE_ATTRIB_BK_ACTIVE                       (11)

/* Screen */
#define NODE_ATTRIB_FULL_SCREEN_IDX                 (4)
#define NODE_ATTRIB_SMALL_SCREEN_IDX                (5)
#define NODE_ATTRIB_IDLE_SCREEN_IDX                 (6)
#define NODE_ATTRIB_MULTI_CLOSE_ACTIVE_SCRN_IDX     (7)
#define NODE_ATTRIB_CHANGE_NODE_TYPE_IN_GOBACK_IDX  (8)
#define NODE_ATTRIB_AUTO_ADD_HISTORY_IDX            (9)
#define NODE_ATTRIB_REDRAW_ENTER_IDX                (10)
#define NODE_ATTRIB_FREE_NODE_IDX                   (11)
#define NODE_ATTRIB_NOT_ALLOW_DEL                   (12)

/* Screen/Tab/Tab-page */
#define NODE_ATTRIB_PAGE_DISABLE                    (15)


#define MMI_SCENARIO_POST_GROUP_EVENT_MAX_SIZE      ((128 - 20) >> 2)   /* the max message size for post mechanism is 128 bytes */
#define INCREMENT     (1)
#define DECREMENT      (-1)

/* send/post group event flag */
#define MMI_SCENARIO_SEND_GROUP_EVENT_NEED_RESULT       (0x01)


/***************************************************************************** 
*  Typedef 
*****************************************************************************/
typedef enum
{
    SCENARIO_NORMAL,
    SCENARIO_POST,    
    
    ERR_G_HIDE_NOT_EXIST,
    ERR_G_UNHIDE_NOT_EXIST,    
    ERR_S_ENTER_NO_PARENT,
    SCENARIO_S_ENTER_INACTIVE,
    SCENARIO_S_ENTER_REDRAW,
    SCENARIO_S_ENTER_BW,
    SCENARIO_S_SCRN_TO_TAB,
    SCENARIO_S_TAB_TO_SCRN,
    ERR_S_ENTER_EXIST_FW,
    ERR_S_ENTER_INACTIVE_GROUP_WITHOUT_ENTER_PROC,
    SCENARIO_S_ENTER_EXIST_ACTIVE,
    ERR_M_S_CLOSE_1,
    ERR_M_S_CLOSE_2,
    ERR_M_S_CLOSE_3,
    ERR_M_S_CLOSE_4,
    ERR_M_S_CLOSE_5,
    ERR_M_S_CLOSE_6,
    ERR_M_S_CLOSE_7,
    
    SCENARIO_G_CLOSE_IN_TOIDLE_PROC,
    ERR_SRV_INVALID_PARENT,
    ERR_SRV_NO_INSTANCE,    
    ERR_ENTER_DIFF_SCRN_IN_REDRAWING,
    S_CREATE_SCREEN_NO_PARENT,
    // group create
    G_CREATE_NO_PARENT_SG_API_END,
    G_CREATE_EXIST_SG_API_END,
    G_CREATE_IN_REDRAW_SG_API_END,    
    // group enter
    G_ENTER_EX_NO_CREATE,    
    G_ENTER_EXIST_SG_API_END,
    G_ENTER_NO_CREATE_SG_API_END,
    G_ENTER_NO_PARENT_SG_API_END,
    // group close
    G_CLOSE_IN_REDRAWING_SG_API_END,
    G_CLOSE_NOTIFY_PARENT_NO_CHILD,
    G_CLOSE_NO_ENTER,
    G_CLOSE_NOT_EXIST,
    G_CLOSE_GOTO_IDLE,
    // scrn first enter
    S_FIRST_ENTER_PID_IS_ROOT,
    S_FIRST_ENTER_NO_PARENT_SG_API_END,
    S_FIRST_ENTER_EXIST_SCRN_SG_API_END,
    S_FIRST_ENTER_EXECUTE_ENTRY_PROC,
    // scrn enter
    S_ENTER_PID_IS_ROOT_NOT_EXIST,
    S_ENTER_PID_IS_ROOT_EXIST,
    // scrn close
    S_CLOSE_IN_REDRAWING_SG_API_END,
    S_CLOSE_NOTIFY_PARENT_NO_CHILD,
    S_CLOSE_SMART_CLOSE_PARENT,    
    // insert    
    NODE_INSERT_NO_PARENT,
    NODE_INSERT_PARA_ERROR,
    NODE_INSERT_NEW_NODE_EXIST,
    NODE_INSERT_NOTIFY_HISTORY_BEG,
    NODE_INSERT_NOTIFY_HISTORY_END,    
    // notify    
    G_SEND_EVENT_CALLER_PROC,
    G_SEND_EVENT_CALLER,
    G_SEND_EVENT_NO_CALLER,
    G_SEND_EVENT_PARENT,
    G_POST_EVENT_CALLER_PROC,
    G_POST_EVENT_NO_SENDER,
    G_POST_EVENT_NO_RECEIVER,
    G_POST_EVENT,
    G_POST_EVENT_CALLER_HANDLER,
    G_POST_EVENT_PARENT_HANDLER,
    G_POST_EVENT_EX_API,
    G_POST_EVENT_NEED_RESULT_EX_API,
    G_POST_EVENT_NEED_RESULT_HANDLER,
    REDRAWING_STAGE1,
    ERR_ENTRY_DUMMY_NOT_ACTIVE,
    // go to idle
    ONLY_IDLE_SG_API_END,

    // close all background groups
    SCENARIO_POST_SG_API_END,
    
    SG_API_BEG,
    SG_API_END,
    
} scenario_err_enum;
typedef enum _post_scenario_act_enum
{
    POST_EXECUTE_ACTIVE,            /* post "active" action in scenario post mech. */
    POST_EXECUTE_INACTIVE,          /* post "inactive" action in scenario post mech. */
    POST_EXECUTE_CLOSE,             /* post "close" action in scenario post mech. */
    POST_EXECUTE_DEINIT,            /* post "deinit" action in scenario post mech. */

    POST_EXECUTE_GROUP_ENTER,       /* post "group enter" action in scenario post mech. */
    POST_EXECUTE_GROUP_ACTIVE,      /* post "group active" action in scenario post mech. */
    POST_EXECUTE_GROUP_INACTIVE,    /* post "group inactive" action in scenario post mech. */
    POST_EXECUTE_GROUP_EXIT,        /* post "group exit" action in scenario post mech. */

    POST_EXECUTE_SCRN_FIRST_ENTRY,  /* post "screen first entry" action in scenario post mech. */
    POST_EXECUTE_SCRN_ACTIVE,       /* post "screen active" action in scenario post mech. */
    POST_EXECUTE_SCRN_INACTIVE,     /* post "screen inactive" action in scenario post mech. */

    POST_EXECUTE_GOBACK_ORG_HIST,   /* post "mmi_go_back_to_history(GoBackHistory)" action in scenario post mech. */
    POST_EXECUTE_SCRN_DUMMY_CLEANUP,     /* post "scrn dummy cleanup"  */
    POST_EXECUTE_GROUP_HIDE,
    POST_EXECUTE_GROUP_UNHIDE,
    POST_EXECUTE_GROUP_MOVE,
    POST_EXECUTE_HIDE,
    POST_EXECUTE_UNHIDE,
    POST_EXECUTE_DEL_HIST,
    POST_EXECUTE_GROUP_FOCUS,
    POST_EXECUTE_GROUP_DEFOCUS,

    POST_EXECUTE_INSERT,
    POST_EXECUTE_CLOSE_TO_IDLE_GROUP,
    POST_EXECUTE_CLOSE_ALL_BG_GROUPS,
    POST_EXECUTE_CLOSE_TO_ROOT_GROUP,
    POST_EXECUTE_DISPLAY_DESKTOP,
    
    POST_EXECUTE_NO_CHILD,
    
    POST_EXECUTE_MAX
}post_scenario_act_enum;


typedef enum _mmi_node_type_enum
{
    SCENARIO_GROUP_NODE,
    SCENARIO_SCRN_NODE,
    SCENARIO_TAB_NODE,
    SCENARIO_TAB_PAGE_NODE,
    SCENARIO_POST_EVT,
    SCENARIO_APP_NAME,
    SCENARIO_NODE_END
}mmi_node_type_enum;

typedef enum
{
    GROUP_TREE,
    GROUP_BG_TREE,
    GROUP_DANGLE_TREE,
    SRV_TREE,
    //IGNORE_TREE,
    SCENARIO_TREE_TYPE_MAX
} scenario_tree_type_enum;


typedef enum _scrn_close_type_enum
{
    SCRN_CLOSE_DEFAULT,
    SCRN_CLOSE_FREEZE_LCD,
    SCRN_CLOSE_ITSELF,

    SCRN_CLOSE_MAX
}scrn_close_type_enum;

typedef enum
{
    GUI_BUFFER,
    INPUT_BUFFER,
    HISTORY_BUF_END
} history_buffer_enum;

typedef enum
{
    PEAK_VALUE,
    DYNAMIC_VALUE,
    SCENARIO_OBJ_STAT_TYPE_END
} scenario_obj_stat_type_enum;

/*  */
typedef enum {
    HOOK_EVT_AFTER_CREATE,
    HOOK_EVT_AFTER_INACTIVE,
    HOOK_EVT_AFTER_DEINIT,
    HOOK_EVT_BEFORE_INACTIVE,
    HOOK_EVT_BEFORE_ACTIVE,
    HOOK_EVT_BEFORE_CLOSE,
    HOOK_EVT_CLOSE_FAIL,
    HOOK_EVT_BEFORE_TO_IDLE,
    HOOK_EVT_SET_ACTIVE_APP,
    HOOK_EVT_BEFORE_ENTER,
	HOOK_EVT_AFTER_ACTIVE
} scenario_hook_evt_enum;

/* asm related data */
typedef struct {
    U32 flag;   /*flag defined in AppMemMgrCore.c 's asm property of app*/
    U32 usage;
    U32 shrunk_base; /*shrunk base size*/
#ifdef  __MMI_ASM_OOM_AUTO_KILL__
    U32  mem_prio; /*memory alloc priority*/
#endif
} asm_data_struct;

#define BASE_NODE_INFO                              \
    struct _base_node_struct    *m_prev;            \
    struct _base_node_struct    *m_next;            \
    U16                          priority;          \
    U16                          type;              \
    struct _group_node_struct   *parent;            \
    U32                         id;                 \
    U16                         attrib;             \
    U16                         state;              \
    void                        *user_data;         \
    mmi_proc_func               proc;



#define GROUP_NODE_INFO                     \
    CHAR                        *app_name;          \
    mmi_proc_func               caller_proc;        \
    void*                       caller_user_data;   \
    struct _group_node_struct   *caller;    \
    struct _base_node_struct    *m_head;    \
    struct _base_node_struct    *m_tail;    \
    S32                         m_count;    \
    asm_data_struct             asm_data;


#define SCRN_NODE_INFO                  \
    mmi_scrn_func   entry_proc;         \
    mmi_scrn_func   exit_proc;          \
    mmi_proc_func   input_proc;         \
    U32             ui_data;


#define SCRN_NODE_HISTORY_INFO          \
    mmi_malloc_func_ptr mem_alloc;      \
    mmi_mfree_func_ptr  mem_free;       \
    void                *mem_user_data; \
    U8                  *gui_buf;       \
    WCHAR               *input_buf;     \
    U16                 gui_buf_size;   \
    U16                 input_buf_size;


typedef struct _base_node_struct
{
    BASE_NODE_INFO

}base_node_struct;


typedef struct _group_node_struct
{
    BASE_NODE_INFO      /* 8 * sizeof(U32) */

    GROUP_NODE_INFO     /* 4 * sizeof(U32) */

}group_node_struct;

typedef struct _scrn_node_history_struct
{
    SCRN_NODE_HISTORY_INFO

}scrn_node_history_struct;

typedef struct _scrn_node_struct
{
    BASE_NODE_INFO          /* 8 * sizeof(U32) */

    SCRN_NODE_INFO          /* 4 * sizeof(U32) */

    SCRN_NODE_HISTORY_INFO  /* 6 * sizeof(U32) */

}scrn_node_struct;


typedef struct _tab_page_node_struct
{
    BASE_NODE_INFO          /* 8 * sizeof(U32) */

    SCRN_NODE_INFO          /* 4 * sizeof(U32) */

    SCRN_NODE_HISTORY_INFO  /* 6 * sizeof(U32) */

    U8              index;
    U8              *icon;  /* sizeof(U32) */
    WCHAR           *label; /* sizeof(U32) */

}tab_page_node_struct;


/* tab node is base on group node */
typedef struct _tab_node_struct
{
    BASE_NODE_INFO          /* 8 * sizeof(U32) */

    SCRN_NODE_INFO          /* 4 * sizeof(U32) */

    SCRN_NODE_HISTORY_INFO  /* 6 * sizeof(U32) */

    GROUP_NODE_INFO         /* 4 * sizeof(U32) */

    U8                  cur_sel_index;
    U8                  page_count;
    S8                  first_item_index;

    MMI_BOOL            use_pen_switch;

}tab_node_struct;


typedef struct _mmi_post_evt_struct                     /* EVT_ID_GROUP_POST_CALLER_NOTIFY & EVT_ID_GROUP_POST_PARENT_NOTIFY */
{
    MMI_EVT_PARAM_HEADER                                /* evt_id: event ID; user_data: the receiver's user_data */

    MMI_ID          sender_gid;
    MMI_ID          receiver_gid;
    MMI_BOOL        need_result;

    U32 data[MMI_SCENARIO_POST_GROUP_EVENT_MAX_SIZE];   /* the max message size for post mechanism is 128 bytes */

}mmi_post_evt_struct;


/*
 * Tricky: We use the high byte of scenario_evt.state to keep the memory type.
 * We need to care the ordering of mmi_scenario_evt_struct and base_node_struct.
 */
typedef struct _mmi_post_scenario_evt_struct
{
    /* scenario_evt must be the first element, we will type-casting mmi_post_scenario_evt_struct to mmi_scenario_evt_struct */
    mmi_scenario_evt_struct scenario_evt;
    post_scenario_act_enum  act;
    U32                     group_id;
    U32                     scrn_id;
}mmi_post_scenario_evt_struct;



typedef struct _post_queue_struct
{
    mmi_post_scenario_evt_struct    *evt;
    U32                             flag;
}post_queue_struct;



typedef struct _shell_struct
{
    U32                     state;

    /* handle to invoke mmi_frm_scrn_first_enter() in goback history process */
    U32                     post_flow_in_org_back_history : 1;
    /* in_external_goback_process means it is in mmi_go_back_to_history procedure. */
    U32                     in_external_goback_process : 1;
    /* 
     * need_to_record_active_target_scrn_for_closing is keep the node that will be close and
     * it is related with goback_target_scrn.
     */
    U32                     is_allow_delete_adapor_node:1;
    U32                     is_in_deinit:1;
    U32                     is_smart_close_in_forward_case:1;
    /* scenario tree */
    group_node_struct       scenario_root;
    group_node_struct       scenario_bg;
    /* active group node */
    group_node_struct       *active_group;
    /* active screen/tab-page node */
    scrn_node_struct        *active_scrn;
    /* active tab node */
    tab_node_struct         *active_tab;
    /* scenario dangle tree: only 1 level */
    group_node_struct       scenario_dangle;
    /* the node that current event is going to */
    base_node_struct        *targ_node;
}shell_struct;

typedef struct
{
    U32             topmost_full_scrn_id;
    MMI_BOOL        start_draw;                 
    group_node_struct   *skip_group_ptr;
    shell_struct    backup_group_shell;
}traverse_redraw_ctxt_struct;

typedef struct
{
    U32     topmost_full_scrn_id;
    S16     history_idx;
    S16     tmp_idx;
}traverse_find_ctxt_struct;

typedef struct
{
    U32     topmost_full_scrn_id;
    U32     level_one_node;
}traverse_find_ctxt_struct_ex;

typedef struct
{
    U16             target_scrn_id;
    U32             result;                 
    U32             currLevel;
}traverse_level_ctxt_struct;

typedef mmi_ret (*TraverseNodeOpFunc) (base_node_struct *node, void *arg);

/* struct connect the screen group and screen history */
typedef struct
{
    MMI_ID                  active_group_id;
    MMI_ID                  exit_group_id;
    MMI_ID                  active_scrn_id;
    MMI_ID                  exit_scrn_id;
    U16                     max_his_buf_size[HISTORY_BUF_END];
    U8                      scenario_obj_stat[SCENARIO_NODE_END][SCENARIO_OBJ_STAT_TYPE_END];
} screen_mgr_struct;

#define ROOT_SCRN_ENTER_EVT  \
    MMI_EVT_PARAM_HEADER     \
    MMI_ID scrn_id;          \
    FuncPtr entry_proc;

typedef struct
{
    ROOT_SCRN_ENTER_EVT
} enter_root_screen_evt_struct;

typedef struct
{
    ROOT_SCRN_ENTER_EVT
    void *arg;
    mmi_proc_func scrn_proc;
} first_enter_root_screen_evt_struct;

typedef struct
{
    ROOT_SCRN_ENTER_EVT
    FuncPtr exit_proc;
    mmi_frm_scrn_type_enum type;
} comm_enter_root_screen_evt_struct;

/* insert post operation info */
typedef struct
{
    MMI_ID parent_id;
    MMI_ID base_id;
    mmi_scenario_node_flag flag;
    MMI_BOOL is_group_node;
    mmi_frm_node_struct new_node_info;        
} insert_op_info_struct;


/***************************************************************************** 
*  Extern Variables
*****************************************************************************/
extern shell_struct shell;

/***************************************************************************** 
*  Global Variables
*****************************************************************************/


/*****************************************************************************  
*  Local Variables 
*****************************************************************************/


/*****************************************************************************  
*   Extern Functions 
*****************************************************************************/
extern void mmi_frm_shell_init(void);
extern void group_check_small_by_id(U32 scrn_id, traverse_find_ctxt_struct* );
extern void group_redraw_by_id(U32 scrn_id, traverse_redraw_ctxt_struct* );
extern void group_status_backup(shell_struct *backup_shell_ptr);
extern void group_status_restore(shell_struct *backup_shell_ptr);
extern void group_redraw_by_id(U32 scrn_id, traverse_redraw_ctxt_struct* );
extern void group_check_level_by_id(U32 scrn_id, traverse_level_ctxt_struct* );
extern U32 mmi_frm_get_max_history_buffer_size(U8 type);
extern U8 mmi_frm_scenario_get_dync_obj_info(U8 obj_type, U8 stat_type);

extern mmi_ret mmi_frm_group_set_attribute_int(MMI_ID group_id, U32 attrib, MMI_BOOL val);
extern MMI_BOOL mmi_frm_group_get_attribute_int(MMI_ID group_id, U32 attrib);

extern asm_data_struct * mmi_frm_group_get_asm_data_ptr(MMI_ID group_id);


/* For AppMgr Srv */
extern MMI_ID mmi_frm_group_query_app_name(const char *app_name);
extern S32 mmi_frm_group_query_app_num(scenario_tree_type_enum type);
extern mmi_ret mmi_frm_group_query_app_list(scenario_tree_type_enum type, group_node_struct **table, S32 table_size);
extern mmi_ret mmi_frm_group_send_event_ex (MMI_ID sender_gid, MMI_ID receiver_gid, mmi_event_struct *evt);
extern void mmi_frm_group_post_event_ex (MMI_ID sender_gid, MMI_ID receiver_gid, mmi_event_struct *evt, U32 flag);
extern mmi_ret mmi_frm_group_set_app_name(MMI_ID gid, CHAR *app_name);

 

extern MMI_BOOL mmi_frm_scenario_is_redrawing(void);
#ifndef __MMI_FRM_HISTORY__
extern U32 mmi_frm_get_screen_level_sg(U16 scrn_id);
extern MMI_BOOL mmi_frm_in_exit_hdlr_proc_sg(void);
extern void mmi_frm_switch_small_screen_redraw_sg(MMI_BOOL enable);
#endif
extern void mmi_frm_set_active_group_int(MMI_ID group_id);
extern MMI_RET mmi_frm_group_urgent_close(MMI_ID group_id);
/*****************************************************************************  
*   Local Functions  
*****************************************************************************/


#endif /* MMI_FRM_SCENARIO_PROT_H */

