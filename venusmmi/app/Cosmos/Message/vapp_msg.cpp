/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH锟斤拷
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*******************************************************************************
 * Filename:
 * ---------
 *  vapp_msg.cpp
 *
 * Project:
 * --------
 *  Venus
 *
 * Description:
 * ------------
 *  
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!

not happen on tempload 


[Lifang 5\17]

Dear Ken,

我放了一份新的12.20的bin在\\glbfs14\sw_releases\Valid_Before_20120701\from Lifang，麻烦您验证一下。

谢谢！



0515 Ken

hi , Lifang，你@份load _不了C，你用的是1217 的code base，目前hq @都用e2 的手C了，所以只能用18 以上的code base 。

e1的手C全部回收了…，可能要你generate 一份1218 或1220 code base的load 再Mpatch 眚，麻┠懔




[Lifang 5\13]

Dear Ken,

我在\\glbfs14\sw_releases\Valid_Before_20120701\from Lifang放了一个bin档，由于这笔issue的复现有点难且不是必现，因此我不是很肯定已经把这笔issue解了，想请您帮忙验证一下。

谢谢！


Basic function so set high


[Load Path]

\\mtksfs07\Public3\11B_branch_load\W12.17_Stage1\KHAN50_V11_DEMO_GPRS(12864_COSMOS_HVGA_CN)\12.17_official_release

 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/

/***************************************************************************** 
 * Include
 *****************************************************************************/
#include "MMI_features.h"  
#include "vapp_msg_features.h"
#include "vapp_msg_gprot.h"
#include "vapp_msg.h"
#include "vapp_msg_viewer.h"
#include "vapp_sms_viewer.h"
#include "vapp_text_template_scrn.h"
#include "vapp_sms_gprot.h"
#include "vapp_sms_setting_scrn.h"
#ifdef __MMI_MMS_IN_UM__
#include "vapp_mms_viewer.h"
#include "vapp_mms_setting.h"
#include "vapp_mms_common.h"
#include "vapp_mms_contact_provider.h"
#include "vapp_mms_gprot.h"
#endif /* __MMI_MMS_IN_UM__ */
#ifdef __MMI_PUSH_IN_UM__
#include "vapp_wap_push_viewer.h"
#include "vapp_wap_push_setting.h"
#include "vapp_wap_push_interface.h"
#endif /* __MMI_PUSH_IN_UM__ */
#ifdef __MMI_PROV_IN_UM__
#include "vapp_prov_viewer.h"
#include "vapp_prov_util.h"
#endif /* __MMI_PROV_IN_UM__ */
#include "vapp_uc_gprot.h" /* emoticon */
#include "vapp_msg_contact_bar.h"
#include "vcui_dialer_gprot.h" /* vcui_dialer_create */
#include "vapp_sim_setting_gprot.h" /* vapp_sim_settings_get_sim_name_with_sim_id */
#ifdef __MMI_USB_SUPPORT__
#include "Vapp_usb_gprot.h"
#endif /* __MMI_USB_SUPPORT__ */

#include "vcp_global_popup.h"
#include "vcp_function_bar.h"
#include "vfx_system.h"
#ifdef __AFX_RT_TEST__
#include "vtst_rt_main.h"
#endif
#include "../xml/vfx_xml_loader.h"
#include "../cbapp/Vapp_cbs_setting_page.h"
#include "vfx_adp_device.h"
#ifdef __MMI_UNIFIED_COMPOSER__
#include "mmi_rp_vapp_unifiedcomposer_def.h"
#endif

#ifdef __MMI_SNS_MESSAGES__
#include "Vapp_sns_gprot.h"
#endif /* __MMI_SNS_MESSAGES__ */

/* Pluto MMI headers: */
#ifdef __cplusplus
extern "C"
#endif
{
    #include "MMI_features.h" 
    #include "UMSrvGprot.h"  /* for UM service event */
    #include "SmsSrvGprot.h" /* for SMS service */
#ifdef __MMI_MMS_IN_UM__
    #include "MmsSrvGprot.h" /* for MMS service */
    #include "Mma_api.h" /* for get mms box type */
#endif /* __MMI_MMS_IN_UM__ */
    #include "mmi_rp_vapp_msg_def.h"
    #include "mmi_rp_app_cosmos_global_def.h"
    #include "App_str.h"
    #include "FileMgrSrvGProt.h"
    #include "UcSrvGprot.h" /* srv_uc_info_type_enum */
    #include "UCMGProt.h" /* mmi_ucm_make_call_para_struct */
    #include "mmi_rp_srv_venus_component_tool_bar_def.h" /* toolbar resource */
    #include "SimCtrlSrvGprot.h" /* srv_sim_ctrl_is_available */
    #include "IdleNotificationManagerGprot.h" /* for dummy function */
#ifdef __MMI_PUSH_IN_UM__
    #include "WAPPushSrvGprots.h" /* for get unread count of push */
#endif /* __MMI_PUSH_IN_UM__ */
    #include "PhbSrvGprot.h" /* srv_phb_get_name_by_number */
    #include "custom_phb_config.h" /* MMI_PHB_NAME_LENGTH */
    #include "GlobalResDef.h" /* for global string */
#ifdef __MMI_PROV_IN_UM__
    #include "ProvBoxSrvGProt.h" /* srv_provbox_get_msg_status, srv_provbox_set_msg_status */
#endif /* __MMI_PROV_IN_UM__ */
#ifdef __MMI_USB_SUPPORT__
    #include "USBSrvGprot.h" /* srv_usb_is_in_mass_storage_mode */
    #include "Mmi_rp_app_usbsrv_def.h" /* EVT_ID_USB_ENTER_MS_MODE */
#endif /* __MMI_USB_SUPPORT__ */
    #include "ModeSwitchSrvGprot.h" /* srv_mode_switch_is_network_service_available */
    #include "mmi_frm_utility_gprot.h" /* MMI_SIM_ALL */

    #include "AppMgrSrvGprot.h"
    #include "NativeAppFactorySrvGprot.h"
    #include "Unicodexdcl.h"

#ifdef __SMS_CLOUD_SUPPORT__
    #include "CloudSrvGprot.h"
    #include "mmi_rp_srv_sso_def.h"
    #include "mmi_rp_vcui_sso_setting_def.h"
#endif /* __CLOUD_SUPPORT__ */
}
#ifdef __SMS_CLOUD_SUPPORT__
    #include "Vcui_sso_gprot.h"
#endif /* __CLOUD_SUPPORT__ */

#ifdef __MMI_SMS_COMPOSER__
    #include "vcui_sms_composer_gprot.h"
    #include "mmi_rp_vcui_sms_composer_def.h"
#endif
     

/***************************************************************************** 
 * Define
 *****************************************************************************/
#define VAPP_MSG_MS_TIMER_PERIOD 300

/***************************************************************************** 
 * Typedef
 *****************************************************************************/

/***************************************************************************** 
 * Global Variable
 *****************************************************************************/

/***************************************************************************** 
 * Function
 *****************************************************************************/

extern "C" MMI_ID vapp_msg_launch(void *param, U32 param_size)
{
    VfxAppLauncher::killApp(
        VAPP_MSG, 
        VFX_OBJ_CLASS_INFO(VappMsgApp), 
        VFX_APP_LAUNACHER_FIND_APP_NORMAL_FLAG | VFX_APP_LAUNACHER_FIND_APP_BG_FLAG);

    /* check if ready */
    if (MMI_TRUE == srv_um_check_ready_type(srv_um_support_msg_type()))
    {
        VfxAppLauncher::launch( 
            VAPP_MSG,
            VFX_OBJ_CLASS_INFO(VappMsgApp),
            GRP_ID_ROOT, 
            param, 
            param_size);
    }
    else
    {
        mmi_frm_nmgr_balloon(
            MMI_SCENARIO_ID_GENERAL,
            MMI_EVENT_INFO_BALLOON,
            MMI_NMGR_BALLOON_TYPE_INFO,
            (WCHAR*)GetString(STR_ID_VAPP_MSG_NOT_READY));
    }

    return MMI_RET_OK;
}

extern "C" MMI_ID vapp_msg_launch_with_callback(void *param, U32 param_size)
{
    VfxAppLauncher::killApp(
        VAPP_MSG, 
        VFX_OBJ_CLASS_INFO(VappMsgApp), 
        VFX_APP_LAUNACHER_FIND_APP_NORMAL_FLAG | VFX_APP_LAUNACHER_FIND_APP_BG_FLAG);

    /* check if ready */
    if (MMI_TRUE == srv_um_check_ready_type(srv_um_support_msg_type()))
    {
		VappMsgLaunchStruct* data = (VappMsgLaunchStruct*)param;        
		
        VfxAppLauncherParam launch_param(VAPP_MSG, VFX_OBJ_CLASS_INFO(VappMsgApp), GRP_ID_ROOT);
        launch_param.setArgument(data, sizeof(VappMsgLaunchStruct));
        launch_param.setLauncherResultCb(data->cbFunc, (void*)data->cbFuncParam);
        VfxAppLauncher::launchEx(launch_param);
    }
    else
    {
        mmi_frm_nmgr_balloon(
            MMI_SCENARIO_ID_GENERAL,
            MMI_EVENT_INFO_BALLOON,
            MMI_NMGR_BALLOON_TYPE_INFO,
            (WCHAR*)GetString(STR_ID_VAPP_MSG_NOT_READY));
    }

    return MMI_RET_OK;
}

extern "C" mmi_ret vapp_msg_event_hdlr(mmi_event_struct *evt)
{
    switch(evt->evt_id)
    {
        case EVT_ID_SRV_UM_NOTIFY_READY:
        case EVT_ID_SRV_UM_NOTIFY_REFRESH:
        {
            srv_appmgr_update_app_info("native.mtk.msg", EVT_ID_SRV_APPMGR_UPDATE_BADGE);
            return MMI_RET_OK;
        }

        default:
            return MMI_RET_DONT_CARE;
    }
}

extern "C" mmi_ret vapp_msg_package_proc(mmi_event_struct* evt)
{
    switch(evt->evt_id)
    {
        case EVT_ID_SRV_NATIVEAPPFACTORY_QUERY_APP_BADGE:
        {
            srv_um_get_msg_num_result data;
            srv_nativeappfactory_query_app_badge_evt_struct* badge_evt = (srv_nativeappfactory_query_app_badge_evt_struct*)evt;
            S32 result = srv_um_check_msg_num(SRV_UM_SIM_ALL, SRV_UM_MSG_ALL, &data);

            if (SRV_UM_RESULT_OK == result && 0 != data.inbox_unread_msg_number)
            {
                mmi_wsprintf_ex(
                    (badge_evt->badge), 
                    (SRV_APPMGR_BADGE_MAX_LEN + 1) * sizeof(WCHAR),
                    (WCHAR*)L"%d", 
                    (VfxU32)(data.inbox_unread_msg_number));	
            }
            else
            {
                mmi_wsprintf_ex(
                    (badge_evt->badge), 
                    (SRV_APPMGR_BADGE_MAX_LEN + 1) * sizeof(WCHAR),
                    (WCHAR*)L"", 
                    (VfxU32)(data.inbox_unread_msg_number));	
            }
            return MMI_RET_OK;
        }
            
        default:
            return MMI_RET_DONT_CARE;
    }
}

extern "C" MMI_ID vapp_msg_launch_inbox()
{
    VappMsgLaunchStruct param;
    param.mode = VAPP_MSG_LAUNCH_INBOX;
    vapp_msg_launch(&param, sizeof(param));
    return MMI_RET_OK;
}


VFX_IMPLEMENT_CLASS("VappMsgApp", VappMsgApp, VfxApp);

VappMsgApp::VappMsgApp()
	:m_subMsgCb(NULL),
	 m_isCloseApp(VFX_FALSE),
	 m_userData(NULL)
{}

void VappMsgApp::onRun(void * args, VfxU32 argSize)
{
    VfxApp::onRun(args, argSize);

    // create and display main screen
    VappMsgLaunchStruct *param;
    param = (VappMsgLaunchStruct *)args;

    VappMsgScreen *scr;
    VFX_OBJ_CREATE(scr, VappMsgScreen, this);
    if (NULL != param)
    {
        MMI_TRACE(TRACE_GROUP_6, TRC_MMI_VAPP_MSG_LAUNCH, param->mode);
        scr->setFirstEntryMode(param->mode);
    }
    else
    {
        MMI_TRACE(TRACE_GROUP_6, TRC_MMI_VAPP_MSG_LAUNCH, VAPP_MSG_LAUNCH_NORMAL);
    }
    scr->show();

    /* Send the event out */
    VappMsgEntryStruct evt;
    MMI_FRM_INIT_EVENT(&evt, EVT_ID_VAPP_MSG_ENTRY);
    evt.isEntry = VFX_TRUE;
    MMI_FRM_CB_EMIT_POST_EVENT(&evt);
}

VfxBool VappMsgApp::setSubMsgCareHomeKeyCb(subMsgCareHomeKeyCbFunc cbFunc, void *user_data)
{
    if (NULL != cbFunc)
    {
        m_subMsgCb = cbFunc;
        m_userData = user_data;
        return VFX_TRUE;
    }
    
    return VFX_FALSE;
}

VfxBool VappMsgApp::subMsgFreeHomeKey()
{
    if (!m_isCloseApp)
        return VFX_FALSE;
    
    if (NULL != m_subMsgCb)
    {
        m_subMsgCb = NULL;
        continueClose(VFX_APP_CLOSE_ANSWER_YES);
        return VFX_TRUE;
    }
    MMI_ASSERT(0);

    return VFX_FALSE;
}

VfxBool VappMsgApp::releaseSubMsgCareHomeKeyCb(subMsgCareHomeKeyCbFunc cbFunc)
{
    if (m_subMsgCb == cbFunc)
    {   
        m_subMsgCb = NULL;
        m_userData = NULL;
        return VFX_TRUE;
    }
    return VFX_FALSE;
}

void VappMsgApp::onInit()
{
    MMI_PRINT(MOD_MMI_COMMON_APP, TRACE_GROUP_6, "%s", this->getClassInfo()->getClassName());
    MMI_TRACE(TRACE_GROUP_6, TRC_MMI_VAPP_MSG_ON_INIT, this);
    VfxApp::onInit();

    mmi_frm_cb_reg_event(EVT_ID_SRV_UM_NOTIFY_READY, &VappMsgApp::onMsgSrvEvtCb, getObjHandle());
	
#if (defined (__SIM_HOT_SWAP_SUPPORT__) || (__SIM_RECOVERY_ENHANCEMENT__))
	mmi_frm_cb_reg_event(EVT_ID_SRV_SIM_CTRL_EVENT_DETECTED, &VappMsgApp::onSimDetected, getObjHandle());
#endif

}

void VappMsgApp::onDeinit()
{
    mmi_frm_cb_dereg_event(EVT_ID_SRV_UM_NOTIFY_READY, &VappMsgApp::onMsgSrvEvtCb, getObjHandle());

#if (defined (__SIM_HOT_SWAP_SUPPORT__) || (__SIM_RECOVERY_ENHANCEMENT__))
	mmi_frm_cb_dereg_event(EVT_ID_SRV_SIM_CTRL_EVENT_DETECTED, &VappMsgApp::onSimDetected, getObjHandle());
#endif

    VfxApp::onDeinit();
}

#if (defined (__SIM_HOT_SWAP_SUPPORT__) || (__SIM_RECOVERY_ENHANCEMENT__))
mmi_ret VappMsgApp::onSimDetected(mmi_event_struct * param)
{
    VappMsgApp *self = (VappMsgApp *)VfxObject::handleToObject((VfxObjHandle)param->user_data);

    /* Need to check if it is NULL pointer. Otherwise, it may cause fatal error of NULL pointer access */
    if (NULL != self)
    {
	    self->exit();
    }
    return MMI_RET_OK;
}
#endif

VfxAppCloseAnswerEnum VappMsgApp::onProcessClose(VfxAppCloseOption options)
{
    m_isCloseApp = VFX_TRUE;
    
    if (NULL != m_subMsgCb)
    {
        VfxBool result = VFX_FALSE;
        (*m_subMsgCb)(result, m_userData);
        if (VFX_TRUE == result)
        {
            return VFX_APP_CLOSE_ANSWER_LATER;
        }
        else
        {
            m_subMsgCb = NULL;
        }
    }
    return VFX_APP_CLOSE_ANSWER_YES;
}

mmi_ret VappMsgApp::onMsgSrvEvtCb(mmi_event_struct * param)
{
    VappMsgApp *self = (VappMsgApp *)VfxObject::handleToObject((VfxObjHandle)param->user_data);

    if (self)
    {
        MMI_PRINT(MOD_MMI_COMMON_APP, TRACE_GROUP_6, "%s", self->getClassInfo()->getClassName());
        MMI_TRACE(TRACE_GROUP_6, TRC_MMI_VAPP_MSG_UM_SRV_EVT, param->evt_id, self);
        if (self->isKindOf(VFX_OBJ_CLASS_INFO(VappMsgApp)))
        {
            switch (param->evt_id)
            {
                case EVT_ID_SRV_UM_NOTIFY_READY:
                    if (MMI_FALSE == srv_um_check_ready())
                    {
                        // display a error popup
                        /*vcp_global_popup_show_confirm_one_button_id(
                            GRP_ID_ROOT,
                            VCP_POPUP_TYPE_INFO, 
                            STR_ID_VAPP_MSG_NOT_READY_AND_CLOSE_APP, 
                            STR_GLOBAL_OK, 
                            VCP_POPUP_BUTTON_TYPE_NORMAL,  
                            NULL,
                            NULL);*/
                        mmi_frm_nmgr_balloon(
                            MMI_SCENARIO_ID_GENERAL,
                            MMI_EVENT_INFO_BALLOON,
                            MMI_NMGR_BALLOON_TYPE_INFO,
                            (WCHAR*)GetString(STR_ID_VAPP_MSG_NOT_READY));
                        // close it 
                        self->exit();
                    }
                    break;

                default:
                    break;
            }
        }
    }

    return MMI_RET_OK;
}


VFX_IMPLEMENT_CLASS("VappMsgScreen", VappMsgScreen, VfxMainScr);

VappMsgScreen::VappMsgScreen():
    m_mode(VAPP_MSG_LAUNCH_NORMAL),
    m_isEntered(VFX_FALSE),
    m_pageFirstEnter(NULL)
{
    setAppContextShareForVrt(VFX_TRUE);
}

void VappMsgScreen::setFirstEntryMode(VappMsgLaunchMode mode)
{
    m_mode = mode;
}

void VappMsgScreen::on1stReady()
{
    VfxMainScr::on1stReady();
    // read setting from NVRAM
        VfxU8 select = 0;
        VfxS16 error;

        ReadValue(NVRAM_VAPP_MESSAGE_CS_SETTING, &select, DS_BYTE, &error);
#ifdef __MMI_UM_CONVERSATION_BOX__
    #ifdef __MMI_UM_BOX_LIST_SUPPORT__        
        if (0 != select && 1 != select)
        {
            /* Value is wrong, reset as default value */
            select = 1;
            WriteValue(NVRAM_VAPP_MESSAGE_CS_SETTING, &select, DS_BYTE, &error);
        }
    #endif  /* __MMI_UM_BOX_LIST_SUPPORT__ */
#endif /* __MMI_UM_CONVERSATION_BOX__ */

#ifdef __MMI_SNS_MESSAGES__
    createSimPage(select);      
#else /* __MMI_SNS_MESSAGES__ */

    /* check if entry sim box */
    switch (m_mode)
    {
        case VAPP_MSG_LAUNCH_SIM1_BOX:
            entrySimFolder(SRV_UM_SIM_GSM_SIM1);
            return;

    #if (MMI_MAX_SIM_NUM >= 2)
        case VAPP_MSG_LAUNCH_SIM2_BOX:
            entrySimFolder(SRV_UM_SIM_GSM_SIM2);
            return;
    #endif /* MMI_MAX_SIM_NUM >= 2 */

    #if (MMI_MAX_SIM_NUM >= 3)
        case VAPP_MSG_LAUNCH_SIM3_BOX:
            entrySimFolder(SRV_UM_SIM_GSM_SIM3);
            return;
    #endif /* MMI_MAX_SIM_NUM >= 3 */

    #if (MMI_MAX_SIM_NUM >= 4)
        case VAPP_MSG_LAUNCH_SIM4_BOX:
            entrySimFolder(SRV_UM_SIM_GSM_SIM4);
            return;
    #endif /* MMI_MAX_SIM_NUM >= 4 */

        default:
            break;
    }

#ifdef __MMI_UM_BOX_LIST_SUPPORT__
    if (1 == select)
#endif  /* __MMI_UM_BOX_LIST_SUPPORT__ */         
    {
        VappMsgFolderPage *page;
        VFX_OBJ_CREATE_EX(page, 
                          VappMsgFolderPage, 
                          this, 
                          (SRV_UM_MSG_ALL, 
                           SRV_UM_MSG_BOX_INBOX | SRV_UM_MSG_BOX_SENT | SRV_UM_MSG_BOX_UNSENT | SRV_UM_MSG_BOX_DRAFT, 
                           SRV_UM_SIM_ALL, 
                           VAPP_MSG_FOLDER_TYPE_CONVERSATION));
        pushPage(VAPP_MSG_SCREEN_PAGE_CONVERSATION, page);
        m_pageFirstEnter = (VfxPage*) page;
    }
#ifdef __MMI_UM_BOX_LIST_SUPPORT__
    else if (0 == select)
    {
        switch (m_mode)
        {
            case VAPP_MSG_LAUNCH_NORMAL:
            {
                VappMsgBoxListPage *page;
                VFX_OBJ_CREATE(page, VappMsgBoxListPage, this);
                pushPage(VAPP_MSG_SCREEN_PAGE_BOX_LIST, page);
                m_pageFirstEnter = (VfxPage*) page;
            }
                break;

            case VAPP_MSG_LAUNCH_INBOX:
            {
                /* entry inbox */
                VappMsgFolderPage *page;
                VFX_OBJ_CREATE(page, VappMsgFolderPage, this);
                pushPage(VAPP_MSG_SCREEN_PAGE_FOLDER, page);
                m_pageFirstEnter = (VfxPage*) page;
            }
                break;

            case VAPP_MSG_LAUNCH_OUTBOX:
            {
                /* entry outbox */
                VappMsgFolderPage *page;
                VFX_OBJ_CREATE_EX(page, 
                                  VappMsgFolderPage, 
                                  this, 
                                  (SRV_UM_MSG_ALL, 
                                   SRV_UM_MSG_BOX_UNSENT));
                pushPage(VAPP_MSG_SCREEN_PAGE_FOLDER, page);
                m_pageFirstEnter = (VfxPage*) page;
            }
                break;

            default:
                VFX_ASSERT(0);
                break;
        }
    }
    else
    {
        VFX_ASSERT(0);
    }
#endif  /* __MMI_UM_BOX_LIST_SUPPORT__ */   
#endif /* !__MMI_SNS_MESSAGES__ */
}

#ifdef __MMI_SNS_MESSAGES__
VfxPage *VappMsgScreen::createSimPage(VfxU8 select)
{
    VappMsgFolderPage *folderPage = NULL;
    VappMsgTabPage *tabPage = NULL;
    switch (m_mode)
    {
        case VAPP_MSG_LAUNCH_NORMAL:        
        case VAPP_MSG_LAUNCH_SNS:
            {
                VFX_OBJ_CREATE_EX(tabPage, 
                                  VappMsgTabPage, 
                                  this, 
                                  (m_mode));
                pushPage(VAPP_MSG_SCREEN_PAGE_TAB, tabPage);
                m_pageFirstEnter = (VfxPage*) tabPage;
            }
            break;
            
        case VAPP_MSG_LAUNCH_INBOX:
        case VAPP_MSG_LAUNCH_OUTBOX:
        	#ifdef __MMI_UM_BOX_LIST_SUPPORT__
            if (1 == select)
            {
            #endif /* __MMI_UM_BOX_LIST_SUPPORT__ */
                VFX_OBJ_CREATE_EX(tabPage, 
                                  VappMsgTabPage, 
                                  this, 
                                  (m_mode));
                pushPage(VAPP_MSG_SCREEN_PAGE_TAB, tabPage);
                m_pageFirstEnter = (VfxPage*) tabPage;        
            #ifdef __MMI_UM_BOX_LIST_SUPPORT__
            }
            else
            {
                if (VAPP_MSG_LAUNCH_INBOX == m_mode)
                {
                    /* entry inbox */
                    VFX_OBJ_CREATE_EX(folderPage, 
                                      VappMsgFolderPage, 
                                      this, 
                                      (SRV_UM_MSG_ALL, 
                                       SRV_UM_MSG_BOX_INBOX));
                    pushPage(VAPP_MSG_SCREEN_PAGE_FOLDER, folderPage);
                    m_pageFirstEnter = (VfxPage*) folderPage;
                }
                else if (VAPP_MSG_LAUNCH_OUTBOX == m_mode)
                {
                    /* entry outbox */
                    VFX_OBJ_CREATE_EX(folderPage, 
                                      VappMsgFolderPage, 
                                      this, 
                                      (SRV_UM_MSG_ALL, 
                                       SRV_UM_MSG_BOX_UNSENT));
                    pushPage(VAPP_MSG_SCREEN_PAGE_FOLDER, folderPage);
                    m_pageFirstEnter = (VfxPage*) folderPage;
                }
                else
                {
                    VFX_ASSERT(0);
                }
            }
            #endif /* __MMI_UM_BOX_LIST_SUPPORT__ */
            break;

        case VAPP_MSG_LAUNCH_SIM1_BOX:
            VFX_OBJ_CREATE_EX(folderPage, 
                              VappMsgFolderPage, 
                              this, 
                              (SRV_UM_MSG_ALL, 
                               SRV_UM_MSG_BOX_SIM, 
                               VAPP_MSG_LAUNCH_SIM1_BOX));
            pushPage(VAPP_MSG_SCREEN_PAGE_FOLDER, folderPage);
            m_pageFirstEnter = (VfxPage*) folderPage;
            break;

    #if (MMI_MAX_SIM_NUM >= 2)
        case VAPP_MSG_LAUNCH_SIM2_BOX:
            VFX_OBJ_CREATE_EX(folderPage, 
                              VappMsgFolderPage, 
                              this, 
                              (SRV_UM_MSG_ALL, 
                               SRV_UM_MSG_BOX_SIM, 
                               VAPP_MSG_LAUNCH_SIM2_BOX));
            pushPage(VAPP_MSG_SCREEN_PAGE_FOLDER, folderPage);
            m_pageFirstEnter = (VfxPage*) folderPage;
            break;
    #endif /* MMI_MAX_SIM_NUM >= 2 */

    #if (MMI_MAX_SIM_NUM >= 3)
        case VAPP_MSG_LAUNCH_SIM3_BOX:
            VFX_OBJ_CREATE_EX(folderPage, 
                              VappMsgFolderPage, 
                              this, 
                              (SRV_UM_MSG_ALL, 
                               SRV_UM_MSG_BOX_SIM, 
                               VAPP_MSG_LAUNCH_SIM3_BOX));
            pushPage(VAPP_MSG_SCREEN_PAGE_FOLDER, folderPage);
            m_pageFirstEnter = (VfxPage*) folderPage;
            break;
    #endif /* MMI_MAX_SIM_NUM >= 3 */

    #if (MMI_MAX_SIM_NUM >= 4)
        case VAPP_MSG_LAUNCH_SIM4_BOX:
            VFX_OBJ_CREATE_EX(folderPage, 
                              VappMsgFolderPage, 
                              this, 
                              (SRV_UM_MSG_ALL, 
                               SRV_UM_MSG_BOX_SIM, 
                               VAPP_MSG_LAUNCH_SIM4_BOX));
            pushPage(VAPP_MSG_SCREEN_PAGE_FOLDER, folderPage);
            m_pageFirstEnter = (VfxPage*) folderPage;
            break;
    #endif /* MMI_MAX_SIM_NUM >= 4 */

        default:
            VFX_ASSERT(0);
            break;
    }

    return m_pageFirstEnter;
}
#endif /*__MMI_SNS_MESSAGES__*/
void VappMsgScreen::on2ndReady()
{
    VfxMainScr::on2ndReady();
    m_isEntered = VFX_TRUE;
    VFX_ASSERT(m_pageFirstEnter != NULL);
    m_pageFirstEnter->checkUpdate();
}

void VappMsgScreen::entrySimFolder(srv_um_sim_enum umSim)
{
    /* entry sim1 box */
    VappMsgFolderPage *page;
    VFX_OBJ_CREATE_EX(page, 
                      VappMsgFolderPage, 
                      this, 
                      (SRV_UM_MSG_ALL, 
                       SRV_UM_MSG_BOX_SIM, 
                       umSim));
    pushPage(VAPP_MSG_SCREEN_PAGE_FOLDER, page);
    m_pageFirstEnter = (VfxPage*) page;
}

#ifdef __MMI_UM_BOX_LIST_SUPPORT__
void VappMsgScreen::setMode(VfxBool isConversation)
{
    MMI_PRINT(MOD_MMI_COMMON_APP, TRACE_GROUP_6, "%s", this->getClassInfo()->getClassName());
    MMI_TRACE(TRACE_GROUP_6, TRC_MMI_VAPP_MSG_SET_MODE, isConversation, this);

#ifdef __MMI_SNS_MESSAGES__
    VappMsgTabPage *tabPage = VFX_OBJ_DYNAMIC_CAST(getPage(VAPP_MSG_SCREEN_PAGE_TAB), VappMsgTabPage);
    VFX_DEV_ASSERT(NULL != tabPage);

    /* check current page if folder page or box list page */
    VfxPage *page = tabPage->getTabPage(VappMsgTabPage::VAPP_MSG_TAB_NATIVE);
    VappMsgFolderPage *fdPage = VFX_OBJ_DYNAMIC_CAST(page, VappMsgFolderPage);
    VappMsgBoxListPage *boxPage = VFX_OBJ_DYNAMIC_CAST(page, VappMsgBoxListPage);
    if (VFX_TRUE == isConversation)
    {
        VappMsgFolderPage *pageInsert;
        VFX_OBJ_CREATE_EX(pageInsert, 
                          VappMsgFolderPage, 
                          tabPage, 
                          (SRV_UM_MSG_ALL, 
                           SRV_UM_MSG_BOX_INBOX | SRV_UM_MSG_BOX_SENT | SRV_UM_MSG_BOX_UNSENT | SRV_UM_MSG_BOX_DRAFT, 
                           SRV_UM_SIM_ALL, 
                           VAPP_MSG_FOLDER_TYPE_CONVERSATION, 
                           VAPP_MSG_FOLDER_MODE_NORMAL, 
                           VFX_FALSE));
        tabPage->replaceTab(VappMsgTabPage::VAPP_MSG_TAB_NATIVE, STR_ID_VAPP_MSG_LOCAL, VcpStateImage(IMG_ID_VAPP_MSG_TAB_LOCAL), pageInsert);
    }
    else
    {
        VappMsgBoxListPage *pageInsert;
        VFX_OBJ_CREATE_EX(pageInsert, VappMsgBoxListPage, tabPage, (VFX_FALSE));
        tabPage->replaceTab(VappMsgTabPage::VAPP_MSG_TAB_NATIVE, STR_ID_VAPP_MSG_LOCAL, VcpStateImage(IMG_ID_VAPP_MSG_TAB_LOCAL), pageInsert);
    }
#else /* __MMI_SNS_MESSAGES__ */
    if (VFX_TRUE == isConversation)
    {
        // find conversation page
        VfxPage *page;
        page = getPage(VAPP_MSG_SCREEN_PAGE_CONVERSATION);
        if (NULL == page)
        {
            // not find insert it
            VappMsgFolderPage *pageInsert;
            VFX_OBJ_CREATE_EX(pageInsert, 
                              VappMsgFolderPage, 
                              this, 
                              (SRV_UM_MSG_ALL, 
                               SRV_UM_MSG_BOX_INBOX | SRV_UM_MSG_BOX_SENT | SRV_UM_MSG_BOX_UNSENT | SRV_UM_MSG_BOX_DRAFT, 
                               SRV_UM_SIM_ALL, 
                               VAPP_MSG_FOLDER_TYPE_CONVERSATION));
            insertPage(VAPP_MSG_SCREEN_PAGE_CONVERSATION, pageInsert, VAPP_MSG_SCREEN_PAGE_BOX_LIST);
            switch (m_mode)
            {
                case VAPP_MSG_LAUNCH_NORMAL:
                    closePage(VAPP_MSG_SCREEN_PAGE_BOX_LIST);
                    break;

                case VAPP_MSG_LAUNCH_INBOX:
                case VAPP_MSG_LAUNCH_OUTBOX:
                    closePage(VAPP_MSG_SCREEN_PAGE_FOLDER);
                    break;

                default:
                    VFX_ASSERT(0);
                    break;
            }
        }
    }
    else
    {
        // find box list page
        VfxPage *page;
        switch (m_mode)
        {
            case VAPP_MSG_LAUNCH_NORMAL:
                page = getPage(VAPP_MSG_SCREEN_PAGE_BOX_LIST);
                if (NULL == page)
                {
                    // not find insert it
                    VappMsgBoxListPage *pageInsert;
                    VFX_OBJ_CREATE(pageInsert, VappMsgBoxListPage, this);
                    insertPage(VAPP_MSG_SCREEN_PAGE_BOX_LIST, pageInsert, VAPP_MSG_SCREEN_PAGE_CONVERSATION);
                    closePage(VAPP_MSG_SCREEN_PAGE_CONVERSATION);
                }
                break;

            case VAPP_MSG_LAUNCH_INBOX:
                page = getPage(VAPP_MSG_SCREEN_PAGE_FOLDER);
                if (NULL == page)
                {
                    // not find insert it
                    VappMsgFolderPage *pageInsert;
                    VFX_OBJ_CREATE(pageInsert, VappMsgFolderPage, this);
                    insertPage(VAPP_MSG_SCREEN_PAGE_FOLDER, pageInsert, VAPP_MSG_SCREEN_PAGE_CONVERSATION);
                    closePage(VAPP_MSG_SCREEN_PAGE_CONVERSATION);
                }
                break;

            case VAPP_MSG_LAUNCH_OUTBOX:
                page = getPage(VAPP_MSG_SCREEN_PAGE_FOLDER);
                if (NULL == page)
                {
                    // not find insert it
                    VappMsgFolderPage *pageInsert;
                    VFX_OBJ_CREATE_EX(pageInsert, 
                                      VappMsgFolderPage, 
                                      this, 
                                      (SRV_UM_MSG_ALL, 
                                       SRV_UM_MSG_BOX_UNSENT));
                    insertPage(VAPP_MSG_SCREEN_PAGE_FOLDER, pageInsert, VAPP_MSG_SCREEN_PAGE_CONVERSATION);
                    closePage(VAPP_MSG_SCREEN_PAGE_CONVERSATION);
                }
                break;

            default:
                VFX_ASSERT(0);
                break;
        }
    }
#endif /* !__MMI_SNS_MESSAGES__ */
}
#endif  /* __MMI_UM_BOX_LIST_SUPPORT__ */ 

VfxBool VappMsgScreen::checkIsEntered()
{
    return m_isEntered;
}

#ifdef __MMI_SNS_MESSAGES__
VFX_IMPLEMENT_CLASS("VappMsgTabPage", VappMsgTabPage, VcpTabCtrlPage);

VappMsgTabPage::VappMsgTabPage(VappMsgLaunchMode mode):
    m_mode(mode)
{
}

void VappMsgTabPage::onInit()
{
    VcpTabCtrlPage::onInit();

    addTab(VAPP_MSG_TAB_NATIVE, STR_ID_VAPP_MSG_LOCAL, VcpStateImage(IMG_ID_VAPP_MSG_TAB_LOCAL));
    addTab(VAPP_MSG_TAB_SNS, STR_ID_VAPP_MSG_SNS, VcpStateImage(IMG_ID_VAPP_MSG_TAB_SNS));

    if (VAPP_MSG_LAUNCH_SNS == m_mode)
    {
        setCurrTab(VAPP_MSG_TAB_SNS);
    }
    else
    {
        setCurrTab(VAPP_MSG_TAB_NATIVE);
    }
}

void VappMsgTabPage::onUpdate()
{
	VcpTabCtrlPage::onUpdate();
	VfxPage *msgTabPage = getTabPage(getCurrTab());

	if (msgTabPage)
	{
		msgTabPage->checkUpdate();
	}	
}

VfxPage *VappMsgTabPage::onCreateTabPage(VfxId tabId)
{
    /* SNS page */
    if (VAPP_MSG_TAB_SNS == tabId)
    {
        VappSnsMsgMainPage *snsPage;
        VFX_OBJ_CREATE(snsPage, VappSnsMsgMainPage, this);

        return snsPage;
    }

    /* Natvie message page */
    VfxU8 select = 0;
    VfxS16 error;
#ifdef __MMI_UM_CONVERSATION_BOX__
    ReadValue(NVRAM_VAPP_MESSAGE_CS_SETTING, &select, DS_BYTE, &error);
#endif /* __MMI_UM_CONVERSATION_BOX__ */

    VfxPage *nativePage = NULL;
    switch (m_mode)
    {
        case VAPP_MSG_LAUNCH_NORMAL:        
        case VAPP_MSG_LAUNCH_SNS:
        case VAPP_MSG_LAUNCH_INBOX:
        case VAPP_MSG_LAUNCH_OUTBOX:
            #ifdef __MMI_UM_BOX_LIST_SUPPORT__
            if (1 == select)
            {
            #endif /* __MMI_UM_BOX_LIST_SUPPORT__ */
                VappMsgFolderPage *page;
                VFX_OBJ_CREATE_EX(page, 
                                  VappMsgFolderPage, 
                                  this, 
                                  (SRV_UM_MSG_ALL, 
                                   SRV_UM_MSG_BOX_INBOX | SRV_UM_MSG_BOX_SENT | SRV_UM_MSG_BOX_UNSENT | SRV_UM_MSG_BOX_DRAFT, 
                                   SRV_UM_SIM_ALL, 
                                   VAPP_MSG_FOLDER_TYPE_CONVERSATION, 
                                   VAPP_MSG_FOLDER_MODE_NORMAL, 
                                   VFX_FALSE));
                nativePage = page;
            #ifdef __MMI_UM_BOX_LIST_SUPPORT__
            }
            else
            {
                if (VAPP_MSG_LAUNCH_NORMAL == m_mode ||
                    VAPP_MSG_LAUNCH_SNS == m_mode)
                {
                    VappMsgBoxListPage *page;
                    VFX_OBJ_CREATE_EX(page, VappMsgBoxListPage, this, (VFX_FALSE));
                    nativePage = page;
                }                
                else
                {
                    VFX_ASSERT(0);
                }
            }
            #endif /* __MMI_UM_BOX_LIST_SUPPORT__ */
            break;

        default:
            VFX_ASSERT(0);
            break;
    }

    return nativePage;
}

void VappMsgTabPage::onQueryRotateEx(VfxScreenRotateParam &param)
{
    // do Nothing
}


#endif /* __MMI_SNS_MESSAGES__ */

#ifdef __MMI_UM_BOX_LIST_SUPPORT__
VFX_IMPLEMENT_CLASS("VappMsgBoxListPage", VappMsgBoxListPage, VfxPage);

VappMsgBoxListPage::VappMsgBoxListPage(VfxBool isNeedTitle):
    m_listMenu(NULL), 
    m_isRequest(VFX_FALSE), 
    m_msgDataProvider(NULL),
    m_isNeedReset(VFX_TRUE),
    m_isEntered(VFX_FALSE),
    m_isNeedTitle(isNeedTitle)
{
    vfx_sys_mem_zero(&m_msgNumber, sizeof(srv_um_get_msg_num_result));
}

void VappMsgBoxListPage::onInit()
{
    MMI_PRINT(MOD_MMI_COMMON_APP, TRACE_GROUP_6, "%s", this->getClassInfo()->getClassName());
    MMI_TRACE(TRACE_GROUP_6, TRC_MMI_VAPP_MSG_ON_INIT, this);
    VfxPage::onInit();

    if (VFX_TRUE == m_isNeedTitle)
    {
        VcpTitleBar *title;
        VFX_OBJ_CREATE(title, VcpTitleBar, this);
        title->setAutoAnimate(VFX_TRUE);
        title->setTitle(STR_ID_VAPP_MSG);
        setTopBar(title);
    }

    VFX_OBJ_CREATE(m_listMenu, VcpListMenu, this);
    m_listMenu->setAutoAnimate(VFX_TRUE);
    m_listMenu->setContentProvider(this);
    m_listMenu->setCellStyle(VCP_LIST_MENU_CELL_STYLE_ICON_SINGLE_TEXT);
    m_listMenu->setSize(getSize());
    m_listMenu->setAlignParent(
                    VFX_FRAME_ALIGNER_MODE_SIDE, 
                    VFX_FRAME_ALIGNER_MODE_SIDE, 
                    VFX_FRAME_ALIGNER_MODE_SIDE, 
                    VFX_FRAME_ALIGNER_MODE_SIDE);
    m_listMenu->m_signalItemTapped.connect(this, &VappMsgBoxListPage::onItemTapped);

    VcpToolBar *toolBar;
    VFX_OBJ_CREATE(toolBar, VcpToolBar, this);
    toolBar->addItem(VAPP_MSG_BOX_LIST_TOOLBAR_NEW_MSG, STR_ID_VAPP_MSG_NEW_MSG, IMG_ID_VAPP_MSG_TB_NEW_MSG);
    toolBar->addItem(VAPP_MSG_BOX_LIST_TOOLBAR_SIM_MSG, STR_ID_VAPP_MSG_SIM_MSG, IMG_ID_VAPP_MSG_TB_SIM_MSG);
    if (0 == srv_sim_ctrl_get_num_of_inserted())
    {
        toolBar->setDisableItem(VAPP_MSG_BOX_LIST_TOOLBAR_SIM_MSG, VFX_TRUE);
    }
    toolBar->addItem(VAPP_MSG_BOX_LIST_TOOLBAR_SETTING, VCP_STR_TOOL_BAR_SETTINGS, VCP_IMG_TOOL_BAR_COMMON_ITEM_SETTING);
    toolBar->m_signalButtonTap.connect(this, &VappMsgBoxListPage::onToolbarClick);
    setBottomBar(toolBar);

    srv_um_get_msg_num_result result;
    vfx_sys_mem_zero(&result, sizeof(srv_um_get_msg_num_result));
    VFX_OBJ_CREATE(m_msgDataProvider, VappMsgDataProvider, this);
    m_msgDataProvider->m_signalGetMsgNumFinished.connect(this, &VappMsgBoxListPage::onGetMsgNumFinished);
//    m_msgDataProvider->getMsgNum(SRV_UM_MSG_ALL, result);
//    m_isRequest = VFX_TRUE;

    mmi_frm_cb_reg_event(EVT_ID_SRV_UM_NOTIFY_READY, &VappMsgBoxListPage::onMsgSrvEvtCb, getObjHandle());
    mmi_frm_cb_reg_event(EVT_ID_SRV_UM_NOTIFY_REFRESH, &VappMsgBoxListPage::onMsgSrvEvtCb, getObjHandle());
}

void VappMsgBoxListPage::onDeinit()
{
    mmi_frm_cb_dereg_event(EVT_ID_SRV_UM_NOTIFY_READY, &VappMsgBoxListPage::onMsgSrvEvtCb, getObjHandle());
    mmi_frm_cb_dereg_event(EVT_ID_SRV_UM_NOTIFY_REFRESH, &VappMsgBoxListPage::onMsgSrvEvtCb, getObjHandle());

    VfxPage::onDeinit();
}

void VappMsgBoxListPage::onUpdate()
{
    VfxPage::onUpdate();
    
    /* not active, return */
    if (VFX_FALSE == isActive() || 
        VFX_FALSE == getApp()->isActive() ||
        VFX_FALSE == ((VappMsgScreen*)getMainScr())->checkIsEntered() ||            
        VFX_FALSE == m_isEntered)
    {
        return;
    }
    
    srv_um_get_msg_num_result result;
    m_msgDataProvider->getMsgNum(SRV_UM_MSG_ALL, result);
    m_isRequest = VFX_TRUE;
}
void VappMsgBoxListPage::onEntered()
{
    VfxPage::onEntered();

    m_isEntered = VFX_TRUE;
    checkUpdate();
}

void VappMsgBoxListPage::onQueryRotateEx(VfxScreenRotateParam &param)
{
    // do Nothing    
}

mmi_ret VappMsgBoxListPage::onProc(mmi_event_struct * evt)
{
    switch (evt->evt_id)
    {
        case EVT_ID_CUI_UC_MSGCOMPOSER_CLOSE:
        {
            cui_msgcomposer_evt_struct *ucEvt = (cui_msgcomposer_evt_struct *)evt;
            /* just close it */
            vcui_unifiedcomposer_close(ucEvt->sender_id);
        }
            break;
    }
    return MMI_RET_OK;
}

void VappMsgBoxListPage::setMenu(VcpListMenu * menu)
{
}

VfxBool VappMsgBoxListPage::getItemText(VfxU32 index, VcpListMenuFieldEnum fieldType, VfxWString & text, VcpListMenuTextColorEnum & color)
{
    if (VCP_LIST_MENU_FIELD_TEXT != fieldType)
    {
        return VFX_FALSE;
    }

    VfxWString name;
    switch (index)
    {
        case VAPP_MSG_BOX_LIST_INBOX:
            name.loadFromRes(STR_GLOBAL_INBOX);
            break;

        case VAPP_MSG_BOX_LIST_SENT:
            name.loadFromRes(STR_ID_VAPP_MSG_SENTBOX);
            break;

        case VAPP_MSG_BOX_LIST_OUTBOX:
            name.loadFromRes(STR_GLOBAL_OUTBOX);
            break;

        case VAPP_MSG_BOX_LIST_DRAFT:
            name.loadFromRes(STR_GLOBAL_DRAFTS);
            break;

    #ifdef __UNIFIED_MESSAGE_ARCHIVE_SUPPORT__
        case VAPP_MSG_BOX_LIST_ARCHIVE:
            name.loadFromRes(STR_ID_VAPP_MSG_ARCHIVE);
            break;
    #endif /* __UNIFIED_MESSAGE_ARCHIVE_SUPPORT__ */

        default:
            break;
    }

    VfxWString tail;
    if (VFX_TRUE == m_isRequest)
    {
        tail = VFX_WSTR_EMPTY;
    }
    else
    {
        switch (index)
        {
            case VAPP_MSG_BOX_LIST_INBOX:
                tail = VfxWString().format("(%d/%d)", m_msgNumber.inbox_unread_msg_number, m_msgNumber.inbox_msg_number);
                break;

            case VAPP_MSG_BOX_LIST_SENT:
                tail = VfxWString().format("(%d)", m_msgNumber.sent_msg_number);
                break;

            case VAPP_MSG_BOX_LIST_OUTBOX:
                tail = VfxWString().format("(%d)", m_msgNumber.unsent_msg_number);
                break;

            case VAPP_MSG_BOX_LIST_DRAFT:
                tail = VfxWString().format("(%d)", m_msgNumber.draft_msg_number);
                break;
                
        #ifdef __UNIFIED_MESSAGE_ARCHIVE_SUPPORT__
            case VAPP_MSG_BOX_LIST_ARCHIVE:
                tail = VfxWString().format("(%d)", m_msgNumber.archive_msg_number);
                break;
        #endif /* __UNIFIED_MESSAGE_ARCHIVE_SUPPORT__ */

            default:
                break;
        }
    }

    text = name;
    text += tail;

    return VFX_TRUE;
}

VfxBool VappMsgBoxListPage::getItemTextFrameFormat(VfxU32 index, VcpListMenuFieldEnum fieldType, VfxTextFrame * frame)
{
    if (VCP_LIST_MENU_FIELD_TEXT != fieldType)
    {
        return VFX_FALSE;
    }

    if (VFX_FALSE == m_isRequest &&
        VAPP_MSG_BOX_LIST_INBOX == index)
    {
        if (m_msgNumber.inbox_unread_msg_number > 0)
        {
            VfxFontDesc font = frame->getFont();
            font.setAttr(VFX_FONT_DESC_ATTR_BOLD);
            frame->setFont(font);

            return VFX_TRUE;
        }
    }

    return VFX_FALSE;
}

VfxBool VappMsgBoxListPage::getItemImage(VfxU32 index, VcpListMenuFieldEnum fieldType, VfxImageSrc & image)
{
    if (VCP_LIST_MENU_FIELD_ICON != fieldType)
    {
        return VFX_FALSE;
    }

    switch (index)
    {
        case VAPP_MSG_BOX_LIST_INBOX:
            image = VfxImageSrc(IMG_ID_VAPP_MSG_INBOX);
            break;

        case VAPP_MSG_BOX_LIST_SENT:
            image = VfxImageSrc(IMG_ID_VAPP_MSG_SENTBOX);
            break;

        case VAPP_MSG_BOX_LIST_OUTBOX:
            image = VfxImageSrc(IMG_ID_VAPP_MSG_OUTBOX);
            break;

        case VAPP_MSG_BOX_LIST_DRAFT:
            image = VfxImageSrc(IMG_ID_VAPP_MSG_DRAFTS);
            break;

    #ifdef __UNIFIED_MESSAGE_ARCHIVE_SUPPORT__
        case VAPP_MSG_BOX_LIST_ARCHIVE:
            image = VfxImageSrc(IMG_ID_VAPP_MSG_ARCHIVE);
            break;
    #endif /* __UNIFIED_MESSAGE_ARCHIVE_SUPPORT__ */

        default:
            break;
    }

    return VFX_TRUE;
}

VfxU32 VappMsgBoxListPage::getCount() const
{
    if( VFX_FALSE == ((VappMsgScreen*)getMainScr())->checkIsEntered() || VFX_FALSE == m_isEntered )
    {
        return 0;
    }  

    return VAPP_MSG_BOX_LIST_TOTAL_NUM;
}

VcpListMenuItemStateEnum VappMsgBoxListPage::getItemState(VfxU32 index) const
{
    return VCP_LIST_MENU_ITEM_STATE_NONE;
}

void VappMsgBoxListPage::onGetMsgNumFinished(srv_um_get_msg_num_result result)
{
    vfx_sys_mem_copy((void *)&m_msgNumber, (void *)&result, sizeof(srv_um_get_msg_num_result));
    m_isRequest = VFX_FALSE;
    
    if (VFX_TRUE == m_isNeedReset)
    {
        m_listMenu->resetAllItems();
        m_isNeedReset = VFX_FALSE;
    }
    else
    {
        m_listMenu->updateAllItems();
    }
}

void VappMsgBoxListPage::onItemTapped(VcpListMenu * listMenu, VfxU32 index)
{
    VfxU32 boxType = SRV_UM_MSG_BOX_NONE;

    switch (index)
    {
        case VAPP_MSG_BOX_LIST_INBOX:
            boxType = SRV_UM_MSG_BOX_INBOX;
            break;

        case VAPP_MSG_BOX_LIST_SENT:
            boxType = SRV_UM_MSG_BOX_SENT;
            break;

        case VAPP_MSG_BOX_LIST_OUTBOX:
            boxType = SRV_UM_MSG_BOX_UNSENT;
            break;

        case VAPP_MSG_BOX_LIST_DRAFT:
            boxType = SRV_UM_MSG_BOX_DRAFT;
            break;

    #ifdef __UNIFIED_MESSAGE_ARCHIVE_SUPPORT__
        case VAPP_MSG_BOX_LIST_ARCHIVE:
            boxType = SRV_UM_MSG_BOX_ARCHIVE;
            break;
    #endif /* __UNIFIED_MESSAGE_ARCHIVE_SUPPORT__ */

        default:
            break;
    }

#ifdef __MMI_USB_SUPPORT__
    if (boxType == SRV_UM_MSG_BOX_ARCHIVE && MMI_TRUE == srv_usb_is_in_mass_storage_mode())
    {
        vapp_usb_unavailable_popup(0);
    }
    else
#endif /* __MMI_USB_SUPPORT__ */
    {
        VappMsgFolderPage *page;
        VFX_OBJ_CREATE_EX(page, VappMsgFolderPage, getMainScr(), (SRV_UM_MSG_ALL, boxType));
        getMainScr()->pushPage(VappMsgScreen::VAPP_MSG_SCREEN_PAGE_FOLDER, page);
    }
}

void VappMsgBoxListPage::onToolbarClick(VfxObject * obj, VfxId id)
{
    switch (id)
    {
        case VAPP_MSG_BOX_LIST_TOOLBAR_NEW_MSG:
        {
            mmi_id cuiId = GRP_ID_INVALID;
		#ifdef __MMI_UNIFIED_COMPOSER__
            cuiId = vcui_unifiedcomposer_create(getApp()->getGroupId(), NULL);
            if (cuiId != GRP_ID_INVALID)
            {
                vfxSetCuiCallerScr(cuiId, getMainScr());
                vcui_unifiedcomposer_run(cuiId);
            }
        #endif
        #ifdef __MMI_SMS_COMPOSER__
            cuiId = vcui_sms_composer_create(getApp()->getGroupId());
            if (cuiId != GRP_ID_INVALID)
            {
                vfxSetCuiCallerScr(cuiId, getMainScr());
                vcui_sms_composer_run(cuiId);
            }
        #endif
        }
            break;

        case VAPP_MSG_BOX_LIST_TOOLBAR_SIM_MSG:
        #if (MMI_MAX_SIM_NUM >= 2)
            if (2 <= srv_sim_ctrl_get_num_of_inserted())
            {
                /* multiple sims */
                VcpCommandPopup *simCmd;
                VFX_OBJ_CREATE(simCmd, VcpCommandPopup, this);
                simCmd->setText(STR_ID_VAPP_MSG_VIEW_MSG_IN);
                U16 index = 0;
                U16 cmdId = VAPP_MSG_BOX_LIST_SIM_1;
                mmi_sim_enum sim = MMI_SIM1;
                /* Add all sim buttons */
                for (index = 0; index < MMI_MAX_SIM_NUM ; index++, sim = (mmi_sim_enum)(sim << 1), cmdId++)
                {
                    if (MMI_TRUE == srv_sim_ctrl_is_inserted(sim))
                    {
                        simCmd->addItem(cmdId, vapp_sim_settings_get_sim_name_with_sim_id(sim), VCP_POPUP_BUTTON_TYPE_NORMAL);
                    }
                }
                simCmd->addItem(VAPP_MSG_BOX_LIST_SIM_CANCEL, STR_GLOBAL_CANCEL, VCP_POPUP_BUTTON_TYPE_CANCEL);
                simCmd->m_signalButtonClicked.connect(this, &VappMsgBoxListPage::onSimCmdClicked);
                simCmd->show(VFX_TRUE);
            }
            else
        #endif /* MMI_MAX_SIM_NUM >= 2 */
            {
            #if (MMI_MAX_SIM_NUM == 1)
                /* single sim */
                VappMsgFolderPage *page;
                VFX_OBJ_CREATE_EX(page, VappMsgFolderPage, getMainScr(), (SRV_UM_MSG_ALL, SRV_UM_MSG_BOX_SIM, SRV_UM_SIM_ALL));
                getMainScr()->pushPage(VappMsgScreen::VAPP_MSG_SCREEN_PAGE_SIM_MSG, page);
            #else /* MMI_MAX_SIM_NUM == 1 */
                /* check if which one inserted */
                U16 index = 0;
                srv_um_sim_enum umSim = SRV_UM_SIM_GSM_SIM1;
                mmi_sim_enum sim = MMI_SIM1;
                /* Add all sim buttons */
                for (index = 0; index < MMI_MAX_SIM_NUM ; index++, sim = (mmi_sim_enum)(sim << 1), umSim = (srv_um_sim_enum)(umSim << 1))
                {
                    if (MMI_TRUE == srv_sim_ctrl_is_inserted(sim))
                    {
                        break;
                    }
                }
                VappMsgFolderPage *page;
                VFX_OBJ_CREATE_EX(page, VappMsgFolderPage, getMainScr(), (SRV_UM_MSG_ALL, SRV_UM_MSG_BOX_SIM, (VfxU32)umSim));
                getMainScr()->pushPage(VappMsgScreen::VAPP_MSG_SCREEN_PAGE_SIM_MSG, page);
            #endif /* MMI_MAX_SIM_NUM >= 2 */
            }
            break;

        case VAPP_MSG_BOX_LIST_TOOLBAR_SETTING:
        {
            VappMsgSettingPage *page;
            VFX_OBJ_CREATE(page, VappMsgSettingPage, getMainScr());
            getMainScr()->pushPage(VappMsgScreen::VAPP_MSG_SCREEN_PAGE_SETTING, page);
        }
            break;

        default:
            VFX_ASSERT(0);
            break;
    }
}

#if (MMI_MAX_SIM_NUM >= 2)
void VappMsgBoxListPage::onSimCmdClicked(VfxObject * obj, VfxId id)
{
    if (VAPP_MSG_BOX_LIST_SIM_CANCEL == id ||
        VCP_POPUP_BUTTON_NO_PRESSED == id)
    {
        return;
    }

    srv_um_sim_enum sim = SRV_UM_SIM_GSM_SIM1;
    switch (id)
    {
        case VAPP_MSG_BOX_LIST_SIM_2:
            sim = SRV_UM_SIM_GSM_SIM2;
            break;

    #if (MMI_MAX_SIM_NUM >= 3)
        case VAPP_MSG_BOX_LIST_SIM_3:
            sim = SRV_UM_SIM_GSM_SIM3;
            break;
    #endif /* MMI_MAX_SIM_NUM >= 3 */

    #if (MMI_MAX_SIM_NUM >= 4)
        case VAPP_MSG_BOX_LIST_SIM_4:
            sim = SRV_UM_SIM_GSM_SIM4;
            break;
    #endif /* MMI_MAX_SIM_NUM >= 4 */

        default:
            break;
    }

    VappMsgFolderPage *page;
    VFX_OBJ_CREATE_EX(page, VappMsgFolderPage, getMainScr(), (SRV_UM_MSG_ALL, SRV_UM_MSG_BOX_SIM, (VfxU32)sim));
    getMainScr()->pushPage(VappMsgScreen::VAPP_MSG_SCREEN_PAGE_SIM_MSG, page);
}
#endif /* MMI_MAX_SIM_NUM >= 2 */

mmi_ret VappMsgBoxListPage::onMsgSrvEvtCb(mmi_event_struct * param)
{
    VappMsgBoxListPage *self = (VappMsgBoxListPage *)VfxObject::handleToObject((VfxObjHandle)param->user_data);

    if (self)
    {
        MMI_PRINT(MOD_MMI_COMMON_APP, TRACE_GROUP_6, "%s", self->getClassInfo()->getClassName());
        MMI_TRACE(TRACE_GROUP_6, TRC_MMI_VAPP_MSG_UM_SRV_EVT, param->evt_id, self);
        if (self->isKindOf(VFX_OBJ_CLASS_INFO(VappMsgBoxListPage)))
        {
            switch (param->evt_id)
            {
                case EVT_ID_SRV_UM_NOTIFY_READY:
                    break;

                case EVT_ID_SRV_UM_NOTIFY_REFRESH:
                    srv_um_get_msg_num_result result;
                    self->m_msgDataProvider->getMsgNum(SRV_UM_MSG_ALL, result);
                    self->m_isRequest = VFX_TRUE;
                    break;

                default:
                    break;
            }
        }
    }

    return MMI_RET_OK;
}
#endif  /* __MMI_UM_BOX_LIST_SUPPORT__ */ 

VFX_IMPLEMENT_CLASS("VappMsgFolderPage", VappMsgFolderPage, VfxPage);

VappMsgFolderPage::VappMsgFolderPage(VfxU32 msgType, VfxU32 boxType, VfxU32 simType, VappMsgFolderTypeEnum style, VappMsgFolderModeEnum mode, VfxBool isNeedTitle):
    m_title(NULL), 
    m_isTitleValid(VFX_FALSE), 
    m_isNeedTitle(isNeedTitle), 
    m_list(NULL), 
    m_listMenu(NULL), 
    m_toolbar(NULL), 
    m_loading(NULL), 
    m_style(style), 
    m_enterIndex(0), 
    m_isStartEnter(VFX_FALSE), 
    m_isSetNewMode(VFX_FALSE), 
    m_mode(mode), 
    m_msOpAction(SRV_UM_MARK_SEVERAL_OP_ACTION_NONE), 
    m_msProcessLoading(NULL), 
    m_msProcessTimer(NULL), 
    m_isBlockUpdate(VFX_FALSE), 
    m_isNeedReset(VFX_TRUE), 
    m_isNeedUpdate(VFX_FALSE), 
    m_contextMenu(NULL), 
    m_confirmPopup(NULL), 
    m_actionPtr(NULL),
    m_isEntered(VFX_FALSE), //performance
    m_isInMsgApp(VFX_TRUE),  //performance
    m_isExited(VFX_FALSE),
    m_isNotification(VFX_FALSE)
{
    if (VAPP_MSG_FOLDER_TYPE_LITE == style)
    {
        m_boxId.msg_type = SRV_UM_MSG_SMS;
    }
    else
    {
        m_boxId.msg_type = (srv_um_msg_enum) msgType;
    }
    m_boxId.msg_box_type = (srv_um_msg_box_enum) boxType;
    m_boxId.sim_id = (srv_um_sim_enum) simType;

    m_listFilter.idx_type = SRV_UM_LIST_IDX_TIMESTAMP;
    m_listFilter.order = SRV_UM_SORT_ORDER_UNCLASSIFIED;

    m_msgCopyFilter.msg_box = SRV_UM_MSG_BOX_NONE;
    m_msgCopyFilter.msg_type = SRV_UM_MSG_NONE;
    m_msgCopyFilter.msg_storage = VAPP_MSG_STORAGE_NONE;
    
#ifdef __MMI_UM_CONVERSATION_BOX__
    vfx_sys_mem_zero(&m_listFilter.thread_id, sizeof(srv_um_thread_id_struct));
#endif /* __MMI_UM_CONVERSATION_BOX__ */
}

void VappMsgFolderPage::setMode(VappMsgFolderModeEnum newMode)
{
    if (m_mode != newMode &&
        newMode < VAPP_MSG_FOLDER_MODE_END)
    {
        m_mode = newMode;
        m_isSetNewMode = VFX_TRUE;
        checkUpdate();
    }
}

void VappMsgFolderPage::onInit()
{
    MMI_PRINT(MOD_MMI_COMMON_APP, TRACE_GROUP_6, "%s", this->getClassInfo()->getClassName());
    MMI_TRACE(TRACE_GROUP_6, TRC_MMI_VAPP_MSG_ON_INIT, this);
    VfxPage::onInit();

    // Title
    if (VFX_TRUE == m_isNeedTitle)
    {
        VFX_OBJ_CREATE(m_title, VcpTitleBar, this);
        m_title->setTitleStyle(VCP_TITLE_BAR_STYLE_BASE);
        m_title->setAutoAnimate(VFX_TRUE);
        setTitle(0, 0, m_isTitleValid);
        setTopBar(m_title);
    }

    // Body
    VFX_OBJ_CREATE(m_listMenu, VcpListMenu, this);
    m_listMenu->setAutoAnimate(VFX_TRUE);
    m_listMenu->setContentProvider(this);
    m_listMenu->setPos(0, 0);
    m_listMenu->setSize(getSize());
    m_listMenu->setAlignParent(
                        VFX_FRAME_ALIGNER_MODE_SIDE, 
                        VFX_FRAME_ALIGNER_MODE_SIDE, 
                        VFX_FRAME_ALIGNER_MODE_SIDE, 
                        VFX_FRAME_ALIGNER_MODE_SIDE);

    if ((SRV_UM_MSG_BOX_PREDEF_TEMPLATES | SRV_UM_MSG_BOX_USRDEF_TEMPLATES) == m_boxId.msg_box_type)
    {
        /* teamplte only have text */
        m_listMenu->setCellStyle(VCP_LIST_MENU_CELL_STYLE_SINGLE_TEXT);
    }
    else
    {
    #if (MMI_MAX_SIM_NUM == 1)
        m_listMenu->setCellStyle(VCP_LIST_MENU_CELL_STYLE_TRIPLE_TEXT_EX);
    #else
        if (SRV_UM_MSG_BOX_SIM != m_boxId.msg_box_type)
        {
            m_listMenu->setCellStyle(VCP_LIST_MENU_CELL_STYLE_ICON_TRIPLE_TEXT_EX);
        }
        else
        {
            /* SIM messages, no need to show any icon */
            m_listMenu->setCellStyle(VCP_LIST_MENU_CELL_STYLE_TRIPLE_TEXT_EX);
        }
    #endif /* MMI_MAX_SIM_NUM */
    }
    m_listMenu->m_signalItemTapped.connect(this, &VappMsgFolderPage::onListItemTapped);
    m_listMenu->m_signalItemSelectionStateChanged.connect(this, &VappMsgFolderPage::onListItemSelected);
    m_listMenu->m_signalItemLongTapped.connect(this, &VappMsgFolderPage::onListItemLongPressed);
    VFX_OBJ_CREATE_EX(m_list, VappMessageList, this, (m_boxId.msg_type, m_boxId.msg_box_type, m_boxId.sim_id));
    if (VAPP_MSG_FOLDER_TYPE_CONVERSATION == m_style)
    {
        m_list->setStyle(VAPP_MESSAGE_LIST_STYLE_THREAD);
        //TODO: Need a QUINTUPLE_TEXT with no icon
        //m_listMenu->setCellStyle(VCP_LIST_MENU_CELL_STYLE_ICON_QUINTUPLE_TEXT);
    }
    m_list->m_signalListUpdated.connect(this, &VappMsgFolderPage::onMsgListUpdated);
    m_list->m_signalSingleMsgUpdated.connect(this, &VappMsgFolderPage::onSingleMsgUpdated);
    m_list->m_signalOperationResult.connect(this, &VappMsgFolderPage::onMsOpResult);

    // Toolbar
    if (SRV_UM_MSG_BOX_UNSENT != m_boxId.msg_box_type)
    {
        createToolbar(m_style, m_mode);
        //updateToolbar(m_style, m_mode);
    }

    // loading
    VFX_OBJ_CREATE(m_loading, VcpActivityIndicator, this);
    m_loading->setAutoAnimate(VFX_TRUE);
    m_loading->setHiddenWhenStopped(VFX_TRUE);
    m_loading->setPos(getSize().width/2 - m_loading->getSize().width/2, getSize().height/2 - m_loading->getSize().height/2);
    m_loading->setAlignParent(
                        VFX_FRAME_ALIGNER_MODE_MID, 
                        VFX_FRAME_ALIGNER_MODE_MID, 
                        VFX_FRAME_ALIGNER_MODE_MID, 
                        VFX_FRAME_ALIGNER_MODE_MID);

    /* get the list first and set the title */
    if (VFX_TRUE == m_list->checkMsgList())
    {
        // update title with number
        m_isTitleValid = VFX_TRUE;
        setTitle(m_list->getCount(), getUnreadCount(), m_isTitleValid);
    }

    VFX_OBJ_CREATE(m_msProcessLoading, VcpIndicatorPopup, this);
    m_msProcessLoading->setAutoAnimate(VFX_TRUE);
    m_msProcessLoading->setText(VFX_WSTR_EMPTY);
    m_msProcessLoading->setAutoDestory(VFX_FALSE);
    m_msProcessLoading->m_signalCanceled.connect(this, &VappMsgFolderPage::onMsOpCancelled);

    VFX_OBJ_CREATE(m_msProcessTimer, VfxTimer, this);
    m_msProcessTimer->setDuration(VAPP_MSG_MS_TIMER_PERIOD);
    m_msProcessTimer->m_signalTick.connect(this, &VappMsgFolderPage::onMsProgressTimeout);

    if (VAPP_MSG > getApp()->getGroupId() || mmi_res_get_app_max(VAPP_MSG) < getApp()->getGroupId())
    {
        /* message folder page is created by other app*/    
        m_isInMsgApp = VFX_FALSE;
    }

    mmi_frm_cb_reg_event(EVT_ID_PHB_ADD_CONTACT, &VappMsgFolderPage::onPhbSrvEvt, getObjHandle());
    mmi_frm_cb_reg_event(EVT_ID_PHB_UPD_CONTACT, &VappMsgFolderPage::onPhbSrvEvt, getObjHandle());
    mmi_frm_cb_reg_event(EVT_ID_PHB_DEL_CONTACT, &VappMsgFolderPage::onPhbSrvEvt, getObjHandle());
#ifdef __MMI_USB_SUPPORT__
    mmi_frm_cb_reg_event(EVT_ID_USB_ENTER_MS_MODE, &VappMsgFolderPage::onMsModeEvt, getObjHandle());
#endif /* __MMI_USB_SUPPORT__ */
}

void VappMsgFolderPage::onDeinit()
{
    mmi_frm_cb_dereg_event(EVT_ID_PHB_ADD_CONTACT, &VappMsgFolderPage::onPhbSrvEvt, getObjHandle());
    mmi_frm_cb_dereg_event(EVT_ID_PHB_UPD_CONTACT, &VappMsgFolderPage::onPhbSrvEvt, getObjHandle());
    mmi_frm_cb_dereg_event(EVT_ID_PHB_DEL_CONTACT, &VappMsgFolderPage::onPhbSrvEvt, getObjHandle());
#ifdef __MMI_USB_SUPPORT__
    mmi_frm_cb_dereg_event(EVT_ID_USB_ENTER_MS_MODE, &VappMsgFolderPage::onMsModeEvt, getObjHandle());
#endif /* __MMI_USB_SUPPORT__ */

    VFX_DEV_ASSERT(NULL == m_actionPtr);

    VfxPage::onDeinit();
}

void VappMsgFolderPage::onUpdate()
{
    MMI_PRINT(MOD_MMI_COMMON_APP, TRACE_GROUP_6, "%s", this->getClassInfo()->getClassName());
    MMI_TRACE(TRACE_GROUP_6, TRC_MMI_VAPP_MSG_ON_UPDATE, this);
    VfxPage::onUpdate();

    /***********************************************************************
     * for ms / long presss feature, also use the same loading to process.
     * we need to block the onUpdate if we receive any checkUpdate
     **********************************************************************/
    if (VFX_TRUE == m_isBlockUpdate)
    {
        return;
    }

    // check if start to enter next page
    if (VFX_TRUE == m_isStartEnter)
    {
        // get the detail info of tapped item
        srv_um_msg_info_struct *msgInfo = NULL;
        srv_um_thread_info_struct *threadInfo = NULL;
        VfxBool result = VFX_FALSE;
        srv_um_msg_info_struct tempMsgInfor;
        srv_um_thread_info_struct tempThreadInfo;

        result = m_list->getMsgInfo(m_enterIndex, msgInfo, threadInfo);

        if (VFX_TRUE == result)
        {
            memcpy( &tempMsgInfor, msgInfo, sizeof(srv_um_msg_info_struct));
            msgInfo = &tempMsgInfor;
            memcpy( &tempThreadInfo, threadInfo, sizeof(srv_um_thread_info_struct));
            threadInfo = &tempThreadInfo;

        #ifdef __MMI_UM_CONVERSATION_BOX__
            if (VAPP_MSG_FOLDER_TYPE_CONVERSATION == m_style)
            {
                VappMsgDialogPage *page;
                VFX_OBJ_CREATE_EX(page, VappMsgDialogPage, getMainScr(), (m_boxId.msg_type, m_boxId.msg_box_type, m_boxId.sim_id));
                if (msgInfo->address_number == 1)
                {
                #if (MMI_MAX_SIM_NUM >= 2)
                    page->setAddress(
                            VFX_WSTR_MEM(msgInfo->address), 
                            msgInfo->address_type, 
                            msgInfo->sim_id, 
                            threadInfo->thread_id, 
                            0, 
                            SRV_UM_MSG_NONE, 
                            VFX_FALSE);
                #else
                    page->setAddress(
                            VFX_WSTR_MEM(msgInfo->address), 
                            msgInfo->address_type, 
                            SRV_UM_SIM_GSM_SIM1, 
                            threadInfo->thread_id, 
                            0, 
                            SRV_UM_MSG_NONE, 
                            VFX_FALSE);
                #endif /* MMI_MAX_SIM_NUM */
                }
                else
                {
                    page->setAddress(
                            VFX_WSTR_EMPTY, 
                            SRV_UM_ADDR_EMPTY, 
                        #if (MMI_MAX_SIM_NUM >= 2)
                            msgInfo->sim_id, 
                        #else
                            SRV_UM_SIM_GSM_SIM1, 
                        #endif /* MMI_MAX_SIM_NUM */
                            threadInfo->thread_id, 
                            threadInfo->list_head.msg_id, 
                            threadInfo->list_head.msg_type, 
                            VFX_TRUE);
                }
                getMainScr()->pushPage(VappMsgScreen::VAPP_MSG_SCREEN_PAGE_DIALOG_LIST, page);
            }
        #endif /* __MMI_UM_CONVERSATION_BOX__ */
            m_enterIndex = 0;
            m_isStartEnter = VFX_FALSE;
            /* unlock all cps */
            m_listMenu->setIsUnhittable(VFX_FALSE);
            if (NULL != m_toolbar)
            {
                m_toolbar->setIsUnhittable(VFX_FALSE);
            }
        }
    }
    else
    {
        /* not active, return */
        if (VFX_FALSE == isActive() || 
            VFX_FALSE == getApp()->isActive() ||
            (VFX_TRUE == m_isInMsgApp && VFX_FALSE == ((VappMsgScreen*)getMainScr())->checkIsEntered() ) ||            
            VFX_FALSE == m_isEntered ||
            VFX_TRUE == m_isExited)
        {
            return;
        }

        // check the list status */
        if (VFX_FALSE == m_list->checkMsgList())
        {
            showLoading();
            m_isTitleValid = VFX_FALSE;
            setTitle(m_list->getCount(), getUnreadCount(), m_isTitleValid);
            m_isNeedReset = VFX_TRUE;
        }
        else
        {
            stopLoading();
            // check the mode and re-layout the page
            if (VFX_TRUE == m_isSetNewMode)
            {
                modeChange();
                updateToolbar(m_style, m_mode);
                m_isSetNewMode = VFX_FALSE;
            }
            /* update title if necessary */
            if (VFX_FALSE == m_isTitleValid)
            {
                // update title with number
                m_isTitleValid = VFX_TRUE;
                setTitle(m_list->getCount(), getUnreadCount(), m_isTitleValid);
            }
            if (VFX_TRUE == m_isNeedReset)
            {
                /* reset all items */
                m_listMenu->resetAllItems(VFX_TRUE);
                m_isNeedReset = VFX_FALSE;
            }
            else if (VFX_TRUE == m_isNeedUpdate)
            {
                /* update all items */
                m_listMenu->updateAllItems();
                m_isNeedUpdate = VFX_FALSE;
            }
            /* update toolbar */
            if (0 == m_list->getCount())
            {
                /* 0 message inside, disable all actions */
                enableToolbar(m_style, m_mode, VFX_FALSE);
            }
            else
            {
                enableToolbar(m_style, m_mode, VFX_TRUE);
            }
        }
    }
}

void VappMsgFolderPage::onExited()
{
    VfxPage::onExited();
    m_isExited = VFX_TRUE;
}

void VappMsgFolderPage::onEntered()
{
    VfxPage::onEntered();

    if (NULL != m_list && VFX_FALSE == m_list->checkMsgList())
    {
        m_listMenu->resetAllItems(VFX_TRUE);
    }
    m_isEntered = VFX_TRUE;
    m_isExited = VFX_FALSE;
    checkUpdate();
}

void VappMsgFolderPage::onBack()
{
    if (VAPP_MSG_FOLDER_MODE_MS == m_mode)
    {
        m_msOpAction = SRV_UM_MARK_SEVERAL_OP_ACTION_NONE;
        m_msgCopyFilter.msg_type = SRV_UM_MSG_NONE;
        m_msgCopyFilter.msg_box = SRV_UM_MSG_BOX_NONE;
        m_msgCopyFilter.msg_storage = VAPP_MSG_STORAGE_NONE;
        setMode(VAPP_MSG_FOLDER_MODE_NORMAL);
    }
    else
    {
        VfxPage::onBack();
    }
}

void VappMsgFolderPage::onQueryRotateEx(VfxScreenRotateParam &param)
{
    // do Nothing    
}

mmi_ret VappMsgFolderPage::onProc(mmi_event_struct * evt)
{
    switch (evt->evt_id)
    {    
    #ifdef __MMI_UNIFIED_COMPOSER__
        case EVT_ID_CUI_UC_MSGCOMPOSER_CLOSE:
        {
            cui_msgcomposer_evt_struct *ucEvt = (cui_msgcomposer_evt_struct *)evt;
            /* just close it */
            vcui_unifiedcomposer_close(ucEvt->sender_id);
            break; 
        }
    #endif 
    #ifdef __MMI_SMS_COMPOSER__
        case EVT_ID_CUI_SMS_COMPOSER_CLOSE:
        {
            VcuiSmsComposerEventStruct *ucEvt = (VcuiSmsComposerEventStruct*)evt;
            vcui_sms_composer_close(ucEvt->sender_id);
            break;
        }
    #endif
    }
    return MMI_RET_OK;
}

void VappMsgFolderPage::setMenu(VcpListMenu *listMenu)
{
    return;
}

VfxBool VappMsgFolderPage::getItemText(
                VfxU32 index,
                VcpListMenuFieldEnum fieldType,
                VfxWString &text, 
                VcpListMenuTextColorEnum &color)
{
    VFX_ASSERT(NULL != m_list);

    srv_um_msg_info_struct *msgInfo = NULL;
    srv_um_thread_info_struct *threadInfo = NULL;
    VfxBool result = VFX_FALSE;

    if (VAPP_MSG_FOLDER_TYPE_NORMAL == m_style || 
        VAPP_MSG_FOLDER_TYPE_LITE == m_style)
    {
        result = m_list->getMsgInfo(index, msgInfo);
    }
    else
    {
        result = m_list->getMsgInfo(index, msgInfo, threadInfo);
    }

    
    if (VFX_TRUE == result)
    {
        // Fill data
        switch (fieldType)
        {
            case VCP_LIST_MENU_FIELD_TEXT:
            {
                if ((SRV_UM_MSG_BOX_PREDEF_TEMPLATES | SRV_UM_MSG_BOX_USRDEF_TEMPLATES) == m_boxId.msg_box_type)
                {
                    if (0 == vfx_sys_wcslen((VfxWChar *)msgInfo->subject))
                    {
                        if (SRV_UM_MSG_SMS == m_boxId.msg_type)
                        {
                            text.loadFromRes(STR_ID_VAPP_MSG_NO_CONTENT);
                        }
                        else
                        {
                            text.loadFromRes(STR_ID_VAPP_MSG_NO_SUBJECT);
                        }
                    }
                    else
                    {
                        /* template, show content */
                        text.loadFromMem(msgInfo->subject);
                    }
                }
                else
                {
                    if (0 != msgInfo->address_length)
                    {
                        text = transfer2PhbName(msgInfo);
                        if (VAPP_MSG_FOLDER_TYPE_CONVERSATION == m_style)
                        {
                            VfxWString tmpAddr;
                            if (threadInfo->unread_msg_number > 0)
                            {
                                text += VfxWString().format(" (%d)", threadInfo->unread_msg_number);
                            }
                        }
                    }
                    else
                    {
                        text.loadFromRes(STR_GLOBAL_NO_NUMBER);
                    }
                }
            }
                break;

            case VCP_LIST_MENU_FIELD_SUB_TEXT1:
                if (0 == vfx_sys_wcslen((VfxWChar *)msgInfo->subject))
                {
                    if (VAPP_MSG_FOLDER_TYPE_NORMAL == m_style || 
                        VAPP_MSG_FOLDER_TYPE_LITE == m_style)
                    {
                        if (SRV_UM_MSG_SMS == m_list->getMsgType(index)) 
                        {
                            text.loadFromRes(STR_ID_VAPP_MSG_NO_CONTENT);
                        }
                        else
                        {
                            text.loadFromRes(STR_ID_VAPP_MSG_NO_SUBJECT);
                        }
                    }
                    else
                    {
                        if (SRV_UM_MSG_SMS == threadInfo->list_head.msg_type)
                        {
                            text.loadFromRes(STR_ID_VAPP_MSG_NO_CONTENT);
                        }
                        else
                        {
                            text.loadFromRes(STR_ID_VAPP_MSG_NO_SUBJECT);
                        }
                    }
                }
                else
                {
                    text.loadFromMem(msgInfo->subject);
                }
                break;

            case VCP_LIST_MENU_FIELD_SUB_TEXT2:
            {
                VfxU32 localSec = 0;
                applib_time_struct dateTime;

                vfx_sys_mem_zero(&dateTime, sizeof(applib_time_struct));
                localSec = applib_dt_sec_utc_to_local(msgInfo->timestamp);
                mmi_dt_utc_sec_2_mytime(localSec, &dateTime, MMI_FALSE);

                VfxDateTime time;
                time.setDateTime(&dateTime);
                text = time.getDateTimeString(VFX_DATE_TIME_FORMAT_AUTO_DETECT_DATE_DISPLAY);
            }
                break;

            default:
                break;
        }
    }
    else
    {
        return VFX_FALSE;
    }

    return VFX_TRUE;
}

VfxBool VappMsgFolderPage::getItemTextFrameFormat(
                VfxU32 index, 
                VcpListMenuFieldEnum fieldType, 
                VfxTextFrame *frame)
{
    VFX_ASSERT(NULL != m_list);

    // Fill data
    switch (fieldType)
    {
        case VCP_LIST_MENU_FIELD_TEXT:
            if (VAPP_MSG_FOLDER_TYPE_NORMAL == m_style ||
                VAPP_MSG_FOLDER_TYPE_LITE == m_style)
            {
                if (VFX_FALSE == getReadStatus(m_list->getMsgId(index), m_list->getMsgType(index)))
                {
                    /* Unread, bold it */
                    VfxFontDesc font;
                    font = frame->getFont();
                    font.setAttr(VFX_FONT_DESC_ATTR_BOLD);
                    frame->setFont(font);
                    if (m_listMenu->getFocusItemIndex() != index)
                    {
                        frame->setColor(VFX_COLOR_RES(CLR_ID_VAPP_MSG_UNREAD_MSG));
                    }
 
                    return VFX_TRUE;
                }
            }
            else if (VAPP_MSG_FOLDER_TYPE_CONVERSATION == m_style)
            {
                srv_um_msg_info_struct *msgInfo = NULL;
                srv_um_thread_info_struct *threadInfo = NULL;
                VfxBool result = VFX_FALSE;

                result = m_list->getMsgInfo(index, msgInfo, threadInfo);
                if (VFX_TRUE == result &&
                    threadInfo->unread_msg_number > 0)
                {
                    /* Unread, bold it */
                    VfxFontDesc font;
                    font = frame->getFont();
                    font.setAttr(VFX_FONT_DESC_ATTR_BOLD);
                    frame->setFont(font);
                    if (m_listMenu->getFocusItemIndex() != index)
                    {
                        frame->setColor(VFX_COLOR_RES(CLR_ID_VAPP_MSG_UNREAD_MSG));
                    }
 
                    return VFX_TRUE;
                }
             }
            break;

        default:
            break;
    }

    return VFX_FALSE;
}

VfxBool VappMsgFolderPage::getItemImage(
                VfxU32 index, 
                VcpListMenuFieldEnum fieldType, 
                VfxImageSrc &image)
{
    VFX_ASSERT(NULL != m_list);

    srv_um_msg_info_struct *msgInfo = NULL;
    
    if (VFX_TRUE == m_list->getMsgInfo(index, msgInfo))
    {
        // Fill data
        switch (fieldType)
        {
            case VCP_LIST_MENU_FIELD_ICON:
            #if (MMI_MAX_SIM_NUM >= 2)
                if (SRV_UM_SIM_GSM_SIM1 == msgInfo->sim_id)
                {
                    image = VfxImageSrc(IMG_COSMOS_SIM1);
                }
                else if (SRV_UM_SIM_GSM_SIM2 == msgInfo->sim_id)
                {
                    image = VfxImageSrc(IMG_COSMOS_SIM2);
                }
            #if (MMI_MAX_SIM_NUM >= 3)
                else if (SRV_UM_SIM_GSM_SIM3 == msgInfo->sim_id)
                {
                    image = VfxImageSrc(IMG_COSMOS_SIM3);
                }
            #endif /* MMI_MAX_SIM_NUM >= 3 */
            #if (MMI_MAX_SIM_NUM >= 4)
                else if (SRV_UM_SIM_GSM_SIM4 == msgInfo->sim_id)
                {
                    image = VfxImageSrc(IMG_COSMOS_SIM4);
                }
            #endif /* MMI_MAX_SIM_NUM >= 4 */
            #else
                image = VfxImageSrc(IMG_COSMOS_SIM1);
            #endif /* MMI_MAX_SIM_NUM */
                break;

            case VCP_LIST_MENU_FIELD_ICON_EXTRA1:
                break;

            case VCP_LIST_MENU_FIELD_ICON_EXTRA2:
            {
                VfxU32 icon = 0;
                if (VAPP_MSG_FOLDER_TYPE_NORMAL == m_style ||
                    VAPP_MSG_FOLDER_TYPE_LITE == m_style)
                {
                    icon = getMsgTypeIcon(m_list->getMsgType(index), msgInfo->msg_status);
                }
                else
                {
                    srv_um_msg_info_struct *msgInfo = NULL;
                    srv_um_thread_info_struct *threadInfo = NULL;
                    VfxBool result = VFX_FALSE;

                    result = m_list->getMsgInfo(index, msgInfo, threadInfo);
                    if (VFX_TRUE == result)
                    {
                        icon = getMsgTypeIcon(threadInfo->list_head.msg_type, msgInfo->msg_status);
                    }
                }
                if (0 != icon)
                {
                    image = VfxImageSrc(icon);
                }
            }
                break;

            default:
                break;
        }
    }
    else
    {
        return VFX_FALSE;
    }

    return VFX_TRUE;
}

VfxU32 VappMsgFolderPage::getCount() const
{
    VFX_ASSERT(NULL != m_list);

    VfxS32 count = 0;
    
    if( (VFX_TRUE == m_isInMsgApp && VFX_FALSE == ((VappMsgScreen*)getMainScr())->checkIsEntered() ) || VFX_FALSE == m_isEntered )
    {
        count =0;
    }
    else
    { 
        count = m_list->getCount();
        if (-1 == count)
        {
            count = 0;
        }
    }

    return count;
}

VcpListMenuItemStateEnum VappMsgFolderPage::getItemState(VfxU32 index) const
{
    VFX_ASSERT(NULL != m_list);

    if (VAPP_MSG_FOLDER_MODE_MS != m_mode)
    {
        return VCP_LIST_MENU_ITEM_STATE_NONE;
    }

    if (m_list->getMarkStatus(index))
    {
        return VCP_LIST_MENU_ITEM_STATE_SELECTED;
    }
    else
    {
        return VCP_LIST_MENU_ITEM_STATE_UNSELECTED;
    }
}

VfxBool VappMsgFolderPage::getItemIsDisabled(VfxU32 index) const
{
    if (NULL == m_list)
    {
        return VFX_FALSE;
    }

    if (VAPP_MSG_FOLDER_MODE_MS != m_mode)
        return VFX_FALSE;

    if (m_msgCopyFilter.msg_box == SRV_UM_MSG_BOX_SIM)
    {
        return VFX_FALSE;
    }
    else
    {
        if (!(m_list->getMsgType(index) & m_msgCopyFilter.msg_type))
        {
            return VFX_TRUE;
        }
        else
        {
            if (SRV_UM_MSG_SMS == m_msgCopyFilter.msg_type)
            {
				VfxU32 storage = srv_sms_get_msg_storage_type(m_list->getMsgId(index));
                switch (m_msgCopyFilter.msg_storage)
                {	                        
                    case VAPP_MSG_STORAGE_PHONE:
                    {
                        if (storage == SRV_SMS_STORAGE_ME)
                        {
                            return VFX_FALSE;
                        }
                        break;
                    }
                        
                    case VAPP_MSG_STORAGE_MEMORY_CARD:
                    {
                        if (storage == SRV_SMS_STORAGE_TCARD)
                        {
                            return VFX_FALSE;
                        }
                        break;
                    }
                        
                    case VAPP_MSG_STORAGE_PHONE_AND_MEMORY:
                    {
                        if (storage == SRV_SMS_STORAGE_ME || storage == SRV_SMS_STORAGE_TCARD)
                        {
                            return VFX_FALSE;
                        }
                        break;
                    }                   
                        
                    case VAPP_MSG_STORAGE_SIM:
                    {
                        if (storage == SRV_SMS_STORAGE_SIM)
                        {
                            return VFX_FALSE;
                        }
                        break;
                    }
                        
                    default:
                    {
                        return VFX_TRUE;
                    }
                }
            }
            #ifdef __MMI_MMS_IN_UM__
            else if (SRV_UM_MSG_MMS == m_msgCopyFilter.msg_type)
            {
                switch (m_msgCopyFilter.msg_storage)
                {	                        
                    case VAPP_MSG_STORAGE_PHONE:
                    {
                        if (srv_mms_get_msg_storage(m_list->getMsgId(index)) == SRV_MMS_STORAGE_CARD1)
                        {
                            return VFX_FALSE;
                        }
                        break;
                    }

                    case VAPP_MSG_STORAGE_MEMORY_CARD:
                    {
                        if (srv_mms_get_msg_storage(m_list->getMsgId(index)) == SRV_MMS_STORAGE_PHONE)
                        {
                            return VFX_FALSE;
                        }
                        break;
                    }
                        
                    default:
                    {
                        return VFX_TRUE;
                    }
                }
            }
            #endif
        }

        // check push/prov
        if (SRV_UM_MARK_SEVERAL_OP_ACTION_DELETE == m_msOpAction)
        {
            if (SRV_UM_MSG_WAP_PUSH != m_list->getMsgType(index) || 
                SRV_UM_MSG_PROV != m_list->getMsgType(index))
            {
                return VFX_FALSE;
            }
        }
    }

    return VFX_TRUE;
}

VfxBool VappMsgFolderPage::getMenuEmptyText(VfxWString & text,VcpListMenuTextColorEnum & color)
{
    if( (VFX_TRUE == m_isInMsgApp && VFX_FALSE == ((VappMsgScreen*)getMainScr())->checkIsEntered() ) || VFX_FALSE == m_isEntered )
    {
        return VFX_FALSE;
    }

    if (VFX_TRUE == m_list->checkMsgList())
    {
        text.loadFromRes(STR_ID_VAPP_MSG_NO_MESSAGES);
        color = VCP_LIST_MENU_TEXT_COLOR_NORMAL;

        return VFX_TRUE;
    }

    return VFX_FALSE;
}

void VappMsgFolderPage::showLoading()
{
    m_loading->start();
    m_listMenu->setIsUnhittable(VFX_TRUE);
    if (NULL != m_toolbar)
    {
        m_toolbar->setIsUnhittable(VFX_TRUE);
    }
}

void VappMsgFolderPage::stopLoading()
{
    m_loading->stop();
    m_listMenu->setIsUnhittable(VFX_FALSE);
    if (NULL != m_toolbar)
    {
        m_toolbar->setIsUnhittable(VFX_FALSE);
    }
}

VfxU32 VappMsgFolderPage::getUnreadCount()
{
    VfxU32 count = 0;

    /* Get SMS unread count */
    if (m_boxId.msg_type & SRV_UM_MSG_SMS)
    {
        count += srv_sms_get_unread_sms_num();
        MMI_TRACE(TRACE_GROUP_6, TRC_MMI_VAPP_MSG_GET_UNREAD_COUNT, SRV_UM_MSG_SMS, srv_sms_get_unread_sms_num(), this);
    }

#ifdef __MMI_MMS_IN_UM__
    /* Get MMS unread count */
    if (m_boxId.msg_type & SRV_UM_MSG_MMS)
    {
        VfxS32 result;
        srv_mms_get_msg_count_struct msg_count_req;

        vfx_sys_mem_zero(&msg_count_req, sizeof(srv_mms_get_msg_count_struct));

        msg_count_req.count = 1;
        msg_count_req.req_tb[0] = SRV_MMS_QUERY_TOTAL_UNREAD_INBOX_MSG;

        result = srv_mms_get_msg_count(&msg_count_req);

        if (SRV_MMS_RESULT_OK == result)
        {
            count += msg_count_req.rsp_tb[0];
            MMI_TRACE(TRACE_GROUP_6, TRC_MMI_VAPP_MSG_GET_UNREAD_COUNT, SRV_UM_MSG_MMS, msg_count_req.rsp_tb[0], this);
        }
    }
#endif /* __MMI_MMS_IN_UM__ */

#ifdef __MMI_PUSH_IN_UM__
    /* Get Push unread count */
    if (m_boxId.msg_type & SRV_UM_MSG_WAP_PUSH)
    {
        count += srv_get_push_unread_count();
        MMI_TRACE(TRACE_GROUP_6, TRC_MMI_VAPP_MSG_GET_UNREAD_COUNT, SRV_UM_MSG_WAP_PUSH, srv_get_push_unread_count(), this);
    }
#endif /* __MMI_PUSH_IN_UM__ */

#ifdef __MMI_PROV_IN_UM__
    /* Get Prov unread count */
    if (m_boxId.msg_type & SRV_UM_MSG_PROV)
    {
        count += srv_provbox_get_unread_msg_num(SRV_PROVBOX_BOX_TYPE_INBOX, MMI_SIM_ALL);
        MMI_TRACE(TRACE_GROUP_6, TRC_MMI_VAPP_MSG_GET_UNREAD_COUNT, SRV_UM_MSG_PROV, srv_provbox_get_unread_msg_num(SRV_PROVBOX_BOX_TYPE_INBOX, MMI_SIM_ALL), this);
    }
#endif /* __MMI_PROV_IN_UM__ */

    return count;
}

void VappMsgFolderPage::setTitle(VfxU32 number, VfxU32 unreadNumber, VfxBool isValid)
{
    if (VFX_FALSE == m_isNeedTitle)
    {
        return;
    }
    
    VFX_ASSERT(NULL != m_title);
    /* set title */
    VfxWString title;
    if (VAPP_MSG_FOLDER_MODE_NORMAL == m_mode)
    {
        if (VAPP_MSG_FOLDER_TYPE_NORMAL == m_style || 
            VAPP_MSG_FOLDER_TYPE_LITE == m_style)
        {
            switch (m_boxId.msg_box_type)
            {
            #ifdef __MMI_UM_BOX_LIST_SUPPORT__          
                case SRV_UM_MSG_BOX_INBOX:
                    title.loadFromRes(STR_GLOBAL_INBOX);
                    break;

                case SRV_UM_MSG_BOX_DRAFT:
                    title.loadFromRes(STR_GLOBAL_DRAFTS);
                    break;

                case SRV_UM_MSG_BOX_UNSENT:
                    title.loadFromRes(STR_GLOBAL_OUTBOX);
                    break;

                case SRV_UM_MSG_BOX_SENT:
                    title.loadFromRes(STR_ID_VAPP_MSG_SENTBOX);
                    break;
            #endif /* __MMI_UM_BOX_LIST_SUPPORT__ */
            #ifdef __UNIFIED_MESSAGE_ARCHIVE_SUPPORT__ 
                case SRV_UM_MSG_BOX_ARCHIVE:
                    title.loadFromRes(STR_ID_VAPP_MSG_ARCHIVE);
                    break;
            #endif /* __UNIFIED_MESSAGE_ARCHIVE_SUPPORT__  */

                case SRV_UM_MSG_BOX_SIM:
                    if (1 >= srv_sim_ctrl_get_num_of_inserted())
                    {
                        title.loadFromRes(STR_ID_VAPP_MSG_SIM_MSG);
                    }
                #if (MMI_MAX_SIM_NUM >= 2)
                    else if (SRV_UM_SIM_GSM_SIM1 == m_boxId.sim_id)
                    {
                        title.loadFromRes(STR_ID_VAPP_MSG_SIM1_MSG);
                    }
                    else if (SRV_UM_SIM_GSM_SIM2 == m_boxId.sim_id)
                    {
                        title.loadFromRes(STR_ID_VAPP_MSG_SIM2_MSG);
                    }
                #if (MMI_MAX_SIM_NUM >= 3)
                    else if (SRV_UM_SIM_GSM_SIM3 == m_boxId.sim_id)
                    {
                        title.loadFromRes(STR_ID_VAPP_MSG_SIM3_MSG);
                    }
                #endif /* MMI_MAX_SIM_NUM >= 3 */
                #if (MMI_MAX_SIM_NUM >= 4)
                    else if (SRV_UM_SIM_GSM_SIM4 == m_boxId.sim_id)
                    {
                        title.loadFromRes(STR_ID_VAPP_MSG_SIM4_MSG);
                    }
                #endif /* MMI_MAX_SIM_NUM >= 4 */
                #endif /* MMI_MAX_SIM_NUM >= 2 */
                    else
                    {
                        title.loadFromRes(STR_ID_VAPP_MSG_SIM_MSG);
                    }
                    break;

                default:
                    VFX_ASSERT(0);
                    break;
            }

            if (VFX_TRUE == isValid)
            {
                /* set subtitle */
                VfxWString subTitle;
            #ifdef __MMI_UM_BOX_LIST_SUPPORT__
                if (SRV_UM_MSG_BOX_INBOX == m_boxId.msg_box_type)
                {
                    subTitle.format(" (%d/%d)", unreadNumber, number);
                }
                else
            #endif /* __MMI_UM_BOX_LIST_SUPPORT__ */                    
                {
                    subTitle.format(" (%d)", number);
                }

                title += subTitle;
                m_title->setTitle(title);
            }
        }
        else
        {
            title.loadFromRes(STR_ID_VAPP_MSG);
        }
    }
    else
    {
        switch (m_msOpAction)
        {
            case SRV_UM_MARK_SEVERAL_OP_ACTION_DELETE:
                if (VAPP_MSG_FOLDER_TYPE_CONVERSATION == m_style)
                {
                    title.loadFromRes(STR_ID_VAPP_MSG_DELETE_CS_MSG);
                }
                else
                {
                    title.loadFromRes(STR_ID_VAPP_MSG_DELETE_MSG);
                }
                break;
                
    #ifdef __MMI_UM_BOX_LIST_SUPPORT__
            case SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_ARCHIVE:
                title.loadFromRes(STR_ID_VAPP_MSG_COPY_TO_ARCHIVE);
                break;

            case SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_SIM1:
                if (1 == srv_sim_ctrl_get_num_of_inserted())
                {
                    title.loadFromRes(STR_ID_VAPP_MSG_COPY_SMS_TO_SIM);
                }
                else
                {
                    title.loadFromRes(STR_ID_VAPP_MSG_COPY_SMS_TO_SIM1);
                }
                break;

        #if (MMI_MAX_SIM_NUM >= 2)
            case SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_SIM2:
                if (1 == srv_sim_ctrl_get_num_of_inserted())
                {
                    title.loadFromRes(STR_ID_VAPP_MSG_COPY_SMS_TO_SIM);
                }
                else
                {
                    title.loadFromRes(STR_ID_VAPP_MSG_COPY_SMS_TO_SIM2);
                }
                break;
        #endif /* MMI_MAX_SIM_NUM >= 2 */

        #if (MMI_MAX_SIM_NUM >= 3)
            case SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_SIM3:
                if (1 == srv_sim_ctrl_get_num_of_inserted())
                {
                    title.loadFromRes(STR_ID_VAPP_MSG_COPY_SMS_TO_SIM);
                }
                else
                {
                    title.loadFromRes(STR_ID_VAPP_MSG_COPY_SMS_TO_SIM3);
                }
                break;
        #endif /* MMI_MAX_SIM_NUM >= 3 */

        #if (MMI_MAX_SIM_NUM >= 4)
            case SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_SIM4:
                if (1 == srv_sim_ctrl_get_num_of_inserted())
                {
                    title.loadFromRes(STR_ID_VAPP_MSG_COPY_SMS_TO_SIM);
                }
                else
                {
                    title.loadFromRes(STR_ID_VAPP_MSG_COPY_SMS_TO_SIM4);
                }
                break;
        #endif /* MMI_MAX_SIM_NUM >= 4 */
    #endif /* __MMI_UM_BOX_LIST_SUPPORT__ */

            case SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_PHONE:
                if (m_boxId.msg_box_type == SRV_UM_MSG_BOX_SIM)
                {
                    /* if box type is equal to SIM folder, it should be copy sms to phone */
                    title.loadFromRes(STR_ID_VAPP_MSG_COPY_SMS_TO_PHONE);
                }
            #ifdef __MMI_UM_BOX_LIST_SUPPORT__
                else
                {
                    title.loadFromRes(STR_ID_VAPP_MSG_COPY_MMS_TO_PHONE);
                }
            #endif
                break;

            case SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_MEMORY_CARD:
                if (m_boxId.msg_box_type == SRV_UM_MSG_BOX_SIM)
                {
                    /* if box type is equal to SIM folder, it should be copy sms to memory card */
                    title.loadFromRes(STR_ID_VAPP_MSG_COPY_SMS_TO_MEMORY_CARD);
                }
            #ifdef __MMI_UM_BOX_LIST_SUPPORT__          //ff
                else
                {
                    title.loadFromRes(STR_ID_VAPP_MSG_COPY_MMS_TO_MEMORY_CARD);
                }
            #endif /* __MMI_UM_BOX_LIST_SUPPORT__ */          //ff
                break;

            default:
                VFX_ASSERT(0);
                break;
        }
    }

    m_title->setTitle(title);
}

VfxBool VappMsgFolderPage::getReadStatus(VfxU32 msgId, srv_um_msg_enum msgType)
{
    VfxBool readStatus = VFX_TRUE;

    switch (msgType)
    {
        case SRV_UM_MSG_SMS:
            if (SRV_SMS_STATUS_UNREAD & srv_sms_get_msg_status(msgId))
            {
                readStatus = VFX_FALSE;
            }
            break;

    #ifdef __MMI_MMS_IN_UM__
        case SRV_UM_MSG_MMS:
            if (MMI_FALSE == srv_mms_mma_get_mms_read_status(msgId))
            {
                readStatus = VFX_FALSE;
            }
            break;
    #endif /* __MMI_MMS_IN_UM__ */

    #ifdef __MMI_PUSH_IN_UM__
        case SRV_UM_MSG_WAP_PUSH:
            if (MMI_FALSE == srv_wap_push_msg_read_status(msgId))
            {
                readStatus = VFX_FALSE;
            }
            break;
    #endif /* __MMI_PUSH_IN_UM__ */

    #ifdef __MMI_PROV_IN_UM__
        case SRV_UM_MSG_PROV:
            if (SRV_PROVBOX_MSG_READ_STATUS_UNREAD == srv_provbox_get_msg_status(msgId))
            {
                readStatus = VFX_FALSE;
            }
            break;
    #endif /* __MMI_PROV_IN_UM__ */

        default:
            break;
    }

    MMI_TRACE(TRACE_GROUP_6, TRC_MMI_VAPP_MSG_GET_READ_STATUTS, msgType, msgId, readStatus, this);
    return readStatus;
}

void VappMsgFolderPage::modeChange()
{
    m_isTitleValid = VFX_FALSE;
    switch (m_mode)
    {
        case VAPP_MSG_FOLDER_MODE_NORMAL:
            // free ms status
            m_list->freeMsStatus();
            m_listMenu->setMenuMode(VCP_LIST_MENU_MODE_NORMAL, VFX_TRUE);
            break;

        case VAPP_MSG_FOLDER_MODE_MS:
            m_listMenu->setMenuMode(VCP_LIST_MENU_MODE_MULTI_SELECTION, VFX_TRUE);
            break;

        default:
            VFX_ASSERT(0);
            break;
    }
}

void VappMsgFolderPage::createToolbar(VappMsgFolderTypeEnum type, VappMsgFolderModeEnum mode)
{
    if (NULL != m_toolbar)
    {
        return;
    }

    VFX_OBJ_CREATE(m_toolbar, VcpToolBar, this);
    updateToolbar(type, mode);
    m_toolbar->m_signalButtonTap.connect(this, &VappMsgFolderPage::onToolbarClick);
    setBottomBar(m_toolbar);
}

void VappMsgFolderPage::updateToolbar(VappMsgFolderTypeEnum type, VappMsgFolderModeEnum mode)
{
    if (NULL == m_toolbar)
    {
        return;
    }

    /* remove all items */
    VfxU32 i;
    for (i = 1 ; i < VAPP_MSG_FOLDER_TOOL_BAR_END ; i = i << 1)
    {
        m_toolbar->removeItem(i);
    }

    /* add new */
    VfxU32 toolbarId = 0;
    switch (mode)
    {
        /*********************************************** 
         * normal mode *********************************
         **********************************************/
        case VAPP_MSG_FOLDER_MODE_NORMAL:
            switch (type)
            {
                /*********************************************** 
                 * conversation type ***************************
                 **********************************************/
                case VAPP_MSG_FOLDER_TYPE_CONVERSATION:
                    toolbarId = VAPP_MSG_FOLDER_TOOL_BAR_NEW_MSG | 
                                VAPP_MSG_FOLDER_TOOL_BAR_DELETE |
                            #ifdef __UNIFIED_MESSAGE_ARCHIVE_SUPPORT__                                
                                VAPP_MSG_FOLDER_TOOL_BAR_ARCHIVE |
                            #endif                                
                                VAPP_MSG_FOLDER_TOOL_BAR_SIM_MSG |
                                VAPP_MSG_FOLDER_TOOL_BAR_SETTING;
                    break;

                /*********************************************** 
                 * normal type *********************************
                 **********************************************/
                case VAPP_MSG_FOLDER_TYPE_NORMAL:
                    switch (m_boxId.msg_box_type)
                    {
                    #ifdef __MMI_UM_BOX_LIST_SUPPORT__                    
                        case SRV_UM_MSG_BOX_INBOX:
                            toolbarId = VAPP_MSG_FOLDER_TOOL_BAR_NEW_MSG | 
                                        VAPP_MSG_FOLDER_TOOL_BAR_DELETE | 
                                        VAPP_MSG_FOLDER_TOOL_BAR_COPY | 
                                        VAPP_MSG_FOLDER_TOOL_BAR_SORT;
                            break;

                        case SRV_UM_MSG_BOX_SENT:
                            toolbarId = VAPP_MSG_FOLDER_TOOL_BAR_DELETE | 
                                        VAPP_MSG_FOLDER_TOOL_BAR_COPY | 
                                        VAPP_MSG_FOLDER_TOOL_BAR_SORT;
                            break;

                        case SRV_UM_MSG_BOX_DRAFT:
                        case SRV_UM_MSG_BOX_ARCHIVE:
                            toolbarId = VAPP_MSG_FOLDER_TOOL_BAR_DELETE | 
                                        VAPP_MSG_FOLDER_TOOL_BAR_SORT;
                            break;

                        case SRV_UM_MSG_BOX_UNSENT:
                            break;
                    #endif /* __MMI_UM_BOX_LIST_SUPPORT__ */

                        case SRV_UM_MSG_BOX_SIM:
                            toolbarId = VAPP_MSG_FOLDER_TOOL_BAR_DELETE | 
                                        VAPP_MSG_FOLDER_TOOL_BAR_COPY_TO_INBOX;
                            break;
                            
                    #ifdef __MMI_UM_TEMPLATE_SUPPORT__

                        case SRV_UM_MSG_BOX_PREDEF_TEMPLATES| SRV_UM_MSG_BOX_USRDEF_TEMPLATES:
                            toolbarId = VAPP_MSG_FOLDER_TOOL_BAR_ADD_TEMPLATE |
                                        VAPP_MSG_FOLDER_TOOL_BAR_DELETE;
                            break;
                    #endif /* __MMI_UM_TEMPLATE_SUPPORT__ */
                        default:
                            break;
                    }
                    break;

                /*********************************************** 
                 * lite type ***********************************
                 **********************************************/
                case VAPP_MSG_FOLDER_TYPE_LITE:
                    toolbarId = VAPP_MSG_FOLDER_TOOL_BAR_NEW_MSG | 
                                VAPP_MSG_FOLDER_TOOL_BAR_DELETE;
                    break;

                default:
                    VFX_ASSERT(0);
                    break;
            }
            break;

        /*********************************************** 
         * mark several mode ***************************
         **********************************************/
        case VAPP_MSG_FOLDER_MODE_MS:
            switch (m_msOpAction)
            {
                case SRV_UM_MARK_SEVERAL_OP_ACTION_DELETE:
                    toolbarId = VAPP_MSG_FOLDER_TOOL_BAR_MS_SELECT_ALL |
                                VAPP_MSG_FOLDER_TOOL_BAR_MS_DELETE |
                                VAPP_MSG_FOLDER_TOOL_BAR_MS_CANCEL;
                    break;
                    
        #ifdef __MMI_UM_BOX_LIST_SUPPORT__  
                case SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_ARCHIVE:
                case SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_SIM1:
            #if (MMI_MAX_SIM_NUM >= 2)
                case SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_SIM2:
            #endif /* MMI_MAX_SIM_NUM >= 2 */
            #if (MMI_MAX_SIM_NUM >= 3)
                case SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_SIM3:
            #endif /* MMI_MAX_SIM_NUM >= 3 */
            #if (MMI_MAX_SIM_NUM >= 4)
                case SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_SIM4:
            #endif /* MMI_MAX_SIM_NUM >= 4 */
            
        #endif /* __MMI_UM_BOX_LIST_SUPPORT__ */                         
                case SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_MEMORY_CARD:   
                case SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_PHONE:              
                    toolbarId = VAPP_MSG_FOLDER_TOOL_BAR_MS_SELECT_ALL |
                                VAPP_MSG_FOLDER_TOOL_BAR_MS_COPY |
                                VAPP_MSG_FOLDER_TOOL_BAR_MS_CANCEL;
                    break;
                default:
                    VFX_ASSERT(0);
                    break;
            }
            break;

        default:
            VFX_ASSERT(0);
            break;
    }

    for (i = 1 ; i < VAPP_MSG_FOLDER_TOOL_BAR_END ; i = i << 1)
    {
        if (toolbarId & i)
        {
            addToolBarItem((VappMsgToolbarEnum)i);
        }
    }
}

void VappMsgFolderPage::addToolBarItem(VappMsgToolbarEnum id)
{
    if (NULL == m_toolbar)
    {
        return;
    }

    switch (id)
    {
        case VAPP_MSG_FOLDER_TOOL_BAR_NEW_MSG:
            m_toolbar->addItem(id, STR_ID_VAPP_MSG_NEW_MSG, IMG_ID_VAPP_MSG_TB_NEW_MSG);
            break;
    #ifdef __MMI_UM_TEMPLATE_SUPPORT__
        case VAPP_MSG_FOLDER_TOOL_BAR_ADD_TEMPLATE:
            m_toolbar->addItem(id, STR_GLOBAL_ADD, VCP_IMG_TOOL_BAR_COMMON_ITEM_ADD);
            break;
    #endif
        case VAPP_MSG_FOLDER_TOOL_BAR_DELETE:
            m_toolbar->addItem(id, VCP_STR_TOOL_BAR_DELETE, VCP_IMG_TOOL_BAR_COMMON_ITEM_DELETE);
            break;

        case VAPP_MSG_FOLDER_TOOL_BAR_MS_DELETE:
            m_toolbar->addItem(id, VCP_STR_TOOL_BAR_DELETE, VCP_IMG_TOOL_BAR_COMMON_ITEM_DELETE);
            if (VFX_TRUE == m_list->getIsAllMarked(VFX_FALSE))
            {
                m_toolbar->setDisableItem(id, VFX_TRUE);
            }
            break;
            
    #ifdef __UNIFIED_MESSAGE_ARCHIVE_SUPPORT__
        case VAPP_MSG_FOLDER_TOOL_BAR_ARCHIVE:
            m_toolbar->addItem(id, STR_ID_VAPP_MSG_ARCHIVE, VCP_IMG_TOOL_BAR_COMMON_ITEM_SAVE);
            break;
    #endif
        case VAPP_MSG_FOLDER_TOOL_BAR_SIM_MSG:
            m_toolbar->addItem(id, STR_ID_VAPP_MSG_SIM_MSG, IMG_ID_VAPP_MSG_TB_SIM_MSG);
            if (0 == srv_sim_ctrl_get_num_of_inserted())
            {
                m_toolbar->setDisableItem(id, VFX_TRUE);
            }
            break;

        case VAPP_MSG_FOLDER_TOOL_BAR_SETTING:
            m_toolbar->addItem(id, VCP_STR_TOOL_BAR_SETTINGS, VCP_IMG_TOOL_BAR_COMMON_ITEM_SETTING);
            break;

    #ifdef __MMI_UM_BOX_LIST_SUPPORT__  
        case VAPP_MSG_FOLDER_TOOL_BAR_COPY:
            {
                m_toolbar->addItem(id, STR_ID_VAPP_MSG_COPY_TO, VCP_IMG_TOOL_BAR_COMMON_ITEM_COPY);
                if ((0 == srv_sim_ctrl_get_num_of_inserted()) && 
                    (MMI_FALSE == srv_fmgr_drv_is_accessible(srv_fmgr_drv_get_letter_by_type(SRV_FMGR_DRV_CARD_TYPE))))
                {
                    m_toolbar->setDisableItem(id, VFX_TRUE);
                }
            }
            break;
    #endif
        case VAPP_MSG_FOLDER_TOOL_BAR_MS_COPY:
            m_toolbar->addItem(id, VCP_STR_TOOL_BAR_COPY, VCP_IMG_TOOL_BAR_COMMON_ITEM_COPY);
            if (VFX_TRUE == m_list->getIsAllMarked(VFX_FALSE))
            {
                m_toolbar->setDisableItem(id, VFX_TRUE);
            }
            break;

        case VAPP_MSG_FOLDER_TOOL_BAR_COPY_TO_INBOX:
            m_toolbar->addItem(id, STR_ID_VAPP_MSG_COPY_TO_INBOX, IMG_ID_VAPP_MSG_TB_COPY_TO_PHONE);
            break;
    #ifdef __UNIFIED_MESSAGE_SORT_MESSAGE_LIST__
        case VAPP_MSG_FOLDER_TOOL_BAR_SORT:
            m_toolbar->addItem(id, VCP_STR_TOOL_BAR_SORT, VCP_IMG_TOOL_BAR_COMMON_ITEM_SORT);
            break;
    #endif
        case VAPP_MSG_FOLDER_TOOL_BAR_MS_SELECT_ALL:
            if (VFX_TRUE == m_list->getIsAllMarked(VFX_TRUE, m_msgCopyFilter.msg_type, getTransMsMsgListCopyType()))
            {
                m_toolbar->addItem(id, VCP_STR_TOOL_BAR_UNSELECT_ALL, VCP_IMG_TOOL_BAR_COMMON_ITEM_UNSELECT_ALL);
            }
            else
            {
                m_toolbar->addItem(id, VCP_STR_TOOL_BAR_SELECT_ALL, VCP_IMG_TOOL_BAR_COMMON_ITEM_SELECT_ALL);
            }
            /* no valid number, disable the select all */
            if (0 == m_list->getNumValidMsMsg(m_msgCopyFilter.msg_type, getTransMsMsgListCopyType()))
            {
                m_toolbar->setDisableItem(id, VFX_TRUE);
            }
            break;

        case VAPP_MSG_FOLDER_TOOL_BAR_MS_CANCEL:
            m_toolbar->addItem(id, VCP_STR_TOOL_BAR_CANCEL, VCP_IMG_TOOL_BAR_COMMON_ITEM_CANCEL);
            break;

        default:
            VFX_ASSERT(0);
            break;
    }
}

void VappMsgFolderPage::enableToolbar(VappMsgFolderTypeEnum type, VappMsgFolderModeEnum mode, VfxBool enable)
{
    if (NULL == m_toolbar)
    {
        return;
    }

    m_toolbar->setDisableItem(VAPP_MSG_FOLDER_TOOL_BAR_DELETE, !enable);
#ifdef __MMI_UM_BOX_LIST_SUPPORT__    
    m_toolbar->setDisableItem(VAPP_MSG_FOLDER_TOOL_BAR_COPY, !enable);
#endif         
    m_toolbar->setDisableItem(VAPP_MSG_FOLDER_TOOL_BAR_COPY_TO_INBOX, !enable);
#ifdef __UNIFIED_MESSAGE_SORT_MESSAGE_LIST__    
    m_toolbar->setDisableItem(VAPP_MSG_FOLDER_TOOL_BAR_SORT, !enable);
#endif
    if (VAPP_MSG_FOLDER_MODE_MS == mode)
    {
        /* check if valid number inside */
        if (0 == m_list->getNumValidMsMsg(m_msgCopyFilter.msg_type, getTransMsMsgListCopyType()))
        {
            m_toolbar->setDisableItem(VAPP_MSG_FOLDER_TOOL_BAR_MS_SELECT_ALL, VFX_TRUE);
        }
        else
        {
            m_toolbar->setDisableItem(VAPP_MSG_FOLDER_TOOL_BAR_MS_SELECT_ALL, VFX_FALSE);
        }
    }
}

VfxU32 VappMsgFolderPage::getMsgTypeIcon(VfxU32 msgType, VfxU32 msgStatus)
{
    VfxU32 icon = 0;

    switch (msgType)
    {
        case SRV_UM_MSG_SMS:
            icon = vapp_sms_get_icon_by_status(msgStatus);
            break;

    #ifdef __MMI_MMS_IN_UM__
        case SRV_UM_MSG_MMS:
            icon = vapp_mms_get_msg_icon(msgStatus);
            break;
    #endif /* __MMI_MMS_IN_UM__ */

    #ifdef __MMI_PUSH_IN_UM__
        case SRV_UM_MSG_WAP_PUSH:
            icon = VfxAppWapPushInterface::vappWapPushGetIcon(msgStatus);
            break;
    #endif /* __MMI_PUSH_IN_UM__ */

    #ifdef __MMI_PROV_IN_UM__
        case SRV_UM_MSG_PROV:
            icon = vapp_prov_get_status_icon_id(msgStatus);
            break;
    #endif /* __MMI_PROV_IN_UM__ */

        default:
            break;
    }

    return icon;
}

void VappMsgFolderPage::createContextItem(
    VcpMenuPopup * cntx, 
    srv_um_msg_box_enum boxType, 
    srv_um_msg_enum msgType, 
    VfxU32 msgId, 
    VfxU32 index)
{
    srv_um_msg_info_struct *msgInfo = NULL;
    VfxBool result = VFX_FALSE;

    result = m_list->getMsgInfo(index, msgInfo);
    VFX_ASSERT(VFX_TRUE == result);
    switch (boxType)
    {
#ifdef __MMI_UM_BOX_LIST_SUPPORT__     
        case SRV_UM_MSG_BOX_INBOX:
            if ((SRV_UM_MSG_SMS | SRV_UM_MSG_MMS) & msgType)
            {
            #ifdef __MMI_UM_CONVERSATION_BOX__
                if (1 == msgInfo->address_number && 
                    SRV_UM_ADDR_PHONE_NUMBER == msgInfo->address_type)
                {
                    VfxWString text;
                    text = VFX_WSTR_RES(STR_GLOBAL_DIAL);
                    text += VFX_WSTR(" ");
                    text += transferSingle2PhbName(msgInfo->address);
                    createContextSingleItem(cntx, VAPP_MSG_FOLDER_LP_TYPE_CALL, text, msgId, msgType, index);
                }
            #endif /* __MMI_UM_CONVERSATION_BOX__ */
                if ((SRV_UM_MSG_SMS == msgType && 
                     SRV_SMS_STATUS_UNSUPPORTED != (SRV_SMS_STATUS_UNSUPPORTED & srv_sms_get_msg_status(msgId))) 
                #ifdef __MMI_MMS_IN_UM__
                    ||
                    (SRV_UM_MSG_MMS == msgType && 
                     (MMI_FALSE == srv_mms_is_java_mms(msgId) && 
                      MMI_FALSE == srv_mms_is_corrupted_mms(msgId) && 
                      MMI_FALSE == srv_mms_is_mms_notification(msgId) && 
                      MMI_FALSE == srv_mms_is_forward_lock(msgId)
                     )
                    )
                #endif /* __MMI_MMS_IN_UM__ */
                   )
                {
                    createContextSingleItem(cntx, VAPP_MSG_FOLDER_LP_TYPE_FORWARD, VFX_WSTR_RES(STR_GLOBAL_FORWARD), msgId, msgType, index);
                }
            }
        #ifdef __MMI_PUSH_IN_UM__
            if (SRV_UM_MSG_WAP_PUSH == msgType)
            {
                srv_um_msg_info_struct *msgInfo = NULL;
                VfxBool result = VFX_FALSE;

                result = m_list->getMsgInfo(index, msgInfo);
                VFX_ASSERT(VFX_TRUE == result);
                if (SRV_UM_ADDR_PHONE_NUMBER == msgInfo->address_type)
                {
                    VfxWString text;
                    text = VFX_WSTR_RES(STR_GLOBAL_DIAL);
                    text += VFX_WSTR(" ");
                    text += transferSingle2PhbName(msgInfo->address);
                    createContextSingleItem(cntx, VAPP_MSG_FOLDER_LP_TYPE_CALL, text, msgId, msgType, index);
                }
                createContextSingleItem(cntx, VAPP_MSG_FOLDER_LP_TYPE_VIEW_WEBSITE, VFX_WSTR_RES(STR_ID_VAPP_MSG_VIEW_WEBSITE), msgId, msgType, index);
            }
        #endif /* __MMI_PUSH_IN_UM__ */
        #ifdef __MMI_PROV_IN_UM__
            if (SRV_UM_MSG_PROV == msgType)
            {
                createContextSingleItem(cntx, VAPP_MSG_FOLDER_LP_TYPE_INSTALL, VFX_WSTR_RES(STR_GLOBAL_INSTALL), msgId, msgType, index);
            }
        #endif /* __MMI_PROV_IN_UM__ */
            createContextSingleItem(cntx, VAPP_MSG_FOLDER_LP_TYPE_DELETE, VFX_WSTR_RES(STR_GLOBAL_DELETE), msgId, msgType, index);
            break;

        case SRV_UM_MSG_BOX_DRAFT:
            if ((SRV_UM_MSG_SMS == msgType && 
                 SRV_SMS_STATUS_UNSUPPORTED != (SRV_SMS_STATUS_UNSUPPORTED & srv_sms_get_msg_status(msgId)))
            #ifdef __MMI_MMS_IN_UM__
                ||
                (SRV_UM_MSG_MMS == msgType && 
                 MMI_FALSE == srv_mms_is_corrupted_mms(msgId) && 
                 MMI_FALSE == srv_mms_is_forward_lock(msgId)
                )
            #endif /* __MMI_MMS_IN_UM__ */
               )
            {
                createContextSingleItem(cntx, VAPP_MSG_FOLDER_LP_TYPE_EDIT, VFX_WSTR_RES(STR_GLOBAL_EDIT), msgId, msgType, index);
            }
            createContextSingleItem(cntx, VAPP_MSG_FOLDER_LP_TYPE_DELETE, VFX_WSTR_RES(STR_GLOBAL_DELETE), msgId, msgType, index);
            break;

        case SRV_UM_MSG_BOX_UNSENT:
            if ((SRV_UM_MSG_SMS == msgType && 
                 SRV_SMS_STATUS_UNSUPPORTED != (SRV_SMS_STATUS_UNSUPPORTED & srv_sms_get_msg_status(msgId))) 
            #ifdef __MMI_MMS_IN_UM__
                ||
                (SRV_UM_MSG_MMS == msgType && 
                 MMI_FALSE == srv_mms_is_corrupted_mms(msgId) && 
                 MMI_FALSE == srv_mms_is_forward_lock(msgId)
                )
            #endif /* __MMI_MMS_IN_UM__ */
               )
            {
                createContextSingleItem(cntx, VAPP_MSG_FOLDER_LP_TYPE_EDIT, VFX_WSTR_RES(STR_GLOBAL_EDIT), msgId, msgType, index);
            }
            if ((SRV_UM_MSG_MMS != msgType) 
            #ifdef __MMI_MMS_IN_UM__
                ||
                (SRV_UM_MSG_MMS == msgType && MMI_FALSE == srv_mms_is_corrupted_mms(msgId))
            #endif /* __MMI_MMS_IN_UM__ */
               )
            {
            #if (MMI_MAX_SIM_NUM == 1)
                if (MMI_TRUE == srv_sim_ctrl_is_inserted(MMI_SIM1))
            #else
                if (MMI_TRUE == srv_sim_ctrl_is_inserted(tsfrUmSim2Sim(msgInfo->sim_id)))
            #endif /* MMI_MAX_SIM_NUM >= 2 */
                {
                    createContextSingleItem(cntx, VAPP_MSG_FOLDER_LP_TYPE_RESEND, VFX_WSTR_RES(STR_GLOBAL_RESEND), msgId, msgType, index);
                }
            }
            createContextSingleItem(cntx, VAPP_MSG_FOLDER_LP_TYPE_DELETE, VFX_WSTR_RES(STR_GLOBAL_DELETE), msgId, msgType, index);
            break;

        case SRV_UM_MSG_BOX_SENT:
            if ((SRV_UM_MSG_SMS == msgType && 
                 SRV_SMS_STATUS_UNSUPPORTED != (SRV_SMS_STATUS_UNSUPPORTED & srv_sms_get_msg_status(msgId))) 
            #ifdef __MMI_MMS_IN_UM__
                ||
                (SRV_UM_MSG_MMS == msgType && MMI_FALSE == srv_mms_is_corrupted_mms(msgId))
            #endif /* __MMI_MMS_IN_UM__ */
               )
            {
                createContextSingleItem(cntx, VAPP_MSG_FOLDER_LP_TYPE_FORWARD, VFX_WSTR_RES(STR_GLOBAL_FORWARD), msgId, msgType, index);
            }
            createContextSingleItem(cntx, VAPP_MSG_FOLDER_LP_TYPE_DELETE, VFX_WSTR_RES(STR_GLOBAL_DELETE), msgId, msgType, index);
            break;
#endif /* __MMI_UM_BOX_LIST_SUPPORT__  */
#ifdef __UNIFIED_MESSAGE_ARCHIVE_SUPPORT__ 
        case SRV_UM_MSG_BOX_ARCHIVE:
            createContextSingleItem(cntx, VAPP_MSG_FOLDER_LP_TYPE_DELETE, VFX_WSTR_RES(STR_GLOBAL_DELETE), msgId, msgType, index);
            break;
#endif /* __UNIFIED_MESSAGE_ARCHIVE_SUPPORT__  */
        case SRV_UM_MSG_BOX_SIM:
        #ifdef __MMI_UM_CONVERSATION_BOX__
            if (1 == msgInfo->address_number&& 
                    SRV_UM_ADDR_PHONE_NUMBER == msgInfo->address_type)
            {
                VfxWString text;
                text = VFX_WSTR_RES(STR_GLOBAL_DIAL);
                text += VFX_WSTR(" ");
                text += transferSingle2PhbName(msgInfo->address);
                createContextSingleItem(cntx, VAPP_MSG_FOLDER_LP_TYPE_CALL, text, msgId, msgType, index);
            }
        #endif /* __MMI_UM_CONVERSATION_BOX__ */
            createContextSingleItem(cntx, VAPP_MSG_FOLDER_LP_TYPE_DELETE, VFX_WSTR_RES(STR_GLOBAL_DELETE), msgId, msgType, index);
            break;

#ifdef __MMI_UM_TEMPLATE_SUPPORT__
        case (SRV_UM_MSG_BOX_PREDEF_TEMPLATES|SRV_UM_MSG_BOX_USRDEF_TEMPLATES):
            if (SRV_UM_MSG_MMS != msgType 
            #ifdef __MMI_MMS_IN_UM__
                || 
                (SRV_UM_MSG_MMS == msgType && 
                 MMI_FALSE == srv_mms_is_corrupted_mms(msgId) && 
                 MMI_FALSE == srv_mms_is_forward_lock(msgId)
                )
            #endif /* __MMI_MMS_IN_UM__ */
               )
            {
                createContextSingleItem(cntx, VAPP_MSG_FOLDER_LP_TYPE_USE, VFX_WSTR_RES(STR_GLOBAL_USE), msgId, msgType, index);
            }
            createContextSingleItem(cntx, VAPP_MSG_FOLDER_LP_TYPE_DELETE, VFX_WSTR_RES(STR_GLOBAL_DELETE), msgId, msgType, index);
            if (SRV_UM_MSG_MMS != msgType 
            #ifdef __MMI_MMS_IN_UM__
                || 
                (SRV_UM_MSG_MMS == msgType && 
                 MMI_FALSE == srv_mms_is_corrupted_mms(msgId) && 
                 MMI_FALSE == srv_mms_is_forward_lock(msgId)
                )
            #endif /* __MMI_MMS_IN_UM__ */
               )
            {
                createContextSingleItem(cntx, VAPP_MSG_FOLDER_LP_TYPE_EDIT, VFX_WSTR_RES(STR_GLOBAL_EDIT), msgId, msgType, index);
            }
            break;
#endif
        default:
            VFX_ASSERT(0);
            break;
    }
}

VappMsgCntxOptItemCp* VappMsgFolderPage::createContextSingleItem(
    VcpMenuPopup * parentCntx, 
    VfxId itemId, 
    VfxWString itemText, 
    VfxU32 msgId, 
    srv_um_msg_enum msgType, 
    VfxU32 index)
{
    if (VAPP_MSG_FOLDER_LP_TYPE_FORWARD == itemId && m_isNotification)
        return NULL;
    
    VappMsgCntxOptItemCp *item;

    VFX_OBJ_CREATE(item, VappMsgCntxOptItemCp, parentCntx);
    item->setId(itemId);
    item->setText(itemText);

    item->setMsgId(msgId);
    item->setMsgType(msgType);
    item->setIndex(index);

    parentCntx->insertItem(NULL, NULL, item);

    return item;
}

VappMsgCntxOptItemCp* VappMsgFolderPage::createContextSingleItem(
    VcpMenuPopup * parentCntx, 
    VfxId itemId, 
    VfxWString itemText, 
    VfxU32 thrdIdType, 
    VfxU64 thrdIdValue, 
    VfxU32 index)
{
    if (VAPP_MSG_FOLDER_LP_TYPE_FORWARD == itemId && m_isNotification)
        return NULL;
    
    VappMsgCntxOptItemCp *item;

    VFX_OBJ_CREATE(item, VappMsgCntxOptItemCp, parentCntx);
    item->setId(itemId);
    item->setText(itemText);

    item->setThrdIdType(thrdIdType);
    item->setThrdIdValue(thrdIdValue);
    item->setIndex(index);

    parentCntx->insertItem(NULL, NULL, item);

    return item;
}

#ifdef __MMI_UNIFIED_COMPOSER__
srv_uc_info_type_enum VappMsgFolderPage::transferUcType(srv_um_msg_enum msgType)
{
    srv_uc_info_type_enum ucType = SRV_UC_INFO_TYPE_SMS;

    switch (msgType)
    {
        case SRV_UM_MSG_SMS:
            ucType = SRV_UC_INFO_TYPE_SMS;
            break;

        case SRV_UM_MSG_MMS:
            ucType = SRV_UC_INFO_TYPE_MMS;
            break;

        default:
            VFX_ASSERT(0);
            break;
    }

    return ucType;
}
#endif

VfxPage *VappMsgFolderPage::createViewerPage(VfxU32 msgId, VfxU32 msgType)
{
    switch (msgType)
    {
        case SRV_UM_MSG_SMS:
            VappSmsViewerPage *smsViewerPage;
            VFX_OBJ_CREATE(smsViewerPage, VappSmsViewerPage, getMainScr());
            if (VAPP_MSG_FOLDER_TYPE_LITE == m_style)
            {
                smsViewerPage->setMsgID(msgId, VFX_TRUE);
            }
            else
            {
                smsViewerPage->setMsgID(msgId);
            }
            return smsViewerPage;

    #ifdef __MMI_MMS_IN_UM__
        case SRV_UM_MSG_MMS:
            VappMmsViewerPage *mmsViewerPage;
            VFX_OBJ_CREATE_EX(mmsViewerPage, VappMmsViewerPage, getMainScr(), (MODE_STOP, msgId));
            return mmsViewerPage;
    #endif /* __MMI_MMS_IN_UM__ */

    #ifdef __MMI_PUSH_IN_UM__
        case SRV_UM_MSG_WAP_PUSH:
            VappWapPushViewerPage *pushViewerPage;
            VFX_OBJ_CREATE_EX(pushViewerPage, VappWapPushViewerPage, getMainScr(), (msgId));
            return pushViewerPage;
    #endif /* __MMI_PUSH_IN_UM__ */

    #ifdef __MMI_PROV_IN_UM__
        case SRV_UM_MSG_PROV:
            VappProvDetailPage *provViewerPage;
            VFX_OBJ_CREATE_EX(provViewerPage, VappProvDetailPage, getMainScr(), (msgId, SRV_UM_MSG_PROV));
            return provViewerPage;
    #endif /* __MMI_PROV_IN_UM__ */

        default:
            VFX_ASSERT(0);
    }

    return NULL;
}

void *VappMsgFolderPage::allocMem(VfxU32 size, void * userData)
{
    VappMsgFolderPage *self = (VappMsgFolderPage *)VfxObject::handleToObject((VfxObjHandle)userData);
    void *mem = NULL;

    if (self)
    {
        if (self->isKindOf(VFX_OBJ_CLASS_INFO(VappMsgFolderPage)))
        {
            VFX_ALLOC_MEM(mem, size, self);
        }
    }

    return mem;
}

void VappMsgFolderPage::freeMem(void * ptr)
{
    VFX_FREE_MEM(ptr);
}

srv_um_msg_enum VappMsgFolderPage::getMsMarkAllMsgType()
{
    if (VAPP_MSG_FOLDER_MODE_NORMAL == m_mode)
    {
        return SRV_UM_MSG_ALL;
    }

    srv_um_msg_enum msgType = SRV_UM_MSG_ALL;
    switch (m_msOpAction)
    {
#ifdef __MMI_UM_BOX_LIST_SUPPORT__    
        case SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_ARCHIVE:
            msgType = (srv_um_msg_enum) (SRV_UM_MSG_SMS | SRV_UM_MSG_MMS);
            break;

        case SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_SIM1:
    #if (MMI_MAX_SIM_NUM >= 2)
        case SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_SIM2:
    #endif /* MMI_MAX_SIM_NUM >= 2 */
    #if (MMI_MAX_SIM_NUM >= 3)
        case SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_SIM3:
    #endif /* MMI_MAX_SIM_NUM >= 3 */
    #if (MMI_MAX_SIM_NUM >= 4)
        case SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_SIM4:
    #endif /* MMI_MAX_SIM_NUM >= 4 */
            msgType = SRV_UM_MSG_SMS;
            break;

        case SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_MEMORY_CARD:
#endif /* __MMI_UM_BOX_LIST_SUPPORT__ */
        case SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_PHONE:

            msgType = SRV_UM_MSG_MMS;
            break;

        default:
            break;
    }

    /* special case for sim card copy to phone */
    if (SRV_UM_MSG_BOX_SIM == m_boxId.msg_box_type &&
        SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_PHONE == m_msOpAction)
    {
        msgType = SRV_UM_MSG_SMS;
    }

    return msgType;
}

VappMessageListCopyStorageEnum VappMsgFolderPage::getTransMsMsgListCopyType()
{
    if (VAPP_MSG_FOLDER_MODE_NORMAL == m_mode)
    {
        return VAPP_MESSAGE_LIST_COPY_STORAGE_NONE;
    }

    VappMessageListCopyStorageEnum copy = VAPP_MESSAGE_LIST_COPY_STORAGE_NONE;
    switch (m_msOpAction)
    {
#ifdef __MMI_UM_BOX_LIST_SUPPORT__     
        case SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_ARCHIVE:
            copy = VAPP_MESSAGE_LIST_COPY_STORAGE_ARCHIVE;
            break;

        case SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_SIM1:
            copy = VAPP_MESSAGE_LIST_COPY_STORAGE_SIM1;
            break;

    #if (MMI_MAX_SIM_NUM >= 2)
        case SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_SIM2:
            copy = VAPP_MESSAGE_LIST_COPY_STORAGE_SIM2;
            break;
    #endif /* MMI_MAX_SIM_NUM >= 2 */

    #if (MMI_MAX_SIM_NUM >= 3)
        case SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_SIM3:
            copy = VAPP_MESSAGE_LIST_COPY_STORAGE_SIM3;
            break;
    #endif /* MMI_MAX_SIM_NUM >= 3 */

    #if (MMI_MAX_SIM_NUM >= 4)
        case SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_SIM4:
            copy = VAPP_MESSAGE_LIST_COPY_STORAGE_SIM4;
            break;
    #endif /* MMI_MAX_SIM_NUM >= 4 */
#endif /* __MMI_UM_BOX_LIST_SUPPORT__ */

        case SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_PHONE:
            copy = VAPP_MESSAGE_LIST_COPY_STORAGE_PHONE;
            break;
        case SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_MEMORY_CARD:
            copy = VAPP_MESSAGE_LIST_COPY_STORAGE_MEMORY_CARD;
            break;

        default:
            break;
    }

    return copy;
}

VfxWString VappMsgFolderPage::transfer2PhbName(srv_um_msg_info_struct *msgInfo)
{
    VfxWString text;
    text = VFX_WSTR_EMPTY;
#ifdef __MMI_UM_CONVERSATION_BOX__
    if (1 == msgInfo->address_number)
    {
        text = transferSingle2PhbName(msgInfo->address);
    }
    else
    {
        /* loop to transfer the address */
        VfxU32 i;
        text = transferSingle2PhbName(msgInfo->address);
        for (i = 0 ; i < (VfxU32)(msgInfo->address_number - 1) ; i++)
        {
            text += VFX_WSTR(", ");
            text += transferSingle2PhbName(msgInfo->address_ext[i]);
        }

        if (KAL_TRUE == msgInfo->address_more)
        {
            /* Need to add suspension point if there are more addresses */
            text += VFX_WSTR(" ...");
        }
    }
#else
    text = transferSingle2PhbName(msgInfo->address);
#endif /* __MMI_UM_CONVERSATION_BOX__ */

    return text;
}

VfxWString VappMsgFolderPage::transferSingle2PhbName(VfxWChar * addr)
{
    VfxWString text;
    text = VFX_WSTR_EMPTY;
    /* check phb */
    VfxU32 len = 0;
    VfxWChar *tmpName = NULL;
    MMI_BOOL find = MMI_FALSE;

    len = (MMI_PHB_NAME_LENGTH > SRV_UM_MAX_ADDR_LEN) ? MMI_PHB_NAME_LENGTH : SRV_UM_MAX_ADDR_LEN;
    len++;
    VFX_ALLOC_MEM(tmpName, sizeof(VfxWChar)*(len * ENCODING_LENGTH), this);
    vfx_sys_mem_zero(tmpName, sizeof(VfxWChar)*(len * ENCODING_LENGTH));
    find = srv_phb_get_name_by_number(addr, tmpName, len);
    if (find)
    {
        text.loadFromMem(tmpName);
        if (VFX_WSTR_EMPTY == text)
        {
            text.loadFromMem(addr);
        }
    }
    else
    {
        text.loadFromMem(addr);
    }
    VFX_FREE_MEM(tmpName);

    return text;
}

void VappMsgFolderPage::updateMsToolbar()
{
    if (VAPP_MSG_FOLDER_MODE_MS == m_mode && NULL != m_toolbar)
    {
        if (m_list->getIsAllMarked(VFX_FALSE))
        {
            m_toolbar->setDisableItem(VAPP_MSG_FOLDER_TOOL_BAR_MS_DELETE, VFX_TRUE);
            m_toolbar->setDisableItem(VAPP_MSG_FOLDER_TOOL_BAR_MS_COPY, VFX_TRUE);
        }
        else
        {
            m_toolbar->setDisableItem(VAPP_MSG_FOLDER_TOOL_BAR_MS_DELETE, VFX_FALSE);
            m_toolbar->setDisableItem(VAPP_MSG_FOLDER_TOOL_BAR_MS_COPY, VFX_FALSE);
        }
        
        /* if it hasn't get the list inside,there is no need to change txt on this button */
        if (TRUE == m_list->isMsgList())
        {
            if (VFX_TRUE == m_list->getIsAllMarked(VFX_TRUE, m_msgCopyFilter.msg_type, getTransMsMsgListCopyType()))
            {
                m_toolbar->changeItem(VAPP_MSG_FOLDER_TOOL_BAR_MS_SELECT_ALL, VCP_STR_TOOL_BAR_UNSELECT_ALL, VCP_IMG_TOOL_BAR_COMMON_ITEM_UNSELECT_ALL);
            }
            else
            {
                m_toolbar->changeItem(VAPP_MSG_FOLDER_TOOL_BAR_MS_SELECT_ALL, VCP_STR_TOOL_BAR_SELECT_ALL, VCP_IMG_TOOL_BAR_COMMON_ITEM_SELECT_ALL);
            }
        }
    }
}

void VappMsgFolderPage::onMsgListUpdated(VfxObject *obj)
{
    VFX_ASSERT(NULL != m_list);

    m_isTitleValid = VFX_FALSE;
     /* need reset */
    m_isNeedReset = VFX_TRUE;
    m_isStartEnter = VFX_FALSE;
    checkUpdate();

    if (NULL != m_contextMenu)
    {
        m_contextMenu->exit(VFX_TRUE);
        m_contextMenu = NULL;
    }
    updateMsToolbar();
}

void VappMsgFolderPage::onSingleMsgUpdated(VfxObject * obj,VfxU32 index)
{
    /* update single item */
    m_listMenu->updateItem(index);
    if (VFX_TRUE == m_isStartEnter)
    {
        /* need to entry new page */
        checkUpdate();
    }
    /* if it is inbox, update the title if necessary */
    if (SRV_UM_MSG_BOX_INBOX == m_boxId.msg_box_type)
    {
        setTitle(m_list->getCount(), getUnreadCount(), VFX_TRUE);
    }
}

void VappMsgFolderPage::onMsOpResult(VfxObject * obj, VfxU32 success, VfxU32 fail, VfxS32 error)
{
    VFX_ASSERT(NULL != m_list);

    /* close processing */
    if (0 != fail || SRV_UM_RESULT_OK != error)
    {
        m_msProcessLoading->setProgress(0);
        m_msProcessLoading->hide(VFX_TRUE);
    }
    else
    {
        m_msProcessLoading->setProgress(1.0f);
        m_msProcessLoading->hide(VFX_TRUE);
    }

    m_msProcessTimer->stop();
    stopLoading();
    m_isBlockUpdate = VFX_FALSE;

    m_isTitleValid = VFX_FALSE;
    m_mode = VAPP_MSG_FOLDER_MODE_NORMAL;
    m_isSetNewMode = VFX_TRUE;

    VcpConfirmPopup *result;
    if (0 != fail || SRV_UM_RESULT_OK != error)
    {
        VFX_OBJ_CREATE(result, VcpConfirmPopup, this);
        result->setButtonSet(VCP_CONFIRM_BUTTON_SET_OK);
        result->setInfoType(VCP_POPUP_TYPE_FAILURE);
        if (SRV_UM_MARK_SEVERAL_OP_ACTION_DELETE == m_msOpAction)
        {
            result->setText(STR_ID_VAPP_MSG_FAIL_TO_DELETE);
        }
        else
        {
            result->setText(STR_ID_VAPP_MSG_FAIL_TO_COPY);
        }
        result->show(VFX_TRUE);
    }

    m_msOpAction = SRV_UM_MARK_SEVERAL_OP_ACTION_NONE;
    checkUpdate();
}

void VappMsgFolderPage::onListItemTapped(VcpListMenu *listMenu, VfxU32 index)
{
    // while refresh ind is during in pen_down and pen_up, there will be no list, just return
    if (MMI_FALSE == m_list->checkMsgList())
    {
        return;
    }
    if (VAPP_MSG_FOLDER_MODE_NORMAL == m_mode)
    {
        if (VAPP_MSG_FOLDER_TYPE_NORMAL == m_style || 
            VAPP_MSG_FOLDER_TYPE_LITE == m_style)
        {
            #ifdef __MMI_UM_BOX_LIST_SUPPORT__
            if (SRV_UM_MSG_BOX_DRAFT == m_boxId.msg_box_type)
            {
            #ifdef __MMI_MMS_IN_UM__
                if (SRV_UM_MSG_MMS == m_list->getMsgType(index) &&
                    (MMI_TRUE == srv_mms_is_corrupted_mms(m_list->getMsgId(index)) ||
                     MMI_TRUE == srv_mms_is_forward_lock(m_list->getMsgId(index))
                    )
                   )
                {
                    /* If MMS is corrupted, other api will be useless */
                    if (MMI_FALSE == srv_mms_is_corrupted_mms(m_list->getMsgId(index)) &&
                        MMI_TRUE == srv_mms_is_forward_lock(m_list->getMsgId(index)))
                    {
                        /* display a balloon */
                        mmi_frm_nmgr_balloon(MMI_SCENARIO_ID_DEFAULT, MMI_EVENT_INFO_BALLOON, MMI_NMGR_BALLOON_TYPE_INFO, VFX_WSTR_RES(STR_ID_VAPP_MSG_DRM_MMS_CANNOT_EDIT));
                    }
                    return;
                }
            #endif /* __MMI_MMS_IN_UM__ */
                // entry UC editor
                mmi_id cuiId = GRP_ID_INVALID;
            #ifdef __MMI_UNIFIED_COMPOSER__
                VfxU16 displayString = 0;
                VappUcEntryStruct *ucInfo;
                VFX_ALLOC_MEM(ucInfo, sizeof(VappUcEntryStruct), this);
                vfx_sys_mem_zero(ucInfo, sizeof(VappUcEntryStruct));
                ucInfo->info_type = transferUcType(m_list->getMsgType(index));
                ucInfo->msg_id = m_list->getMsgId(index);
                ucInfo->type = SRV_UC_STATE_EDIT_EXISTED_MSG;
                ucInfo->operation = UC_OPERATION_EDIT_EXISTED_MSG;
            #ifdef __MMI_MMS_IN_UM__
                if (SRV_UM_MSG_MMS == m_list->getMsgType(index))
                {
                    ucInfo->mode = MMA_MODE_EDIT;
                    isNeedConfirm = vapp_mms_is_need_show_edit_cnfm(m_list->getMsgId(index), &displayString);
                }
            #endif /* __MMI_MMS_IN_UM__ */
                if (VFX_TRUE == isNeedConfirm)
                {
                    // record the data
                    VFX_FREE_MEM(m_actionPtr);
                    VFX_ALLOC_MEM(m_actionPtr, sizeof(VappUcEntryStruct), this);
                    vfx_sys_mem_zero(m_actionPtr, sizeof(VappUcEntryStruct));
                    vfx_sys_mem_copy(m_actionPtr, ucInfo, sizeof(VappUcEntryStruct));
                    /* display restricted confirm */
                    VFX_DEV_ASSERT(NULL == m_confirmPopup);
                    VFX_OBJ_CREATE(m_confirmPopup, VcpConfirmPopup, this);
                    m_confirmPopup->setText(displayString);
                    m_confirmPopup->setInfoType(VCP_POPUP_TYPE_WARNING);
                    m_confirmPopup->setButtonSet(VCP_CONFIRM_BUTTON_SET_YES_NO);
                    m_confirmPopup->setCustomButton(
                                STR_GLOBAL_CONTINUE, 
                                STR_GLOBAL_CANCEL, 
                                VCP_POPUP_BUTTON_TYPE_NORMAL, 
                                VCP_POPUP_BUTTON_TYPE_CANCEL);
                    m_confirmPopup->m_signalButtonClicked.connect(this, &VappMsgFolderPage::onRestrictConfirmClicked);
                    m_confirmPopup->show(VFX_TRUE);
                }
                else
                {
                    cuiId = vcui_unifiedcomposer_create(getApp()->getGroupId(), ucInfo);
                    if (cuiId != GRP_ID_INVALID)
                    {
                        vfxSetCuiCallerScr(cuiId, getMainScr());
                        vcui_unifiedcomposer_run(cuiId);
                    }
                }
                VFX_FREE_MEM(ucInfo);
            #endif
            #ifdef __MMI_SMS_COMPOSER__            
                VcuiSmsComposerEntryStruct *entryData;
                VFX_ALLOC_MEM(entryData, sizeof(VcuiSmsComposerEntryStruct), this);
                vfx_sys_mem_zero(entryData, sizeof(VcuiSmsComposerEntryStruct));
                entryData->msg_id = m_list->getMsgId(index);
                entryData->operation = VCUI_SMS_COMPOSER_OPERATION_EDIT;                
                    
                cuiId = vcui_sms_composer_create(getApp()->getGroupId());
                if (cuiId != GRP_ID_INVALID)
                {
                    vfxSetCuiCallerScr(cuiId, getMainScr());
                    vcui_sms_composer_set_entry_data(cuiId, entryData);
                        
                    vcui_sms_composer_run(cuiId);
                }
                VFX_FREE_MEM(entryData);
            #endif
            }
            else
            #endif /* __MMI_UM_BOX_LIST_SUPPORT__ */    
            {
                srv_sms_send_status_enum smsStatus = SRV_SMS_SEND_INVALID;
            #ifdef __MMI_MMS_IN_UM__
                srv_mms_msg_status_enum mmsStatus = SRV_MMS_MSG_STATUS_NONE;
            #endif /* __MMI_MMS_IN_UM__ */
                if (SRV_UM_MSG_SMS == m_list->getMsgType(index))
                {
                    smsStatus = srv_sms_get_unsent_msg_status(m_list->getMsgId(index));
                }
            #ifdef __MMI_MMS_IN_UM__
                else if (SRV_UM_MSG_MMS == m_list->getMsgType(index))
                {
                    mmsStatus = srv_mms_get_msg_status(m_list->getMsgId(index));
                }
            #endif /* __MMI_MMS_IN_UM__ */
                // sms : sending/waiting, mms : sending => do nothing
                if (SRV_SMS_SEND_SENDING != smsStatus
                    && SRV_SMS_SEND_WAITING != smsStatus 
                #ifdef __MMI_MMS_IN_UM__
                    && SRV_MMS_MSG_STATUS_SENDING != mmsStatus
                    && SRV_MMS_MSG_STATUS_WAITING != mmsStatus
                    && SRV_MMS_MSG_STATUS_PENDING != mmsStatus
                #endif /* __MMI_MMS_IN_UM__ */
                   )
                {
                    // entry viewer page
                    VfxPage *page = NULL;
                    page = createViewerPage(m_list->getMsgId(index), m_list->getMsgType(index));
                    getMainScr()->pushPage(VappMsgScreen::VAPP_MSG_SCREEN_PAGE_VIEWER, page);
                }
            }
        }
        else
        {
            // get the detail info of tapped item
            srv_um_msg_info_struct *msgInfo = NULL;
            srv_um_thread_info_struct *threadInfo = NULL;
            VfxBool result = VFX_FALSE;

            result = m_list->getMsgInfo(index, msgInfo, threadInfo);
            m_isStartEnter = VFX_TRUE;
            m_enterIndex = index;
            if (VFX_FALSE == result)
            {
                /* lock all cps */
                m_listMenu->setIsUnhittable(VFX_TRUE);
                if (NULL != m_toolbar)
                {
                    m_toolbar->setIsUnhittable(VFX_TRUE);
                }
            }
        }
    }
    checkUpdate();
}

void VappMsgFolderPage::onListItemSelected(VcpListMenu * listMenu, VfxU32 index, VcpListMenuItemStateEnum state)
{
    if (VAPP_MSG_FOLDER_MODE_MS == m_mode)
    {
        /* current state */
        if (VCP_LIST_MENU_ITEM_STATE_UNSELECTED == state)
        {
            m_list->setMarkStatus(index, VFX_FALSE);
        }
        else if (VCP_LIST_MENU_ITEM_STATE_SELECTED == state)
        {
            m_list->setMarkStatus(index, VFX_TRUE);
        }
        updateMsToolbar();
    }
}

void VappMsgFolderPage::onListItemLongPressed(VcpListMenu * listMenu, VfxU32 index)
{
    srv_um_msg_info_struct *msgInfo = NULL;
    VfxBool result = VFX_FALSE;

    if (VAPP_MSG_FOLDER_MODE_MS == m_mode)
    {
        return;
    }

    // while refresh ind is during in pen_down and pen_up, there will be no list, just return
    if (VFX_FALSE == m_list->checkMsgList())
    {
        return;
    }

    // Even if the list exists, there is a possibility that we can not get msg infor immediately,
    // because UM service may not have the chache for the msg infor we want to get.
    if (VFX_FALSE == m_list->getMsgInfo(index, msgInfo))
    {
        return;
    }

    m_isNotification = VFX_FALSE;
    
    if (VAPP_MSG_FOLDER_TYPE_NORMAL == m_style)
    {
        /* this message is pending/waiting, the context will not show */
        if (SRV_UM_MSG_SMS == m_list->getMsgType(index))
        {
            srv_sms_send_status_enum smsSendStatus;
            smsSendStatus = srv_sms_get_unsent_msg_status(m_list->getMsgId(index));
            if (SRV_SMS_SEND_WAITING == smsSendStatus ||
                SRV_SMS_SEND_SENDING == smsSendStatus)
            {
                return;
            }            
        }
#ifdef __MMI_MMS_IN_UM__
        else if (SRV_UM_MSG_MMS == m_list->getMsgType(index))
        {
            srv_mms_msg_status_enum mmsSendStatus;
            mmsSendStatus = srv_mms_get_msg_status(m_list->getMsgId(index));
            if (SRV_MMS_MSG_STATUS_SENDING == mmsSendStatus ||
                SRV_MMS_MSG_STATUS_WAITING == mmsSendStatus ||
                SRV_MMS_MSG_STATUS_PENDING == mmsSendStatus)
            {
                return;
            }
        }
#endif /* __MMI_MMS_IN_UM__ */
    }
#ifdef __MMI_MMS_IN_UM__
#ifndef __MMI_MMS_REPORT_STATUS_SUPPORT__
    else
    {
        srv_um_thread_info_struct* threadInfo = NULL;
        result = m_list->getMsgInfo(index, msgInfo, threadInfo);
        if (result)
        {
            if (SRV_UM_MSG_MMS == threadInfo->list_head.msg_type)
            {
                if (srv_mms_is_delivery_report(threadInfo->list_head.msg_id))
                {
                    m_isNotification = VFX_TRUE;
                }
            }
        }
    }
#endif /* __MMI_MMS_REPORT_STATUS_SUPPORT__ */
#endif /* __MMI_MMS_IN_UM__ */

    VFX_OBJ_CLOSE(m_contextMenu);
    VFX_OBJ_CREATE(m_contextMenu, VcpMenuPopup, this);
    m_contextMenu->setTitle(STR_ID_VAPP_MSG_MSG_OPTION);
    switch (m_style)
    {
        case VAPP_MSG_FOLDER_TYPE_NORMAL:
            createContextItem(m_contextMenu, m_boxId.msg_box_type, m_list->getMsgType(index), m_list->getMsgId(index), index);
            break;

        case VAPP_MSG_FOLDER_TYPE_CONVERSATION:
        {
        #ifdef __MMI_UM_CONVERSATION_BOX__

            result = m_list->getMsgInfo(index, msgInfo);
            VFX_ASSERT(VFX_TRUE == result);
            if (SRV_UM_ADDR_PHONE_NUMBER == msgInfo->address_type &&
                1 == msgInfo->address_number && 
                0 != msgInfo->address_length)
            {
                VfxWString text;
                text.loadFromRes(STR_GLOBAL_DIAL);
                text += VFX_WSTR(" ");
                text += transferSingle2PhbName(msgInfo->address);

                createContextSingleItem(
                    m_contextMenu, 
                    VAPP_MSG_FOLDER_LP_TYPE_CALL, 
                    text, 
                    m_list->getThreadIdType(index), 
                    m_list->getThreadIdValue(index), 
                    index);
            }
            createContextSingleItem(
                m_contextMenu, 
                VAPP_MSG_FOLDER_LP_TYPE_DELETE, 
                VFX_WSTR_RES(STR_GLOBAL_DELETE), 
                m_list->getThreadIdType(index), 
                m_list->getThreadIdValue(index), 
                index);
        #endif /* __MMI_UM_CONVERSATION_BOX__ */
        }
            break;

        case VAPP_MSG_FOLDER_TYPE_LITE:
            /* only support inbox now */
            if (SRV_UM_MSG_BOX_INBOX == m_boxId.msg_box_type)
            {
                createContextSingleItem(
                    m_contextMenu, 
                    VAPP_MSG_FOLDER_LP_TYPE_FORWARD, 
                    VFX_WSTR_RES(STR_GLOBAL_FORWARD), 
                    m_list->getMsgId(index), 
                    m_list->getMsgType(index), 
                    index);
                createContextSingleItem(
                    m_contextMenu, 
                    VAPP_MSG_FOLDER_LP_TYPE_DELETE, 
                    VFX_WSTR_RES(STR_GLOBAL_DELETE), 
                    m_list->getMsgId(index), 
                    m_list->getMsgType(index), 
                    index);
            }
            else
            {
                VFX_ASSERT(0);
            }
            break;

        default:
            VFX_ASSERT(0);
            break;
    }
    m_contextMenu->m_signalMenuCallback.connect(this, &VappMsgFolderPage::onContextMenuSelected);
    m_contextMenu->showMenu();
    vfx_adp_touch_fb_play(VFX_ADP_TOUCH_FB_TYPE_HOLD);
}

void VappMsgFolderPage::onContextMenuSelected(VcpMenuPopup * menu,  VcpMenuPopupEventEnum event, VcpMenuPopupItem * item)
{
    if (VCP_MENU_POPUP_EVENT_MENU_CLOSE == event)
    {
        /* Because of autoDestory, this pointer will be destory by VcpMenuPopup itself. Just need to set as NULL */
        m_contextMenu = NULL;
    }
    if (VCP_MENU_POPUP_EVENT_ITEM_SELECTED != event)
    {
        return;
    }

    /* action */
    VappMsgCntxOptItemCp *cntxItem;
    cntxItem = VFX_OBJ_DYNAMIC_CAST(item, VappMsgCntxOptItemCp);
    VFX_ASSERT(NULL != cntxItem);

    switch (cntxItem->getId())
    {
        case VAPP_MSG_FOLDER_LP_TYPE_DELETE:
            longpressDelete(cntxItem);
            break;

        case VAPP_MSG_FOLDER_LP_TYPE_CALL:
            longpressCall(cntxItem);
            break;
#ifdef __MMI_UM_BOX_LIST_SUPPORT__
        case VAPP_MSG_FOLDER_LP_TYPE_FORWARD:
            longpressForward(cntxItem);
            break;

        case VAPP_MSG_FOLDER_LP_TYPE_RESEND:
            longpressResend(cntxItem);
            break;
#endif /* __MMI_UM_BOX_LIST_SUPPORT__ */

        case VAPP_MSG_FOLDER_LP_TYPE_EDIT:
            longpressEdit(cntxItem);
            break;

#ifdef __MMI_UM_BOX_LIST_SUPPORT__
        case VAPP_MSG_FOLDER_LP_TYPE_VIEW_WEBSITE:
            longpressViewWebsite(cntxItem);
            break;

        case VAPP_MSG_FOLDER_LP_TYPE_INSTALL:
            longpressInstall(cntxItem);
            break;
#endif /* __MMI_UM_BOX_LIST_SUPPORT__ */

        case VAPP_MSG_FOLDER_LP_TYPE_USE:
            longpressUse(cntxItem);
            break;

        default:
            VFX_ASSERT(0);
            break;
    }
}

void VappMsgFolderPage::onLpActionClicked(VfxObject * obj, VfxId id)
{
    // only delete action now
    /* show processing */
    if (VCP_CONFIRM_POPUP_BUTTON_YES == id)
    {
        m_msProcessLoading->setText(STR_GLOBAL_DELETING);
        m_msProcessLoading->setInfoType(VCP_INDICATOR_POPUP_STYLE_ACTIVITY);
        m_msProcessLoading->setProgress(0);
        m_msProcessLoading->show(VFX_TRUE);
        m_msOpAction = SRV_UM_MARK_SEVERAL_OP_ACTION_DELETE;
        m_list->deleteMarked();
        m_isNeedReset = VFX_TRUE;
        checkUpdate();
    }
    else
    {
        m_list->setMarkAll(VFX_FALSE);
    }

    /* auto destory, just set as NULL */
    m_confirmPopup = NULL;
}

void VappMsgFolderPage::onToolbarClick(VfxObject * obj, VfxId id)
{
    switch (id)
    {
        case VAPP_MSG_FOLDER_TOOL_BAR_NEW_MSG:
            toolbarNewMsg();
            break;
#ifdef __MMI_UM_TEMPLATE_SUPPORT__
        case VAPP_MSG_FOLDER_TOOL_BAR_ADD_TEMPLATE:
            toolbarAddTemplate();
            break;
#endif /* __MMI_UM_TEMPLATE_SUPPORT__ */
        case VAPP_MSG_FOLDER_TOOL_BAR_COPY_TO_INBOX:
            toolbarCopy2Inbox();
            break;

        case VAPP_MSG_FOLDER_TOOL_BAR_DELETE:
            toolbarDelete();
            break;
#ifdef __UNIFIED_MESSAGE_ARCHIVE_SUPPORT__
        case VAPP_MSG_FOLDER_TOOL_BAR_ARCHIVE:
            toolbarArchive();
            break;
#endif
        case VAPP_MSG_FOLDER_TOOL_BAR_SIM_MSG:
            toolbarSimMsg();
            break;

        case VAPP_MSG_FOLDER_TOOL_BAR_SETTING:
            toolbarSetting();
            break;
#ifdef __MMI_UM_BOX_LIST_SUPPORT__
        case VAPP_MSG_FOLDER_TOOL_BAR_COPY:
            toolbarCopy();
            break;
#endif /* __MMI_UM_BOX_LIST_SUPPORT__ */            
#ifdef __UNIFIED_MESSAGE_SORT_MESSAGE_LIST__
        case VAPP_MSG_FOLDER_TOOL_BAR_SORT:
            toolbarSort();
            break;
#endif /* __UNIFIED_MESSAGE_SORT_MESSAGE_LIST__ */

        case VAPP_MSG_FOLDER_TOOL_BAR_MS_SELECT_ALL:
            toolbarMsSelectAll();
            break;

        case VAPP_MSG_FOLDER_TOOL_BAR_MS_DELETE:
            toolbarMsDelete();
            break;

        case VAPP_MSG_FOLDER_TOOL_BAR_MS_COPY:
            toolbarMsCopy();
            break;

        case VAPP_MSG_FOLDER_TOOL_BAR_MS_CANCEL:
            toolbarMsCancel();
            break;

        default:
            break;
    }
}

void VappMsgFolderPage::onMsActionClicked(VfxObject * obj, VfxId id)
{
    VFX_ASSERT(NULL != m_list);
    VfxU32 displayStringRes = STR_GLOBAL_COPYING;

    switch (id)
    {
        case VCP_CONFIRM_POPUP_BUTTON_YES:
            /* start to process */
            switch (m_msOpAction)
            {
                case SRV_UM_MARK_SEVERAL_OP_ACTION_DELETE:
                    displayStringRes = STR_GLOBAL_DELETING;
                    m_list->deleteMarked();
                    m_isNeedReset = VFX_TRUE;
                    checkUpdate();
                    break;
#ifdef __MMI_UM_BOX_LIST_SUPPORT__
                case SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_ARCHIVE:
                case SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_SIM1:
            #if (MMI_MAX_SIM_NUM >= 2)
                case SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_SIM2:
            #endif /* MMI_MAX_SIM_NUM >= 2 */
            #if (MMI_MAX_SIM_NUM >= 3)
                case SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_SIM3:
            #endif /* MMI_MAX_SIM_NUM >= 3 */
            #if (MMI_MAX_SIM_NUM >= 4)
                case SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_SIM4:
            #endif /* MMI_MAX_SIM_NUM >= 4 */
                case SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_MEMORY_CARD:
#endif  /* __MMI_UM_BOX_LIST_SUPPORT__ */                  
                case SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_PHONE:
                
                    m_list->copyMarked(getTransMsMsgListCopyType());
                    break;

                default:
                    VFX_ASSERT(0);
                    break;
            }
            /* show processing */
            m_msProcessLoading->setText(displayStringRes);
            m_msProcessLoading->setInfoType(VCP_INDICATOR_POPUP_STYLE_PROGRESS_WITH_CANCEL_BUTTON);
            m_msProcessLoading->setProgress(0);
            m_msProcessLoading->show(VFX_TRUE);
            /* start a timer to update the process */
            m_msProcessTimer->start();
            break;

        case VCP_CONFIRM_POPUP_BUTTON_NO:
            break;

        default:
            break;
    }

    /* auto destory, just set as NULL */
    m_confirmPopup = NULL;
}

void VappMsgFolderPage::onMsOpCancelled(VfxObject * obj, VfxFloat progress)
{
    VFX_ASSERT(NULL != m_list);
    if (SRV_UM_MARK_SEVERAL_OP_ACTION_NONE == m_msOpAction)
    {
        /* already finished */
        return;
    }

    //m_msOpAction = SRV_UM_MARK_SEVERAL_OP_ACTION_NONE;
    m_msgCopyFilter.msg_box = SRV_UM_MSG_BOX_NONE;
    m_msgCopyFilter.msg_type = SRV_UM_MSG_NONE;
    m_msgCopyFilter.msg_storage = VAPP_MSG_STORAGE_NONE;
    
    m_list->cancelMsAction();

    m_msProcessLoading->hide(VFX_TRUE);
    m_msProcessTimer->stop();
    showLoading();
    m_isBlockUpdate = VFX_TRUE;
}

void VappMsgFolderPage::onCopyCmdClicked(VfxObject * obj, VfxId id)
{    
#ifdef __MMI_UM_BOX_LIST_SUPPORT__ 
    switch (id)
    {   
        case VAPP_MSG_FOLDER_COPY_TO_ARCHIVE:
        {
            m_msOpAction = SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_ARCHIVE;
            setMode(VAPP_MSG_FOLDER_MODE_MS);
            break;
        }

        case VAPP_MSG_FOLDER_COPY_SMS_TO_SIM1:
        {
            m_msOpAction = SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_SIM1;
            m_msgCopyFilter.msg_box = SRV_UM_MSG_BOX_ALL;
            m_msgCopyFilter.msg_type = SRV_UM_MSG_SMS;
            m_msgCopyFilter.msg_storage = VAPP_MSG_STORAGE_PHONE_AND_MEMORY;
            setMode(VAPP_MSG_FOLDER_MODE_MS);
            break;
        }

    #if (MMI_MAX_SIM_NUM >= 2)
        case VAPP_MSG_FOLDER_COPY_SMS_TO_SIM2:
        {
            m_msOpAction = SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_SIM2;
            m_msgCopyFilter.msg_box = SRV_UM_MSG_BOX_ALL;
            m_msgCopyFilter.msg_type = SRV_UM_MSG_SMS;
            m_msgCopyFilter.msg_storage = VAPP_MSG_STORAGE_PHONE_AND_MEMORY;
            setMode(VAPP_MSG_FOLDER_MODE_MS);
            break;
        }
    #endif /* MMI_MAX_SIM_NUM >= 2 */

    #if (MMI_MAX_SIM_NUM >= 3)
        case VAPP_MSG_FOLDER_COPY_SMS_TO_SIM3:
        {
            m_msOpAction = SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_SIM3;
            m_msgCopyFilter.msg_box = SRV_UM_MSG_BOX_ALL;
            m_msgCopyFilter.msg_type = SRV_UM_MSG_SMS;
            m_msgCopyFilter.msg_storage = VAPP_MSG_STORAGE_PHONE_AND_MEMORY;
            setMode(VAPP_MSG_FOLDER_MODE_MS);
            break;
        }
    #endif /* MMI_MAX_SIM_NUM >= 3 */

    #if (MMI_MAX_SIM_NUM >= 4)
        case VAPP_MSG_FOLDER_COPY_SMS_TO_SIM4:
        {
            m_msOpAction = SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_SIM4;
            m_msgCopyFilter.msg_box = SRV_UM_MSG_BOX_ALL;
            m_msgCopyFilter.msg_type = SRV_UM_MSG_SMS;
            m_msgCopyFilter.msg_storage = VAPP_MSG_STORAGE_PHONE_AND_MEMORY;
            setMode(VAPP_MSG_FOLDER_MODE_MS);
            break;
        }
    #endif /* MMI_MAX_SIM_NUM >= 4 */

    #if (MMI_MAX_SIM_NUM >= 2)
        case VAPP_MSG_FOLDER_COPY_SMS_TO_SIM_SELECT:
        {
            /* show another VcpCommandPopup to select */
            U16 index = 0;
            U16 copyId = VAPP_MSG_FOLDER_COPY_SMS_TO_SIM1;
            mmi_sim_enum sim = MMI_SIM1;
            VcpCommandPopup *cmdPopup;
            VFX_OBJ_CREATE(cmdPopup, VcpCommandPopup, this);
            cmdPopup->setText(STR_ID_VAPP_MSG_COPY_SMS_TO_SIM);
            for (index = 0 ; index < MMI_MAX_SIM_NUM ; index++, copyId++, sim = (mmi_sim_enum)(sim << 1))
            {
                if (MMI_TRUE == srv_sim_ctrl_is_inserted(sim))
                {
                    cmdPopup->addItem(copyId, vapp_sim_settings_get_sim_name_with_sim_id(sim), VCP_POPUP_BUTTON_TYPE_NORMAL);
                }
            }
            cmdPopup->addItem(VAPP_MSG_FOLDER_COPY_CANCEL, STR_GLOBAL_CANCEL, VCP_POPUP_BUTTON_TYPE_CANCEL);
            cmdPopup->m_signalButtonClicked.connect(this, &VappMsgFolderPage::onCopyCmdClicked);
            cmdPopup->show(VFX_TRUE);
            m_msOpAction = SRV_UM_MARK_SEVERAL_OP_ACTION_NONE;
            m_msgCopyFilter.msg_box = SRV_UM_MSG_BOX_NONE;
            m_msgCopyFilter.msg_type = SRV_UM_MSG_NONE;
            m_msgCopyFilter.msg_storage = VAPP_MSG_STORAGE_NONE;
            break;
        }
    #endif /* MMI_MAX_SIM_NUM >= 2 */

    #ifdef __MMI_SMS_TCARD_STORAGE_SUPPORT__
        case VAPP_MSG_FOLDER_COPY_SMS_TO_PHONE:
        {
            m_msOpAction = SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_PHONE;
            m_msgCopyFilter.msg_box = SRV_UM_MSG_BOX_ALL;
            m_msgCopyFilter.msg_type = SRV_UM_MSG_SMS;
            m_msgCopyFilter.msg_storage = VAPP_MSG_STORAGE_MEMORY_CARD;
            setMode(VAPP_MSG_FOLDER_MODE_MS);
            break;
        }
            
        case VAPP_MSG_FOLDER_COPY_SMS_TO_MEMORY_CARD:
        {
            m_msOpAction = SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_MEMORY_CARD;
            m_msgCopyFilter.msg_box = SRV_UM_MSG_BOX_ALL;
            m_msgCopyFilter.msg_type = SRV_UM_MSG_SMS;
            m_msgCopyFilter.msg_storage = VAPP_MSG_STORAGE_PHONE;
            setMode(VAPP_MSG_FOLDER_MODE_MS);
            break;
        }
    #endif /* __MMI_SMS_TCARD_STORAGE_SUPPORT__ */

        case VAPP_MSG_FOLDER_COPY_MMS_TO_PHONE:
        {
            m_msOpAction = SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_PHONE;
            m_msgCopyFilter.msg_box = SRV_UM_MSG_BOX_ALL;
            m_msgCopyFilter.msg_type = SRV_UM_MSG_MMS;
            m_msgCopyFilter.msg_storage = VAPP_MSG_STORAGE_MEMORY_CARD;
            setMode(VAPP_MSG_FOLDER_MODE_MS);
            break;
        }

        case VAPP_MSG_FOLDER_COPY_MMS_TO_MEMORY_CARD:
        {
            m_msOpAction = SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_MEMORY_CARD;
            m_msgCopyFilter.msg_box = SRV_UM_MSG_BOX_ALL;
            m_msgCopyFilter.msg_type = SRV_UM_MSG_MMS;
            m_msgCopyFilter.msg_storage = VAPP_MSG_STORAGE_PHONE;
            setMode(VAPP_MSG_FOLDER_MODE_MS);
            break;
        }

        default:
        {
            m_msOpAction = SRV_UM_MARK_SEVERAL_OP_ACTION_NONE;
            m_msgCopyFilter.msg_box = SRV_UM_MSG_BOX_NONE;
            m_msgCopyFilter.msg_type = SRV_UM_MSG_NONE;
            m_msgCopyFilter.msg_storage = VAPP_MSG_STORAGE_NONE;
            break;
        }
    }
#endif  /* __MMI_UM_BOX_LIST_SUPPORT__ */
}

#ifdef __UNIFIED_MESSAGE_SORT_MESSAGE_LIST__
void VappMsgFolderPage::onSortCmdClicked(VfxObject * obj, VfxId id)
{
    if ((SRV_UM_LIST_IDX_TOTAL + 1) == id ||
        VCP_POPUP_BUTTON_NO_PRESSED == id)
    {
        /* cancel */
        return;
    }

    /* always re-sort due to some status changed maybe */
    m_listFilter.idx_type = (srv_um_list_idx_enum) (id - 1);
    if ((m_listFilter.idx_type < SRV_UM_LIST_IDX_TIMESTAMP) || (m_listFilter.idx_type >= SRV_UM_LIST_IDX_TOTAL))
    {
        VFX_ASSERT(0);
    }
    m_listMenu->updateLayout();
    
    m_list->setSortType(m_listFilter.idx_type);
    checkUpdate();
}
#endif /* __UNIFIED_MESSAGE_SORT_MESSAGE_LIST__ */

#if (MMI_MAX_SIM_NUM >= 2)
void VappMsgFolderPage::onSimCmdClicked(VfxObject * obj, VfxId id)
{
    if (VAPP_MSG_FOLDER_SIM_CANCEL == id ||
        VCP_POPUP_BUTTON_NO_PRESSED == id)
    {
        return;
    }

    srv_um_sim_enum sim = SRV_UM_SIM_GSM_SIM1;
    switch (id)
    {
        case VAPP_MSG_FOLDER_SIM_2:
            sim = SRV_UM_SIM_GSM_SIM2;
            break;

    #if (MMI_MAX_SIM_NUM >= 3)
        case VAPP_MSG_FOLDER_SIM_3:
            sim = SRV_UM_SIM_GSM_SIM3;
            break;
    #endif /* MMI_MAX_SIM_NUM >= 3 */

    #if (MMI_MAX_SIM_NUM >= 4)
        case VAPP_MSG_FOLDER_SIM_4:
            sim = SRV_UM_SIM_GSM_SIM4;
            break;
    #endif /* MMI_MAX_SIM_NUM >= 4 */

        default:
            break;
    }

    VappMsgFolderPage *page;
    VFX_OBJ_CREATE_EX(page, VappMsgFolderPage, getMainScr(), (SRV_UM_MSG_ALL, SRV_UM_MSG_BOX_SIM, (VfxU32)sim));
    getMainScr()->pushPage(VappMsgScreen::VAPP_MSG_SCREEN_PAGE_SIM_MSG, page);
}
#endif /* MMI_MAX_SIM_NUM >= 2 */

void VappMsgFolderPage::onMsProgressTimeout(VfxTimer * timer)
{
    if (VFX_TRUE == m_list->getIsMsActionActive())
    {
        // update the process screen
        VfxS32 finishNum, totalNum;
        finishNum = totalNum = 0;
        m_list->getMsActionDuriation(finishNum, totalNum);
        // update it
        m_msProcessLoading->setProgress((VfxFloat)finishNum/(VfxFloat)totalNum);
    }
    else
    {
        m_msProcessTimer->stop();
    }
}

#ifdef __MMI_UM_BOX_LIST_SUPPORT__

void VappMsgFolderPage::onPushViewWebsiteCb()
{
    stopLoading();
    m_isBlockUpdate = VFX_FALSE;
    checkUpdate();
}

#ifdef __MMI_PROV_IN_UM__
MMI_BOOL VappMsgFolderPage::onProvInstallCb(void * userData)
{
    VappMsgFolderPage *self = (VappMsgFolderPage *)VfxObject::handleToObject((VfxObjHandle)userData);

    if (self)
    {
        VFX_DEV_ASSERT(self->isKindOf(VFX_OBJ_CLASS_INFO(VappMsgFolderPage)));

        if (self->isKindOf(VFX_OBJ_CLASS_INFO(VappMsgFolderPage)))
        {
            self->stopLoading();
            self->m_isBlockUpdate = VFX_FALSE;
            self->checkUpdate();
        }
    }

    return MMI_TRUE;
}
#endif /* __MMI_PROV_IN_UM__ */

#endif /* __MMI_UM_BOX_LIST_SUPPORT__ */

mmi_ret VappMsgFolderPage::onPhbSrvEvt(mmi_event_struct * param)
{
    VappMsgFolderPage *self = (VappMsgFolderPage *)VfxObject::handleToObject((VfxObjHandle)param->user_data);

    if (self)
    {
        VFX_DEV_ASSERT(self->isKindOf(VFX_OBJ_CLASS_INFO(VappMsgFolderPage)));

        if (self->isKindOf(VFX_OBJ_CLASS_INFO(VappMsgFolderPage)))
        {
            /* update all items because of PHB contact change */
            self->m_listMenu->updateAllItems();
        }
    }

    return MMI_RET_OK;
}

#ifdef __MMI_USB_SUPPORT__
mmi_ret VappMsgFolderPage::onMsModeEvt(mmi_event_struct * param)
{
    VappMsgFolderPage *self = (VappMsgFolderPage *)VfxObject::handleToObject((VfxObjHandle)param->user_data);

    if (self)
    {
        VFX_DEV_ASSERT(self->isKindOf(VFX_OBJ_CLASS_INFO(VappMsgFolderPage)));

        if (self->isKindOf(VFX_OBJ_CLASS_INFO(VappMsgFolderPage)))
        {
        #ifdef __MMI_MMS_IN_UM__
            /* entry ms storage mode, close confirm if exist */
            if (SRV_UM_MSG_MMS == self->m_boxId.msg_type &&
                (SRV_UM_MSG_BOX_PREDEF_TEMPLATES | SRV_UM_MSG_BOX_USRDEF_TEMPLATES) == self->m_boxId.msg_box_type)
            {
                if (NULL != self->m_confirmPopup)
                {
                    self->m_confirmPopup->exit(VFX_TRUE);
                    self->m_confirmPopup = NULL;
                }
                if (NULL != self->m_contextMenu)
                {
                    self->m_contextMenu->exit(VFX_TRUE);
                    self->m_contextMenu = NULL;
                }
            }
        #endif /* __MMI_MMS_IN_UM__ */
        }
    }

    return MMI_RET_OK;
}
#endif /* __MMI_USB_SUPPORT__ */

void VappMsgFolderPage::onRestrictConfirmClicked(VfxObject * obj,VfxId id)
{
    VFX_ASSERT(NULL != m_actionPtr);
    if (VCP_CONFIRM_POPUP_BUTTON_YES == id)
    {
    	
#ifdef __MMI_UNIFIED_COMPOSER__
        mmi_id cuiId;
        cuiId = vcui_unifiedcomposer_create(getApp()->getGroupId(), (VappUcEntryStruct *)m_actionPtr);
        if (cuiId != GRP_ID_INVALID)
        {
            vfxSetCuiCallerScr(cuiId, getMainScr());
            vcui_unifiedcomposer_run(cuiId);
        }
#endif
    }

    /* auto destory, just set as NULL */
    m_confirmPopup = NULL;
    // free memory
    VFX_FREE_MEM(m_actionPtr);
}

VfxU16 VappMsgFolderPage::tsfrSimCard2StrId(mmi_sim_enum sim)
{
    U16 simStrId = STR_GLOBAL_SIM;

    switch (sim)
    {
        case MMI_SIM1:
            simStrId = STR_GLOBAL_SIM_1;
            break;

    #if (MMI_MAX_SIM_NUM >= 2)
        case MMI_SIM2:
            simStrId = STR_GLOBAL_SIM_2;
            break;
    #endif /* MMI_MAX_SIM_NUM >= 2 */

    #if (MMI_MAX_SIM_NUM >= 3)
        case MMI_SIM3:
            simStrId = STR_GLOBAL_SIM_3;
            break;
    #endif /* MMI_MAX_SIM_NUM >= 3 */

    #if (MMI_MAX_SIM_NUM >= 4)
        case MMI_SIM4:
            simStrId = STR_GLOBAL_SIM_4;
            break;
    #endif /* MMI_MAX_SIM_NUM >= 4 */

        default:
            break;
    }

    return simStrId;
}

mmi_sim_enum VappMsgFolderPage::tsfrUmSim2Sim(srv_um_sim_enum umSim)
{
    mmi_sim_enum sim = MMI_SIM1;

    switch (umSim)
    {
    #if (MMI_MAX_SIM_NUM >= 2)
        case SRV_UM_SIM_GSM_SIM2:
            sim = MMI_SIM2;
            break;
    #endif /* MMI_MAX_SIM_NUM >= 2 */

    #if (MMI_MAX_SIM_NUM >= 3)
        case SRV_UM_SIM_GSM_SIM3:
            sim = MMI_SIM3;
            break;
    #endif /* MMI_MAX_SIM_NUM >= 3 */

    #if (MMI_MAX_SIM_NUM >= 4)
        case SRV_UM_SIM_GSM_SIM4:
            sim = MMI_SIM4;
            break;
    #endif /* MMI_MAX_SIM_NUM >= 4 */

        default:
            break;
    }

    return sim;
}

void VappMsgFolderPage::toolbarNewMsg()
{
    mmi_id cuiId = GRP_ID_INVALID;
#ifdef __MMI_UNIFIED_COMPOSER__
    VappUcEntryStruct *ucInfo;
    VFX_ALLOC_MEM(ucInfo, sizeof(VappUcEntryStruct), this);
    vfx_sys_mem_zero(ucInfo, sizeof(VappUcEntryStruct));

    if (VAPP_MSG_FOLDER_TYPE_LITE == m_style)
    {
        ucInfo->msg_type = SRV_UC_MSG_TYPE_SMS_ONLY;
        ucInfo->type = SRV_UC_STATE_WRITE_NEW_MSG;
        cuiId = vcui_unifiedcomposer_create(getApp()->getGroupId(), ucInfo);
    }
    else
    {
        cuiId = vcui_unifiedcomposer_create(getApp()->getGroupId(), NULL);
    }
    if (cuiId != GRP_ID_INVALID)
    {
        vfxSetCuiCallerScr(cuiId, getMainScr());
        vcui_unifiedcomposer_run(cuiId);
    }
    VFX_FREE_MEM(ucInfo);
    return;
#endif

#ifdef __MMI_SMS_COMPOSER__    
    cuiId = vcui_sms_composer_create(getApp()->getGroupId());
    if (cuiId != GRP_ID_INVALID)
    {
        vfxSetCuiCallerScr(cuiId, getMainScr());
        vcui_sms_composer_run(cuiId);
    }
    return;
#endif
}

#ifdef __MMI_UM_TEMPLATE_SUPPORT__
void VappMsgFolderPage::toolbarAddTemplate()
{
    VfxS32 result;
    VfxU32 numPhone = 0;
    VfxU32 totalPhone = 0;
#ifdef __MMI_MMS_IN_UM__
    srv_mms_get_msg_count_struct msg_count_req;

    vfx_sys_mem_zero(&msg_count_req, sizeof(srv_mms_get_msg_count_struct));
    msg_count_req.count = 1;
    msg_count_req.req_tb[0] = SRV_MMS_QUERY_TOTAL_PHONE_MSG;
    result = srv_mms_get_msg_count(&msg_count_req);
     if (SRV_MMS_RESULT_OK == result)
    {
        numPhone = msg_count_req.rsp_tb[0];
    }
    totalPhone = srv_mms_get_max_mms_num_on_phone();
#endif /* __MMI_MMS_IN_UM__ */
    if (numPhone >= totalPhone)
    {
        /* show a balloon */
        mmi_frm_nmgr_balloon(MMI_SCENARIO_ID_DEFAULT, MMI_EVENT_INFO_BALLOON, MMI_NMGR_BALLOON_TYPE_INFO, VFX_WSTR_RES(STR_ID_VAPP_MSG_MAX_MMS_NUM_REACH));
    }
    else
    {
        mmi_id cuiId = GRP_ID_INVALID;
#ifdef __MMI_UNIFIED_COMPOSER__
        VappUcEntryStruct *ucInfo;
        VFX_ALLOC_MEM(ucInfo, sizeof(VappUcEntryStruct), this);
        vfx_sys_mem_zero(ucInfo, sizeof(VappUcEntryStruct));

        ucInfo->info_type = SRV_UC_INFO_TYPE_MMS;
        ucInfo->type = SRV_UC_STATE_WRITE_NEW_MSG;
        ucInfo->operation = UC_OPERATION_WRITE_NEW_MMS_TEMPLATE;
        cuiId = vcui_unifiedcomposer_create(getApp()->getGroupId(), ucInfo);
        if (cuiId != GRP_ID_INVALID)
        {
            vfxSetCuiCallerScr(cuiId, getMainScr());
            vcui_unifiedcomposer_run(cuiId);
        }
        VFX_FREE_MEM(ucInfo);
#endif
    }
}
#endif /* __MMI_UM_TEMPLATE_SUPPORT__ */

void VappMsgFolderPage::toolbarCopy2Inbox()
{
    srv_sms_sim_enum sms_sim;
    switch (m_boxId.sim_id)
    {
        case SRV_UM_SIM_GSM_SIM1:
        {
            sms_sim = SRV_SMS_SIM_1;
        }
            break;
            
        case SRV_UM_SIM_GSM_SIM2:
        {
            sms_sim = SRV_SMS_SIM_2;
        }
            break;
            
        case SRV_UM_SIM_GSM_SIM3:
        {
            sms_sim = SRV_SMS_SIM_3;
        }
            break;
            
        case SRV_UM_SIM_GSM_SIM4:
        {
            sms_sim = SRV_SMS_SIM_4;
        }
            break;
            
        default:
        {
            sms_sim = SRV_SMS_SIM_TOTAL;
        }
            break;
    }
    if (SRV_SMS_STORAGE_TCARD == srv_sms_get_prefer_storage(sms_sim))
        m_msOpAction = SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_MEMORY_CARD;
    else
        m_msOpAction = SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_PHONE;
    
    m_msgCopyFilter.msg_box = SRV_UM_MSG_BOX_SIM;
    m_msgCopyFilter.msg_type = SRV_UM_MSG_SMS;        
    m_msgCopyFilter.msg_storage = VAPP_MSG_STORAGE_SIM;
    setMode(VAPP_MSG_FOLDER_MODE_MS);
}

void VappMsgFolderPage::toolbarDelete()
{
    m_msOpAction = SRV_UM_MARK_SEVERAL_OP_ACTION_DELETE;
    m_msgCopyFilter.msg_box = SRV_UM_MSG_BOX_ALL;
    m_msgCopyFilter.msg_type = SRV_UM_MSG_ALL;
    m_msgCopyFilter.msg_storage = VAPP_MSG_STORAGE_ALL;
    setMode(VAPP_MSG_FOLDER_MODE_MS);
}

#ifdef __UNIFIED_MESSAGE_ARCHIVE_SUPPORT__
void VappMsgFolderPage::toolbarArchive()
{
#ifdef __MMI_USB_SUPPORT__
    if (MMI_TRUE == srv_usb_is_in_mass_storage_mode())
    {
        vapp_usb_unavailable_popup(0);
    }
    else
#endif /* __MMI_USB_SUPPORT__ */
    {
        VappMsgFolderPage *archive;
        VFX_OBJ_CREATE_EX(archive, VappMsgFolderPage, getMainScr(), (SRV_UM_MSG_ALL, SRV_UM_MSG_BOX_ARCHIVE));
        getMainScr()->pushPage(VappMsgScreen::VAPP_MSG_SCREEN_PAGE_ARCHIVE, archive);
    }
}
#endif /* __UNIFIED_MESSAGE_ARCHIVE_SUPPORT__ */

void VappMsgFolderPage::toolbarSimMsg()
{
#if (MMI_MAX_SIM_NUM >= 2)
    if (2 <= srv_sim_ctrl_get_num_of_inserted())
    {
        /* multiple sims */
        VcpCommandPopup *simCmd;
        VFX_OBJ_CREATE(simCmd, VcpCommandPopup, this);
        simCmd->setText(STR_ID_VAPP_MSG_VIEW_MSG_IN);
        U16 index = 0;
        U16 cmdId = VAPP_MSG_FOLDER_SIM_1;
        mmi_sim_enum sim = MMI_SIM1;
        /* Add all sim buttons */
        for (index = 0; index < MMI_MAX_SIM_NUM ; index++, sim = (mmi_sim_enum)(sim << 1), cmdId++)
        {
            if (MMI_TRUE == srv_sim_ctrl_is_inserted(sim))
            {
                simCmd->addItem(cmdId, vapp_sim_settings_get_sim_name_with_sim_id(sim), VCP_POPUP_BUTTON_TYPE_NORMAL);
            }
        }
        simCmd->addItem(VAPP_MSG_FOLDER_SIM_CANCEL, STR_GLOBAL_CANCEL, VCP_POPUP_BUTTON_TYPE_CANCEL);
        simCmd->m_signalButtonClicked.connect(this, &VappMsgFolderPage::onSimCmdClicked);
        simCmd->show(VFX_TRUE);
    }
    else
#endif /* MMI_MAX_SIM_NUM >= 2 */
    {
    #if (MMI_MAX_SIM_NUM == 1)
        /* single sim */
        VappMsgFolderPage *page;
        VFX_OBJ_CREATE_EX(page, VappMsgFolderPage, getMainScr(), (SRV_UM_MSG_ALL, SRV_UM_MSG_BOX_SIM, SRV_UM_SIM_ALL));
        getMainScr()->pushPage(VappMsgScreen::VAPP_MSG_SCREEN_PAGE_SIM_MSG, page);
    #else /* MMI_MAX_SIM_NUM == 1 */
        /* check if which one inserted */
        U16 index = 0;
        srv_um_sim_enum umSim = SRV_UM_SIM_GSM_SIM1;
        mmi_sim_enum sim = MMI_SIM1;
        /* Add all sim buttons */
        for (index = 0; index < MMI_MAX_SIM_NUM ; index++, sim = (mmi_sim_enum)(sim << 1), umSim = (srv_um_sim_enum)(umSim << 1))
        {
            if (MMI_TRUE == srv_sim_ctrl_is_inserted(sim))
            {
                break;
            }
        }
        VappMsgFolderPage *page;
        VFX_OBJ_CREATE_EX(page, VappMsgFolderPage, getMainScr(), (SRV_UM_MSG_ALL, SRV_UM_MSG_BOX_SIM, (VfxU32)umSim));
        getMainScr()->pushPage(VappMsgScreen::VAPP_MSG_SCREEN_PAGE_SIM_MSG, page);
    #endif /* MMI_MAX_SIM_NUM >= 2 */
    }
}

void VappMsgFolderPage::toolbarSetting()
{
    VappMsgSettingPage *setting;
    VFX_OBJ_CREATE(setting, VappMsgSettingPage, getMainScr());
    getMainScr()->pushPage(VappMsgScreen::VAPP_MSG_SCREEN_PAGE_SETTING, setting);
}

#ifdef __MMI_UM_BOX_LIST_SUPPORT__
void VappMsgFolderPage::toolbarCopy()
{
    VcpCommandPopup *copyCmd;
    VFX_OBJ_CREATE(copyCmd, VcpCommandPopup, this);
    copyCmd->setText(STR_GLOBAL_COPY);
    copyCmd->addItem(VAPP_MSG_FOLDER_COPY_TO_ARCHIVE, STR_ID_VAPP_MSG_COPY_TO_ARCHIVE, VCP_POPUP_BUTTON_TYPE_NORMAL);
#ifdef __MMI_USB_SUPPORT__
    if (MMI_TRUE == srv_usb_is_in_mass_storage_mode())
    {
        copyCmd->disableItem(VAPP_MSG_FOLDER_COPY_TO_ARCHIVE);
    }
#endif /* __MMI_USB_SUPPORT__ */
    if (0 == srv_sim_ctrl_get_num_of_inserted())
    {
        copyCmd->addItem(VAPP_MSG_FOLDER_COPY_SMS_TO_SIM1, STR_ID_VAPP_MSG_COPY_SMS_TO_SIM, VCP_POPUP_BUTTON_TYPE_NORMAL);
        copyCmd->disableItem(VAPP_MSG_FOLDER_COPY_SMS_TO_SIM1);
    }
    else if (1 == srv_sim_ctrl_get_num_of_inserted())
    {
        /* show inserted sim card */
        U16 index = 0;
        U16 folderCpyId = VAPP_MSG_FOLDER_COPY_SMS_TO_SIM1;
        mmi_sim_enum sim = MMI_SIM1;
        /* Add all sim buttons */
        for (index = 0; index < MMI_MAX_SIM_NUM ; index++, sim = (mmi_sim_enum)(sim << 1), folderCpyId++)
        {
            if (MMI_TRUE == srv_sim_ctrl_is_inserted(sim))
            {
                break;
            }
        }
        copyCmd->addItem(folderCpyId, STR_ID_VAPP_MSG_COPY_SMS_TO_SIM, VCP_POPUP_BUTTON_TYPE_NORMAL);
    }
    else
    {
        copyCmd->addItem(VAPP_MSG_FOLDER_COPY_SMS_TO_SIM_SELECT, STR_ID_VAPP_MSG_COPY_SMS_TO_SIM, VCP_POPUP_BUTTON_TYPE_NORMAL);
    }

#ifdef __MMI_SMS_TCARD_STORAGE_SUPPORT__
    copyCmd->addItem(VAPP_MSG_FOLDER_COPY_SMS_TO_PHONE, STR_ID_VAPP_MSG_COPY_SMS_TO_PHONE, VCP_POPUP_BUTTON_TYPE_NORMAL);
    if (MMI_FALSE == srv_fmgr_drv_is_accessible(srv_fmgr_drv_get_letter_by_type(SRV_FMGR_DRV_CARD_TYPE)))
    {
        copyCmd->disableItem(VAPP_MSG_FOLDER_COPY_SMS_TO_PHONE);
    }
#ifdef __MMI_USB_SUPPORT__
    if (MMI_TRUE == srv_usb_is_in_mass_storage_mode())
    {
        copyCmd->disableItem(VAPP_MSG_FOLDER_COPY_SMS_TO_PHONE);
    }
#endif /* __MMI_USB_SUPPORT__ */
    copyCmd->addItem(VAPP_MSG_FOLDER_COPY_SMS_TO_MEMORY_CARD, STR_ID_VAPP_MSG_COPY_SMS_TO_MEMORY_CARD, VCP_POPUP_BUTTON_TYPE_NORMAL);
    /* check memroy card */
    if (MMI_FALSE == srv_fmgr_drv_is_accessible(srv_fmgr_drv_get_letter_by_type(SRV_FMGR_DRV_CARD_TYPE)))
    {
        copyCmd->disableItem(VAPP_MSG_FOLDER_COPY_SMS_TO_MEMORY_CARD);
    }
#endif /* __MMI_SMS_TCARD_STORAGE_SUPPORT__ */
    
#ifndef __COSMOS_NO_USER_DRIVE__
    copyCmd->addItem(VAPP_MSG_FOLDER_COPY_MMS_TO_PHONE, STR_ID_VAPP_MSG_COPY_MMS_TO_PHONE, VCP_POPUP_BUTTON_TYPE_NORMAL);
	
    /* Set copy to phone as disable if the memory card is not inserted. But if support multiple memory cards in the future, it should be revised again  */
    if (MMI_FALSE == srv_fmgr_drv_is_accessible(srv_fmgr_drv_get_letter_by_type(SRV_FMGR_DRV_CARD_TYPE)))
    {
        copyCmd->disableItem(VAPP_MSG_FOLDER_COPY_MMS_TO_PHONE);
    }
#ifdef __MMI_USB_SUPPORT__
    if (MMI_TRUE == srv_usb_is_in_mass_storage_mode())
    {
        copyCmd->disableItem(VAPP_MSG_FOLDER_COPY_MMS_TO_PHONE);
    }
#endif /* __MMI_USB_SUPPORT__ */
    copyCmd->addItem(VAPP_MSG_FOLDER_COPY_MMS_TO_MEMORY_CARD, STR_ID_VAPP_MSG_COPY_MMS_TO_MEMORY_CARD, VCP_POPUP_BUTTON_TYPE_NORMAL);
    /* check memroy card */
    if (MMI_FALSE == srv_fmgr_drv_is_accessible(srv_fmgr_drv_get_letter_by_type(SRV_FMGR_DRV_CARD_TYPE)))
    {
        copyCmd->disableItem(VAPP_MSG_FOLDER_COPY_MMS_TO_MEMORY_CARD);
    }
#endif /* __COSMOS_NO_USER_DRIVE__ */

    copyCmd->addItem(VAPP_MSG_FOLDER_COPY_CANCEL, STR_GLOBAL_CANCEL, VCP_POPUP_BUTTON_TYPE_CANCEL);
    copyCmd->m_signalButtonClicked.connect(this, &VappMsgFolderPage::onCopyCmdClicked);
    copyCmd->show(VFX_TRUE);
}
#endif /* __MMI_UM_BOX_LIST_SUPPORT__ */ 

#ifdef __UNIFIED_MESSAGE_SORT_MESSAGE_LIST__
void VappMsgFolderPage::toolbarSort()
{
    VcpCommandPopup *sortCmd;
    VFX_OBJ_CREATE(sortCmd, VcpCommandPopup, this);
    sortCmd->setText(STR_ID_VAPP_MSG_SORT_MSG_BY);
    /* use service's enum to let as VfxId */
    sortCmd->addItem(SRV_UM_LIST_IDX_ADDRESS + 1, STR_ID_VAPP_MSG_SORT_MSG_BY_RECIPIENT, VCP_POPUP_BUTTON_TYPE_NORMAL);
    sortCmd->addItem(SRV_UM_LIST_IDX_MSG_TYPE + 1, STR_ID_VAPP_MSG_SORT_MSG_BY_TYPE, VCP_POPUP_BUTTON_TYPE_NORMAL);
    sortCmd->addItem(SRV_UM_LIST_IDX_READ_STATUS + 1, STR_ID_VAPP_MSG_SORT_MSG_BY_READ_STATUS, VCP_POPUP_BUTTON_TYPE_NORMAL);
    sortCmd->addItem(SRV_UM_LIST_IDX_TIMESTAMP + 1, STR_ID_VAPP_MSG_SORT_MSG_BY_TIME, VCP_POPUP_BUTTON_TYPE_NORMAL);
    sortCmd->addItem(SRV_UM_LIST_IDX_TOTAL + 1, STR_GLOBAL_CANCEL, VCP_POPUP_BUTTON_TYPE_CANCEL);
    sortCmd->m_signalButtonClicked.connect(this, &VappMsgFolderPage::onSortCmdClicked);
    sortCmd->show(VFX_TRUE);
}
#endif

void VappMsgFolderPage::toolbarMsSelectAll()
{
    if (VFX_TRUE == m_list->getIsAllMarked(VFX_TRUE, m_msgCopyFilter.msg_type, getTransMsMsgListCopyType()))
    {
        /* unmark all */
        m_list->setMarkAll(VFX_FALSE);
        m_toolbar->changeItem(VAPP_MSG_FOLDER_TOOL_BAR_MS_SELECT_ALL, VCP_STR_TOOL_BAR_SELECT_ALL, VCP_IMG_TOOL_BAR_COMMON_ITEM_SELECT_ALL);
    }
    else
    {
        /* mark all */
        if (SRV_UM_MSG_BOX_SIM == m_boxId.msg_box_type)
        {
            /* sim box special case handling */
            m_list->setMarkAll(VFX_TRUE);
        }
        else
        {
            m_list->setMarkAll(VFX_TRUE, m_msgCopyFilter.msg_type, getTransMsMsgListCopyType());
        }
        m_toolbar->changeItem(VAPP_MSG_FOLDER_TOOL_BAR_MS_SELECT_ALL, VCP_STR_TOOL_BAR_UNSELECT_ALL, VCP_IMG_TOOL_BAR_COMMON_ITEM_UNSELECT_ALL);
    }
    /* check if enable/disable the action toolbar */
    if (m_list->getIsAllMarked(VFX_FALSE))
    {
        m_toolbar->setDisableItem(VAPP_MSG_FOLDER_TOOL_BAR_MS_DELETE, VFX_TRUE);
        m_toolbar->setDisableItem(VAPP_MSG_FOLDER_TOOL_BAR_MS_COPY, VFX_TRUE);
    }
    else
    {
        m_toolbar->setDisableItem(VAPP_MSG_FOLDER_TOOL_BAR_MS_DELETE, VFX_FALSE);
        m_toolbar->setDisableItem(VAPP_MSG_FOLDER_TOOL_BAR_MS_COPY, VFX_FALSE);
    }
    m_isNeedUpdate = VFX_TRUE;
    checkUpdate();
}

void VappMsgFolderPage::toolbarMsDelete()
{
    VFX_DEV_ASSERT(NULL == m_confirmPopup);
    VFX_OBJ_CREATE(m_confirmPopup, VcpConfirmPopup, this);
    VfxWString text, prefix;
    if (VAPP_MSG_FOLDER_TYPE_CONVERSATION == m_style)
    {
        text.loadFromRes(STR_ID_VAPP_MSG_MS_DELETE_CS_SELECT_PREFIX);
    }
    else
    {
        if ((SRV_UM_MSG_BOX_PREDEF_TEMPLATES | SRV_UM_MSG_BOX_USRDEF_TEMPLATES) != m_boxId.msg_box_type)
        {
            text.loadFromRes(STR_ID_VAPP_MSG_MS_DELETE_SELECT_PREFIX);
        }
        else
        {
            text.loadFromRes(STR_ID_VAPP_MSG_MS_DELETE_TEMPLATE_PREFIX);
        }
    }
    text += VfxWString().format("%d", m_list->getNumMarked());
    if (VAPP_MSG_FOLDER_TYPE_CONVERSATION == m_style)
    {
        prefix.loadFromRes(STR_ID_VAPP_MSG_MS_DELETE_CS_SELECT_POSTFIX);
        text += prefix;
    }
    else
    {
        if ((SRV_UM_MSG_BOX_PREDEF_TEMPLATES | SRV_UM_MSG_BOX_USRDEF_TEMPLATES) != m_boxId.msg_box_type)
        {
            prefix.loadFromRes(STR_ID_VAPP_MSG_MS_DELETE_SELECT_POSTFIX);
            text += prefix;
        }
        else
        {
            prefix.loadFromRes(STR_ID_VAPP_MSG_MS_DELETE_TEMPLATE_POSTFIX);
            text += prefix;
        }
    }
    m_confirmPopup->setText(text);
    m_confirmPopup->setInfoType(VCP_POPUP_TYPE_WARNING);
    m_confirmPopup->setButtonSet(VCP_CONFIRM_BUTTON_SET_YES_NO);
    m_confirmPopup->setCustomButton(
                STR_GLOBAL_DELETE, 
                STR_GLOBAL_CANCEL, 
                VCP_POPUP_BUTTON_TYPE_WARNING, 
                VCP_POPUP_BUTTON_TYPE_CANCEL);
    m_confirmPopup->m_signalButtonClicked.connect(this, &VappMsgFolderPage::onMsActionClicked);
    m_confirmPopup->show(VFX_TRUE);
}

void VappMsgFolderPage::toolbarMsCopy()
{
    m_list->copyMarked(getTransMsMsgListCopyType());
    /* show processing */
    m_msProcessLoading->setText(STR_GLOBAL_COPYING);
    m_msProcessLoading->setInfoType(VCP_INDICATOR_POPUP_STYLE_PROGRESS_WITH_CANCEL_BUTTON);
    m_msProcessLoading->setProgress(0);
    m_msProcessLoading->show(VFX_TRUE);
    /* start a timer to update the process */
    m_msProcessTimer->start();
}

void VappMsgFolderPage::toolbarMsCancel()
{
    m_msOpAction = SRV_UM_MARK_SEVERAL_OP_ACTION_NONE;
    setMode(VAPP_MSG_FOLDER_MODE_NORMAL);
}

void VappMsgFolderPage::longpressDelete(VappMsgCntxOptItemCp * item)
{
    /* record the mark status */
    m_list->setMarkAll(VFX_FALSE);
    m_list->setMarkStatus(item->getIndex(), VFX_TRUE);
    /* show a confirm */
    VFX_DEV_ASSERT(NULL == m_confirmPopup);
    VFX_OBJ_CREATE(m_confirmPopup, VcpConfirmPopup, this);
    if (VAPP_MSG_FOLDER_TYPE_CONVERSATION == m_style)
    {
        m_confirmPopup->setText(STR_ID_VAPP_MSG_ASK_DELETE_CS_COFIRM);
    }
    else
    {
        if ((SRV_UM_MSG_BOX_PREDEF_TEMPLATES | SRV_UM_MSG_BOX_USRDEF_TEMPLATES) != m_boxId.msg_box_type)
        {
            m_confirmPopup->setText(STR_ID_VAPP_MSG_ASK_DELETE_COFIRM);
        }
        else
        {
            m_confirmPopup->setText(STR_ID_VAPP_MSG_ASK_DELETE_TEMPLATE_CONFIRM);
        }
    }
    m_confirmPopup->setInfoType(VCP_POPUP_TYPE_WARNING);
    m_confirmPopup->setButtonSet(VCP_CONFIRM_BUTTON_SET_YES_NO);
    m_confirmPopup->setCustomButton(
                STR_GLOBAL_DELETE, 
                STR_GLOBAL_CANCEL, 
                VCP_POPUP_BUTTON_TYPE_WARNING, 
                VCP_POPUP_BUTTON_TYPE_CANCEL);
    m_confirmPopup->m_signalButtonClicked.connect(this, &VappMsgFolderPage::onLpActionClicked);
    m_confirmPopup->show(VFX_TRUE);
}

void VappMsgFolderPage::longpressCall(VappMsgCntxOptItemCp * item)
{
    srv_um_msg_info_struct *msgInfo = NULL;
    srv_um_thread_info_struct *threadInfo = NULL;
    VfxBool result = VFX_FALSE;

    if (VAPP_MSG_FOLDER_TYPE_CONVERSATION == m_style)
    {
        result = m_list->getMsgInfo(item->getIndex(), msgInfo, threadInfo);
    }
    else
    {
        result = m_list->getMsgInfo(item->getIndex(), msgInfo);
    }
    /* fill call parameter */
    VFX_ASSERT(VFX_TRUE == result);
    mmi_id cuiId;

    cuiId = vcui_dialer_create(getApp()->getGroupId());
    vcui_dialer_set_dial_string(cuiId, VFX_WSTR_MEM(msgInfo->address));
    vcui_dialer_run(cuiId);
}

#ifdef __MMI_UM_BOX_LIST_SUPPORT__
void VappMsgFolderPage::longpressForward(VappMsgCntxOptItemCp * item)
{
#ifdef __MMI_UNIFIED_COMPOSER__
    VappUcEntryStruct *ucInfo;
    VFX_ALLOC_MEM(ucInfo, sizeof(VappUcEntryStruct), this);
    vfx_sys_mem_zero(ucInfo, sizeof(VappUcEntryStruct));

    if (VAPP_MSG_FOLDER_TYPE_LITE == m_style &&
        SRV_UM_MSG_SMS != item->getMsgType())
    {
        VFX_ASSERT(0);
    }

    VfxBool isNeedConfirm = VFX_FALSE;
    VfxU16 displayString = 0;
    ucInfo->info_type = transferUcType(item->getMsgType());
    ucInfo->msg_id = item->getMsgId();
    ucInfo->type = SRV_UC_STATE_FORWARD;
    ucInfo->operation = UC_OPERATION_FORWARD;
#ifdef __MMI_MMS_IN_UM__
    if (SRV_UM_MSG_MMS == item->getMsgType())
    {
        ucInfo->mode = MMA_MODE_FORWARD;
        isNeedConfirm = vapp_mms_is_need_show_edit_cnfm(item->getMsgId(), &displayString);
    }
#endif /* __MMI_MMS_IN_UM__ */
    if (VFX_TRUE == isNeedConfirm)
    {
        // record the data
        VFX_FREE_MEM(m_actionPtr);
        VFX_ALLOC_MEM(m_actionPtr, sizeof(VappUcEntryStruct), this);
        vfx_sys_mem_zero(m_actionPtr, sizeof(VappUcEntryStruct));
        vfx_sys_mem_copy(m_actionPtr, ucInfo, sizeof(VappUcEntryStruct));
        /* display restricted confirm */
        VFX_DEV_ASSERT(NULL == m_confirmPopup);
        VFX_OBJ_CREATE(m_confirmPopup, VcpConfirmPopup, this);
        m_confirmPopup->setText(displayString);
        m_confirmPopup->setInfoType(VCP_POPUP_TYPE_WARNING);
        m_confirmPopup->setButtonSet(VCP_CONFIRM_BUTTON_SET_YES_NO);
        m_confirmPopup->setCustomButton(
                    STR_GLOBAL_CONTINUE, 
                    STR_GLOBAL_CANCEL, 
                    VCP_POPUP_BUTTON_TYPE_NORMAL, 
                    VCP_POPUP_BUTTON_TYPE_CANCEL);
        m_confirmPopup->m_signalButtonClicked.connect(this, &VappMsgFolderPage::onRestrictConfirmClicked);
        m_confirmPopup->show(VFX_TRUE);
    }
    else
    {
        mmi_id cuiId;
        /* lite type only support UC sms only */
        if (VAPP_MSG_FOLDER_TYPE_LITE == m_style)
        {
            ucInfo->msg_type = SRV_UC_MSG_TYPE_SMS_ONLY;
        }
        cuiId = vcui_unifiedcomposer_create(getApp()->getGroupId(), ucInfo);
        if (cuiId != GRP_ID_INVALID)
        {
            vfxSetCuiCallerScr(cuiId, getMainScr());
            vcui_unifiedcomposer_run(cuiId);
        }
    }

    VFX_FREE_MEM(ucInfo);
#endif

#ifdef __MMI_SMS_COMPOSER__
    mmi_id cuiId;          
    VcuiSmsComposerEntryStruct *entryData;
    VFX_ALLOC_MEM(entryData, sizeof(VcuiSmsComposerEntryStruct), this);
    vfx_sys_mem_zero(entryData, sizeof(VcuiSmsComposerEntryStruct));
    entryData->msg_id = item->getMsgId();
    entryData->operation = VCUI_SMS_COMPOSER_OPERATION_FORWARD;                
        
    cuiId = vcui_sms_composer_create(getApp()->getGroupId());
    if (cuiId != GRP_ID_INVALID)
    {
        vfxSetCuiCallerScr(cuiId, getMainScr());
        vcui_sms_composer_set_entry_data(cuiId, entryData);
            
        vcui_sms_composer_run(cuiId);
    }
    VFX_FREE_MEM(entryData);
#endif
}

void VappMsgFolderPage::longpressResend(VappMsgCntxOptItemCp * item)
{
    if (MMI_FALSE == srv_mode_switch_is_network_service_available())
    {
        mmi_frm_nmgr_balloon(MMI_SCENARIO_ID_DEFAULT, MMI_EVENT_INFO_BALLOON, MMI_NMGR_BALLOON_TYPE_INFO, VFX_WSTR_RES(STR_GLOBAL_UNAVAILABLE_IN_FLIGHT_MODE));
    }
    else
    {
        if (SRV_UM_MSG_SMS == item->getMsgType())
        {
            vapp_sms_resend_msg(item->getMsgId());
        }
    #ifdef __MMI_MMS_IN_UM__
        else if (SRV_UM_MSG_MMS == item->getMsgType())
        {
            srv_mms_mma_get_msg_info_struct *msgInfo;
            VFX_ALLOC_MEM(msgInfo, sizeof(srv_mms_mma_get_msg_info_struct), this);
            vfx_sys_mem_zero(msgInfo, sizeof(srv_mms_mma_get_msg_info_struct));

            if (SRV_MMS_RESULT_OK == srv_mms_mma_get_sync_msg_info_user_data_input(
                                        item->getMsgId(), 
                                        msgInfo, 
                                        &VappMsgFolderPage::allocMem, 
                                        &VappMsgFolderPage::freeMem, 
                                        (void *)getObjHandle()))
            {
                srv_mms_send_req_struct req;
                vfx_sys_mem_zero(&req, sizeof(srv_mms_send_req_struct));
                req.sim_id = msgInfo->sim_id;
                req.send_setting = SRV_MMS_SETTING_SAVE_AND_SEND;
                req.msg_id = item->getMsgId();
                req.is_rr = MMI_FALSE;
                req.storage_type = msgInfo->storage_type;
                vapp_mms_send_msg(&req, &VappMsgFolderPage::allocMem, &VappMsgFolderPage::freeMem, (void *)getObjHandle());
            }

            VFX_FREE_MEM(msgInfo);
        }
    #endif /* __MMI_MMS_IN_UM__ */
        else
        {
            VFX_ASSERT(0);
        }
        m_isNeedReset = VFX_TRUE;
        checkUpdate();

        //setPreferredSim(item->getMsgType(), item->getMsgId(), item->getIndex());
    }
}
#endif /* __MMI_UM_BOX_LIST_SUPPORT__ */

void VappMsgFolderPage::longpressEdit(VappMsgCntxOptItemCp * item)
{
#ifdef __MMI_UNIFIED_COMPOSER__
    VappUcEntryStruct *ucInfo;
    VFX_ALLOC_MEM(ucInfo, sizeof(VappUcEntryStruct), this);
    vfx_sys_mem_zero(ucInfo, sizeof(VappUcEntryStruct));

    ucInfo->info_type = transferUcType(item->getMsgType());
    ucInfo->msg_id = item->getMsgId();
    ucInfo->type = SRV_UC_STATE_EDIT_EXISTED_MSG;
    if (m_boxId.msg_box_type == (SRV_UM_MSG_BOX_PREDEF_TEMPLATES|SRV_UM_MSG_BOX_USRDEF_TEMPLATES))
    {
        ucInfo->operation = UC_OPERATION_EDIT_MMS_TEMPLATE;
    }
    else
    {
        ucInfo->operation = UC_OPERATION_EDIT_EXISTED_MSG;
    }

    VfxBool isNeedConfirm = VFX_FALSE;
    VfxU16 displayString = 0;
#ifdef __MMI_MMS_IN_UM__
    if (SRV_UM_MSG_MMS == item->getMsgType())
    {
        ucInfo->mode = MMA_MODE_EDIT;
        isNeedConfirm = vapp_mms_is_need_show_edit_cnfm(item->getMsgId(), &displayString);
    }
#endif /* __MMI_MMS_IN_UM__ */
    if (VFX_TRUE == isNeedConfirm)
    {
        // record the data
        VFX_FREE_MEM(m_actionPtr);
        VFX_ALLOC_MEM(m_actionPtr, sizeof(VappUcEntryStruct), this);
        vfx_sys_mem_zero(m_actionPtr, sizeof(VappUcEntryStruct));
        vfx_sys_mem_copy(m_actionPtr, ucInfo, sizeof(VappUcEntryStruct));
        /* display restricted confirm */
        VFX_DEV_ASSERT(NULL == m_confirmPopup);
        VFX_OBJ_CREATE(m_confirmPopup, VcpConfirmPopup, this);
        m_confirmPopup->setText(displayString);
        m_confirmPopup->setInfoType(VCP_POPUP_TYPE_WARNING);
        m_confirmPopup->setButtonSet(VCP_CONFIRM_BUTTON_SET_YES_NO);
        m_confirmPopup->setCustomButton(
                    STR_GLOBAL_CONTINUE, 
                    STR_GLOBAL_CANCEL, 
                    VCP_POPUP_BUTTON_TYPE_NORMAL, 
                    VCP_POPUP_BUTTON_TYPE_CANCEL);
        m_confirmPopup->m_signalButtonClicked.connect(this, &VappMsgFolderPage::onRestrictConfirmClicked);
        m_confirmPopup->show(VFX_TRUE);
    }
    else
    {
        mmi_id cuiId;
        cuiId = vcui_unifiedcomposer_create(getApp()->getGroupId(), ucInfo);
        if (cuiId != GRP_ID_INVALID)
        {
            vfxSetCuiCallerScr(cuiId, getMainScr());
            vcui_unifiedcomposer_run(cuiId);
        }
    }

    VFX_FREE_MEM(ucInfo);
#endif

#ifdef __MMI_SMS_COMPOSER__     
    mmi_id cuiId;       
    VcuiSmsComposerEntryStruct *entryData;
    VFX_ALLOC_MEM(entryData, sizeof(VcuiSmsComposerEntryStruct), this);
    vfx_sys_mem_zero(entryData, sizeof(VcuiSmsComposerEntryStruct));
    entryData->msg_id = item->getMsgId();
    entryData->operation = VCUI_SMS_COMPOSER_OPERATION_EDIT;                
        
    cuiId = vcui_sms_composer_create(getApp()->getGroupId());
    if (cuiId != GRP_ID_INVALID)
    {
        vfxSetCuiCallerScr(cuiId, getMainScr());
        vcui_sms_composer_set_entry_data(cuiId, entryData);
            
        vcui_sms_composer_run(cuiId);
    }
    VFX_FREE_MEM(entryData);
#endif
}

#ifdef __MMI_UM_BOX_LIST_SUPPORT__
void VappMsgFolderPage::longpressViewWebsite(VappMsgCntxOptItemCp * item)
{
#ifdef __MMI_PUSH_IN_UM__
    VfxAppWapPushInterface::vappWapPushLauchMsgURL(item->getMsgId(), this, &VappMsgFolderPage::onPushViewWebsiteCb);
    showLoading();
    m_isBlockUpdate = VFX_TRUE;
#endif /* __MMI_PUSH_IN_UM__ */
}

void VappMsgFolderPage::longpressInstall(VappMsgCntxOptItemCp * item)
{
#ifdef __MMI_PROV_IN_UM__
    vapp_prov_install_ext(item->getMsgId(), &VappMsgFolderPage::onProvInstallCb, (void *)getObjHandle(), getApp()->getGroupId());
    showLoading();
    m_isBlockUpdate = VFX_TRUE;
#endif /* __MMI_PROV_IN_UM__ */
}
#endif /* __MMI_UM_BOX_LIST_SUPPORT__ */

void VappMsgFolderPage::longpressUse(VappMsgCntxOptItemCp * item)
{
#ifdef __MMI_UNIFIED_COMPOSER__
    VappUcEntryStruct *ucInfo;
    VFX_ALLOC_MEM(ucInfo, sizeof(VappUcEntryStruct), this);
    vfx_sys_mem_zero(ucInfo, sizeof(VappUcEntryStruct));

    VfxBool isNeedConfirm = VFX_FALSE;
    VfxU16 displayString;
    ucInfo->info_type = transferUcType(item->getMsgType());
    ucInfo->msg_id = item->getMsgId();
    ucInfo->type = SRV_UC_STATE_EDIT_EXISTED_MSG;
    ucInfo->operation = UC_OPERATION_EDIT_EXISTED_MSG;
#ifdef __MMI_MMS_IN_UM__
    if (SRV_UM_MSG_MMS == item->getMsgType())
    {
        ucInfo->mode = MMA_MODE_EDIT;
        isNeedConfirm = vapp_mms_is_need_show_edit_cnfm(item->getMsgId(), &displayString);
    }
#endif /* __MMI_MMS_IN_UM__ */
    if (VFX_TRUE == isNeedConfirm)
    {
        // record the data
        VFX_FREE_MEM(m_actionPtr);
        VFX_ALLOC_MEM(m_actionPtr, sizeof(VappUcEntryStruct), this);
        vfx_sys_mem_zero(m_actionPtr, sizeof(VappUcEntryStruct));
        vfx_sys_mem_copy(m_actionPtr, ucInfo, sizeof(VappUcEntryStruct));
        /* display restricted confirm */
        VFX_DEV_ASSERT(NULL == m_confirmPopup);
        VFX_OBJ_CREATE(m_confirmPopup, VcpConfirmPopup, this);
        m_confirmPopup->setText(displayString);
        m_confirmPopup->setInfoType(VCP_POPUP_TYPE_WARNING);
        m_confirmPopup->setButtonSet(VCP_CONFIRM_BUTTON_SET_YES_NO);
        m_confirmPopup->setCustomButton(
                    STR_GLOBAL_CONTINUE, 
                    STR_GLOBAL_CANCEL, 
                    VCP_POPUP_BUTTON_TYPE_NORMAL, 
                    VCP_POPUP_BUTTON_TYPE_CANCEL);
        m_confirmPopup->m_signalButtonClicked.connect(this, &VappMsgFolderPage::onRestrictConfirmClicked);
        m_confirmPopup->show(VFX_TRUE);
    }
    else
    {
        mmi_id cuiId;
        cuiId = vcui_unifiedcomposer_create(getApp()->getGroupId(), ucInfo);
        if (cuiId != GRP_ID_INVALID)
        {
            vfxSetCuiCallerScr(cuiId, getMainScr());
            vcui_unifiedcomposer_run(cuiId);
        }
    }

    VFX_FREE_MEM(ucInfo);
#endif
}

#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
        #if (MMI_MAX_SIM_NUM >= 2)
/* under construction !*/
/* under construction !*/
/* under construction !*/
        #endif /* MMI_MAX_SIM_NUM >= 2 */
/* under construction !*/
        #if (MMI_MAX_SIM_NUM >= 3)
/* under construction !*/
/* under construction !*/
/* under construction !*/
        #endif /* MMI_MAX_SIM_NUM >= 3 */
/* under construction !*/
        #if (MMI_MAX_SIM_NUM >= 4)
/* under construction !*/
/* under construction !*/
/* under construction !*/
        #endif /* MMI_MAX_SIM_NUM >= 4 */
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif


VFX_IMPLEMENT_CLASS("VappMsgDialogPage", VappMsgDialogPage, VfxPage);

VappMsgDialogPage::VappMsgDialogPage(VfxU32 msgType, VfxU32 boxType, VfxU32 simType, VappMsgDialogPageModeEnum mode):
    m_isSetAddr(VFX_FALSE), 
    m_mode(mode), 
    m_isNewMode(VFX_FALSE), 
    m_isNeedReset(VFX_TRUE), 
    m_list(NULL), 
    m_listMenu(NULL), 
    m_editorMaxLength(0), 
    m_editor(NULL), 
    m_addressType(SRV_UM_ADDR_EMPTY), 
    m_addressSimId(SRV_UM_SIM_UNCLASSIFIED), 
    m_loading(NULL), 
    m_toolbar(NULL), 
    m_msAction(SRV_UM_MARK_SEVERAL_OP_ACTION_NONE), 
    m_msProcessLoading(NULL), 
    m_contactBar(NULL), 
    m_msProcessTimer(NULL), 
    m_isBlockUpdate(VFX_FALSE), 
    m_editFuncbar(NULL), 
    m_msgId(0), 
    m_msgType(SRV_UM_MSG_NONE), 
    m_isMultiAddr(VFX_FALSE), 
    m_isStartSetAllMsgRead(VFX_FALSE), 
    m_isWaitSetAllRead(VFX_FALSE), 
    m_setAllReadIndex(0), 
    m_contextMenu(NULL), 
    m_actionPtr(NULL),
    m_isEntered(VFX_FALSE),
    m_isStartEnter(VFX_FALSE),
    m_isNotification(VFX_FALSE),
    m_saveStatus(VAPP_MSG_TCARD_SAVE_NONE)
#ifdef __MMI_SMS_COMPOSER__
	,m_phbCuiId(0)
	,m_phbCuiStatue(VAPP_MSG_POP_PHB_NUM)
#endif
{
    m_boxId.msg_type = (srv_um_msg_enum) msgType;
    m_boxId.msg_box_type = (srv_um_msg_box_enum) boxType;
    m_boxId.sim_id = (srv_um_sim_enum) simType;

    vfx_sys_mem_zero(&m_listFilter, sizeof(srv_um_list_filter_struct));
    
    m_msgCopyFilter.msg_type = SRV_UM_MSG_NONE;
    m_msgCopyFilter.msg_box = SRV_UM_MSG_BOX_NONE;
    m_msgCopyFilter.msg_storage = VAPP_MSG_STORAGE_NONE;

    m_address = VFX_WSTR_EMPTY;
}

void VappMsgDialogPage::setAddress(
                        VfxWString addr, 
                        srv_um_addr_enum addrType, 
                        srv_um_sim_enum simId, 
                        srv_um_thread_id_struct thrdId, 
                        VfxU32 msgId,               /* for multiple address used */
                        srv_um_msg_enum msgType,    /* for multiple address used */
                        VfxBool isMultiple)
{
    MMI_PRINT(MOD_MMI_COMMON_APP, TRACE_GROUP_6, "%s", this->getClassInfo()->getClassName());
    MMI_TRACE(TRACE_GROUP_6, TRC_MMI_VAPP_MSG_DIALOG_SET_ADDRESS, this);
    if (VFX_FALSE == isMultiple)
    {
        m_address = addr;
        m_addressSimId = simId;
        m_addressType = addrType;
    }
    else
    {
        m_addressSimId = simId;
        m_msgId = msgId;
        m_msgType = msgType;
        /* destory editor and relayout the listMenu */
        VfxFrame *editorBg = NULL;
        editorBg = m_editor->getParentFrame();
        VFX_OBJ_CLOSE(m_editFuncbar);
        VFX_OBJ_CLOSE(m_editor);
        VFX_OBJ_CLOSE(editorBg);
        m_listMenu->setSize(getSize().width, getSize().height - m_contactBar->getSize().height + m_contactBar->getShadowHeight());
        m_listMenu->setAlignParent(
                        VFX_FRAME_ALIGNER_MODE_SIDE, 
                        VFX_FRAME_ALIGNER_MODE_SIDE, 
                        VFX_FRAME_ALIGNER_MODE_SIDE, 
                        VFX_FRAME_ALIGNER_MODE_SIDE);
    }
    m_isSetAddr = VFX_TRUE;
    m_isMultiAddr = isMultiple;

    m_list->setThreadId(thrdId);
    setContactBar();
    checkUpdate();
    m_isWaitSetAllRead = VFX_TRUE;
    m_setAllReadIndex = 0;
    updateToolbar();
}

VfxBool VappMsgDialogPage::getItemInfo(VfxU32 index, VfxU32 &msgId, srv_um_msg_enum &msgType)
{
    if (NULL == m_list ||
        VFX_FALSE == m_isSetAddr)
    {
        return VFX_FALSE;
    }

    msgId = m_list->getMsgId(index);
    msgType = m_list->getMsgType(index);
    return VFX_TRUE;
}

VfxU32 VappMsgDialogPage::getCount()
{
    if (NULL == m_list ||
        VFX_FALSE == m_isSetAddr   ||
        VFX_FALSE == m_isEntered )    
    {
        return 0;
    }

    VfxS32 count;
    count = m_list->getCount();

    if (count <= 0)
    {
        return 0;
    }
    else
    {
        return count;
    }
}

VfxBool VappMsgDialogPage::getMarkStatus(VfxU32 index)
{
    if (NULL == m_list ||
        VFX_FALSE == m_isSetAddr)
    {
        return VFX_FALSE;
    }

    return m_list->getMarkStatus(index);
}

VfxBool VappMsgDialogPage::getCellIsDisabled(VfxU32 index)
{
    // normal mode, default does not disable
    if (VAPP_MSG_DIALOG_PAGE_MODE_NORMAL == m_mode)
    {
        return VFX_FALSE;
    }

    if (SRV_UM_MARK_SEVERAL_OP_ACTION_DELETE == m_msAction)
    {
        return VFX_FALSE;
    }

    // copy to archive check push/prov
    if (SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_ARCHIVE == m_msAction)
    {
        if (SRV_UM_MSG_WAP_PUSH != m_list->getMsgType(index) &&
            SRV_UM_MSG_PROV != m_list->getMsgType(index))
        {
            return VFX_FALSE;
        }
    }
    
    if (!(m_list->getMsgType(index) & m_msgCopyFilter.msg_type))
    {
        return VFX_TRUE;
    }
    else
    {
        if (SRV_UM_MSG_SMS == m_msgCopyFilter.msg_type)
        {
			VfxU32 storage = srv_sms_get_msg_storage_type(m_list->getMsgId(index));
            switch (m_msgCopyFilter.msg_storage)
            {	                        
                case VAPP_MSG_STORAGE_PHONE:
                {
                    if (storage == SRV_SMS_STORAGE_ME)
                    {
                        return VFX_FALSE;
                    }
                    break;
                }
                    
                case VAPP_MSG_STORAGE_MEMORY_CARD:
                {
                    if (storage == SRV_SMS_STORAGE_TCARD)
                    {
                        return VFX_FALSE;
                    }
                    break;
                }
                    
                case VAPP_MSG_STORAGE_PHONE_AND_MEMORY:
                {
                    if (storage == SRV_SMS_STORAGE_ME || storage == SRV_SMS_STORAGE_TCARD)
                    {
                        return VFX_FALSE;
                    }
                    break;
                }                    
                    
                case VAPP_MSG_STORAGE_SIM:
                {
                    if (storage == SRV_SMS_STORAGE_SIM)
                    {
                        return VFX_FALSE;
                    }
                    break;
                }
                    
                default:
                {
                    return VFX_TRUE;
                }
            }
        }
        #ifdef __MMI_MMS_IN_UM__
        else if (SRV_UM_MSG_MMS == m_msgCopyFilter.msg_type)
        {
          	VfxU32 storage = srv_mms_get_msg_storage(m_list->getMsgId(index));
            switch (m_msgCopyFilter.msg_storage)
            {	                        
                case VAPP_MSG_STORAGE_PHONE:
                {
                    if (srv_mms_get_msg_storage(m_list->getMsgId(index)) != SRV_MMS_STORAGE_CARD1)
                    {
                        return VFX_FALSE;
                    }
                    break;
                }

                case VAPP_MSG_STORAGE_MEMORY_CARD:
                {
                    if (srv_mms_get_msg_storage(m_list->getMsgId(index)) != SRV_MMS_STORAGE_PHONE)
                    {
                        return VFX_FALSE;
                    }
                    break;
                }
                    
                default:
                {
                    return VFX_TRUE;
                }
            }
        }
        #endif
    }
    
    return VFX_TRUE;
}

VfxBool VappMsgDialogPage::getLoadingStatus()
{
    if (MMI_FALSE == m_isEntered || MMI_FALSE == m_list->checkMsgList())
    {
        return MMI_TRUE;
    }

    return MMI_FALSE;
}

void VappMsgDialogPage::adjustImeResize(const VfxSize & size,VfxFrame * focusFrame)
{
    /* auto resize via page */

    VfxTopLevel *topLevel = VFX_OBJ_GET_INSTANCE(VfxTopLevel);
    VFX_DEV_ASSERT(NULL != topLevel);
    /* landscape mode */
    if (VFX_SCR_ROTATE_TYPE_90 == topLevel->getScreenRotateType() ||
        VFX_SCR_ROTATE_TYPE_270 == topLevel->getScreenRotateType())
    {
        if (focusFrame)
        {
            /* IME appear */
            m_contactBar->setHidden(VFX_TRUE);
            m_listMenu->setHidden(VFX_TRUE);
        }
        else
        {
            /* IME disappear */
            m_contactBar->setHidden(VFX_FALSE);
            m_listMenu->setHidden(VFX_FALSE);
            onEditorBoundsChange(m_editor, m_editor->getRect());
        }
    }
    else if (VFX_SCR_ROTATE_TYPE_NORMAL == topLevel->getScreenRotateType())
    {
        /* normal */
        m_contactBar->setHidden(VFX_FALSE);
        m_listMenu->setHidden(VFX_FALSE);
        onEditorBoundsChange(m_editor, m_editor->getRect());
    }
}

void VappMsgDialogPage::onObjectNotify(VfxId id,void * userData)
{
	switch(id)
	{
		case VFX_FRAME_NOTIFY_ID_ADJUST_IME_RESIZE:
		{
			VfxFrameAdjustImeResizeData *para = (VfxFrameAdjustImeResizeData *)userData;
	
			adjustImeResize(para->size, para->focusFrame);
			VfxPage::onObjectNotify(id, userData);
			return;
		}
		default:
			VfxPage::onObjectNotify(id, userData);
			return;
	}	
		
}

void VappMsgDialogPage::onInit()
{
    MMI_PRINT(MOD_MMI_COMMON_APP, TRACE_GROUP_6, "%s", this->getClassInfo()->getClassName());
    MMI_TRACE(TRACE_GROUP_6, TRC_MMI_VAPP_MSG_ON_INIT, this);
    VfxPage::onInit();

    //setOpaqueMode(VFX_FRAME_OPAQUE_MODE_FULLY_OPAQUE);

    // create title bar, toolbar not finish yet
    VFX_OBJ_CREATE(m_contactBar, VappMsgContactBar, this);
    m_contactBar->setAutoAnimate(VFX_TRUE);
    m_contactBar->setSize(VfxSize(getSize().width, m_contactBar->getSize().height));
    m_contactBar->setAlignParent(
                    VFX_FRAME_ALIGNER_MODE_SIDE, 
                    VFX_FRAME_ALIGNER_MODE_SIDE, 
                    VFX_FRAME_ALIGNER_MODE_SIDE, 
                    VFX_FRAME_ALIGNER_MODE_NONE);
   VfxFrame *frame;
   VFX_OBJ_CREATE(frame, VfxFrame, this);
   frame->setBgColor(getMainScr()->getBgColor());
   frame->setPos(0, 0);
   frame->setSize(getSize().width, m_contactBar->getSize().height - m_contactBar->getShadowHeight());
   frame->setAlignParent(
                   VFX_FRAME_ALIGNER_MODE_SIDE, 
                   VFX_FRAME_ALIGNER_MODE_SIDE, 
                   VFX_FRAME_ALIGNER_MODE_SIDE, 
                   VFX_FRAME_ALIGNER_MODE_NONE);
    // create message list 
    VFX_OBJ_CREATE_EX(m_list, VappMessageList, this, (m_boxId.msg_type, m_boxId.msg_box_type, m_boxId.sim_id));
    m_list->m_signalListUpdated.connect(this, &VappMsgDialogPage::onListUpdate);
    m_list->m_signalOperationResult.connect(this, &VappMsgDialogPage::onMsOpResult);

    // create editor, put on the bottom of page
    VfxFrame *editorBg;
    VFX_OBJ_CREATE(editorBg, VfxFrame, this);
    editorBg->setAutoAnimate(VFX_TRUE);
    editorBg->setSize(getSize().width, VAPP_MSG_DIALOG_EDITOR_BG_HEIGHT);
    editorBg->setPos(0, getSize().height - editorBg->getSize().height);
    editorBg->setContentPlacement(VFX_FRAME_CONTENT_PLACEMENT_TYPE_RESIZE);
    editorBg->setImgContent(VfxImageSrc(IMG_ID_VAPP_MSG_DIALOG_EDITOR_BG));
    editorBg->setAlignParent(
                    VFX_FRAME_ALIGNER_MODE_SIDE, 
                    VFX_FRAME_ALIGNER_MODE_NONE, 
                    VFX_FRAME_ALIGNER_MODE_SIDE, 
                    VFX_FRAME_ALIGNER_MODE_SIDE);
    VFX_OBJ_CREATE(m_editor, VcpTextEditor, editorBg);
    m_editor->setAutoAnimate(VFX_TRUE);
    m_editor->setSize(editorBg->getSize().width - VAPP_MSG_DIALOG_EDITOR_LEFT_MARGIN - VAPP_MSG_DIALOG_EDITOR_RIGHT_MARGIN, VAPP_MSG_DIALOG_EDITOR_HEIGHT);
    m_editor->setPos(VAPP_MSG_DIALOG_EDITOR_LEFT_MARGIN, VAPP_MSG_DIALOG_EDITOR_UP_MARGIN);
    m_editor->setAlignParent(
                    VFX_FRAME_ALIGNER_MODE_SIDE, 
                    VFX_FRAME_ALIGNER_MODE_SIDE, 
                    VFX_FRAME_ALIGNER_MODE_SIDE, 
                    VFX_FRAME_ALIGNER_MODE_SIDE);
    m_editor->setLineMode(VCP_TEXT_LINE_MODE_MULTI);
    m_editorMaxLength = (VfxU32)(srv_sms_get_usable_text_len(SMSAL_UCS2_DCS)/2);
    m_editor->setMaxLength(m_editorMaxLength);
    m_editor->setHint(STR_GLOBAL_REPLY);
    m_editor->setAutoResized(VFX_TRUE, VAPP_MSG_DIALOG_EDITOR_HEIGHT, VAPP_MSG_DIALOG_EDITOR_MAX_HEIGHT);
    m_editor->m_signalTextChanged.connect(this, &VappMsgDialogPage::onEditorTextChanged);
    m_editor->m_signalBoundsChanged.connect(this, &VappMsgDialogPage::onEditorBoundsChange);
    VFX_OBJ_CREATE(m_editFuncbar, VcpFunctionBar, m_editor);
    m_editFuncbar->setAutoAnimate(VFX_TRUE);
#if defined(__MMI_VUI_TEXT_EMOTION_ICON_SUPPORT__)    
    VcpIconTable *iconTable = NULL;
    iconTable = VappUcEmoticon::getEmotionTablePointer();
    /* Display the first icon as default */
    m_editFuncbar->addItem(VAPP_MSG_DIALOG_PAGE_FB_EMOTICON, iconTable[0].imageId);
#endif /* __MMI_VUI_TEXT_EMOTION_ICON_SUPPORT__ */   
#ifdef __MMI_UM_TEMPLATE_SUPPORT__     
    m_editFuncbar->addItem((VfxResId)STR_GLOBAL_TEMPLATE, (VfxId)VAPP_MSG_DIALOG_PAGE_FB_TEMPLATE);
#endif
    m_editFuncbar->addItem((VfxResId)STR_ID_VAPP_MSG_INSERT, (VfxId)VAPP_MSG_DIALOG_PAGE_FB_INSERT);
    m_editFuncbar->addItem((VfxResId)STR_GLOBAL_SEND, (VfxId)VAPP_MSG_DIALOG_PAGE_FB_SEND);
    m_editFuncbar->setItemSpecial(VAPP_MSG_DIALOG_PAGE_FB_SEND);
    m_editFuncbar->setDisableItem(VAPP_MSG_DIALOG_PAGE_FB_SEND, VFX_TRUE);
    m_editFuncbar->m_signalButtonTap.connect(this, &VappMsgDialogPage::onEditorFbClick);
    m_editor->setFunctionBar(m_editFuncbar);

    // create dialog list
    VFX_OBJ_CREATE(m_listMenu, VappMsgDialogListCp, this);
    m_listMenu->setAutoAnimate(VFX_TRUE);
    m_listMenu->setContentPlacement(VFX_FRAME_CONTENT_PLACEMENT_TYPE_RESIZE);
    m_listMenu->setImgContent(VfxImageSrc(IMG_ID_VAPP_MSG_DIALOG_LIST_BG));
    m_listMenu->setProvider(this);
    m_listMenu->setSize(getSize().width, getSize().height - m_contactBar->getSize().height - editorBg->getSize().height + m_contactBar->getShadowHeight() + VAPP_MSG_DIALOG_EDITOR_SHADOW);
    m_listMenu->setPos(0, m_contactBar->getSize().height - m_contactBar->getShadowHeight());
    m_listMenu->setAlignParent(
                VFX_FRAME_ALIGNER_MODE_SIDE, 
                VFX_FRAME_ALIGNER_MODE_SIDE, 
                VFX_FRAME_ALIGNER_MODE_SIDE, 
                VFX_FRAME_ALIGNER_MODE_SIDE);
    m_listMenu->setHasAnimation(VFX_TRUE);
    m_listMenu->m_signalCellTapped.connect(this, &VappMsgDialogPage::onCellTapped);
    m_listMenu->m_signalCellMarked.connect(this, &VappMsgDialogPage::onCellMarked);
    m_listMenu->m_signalCellLongPressed.connect(this, &VappMsgDialogPage::onCellLongPressed);


    // move the listmenu behind the contactbar
    insertChildFrameAfter(m_listMenu, m_contactBar);
    insertChildFrameAfter(m_listMenu, editorBg);

    // create toolbar
    VFX_OBJ_CREATE(m_toolbar, VcpToolBar, this);
    m_toolbar->m_signalButtonTap.connect(this, &VappMsgDialogPage::onToolbarClick);
    setBottomBar(m_toolbar);

    // loading
    VFX_OBJ_CREATE(m_loading, VcpActivityIndicator, this);
    //m_loading->setBgColor(VfxColor(VFX_COLOR_GREY));
    m_loading->setAutoAnimate(VFX_TRUE);
    m_loading->setHiddenWhenStopped(VFX_TRUE);
    m_loading->setPos(getSize().width/2 - m_loading->getSize().width/2, getSize().height/2 - m_loading->getSize().height/2);
    m_loading->setAlignParent(
                        VFX_FRAME_ALIGNER_MODE_MID, 
                        VFX_FRAME_ALIGNER_MODE_MID, 
                        VFX_FRAME_ALIGNER_MODE_MID, 
                        VFX_FRAME_ALIGNER_MODE_MID);

    VFX_OBJ_CREATE(m_msProcessLoading, VcpIndicatorPopup, this);
    m_msProcessLoading->setText(VFX_WSTR_EMPTY);
    m_msProcessLoading->setAutoDestory(VFX_FALSE);
    m_msProcessLoading->m_signalCanceled.connect(this, &VappMsgDialogPage::onMsOpCancelled);

    VFX_OBJ_CREATE(m_msProcessTimer, VfxTimer, this);
    m_msProcessTimer->setDuration(VAPP_MSG_MS_TIMER_PERIOD);
    m_msProcessTimer->m_signalTick.connect(this, &VappMsgDialogPage::onMsProgressTimeout);

    mmi_frm_cb_reg_event(EVT_ID_SRV_SMS_UPDATE_UNSENT_MSG_STATUS, &VappMsgDialogPage::onMsgSrvEvtCb, getObjHandle());
#ifdef __MMI_MMS_IN_UM__
    mmi_frm_cb_reg_event(EVT_ID_SRV_MMS_UPDATE_STATUS, &VappMsgDialogPage::onMsgSrvEvtCb, getObjHandle());
#endif /* __MMI_MMS_IN_UM__ */

#ifdef __MMI_SMS_TCARD_STORAGE_SUPPORT__
    mmi_frm_cb_reg_event(EVT_ID_SRV_SMS_SAVE_STORAGE_STATUS, &VappMsgDialogPage::onMsgSrvEvtCb, getObjHandle());
#endif /* __MMI_SMS_TCARD_STORAGE_SUPPORT__ */
}

void VappMsgDialogPage::onDeinit()
{
    saveRemainderTextToDraft();
    mmi_frm_cb_dereg_event(EVT_ID_SRV_SMS_UPDATE_UNSENT_MSG_STATUS, &VappMsgDialogPage::onMsgSrvEvtCb, getObjHandle());
#ifdef __MMI_MMS_IN_UM__
    mmi_frm_cb_dereg_event(EVT_ID_SRV_MMS_UPDATE_STATUS, &VappMsgDialogPage::onMsgSrvEvtCb, getObjHandle());
#endif /* __MMI_MMS_IN_UM__ */

#ifdef __MMI_SMS_TCARD_STORAGE_SUPPORT__
    mmi_frm_cb_dereg_event(EVT_ID_SRV_SMS_SAVE_STORAGE_STATUS, &VappMsgDialogPage::onMsgSrvEvtCb, getObjHandle());
#endif /* __MMI_SMS_TCARD_STORAGE_SUPPORT__ */

    VFX_DEV_ASSERT(NULL == m_actionPtr);

    VfxPage::onDeinit();
}

void VappMsgDialogPage::onUpdate()
{
    MMI_PRINT(MOD_MMI_COMMON_APP, TRACE_GROUP_6, "%s", this->getClassInfo()->getClassName());
    MMI_TRACE(TRACE_GROUP_6, TRC_MMI_VAPP_MSG_ON_UPDATE, this);
    VfxPage::onUpdate();

    /*********************************************************
     * 1) no set any address, do nothing 
     * 2) for ms / long press feature, we use the same loading
     *    to block. While during above process, it should block
     *    update
     * 3) while it is not active, do notihng
     * 4) while page not entered, do nothing
     ********************************************************/
    if (VFX_FALSE == m_isSetAddr ||
        VFX_TRUE == m_isBlockUpdate || 
        VFX_FALSE == isActive() || 
        VFX_FALSE == getApp()->isActive() ||
        VFX_FALSE == m_isEntered)
    {
        return;
    }

    /* check list */
    if(VFX_FALSE == m_list->checkMsgList() || 
       VFX_FALSE == getAllMsgRead())
    {
        showLoading();
    }
    else
    {
        stopLoading();

        /* if there is no any message insdie, close it */
        if (0 == m_list->getCount())
        {
            exit();
        }
        else
        {
            /* set new mode */
            if (VFX_TRUE == m_isNewMode)
            {
                if (VAPP_MSG_DIALOG_PAGE_MODE_NORMAL == m_mode)
                {
                    m_listMenu->setMode(VAPP_MSG_DIALOG_LIST_CP_MODE_NORMAL, !m_isNeedReset);
                    //m_listMenu->jumpToInitPos();
                    m_list->freeMsStatus();
                    if (NULL != m_editor)
                    {
                        m_editor->setIsDisabled(VFX_FALSE);
                    }
                }
                else
                {
                    m_listMenu->setMode(VAPP_MSG_DIALOG_LIST_CP_MODE_MS, !m_isNeedReset);
                    //m_listMenu->jumpToInitPos();
                    if (NULL != m_editor)
                    {
                        m_editor->setIsDisabled(VFX_TRUE);
                    }
                }
                updateToolbar();
            }
            if (VFX_TRUE == m_isNeedReset)
            {
                m_listMenu->reset();
            }
            else
            {
                m_listMenu->updateLayout();
            }
            /* enable call toolbar */
            if (VFX_WSTR_EMPTY != m_address &&
                SRV_UM_ADDR_PHONE_NUMBER == m_addressType)
            {
                m_toolbar->setDisableItem(VAPP_MSG_DIALOG_PAGE_TOOLBAR_CALL, VFX_FALSE);
            }
            else
            {
                m_toolbar->setDisableItem(VAPP_MSG_DIALOG_PAGE_TOOLBAR_CALL, VFX_TRUE);
            }
            if (VAPP_MSG_DIALOG_PAGE_MODE_MARK_SEVERAL == m_mode)
            {
                /* check if valid number inside */
                if (0 == m_list->getNumValidMsMsg(m_msgCopyFilter.msg_type, getTransMsMsgListCopyType()))
                {
                    m_toolbar->setDisableItem(VAPP_MSG_DIALOG_PAGE_TOOLBAR_MS_SELECT_ALL, VFX_TRUE);
                }
                else
                {
                    m_toolbar->setDisableItem(VAPP_MSG_DIALOG_PAGE_TOOLBAR_MS_SELECT_ALL, VFX_FALSE);
                }
            }
            m_isNeedReset = VFX_FALSE;
            m_isNewMode = VFX_FALSE;
        }
    }
}

VfxBool VappMsgDialogPage::onKeyInput(VfxKeyEvent & event)
{
    VcpToolBarDisableEnum callItemStatus = VCP_TOOL_BAR_ITEM_NOT_EXIST;
    if (NULL != m_toolbar)
    {
        callItemStatus = m_toolbar->getIsItemDisabled(VAPP_MSG_DIALOG_PAGE_TOOLBAR_CALL);
    }
    if (VCP_TOOL_BAR_ITEM_ENABLED == callItemStatus && 
        VFX_KEY_CODE_SEND == event.keyCode && 
        VFX_KEY_EVENT_TYPE_DOWN == event.type)
    {
        toolbarCall();
        return VFX_TRUE;
    }

    return VfxPage::onKeyInput(event);
}

void VappMsgDialogPage::onExited()
{
    VfxPage::onExited();
    if( VFX_TRUE == m_isStartEnter)
    {
    	setOpaqueMode(VFX_FRAME_OPAQUE_MODE_AUTO);
        m_listMenu->setHidden(VFX_TRUE);
        m_isStartEnter = VFX_FALSE;
    }
}

void VappMsgDialogPage::onEntered()
{
    VfxPage::onEntered();
    setOpaqueMode(VFX_FRAME_OPAQUE_MODE_FULLY_OPAQUE);
    m_listMenu->setHidden(VFX_FALSE);
    m_listMenu->setReadyForAnimation();

    m_isEntered = VFX_TRUE;

    if (m_contactBar != NULL)
    {
        m_contactBar->onRotate();
    }

    checkUpdate();
}

void VappMsgDialogPage::onBack()
{
    if (VAPP_MSG_DIALOG_PAGE_MODE_MARK_SEVERAL == m_mode)
    {
        m_isNewMode = VFX_TRUE;
        m_mode = VAPP_MSG_DIALOG_PAGE_MODE_NORMAL;
        m_msAction = SRV_UM_MARK_SEVERAL_OP_ACTION_NONE;
        m_msgCopyFilter.msg_type = SRV_UM_MSG_NONE;
        m_msgCopyFilter.msg_box = SRV_UM_MSG_BOX_NONE;
        m_msgCopyFilter.msg_storage = VAPP_MSG_STORAGE_NONE;
        checkUpdate();
    }
    else
    {
        VfxPage::onBack();
    }
}

void VappMsgDialogPage::onQueryRotateEx(VfxScreenRotateParam &param)
{
    // do Nothing    
}

void VappMsgDialogPage::onRotate(const VfxScreenRotateParam &param)
{
    m_listMenu->updateLayout();
    if (NULL == m_contactBar)
    {
        return;
    }
    m_contactBar->onRotate();
}

mmi_ret VappMsgDialogPage::onProc(mmi_event_struct * evt)
{
    switch (evt->evt_id)
    {
    #ifdef __MMI_UNIFIED_COMPOSER__
        case EVT_ID_CUI_UC_MSGCOMPOSER_CLOSE:
        {
            cui_msgcomposer_evt_struct *ucEvt = (cui_msgcomposer_evt_struct *)evt;
            /* just close it */
            vcui_unifiedcomposer_close(ucEvt->sender_id);
            break;
        }
    #endif
    
    #ifdef __MMI_SMS_COMPOSER__
        case EVT_ID_CUI_SMS_COMPOSER_CLOSE:
        {
            VcuiSmsComposerEventStruct *ucEvt = (VcuiSmsComposerEventStruct *)evt;
            /* just close it */
            vcui_sms_composer_close(ucEvt->sender_id);
            break;
        }
        
        case EVT_ID_CUI_PHB_LIST_RESULT:
        {
            if (GRP_ID_INVALID != m_phbCuiId)
            {
                vcui_phb_list_result_event_struct *phBookEvt = 
                    (vcui_phb_list_result_event_struct*)evt;

                if (phBookEvt->result > 0)
                {                       
                    VfxWChar *buff = NULL;  
                    VfxU16 buffLen = 
                        (MMI_PHB_NUMBER_LENGTH + 1) * ENCODING_LENGTH;

                    VFX_ALLOC_MEM(buff, buffLen, this);
                    if (VAPP_MSG_POP_PHB_NUM == m_phbCuiStatue)
                    {
                      vcui_phb_list_get_selected_contact_data_by_index(
                        m_phbCuiId, buff , buffLen , 0);
                    }
                    else if (VAPP_MSG_POP_PHB_NAME == m_phbCuiStatue)
                    {
                       vcui_phb_list_get_selected_contact_name_by_index(
                        m_phbCuiId, buff, buffLen, 0);
                    }

                    m_editor->insertText(buff);
                    m_editor->insertText(L' ');                    	

                    VFX_FREE_MEM(buff);  
                }
                vcui_phb_list_close(m_phbCuiId);
                m_phbCuiId = GRP_ID_INVALID;  
            }            
            break;
        }
            
    #endif
    }
    return MMI_RET_OK;
}

void VappMsgDialogPage::onToolbarClick(VfxObject * obj, VfxId id)
{
    switch (id)
    {
        case VAPP_MSG_DIALOG_PAGE_TOOLBAR_SEND:
            toolbarSend();
            break;

        case VAPP_MSG_DIALOG_PAGE_TOOLBAR_CALL:
            toolbarCall();
            break;

        case VAPP_MSG_DIALOG_PAGE_TOOLBAR_RESEND_FAIL:
            toolbarResendFail();
            break;

        case VAPP_MSG_DIALOG_PAGE_TOOLBAR_DELETE:
            toolbarDelete();
            break;

        case VAPP_MSG_DIALOG_PAGE_TOOLBAR_COPY:
            toolbarCopy();
            break;
            
        case VAPP_MSG_DIALOG_PAGE_TOOLBAR_INSERT:
            toolbarInsert();
            break;

        case VAPP_MSG_DIALOG_PAGE_TOOLBAR_MS_SELECT_ALL:
            toolbarMsSelectAll();
            break;

        case VAPP_MSG_DIALOG_PAGE_TOOLBAR_MS_DELETE:
            toolbarMsDelete();
            break;

        case VAPP_MSG_DIALOG_PAGE_TOOLBAR_MS_COPY:
            toolbarMsCopy();
            break;

        case VAPP_MSG_DIALOG_PAGE_TOOLBAR_MS_CANCEL:
            toolbarMsCancel();
            break;

        default:
            break;
    }
}

void VappMsgDialogPage::onListUpdate(VfxObject *obj)
{
    VFX_ASSERT(NULL != m_list);

    m_isNeedReset = VFX_TRUE;
    /* update list, need to re-check all message if read */
    m_isWaitSetAllRead = VFX_TRUE;
    checkUpdate();

    if (NULL != m_contextMenu)
    {
        m_contextMenu->exit(VFX_TRUE);
        m_contextMenu = NULL;
    }
    updateMsToolbar();
}

void VappMsgDialogPage::onMsOpResult(VfxObject * obj, VfxU32 success, VfxU32 fail, VfxS32 error)
{
    VFX_ASSERT(NULL != m_list);

    /* close processing */
    if (0 != fail || SRV_UM_RESULT_OK != error)
    {
        m_msProcessLoading->setProgress(0);
        m_msProcessLoading->hide(VFX_TRUE);
    }
    else
    {
        m_msProcessLoading->setProgress(1.0f);
        m_msProcessLoading->hide(VFX_TRUE);
    }
    
    m_msProcessTimer->stop();
    stopLoading();
    m_isBlockUpdate = VFX_FALSE;

    m_mode = VAPP_MSG_DIALOG_PAGE_MODE_NORMAL;
    m_isNewMode = VFX_TRUE;
    m_isNeedReset = VFX_TRUE;

    VcpConfirmPopup *result;
    if (0 != fail || SRV_UM_RESULT_OK != error)
    {
        VFX_OBJ_CREATE(result, VcpConfirmPopup, this);
        result->setButtonSet(VCP_CONFIRM_BUTTON_SET_OK);
        result->setInfoType(VCP_POPUP_TYPE_FAILURE);
        if (SRV_UM_MARK_SEVERAL_OP_ACTION_DELETE == m_msAction)
        {
            result->setText(STR_ID_VAPP_MSG_FAIL_TO_DELETE);
        }
        else
        {
            result->setText(STR_ID_VAPP_MSG_FAIL_TO_COPY);
        }
        result->show(VFX_TRUE);
    }
    //TODO: Need VcpVarHeightMenu does not need clear all cell, it should choose the "necessary cell" to delete
    m_msAction = SRV_UM_MARK_SEVERAL_OP_ACTION_NONE;
    m_msgCopyFilter.msg_type = SRV_UM_MSG_NONE;
    m_msgCopyFilter.msg_box = SRV_UM_MSG_BOX_NONE;
    m_msgCopyFilter.msg_storage = VAPP_MSG_STORAGE_NONE;
    checkUpdate();
}

void VappMsgDialogPage::onCellTapped(VfxControl * control, VfxU32 index, VfxU32 msgId, srv_um_msg_enum msgType)
{
    VfxBool isEntryViewerPage = VFX_TRUE;
    if (SRV_UM_MSG_SMS == msgType)
    {
        srv_sms_box_enum box = SRV_SMS_BOX_NONE;
        srv_sms_get_msg_list_index(&box, msgId);
        if (SRV_SMS_BOX_DRAFTS == box)
        {
            isEntryViewerPage = VFX_FALSE;
        }
    }
#ifdef __MMI_MMS_IN_UM__
    else if (SRV_UM_MSG_MMS == msgType)
    {
        mma_folder_enum box = MMA_FOLDER_NONE;
        box = mma_get_box(msgId);
        if (MMA_FOLDER_DRAFT == box)
        {
            isEntryViewerPage = VFX_FALSE;
        }
    }
#endif /* __MMI_MMS_IN_UM__ */

    if (VFX_TRUE == isEntryViewerPage)
    {
        srv_sms_send_status_enum smsStatus = SRV_SMS_SEND_INVALID;
    #ifdef __MMI_MMS_IN_UM__
        srv_mms_msg_status_enum mmsStatus = SRV_MMS_MSG_STATUS_NONE;
    #endif /* __MMI_MMS_IN_UM__ */
        if (SRV_UM_MSG_SMS == m_list->getMsgType(index))
        {
            smsStatus = srv_sms_get_unsent_msg_status(m_list->getMsgId(index));
        }
    #ifdef __MMI_MMS_IN_UM__
        else if (SRV_UM_MSG_MMS == m_list->getMsgType(index))
        {
            mmsStatus = srv_mms_get_msg_status(m_list->getMsgId(index));
        }
    #endif /* __MMI_MMS_IN_UM__ */
        // sms : sending/waiting, mms : sending => do nothing
        if (SRV_SMS_SEND_SENDING != smsStatus 
            && SRV_SMS_SEND_WAITING != smsStatus 
        #ifdef __MMI_MMS_IN_UM__
            && SRV_MMS_MSG_STATUS_SENDING != mmsStatus
            && SRV_MMS_MSG_STATUS_WAITING != mmsStatus
            && SRV_MMS_MSG_STATUS_PENDING != mmsStatus     
        #endif /* __MMI_MMS_IN_UM__ */
            )
        {
            m_isStartEnter = VFX_TRUE;
            // entry normal viewer
            VfxPage *page = createViewerPage(msgId, msgType);
            getMainScr()->pushPage(VappMsgScreen::VAPP_MSG_SCREEN_PAGE_VIEWER, page);
        }
    }
    else
    {
#ifdef __MMI_UNIFIED_COMPOSER__
    #ifdef __MMI_MMS_IN_UM__
        if (SRV_UM_MSG_MMS == m_list->getMsgType(index) &&
            (MMI_TRUE == srv_mms_is_corrupted_mms(m_list->getMsgId(index)) ||
             MMI_TRUE == srv_mms_is_forward_lock(m_list->getMsgId(index))
            )
           )
        {
            /* If MMS is corrupted, other api will be useless */
            if (MMI_FALSE == srv_mms_is_corrupted_mms(m_list->getMsgId(index)) &&
                MMI_TRUE == srv_mms_is_forward_lock(m_list->getMsgId(index)))
            {
                /* display a balloon */
                mmi_frm_nmgr_balloon(MMI_SCENARIO_ID_DEFAULT, MMI_EVENT_INFO_BALLOON, MMI_NMGR_BALLOON_TYPE_INFO, VFX_WSTR_RES(STR_ID_VAPP_MSG_DRM_MMS_CANNOT_EDIT));
            }
            return;
        }
    #endif /* __MMI_MMS_IN_UM__ */
        VfxBool isNeedConfirm = VFX_FALSE;
        VfxU16 displayString = 0;
        // launch UC
        VappUcEntryStruct *ucInfo;
        VFX_ALLOC_MEM(ucInfo, sizeof(VappUcEntryStruct), this);
        vfx_sys_mem_zero(ucInfo, sizeof(VappUcEntryStruct));
        ucInfo->info_type = transferUcType(msgType);
        ucInfo->msg_id = msgId;
        ucInfo->type = SRV_UC_STATE_EDIT_EXISTED_MSG;
        ucInfo->operation = UC_OPERATION_EDIT_EXISTED_MSG;
    #ifdef __MMI_MMS_IN_UM__
        if (SRV_UM_MSG_MMS == msgType)
        {
            ucInfo->mode = MMA_MODE_EDIT;
            isNeedConfirm = vapp_mms_is_need_show_edit_cnfm(msgId, &displayString);
        }
    #endif /* __MMI_MMS_IN_UM__ */
        if (VFX_TRUE == isNeedConfirm)
        {
            // record the data
            VFX_FREE_MEM(m_actionPtr);
            VFX_ALLOC_MEM(m_actionPtr, sizeof(VappUcEntryStruct), this);
            vfx_sys_mem_zero(m_actionPtr, sizeof(VappUcEntryStruct));
            vfx_sys_mem_copy(m_actionPtr, ucInfo, sizeof(VappUcEntryStruct));
            /* display restricted confirm */
            VcpConfirmPopup *confirm;
            VFX_OBJ_CREATE(confirm, VcpConfirmPopup, this);
            confirm->setText(displayString);
            confirm->setInfoType(VCP_POPUP_TYPE_WARNING);
            confirm->setButtonSet(VCP_CONFIRM_BUTTON_SET_YES_NO);
            confirm->setCustomButton(
                        STR_GLOBAL_CONTINUE, 
                        STR_GLOBAL_CANCEL, 
                        VCP_POPUP_BUTTON_TYPE_NORMAL, 
                        VCP_POPUP_BUTTON_TYPE_CANCEL);
            confirm->m_signalButtonClicked.connect(this, &VappMsgDialogPage::onRestrictConfirmClicked);
            confirm->show(VFX_TRUE);
        }
        else
        {
            mmi_id cuiId;
            cuiId = vcui_unifiedcomposer_create(getApp()->getGroupId(), ucInfo);
            if (cuiId != GRP_ID_INVALID)
            {
                vfxSetCuiCallerScr(cuiId, getMainScr());
                vcui_unifiedcomposer_run(cuiId);
            }
        }
        VFX_FREE_MEM(ucInfo);
#endif

#ifdef __MMI_SMS_COMPOSER__
        mmi_id cuiId = GRP_ID_INVALID;
        VcuiSmsComposerEntryStruct *entryData;
        VFX_ALLOC_MEM(entryData, sizeof(VcuiSmsComposerEntryStruct), this);
        vfx_sys_mem_zero(entryData, sizeof(VcuiSmsComposerEntryStruct));
        entryData->msg_id = msgId;
        entryData->operation = VCUI_SMS_COMPOSER_OPERATION_EDIT;                
            
        cuiId = vcui_sms_composer_create(getApp()->getGroupId());
        if (cuiId != GRP_ID_INVALID)
        {
            vfxSetCuiCallerScr(cuiId, getMainScr());
            vcui_sms_composer_set_entry_data(cuiId, entryData);
                
            vcui_sms_composer_run(cuiId);
        }
        VFX_FREE_MEM(entryData);
#endif
    }
}

void VappMsgDialogPage::onCellMarked(VfxControl * control, VfxU32 index, VfxBool isMarked)
{
    VFX_DEV_ASSERT(NULL != m_list);
    m_list->setMarkStatus(index, isMarked);
    updateMsToolbar();
}

void VappMsgDialogPage::onCellLongPressed(VfxControl * control, srv_um_msg_box_enum msgBox, VfxU32 msgId, srv_um_msg_enum msgType)
{
    if (VAPP_MSG_DIALOG_PAGE_MODE_MARK_SEVERAL == m_mode)
    {
        return;
    }
    // while refresh ind is during in pen_down and pen_up, there will be no list, just return
    if (VFX_FALSE == m_list->checkMsgList())
    {
        return;
    }
    
    m_isNotification = VFX_FALSE;
    
    /* this message is pending/waiting, the context will not show */
    if (SRV_UM_MSG_SMS == msgType)
    {
        srv_sms_send_status_enum smsSendStatus;
        smsSendStatus = srv_sms_get_unsent_msg_status(msgId);
        if (SRV_SMS_SEND_WAITING == smsSendStatus ||
            SRV_SMS_SEND_SENDING == smsSendStatus)
        {
            return;
        }
    }
#ifdef __MMI_MMS_IN_UM__
    else if (SRV_UM_MSG_MMS == msgType)
    {
        srv_mms_msg_status_enum mmsSendStatus;
        mmsSendStatus = srv_mms_get_msg_status(msgId);
        if (SRV_MMS_MSG_STATUS_SENDING == mmsSendStatus ||
            SRV_MMS_MSG_STATUS_WAITING == mmsSendStatus ||
            SRV_MMS_MSG_STATUS_PENDING == mmsSendStatus )
        {
            return;
        }   
        
#ifndef __MMI_MMS_REPORT_STATUS_SUPPORT__         
        if (srv_mms_is_delivery_report(msgId))
        {
            m_isNotification = VFX_TRUE;
        }
#endif /* __MMI_MMS_REPORT_STATUS_SUPPORT__ */
    }
#endif /* __MMI_MMS_IN_UM__ */  

    VFX_OBJ_CLOSE(m_contextMenu);
    VFX_OBJ_CREATE(m_contextMenu, VcpMenuPopup, this);
    m_contextMenu->setTitle(STR_ID_VAPP_MSG_MSG_OPTION);
    VfxS32 index;
    index = m_list->getIndex(msgId, msgType);
    VFX_ASSERT(-1 != index);
    
    createContextItem(m_contextMenu, msgBox, msgType, msgId, (VfxU32)index);
    m_contextMenu->m_signalMenuCallback.connect(this, &VappMsgDialogPage::onContextMenuSelected);
    m_contextMenu->showMenu();
    vfx_adp_touch_fb_play(VFX_ADP_TOUCH_FB_TYPE_HOLD);
}

void VappMsgDialogPage::onContextMenuSelected(VcpMenuPopup * menu,  VcpMenuPopupEventEnum event, VcpMenuPopupItem * item)
{
    if (VCP_MENU_POPUP_EVENT_MENU_CLOSE == event)
    {
        /* Because of autoDestory, this pointer will be destory by VcpMenuPopup itself. Just need to set as NULL */
        m_contextMenu = NULL;
    }
    if (VCP_MENU_POPUP_EVENT_ITEM_SELECTED != event)
    {
        return;
    }

    /* action */
    VappMsgCntxOptItemCp *cntxItem;
    cntxItem = VFX_OBJ_DYNAMIC_CAST(item, VappMsgCntxOptItemCp);
    VFX_ASSERT(NULL != cntxItem);
    switch (cntxItem->getId())
    {
        case VAPP_MSG_DIALOG_PAGE_LP_DELETE:
            longpressDelete(cntxItem);
            break;

        case VAPP_MSG_DIALOG_PAGE_LP_FORWARD:
            longpressForward(cntxItem);
            break;

        case VAPP_MSG_DIALOG_PAGE_LP_EDIT:
            longpressEdit(cntxItem);
            break;

        default:
            break;
    }
}

void VappMsgDialogPage::onLpActionClicked(VfxObject * obj, VfxId id)
{
    // only delete action now
    /* show processing */
    if (VCP_CONFIRM_POPUP_BUTTON_YES == id)
    {
        m_msProcessLoading->setText(STR_GLOBAL_DELETING);
        m_msProcessLoading->setInfoType(VCP_INDICATOR_POPUP_STYLE_ACTIVITY);
        m_msProcessLoading->setProgress(0);
        m_msProcessLoading->show(VFX_TRUE);
        m_msAction = SRV_UM_MARK_SEVERAL_OP_ACTION_DELETE;
        m_list->deleteMarked();
        m_listMenu->reset();
    }
    else
    {
        m_list->setMarkAll(VFX_FALSE);
    }
}

void VappMsgDialogPage::onMsActionClicked(VfxObject * obj, VfxId id)
{
    VFX_ASSERT(NULL != m_list);

    VfxU32 displayStringRes = STR_GLOBAL_COPYING;
    if (m_msAction == SRV_UM_MARK_SEVERAL_OP_ACTION_DELETE)
    {
        displayStringRes = STR_GLOBAL_DELETING;
    }

    switch (id)
    {
        case VCP_CONFIRM_POPUP_BUTTON_YES:
            /* show processing */
            m_msProcessLoading->setText(displayStringRes);
            m_msProcessLoading->setInfoType(VCP_INDICATOR_POPUP_STYLE_PROGRESS_WITH_CANCEL_BUTTON);
            m_msProcessLoading->setProgress(0);
            m_msProcessLoading->show(VFX_TRUE);
            m_msProcessTimer->start();
            /* start to process */
            msActionClicked(m_msAction);
            break;

        case VCP_CONFIRM_POPUP_BUTTON_NO:
        default:
            break;
    }
}

void VappMsgDialogPage::onCopyCmdClicked(VfxObject * obj, VfxId id)
{
    if (VAPP_MSG_DIALOG_PAGE_MS_ACTION_COPY_TO_TOTAL == id ||
        VCP_POPUP_BUTTON_NO_PRESSED == id)
    {
        m_msAction = SRV_UM_MARK_SEVERAL_OP_ACTION_NONE;
        m_msgCopyFilter.msg_type = SRV_UM_MSG_NONE;
        m_msgCopyFilter.msg_box = SRV_UM_MSG_BOX_NONE;
        m_msgCopyFilter.msg_storage = VAPP_MSG_STORAGE_NONE;
        return;
    }

    switch (id)
    {
#ifdef __UNIFIED_MESSAGE_ARCHIVE_SUPPORT__     
        case VAPP_MSG_DIALOG_PAGE_MS_ACTION_COPY_TO_ARCHIVE:
       {
            m_msAction = SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_ARCHIVE;
            m_msgCopyFilter.msg_type = (srv_um_msg_enum)(SRV_UM_MSG_SMS | SRV_UM_MSG_MMS);
            m_msgCopyFilter.msg_box = SRV_UM_MSG_BOX_ALL;
            m_msgCopyFilter.msg_storage = VAPP_MSG_STORAGE_PHONE_AND_MEMORY;
        }
            break;
#endif /* __UNIFIED_MESSAGE_ARCHIVE_SUPPORT__  */

        case VAPP_MSG_DIALOG_PAGE_MS_ACTION_COPY_TO_SIM1:
        {
            m_msAction = SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_SIM1;
            m_msgCopyFilter.msg_type = SRV_UM_MSG_SMS;
            m_msgCopyFilter.msg_box = SRV_UM_MSG_BOX_ALL;
            m_msgCopyFilter.msg_storage = VAPP_MSG_STORAGE_PHONE_AND_MEMORY;
        }
            break;

    #if (MMI_MAX_SIM_NUM >= 2)
        case VAPP_MSG_DIALOG_PAGE_MS_ACTION_COPY_TO_SIM2:
        {
            m_msAction = SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_SIM2;
            m_msgCopyFilter.msg_type = SRV_UM_MSG_SMS;
            m_msgCopyFilter.msg_box = SRV_UM_MSG_BOX_ALL;
            m_msgCopyFilter.msg_storage = VAPP_MSG_STORAGE_PHONE_AND_MEMORY;
        }
            break;
    #endif /* MMI_MAX_SIM_NUM >= 2 */

    #if (MMI_MAX_SIM_NUM >= 3)
        case VAPP_MSG_DIALOG_PAGE_MS_ACTION_COPY_TO_SIM3:
        {
            m_msAction = SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_SIM3;
            m_msgCopyFilter.msg_type = SRV_UM_MSG_SMS;
            m_msgCopyFilter.msg_box = SRV_UM_MSG_BOX_ALL;
            m_msgCopyFilter.msg_storage = VAPP_MSG_STORAGE_PHONE_AND_MEMORY;
        }
            break;
    #endif /* MMI_MAX_SIM_NUM >= 3 */

    #if (MMI_MAX_SIM_NUM >= 4)
        case VAPP_MSG_DIALOG_PAGE_MS_ACTION_COPY_TO_SIM4:
        {
            m_msAction = SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_SIM4;
            m_msgCopyFilter.msg_type = SRV_UM_MSG_SMS;
            m_msgCopyFilter.msg_box = SRV_UM_MSG_BOX_ALL;
            m_msgCopyFilter.msg_storage = VAPP_MSG_STORAGE_PHONE_AND_MEMORY;
        }
            break;
    #endif /* MMI_MAX_SIM_NUM >= 4 */

    #if (MMI_MAX_SIM_NUM >= 2)
        case VAPP_MSG_DIALOG_PAGE_MS_ACTION_COPY_TO_SIM_SELECT:
        {
            /* show another VcpCommandPopup to select */
            U16 index = 0;
            U16 copyId = VAPP_MSG_DIALOG_PAGE_MS_ACTION_COPY_TO_SIM1;
            mmi_sim_enum sim = MMI_SIM1;
            VcpCommandPopup *cmdPopup;
            VFX_OBJ_CREATE(cmdPopup, VcpCommandPopup, this);
            cmdPopup->setText(STR_ID_VAPP_MSG_COPY_SMS_TO_SIM);
            for (index = 0 ; index < MMI_MAX_SIM_NUM ; index++, copyId++, sim = (mmi_sim_enum)(sim << 1))
            {
                if (MMI_TRUE == srv_sim_ctrl_is_inserted(sim))
                {
                    cmdPopup->addItem(copyId, vapp_sim_settings_get_sim_name_with_sim_id(sim), VCP_POPUP_BUTTON_TYPE_NORMAL);
                }
            }
            cmdPopup->addItem(VAPP_MSG_DIALOG_PAGE_MS_ACTION_COPY_TO_TOTAL, STR_GLOBAL_CANCEL, VCP_POPUP_BUTTON_TYPE_CANCEL);
            cmdPopup->m_signalButtonClicked.connect(this, &VappMsgDialogPage::onCopyCmdClicked);
            cmdPopup->show(VFX_TRUE);
            m_msAction = SRV_UM_MARK_SEVERAL_OP_ACTION_NONE;
            m_msgCopyFilter.msg_type = SRV_UM_MSG_NONE;
            m_msgCopyFilter.msg_box = SRV_UM_MSG_BOX_NONE;
            m_msgCopyFilter.msg_storage = VAPP_MSG_STORAGE_NONE;
        }
            break;
    #endif /* MMI_MAX_SIM_NUM >= 2 */

    #ifdef __MMI_SMS_TCARD_STORAGE_SUPPORT__
        case VAPP_MSG_DIALOG_PAGE_MS_ACTION_COPY_SMS_TO_PHONE:
            m_msAction = SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_PHONE;
            m_msgCopyFilter.msg_type = SRV_UM_MSG_SMS;
            m_msgCopyFilter.msg_box = SRV_UM_MSG_BOX_ALL;
            m_msgCopyFilter.msg_storage = VAPP_MSG_STORAGE_MEMORY_CARD;
            break;

        case VAPP_MSG_DIALOG_PAGE_MS_ACTION_COPY_SMS_TO_MEM_CARD:
            m_msAction = SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_MEMORY_CARD;
            m_msgCopyFilter.msg_type = SRV_UM_MSG_SMS;
            m_msgCopyFilter.msg_box = SRV_UM_MSG_BOX_ALL;
            m_msgCopyFilter.msg_storage = VAPP_MSG_STORAGE_PHONE;
            break;
    #endif /* __MMI_SMS_TCARD_STORAGE_SUPPORT__ */

        case VAPP_MSG_DIALOG_PAGE_MS_ACTION_COPY_MMS_TO_PHONE:
            m_msAction = SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_PHONE;
            m_msgCopyFilter.msg_type = SRV_UM_MSG_MMS;
            m_msgCopyFilter.msg_box = SRV_UM_MSG_BOX_ALL;
            m_msgCopyFilter.msg_storage = VAPP_MSG_STORAGE_MEMORY_CARD;
            break;

        case VAPP_MSG_DIALOG_PAGE_MS_ACTION_COPY_MMS_TO_MEM_CARD:
            m_msAction = SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_MEMORY_CARD;
            m_msgCopyFilter.msg_type = SRV_UM_MSG_MMS;
            m_msgCopyFilter.msg_box = SRV_UM_MSG_BOX_ALL;
            m_msgCopyFilter.msg_storage = VAPP_MSG_STORAGE_PHONE;
            break;

        default:
            VFX_ASSERT(0);
            break;
    }

    if (SRV_UM_MARK_SEVERAL_OP_ACTION_NONE != m_msAction)
    {
        m_isNewMode = VFX_TRUE;
        m_mode = VAPP_MSG_DIALOG_PAGE_MODE_MARK_SEVERAL;
        checkUpdate();
    }
}

void VappMsgDialogPage::onMsOpCancelled(VfxObject * obj, VfxFloat progress)
{
    VFX_ASSERT(NULL != m_list);
    if (SRV_UM_MARK_SEVERAL_OP_ACTION_NONE == m_msAction)
    {
        /* already finished */
        return;
    }

    //m_msAction = SRV_UM_MARK_SEVERAL_OP_ACTION_NONE;
    m_msgCopyFilter.msg_type = SRV_UM_MSG_NONE;
    m_msgCopyFilter.msg_box = SRV_UM_MSG_BOX_NONE;
    m_msgCopyFilter.msg_storage = VAPP_MSG_STORAGE_NONE;
    m_list->cancelMsAction();

    m_msProcessLoading->hide(VFX_TRUE);
    m_msProcessTimer->stop();
    showLoading();
    m_isBlockUpdate = VFX_TRUE;
}

void VappMsgDialogPage::onMsProgressTimeout(VfxTimer * timer)
{
    if (VFX_TRUE == m_list->getIsMsActionActive())
    {
        // update the process screen
        VfxS32 finishNum, totalNum;
        finishNum = totalNum = 0;
        m_list->getMsActionDuriation(finishNum, totalNum);
        // update it
        m_msProcessLoading->setProgress((VfxFloat)finishNum/(VfxFloat)totalNum);
    }
    else
    {
        m_msProcessTimer->stop();
    }
}

void VappMsgDialogPage::onEditorTextChanged(VcpTextEditor * editor)
{
    if (NULL == m_toolbar)
    {
        return;
    }

    if (VFX_FALSE == m_isMultiAddr)
    {
        if (0 == srv_sim_ctrl_get_num_of_inserted())
        {
            /* no sim insert */
            m_toolbar->setDisableItem(VAPP_MSG_DIALOG_PAGE_TOOLBAR_SEND, VFX_TRUE);
            m_editFuncbar->setDisableItem(VAPP_MSG_DIALOG_PAGE_FB_SEND, VFX_TRUE);
        }
        else
        {
            /* normal case, based on the number of text */
            if (0 == vfx_sys_wcslen(editor->getText()) || 
                VFX_WSTR_EMPTY == m_address)
            {
                m_toolbar->setDisableItem(VAPP_MSG_DIALOG_PAGE_TOOLBAR_SEND, VFX_TRUE);
                m_editFuncbar->setDisableItem(VAPP_MSG_DIALOG_PAGE_FB_SEND, VFX_TRUE);
            }
            else
            {
                m_toolbar->setDisableItem(VAPP_MSG_DIALOG_PAGE_TOOLBAR_SEND, VFX_FALSE);
                m_editFuncbar->setDisableItem(VAPP_MSG_DIALOG_PAGE_FB_SEND, VFX_FALSE);
            }
        }
    }
}

void VappMsgDialogPage::onEditorFbClick(VfxObject * obj,VfxId id)
{
    switch (id)
    {
#if defined(__MMI_VUI_TEXT_EMOTION_ICON_SUPPORT__)    
        case VAPP_MSG_DIALOG_PAGE_FB_EMOTICON:
        {
            VappUcEmoticon *emoticon;
            VFX_OBJ_CREATE(emoticon, VappUcEmoticon, this);
            emoticon->m_signalcallback.connect(this, &VappMsgDialogPage::onEmoticonClicked);
            emoticon->show(VFX_TRUE);
        }
            break;
#endif /* __MMI_VUI_TEXT_EMOTION_ICON_SUPPORT__ */

        case VAPP_MSG_DIALOG_PAGE_FB_INSERT:
        {
        #ifdef __MMI_UNIFIED_COMPOSER__
            VFX_ASSERT(NULL != m_editor);
            VappUcEntryStruct *ucInfo;
            VFX_ALLOC_MEM(ucInfo, sizeof(VappUcEntryStruct), this);
            vfx_sys_mem_zero(ucInfo, sizeof(VappUcEntryStruct));
            ucInfo->info_type = SRV_UC_INFO_TYPE_SMS;
            VfxWString tmp;
            tmp = VFX_WSTR_MEM(m_editor->getText());

            /* start to launch UC */
            ucInfo->text_buffer = (U8 *)tmp.getBuf();
            ucInfo->text_num = (U16)tmp.getLength();
            ucInfo->type = SRV_UC_STATE_WRITE_NEW_MSG;
            ucInfo->operation = UC_OPERATION_WRITE_NEW_MSG;
            ucInfo->launch_mode = UC_LAUNCH_MODE_INSERT;
            ucInfo->sim_id = SRV_UC_SIM_ID_GSM_SIM1;
        #if (MMI_MAX_SIM_NUM >= 2)
            if (SRV_UM_SIM_GSM_SIM2 == m_addressSimId)
            {
                ucInfo->sim_id = SRV_UC_SIM_ID_GSM_SIM2;
            }
        #endif /* MMI_MAX_SIM_NUM >= 2 */
        #if (MMI_MAX_SIM_NUM >= 3)
            else if (SRV_UM_SIM_GSM_SIM3 == m_addressSimId)
            {
                ucInfo->sim_id = SRV_UC_SIM_ID_GSM_SIM3;
            }
        #endif /* MMI_MAX_SIM_NUM >= 3*/
        #if (MMI_MAX_SIM_NUM >= 4)
            else if (SRV_UM_SIM_GSM_SIM4 == m_addressSimId)
            {
                ucInfo->sim_id = SRV_UC_SIM_ID_GSM_SIM4;
            }
        #endif /* MMI_MAX_SIM_NUM >= 4*/
            if (VFX_WSTR_EMPTY != m_address)
            {
                ucInfo->addr_num = 1;
                VFX_ALLOC_MEM(ucInfo->addr, sizeof(srv_uc_addr_struct), this);
                vfx_sys_mem_zero(ucInfo->addr, sizeof(srv_uc_addr_struct));
                ucInfo->addr->addr = (kal_uint8 *)m_address.getBuf();
                /* default is number */
                if (SRV_UM_ADDR_EMAIL_ADDRESS == m_addressType)
                {
                    ucInfo->addr->type = SRV_UC_ADDRESS_TYPE_EMAIL;
                }
                else if (SRV_UM_ADDR_IP_ADDRESS == m_addressType)
                {
                    ucInfo->addr->type = SRV_UC_ADDRESS_TYPE_IP;
                }
                mmi_id cuiId;
                cuiId = vcui_unifiedcomposer_create(getApp()->getGroupId(), ucInfo);
                if (cuiId != GRP_ID_INVALID)
                {
                    /* clean editor and deactivate */
                    m_editor->deactivate();
                    m_editor->setText(VFX_WSTR_EMPTY, m_editorMaxLength);
            
                    vfxSetCuiCallerScr(cuiId, getMainScr());
                    vcui_unifiedcomposer_run(cuiId);
                }
                VFX_FREE_MEM(ucInfo->addr);
            }
            else
            {
                mmi_id cuiId;
                cuiId = vcui_unifiedcomposer_create(getApp()->getGroupId(), ucInfo);
                if (cuiId != GRP_ID_INVALID)
                {
                    /* clean editor and deactivate */
                    m_editor->deactivate();
                    m_editor->setText(VFX_WSTR_EMPTY, m_editorMaxLength);
                    
                    vfxSetCuiCallerScr(cuiId, getMainScr());
                    vcui_unifiedcomposer_run(cuiId);
                }
            }
            VFX_FREE_MEM(ucInfo);
        #endif
        #ifdef __MMI_SMS_COMPOSER__
            VcpCommandPopup *commandPopup = NULL;
            VFX_OBJ_CREATE(commandPopup, VcpCommandPopup, this);
            commandPopup->setText(STR_ID_VCUI_SMSC_INSERT_ID);
            commandPopup->addItem(
                VAPP_MSG_POP_PHB_NAME, STR_ID_VCUI_SMSC_INSERT_PHB_NAME_ID);
            commandPopup->addItem(
                VAPP_MSG_POP_PHB_NUM, STR_ID_VCUI_SMSC_INSERT_PHB_NUMBER_ID);
            commandPopup->addItem(
                0xFFFF, STR_GLOBAL_CANCEL, VCP_POPUP_BUTTON_TYPE_CANCEL);         
            commandPopup->setAutoDestory(VFX_TRUE);
            commandPopup->m_signalButtonClicked.connect(this, &VappMsgDialogPage::onCommandPopClicked); 
            commandPopup->show(VFX_TRUE);
        #endif
        }
            break;
#ifdef __MMI_UM_TEMPLATE_SUPPORT__ 
        case VAPP_MSG_DIALOG_PAGE_FB_TEMPLATE:
        {
            VappTextTemplateListPage *templatePage;
            VFX_OBJ_CREATE(templatePage, VappTextTemplateListPage, this);
            templatePage->m_signalTemplateTapped.connect(this, &VappMsgDialogPage::onSmsTemplateClicked);
            getMainScr()->pushPage(VappMsgScreen::VAPP_MSG_SCREEN_PAGE_DIALOG_LIST_SMS_TEMPLATE_LIST, templatePage);
        }
            break;
#endif /* __MMI_UM_TEMPLATE_SUPPORT__ */
        case VAPP_MSG_DIALOG_PAGE_FB_SEND:
            /* use the function to do the same thing */
            onToolbarClick(NULL, VAPP_MSG_DIALOG_PAGE_TOOLBAR_SEND);
            break;

        default:
            break;
    }
}

void VappMsgDialogPage::onEditorBoundsChange(VfxFrame * frame, const VfxRect & rect)
{
    // get the editor background size/pos
    VfxFrame *editorBg;
    editorBg = frame->getParentFrame();

    editorBg->setSize(getSize().width, frame->getSize().height + VAPP_MSG_DIALOG_EDITOR_UP_MARGIN + VAPP_MSG_DIALOG_EDITOR_DOWN_MARGIN);
    frame->setPos(VAPP_MSG_DIALOG_EDITOR_LEFT_MARGIN, VAPP_MSG_DIALOG_EDITOR_UP_MARGIN);
    editorBg->setPos(0, getSize().height - editorBg->getSize().height);

    // new height
    VfxS32 newListHeight = 0;
    newListHeight = getSize().height - m_contactBar->getSize().height - editorBg->getSize().height + m_contactBar->getShadowHeight() + VAPP_MSG_DIALOG_EDITOR_SHADOW;
    if (0 < newListHeight)
    {
        // only height is valid, then set total size/pos
        m_listMenu->setSize(getSize().width, newListHeight);
        m_listMenu->setPos(0, m_contactBar->getSize().height - m_contactBar->getShadowHeight());
        m_listMenu->setAlignParent(
                        VFX_FRAME_ALIGNER_MODE_SIDE, 
                        VFX_FRAME_ALIGNER_MODE_SIDE, 
                        VFX_FRAME_ALIGNER_MODE_SIDE, 
                        VFX_FRAME_ALIGNER_MODE_SIDE);
    }
}

#if defined(__MMI_VUI_TEXT_EMOTION_ICON_SUPPORT__)
void VappMsgDialogPage::onEmoticonClicked(VfxObject * obj,VfxU32 index)
{
#ifdef __MMI_UNIFIED_COMPOSER__
    VFX_ASSERT(NULL != m_editor);
    VFX_ASSERT(VFX_FALSE == m_isMultiAddr);

    /* keep the text,  cause we need to delete the emoticon chars inserted later when it fails to launch UC */
    VfxWString textToKeep;
    textToKeep = VFX_WSTR_MEM(m_editor->getText());
    
    /* get the text and launch the UC */
    VfxWString tmp;
    VappUcEmoticon *ucEmoticon;
    ucEmoticon = VFX_OBJ_DYNAMIC_CAST(obj, VappUcEmoticon);
    VFX_ASSERT(NULL != ucEmoticon);
    m_editor->insertText((VfxWChar *)(ucEmoticon->getTextByIndex(index).getBuf()));
    tmp = VFX_WSTR_MEM(m_editor->getText());

    VappUcEntryStruct *ucInfo;
    VFX_ALLOC_MEM(ucInfo, sizeof(VappUcEntryStruct), this);
    vfx_sys_mem_zero(ucInfo, sizeof(VappUcEntryStruct));
    ucInfo->info_type = SRV_UC_INFO_TYPE_SMS;
    ucInfo->text_buffer = (U8 *)tmp.getBuf();
    ucInfo->text_num = (U16)tmp.getLength();
    ucInfo->type = SRV_UC_STATE_WRITE_NEW_MSG;
    ucInfo->operation = UC_OPERATION_WRITE_NEW_MSG;
    ucInfo->launch_mode = UC_LAUNCH_MODE_EMOTICON;
    ucInfo->sim_id = SRV_UC_SIM_ID_GSM_SIM1;
#if (MMI_MAX_SIM_NUM >= 2)
    if (SRV_UM_SIM_GSM_SIM2 == m_addressSimId)
    {
        ucInfo->sim_id = SRV_UC_SIM_ID_GSM_SIM2;
    }
#endif /* MMI_MAX_SIM_NUM */
#if (MMI_MAX_SIM_NUM >= 3)
    else if (SRV_UM_SIM_GSM_SIM3 == m_addressSimId)
    {
        ucInfo->sim_id = SRV_UC_SIM_ID_GSM_SIM3;
    }
#endif /* MMI_MAX_SIM_NUM >= 3*/
#if (MMI_MAX_SIM_NUM >= 4)
    else if (SRV_UM_SIM_GSM_SIM4 == m_addressSimId)
    {
        ucInfo->sim_id = SRV_UC_SIM_ID_GSM_SIM4;
    }
#endif /* MMI_MAX_SIM_NUM >= 4*/

    if (VFX_WSTR_EMPTY != m_address)
    {
        ucInfo->addr_num = 1;
        VFX_ALLOC_MEM(ucInfo->addr, sizeof(srv_uc_addr_struct), this);
        vfx_sys_mem_zero(ucInfo->addr, sizeof(srv_uc_addr_struct));
        ucInfo->addr->addr = (kal_uint8 *)m_address.getBuf();
        /* default is number */
        if (SRV_UM_ADDR_EMAIL_ADDRESS == m_addressType)
        {
            ucInfo->addr->type = SRV_UC_ADDRESS_TYPE_EMAIL;
        }
        else if (SRV_UM_ADDR_IP_ADDRESS == m_addressType)
        {
            ucInfo->addr->type = SRV_UC_ADDRESS_TYPE_IP;
        }
        mmi_id cuiId;
        cuiId = vcui_unifiedcomposer_create(getApp()->getGroupId(), ucInfo);
        if (cuiId != GRP_ID_INVALID)
        {
            m_editor->setText(VFX_WSTR_EMPTY,m_editorMaxLength);
            m_editor->deactivate();    
            vfxSetCuiCallerScr(cuiId, getMainScr());
            vcui_unifiedcomposer_run(cuiId);
        }
        else
        {
            m_editor->setText(textToKeep, m_editorMaxLength);
        }
        VFX_FREE_MEM(ucInfo->addr);
    }
    else
    {
        mmi_id cuiId;
        cuiId = vcui_unifiedcomposer_create(getApp()->getGroupId(), ucInfo);
        if (cuiId != GRP_ID_INVALID)
        {
            m_editor->setText(VFX_WSTR_EMPTY,m_editorMaxLength);
            m_editor->deactivate();
            vfxSetCuiCallerScr(cuiId, getMainScr());
            vcui_unifiedcomposer_run(cuiId);
        }
        else
        {
            m_editor->setText(textToKeep, m_editorMaxLength);
        }
    }
    VFX_FREE_MEM(ucInfo);
#endif
}
#endif  /* __MMI_VUI_TEXT_EMOTION_ICON_SUPPORT__ */

#ifdef __MMI_UM_TEMPLATE_SUPPORT__
void VappMsgDialogPage::onSmsTemplateClicked(VfxObject * obj,VfxWString templateString,VfxU16 templateId)
{
    VappTextTemplateListPage *page;
    page = (VappTextTemplateListPage *)obj;

    m_editor->insertText((VfxWChar *)templateString.getBuf());

    // close page 
    page->closePage();

    // active the editor
    m_editor->activate();
}
#endif /* __MMI_UM_TEMPLATE_SUPPORT__ */

mmi_ret VappMsgDialogPage::onMsgSrvEvtCb(mmi_event_struct * param)
{
    mmi_ret ret = MMI_RET_OK;
    VappMsgDialogPage *self = (VappMsgDialogPage *)VfxObject::handleToObject((VfxObjHandle)param->user_data);

    if (self)
    {
        MMI_PRINT(MOD_MMI_COMMON_APP, TRACE_GROUP_6, "%s", self->getClassInfo()->getClassName());
        MMI_TRACE(TRACE_GROUP_6, TRC_MMI_VAPP_MSG_UM_SRV_EVT, param->evt_id, self);
        if (self->isKindOf(VFX_OBJ_CLASS_INFO(VappMsgDialogPage)))
        {
        #ifdef __MMI_SMS_TCARD_STORAGE_SUPPORT__
            if (EVT_ID_SRV_SMS_SAVE_STORAGE_STATUS == param->evt_id)
            {
    		    srv_sms_event_struct* sms_event = (srv_sms_event_struct*)param;
    		    srv_sms_event_for_memory_status_struct* memory_status = (srv_sms_event_for_memory_status_struct*)(sms_event->event_info);
                if (memory_status->save_to_type != srv_sms_get_prefer_storage(SRV_SMS_SIM_1))
                {
                    if (SRV_SMS_STORAGE_ME == memory_status->save_to_type)
        			{
        			    if (memory_status->is_tcard_avail)
        				self->m_saveStatus = VAPP_MSG_TCARD_SAVE_PHONE_CARD_FULL;
        			    else
        				self->m_saveStatus = VAPP_MSG_TCARD_SAVE_PHONE_NO_CARD;
        			}
                    else if (SRV_SMS_STORAGE_TCARD == memory_status->save_to_type)
        			{
                        self->m_saveStatus = VAPP_MSG_TCARD_SAVE_CARD_PHONE_FULL;
        			}

        			return ret;
                }
            }
        #endif /* __MMI_SMS_TCARD_STORAGE_SUPPORT__ */

            /* non-multiple, return */
            if (VFX_FALSE == self->m_isMultiAddr)
            {
                return ret;
            }

            switch (param->evt_id)
            {
                case EVT_ID_SRV_SMS_UPDATE_UNSENT_MSG_STATUS:
                    ret = self->smsSendEvtHdlr(param);
                    break;

            #ifdef __MMI_MMS_IN_UM__
                case EVT_ID_SRV_MMS_UPDATE_STATUS:
                    ret = self->mmsSendEvtHdlr(param);
                    break;
            #endif /* __MMI_MMS_IN_UM__ */

                default:
                    break;
            }
        }
    }

    return ret;
}

mmi_ret VappMsgDialogPage::smsSendEvtHdlr(mmi_event_struct * evt)
{
    VappMsgDialogPage *self = (VappMsgDialogPage *)VfxObject::handleToObject((VfxObjHandle)evt->user_data);

    if (self)
    {
        MMI_PRINT(MOD_MMI_COMMON_APP, TRACE_GROUP_6, "%s", self->getClassInfo()->getClassName());
        MMI_TRACE(TRACE_GROUP_6, TRC_MMI_VAPP_MSG_SMS_SRV_EVT, evt->evt_id, self);
        srv_sms_event_struct *smsEvt;
        smsEvt = (srv_sms_event_struct *)evt;

        srv_sms_event_update_unsent_msg_status_struct *smsUnsent;
        smsUnsent = (srv_sms_event_update_unsent_msg_status_struct *)smsEvt->event_info;

        if (self->m_msgId == smsUnsent->msg_id)
        {
            self->updateToolbar();
        }
    }

    return MMI_RET_OK;
}

#ifdef __MMI_MMS_IN_UM__
mmi_ret VappMsgDialogPage::mmsSendEvtHdlr(mmi_event_struct * evt)
{
    VappMsgDialogPage *self = (VappMsgDialogPage *)VfxObject::handleToObject((VfxObjHandle)evt->user_data);

    if (self)
    {
        MMI_PRINT(MOD_MMI_COMMON_APP, TRACE_GROUP_6, "%s", self->getClassInfo()->getClassName());
        MMI_TRACE(TRACE_GROUP_6, TRC_MMI_VAPP_MSG_MMS_SRV_EVT, evt->evt_id, self);
        srv_mms_base_event_struct *mmsEvt;
        mmsEvt = (srv_mms_base_event_struct *)evt;

        srv_mms_update_status_struct *mmsUnsent;
        mmsUnsent = (srv_mms_update_status_struct *)mmsEvt->sender_data;

        if (self->m_msgId == mmsUnsent->msg_id)
        {
            self->updateToolbar();
        }
    }

    return MMI_RET_OK;
}
#endif /* __MMI_MMS_IN_UM__ */

void VappMsgDialogPage::smsSendCb(srv_sms_callback_struct * cbData)
{
    VappMsgDialogPage *self = (VappMsgDialogPage *)VfxObject::handleToObject((VfxObjHandle)cbData->user_data);

    if (self)
    {
        if (SRV_SMS_ACTION_SAVE == cbData->action || SRV_SMS_ACTION_SEND == cbData->action) 
		{
            if (SRV_SMS_CAUSE_NO_ERROR != cbData->cause)
			{
				/* display balloon */
				switch (cbData->cause)
				{
					case SRV_SMS_CAUSE_MEM_INSUFFICIENT:
						mmi_frm_nmgr_balloon(MMI_SCENARIO_ID_DEFAULT, MMI_EVENT_INFO_BALLOON, MMI_NMGR_BALLOON_TYPE_INFO, VFX_WSTR_RES(STR_ID_VAPP_MSG_INSUFFICIENT_MEMORY));
						break;
	                
					case SRV_SMS_CAUSE_MEM_FULL:
						mmi_frm_nmgr_balloon(MMI_SCENARIO_ID_DEFAULT, MMI_EVENT_INFO_BALLOON, MMI_NMGR_BALLOON_TYPE_INFO, VFX_WSTR_RES(STR_GLOBAL_MEMORY_FULL));
						break;    

					case SRV_SMS_CAUSE_NUMBER_INVALID:
						mmi_frm_nmgr_balloon(MMI_SCENARIO_ID_DEFAULT, MMI_EVENT_INFO_BALLOON, MMI_NMGR_BALLOON_TYPE_INFO, VFX_WSTR_RES(STR_ID_VAPP_MSG_INVALID_RECIPIENT));
						break;  

                #ifdef __MMI_UNIFIED_COMPOSER__
					case SRV_SMS_CAUSE_TCARD_NOT_AVAILABLE:
						mmi_frm_nmgr_balloon(MMI_SCENARIO_ID_DEFAULT, MMI_EVENT_INFO_BALLOON, MMI_NMGR_BALLOON_TYPE_INFO, VFX_WSTR_RES(STR_ID_VAPP_UC_INSERT_CARD));
						break;  
                #endif

					default:
						mmi_frm_nmgr_balloon(MMI_SCENARIO_ID_DEFAULT, MMI_EVENT_INFO_BALLOON, MMI_NMGR_BALLOON_TYPE_INFO, VFX_WSTR_RES(STR_GLOBAL_ERROR));
						break;
				}
			}
			else
			{
				switch (self->m_saveStatus)
				{
					case VAPP_MSG_TCARD_SAVE_PHONE_CARD_FULL:
						mmi_frm_nmgr_balloon(MMI_SCENARIO_ID_DEFAULT, MMI_EVENT_INFO_BALLOON, MMI_NMGR_BALLOON_TYPE_INFO, VFX_WSTR_RES(STR_ID_VAPP_MSG_MEMORY_CARD_FULL_SAVE_TO_PHONE));
						break;

                #ifdef __MMI_UNIFIED_COMPOSER__
					case VAPP_MSG_TCARD_SAVE_PHONE_NO_CARD:
						mmi_frm_nmgr_balloon(MMI_SCENARIO_ID_DEFAULT, MMI_EVENT_INFO_BALLOON, MMI_NMGR_BALLOON_TYPE_INFO, VFX_WSTR_RES(STR_ID_VAPP_UC_TCARD_NOT_PRESENT_USE_PHONE));
						break;
                #endif

					case VAPP_MSG_TCARD_SAVE_CARD_PHONE_FULL:
						mmi_frm_nmgr_balloon(MMI_SCENARIO_ID_DEFAULT, MMI_EVENT_INFO_BALLOON, MMI_NMGR_BALLOON_TYPE_INFO, VFX_WSTR_RES(STR_ID_VAPP_MSG_PHONE_FULL_SAVE_TO_MEMORY_CARD));   
						break;

					default:
						break;
				}
			}
		}
    }
	self->m_saveStatus = VAPP_MSG_TCARD_SAVE_NONE;
}

#if (MMI_MAX_SIM_NUM >= 2)
void VappMsgDialogPage::onSendConfirmClicked(VfxObject * obj,VfxId id)
{
    VfxBool isSend = VFX_FALSE;
    switch (id)
    {
        case MMI_SIM1:
        case MMI_SIM2:
        case MMI_SIM3:
        case MMI_SIM4:
            isSend = VFX_TRUE;
            break;

        default:
            break;
    }
    if (VFX_TRUE == isSend)
    {
        sendSms((mmi_sim_enum)id);
    }
}
#endif /* MMI_MAX_SIM_NUM */

void VappMsgDialogPage::onRestrictConfirmClicked(VfxObject * obj,VfxId id)
{
#ifdef __MMI_UNIFIED_COMPOSER__
    VFX_ASSERT(NULL != m_actionPtr);
    if (VCP_CONFIRM_POPUP_BUTTON_YES == id)
    {
        mmi_id cuiId;
        cuiId = vcui_unifiedcomposer_create(getApp()->getGroupId(), (VappUcEntryStruct *)m_actionPtr);
        if (cuiId != GRP_ID_INVALID)
        {
            vfxSetCuiCallerScr(cuiId, getMainScr());
            vcui_unifiedcomposer_run(cuiId);
        }
    }

    // free memory
    VFX_FREE_MEM(m_actionPtr);
#endif
}

void VappMsgDialogPage::showLoading()
{
    m_loading->start();
    if (NULL != m_listMenu)
    {
        m_listMenu->setIsUnhittable(VFX_TRUE);
    }
    m_contactBar->setIsUnhittable(VFX_TRUE);
    if (NULL != m_editor)
    {
        m_editor->setIsDisabled(VFX_TRUE);
    }
    m_toolbar->setIsUnhittable(VFX_TRUE);
}

void VappMsgDialogPage::stopLoading()
{
    m_loading->stop();
    if (NULL != m_listMenu)
    {
        if(m_listMenu->hasPlayAnimation())
        {
            m_listMenu->setIsUnhittable(VFX_FALSE);
        }
    }
    if (NULL != m_editor)
    {
        /* mark several could not hit always */
        if (VAPP_MSG_DIALOG_PAGE_MODE_MARK_SEVERAL == m_mode)
        {
            m_editor->setIsDisabled(VFX_TRUE);
        }
        else
        {
            m_editor->setIsDisabled(VFX_FALSE);
        }
    }
    m_contactBar->setIsUnhittable(VFX_FALSE);
    m_toolbar->setIsUnhittable(VFX_FALSE);
}

VfxPage *VappMsgDialogPage::createViewerPage(VfxU32 msgId, VfxU32 msgType)
{
    switch (msgType)
    {
        case SRV_UM_MSG_SMS:
            VappSmsViewerPage *smsViewerPage;
            VFX_OBJ_CREATE(smsViewerPage, VappSmsViewerPage, getMainScr());
            smsViewerPage->setMsgID(msgId);
            return smsViewerPage;

    #ifdef __MMI_MMS_IN_UM__
        case SRV_UM_MSG_MMS:
            VappMmsViewerPage *mmsViewerPage;
            VFX_OBJ_CREATE_EX(mmsViewerPage, VappMmsViewerPage, getMainScr(), (MODE_STOP, msgId));
            return mmsViewerPage;
    #endif /* __MMI_MMS_IN_UM__ */

    #ifdef __MMI_PUSH_IN_UM__
        case SRV_UM_MSG_WAP_PUSH:
            VappWapPushViewerPage *pushViewerPage;
            VFX_OBJ_CREATE_EX(pushViewerPage, VappWapPushViewerPage, getMainScr(), (msgId));
            return pushViewerPage;
    #endif /* __MMI_PUSH_IN_UM__ */

    #ifdef __MMI_PROV_IN_UM__
        case SRV_UM_MSG_PROV:
            VappProvDetailPage *provViewerPage;
            VFX_OBJ_CREATE_EX(provViewerPage, VappProvDetailPage, getMainScr(), (msgId, SRV_UM_MSG_PROV));
            return provViewerPage;
    #endif /* __MMI_PROV_IN_UM__ */

        default:
            VFX_ASSERT(0);
            break;
    }
    return NULL;
}

void VappMsgDialogPage::updateToolbar()
{
    if (VFX_FALSE == m_isSetAddr)
    {
        return;
    }

    /* remove all items */
    VfxU32 i;
    for (i = VAPP_MSG_DIALOG_PAGE_TOOLBAR_SEND ; i < VAPP_MSG_DIALOG_PAGE_TOOLBAR_END ; i++)
    {
        m_toolbar->removeItem(i);
    }

    /* add new items */
    if (VAPP_MSG_DIALOG_PAGE_MODE_NORMAL == m_mode)
    {
        if (VFX_FALSE == m_isMultiAddr)
        {
            m_toolbar->addItem(VAPP_MSG_DIALOG_PAGE_TOOLBAR_SEND, VCP_STR_TOOL_BAR_SEND, VCP_IMG_TOOL_BAR_COMMON_ITEM_SEND);
            /* disable the send */
            if (0 == vfx_sys_wcslen(m_editor->getText()) ||
                VFX_WSTR_EMPTY == m_address)
            {
                m_toolbar->setDisableItem(VAPP_MSG_DIALOG_PAGE_TOOLBAR_SEND, VFX_TRUE);
            }
            if (0 == srv_sim_ctrl_get_num_of_inserted())
            {
                /* not insert sim card, disable */
                m_toolbar->setDisableItem(VAPP_MSG_DIALOG_PAGE_TOOLBAR_SEND, VFX_TRUE);
            }
            m_toolbar->addItem(VAPP_MSG_DIALOG_PAGE_TOOLBAR_CALL, STR_GLOBAL_DIAL, IMG_ID_VAPP_MSG_TB_CALL);
            /* disable call toolbar */
            if (VFX_WSTR_EMPTY == m_address ||
                SRV_UM_ADDR_PHONE_NUMBER != m_addressType)
            {
                m_toolbar->setDisableItem(VAPP_MSG_DIALOG_PAGE_TOOLBAR_CALL, VFX_TRUE);
            }
            m_toolbar->addItem(VAPP_MSG_DIALOG_PAGE_TOOLBAR_DELETE, VCP_STR_TOOL_BAR_DELETE, VCP_IMG_TOOL_BAR_COMMON_ITEM_DELETE);

        #if ((defined __MMI_MMS_IN_UM__ && !defined __COSMOS_NO_USER_DRIVE__) || (defined __UNIFIED_MESSAGE_ARCHIVE_SUPPORT__) || (defined __MMI_SMS_TCARD_STORAGE_SUPPORT__))
            m_toolbar->addItem(VAPP_MSG_DIALOG_PAGE_TOOLBAR_COPY, STR_ID_VAPP_MSG_COPY_TO, VCP_IMG_TOOL_BAR_COMMON_ITEM_COPY);
            if ((0 == srv_sim_ctrl_get_num_of_inserted()) && 
                (MMI_FALSE == srv_fmgr_drv_is_accessible(srv_fmgr_drv_get_letter_by_type(SRV_FMGR_DRV_CARD_TYPE))))
            {
                m_toolbar->setDisableItem(VAPP_MSG_DIALOG_PAGE_TOOLBAR_COPY, VFX_TRUE);
            }
        #else
            m_toolbar->addItem(VAPP_MSG_DIALOG_PAGE_TOOLBAR_COPY, STR_ID_VAPP_MSG_COPY_SMS_TO_SIM, IMG_ID_VAPP_MSG_TB_SIM_MSG);
            if (0 == srv_sim_ctrl_get_num_of_inserted())
            {
                m_toolbar->setDisableItem(VAPP_MSG_DIALOG_PAGE_TOOLBAR_COPY, VFX_TRUE);
            }
        #endif
            m_toolbar->addItem(VAPP_MSG_DIALOG_PAGE_TOOLBAR_INSERT, VCP_STR_TOOL_BAR_INSERT, VCP_IMG_TOOL_BAR_COMMON_ITEM_INSERT);
        }
        else
        {
            m_toolbar->addItem(VAPP_MSG_DIALOG_PAGE_TOOLBAR_RESEND_FAIL, STR_ID_VAPP_MSG_RESEND_FAIL, VCP_IMG_TOOL_BAR_COMMON_ITEM_SEND);
            m_toolbar->addItem(VAPP_MSG_DIALOG_PAGE_TOOLBAR_DELETE, VCP_STR_TOOL_BAR_DELETE, VCP_IMG_TOOL_BAR_COMMON_ITEM_DELETE);
            /* check box */
            if (SRV_UM_MSG_SMS == m_msgType)
            {
                srv_sms_box_enum box = SRV_SMS_BOX_NONE;
                srv_sms_get_msg_list_index(&box, (U16)m_msgId);
                if (SRV_SMS_BOX_UNSENT != box)
                {
                    m_toolbar->setDisableItem(VAPP_MSG_DIALOG_PAGE_TOOLBAR_RESEND_FAIL, VFX_TRUE);
                }
                else
                {
                    // it exists on outbox and check sending status
                    srv_sms_send_status_enum status = SRV_SMS_SEND_INVALID;
                    status = srv_sms_get_unsent_msg_status(m_msgId);
                    if (SRV_SMS_SEND_SENDING == status || 
                        SRV_SMS_SEND_WAITING == status)
                    {
                        m_toolbar->setDisableItem(VAPP_MSG_DIALOG_PAGE_TOOLBAR_RESEND_FAIL, VFX_TRUE);
                        m_toolbar->setDisableItem(VAPP_MSG_DIALOG_PAGE_TOOLBAR_DELETE, VFX_TRUE);
                    }
                }
            }
        #ifdef __MMI_MMS_IN_UM__
            else if (SRV_UM_MSG_MMS == m_msgType)
            {
                mma_folder_enum box = MMA_FOLDER_NONE;
                box = mma_get_box(m_msgId);
                if (MMA_FOLDER_OUTBOX != box)
                {
                    m_toolbar->setDisableItem(VAPP_MSG_DIALOG_PAGE_TOOLBAR_RESEND_FAIL, VFX_TRUE);
                }
                else
                {
                    // it exists on outbox and check sending status
                    srv_mms_msg_status_enum status = SRV_MMS_MSG_STATUS_NONE;
                    status = srv_mms_get_msg_status(m_msgId);
                    if (SRV_MMS_MSG_STATUS_SENDING == status)
                    {
                        m_toolbar->setDisableItem(VAPP_MSG_DIALOG_PAGE_TOOLBAR_RESEND_FAIL, VFX_TRUE);
                        m_toolbar->setDisableItem(VAPP_MSG_DIALOG_PAGE_TOOLBAR_DELETE, VFX_TRUE);
                    }
                }
            }
        #endif /* __MMI_MMS_IN_UM__ */
            else
            {
                m_toolbar->setDisableItem(VAPP_MSG_DIALOG_PAGE_TOOLBAR_RESEND_FAIL, VFX_TRUE);
            }
        }
    }
    else
    {
        if (VFX_FALSE == m_list->getIsAllMarked(VFX_TRUE, m_msgCopyFilter.msg_type, getTransMsMsgListCopyType()))
        {
            m_toolbar->addItem(VAPP_MSG_DIALOG_PAGE_TOOLBAR_MS_SELECT_ALL, VCP_STR_TOOL_BAR_SELECT_ALL, VCP_IMG_TOOL_BAR_COMMON_ITEM_SELECT_ALL);
        }
        else
        {
            m_toolbar->addItem(VAPP_MSG_DIALOG_PAGE_TOOLBAR_MS_SELECT_ALL, VCP_STR_TOOL_BAR_UNSELECT_ALL, VCP_IMG_TOOL_BAR_COMMON_ITEM_UNSELECT_ALL);
        }
        if (SRV_UM_MARK_SEVERAL_OP_ACTION_DELETE == m_msAction)
        {
            m_toolbar->addItem(VAPP_MSG_DIALOG_PAGE_TOOLBAR_MS_DELETE, VCP_STR_TOOL_BAR_DELETE, VCP_IMG_TOOL_BAR_COMMON_ITEM_DELETE);
            m_toolbar->setDisableItem(VAPP_MSG_DIALOG_PAGE_TOOLBAR_MS_DELETE, VFX_TRUE);
        }
        else
        {
            m_toolbar->addItem(VAPP_MSG_DIALOG_PAGE_TOOLBAR_MS_COPY, VCP_STR_TOOL_BAR_COPY, VCP_IMG_TOOL_BAR_COMMON_ITEM_COPY);
            m_toolbar->setDisableItem(VAPP_MSG_DIALOG_PAGE_TOOLBAR_MS_COPY, VFX_TRUE);
        }
        m_toolbar->addItem(VAPP_MSG_DIALOG_PAGE_TOOLBAR_MS_CANCEL, VCP_STR_TOOL_BAR_CANCEL, VCP_IMG_TOOL_BAR_COMMON_ITEM_CANCEL);
    }
}

void VappMsgDialogPage::msActionClicked(srv_um_mark_several_op_action_enum action)
{
    switch (action)
    {
        case SRV_UM_MARK_SEVERAL_OP_ACTION_DELETE:
            m_list->deleteMarked();
            m_listMenu->reset();
            break;
#ifdef __UNIFIED_MESSAGE_ARCHIVE_SUPPORT__ 
        case SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_ARCHIVE:
#endif /* __UNIFIED_MESSAGE_ARCHIVE_SUPPORT__  */            
        case SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_SIM1:
    #if (MMI_MAX_SIM_NUM >= 2)
        case SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_SIM2:
    #endif /* MMI_MAX_SIM_NUM >= 2 */
    #if (MMI_MAX_SIM_NUM >= 3)
        case SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_SIM3:
    #endif /* MMI_MAX_SIM_NUM >= 3 */
    #if (MMI_MAX_SIM_NUM >= 4)
        case SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_SIM4:
    #endif /* MMI_MAX_SIM_NUM >= 4 */
        case SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_PHONE:
        case SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_MEMORY_CARD:
            m_list->copyMarked(getTransMsMsgListCopyType());
            break;

        default:
            VFX_ASSERT(0);
            break;
    }
}

void VappMsgDialogPage::createContextItem(
    VcpMenuPopup *cntx, 
    srv_um_msg_box_enum boxType, 
    srv_um_msg_enum msgType, 
    VfxU32 msgId, 
    VfxU32 index)
{
    switch (boxType)
    {
        case SRV_UM_MSG_BOX_INBOX:
            if ((SRV_UM_MSG_SMS | SRV_UM_MSG_MMS) & msgType)
            {
                if ((SRV_UM_MSG_SMS == msgType && 
                     SRV_SMS_STATUS_UNSUPPORTED != (SRV_SMS_STATUS_UNSUPPORTED & srv_sms_get_msg_status(msgId))) 
                #ifdef __MMI_MMS_IN_UM__
                    ||
                    (SRV_UM_MSG_MMS == msgType && 
                     (MMI_FALSE == srv_mms_is_java_mms(msgId) && 
                      MMI_FALSE == srv_mms_is_corrupted_mms(msgId) && 
                      MMI_FALSE == srv_mms_is_mms_notification(msgId) && 
                      MMI_FALSE == srv_mms_is_forward_lock(msgId)
                     )
                    )
                #endif /* __MMI_MMS_IN_UM__ */
                   )
                {
                    createContextSingleItem(cntx, VAPP_MSG_DIALOG_PAGE_LP_FORWARD, VFX_WSTR_RES(STR_GLOBAL_FORWARD), msgId, msgType, index);
                }
            }
            createContextSingleItem(cntx, VAPP_MSG_DIALOG_PAGE_LP_DELETE, VFX_WSTR_RES(STR_GLOBAL_DELETE), msgId, msgType, index);
            break;

        case SRV_UM_MSG_BOX_DRAFT:
            if ((SRV_UM_MSG_SMS == msgType && 
                 SRV_SMS_STATUS_UNSUPPORTED != (SRV_SMS_STATUS_UNSUPPORTED & srv_sms_get_msg_status(msgId))) 
            #ifdef __MMI_MMS_IN_UM__
                ||
                (SRV_UM_MSG_MMS == msgType && 
                 MMI_FALSE == srv_mms_is_corrupted_mms(msgId) && 
                 MMI_FALSE == srv_mms_is_forward_lock(msgId)
                )
            #endif /* __MMI_MMS_IN_UM__ */
               )
            {
                createContextSingleItem(cntx, VAPP_MSG_DIALOG_PAGE_LP_EDIT, VFX_WSTR_RES(STR_GLOBAL_EDIT), msgId, msgType, index);
            }
            createContextSingleItem(cntx, VAPP_MSG_DIALOG_PAGE_LP_DELETE, VFX_WSTR_RES(STR_GLOBAL_DELETE), msgId, msgType, index);
            break;

        case SRV_UM_MSG_BOX_UNSENT:
            if ((SRV_UM_MSG_SMS == msgType && 
                 SRV_SMS_STATUS_UNSUPPORTED != (SRV_SMS_STATUS_UNSUPPORTED & srv_sms_get_msg_status(msgId))) 
            #ifdef __MMI_MMS_IN_UM__
                ||
                (SRV_UM_MSG_MMS == msgType && 
                 MMI_FALSE == srv_mms_is_corrupted_mms(msgId) && 
                 MMI_FALSE == srv_mms_is_forward_lock(msgId)
                )
            #endif /* __MMI_MMS_IN_UM__ */
               )
            {
                createContextSingleItem(cntx, VAPP_MSG_DIALOG_PAGE_LP_EDIT, VFX_WSTR_RES(STR_GLOBAL_EDIT), msgId, msgType, index);
            }
            createContextSingleItem(cntx, VAPP_MSG_DIALOG_PAGE_LP_DELETE, VFX_WSTR_RES(STR_GLOBAL_DELETE), msgId, msgType, index);
            break;

        case SRV_UM_MSG_BOX_SENT:
            if ((SRV_UM_MSG_SMS == msgType && 
                 SRV_SMS_STATUS_UNSUPPORTED != (SRV_SMS_STATUS_UNSUPPORTED & srv_sms_get_msg_status(msgId))) 
            #ifdef __MMI_MMS_IN_UM__
                ||
                (SRV_UM_MSG_MMS == msgType && MMI_FALSE == srv_mms_is_corrupted_mms(msgId))
            #endif /* __MMI_MMS_IN_UM__ */
               )
            {
                createContextSingleItem(cntx, VAPP_MSG_DIALOG_PAGE_LP_FORWARD, VFX_WSTR_RES(STR_GLOBAL_FORWARD), msgId, msgType, index);
            }
            createContextSingleItem(cntx, VAPP_MSG_DIALOG_PAGE_LP_DELETE, VFX_WSTR_RES(STR_GLOBAL_DELETE), msgId, msgType, index);
            break;

        default:
            VFX_ASSERT(0);
            break;
    }
}

VappMsgCntxOptItemCp *VappMsgDialogPage::createContextSingleItem(
    VcpMenuPopup * parentCntx, 
    VfxId itemId, 
    VfxWString itemText, 
    VfxU32 msgId, 
    srv_um_msg_enum msgType, 
    VfxU32 index)
{
    if (VAPP_MSG_DIALOG_PAGE_LP_FORWARD == itemId && m_isNotification)
        return NULL;
    
    VappMsgCntxOptItemCp *item;

    VFX_OBJ_CREATE(item, VappMsgCntxOptItemCp, parentCntx);
    item->setId(itemId);
    item->setText(itemText);

    item->setMsgId(msgId);
    item->setMsgType(msgType);
    item->setIndex(index);

    parentCntx->insertItem(NULL, NULL, item);

    return item;
}

VappMsgContactEnum VappMsgDialogPage::transferCtbarType(srv_um_addr_enum addressType)
{
    VappMsgContactEnum contactType = VAPP_MSG_CONTACT_TYPE_NONE;

    switch (addressType)
    {
        case SRV_UM_ADDR_PHONE_NUMBER:
            contactType = VAPP_MSG_CONTACT_TYPE_PHONENUMBER;
            break;

        case SRV_UM_ADDR_EMAIL_ADDRESS:
            contactType = VAPP_MSG_CONTACT_TYPE_EMAIL;
            break;

        case SRV_UM_ADDR_IP_ADDRESS:
        case SRV_UM_ADDR_PLAIN_TEXT:
            contactType = VAPP_MSG_CONTACT_TYPE_ALPHANUMBIC;
            break;

        default:
            break;
    }

    return contactType;
}

#ifdef __MMI_UNIFIED_COMPOSER__ 
srv_uc_info_type_enum VappMsgDialogPage::transferUcType(srv_um_msg_enum msgType)
{
    srv_uc_info_type_enum ucType = SRV_UC_INFO_TYPE_SMS;

    switch (msgType)
    {
        case SRV_UM_MSG_SMS:
            ucType = SRV_UC_INFO_TYPE_SMS;
            break;

        case SRV_UM_MSG_MMS:
            ucType = SRV_UC_INFO_TYPE_MMS;
            break;

        default:
            VFX_ASSERT(0);
            break;
    }

    return ucType;
}
#endif

srv_um_msg_enum VappMsgDialogPage::getMsMarkAllMsgType()
{
    if (VAPP_MSG_DIALOG_PAGE_MODE_NORMAL == m_mode)
    {
        return SRV_UM_MSG_ALL;
    }
    
    srv_um_msg_enum msgType = SRV_UM_MSG_ALL;
    switch (m_msAction)
    {
#ifdef __UNIFIED_MESSAGE_ARCHIVE_SUPPORT__     
        case SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_ARCHIVE:
            msgType = (srv_um_msg_enum) (SRV_UM_MSG_SMS | SRV_UM_MSG_MMS);
            break;
#endif /* __UNIFIED_MESSAGE_ARCHIVE_SUPPORT__  */

        case SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_SIM1:
    #if (MMI_MAX_SIM_NUM >= 2)
        case SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_SIM2:
    #endif /* MMI_MAX_SIM_NUM >= 2 */
    #if (MMI_MAX_SIM_NUM >= 3)
        case SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_SIM3:
    #endif /* MMI_MAX_SIM_NUM >= 3 */
    #if (MMI_MAX_SIM_NUM >= 4)
        case SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_SIM4:
    #endif /* MMI_MAX_SIM_NUM >= 4 */
            msgType = SRV_UM_MSG_SMS;
            break;

        case SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_PHONE:
        case SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_MEMORY_CARD:            
            msgType = SRV_UM_MSG_MMS;
            break;

        default:
            break;
    }
    
    return msgType;
}

VappMessageListCopyStorageEnum VappMsgDialogPage::getTransMsMsgListCopyType()
{
    if (VAPP_MSG_DIALOG_PAGE_MODE_NORMAL == m_mode)
    {
        return VAPP_MESSAGE_LIST_COPY_STORAGE_NONE;
    }

    VappMessageListCopyStorageEnum copy = VAPP_MESSAGE_LIST_COPY_STORAGE_NONE;
    switch (m_msAction)
    {
#ifdef __UNIFIED_MESSAGE_ARCHIVE_SUPPORT__     
        case SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_ARCHIVE:
            copy = VAPP_MESSAGE_LIST_COPY_STORAGE_ARCHIVE;
            break;
#endif /* __UNIFIED_MESSAGE_ARCHIVE_SUPPORT__  */

        case SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_SIM1:
            copy = VAPP_MESSAGE_LIST_COPY_STORAGE_SIM1;
            break;

    #if (MMI_MAX_SIM_NUM >= 2)
        case SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_SIM2:
            copy = VAPP_MESSAGE_LIST_COPY_STORAGE_SIM2;
            break;
    #endif /* MMI_MAX_SIM_NUM >= 2 */

    #if (MMI_MAX_SIM_NUM >= 3)
        case SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_SIM3:
            copy = VAPP_MESSAGE_LIST_COPY_STORAGE_SIM3;
            break;
    #endif /* MMI_MAX_SIM_NUM >= 3 */

    #if (MMI_MAX_SIM_NUM >= 4)
        case SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_SIM4:
            copy = VAPP_MESSAGE_LIST_COPY_STORAGE_SIM4;
            break;
    #endif /* MMI_MAX_SIM_NUM >= 4 */

        case SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_PHONE:
            copy = VAPP_MESSAGE_LIST_COPY_STORAGE_PHONE;
            break;

        case SRV_UM_MARK_SEVERAL_OP_ACTION_COPY_TO_MEMORY_CARD:
            copy = VAPP_MESSAGE_LIST_COPY_STORAGE_MEMORY_CARD;
            break;

        default:
            break;
    }

    return copy;
}

void VappMsgDialogPage::setContactBar()
{
    if (VFX_FALSE == m_isMultiAddr)
    {

        VappMsgContactEnum contactType = VAPP_MSG_CONTACT_TYPE_NONE;
        contactType = transferCtbarType(m_addressType);
        m_contactBar->setContact(m_address, contactType);
    }
    else
    {
        VappMsgContactProvider *msgProvider = NULL;
        if (SRV_UM_MSG_SMS == m_msgType)
        {
            VappSmsContactProvider *smsProvider;
            VFX_OBJ_CREATE(smsProvider, VappSmsContactProvider, this);
            smsProvider->setMsgID(m_msgId);
            msgProvider = smsProvider;
        }
    #ifdef __MMI_MMS_IN_UM__
        else if (SRV_UM_MSG_MMS == m_msgType)
        {
            VappMmsContactProvider *mmsProvider;
            VFX_OBJ_CREATE(mmsProvider, VappMmsContactProvider, this);
            mmsProvider->setMsgID(m_msgId);
            msgProvider = mmsProvider;
        }
    #endif /* __MMI_MMS_IN_UM__ */

        m_contactBar->setContact(msgProvider);
    }
    /* set the right icon for multiple sim project */
#if (MMI_MAX_SIM_NUM >= 2)
    if (SRV_UM_SIM_GSM_SIM1 == m_addressSimId)
    {
        m_contactBar->setRightIcon(VfxImageSrc(IMG_COSMOS_SIM1));
    }
    else if (SRV_UM_SIM_GSM_SIM2 == m_addressSimId)
    {
        m_contactBar->setRightIcon(VfxImageSrc(IMG_COSMOS_SIM2));
    }
#if (MMI_MAX_SIM_NUM >= 3)
    else if (SRV_UM_SIM_GSM_SIM3 == m_addressSimId)
    {
        m_contactBar->setRightIcon(VfxImageSrc(IMG_COSMOS_SIM3));
    }
#endif /* MMI_MAX_SIM_NUM >= 3 */
#if (MMI_MAX_SIM_NUM >= 4)
    else if (SRV_UM_SIM_GSM_SIM4 == m_addressSimId)
    {
        m_contactBar->setRightIcon(VfxImageSrc(IMG_COSMOS_SIM4));
    }
#endif /* MMI_MAX_SIM_NUM >= 4 */
#endif /* MMI_MAX_SIM_NUM >= 2 */
}

VfxBool VappMsgDialogPage::getAllMsgRead()
{
    setAllMsgRead();

    if (VFX_TRUE == m_isWaitSetAllRead)
    {
        return VFX_FALSE;
    }
    else
    {
        return VFX_TRUE;
    }
}

void VappMsgDialogPage::setAllMsgRead()
{
    if (VFX_FALSE == m_list->checkMsgList() ||
        VFX_FALSE == m_isWaitSetAllRead ||
        VFX_TRUE == m_isStartSetAllMsgRead)
    {
        return;
    }

    m_isStartSetAllMsgRead = VFX_TRUE;
    m_setAllReadIndex = 0;
    setAllMsgReadInt();
}

void VappMsgDialogPage::setAllMsgReadInt()
{
    if (VFX_FALSE == m_list->checkMsgList())
    {
        /* list disappear, return */
        m_isStartSetAllMsgRead = VFX_FALSE;
        m_setAllReadIndex = 0;
        m_isWaitSetAllRead = VFX_TRUE;
        return;
    }

    VfxU32 i = m_setAllReadIndex;
    for (i = m_setAllReadIndex ; i < (VfxU32)m_list->getCount() ; i++)
    {
        if (VFX_TRUE == setMsgRead(m_list->getMsgId(i), m_list->getMsgType(i)))
        {
            break;
        }
    }

    /* set the last handling index */
    m_setAllReadIndex = i;
    /* complete, set non-wait */
    if (m_setAllReadIndex >= (VfxU32)m_list->getCount())
    {
        m_isWaitSetAllRead = VFX_FALSE;
        m_setAllReadIndex = 0;
        m_isStartSetAllMsgRead = VFX_FALSE;
        checkUpdate();
    }
}

VfxBool VappMsgDialogPage::setMsgRead(VfxU32 msgId, srv_um_msg_enum msgType)
{
    VfxBool isWaitCb = VFX_FALSE;
    switch (msgType)
    {
        case SRV_UM_MSG_SMS:
            if (SRV_SMS_STATUS_UNREAD & srv_sms_get_msg_status(msgId))
            {
                /* unread, set as read */
                srv_sms_change_msg_status(
                    msgId, 
                    SRV_SMS_STATUS_READ, 
                    &VappMsgDialogPage::setSmsReadCb, 
                    (void *)getObjHandle());
                isWaitCb = VFX_TRUE;
            }
            break;

    #ifdef __MMI_MMS_IN_UM__
        case SRV_UM_MSG_MMS:
            if (MMI_FALSE == srv_mms_mma_get_mms_read_status(msgId))
            {
                /* unrad, set as read */
                U8 result = MMA_RESULT_OK;
                srv_mms_send_read_report_after_validation(msgId, MMI_TRUE);
                srv_mms_set_read_status_and_refresh_list(msgId, MMI_TRUE, &result);
            }
            break;
    #endif /* __MMI_MMS_IN_UM__ */

    #ifdef __MMI_PUSH_IN_UM__
        case SRV_UM_MSG_WAP_PUSH:
            if (MMI_FALSE == srv_wap_push_msg_read_status(msgId))
            {
                /* unrad, set as read */
				srv_wap_push_update_all_service_msg_req(&VappMsgDialogPage::setPushReadCb, (void *)getObjHandle());
                isWaitCb = VFX_TRUE;
            }
            break;
    #endif /* __MMI_PUSH_IN_UM__ */

    #ifdef __MMI_PROV_IN_UM__
        case SRV_UM_MSG_PROV:
            if (SRV_PROVBOX_MSG_READ_STATUS_UNREAD == srv_provbox_get_msg_status(msgId))
            {
                /* unrad, set as read */
                srv_provbox_main_um_set_msg_state(
                        msgId, 
                        SRV_PROVBOX_MSG_READ_STATUS_READ, 
                        &VappMsgDialogPage::setProvReadCb, 
                        (void *)getObjHandle());
                isWaitCb = VFX_TRUE;
            }
            break;
    #endif /* __MMI_PROV_IN_UM__ */

        default:
            break;
    }

    return isWaitCb;
}

void VappMsgDialogPage::setSmsReadCb(srv_sms_callback_struct * cbPara)
{
    VappMsgDialogPage *self = (VappMsgDialogPage *)VfxObject::handleToObject((VfxObjHandle)cbPara->user_data);

    if (self)
    {
        if (self->isKindOf(VFX_OBJ_CLASS_INFO(VappMsgDialogPage)))
        {
            if (VFX_TRUE == self->m_isWaitSetAllRead)
            {
                /* success, increase one */
                /********************************************************
                 * if fails, it means there are some sms disappearing.
                 * while some message disappear, sms app will send a refresh
                 * indication to UM service. 
                 * but message app use the post event to check the if all 
                 * read, it will cause that the refresh indication primitive 
                 * could not be handled and cause the infinitely loop.
                 * The solution is that messagea app assumes that if set
                 * sms read fail must have a refrehs ind event coming later.
                 * hence, just ignore the read result fail.
                 * it just a wrok around solution, sms srv and um srv 
                 * must resolve the refrehs indication issue in the 
                 * future.
                 ********************************************************/
                //if (MMI_TRUE == cbPara->result)
                {
                    self->m_setAllReadIndex++;
                }
                vfxPostInvoke0(self, &VappMsgDialogPage::setAllMsgReadInt);
            }
        }
    }
}

#ifdef __MMI_PUSH_IN_UM__
void VappMsgDialogPage::setPushReadCb(srv_wap_push_msg_read_status_enum result,void * user_data)
{   
    VappMsgDialogPage *self = (VappMsgDialogPage *)VfxObject::handleToObject((VfxObjHandle)user_data);

    if (self)
    {
        if (self->isKindOf(VFX_OBJ_CLASS_INFO(VappMsgDialogPage)))
        {
            if (VFX_TRUE == self->m_isWaitSetAllRead)
            {
                /* success, increase one */
                if (SRV_WAP_PUSH_STATUS_FAIL != result)
                {
                    self->m_setAllReadIndex++;
                }
                vfxPostInvoke0(self, &VappMsgDialogPage::setAllMsgReadInt);
            }
        }
    }
}
#endif /* __MMI_PUSH_IN_UM__ */

#ifdef __MMI_PROV_IN_UM__
void VappMsgDialogPage::setProvReadCb(srv_provbox_result_enum result, void *cbPara)
{
    VappMsgDialogPage *self = (VappMsgDialogPage *)VfxObject::handleToObject((VfxObjHandle)cbPara);

    if (self)
    {
        if (self->isKindOf(VFX_OBJ_CLASS_INFO(VappMsgDialogPage)))
        {
            if (VFX_TRUE == self->m_isWaitSetAllRead)
            {
                /* success, increase one */
                if (MMI_TRUE == result)
                {
                    self->m_setAllReadIndex++;
                }
                vfxPostInvoke0(self, &VappMsgDialogPage::setAllMsgReadInt);
            }
        }
    }
}
#endif /* __MMI_PROV_IN_UM__ */

void *VappMsgDialogPage::allocMem(VfxU32 size,void * userData)
{
    VappMsgDialogPage *self = (VappMsgDialogPage *)VfxObject::handleToObject((VfxObjHandle)userData);
    void *mem = NULL;

    if (self)
    {
        if (self->isKindOf(VFX_OBJ_CLASS_INFO(VappMsgDialogPage)))
        {
            VFX_ALLOC_MEM(mem, size, self);
        }
    }

    return mem;
}

void VappMsgDialogPage::freeMem(void * ptr)
{
    VFX_FREE_MEM(ptr);
}

void VappMsgDialogPage::saveRemainderTextToDraft()
{
    if (NULL != m_editor)
    {
        /* after leaving the page, it should check if editor has content */
        VfxWChar *text = NULL;
        text = m_editor->getText();
        if (NULL != text &&
            0 < vfx_sys_wcslen(text))
        {
            /* store sms in the draft */
            SMS_HANDLE smsHdlr;
            smsHdlr = srv_sms_get_save_handle();
            srv_sms_set_content(smsHdlr, (CHAR *)text, (U16)(vfx_sys_wcslen(text) * ENCODING_LENGTH));
            srv_sms_set_address(smsHdlr, (CHAR *)m_address.getBuf());
            switch (m_addressSimId)
            {
                case SRV_UM_SIM_GSM_SIM1:
                    srv_sms_set_sim_id(smsHdlr,SRV_SMS_SIM_1);
                    break;

            #if (MMI_MAX_SIM_NUM >= 2)
                case SRV_UM_SIM_GSM_SIM2:
                    srv_sms_set_sim_id(smsHdlr,SRV_SMS_SIM_2);
                    break;
            #endif /* MMI_MAX_SIM_NUM >= 2 */

            #if (MMI_MAX_SIM_NUM >= 3)
                case SRV_UM_SIM_GSM_SIM3:
                    srv_sms_set_sim_id(smsHdlr,SRV_SMS_SIM_3);
                    break;
            #endif /* MMI_MAX_SIM_NUM >= 3 */

            #if (MMI_MAX_SIM_NUM >= 4)
                case SRV_UM_SIM_GSM_SIM4:
                    srv_sms_set_sim_id(smsHdlr,SRV_SMS_SIM_4);
                    break;
            #endif /* MMI_MAX_SIM_NUM >= 4 */

                default:
                    srv_sms_set_sim_id(smsHdlr,SRV_SMS_SIM_1);
                    break;
            }
            srv_sms_save_msg(smsHdlr, NULL, NULL);

            m_editor->setText(VFX_WSTR_EMPTY,m_editorMaxLength);
            m_editor->deactivate();
        }
    }
}

void VappMsgDialogPage::updateMsToolbar()
{
    /* if no all marked, it will change as selected all */
    if (VAPP_MSG_DIALOG_PAGE_MODE_MARK_SEVERAL == m_mode && NULL != m_toolbar)
    {
        if (m_list->getIsAllMarked(VFX_FALSE))
        {
            m_toolbar->setDisableItem(VAPP_MSG_DIALOG_PAGE_TOOLBAR_MS_DELETE, VFX_TRUE);
            m_toolbar->setDisableItem(VAPP_MSG_DIALOG_PAGE_TOOLBAR_MS_COPY, VFX_TRUE);
        }
        else
        {
            m_toolbar->setDisableItem(VAPP_MSG_DIALOG_PAGE_TOOLBAR_MS_DELETE, VFX_FALSE);
            m_toolbar->setDisableItem(VAPP_MSG_DIALOG_PAGE_TOOLBAR_MS_COPY, VFX_FALSE);
        }

        /* if it hasn't get the list inside,there is no need to change txt on this button */
        if (TRUE == m_list->isMsgList())
        {
            if (VFX_TRUE == m_list->getIsAllMarked(VFX_TRUE, m_msgCopyFilter.msg_type, getTransMsMsgListCopyType()))
            {
                m_toolbar->changeItem(VAPP_MSG_DIALOG_PAGE_TOOLBAR_MS_SELECT_ALL, VCP_STR_TOOL_BAR_UNSELECT_ALL, VCP_IMG_TOOL_BAR_COMMON_ITEM_UNSELECT_ALL);
            }
            else
            {
                m_toolbar->changeItem(VAPP_MSG_DIALOG_PAGE_TOOLBAR_MS_SELECT_ALL, VCP_STR_TOOL_BAR_SELECT_ALL, VCP_IMG_TOOL_BAR_COMMON_ITEM_SELECT_ALL);
            }
        }
    }
}

void VappMsgDialogPage::sendSms(mmi_sim_enum simCard)
{
    srv_sms_sim_enum smsSimCard = SRV_SMS_SIM_1;

    smsSimCard = SRV_SMS_MMI_SIM_TO_SMS(simCard);

    SMS_HANDLE smsHdlr;
    smsHdlr = srv_sms_get_send_handle();
    VfxWChar *text;
    text = m_editor->getText();
    srv_sms_set_content(smsHdlr,(CHAR *)text, (U16)(vfx_sys_wcslen(text) * ENCODING_LENGTH));
    srv_sms_set_address(smsHdlr, (CHAR *)m_address.getBuf());
    srv_sms_set_sim_id(smsHdlr, smsSimCard);
    srv_sms_set_send_type(smsHdlr, SRV_SMS_BG_SAVE_SEND);
    srv_sms_send_msg(smsHdlr, &VappMsgDialogPage::smsSendCb, (void *)getObjHandle());
    /* reset the editor */
    m_editor->setText(VFX_WSTR_EMPTY, m_editorMaxLength);
    m_editor->deactivate();

    srv_phb_set_preferred_sim((U16 *)m_address.getBuf(), MMI_PHB_INVALID_CONTACT_ID, simCard, SRV_PHB_NUMBER_OP_TYPE_MESSAGE);
}

VfxBool VappMsgDialogPage::checkMsgSimVsInsertSim(srv_um_sim_enum msgSim, mmi_sim_enum * tsfrSim)
{
    VfxBool isAvailable = VFX_TRUE;

    switch (msgSim)
    {
        case SRV_UM_SIM_GSM_SIM1:
            *tsfrSim = MMI_SIM1;
            break;

    #if (MMI_MAX_SIM_NUM >= 2)
        case SRV_UM_SIM_GSM_SIM2:
            *tsfrSim = MMI_SIM2;
            break;
    #endif /* MMI_MAX_SIM_NUM >= 2 */

    #if (MMI_MAX_SIM_NUM >= 3)
        case SRV_UM_SIM_GSM_SIM3:
            *tsfrSim = MMI_SIM3;
            break;
    #endif /* MMI_MAX_SIM_NUM >= 3 */

    #if (MMI_MAX_SIM_NUM >= 4)
        case SRV_UM_SIM_GSM_SIM4:
            *tsfrSim = MMI_SIM4;
            break;
    #endif /* MMI_MAX_SIM_NUM >= 4 */

        default:
            *tsfrSim = MMI_SIM1;
            break;
    }

    if (MMI_FALSE == srv_sim_ctrl_is_inserted(*tsfrSim) ||
        SRV_MODE_SWITCH_OFF == srv_mode_switch_get_network_mode(*tsfrSim))
    {
        isAvailable = VFX_FALSE;
    }

    return isAvailable;
}

VfxU16 VappMsgDialogPage::tsfrSimCard2StrId(srv_um_sim_enum msgSim)
{
    U16 simStrId = STR_GLOBAL_SIM;

    switch (msgSim)
    {
        case SRV_UM_SIM_GSM_SIM1:
            simStrId = STR_GLOBAL_SIM_1;
            break;

    #if (MMI_MAX_SIM_NUM >= 2)
        case SRV_UM_SIM_GSM_SIM2:
            simStrId = STR_GLOBAL_SIM_2;
            break;
    #endif /* MMI_MAX_SIM_NUM >= 2 */

    #if (MMI_MAX_SIM_NUM >= 3)
        case SRV_UM_SIM_GSM_SIM3:
            simStrId = STR_GLOBAL_SIM_3;
            break;
    #endif /* MMI_MAX_SIM_NUM >= 3 */

    #if (MMI_MAX_SIM_NUM >= 4)
        case SRV_UM_SIM_GSM_SIM4:
            simStrId = STR_GLOBAL_SIM_4;
            break;
    #endif /* MMI_MAX_SIM_NUM >= 4 */

        default:
            break;
    }

    return simStrId;
}

void VappMsgDialogPage::toolbarSend()
{
    if (MMI_FALSE == srv_mode_switch_is_network_service_available())
    {
        mmi_frm_nmgr_balloon(MMI_SCENARIO_ID_DEFAULT, MMI_EVENT_INFO_BALLOON, MMI_NMGR_BALLOON_TYPE_INFO, VFX_WSTR_RES(STR_GLOBAL_UNAVAILABLE_IN_FLIGHT_MODE));
    }
    else
    {
        mmi_sim_enum sim = MMI_SIM1;
    #if (MMI_MAX_SIM_NUM >= 2)
        if (VFX_FALSE == checkMsgSimVsInsertSim(m_addressSimId, &sim))
        {
            VcpQuestionPopup *confirm;
            VFX_OBJ_CREATE(confirm, VcpQuestionPopup, this);
            VfxWString description, prifix;
            
            description.loadFromRes(tsfrSimCard2StrId(m_addressSimId));
            prifix.loadFromRes(STR_ID_VAPP_MSG_SIM_CARD_UNAVAILABLE_TRANSFER_TO);
            description += prifix;
            confirm->setText(description);
            /* check if need to display */
            U16 index = 0;
            mmi_sim_enum simDisplay = MMI_SIM1;
            for (index = 0 ; index < MMI_MAX_SIM_NUM ; index++, simDisplay = (mmi_sim_enum)(simDisplay << 1))
            {
                /* hide the current sim card */
                if (MMI_TRUE == srv_sim_ctrl_is_inserted(simDisplay) && 
                    sim != simDisplay)
                {
                    confirm->addItem(simDisplay, vapp_sim_settings_get_sim_name_with_sim_id(simDisplay), VCP_POPUP_BUTTON_TYPE_NORMAL);
                    /* check if neeed to disable */
                    if (SRV_MODE_SWITCH_OFF == srv_mode_switch_get_network_mode(simDisplay))
                    {
                        confirm->disableItem(simDisplay);
                    }
                }
            }
            confirm->addItem(MMI_SIM_END_OF_ENUM, STR_GLOBAL_CANCEL, VCP_POPUP_BUTTON_TYPE_CANCEL);
            confirm->m_signalButtonClicked.connect(this, &VappMsgDialogPage::onSendConfirmClicked);
            confirm->show(VFX_TRUE);
        }
        else
    #endif /* MMI_MAX_SIM_NUM */
        {
            sendSms(sim);
        }
    }
}

void VappMsgDialogPage::toolbarCall()
{
    mmi_id cuiId;

    cuiId = vcui_dialer_create(getApp()->getGroupId());
    vcui_dialer_set_dial_string(cuiId, m_address);
    vcui_dialer_run(cuiId);
}

void VappMsgDialogPage::toolbarResendFail()
{
    if (MMI_FALSE == srv_mode_switch_is_network_service_available())
    {
        mmi_frm_nmgr_balloon(MMI_SCENARIO_ID_DEFAULT, MMI_EVENT_INFO_BALLOON, MMI_NMGR_BALLOON_TYPE_INFO, VFX_WSTR_RES(STR_GLOBAL_UNAVAILABLE_IN_FLIGHT_MODE));
    }
    else
    {
        VFX_ASSERT(VFX_TRUE == m_isMultiAddr);
        if (SRV_UM_MSG_SMS == m_msgType)
        {
            vapp_sms_resend_msg(m_msgId);
        }
    #ifdef __MMI_MMS_IN_UM__
        else if (SRV_UM_MSG_MMS == m_msgType)
        {
            srv_mms_mma_get_msg_info_struct *msgInfo;
            VFX_ALLOC_MEM(msgInfo, sizeof(srv_mms_mma_get_msg_info_struct), this);
            vfx_sys_mem_zero(msgInfo, sizeof(srv_mms_mma_get_msg_info_struct));
            if (SRV_MMS_RESULT_OK == srv_mms_mma_get_sync_msg_info_user_data_input(
                                        m_msgId, 
                                        msgInfo, 
                                        &VappMsgDialogPage::allocMem, 
                                        &VappMsgDialogPage::freeMem, 
                                        (void *)getObjHandle()))
            {
                srv_mms_send_req_struct req;
                vfx_sys_mem_zero(&req, sizeof(srv_mms_send_req_struct));
                req.sim_id = msgInfo->sim_id;
                req.send_setting = SRV_MMS_SETTING_SAVE_AND_SEND;
                req.msg_id = m_msgId;
                req.is_rr = MMI_FALSE;
                req.storage_type = msgInfo->storage_type;
                vapp_mms_send_msg(&req, &VappMsgDialogPage::allocMem, &VappMsgDialogPage::freeMem, (void *)getObjHandle());
            }
            
            VFX_FREE_MEM(msgInfo);
        }
    #endif /* __MMI_MMS_IN_UM__ */
    }
}

void VappMsgDialogPage::toolbarDelete()
{
    m_isNewMode = VFX_TRUE;
    m_mode = VAPP_MSG_DIALOG_PAGE_MODE_MARK_SEVERAL;
    m_msAction = SRV_UM_MARK_SEVERAL_OP_ACTION_DELETE;
    m_msgCopyFilter.msg_type = SRV_UM_MSG_ALL;
    m_msgCopyFilter.msg_box = SRV_UM_MSG_BOX_ALL;
    m_msgCopyFilter.msg_storage = VAPP_MSG_STORAGE_ALL;
    checkUpdate();
}

void VappMsgDialogPage::toolbarCopy()
{
#if ((defined __MMI_MMS_IN_UM__ && !defined __COSMOS_NO_USER_DRIVE__) || (defined __UNIFIED_MESSAGE_ARCHIVE_SUPPORT__) || (defined __MMI_SMS_TCARD_STORAGE_SUPPORT__))
{
    VcpCommandPopup *copyCmd;
    VFX_OBJ_CREATE(copyCmd, VcpCommandPopup, this);
    copyCmd->setText(STR_GLOBAL_COPY);
    /* use service's enum to let as VfxId */

#ifdef __UNIFIED_MESSAGE_ARCHIVE_SUPPORT__     
    copyCmd->addItem(VAPP_MSG_DIALOG_PAGE_MS_ACTION_COPY_TO_ARCHIVE, STR_ID_VAPP_MSG_COPY_TO_ARCHIVE, VCP_POPUP_BUTTON_TYPE_NORMAL);
#ifdef __MMI_USB_SUPPORT__
    if (MMI_TRUE == srv_usb_is_in_mass_storage_mode())
    {
        copyCmd->disableItem(VAPP_MSG_DIALOG_PAGE_MS_ACTION_COPY_TO_ARCHIVE);
    }
#endif /* __MMI_USB_SUPPORT__ */
#endif /* __UNIFIED_MESSAGE_ARCHIVE_SUPPORT__  */

    if (0 == srv_sim_ctrl_get_num_of_inserted())
    {
        copyCmd->addItem(VAPP_MSG_DIALOG_PAGE_MS_ACTION_COPY_TO_SIM1, STR_ID_VAPP_MSG_COPY_SMS_TO_SIM, VCP_POPUP_BUTTON_TYPE_NORMAL);
        copyCmd->disableItem(VAPP_MSG_DIALOG_PAGE_MS_ACTION_COPY_TO_SIM1);
    }
    else if (1 == srv_sim_ctrl_get_num_of_inserted())
    {
        U16 index = 0;
        mmi_sim_enum sim = MMI_SIM1;
        U16 copySimId = VAPP_MSG_DIALOG_PAGE_MS_ACTION_COPY_TO_SIM1;
        for (index = 0 ; index < MMI_MAX_SIM_NUM ; index++, sim = (mmi_sim_enum)(sim << 1), copySimId++)
        {
            if (MMI_TRUE == srv_sim_ctrl_is_inserted(sim))
            {
                break;
            }
        }
        VfxWString string;
        copyCmd->addItem(copySimId, STR_ID_VAPP_MSG_COPY_SMS_TO_SIM, VCP_POPUP_BUTTON_TYPE_NORMAL);
    }
    else
    {
        copyCmd->addItem(VAPP_MSG_DIALOG_PAGE_MS_ACTION_COPY_TO_SIM_SELECT, STR_ID_VAPP_MSG_COPY_SMS_TO_SIM, VCP_POPUP_BUTTON_TYPE_NORMAL);
    }

#ifdef __MMI_SMS_TCARD_STORAGE_SUPPORT__
    copyCmd->addItem(VAPP_MSG_DIALOG_PAGE_MS_ACTION_COPY_SMS_TO_PHONE, STR_ID_VAPP_MSG_COPY_SMS_TO_PHONE, VCP_POPUP_BUTTON_TYPE_NORMAL);
    if ( MMI_FALSE == srv_fmgr_drv_is_accessible(srv_fmgr_drv_get_letter_by_type(SRV_FMGR_DRV_CARD_TYPE)))
    {
        copyCmd->disableItem(VAPP_MSG_DIALOG_PAGE_MS_ACTION_COPY_SMS_TO_PHONE);
    }
#ifdef __MMI_USB_SUPPORT__
    if (MMI_TRUE == srv_usb_is_in_mass_storage_mode())
    {
        copyCmd->disableItem(VAPP_MSG_DIALOG_PAGE_MS_ACTION_COPY_SMS_TO_PHONE);
    }
#endif /* __MMI_USB_SUPPORT__ */
    copyCmd->addItem(VAPP_MSG_DIALOG_PAGE_MS_ACTION_COPY_SMS_TO_MEM_CARD, STR_ID_VAPP_MSG_COPY_SMS_TO_MEMORY_CARD, VCP_POPUP_BUTTON_TYPE_NORMAL);
    if (MMI_FALSE == srv_fmgr_drv_is_accessible(srv_fmgr_drv_get_letter_by_type(SRV_FMGR_DRV_CARD_TYPE)))
    {
        copyCmd->disableItem(VAPP_MSG_DIALOG_PAGE_MS_ACTION_COPY_SMS_TO_MEM_CARD);
    }
#endif /* __MMI_SMS_TCARD_STORAGE_SUPPORT__ */

#ifndef __COSMOS_NO_USER_DRIVE__
    copyCmd->addItem(VAPP_MSG_DIALOG_PAGE_MS_ACTION_COPY_MMS_TO_PHONE, STR_ID_VAPP_MSG_COPY_MMS_TO_PHONE, VCP_POPUP_BUTTON_TYPE_NORMAL);

    /* Set copy to phone as disable if the memory card is not inserted. But if support multiple memory cards in the future, it should be revised again  */
    if ( MMI_FALSE == srv_fmgr_drv_is_accessible(srv_fmgr_drv_get_letter_by_type(SRV_FMGR_DRV_CARD_TYPE)))
    {
        copyCmd->disableItem(VAPP_MSG_DIALOG_PAGE_MS_ACTION_COPY_MMS_TO_PHONE);
    }
#ifdef __MMI_USB_SUPPORT__
    if (MMI_TRUE == srv_usb_is_in_mass_storage_mode())
    {
        copyCmd->disableItem(VAPP_MSG_DIALOG_PAGE_MS_ACTION_COPY_MMS_TO_PHONE);
    }
#endif /* __MMI_USB_SUPPORT__ */
    copyCmd->addItem(VAPP_MSG_DIALOG_PAGE_MS_ACTION_COPY_MMS_TO_MEM_CARD, STR_ID_VAPP_MSG_COPY_MMS_TO_MEMORY_CARD, VCP_POPUP_BUTTON_TYPE_NORMAL);
    /* check memroy card */
    if (MMI_FALSE == srv_fmgr_drv_is_accessible(srv_fmgr_drv_get_letter_by_type(SRV_FMGR_DRV_CARD_TYPE)))
    {
        copyCmd->disableItem(VAPP_MSG_DIALOG_PAGE_MS_ACTION_COPY_MMS_TO_MEM_CARD);
    }
#endif /* __COSMOS_NO_USER_DRIVE__ */

    copyCmd->addItem(VAPP_MSG_DIALOG_PAGE_MS_ACTION_COPY_TO_TOTAL, STR_GLOBAL_CANCEL, VCP_POPUP_BUTTON_TYPE_CANCEL);
    copyCmd->m_signalButtonClicked.connect(this, &VappMsgDialogPage::onCopyCmdClicked);
    copyCmd->show(VFX_TRUE);
}
#else
    if (1 == srv_sim_ctrl_get_num_of_inserted())
    {
        U16 index = 0;
        mmi_sim_enum sim = MMI_SIM1;
        U16 copySimId = VAPP_MSG_DIALOG_PAGE_MS_ACTION_COPY_TO_SIM1;
        for (index = 0 ; index < MMI_MAX_SIM_NUM ; index++, sim = (mmi_sim_enum)(sim << 1), copySimId++)
        {
            if (MMI_TRUE == srv_sim_ctrl_is_inserted(sim))
            {
                break;
            }
        }
        if (index == 0)
        {
            onCopyCmdClicked(NULL, VAPP_MSG_DIALOG_PAGE_MS_ACTION_COPY_TO_SIM1);
        }
    #if (MMI_MAX_SIM_NUM >= 2)
        else if(index == 1)
        {
            onCopyCmdClicked(NULL, VAPP_MSG_DIALOG_PAGE_MS_ACTION_COPY_TO_SIM2);
        }
    #endif
    #if (MMI_MAX_SIM_NUM >= 3)
        else if(index == 2)
        {
            onCopyCmdClicked(NULL, VAPP_MSG_DIALOG_PAGE_MS_ACTION_COPY_TO_SIM3);
        }
    #endif
    #if (MMI_MAX_SIM_NUM >= 4)
        else if(index == 3)
        {
            onCopyCmdClicked(NULL, VAPP_MSG_DIALOG_PAGE_MS_ACTION_COPY_TO_SIM4);
        }
    #endif
    }
    else
    {
        onCopyCmdClicked(NULL, VAPP_MSG_DIALOG_PAGE_MS_ACTION_COPY_TO_SIM_SELECT);
    }
#endif
}

void VappMsgDialogPage::toolbarInsert()
{
    /* use the function to do the same thing */
    onEditorFbClick(NULL, VAPP_MSG_DIALOG_PAGE_FB_INSERT);
}

void VappMsgDialogPage::toolbarMsSelectAll()
{
    if (VFX_TRUE == m_list->getIsAllMarked(VFX_TRUE, m_msgCopyFilter.msg_type, getTransMsMsgListCopyType()))
    {
        /* unmark all */
        m_list->setMarkAll(VFX_FALSE);
        m_listMenu->setMarkAll(VFX_FALSE);
        m_toolbar->changeItem(VAPP_MSG_DIALOG_PAGE_TOOLBAR_MS_SELECT_ALL, VCP_STR_TOOL_BAR_SELECT_ALL, VCP_IMG_TOOL_BAR_COMMON_ITEM_SELECT_ALL);
        m_toolbar->setDisableItem(VAPP_MSG_DIALOG_PAGE_TOOLBAR_MS_DELETE, VFX_TRUE);
        m_toolbar->setDisableItem(VAPP_MSG_DIALOG_PAGE_TOOLBAR_MS_COPY, VFX_TRUE);
    }
    else
    {
        /* mark all */
        m_list->setMarkAll(VFX_TRUE, m_msgCopyFilter.msg_type, getTransMsMsgListCopyType());
        m_listMenu->setMarkAll(VFX_TRUE);
        m_toolbar->changeItem(VAPP_MSG_DIALOG_PAGE_TOOLBAR_MS_SELECT_ALL, VCP_STR_TOOL_BAR_UNSELECT_ALL, VCP_IMG_TOOL_BAR_COMMON_ITEM_UNSELECT_ALL);
        /* check if enable/disable the action toolbar */
        if (m_list->getIsAllMarked(VFX_FALSE))
        {
            m_toolbar->setDisableItem(VAPP_MSG_DIALOG_PAGE_TOOLBAR_MS_DELETE, VFX_TRUE);
            m_toolbar->setDisableItem(VAPP_MSG_DIALOG_PAGE_TOOLBAR_MS_COPY, VFX_TRUE);
        }
        else
        {
            m_toolbar->setDisableItem(VAPP_MSG_DIALOG_PAGE_TOOLBAR_MS_DELETE, VFX_FALSE);
            m_toolbar->setDisableItem(VAPP_MSG_DIALOG_PAGE_TOOLBAR_MS_COPY, VFX_FALSE);
        }
    }
}

void VappMsgDialogPage::toolbarMsDelete()
{
    VcpConfirmPopup *deleteConfirm;
    VFX_OBJ_CREATE(deleteConfirm, VcpConfirmPopup, this);
    VfxWString text, prefix;
    text.loadFromRes(STR_ID_VAPP_MSG_MS_DELETE_SELECT_PREFIX);
    text += VfxWString().format("%d", m_list->getNumMarked());
    prefix.loadFromRes(STR_ID_VAPP_MSG_MS_DELETE_SELECT_POSTFIX);
    text += prefix;
    deleteConfirm->setText(text);
    deleteConfirm->setInfoType(VCP_POPUP_TYPE_WARNING);
    deleteConfirm->setButtonSet(VCP_CONFIRM_BUTTON_SET_YES_NO);
    deleteConfirm->setCustomButton(
                STR_GLOBAL_DELETE, 
                STR_GLOBAL_CANCEL, 
                VCP_POPUP_BUTTON_TYPE_WARNING, 
                VCP_POPUP_BUTTON_TYPE_CANCEL);
    deleteConfirm->m_signalButtonClicked.connect(this, &VappMsgDialogPage::onMsActionClicked);
    deleteConfirm->show(VFX_TRUE);
}

void VappMsgDialogPage::toolbarMsCopy()
{
    /* show processing */
    m_msProcessLoading->setText(STR_GLOBAL_COPYING);
    m_msProcessLoading->setInfoType(VCP_INDICATOR_POPUP_STYLE_PROGRESS_WITH_CANCEL_BUTTON);
    m_msProcessLoading->setProgress(0);
    m_msProcessLoading->show(VFX_TRUE);
    m_msProcessTimer->start();
    /* start to process */
    msActionClicked(m_msAction);
}

void VappMsgDialogPage::toolbarMsCancel()
{
    m_isNewMode = VFX_TRUE;
    m_mode = VAPP_MSG_DIALOG_PAGE_MODE_NORMAL;
    m_msAction = SRV_UM_MARK_SEVERAL_OP_ACTION_NONE;
    checkUpdate();
}

void VappMsgDialogPage::longpressDelete(VappMsgCntxOptItemCp *item)
{
    /* record the mark status */
    m_list->setMarkAll(VFX_FALSE);
    m_list->setMarkStatus(item->getIndex(), VFX_TRUE);
    /* show a confirm */
    VcpConfirmPopup *deleteConfirm;
    VFX_OBJ_CREATE(deleteConfirm, VcpConfirmPopup, this);
    deleteConfirm->setText(STR_ID_VAPP_MSG_ASK_DELETE_COFIRM);
    deleteConfirm->setInfoType(VCP_POPUP_TYPE_WARNING);
    deleteConfirm->setButtonSet(VCP_CONFIRM_BUTTON_SET_YES_NO);
    deleteConfirm->setCustomButton(
                STR_GLOBAL_DELETE, 
                STR_GLOBAL_CANCEL, 
                VCP_POPUP_BUTTON_TYPE_WARNING, 
                VCP_POPUP_BUTTON_TYPE_CANCEL);
    deleteConfirm->m_signalButtonClicked.connect(this, &VappMsgDialogPage::onLpActionClicked);
    deleteConfirm->show(VFX_TRUE);
}

void VappMsgDialogPage::longpressForward(VappMsgCntxOptItemCp *item)
{
#ifdef __MMI_UNIFIED_COMPOSER__
    VappUcEntryStruct *ucInfo;
    VFX_ALLOC_MEM(ucInfo, sizeof(VappUcEntryStruct), this);
    vfx_sys_mem_zero(ucInfo, sizeof(VappUcEntryStruct));

    VfxBool isNeedConfirm = VFX_FALSE;
    VfxU16 displayString = 0;
    ucInfo->info_type = transferUcType(item->getMsgType());
    ucInfo->msg_id = item->getMsgId();
    ucInfo->type = SRV_UC_STATE_FORWARD;
    ucInfo->operation = UC_OPERATION_FORWARD;
#ifdef __MMI_MMS_IN_UM__
    if (SRV_UM_MSG_MMS == item->getMsgType())
    {
        ucInfo->mode = MMA_MODE_FORWARD;
        isNeedConfirm = vapp_mms_is_need_show_edit_cnfm(item->getMsgId(), &displayString);
    }
#endif /* __MMI_MMS_IN_UM__ */
    if (VFX_TRUE == isNeedConfirm)
    {
        // record the data
        VFX_FREE_MEM(m_actionPtr);
        VFX_ALLOC_MEM(m_actionPtr, sizeof(VappUcEntryStruct), this);
        vfx_sys_mem_zero(m_actionPtr, sizeof(VappUcEntryStruct));
        vfx_sys_mem_copy(m_actionPtr, ucInfo, sizeof(VappUcEntryStruct));
        /* display restricted confirm */
        VcpConfirmPopup *confirm;
        VFX_OBJ_CREATE(confirm, VcpConfirmPopup, this);
        confirm->setText(displayString);
        confirm->setInfoType(VCP_POPUP_TYPE_WARNING);
        confirm->setButtonSet(VCP_CONFIRM_BUTTON_SET_YES_NO);
        confirm->setCustomButton(
                    STR_GLOBAL_CONTINUE, 
                    STR_GLOBAL_CANCEL, 
                    VCP_POPUP_BUTTON_TYPE_NORMAL, 
                    VCP_POPUP_BUTTON_TYPE_CANCEL);
        confirm->m_signalButtonClicked.connect(this, &VappMsgDialogPage::onRestrictConfirmClicked);
        confirm->show(VFX_TRUE);
    }
    else
    {
        mmi_id cuiId;
        cuiId = vcui_unifiedcomposer_create(getApp()->getGroupId(), ucInfo);
        if (cuiId != GRP_ID_INVALID)
        {
            vfxSetCuiCallerScr(cuiId, getMainScr());
            vcui_unifiedcomposer_run(cuiId);
        }
    }

    VFX_FREE_MEM(ucInfo);
#endif
#ifdef __MMI_SMS_COMPOSER__  
    mmi_id cuiId;          
    VcuiSmsComposerEntryStruct *entryData;
    VFX_ALLOC_MEM(entryData, sizeof(VcuiSmsComposerEntryStruct), this);
    vfx_sys_mem_zero(entryData, sizeof(VcuiSmsComposerEntryStruct));
    entryData->msg_id = item->getMsgId();
    entryData->operation = VCUI_SMS_COMPOSER_OPERATION_FORWARD;                
        
    cuiId = vcui_sms_composer_create(getApp()->getGroupId());
    if (cuiId != GRP_ID_INVALID)
    {
        vfxSetCuiCallerScr(cuiId, getMainScr());
        vcui_sms_composer_set_entry_data(cuiId, entryData);
            
        vcui_sms_composer_run(cuiId);
    }
    VFX_FREE_MEM(entryData);
#endif
}

void VappMsgDialogPage::longpressEdit(VappMsgCntxOptItemCp *item)
{
#ifdef __MMI_UNIFIED_COMPOSER__
    VappUcEntryStruct *ucInfo;
    VFX_ALLOC_MEM(ucInfo, sizeof(VappUcEntryStruct), this);
    vfx_sys_mem_zero(ucInfo, sizeof(VappUcEntryStruct));

    VfxBool isNeedConfirm = VFX_FALSE;
    VfxU16 displayString = 0;
    ucInfo->info_type = transferUcType(item->getMsgType());
    ucInfo->msg_id = item->getMsgId();
    ucInfo->type = SRV_UC_STATE_EDIT_EXISTED_MSG;
    ucInfo->operation = UC_OPERATION_EDIT_EXISTED_MSG;
#ifdef __MMI_MMS_IN_UM__
    if (SRV_UM_MSG_MMS == item->getMsgType())
    {
        ucInfo->mode = MMA_MODE_EDIT;
        isNeedConfirm = vapp_mms_is_need_show_edit_cnfm(item->getMsgId(), &displayString);
    }
#endif /* __MMI_MMS_IN_UM__ */
    if (VFX_TRUE == isNeedConfirm)
    {
        // record the data
        VFX_FREE_MEM(m_actionPtr);
        VFX_ALLOC_MEM(m_actionPtr, sizeof(VappUcEntryStruct), this);
        vfx_sys_mem_zero(m_actionPtr, sizeof(VappUcEntryStruct));
        vfx_sys_mem_copy(m_actionPtr, ucInfo, sizeof(VappUcEntryStruct));
        /* display restricted confirm */
        VcpConfirmPopup *confirm;
        VFX_OBJ_CREATE(confirm, VcpConfirmPopup, this);
        confirm->setText(displayString);
        confirm->setInfoType(VCP_POPUP_TYPE_WARNING);
        confirm->setButtonSet(VCP_CONFIRM_BUTTON_SET_YES_NO);
        confirm->setCustomButton(
                    STR_GLOBAL_CONTINUE, 
                    STR_GLOBAL_CANCEL, 
                    VCP_POPUP_BUTTON_TYPE_NORMAL, 
                    VCP_POPUP_BUTTON_TYPE_CANCEL);
        confirm->m_signalButtonClicked.connect(this, &VappMsgDialogPage::onRestrictConfirmClicked);
        confirm->show(VFX_TRUE);
    }
    else
    {
        mmi_id cuiId;
        cuiId = vcui_unifiedcomposer_create(getApp()->getGroupId(), ucInfo);
        if (cuiId != GRP_ID_INVALID)
        {
            vfxSetCuiCallerScr(cuiId, getMainScr());
            vcui_unifiedcomposer_run(cuiId);
        }
    }

    VFX_FREE_MEM(ucInfo);
#endif
#ifdef __MMI_SMS_COMPOSER__  
    mmi_id cuiId;          
    VcuiSmsComposerEntryStruct *entryData;
    VFX_ALLOC_MEM(entryData, sizeof(VcuiSmsComposerEntryStruct), this);
    vfx_sys_mem_zero(entryData, sizeof(VcuiSmsComposerEntryStruct));
    entryData->msg_id = item->getMsgId();
    entryData->operation = VCUI_SMS_COMPOSER_OPERATION_EDIT;                
        
    cuiId = vcui_sms_composer_create(getApp()->getGroupId());
    if (cuiId != GRP_ID_INVALID)
    {
        vfxSetCuiCallerScr(cuiId, getMainScr());
        vcui_sms_composer_set_entry_data(cuiId, entryData);
            
        vcui_sms_composer_run(cuiId);
    }
    VFX_FREE_MEM(entryData);
#endif
}
#ifdef __MMI_SMS_COMPOSER__
void VappMsgDialogPage::onCommandPopClicked(VfxObject *obj, VfxId id)
{
    switch(id)
    {
        case VAPP_MSG_POP_PHB_NUM:
        case VAPP_MSG_POP_PHB_NAME:
        {            
            if (VAPP_MSG_POP_PHB_NUM == id)
            {       
                m_phbCuiStatue = VAPP_MSG_POP_PHB_NUM;
                openPhbCui(MMI_PHB_CONTACT_FIELD_NUMBER);
            }
            else
            {
                m_phbCuiStatue = VAPP_MSG_POP_PHB_NAME;
                openPhbCui(MMI_PHB_CONTACT_FIELD_NAME);
            }  
            break;
        }

        default:
            break;
    }
}

void VappMsgDialogPage::openPhbCui(VfxU32 mode)
{
    m_phbCuiId = vcui_phb_list_create(getApp()->getGroupId());
    if (m_phbCuiId > 0)
    {      
        vcui_phb_list_set_req_field(m_phbCuiId, mode);
        vcui_phb_list_set_req_count(m_phbCuiId, 1);  
        vfxSetCuiCallerScr(m_phbCuiId, getMainScr());
        vcui_phb_list_run(m_phbCuiId);
    }        
}
#endif


#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #ifdef __MMI_MMS_IN_UM__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #endif /* __MMI_MMS_IN_UM__ */
/* under construction !*/
    #ifdef __MMI_PUSH_IN_UM__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #endif /* __MMI_PUSH_IN_UM__ */
/* under construction !*/
    #ifdef __MMI_PROV_IN_UM__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #endif /* __MMI_PROV_IN_UM__ */
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif

VFX_IMPLEMENT_CLASS("VappMsgSettingPage", VappMsgSettingPage, VfxPage);

VappMsgSettingPage::VappMsgSettingPage(VfxBool isRotate):
    m_isRotate(isRotate)
#ifdef __SMS_CLOUD_SUPPORT__
    ,m_backupLoading(NULL)
    ,m_restoreLoading(NULL)
    ,m_smsHandle(SRV_SMS_INVALID_HANDLE)
    ,m_providers(NULL)
    ,m_accounts(NULL)
    ,m_isBackup(VFX_TRUE)
    ,m_ssoCount(0)
    ,m_providerArray(0)
    ,m_isSmsAbort(VFX_FALSE)
#endif /* __SMS_CLOUD_SUPPORT__  */
{
}

void VappMsgSettingPage::onInit()
{
    MMI_PRINT(MOD_MMI_COMMON_APP, TRACE_GROUP_6, "%s", this->getClassInfo()->getClassName());
    MMI_TRACE(TRACE_GROUP_6, TRC_MMI_VAPP_MSG_ON_INIT, this);
    VfxPage::onInit();

    VcpTitleBar *title;
    VFX_OBJ_CREATE(title, VcpTitleBar, this);
    title->setAutoAnimate(VFX_TRUE);
    title->setTitle(STR_ID_VAPP_MSG_SETTING);
    setTopBar(title);

    VcpForm* form;
    VFX_OBJ_CREATE(form, VcpForm, this);
    form->setAutoAnimate(VFX_TRUE);
    form->setSize(getSize());
    form->setAlignParent(
                VFX_FRAME_ALIGNER_MODE_SIDE, 
                VFX_FRAME_ALIGNER_MODE_SIDE, 
                VFX_FRAME_ALIGNER_MODE_SIDE, 
                VFX_FRAME_ALIGNER_MODE_SIDE);

#ifdef __SMS_CLOUD_SUPPORT__
    m_ssoCount = srv_sso_get_provider_count();
#endif /* __SMS_CLOUD_SUPPORT__ */
    
    VfxU32 i;
    VfxWString text;
#ifdef __MMI_UM_TEMPLATE_SUPPORT__     
    for (i = VAPP_MSG_SETTING_TEMPLATE ; i < VAPP_MSG_SETTING_CONVERSATION ; i++)
#else
    for (i = VAPP_MSG_SETTING_MEMORY_STATUS ; i < VAPP_MSG_SETTING_CONVERSATION ; i++)
#endif
    {
        VcpFormItemLauncherCell *cell;
        VFX_OBJ_CREATE(cell, VcpFormItemLauncherCell, this);
        cell->setAutoAnimate(VFX_TRUE);
        getSettingText(i, text);
        cell->setMainText(text);
        cell->setId(i);
        cell->setAccessory(VCPFORM_NEXT_ITEM_ICON);
        cell->m_signalTap.connect(this, &VappMsgSettingPage::onCellTapped);
        form->addItem(cell, i);    
        cell = NULL;
    }
#ifdef __MMI_UM_CONVERSATION_BOX__
#ifdef __MMI_UM_BOX_LIST_SUPPORT__
    VcpFormItemSwitchCell *cs;
    VFX_OBJ_CREATE(cs, VcpFormItemSwitchCell, this);
    cs->setAutoAnimate(VFX_TRUE);
    getSettingText(i, text);
    cs->setMainText(text);
    cs->setId(VAPP_MSG_SETTING_CONVERSATION);
    cs->setIsTappable(VFX_FALSE);
    VfxU8 select;
    VfxS16 error;
    ReadValue(NVRAM_VAPP_MESSAGE_CS_SETTING, &select, DS_BYTE, &error);
    if (0 != select && 1 != select)
    {
        /* Value is wrong, reset as default value */
        select = 1;
        WriteValue(NVRAM_VAPP_MESSAGE_CS_SETTING, &select, DS_BYTE, &error);
    }
    if (1 == select)
    {
        cs->setSwitchStatus(VFX_TRUE);
    }
    else if (0 == select)
    {
        cs->setSwitchStatus(VFX_FALSE);
    }
    else
    {
        VFX_ASSERT(0);
    }
    cs->m_signalSwitchChangeReq.connect(this, &VappMsgSettingPage::onCsSettingChanged);
    form->addItem(cs, VAPP_MSG_SETTING_CONVERSATION);
#endif /* __MMI_UM_BOX_LIST_SUPPORT__ */    
#endif /* __MMI_UM_CONVERSATION_BOX__ */

#ifdef __SMS_CLOUD_SUPPORT__
    // loading
    VFX_OBJ_CREATE(m_backupLoading, VcpIndicatorPopup, this);
    m_backupLoading->setAutoAnimate(VFX_TRUE);
    m_backupLoading->setText(STR_ID_VCUI_SSO_BACKUP_SMS_POP);
    m_backupLoading->setAutoDestory(VFX_FALSE);
    m_backupLoading->m_signalCanceled.connect(this, &VappMsgSettingPage::onBackupRestoreCancelled);
    m_backupLoading->setInfoType(VCP_INDICATOR_POPUP_STYLE_PROGRESS_WITH_CANCEL_BUTTON);
    // loading
    VFX_OBJ_CREATE(m_restoreLoading, VcpIndicatorPopup, this);
    m_restoreLoading->setAutoAnimate(VFX_TRUE);
    m_restoreLoading->setText(STR_ID_VCUI_SSO_RESTORE_SMS_POP);
    m_restoreLoading->setAutoDestory(VFX_FALSE);
    m_restoreLoading->m_signalCanceled.connect(this, &VappMsgSettingPage::onBackupRestoreCancelled);
    m_restoreLoading->setInfoType(VCP_INDICATOR_POPUP_STYLE_PROGRESS_WITH_CANCEL_BUTTON);
#endif /* __SMS_CLOUD_SUPPORT__  */

    mmi_frm_cb_reg_event(EVT_ID_VAPP_MSG_ENTRY, &VappMsgSettingPage::onAppMsgEvt, getObjHandle());

#ifdef __SMS_CLOUD_SUPPORT__
    mmi_frm_cb_reg_event(EVT_ID_SRV_SMS_BACKUP_RESTORE, &VappMsgSettingPage::onSmsBackupRestore, getObjHandle());
    mmi_frm_cb_reg_event(EVT_ID_SRV_SSO_READY, &VappMsgSettingPage::onAppMsgEvt, getObjHandle());
    mmi_frm_cb_reg_event(EVT_ID_SRV_SSO_LOGOUT, &VappMsgSettingPage::onAppMsgEvt, getObjHandle());
#endif /* __SMS_CLOUD_SUPPORT__  */
}

void VappMsgSettingPage::onDeinit()
{
    mmi_frm_cb_dereg_event(EVT_ID_VAPP_MSG_ENTRY, &VappMsgSettingPage::onAppMsgEvt, getObjHandle());

#ifdef __SMS_CLOUD_SUPPORT__

    cancelSmsBackupRestore();

    if (m_providerArray)
        VFX_FREE_MEM(m_providerArray);
    if (m_accounts)
        VFX_FREE_MEM(m_accounts);
    
    mmi_frm_cb_dereg_event(EVT_ID_SRV_SMS_BACKUP_RESTORE, &VappMsgSettingPage::onSmsBackupRestore, getObjHandle());
    mmi_frm_cb_dereg_event(EVT_ID_SRV_SSO_READY, &VappMsgSettingPage::onAppMsgEvt, getObjHandle());
    mmi_frm_cb_dereg_event(EVT_ID_SRV_SSO_LOGOUT, &VappMsgSettingPage::onAppMsgEvt, getObjHandle());
#endif /* __SMS_CLOUD_SUPPORT__  */

    VfxPage::onDeinit();
}

void VappMsgSettingPage::onQueryRotateEx(VfxScreenRotateParam &param)
{
    if (VFX_TRUE != m_isRotate)
    {
        param.rotateTo = VFX_SCR_ROTATE_TYPE_NORMAL;
    }
}

void VappMsgSettingPage::getSettingText(VfxU32 id, VfxWString &text)
{
    switch (id)
    {
    #ifdef __MMI_UM_TEMPLATE_SUPPORT__ 
        case VAPP_MSG_SETTING_TEMPLATE:
            text.loadFromRes(STR_ID_VAPP_MSG_TEMPLATE);
            break;
    #endif
        case VAPP_MSG_SETTING_MEMORY_STATUS:
            text.loadFromRes(STR_GLOBAL_MEMORY_STATUS);
            break;

        case VAPP_MSG_SETTING_SMS:
            text.loadFromRes(STR_GLOBAL_TEXT_MESSAGE);
            break;
            
#ifdef __MMI_MMS_IN_UM__
    #ifdef __MMI_MMS_SETTING_PAGE__
        case VAPP_MSG_SETTING_MMS:
            text.loadFromRes(STR_GLOBAL_MULTIMEDIA_MESSAGE);
            break;
    #endif /* __MMI_MMS_SETTING_PAGE__ */
#endif    

    #ifdef __MMI_PUSH_IN_UM__
        case VAPP_MSG_SETTING_PUSH:
            text.loadFromRes(STR_ID_VAPP_MSG_PUSH_MSG);
            break;
    #endif

        case VAPP_MSG_SETTING_CB:
            text.loadFromRes(STR_ID_VAPP_MSG_CB_MSG);
            break;

	#ifdef __SMS_CLOUD_SUPPORT__
        case VAPP_MSG_SETTING_BACKUP_CLOUD:
            text.loadFromRes(STR_ID_VAPP_MSG_BACKUP_CLOUD);
            break;

        case VAPP_MSG_SETTING_RESTORE_CLOUD:
            text.loadFromRes(STR_ID_VAPP_MSG_RESTORE_CLOUD);
            break;
    #endif /* __SMS_CLOUD_SUPPORT__ */
    
        case VAPP_MSG_SETTING_CONVERSATION:
            text.loadFromRes(STR_ID_VAPP_MSG_CONVERSATION_MODE);
            break;

        default:
            VFX_DEV_ASSERT(0);
            break;
    }
}

void VappMsgSettingPage::onCellTapped(VcpFormItemCell * cell, VfxId id)
{
    // entry corrsponding page
    switch (id)
    {
#ifdef __MMI_UM_TEMPLATE_SUPPORT__     
        case VAPP_MSG_SETTING_TEMPLATE:
            VappMsgTemplatePage *templatePage;
            VFX_OBJ_CREATE(templatePage, VappMsgTemplatePage, getMainScr());
            getMainScr()->pushPage(VappMsgScreen::VAPP_MSG_SCREEN_PAGE_TEMPLATE, templatePage);
            break;
#endif
        case VAPP_MSG_SETTING_MEMORY_STATUS:
            VappMsgMemoryStatusPage *statusPage;
            VFX_OBJ_CREATE(statusPage, VappMsgMemoryStatusPage, getMainScr());
            getMainScr()->pushPage(VappMsgScreen::VAPP_MSG_SCREEN_PAGE_MEMORY_STATUS, statusPage);
            break;

        case VAPP_MSG_SETTING_SMS:
            VappSmsSettingPage *smsSetting;
            VFX_OBJ_CREATE(smsSetting, VappSmsSettingPage, getMainScr());
            getMainScr()->pushPage(VappMsgScreen::VAPP_MSG_SCREEN_PAGE_SMS_SETTING, smsSetting);
            break;

#ifdef __MMI_MMS_IN_UM__ 
    #ifdef __MMI_MMS_SETTING_PAGE__
        case VAPP_MSG_SETTING_MMS:
            VappMMSSettingPage *mmsSetting;
            VFX_OBJ_CREATE(mmsSetting, VappMMSSettingPage, getMainScr());
            getMainScr()->pushPage(VappMsgScreen::VAPP_MSG_SCREEN_PAGE_MMS_SETTING, mmsSetting);
            break;
    #endif /* __MMI_MMS_SETTING_PAGE__ */
#endif /* __MMI_MMS_IN_UM__ */

    #ifdef __MMI_PUSH_IN_UM__
        case VAPP_MSG_SETTING_PUSH:
            VappWapPushSettingPage *pushSetting;
            VFX_OBJ_CREATE(pushSetting, VappWapPushSettingPage, getMainScr());
            getMainScr()->pushPage(VappMsgScreen::VAPP_MSG_SCREEN_PAGE_PUSH_SETTING, pushSetting);
            break;
    #endif /* __MMI_PUSH_IN_UM__ */

        case VAPP_MSG_SETTING_CB:
            VappCbsSettingPage *cbsSetting;
            VFX_OBJ_CREATE(cbsSetting, VappCbsSettingPage, getMainScr());
            getMainScr()->pushPage(VappMsgScreen::VAPP_MSG_SCREEN_PAGE_CB_SETTING, cbsSetting);
            break;

    #ifdef __SMS_CLOUD_SUPPORT__ 
        case VAPP_MSG_SETTING_BACKUP_CLOUD:
            { 
                m_isBackup = VFX_TRUE;
                onBackUpRestoreTapped();
            }
            break;

        case VAPP_MSG_SETTING_RESTORE_CLOUD:
            {   
                m_isBackup = VFX_FALSE;
                onBackUpRestoreTapped();
            }
            break;
    #endif /* __SMS_CLOUD_SUPPORT__ */

        default:
            break;
    }
}

#ifdef __MMI_UM_BOX_LIST_SUPPORT__
void VappMsgSettingPage::onCsSettingChanged(VcpFormItemSwitchCell * cell, VfxId id, VfxBool isOn)
{
    cell->setSwitchStatus(isOn);
    vfxPostInvoke1(this, &VappMsgSettingPage::onSetSwitchStatusDone, isOn); 
}

void VappMsgSettingPage::onSetSwitchStatusDone(VfxBool isOn)
{
    VfxU8 select = 0;
    VfxS16 error;
    if (VFX_TRUE == isOn)
    {
        select = 1;
    }
    
    /* write to NVRAM */
    WriteValue(NVRAM_VAPP_MESSAGE_CS_SETTING, &select, DS_BYTE, &error);
	
    VappMsgScreen *mainScr = NULL;
    mainScr = VFX_OBJ_DYNAMIC_CAST(getMainScr(), VappMsgScreen);
    if (NULL != mainScr)
    {
        mainScr->setMode(isOn);
    }
}
#endif /* __MMI_UM_BOX_LIST_SUPPORT__ */

#ifdef __SMS_CLOUD_SUPPORT__
void VappMsgSettingPage::onBack()
{
    stopLoading();
    
    if (SRV_SMS_INVALID_HANDLE != m_smsHandle)
    {
        srv_sms_abort_cloud(m_smsHandle, NULL, NULL);
        m_isSmsAbort = VFX_TRUE;
        m_smsHandle = SRV_SMS_INVALID_HANDLE;
    }
    else
    {
        VfxPage::onBack();
    }
}

void VappMsgSettingPage::showLoading()
{    
    updateProcessLoading(0.0, 0.0);
    
    if (m_isBackup)
        m_backupLoading->show(VFX_TRUE);
    else
        m_restoreLoading->show(VFX_TRUE);
}

void VappMsgSettingPage::stopLoading()
{
    m_backupLoading->hide(VFX_TRUE); 
    m_restoreLoading->hide(VFX_TRUE);  
}

void VappMsgSettingPage::cancelSmsBackupRestore()
{    
    if (NULL != m_smsHandle)
    {
        srv_sms_abort_cloud(m_smsHandle, NULL, NULL);
        m_isSmsAbort = VFX_TRUE;
        m_smsHandle = SRV_SMS_INVALID_HANDLE;
    }
}

void VappMsgSettingPage::updateProcessLoading(U16 current_value, U16 total_value)
{
    if (m_isBackup)
    {
        m_backupLoading->setProgress((VfxFloat)current_value / total_value);
    }
    else
    {
        m_restoreLoading->setProgress((VfxFloat)current_value / total_value);
    }
}

void VappMsgSettingPage::onBackUpRestoreTapped()
{
    /* NOT_AVAILABLE_IN_MASS_STORAGE_MODE */
    S32 isReady = srv_sso_get_ready();
    if (SRV_SSO_USB_MS_MODE == isReady)
    {
        mmi_frm_nmgr_balloon(MMI_SCENARIO_ID_DEFAULT, MMI_EVENT_INFO_BALLOON, MMI_NMGR_BALLOON_TYPE_INFO, VFX_WSTR_RES(STR_GLOBAL_NOT_AVAILABLE_IN_MASS_STORAGE_MODE));      
	return;
    }
    else if(isReady < 0) /* not available without memory card */
    {
        mmi_frm_nmgr_balloon(MMI_SCENARIO_ID_DEFAULT, MMI_EVENT_INFO_BALLOON, MMI_NMGR_BALLOON_TYPE_INFO, VFX_WSTR_RES(STR_GLOBAL_NOT_AVAILABLE));      
	return;
    }

    if (!srv_mode_switch_is_network_service_available() && srv_dtcnt_wlan_status() == SRV_DTCNT_WLAN_STATUS_INACTIVE)
    {
        mmi_frm_nmgr_balloon(MMI_SCENARIO_ID_DEFAULT, MMI_EVENT_INFO_BALLOON, MMI_NMGR_BALLOON_TYPE_INFO, VFX_WSTR_RES(STR_ID_VAPP_MSG_NO_NETWORK));      
	return;
    }

    if (0 == m_ssoCount)
    {
        m_ssoCount = srv_sso_get_provider_count();
    }

    if (0 == m_ssoCount)
    {
        mmi_frm_nmgr_balloon(MMI_SCENARIO_ID_DEFAULT, MMI_EVENT_INFO_BALLOON, MMI_NMGR_BALLOON_TYPE_INFO, VFX_WSTR_RES(STR_GLOBAL_NOT_AVAILABLE));      
	return;
    }
    
    //get provider
    if (NULL == m_providerArray)
    {
        VFX_ALLOC_MEM(m_providerArray, sizeof(srv_sso_provider_struct) * m_ssoCount, this);
        memset(m_providerArray, 0, sizeof(srv_sso_provider_struct) * m_ssoCount);
    }
    srv_sso_get_providers((srv_sso_provider_struct*)m_providerArray, m_ssoCount);
    if (NULL == m_providerArray)
    {
        VFX_FREE_MEM(m_providerArray);
        mmi_frm_nmgr_balloon(MMI_SCENARIO_ID_DEFAULT, MMI_EVENT_INFO_BALLOON, MMI_NMGR_BALLOON_TYPE_INFO, VFX_WSTR_RES(STR_GLOBAL_NOT_AVAILABLE));      
	return;
    }
    
    WCHAR *buffer = NULL;
    VFX_ALLOC_MEM(buffer, (SRV_SSO_NAME_SIZE + 1)*sizeof(WCHAR), this);
    memset(buffer, 0, (SRV_SSO_NAME_SIZE + 1)*sizeof(WCHAR));
    
    if (m_ssoCount > 1)
    {
        VcpCommandPopup* cmdPopup;
        VFX_OBJ_CREATE(cmdPopup, VcpCommandPopup, this);
        for(VfxId item = 0; item < (VfxId)m_ssoCount; item++)
        {
            srv_sso_get_provider_name(m_providerArray[item].provider, buffer);
            cmdPopup->addItem(item, VFX_WSTR_MEM((VfxWChar *)buffer), VCP_POPUP_BUTTON_TYPE_CANCEL);
        }
        cmdPopup->addItem((VfxId)m_ssoCount, STR_GLOBAL_CANCEL, VCP_POPUP_BUTTON_TYPE_CANCEL);
        cmdPopup->m_signalButtonClicked.connect(this, &VappMsgSettingPage::onCmdPopupClicked);
        cmdPopup->show(VFX_TRUE);
    }
    else
    {
        m_providers = &m_providerArray[0];
        smsBackupRestore();
    }

    VFX_FREE_MEM(buffer);    
}

void VappMsgSettingPage::onCmdPopupClicked(VfxObject * obj, VfxId id)
{
    if (id < (VfxId)m_ssoCount)
    {
        m_providers = &m_providerArray[id];
        smsBackupRestore();
    }
}

void VappMsgSettingPage::smsBackupRestore()
{     
    //login account count
    if (NULL == m_providers)
        MMI_ASSERT(0);
    
    U8 accountCount = srv_sso_get_account_count(m_providers->provider, SRV_SSO_LOGIN_TRUE);

    if (accountCount >= 1)
    {
        //get account
        if(NULL == m_accounts)
        {
            VFX_ALLOC_MEM(m_accounts, sizeof(srv_sso_account_struct), this);
            memset(m_accounts, 0, sizeof(srv_sso_account_struct));
        }
        srv_sso_get_accounts(m_providers->provider, SRV_SSO_LOGIN_TRUE, m_accounts, accountCount);           
        
        srv_sms_backup_restore_info_struct* info_struct;
        VFX_ALLOC_MEM(info_struct, sizeof(srv_sms_backup_restore_info_struct), this);
        memset(info_struct, 0, sizeof(srv_sms_backup_restore_info_struct));
        srv_cloud_set_opt_acct_info_struct* account_info;
        VFX_ALLOC_MEM(account_info, sizeof(srv_cloud_set_opt_acct_info_struct), this);
        memset(account_info, 0, sizeof(srv_cloud_set_opt_acct_info_struct));
        info_struct->backup_restore_type = SRV_SMS_BACKUP_RESTORE_CLOUD;
        account_info->provider = m_providers->provider;
        account_info->account_id = m_accounts[0].account;
        info_struct->account_info = account_info;
        
        if (m_isBackup)
        {
            showLoading();
            m_smsHandle = srv_sms_backup_msg(*info_struct, &VappMsgSettingPage::onSmsBackupCallback, getObjHandle());
        }
        else
        {
            showLoading();
            m_smsHandle = srv_sms_restore_msg(*info_struct, &VappMsgSettingPage::onSmsBackupCallback, getObjHandle());
        }
        
        VFX_FREE_MEM(info_struct);   
        VFX_FREE_MEM(account_info);            
    }
    else
    {
        accountCount = srv_sso_get_account_count(m_providers->provider, SRV_SSO_LOGIN_DONT_CARE);
        
        MMI_ID cui_id = 0;
        if (accountCount > 0)
        {
            //get account

            if (NULL == m_accounts)
            {
                VFX_ALLOC_MEM(m_accounts, sizeof(srv_sso_account_struct), this);
                memset(m_accounts, 0, sizeof(srv_sso_account_struct));
            }
            srv_sso_get_accounts(m_providers->provider, SRV_SSO_LOGIN_DONT_CARE, m_accounts, accountCount);
            cui_id = vcui_sso_login_create(getMainScr()->getGroupId(), m_providers->provider, m_accounts[0].account);
            mmi_frm_group_set_caller_proc(cui_id, &VappMsgSettingPage::handleCuiProc, getObjHandle());
        }
        else
        {
            //use default account create login cui
            cui_id = vcui_sso_login_create(getMainScr()->getGroupId(), m_providers[0].provider, SRV_SSO_INVALID_ACC_ID);
            mmi_frm_group_set_caller_proc(cui_id, &VappMsgSettingPage::handleCuiProc, getObjHandle());
        }
        vcui_sso_login_run(cui_id);
    }
}

void VappMsgSettingPage::onBackupRestoreCancelled(VfxObject *obj, VfxFloat progress)
{    
    stopLoading();
    cancelSmsBackupRestore();
}

void VappMsgSettingPage::onSmsBackupCallback(srv_sms_callback_struct* callback_data)
{
    VappMsgSettingPage *self = (VappMsgSettingPage *)VfxObject::handleToObject((VfxObjHandle)callback_data->user_data);
    if(self)
    {
        self->m_smsHandle = SRV_SMS_INVALID_HANDLE; 
    	if (self->m_isSmsAbort)
    	{
    	    self->m_isSmsAbort = VFX_FALSE; 
    	    return;
    	}
        
        if (callback_data->result)
        {
            self->updateProcessLoading(1.0, 1.0);
            self->stopLoading(); 
        }
        else
        {
            self->stopLoading(); 
            
            VcpConfirmPopup *result;
            VFX_OBJ_CREATE(result, VcpConfirmPopup, self);
            result->setButtonSet(VCP_CONFIRM_BUTTON_SET_OK);
            result->setInfoType(VCP_POPUP_TYPE_FAILURE);
            
            if (SRV_SMS_CAUSE_CLOUD_NWK_ERROR == callback_data->cause)
            {
                result->setText(STR_ID_VAPP_MSG_NO_NETWORK);
            }
            else if (SRV_SMS_CAUSE_CLOUD_NO_NEED_SYNC == callback_data->cause)
            {
                if (self->m_isBackup)
                {
                    result->setText(STR_ID_VAPP_MSG_NO_MESSAGE_TO_BACKUP);
                }
                else
                {
                    result->setText(STR_ID_VAPP_MSG_NO_MESSAGE_TO_RESTORE);
                }
            }
            else if (SRV_SMS_CAUSE_CLOUD_NO_STORAGE == callback_data->cause || SRV_SMS_CAUSE_MEM_FULL == callback_data->cause)
            {
                result->setText(STR_ID_VCUI_SSO_SMS_INSUFFICIENT_STORAGE);
            }
            else
            {
                if (self->m_isBackup)
                {
                    result->setText(STR_ID_VAPP_MSG_BACKUP_FAIL);
                }
                else
                {
                    result->setText(STR_ID_VAPP_MSG_RESTORE_FAIL);
                }
            }
            
            result->show(VFX_FALSE);
            result->setAutoDestory(VFX_TRUE);
        }
    }
}

mmi_ret VappMsgSettingPage::onSmsBackupRestore(mmi_event_struct *param)
{
    VappMsgSettingPage *self = (VappMsgSettingPage *)VfxObject::handleToObject((VfxObjHandle)param->user_data);
    if (self)
    {
        if (self->isKindOf(VFX_OBJ_CLASS_INFO(VappMsgSettingPage)))
        {
            switch (param->evt_id)
            {
                case EVT_ID_SRV_SMS_BACKUP_RESTORE:
                {
                    srv_sms_event_backup_restore_struct* evt = (srv_sms_event_backup_restore_struct*)param;
            	    MMI_PRINT(MOD_MMI_COMMON_APP, TRACE_GROUP_6, "onSmsBackupRestore cur_index = %d, total_number = %d", evt->cur_index, evt->Total_number);
                    self->updateProcessLoading(evt->cur_index, evt->Total_number);
                }
                    break;

                default:
                    break;
            }
        }
    }
    
    return MMI_RET_OK;
}

mmi_ret VappMsgSettingPage::handleCuiProc(mmi_event_struct *param)
{    
    VappMsgSettingPage *self = (VappMsgSettingPage *)VfxObject::handleToObject((VfxObjHandle)param->user_data);
    if (self)
    {
        if (self->isKindOf(VFX_OBJ_CLASS_INFO(VappMsgSettingPage)))
        {
            switch (param->evt_id)
            {
                case EVT_ID_VCUI_SSO_LOGIN_RESULT:
                {
                    vcui_sso_login_result_event_struct *cloud_evt = (vcui_sso_login_result_event_struct*)param;
                                        
                    if (VCUI_SSO_LOGIN_SUCCESS ==  cloud_evt->result|| VCUI_SSO_LOGIN_ADD_SUCCESS == cloud_evt->result)
                    {
                        vcui_sso_login_close(cloud_evt->sender_id); 

                        self->smsBackupRestore();
                    }
                    else if (VCUI_SSO_LOGIN_CANCEL == cloud_evt->result)
                    {
                        vcui_sso_login_close(cloud_evt->sender_id); 
                    }
                    break;
                }
            }
        }
    }
   
    return MMI_RET_OK;
}
#endif /* __SMS_CLOUD_SUPPORT__ */

mmi_ret VappMsgSettingPage::onAppMsgEvt(mmi_event_struct * param)
{
    VappMsgSettingPage *self = (VappMsgSettingPage *)VfxObject::handleToObject((VfxObjHandle)param->user_data);

    if (self)
    {
        if (self->isKindOf(VFX_OBJ_CLASS_INFO(VappMsgSettingPage)))
        {
            switch (param->evt_id)
            {
                case EVT_ID_VAPP_MSG_ENTRY:
                {
                    VfxApp *app = NULL;
                    app = self->getApp();
                    if (VAPP_MSG > app->getGroupId() || mmi_res_get_app_max(VAPP_MSG) < app->getGroupId())
                    {
                        /* message setting is existed in the setting app, close it */
                        app->exit();
                    }
                }
                    break;

            #ifdef __SMS_CLOUD_SUPPORT__
                case EVT_ID_SRV_SSO_READY:
                {
                    S32 isReady = srv_sso_get_ready();                    
                    MMI_PRINT(MOD_MMI_COMMON_APP, TRACE_GROUP_6, "%s, %d", "lifang: srv_sso_get_ready", isReady);
     
                    if (SRV_SSO_OK != isReady)
                    {
                        self->stopLoading();
                        self->cancelSmsBackupRestore();
                    }
                }                    
                    break;
                    
                case EVT_ID_SRV_SSO_LOGOUT:
                {
                    self->stopLoading();
                    self->cancelSmsBackupRestore();
                }
                    break;
            #endif /* __SMS_CLOUD_SUPPORT__ */
                    
                default:
                    break;
            }
        }
    }

    return MMI_RET_OK;
}

#ifdef __MMI_UM_TEMPLATE_SUPPORT__
VFX_IMPLEMENT_CLASS("VappMsgTemplatePage", VappMsgTemplatePage, VcpTabCtrlPage);

VappMsgTemplatePage::VappMsgTemplatePage()
{
}

void VappMsgTemplatePage::onInit()
{
    MMI_PRINT(MOD_MMI_COMMON_APP, TRACE_GROUP_6, "%s", this->getClassInfo()->getClassName());
    MMI_TRACE(TRACE_GROUP_6, TRC_MMI_VAPP_MSG_ON_INIT, this);
    VcpTabCtrlPage::onInit();

    addTab(VAPP_MSG_TEMPLATE_SMS, STR_GLOBAL_TEXT_MESSAGE, VcpStateImage(IMG_ID_VAPP_MSG_TAB_SMS));
    addTab(VAPP_MSG_TEMPLATE_MMS, STR_GLOBAL_MULTIMEDIA_MESSAGE, VcpStateImage(IMG_ID_VAPP_MSG_TAB_MMS));
    setCurrTab(VAPP_MSG_TEMPLATE_SMS);
}

VfxPage* VappMsgTemplatePage::onCreateTabPage(VfxId tabId)
{
    switch (tabId)
    {
        case VAPP_MSG_TEMPLATE_SMS:
            VappTextTemplatePage *smsTemplate;
            VFX_OBJ_CREATE(smsTemplate, VappTextTemplatePage, this);
            return smsTemplate;
            break;

    #ifdef __MMI_MMS_IN_UM__
        case VAPP_MSG_TEMPLATE_MMS:
            VappMsgFolderPage *page;
            VFX_OBJ_CREATE_EX(page, 
                              VappMsgFolderPage, 
                              this, 
                              (SRV_UM_MSG_MMS, 
                               SRV_UM_MSG_BOX_PREDEF_TEMPLATES|SRV_UM_MSG_BOX_USRDEF_TEMPLATES, 
                               SRV_UM_SIM_ALL, 
                               VAPP_MSG_FOLDER_TYPE_NORMAL, 
                               VAPP_MSG_FOLDER_MODE_NORMAL, 
                               VFX_FALSE));
            return page;
            break;
    #endif /* __MMI_MMS_IN_UM__ */

        default:
            VFX_DEV_ASSERT(0);
            break;
    }
    return NULL;
}

void VappMsgTemplatePage::onQueryRotateEx(VfxScreenRotateParam &param)
{
    // do Nothing
}
#endif /* __MMI_UM_TEMPLATE_SUPPORT__ */

VFX_IMPLEMENT_CLASS("VappMsgMemoryStatusPage", VappMsgMemoryStatusPage, VfxPage);

VappMsgMemoryStatusPage::VappMsgMemoryStatusPage():
    m_listMenu(NULL)
{
}

VfxBool VappMsgMemoryStatusPage::getItemText(VcpMenuPos pos, VcpListMenuFieldEnum fieldType, VfxWString & text, VcpListMenuTextColorEnum & color)
{
    VfxBool result = VFX_FALSE;
    switch (pos.group)
    {
        case VAPP_MSG_MEM_STATUS_SMS:
            fillSmsStatusData(pos.pos, fieldType, text, color);
            result = VFX_TRUE;
            break;

    #ifdef __MMI_MMS_IN_UM__
        case VAPP_MSG_MEM_STATUS_MMS:
            fillMmsStatusData(pos.pos, fieldType, text, color);
            result = VFX_TRUE;
            break;
    #endif /* __MMI_MMS_IN_UM__ */

        default:
            break;
    }

    return result;
}

VfxBool VappMsgMemoryStatusPage::getItemIsDisabled(VcpMenuPos pos) const
{
    return VFX_FALSE;
}

VfxU32 VappMsgMemoryStatusPage::getCount(VfxU32 group) const
{
    VfxU32 count = 0;
    switch (group)
    {
        case VAPP_MSG_MEM_STATUS_SMS:
        {
        #ifdef __MMI_SMS_TCARD_STORAGE_SUPPORT__
            count = 2 + srv_sim_ctrl_get_num_of_inserted();
        #else       
            count = 1 + srv_sim_ctrl_get_num_of_inserted();
        #endif
        }
            break;

    #ifdef __MMI_MMS_IN_UM__
        case VAPP_MSG_MEM_STATUS_MMS:
            count = VAPP_MSG_MEM_STATUS_MMS_TOTAL;
            break;
    #endif

        default:
            break;
    }
    return count;
}

VfxU32 VappMsgMemoryStatusPage::getGroupCount() const
{
    return VAPP_MSG_MEM_STATUS_TOTAL;
}

void VappMsgMemoryStatusPage::onInit()
{
    MMI_PRINT(MOD_MMI_COMMON_APP, TRACE_GROUP_6, "%s", this->getClassInfo()->getClassName());
    MMI_TRACE(TRACE_GROUP_6, TRC_MMI_VAPP_MSG_ON_INIT, this);
    VfxPage::onInit();

    VcpTitleBar *title;
    VFX_OBJ_CREATE(title, VcpTitleBar, this);
    title->setAutoAnimate(VFX_TRUE);
    title->setTitle(STR_GLOBAL_MEMORY_STATUS);
    setTopBar(title);

    VFX_OBJ_CREATE(m_listMenu, VcpGroupListMenu, this);
    m_listMenu->setItemHighlightHidden(VFX_TRUE);
    m_listMenu->setAutoAnimate(VFX_TRUE);
    m_listMenu->setContentProvider(this);
    m_listMenu->setCellStyle(VCP_LIST_MENU_CELL_STYLE_MULTI_TEXT);
    m_listMenu->setSize(getSize());
    m_listMenu->setAlignParent(
                    VFX_FRAME_ALIGNER_MODE_SIDE, 
                    VFX_FRAME_ALIGNER_MODE_SIDE, 
                    VFX_FRAME_ALIGNER_MODE_SIDE, 
                    VFX_FRAME_ALIGNER_MODE_SIDE);

    mmi_frm_cb_reg_event(EVT_ID_SRV_UM_NOTIFY_REFRESH, &VappMsgMemoryStatusPage::onMsgSrvEvtCb, getObjHandle());
}

void VappMsgMemoryStatusPage::onDeinit()
{
    mmi_frm_cb_dereg_event(EVT_ID_SRV_UM_NOTIFY_REFRESH, &VappMsgMemoryStatusPage::onMsgSrvEvtCb, getObjHandle());

    VfxPage::onDeinit();
}

void VappMsgMemoryStatusPage::onQueryRotateEx(VfxScreenRotateParam &param)
{
    // do Nothing
}

void VappMsgMemoryStatusPage::fillSmsStatusData(
                                        VfxS32 idx, 
                                        VcpListMenuFieldEnum fieldType, 
                                        VfxWString & text, 
                                        VcpListMenuTextColorEnum & color)
{
    if (VCP_LIST_MENU_FIELD_GROUP_HEADER_TEXT == fieldType)
    {
        text.loadFromRes(STR_GLOBAL_TEXT_MESSAGE);
        return;
    }

    srv_sms_memory_status_struct status;
    MMI_BOOL ready = MMI_FALSE;

    vfx_sys_mem_zero(&status, sizeof(srv_sms_memory_status_struct));
    if (idx < srv_sim_ctrl_get_num_of_inserted())
    {
        /* sim info */
        VfxU32 i = 0;
        VfxU32 insertIdx = 0;
        mmi_sim_enum sim = MMI_SIM1;
        for (i = 0 ; i < MMI_MAX_SIM_NUM ; i++, sim = (mmi_sim_enum)(sim << 1))
        {
            if (MMI_TRUE == srv_sim_ctrl_is_inserted(sim))
            {
                if (insertIdx == idx)
                {
                    /* hit the sim card with index */
                    break;
                }
                insertIdx++;
            }
        }

        if (1 == srv_sim_ctrl_get_num_of_inserted())
        {
            fillSmsSingleSimData(fieldType, VFX_WSTR_RES(STR_GLOBAL_SIM), SRV_SMS_MMI_SIM_TO_SMS(sim), text);
        }
        else
        {
            fillSmsSingleSimData(fieldType, vapp_sim_settings_get_sim_name_with_sim_id(sim), SRV_SMS_MMI_SIM_TO_SMS(sim), text);
        }
    }
    else 
    {
	idx += MMI_MAX_SIM_NUM - srv_sim_ctrl_get_num_of_inserted();
        if (VAPP_MSG_MEM_STATUS_SMS_PHONE == idx)
        {
            /* phone info */
            if (VCP_LIST_MENU_FIELD_TEXT == fieldType)
            {
                text.loadFromRes(STR_GLOBAL_PHONE);
            }
            else if (VCP_LIST_MENU_FIELD_SUB_TEXT1 == fieldType)
            {
                /* because sim1/sim2 phone memory is shared, no need to count twice */
                VfxU32 count_used = 0;
                VfxU32 count_total = 0;
                ready = srv_sms_get_memory_status(SRV_SMS_SIM_1, &status);
                count_used += status.me_used;
                count_total += status.me_total;
                if (MMI_TRUE == ready)
                {
                    text = VfxWString().format("%d/%d", count_used, count_total);
                }
                else
                {
                    text = VfxWString().format("%d/%d", 0, 0);
                }
            }
        }
    #ifdef __MMI_SMS_TCARD_STORAGE_SUPPORT__
        else if (VAPP_MSG_MEM_STATUS_SMS_MEMORY_CARD == idx)
        {
            if (VCP_LIST_MENU_FIELD_TEXT == fieldType)
            {
                text.loadFromRes(STR_GLOBAL_MEMORY_CARD);
            }
            else if (VCP_LIST_MENU_FIELD_SUB_TEXT1 == fieldType)
            {
                /* because sim1/sim2 phone memory is shared, no need to count twice */
                VfxU32 count_used = 0;
                VfxU32 count_total = 0;
                ready = srv_sms_get_memory_status(SRV_SMS_SIM_1, &status);
                count_used += status.tcard_used;
                count_total += status.tcard_total;
                if (MMI_TRUE == ready)
                {
                    text = VfxWString().format("%d/%d", count_used, count_total);
                }
                else
                {
                    text = VfxWString().format("%d/%d", 0, 0);
                }
            }
        }
    #endif /* __MMI_SMS_TCARD_STORAGE_SUPPORT__ */
    }
}

void VappMsgMemoryStatusPage::fillSmsSingleSimData(VcpListMenuFieldEnum fieldType, VfxWString simStr, srv_sms_sim_enum smsSimId, VfxWString &outputText)
{
    MMI_BOOL ready = MMI_FALSE;
    srv_sms_memory_status_struct status;

    vfx_sys_mem_zero(&status, sizeof(srv_sms_memory_status_struct));
    if (VCP_LIST_MENU_FIELD_TEXT == fieldType)
    {
        outputText = simStr;
    }
    else if (VCP_LIST_MENU_FIELD_SUB_TEXT1 == fieldType)
    {
        ready = srv_sms_get_memory_status(smsSimId, &status);
        if (MMI_TRUE == ready)
        {
            outputText = VfxWString().format("%d/%d", status.sim_used, status.sim_total);
        }
    }
}

#ifdef __MMI_MMS_IN_UM__
void VappMsgMemoryStatusPage::fillMmsStatusData(
                                        VfxS32 idx, 
                                        VcpListMenuFieldEnum fieldType, 
                                        VfxWString & text, 
                                        VcpListMenuTextColorEnum & color)
{
    if (VCP_LIST_MENU_FIELD_GROUP_HEADER_TEXT == fieldType)
    {
        text.loadFromRes(STR_GLOBAL_MULTIMEDIA_MESSAGE);
        return;
    }

    switch (idx)
    {
    #ifndef __COSMOS_NO_USER_DRIVE__
        case VAPP_MSG_MEM_STATUS_MMS_PHONE:
            if (VCP_LIST_MENU_FIELD_TEXT == fieldType)
            {
                text.loadFromRes(STR_GLOBAL_PHONE);
            }
            else if (VCP_LIST_MENU_FIELD_SUB_TEXT1 == fieldType)
            {
                VfxS32 result;
                srv_mms_get_msg_count_struct msg_count_req;

                vfx_sys_mem_zero(&msg_count_req, sizeof(srv_mms_get_msg_count_struct));

                msg_count_req.count = 1;
                msg_count_req.req_tb[0] = SRV_MMS_QUERY_TOTAL_PHONE_MSG;

                result = srv_mms_get_msg_count(&msg_count_req);
                VfxU32 numPhone = 0;
                VfxU32 totalPhone = 0;
                if (SRV_MMS_RESULT_OK == result)
                {
                    numPhone = msg_count_req.rsp_tb[0];
                }
                totalPhone = srv_mms_get_max_mms_num_on_phone();
                text = VfxWString().format("%d/%d", numPhone, totalPhone); 
                fillFreeMemoryData(text, VFX_TRUE);
            }
            break;
    #endif /* __COSMOS_NO_USER_DRIVE__ */

        case VAPP_MSG_MEM_STATUS_MMS_MEM_CARD:
            if (VCP_LIST_MENU_FIELD_TEXT == fieldType)
            {
                text.loadFromRes(STR_GLOBAL_MEMORY_CARD);
            }
            else if (VCP_LIST_MENU_FIELD_SUB_TEXT1 == fieldType)
            {
                VfxS32 result;
                srv_mms_get_msg_count_struct msg_count_req;

                vfx_sys_mem_zero(&msg_count_req, sizeof(srv_mms_get_msg_count_struct));

                msg_count_req.count = 1;
                msg_count_req.req_tb[0] = SRV_MMS_QUERY_TOTAL_CARD_MSG;

                result = srv_mms_get_msg_count(&msg_count_req);
                VfxU32 numCard = 0;
                VfxU32 totalCard = 0;
                if (SRV_MMS_RESULT_OK == result)
                {
                    numCard = msg_count_req.rsp_tb[0];
                }
                totalCard = srv_mms_get_max_mms_num_on_card();
                text = VfxWString().format("%d/%d", numCard, totalCard); 
                fillFreeMemoryData(text, VFX_FALSE);
            }
            break;

        default:
            break;
    }
}
#endif /* __MMI_MMS_IN_UM__ */

void VappMsgMemoryStatusPage::fillFreeMemoryData(VfxWString &text, VfxBool isPhone)
{                
    VfxU8 drvLetter;    
    if (isPhone)
        drvLetter = srv_fmgr_drv_get_letter_by_type(SRV_FMGR_DRV_PHONE_TYPE);
    else
        drvLetter = srv_fmgr_drv_get_letter_by_type(SRV_FMGR_DRV_CARD_TYPE);    
    VfxU64 totalSize = 0;
    VfxU64 unusedSize = 0;
    srv_fmgr_drv_get_size(drvLetter, &totalSize, &unusedSize);
    VfxU32 i;
    VfxDoube doubleSize;
    doubleSize = (VfxDoube)unusedSize;
    const VfxChar unitChar[] = {"BKMGT"};
    for (i = 0 ; i < 5 ; i++)
    {
        if (doubleSize < SIZE_RANGE)
        {
            break;
        }
        doubleSize /= SIZE_RANGE;
    }
    text += VfxWString().format(" %.2f ", doubleSize);
    text += VfxWString().format("%c", unitChar[i]);
    if (i > 0)
    {
        text += VFX_WSTR("B");
    }
}

mmi_ret VappMsgMemoryStatusPage::onMsgSrvEvtCb(mmi_event_struct * param)
{
    VappMsgMemoryStatusPage *self = (VappMsgMemoryStatusPage *)VfxObject::handleToObject((VfxObjHandle)param->user_data);

    if (self)
    {
        MMI_PRINT(MOD_MMI_COMMON_APP, TRACE_GROUP_6, "%s", self->getClassInfo()->getClassName());
        MMI_TRACE(TRACE_GROUP_6, TRC_MMI_VAPP_MSG_UM_SRV_EVT, param->evt_id, self);
        if (self->isKindOf(VFX_OBJ_CLASS_INFO(VappMsgMemoryStatusPage)))
        {
            switch (param->evt_id)
            {
                case EVT_ID_SRV_UM_NOTIFY_REFRESH:
                    self->m_listMenu->updateAllItems();
                    break;

                default:
                    break;
            }
        }
    }

    return MMI_RET_OK;
}


/*********************************************************/
/* dummy for UMGProt.h ***********************************/
/*********************************************************/
/* Pluto MMI headers: */
#ifdef __cplusplus
extern "C"
#endif
{

kal_uint8 mmi_um_check_new_msg(void)
{ return 0; }
void mmi_um_entry_main_message_menu(void)
{}
void mmi_um_entry_main_message_menu_with_check(void)
{}
void mmi_um_main_message_menu_update_by_app(void *user_data, U16 menu_item_id, U8 *update_string)
{}
#ifdef __UNIFIED_MESSAGE_SIMBOX_SUPPORT__
void mmi_um_pre_entry_simbox(void)
{}
#endif /* __UNIFIED_MESSAGE_SIMBOX_SUPPORT__ */
void mmi_um_nmgr_query_data(struct mmi_nmgr_answer_struct_s *answer)
{}
void mmi_um_nmgr_new_msg_cancel(srv_um_msg_enum msg_type)
{}
void mmi_um_nmgr_lsk_handler(void *data)
{}
void mmi_um_new_msg_notify_cancel_sms(void)
{}
void mmi_um_new_msg_notify_cancel_mms(void)
{}
#ifdef __MMI_UM_REPORT_BOX__
void mmi_um_nmgr_query_report_message(struct mmi_nmgr_answer_struct_s *answer)
{}
void mmi_um_nmgr_report_lsk_handler(void *data)
{}
#endif /* __MMI_UM_REPORT_BOX__ */
srv_um_msg_box_enum mmi_um_get_current_msg_box_type(void)
{ return SRV_UM_MSG_BOX_NONE; }
void mmi_um_hide_main_message_all_folder_menu_id(void)
{}
void mmi_um_unhide_main_message_all_folder_menu_id(void)
{}
kal_uint16 mmi_um_get_not_available_string_id(void)
{ return 0;}
kal_bool mmi_um_is_available(void)
{ return KAL_FALSE; }
void mmi_um_init(void)
{}
void mmi_um_highlight_msg_ind(srv_um_msg_enum msg_type, srv_um_msg_box_enum msg_box_type, kal_uint32 msg_id)
{}
void mmi_um_entry_write_msg(void)
{}
void mmi_um_entry_write_msg_ext(void)
{}
#ifdef __MMI_UM_CONVERSATION_BOX__
void mmi_um_entry_conversation(void)
{}
#endif /* __MMI_UM_CONVERSATION_BOX__ */
void mmi_um_entry_inbox(void)
{}
void mmi_um_entry_draft(void)
{}
void mmi_um_entry_outbox(void)
{}
void mmi_um_entry_sent(void)
{}
#ifdef __UNIFIED_MESSAGE_ARCHIVE_SUPPORT__
void mmi_um_entry_archive(void)
{}
#endif /* __UNIFIED_MESSAGE_ARCHIVE_SUPPORT__ */
#ifdef __UNIFIED_MESSAGE_SIMBOX_SUPPORT__
void mmi_um_entry_simbox(void)
{}
#endif /* __UNIFIED_MESSAGE_SIMBOX_SUPPORT__ */
#ifdef __MMI_UM_REPORT_BOX__
void mmi_um_entry_report(void)
{}
#endif /* __MMI_UM_REPORT_BOX__ */
void mmi_um_entry_delete_folder(void)
{}
#ifdef __MMI_UM_TEMPLATE_SUPPORT__
void mmi_um_entry_template(void)
{}
#endif /* __MMI_UM_TEMPLATE_SUPPORT__ */
void mmi_um_entry_setting(void)
{}

#ifdef __UNIFIED_MESSAGE_MARK_SEVERAL_SUPPORT__
void mmi_um_entry_ms_inbox(void)
{}
void mmi_um_entry_ms_draft(void)
{}
void mmi_um_entry_ms_outbox(void)
{}
void mmi_um_entry_ms_sent(void)
{}
#ifdef __UNIFIED_MESSAGE_ARCHIVE_SUPPORT__
void mmi_um_entry_ms_archive(void)
{}
#endif /* __UNIFIED_MESSAGE_ARCHIVE_SUPPORT__ */
#ifdef __UNIFIED_MESSAGE_SIMBOX_SUPPORT__
void mmi_um_entry_ms_simbox(void)
{}
#endif /* __UNIFIED_MESSAGE_SIMBOX_SUPPORT__ */
#endif /* __UNIFIED_MESSAGE_MARK_SEVERAL_SUPPORT__ */
void mmi_um_pre_entry_inbox(void)
{}
#if defined(__MMI_OP12_TOOLBAR__)
void mmi_um_pre_entry_sms_inbox(void)
{}
void mmi_um_pre_entry_mms_inbox(void)
{}
#endif /*__MMI_OP12_TOOLBAR__*/
void mmi_um_launch_inbox_with_sms_only(void)
{}
void mmi_um_launch_inbox_with_mms_only(void)
{}
#ifdef __UNIFIED_MESSAGE_SORT_MESSAGE_LIST__
void mmi_um_set_message_list_sort_type(kal_uint16 index)
{}
kal_uint16 mmi_um_prepare_sort_selection_list(kal_uint16 *menu_item_str_id, kal_uint16 max_menu_item)
{ return 0;}
#endif /* __UNIFIED_MESSAGE_SORT_MESSAGE_LIST__ */
#ifdef __MMI_DUAL_SIM_MASTER__
void mmi_um_set_message_list_filter_type(U16 index)
{}
U16 mmi_um_prepare_filter_selection_list(U16 *menu_item_str_id, U16 max_menu_item)
{ return 0;}
srv_um_sim_enum mmi_um_get_message_list_filter_type(void *user_data)
{ return SRV_UM_SIM_UNCLASSIFIED;}
#endif /* __MMI_DUAL_SIM_MASTER__ */
#ifdef __MMI_UM_ITERATOR_VIEWER__
struct mmi_um_iter_viewer_info_struct;
struct mmi_um_iter_viewer_result_struct;
MMI_BOOL mmi_um_query_indexing(mmi_um_iter_viewer_info_struct *info, 
                                      mmi_um_iter_viewer_result_struct *result, 
                                      void *user_data)
{ return MMI_FALSE; }
#endif /* __MMI_UM_ITERATOR_VIEWER__ */
#ifdef __MMI_UM_CONVERSATION_BOX__
MMI_BOOL mmi_um_check_conversation_box_setting(void)
{ return MMI_FALSE; }
#endif /* __MMI_UM_CONVERSATION_BOX__ */

void mmi_um_highlight_write_msg(void)
{}
void mmi_um_highlight_conversation(void)
{}
void mmi_um_highlight_inbox(void)
{}
void mmi_um_highlight_draft(void)
{}
void mmi_um_highlight_unsent(void)
{}
void mmi_um_highlight_sent(void)
{}
void mmi_um_highlight_delete_folder(void)
{}
void mmi_um_highlight_template(void)
{}
void mmi_um_highlight_setting(void)
{}
mmi_ret mmi_um_ui_adp_receive_event(mmi_event_struct *evt)
{ return MMI_RET_OK; }
mmi_ret mmi_um_ui_cc_sim_ctrl_unavailable_hdlr(mmi_event_struct *evt)
{ return MMI_RET_OK; }
mmi_ret mmi_um_ui_cc_sim_ctrl_available_hdlr(mmi_event_struct *evt)
{ return MMI_RET_OK; }
mmi_ret mmi_um_ui_cc_sim_status_hdlr(mmi_event_struct *evt)
{ return MMI_RET_OK; }
}
/*********************************************************/
/* dummy for UMGProt.h ***********************************/
/*********************************************************/
